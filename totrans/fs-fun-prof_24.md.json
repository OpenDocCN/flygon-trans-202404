["```\nlet A_Parser str =\n    if String.IsNullOrEmpty(str) then\n        (false,\"\")\n    else if str.[0] = 'A' then\n        let remaining = str.[1..]\n        (true,remaining)\n    else\n        (false,str) \n```", "```\nval A_Parser :\n    string -> (bool * string) \n```", "```\nlet inputABC = \"ABC\"\nA_Parser inputABC \n```", "```\n(true, \"BC\") \n```", "```\nlet inputZBC = \"ZBC\"\nA_Parser inputZBC \n```", "```\n(false, \"ZBC\") \n```", "```\nlet pchar (charToMatch,str) =\n    if String.IsNullOrEmpty(str) then\n        let msg = \"No more input\"\n        (msg,\"\")\n    else \n        let first = str.[0] \n        if first = charToMatch then\n            let remaining = str.[1..]\n            let msg = sprintf \"Found %c\" charToMatch\n            (msg,remaining)\n        else\n            let msg = sprintf \"Expecting '%c'. Got '%c'\" charToMatch first\n            (msg,str) \n```", "```\nval pchar :\n    (char * string) -> (string * string) \n```", "```\nlet inputABC = \"ABC\"\npchar('A',inputABC) \n```", "```\n(\"Found A\", \"BC\") \n```", "```\nlet inputZBC = \"ZBC\"\npchar('A',inputZBC) \n```", "```\n(\"Expecting 'A'. Got 'Z'\", \"ZBC\") \n```", "```\npchar('Z',inputZBC)  // (\"Found Z\", \"BC\") \n```", "```\ntype Result<'a> =\n    | Success of 'a\n    | Failure of string \n```", "```\nlet pchar (charToMatch,str) =\n    if String.IsNullOrEmpty(str) then\n        Failure \"No more input\"\n    else\n        let first = str.[0] \n        if first = charToMatch then\n            let remaining = str.[1..]\n            Success (charToMatch,remaining)\n        else\n            let msg = sprintf \"Expecting '%c'. Got '%c'\" charToMatch first\n            Failure msg \n```", "```\nval pchar :\n    (char * string) -> Result<char * string> \n```", "```\nlet inputABC = \"ABC\"\npchar('A',inputABC) \n```", "```\nSuccess ('A', \"BC\") \n```", "```\nlet inputZBC = \"ZBC\"\npchar('A',inputZBC) \n```", "```\nFailure \"Expecting 'A'. Got 'Z'\" \n```", "```\nlet pchar charToMatch str = \n    if String.IsNullOrEmpty(str) then\n        Failure \"No more input\"\n    else\n        let first = str.[0] \n        if first = charToMatch then\n            let remaining = str.[1..]\n            Success (charToMatch,remaining)\n        else\n            let msg = sprintf \"Expecting '%c'. Got '%c'\" charToMatch first\n            Failure msg \n```", "```\nlet pchar (charToMatch,str) =\n    ... \n```", "```\nlet pchar charToMatch str = \n    ... \n```", "```\nval pchar :\n    (char * string) -> Result<char * string> \n```", "```\nval pchar :\n    char -> string -> Result<char * string> \n```", "```\nlet add x y = \n    x + y \n```", "```\nlet add x = \n    fun y -> x + y  // return a lambda \n```", "```\nlet add x = \n    let innerFn y = x + y\n    innerFn // return innerFn \n```", "```\nlet pchar charToMatch = \n    // define a nested inner function\n    let innerFn str =\n        if String.IsNullOrEmpty(str) then\n            Failure \"No more input\"\n        else\n            let first = str.[0] \n            if first = charToMatch then\n                let remaining = str.[1..]\n                Success (charToMatch,remaining)\n            else\n                let msg = sprintf \"Expecting '%c'. Got '%c'\" charToMatch first\n                Failure msg\n    // return the inner function\n    innerFn \n```", "```\nval pchar :\n    char -> string -> Result<char * string> \n```", "```\n// two-parameter implementation\nlet pchar charToMatch str = \n    ...\n\n// one-parameter implementation with inner function\nlet pchar charToMatch = \n    let innerFn str =\n        ...    \n    // return the inner function\n    innerFn \n```", "```\nlet parseA = pchar 'A' \n```", "```\nlet inputABC = \"ABC\"\nparseA inputABC  // Success ('A', \"BC\")\n\nlet inputZBC = \"ZBC\"\nparseA inputZBC  // Failure \"Expecting 'A'. Got 'Z'\" \n```", "```\nval parseA : string -> Result<char * string> \n```", "```\ntype Parser<'T> = Parser of (string -> Result<'T * string>) \n```", "```\nlet pchar charToMatch = \n    let innerFn str =\n        ...\n    // return the inner function\n    innerFn \n```", "```\nlet pchar charToMatch = \n    let innerFn str =\n        ...\n    // return the \"wrapped\" inner function\n    Parser innerFn \n```", "```\nlet parseA = pchar 'A' \nlet inputABC = \"ABC\"\nparseA inputABC  // compiler error \n```", "```\nerror FS0003: This value is not a function and cannot be applied \n```", "```\nlet run parser input = \n    // unwrap parser to get inner function\n    let (Parser innerFn) = parser \n    // call inner function with input\n    innerFn input \n```", "```\nlet inputABC = \"ABC\"\nrun parseA inputABC  // Success ('A', \"BC\")\n\nlet inputZBC = \"ZBC\"\nrun parseA inputZBC  // Failure \"Expecting 'A'. Got 'Z'\" \n```", "```\nlet parseA = pchar 'A'   \nlet parseB = pchar 'B'\n\nlet parseAThenB = parseA >> parseB \n```", "```\nlet andThen parser1 parser2 =\n    let innerFn input =\n        // run parser1 with the input\n        let result1 = run parser1 input\n\n        // test the result for Failure/Success\n        match result1 with\n        | Failure err -> \n            // return error from parser1\n            Failure err  \n\n        | Success (value1,remaining1) -> \n            // run parser2 with the remaining input\n            let result2 =  run parser2 remaining1\n\n            // test the result for Failure/Success\n            match result2 with \n            | Failure err ->\n                // return error from parser2 \n                Failure err \n\n            | Success (value2,remaining2) -> \n                // combine both values as a pair\n                let newValue = (value1,value2)\n                // return remaining input after parser2\n                Success (newValue,remaining2)\n\n    // return the inner function\n    Parser innerFn \n```", "```\nlet ( .>>. ) = andThen \n```", "```\nval andThen : \n     parser1:Parser<'a> -> parser2:Parser<'b> -> Parser<'a * 'b> \n```", "```\nlet parseA = pchar 'A'   \nlet parseB = pchar 'B'\nlet parseAThenB = parseA .>>. parseB \n```", "```\nval parseA : Parser<char> \nval parseB : Parser<char> \nval parseAThenB : Parser<char * char> \n```", "```\nrun parseAThenB \"ABC\"  // Success (('A', 'B'), \"C\")\n\nrun parseAThenB \"ZBC\"  // Failure \"Expecting 'A'. Got 'Z'\"\n\nrun parseAThenB \"AZC\"  // Failure \"Expecting 'B'. Got 'Z'\" \n```", "```\nlet orElse parser1 parser2 =\n    let innerFn input =\n        // run parser1 with the input\n        let result1 = run parser1 input\n\n        // test the result for Failure/Success\n        match result1 with\n        | Success result -> \n            // if success, return the original result\n            result1\n\n        | Failure err -> \n            // if failed, run parser2 with the input\n            let result2 = run parser2 input\n\n            // return parser2's result\n            result2 \n\n    // return the inner function\n    Parser innerFn \n```", "```\nlet ( <|> ) = orElse \n```", "```\nval orElse : \n    parser1:Parser<'a> -> parser2:Parser<'a> -> Parser<'a> \n```", "```\nlet parseA = pchar 'A'   \nlet parseB = pchar 'B'\nlet parseAOrElseB = parseA <|> parseB \n```", "```\nval parseA : Parser<char> \nval parseB : Parser<char> \nval parseAOrElseB : Parser<char> \n```", "```\nrun parseAOrElseB \"AZZ\"  // Success ('A', \"ZZ\")\n\nrun parseAOrElseB \"BZZ\"  // Success ('B', \"ZZ\")\n\nrun parseAOrElseB \"CZZ\"  // Failure \"Expecting 'B'. Got 'C'\" \n```", "```\nlet parseA = pchar 'A'   \nlet parseB = pchar 'B'\nlet parseC = pchar 'C'\nlet bOrElseC = parseB <|> parseC\nlet aAndThenBorC = parseA .>>. bOrElseC \n```", "```\nrun aAndThenBorC \"ABZ\"  // Success (('A', 'B'), \"Z\")\nrun aAndThenBorC \"ACZ\"  // Success (('A', 'C'), \"Z\")\nrun aAndThenBorC \"QBZ\"  // Failure \"Expecting 'A'. Got 'Q'\"\nrun aAndThenBorC \"AQZ\"  // Failure \"Expecting 'C'. Got 'Q'\" \n```", "```\n/// Choose any of a list of parsers\nlet choice listOfParsers = \n    List.reduce ( <|> ) listOfParsers \n```", "```\nval choice :\n    Parser<'a> list -> Parser<'a> \n```", "```\n/// Choose any of a list of characters\nlet anyOf listOfChars = \n    listOfChars\n    |> List.map pchar // convert into parsers\n    |> choice \n```", "```\nlet parseLowercase = \n    anyOf ['a'..'z']\n\nlet parseDigit = \n    anyOf ['0'..'9'] \n```", "```\nrun parseLowercase \"aBC\"  // Success ('a', \"BC\")\nrun parseLowercase \"ABC\"  // Failure \"Expecting 'z'. Got 'A'\"\n\nrun parseDigit \"1ABC\"  // Success (\"1\", \"ABC\")\nrun parseDigit \"9ABC\"  // Success (\"9\", \"ABC\")\nrun parseDigit \"|ABC\"  // Failure \"Expecting '9'. Got '|'\" \n```", "```\nopen System\n\n/// Type that represents Success/Failure in parsing\ntype Result<'a> =\n    | Success of 'a\n    | Failure of string \n\n/// Type that wraps a parsing function\ntype Parser<'T> = Parser of (string -> Result<'T * string>)\n\n/// Parse a single character\nlet pchar charToMatch = \n    // define a nested inner function\n    let innerFn str =\n        if String.IsNullOrEmpty(str) then\n            Failure \"No more input\"\n        else\n            let first = str.[0] \n            if first = charToMatch then\n                let remaining = str.[1..]\n                Success (charToMatch,remaining)\n            else\n                let msg = sprintf \"Expecting '%c'. Got '%c'\" charToMatch first\n                Failure msg\n    // return the \"wrapped\" inner function\n    Parser innerFn \n\n/// Run a parser with some input\nlet run parser input = \n    // unwrap parser to get inner function\n    let (Parser innerFn) = parser \n    // call inner function with input\n    innerFn input\n\n/// Combine two parsers as \"A andThen B\"\nlet andThen parser1 parser2 =\n    let innerFn input =\n        // run parser1 with the input\n        let result1 = run parser1 input\n\n        // test the result for Failure/Success\n        match result1 with\n        | Failure err -> \n            // return error from parser1\n            Failure err  \n\n        | Success (value1,remaining1) -> \n            // run parser2 with the remaining input\n            let result2 =  run parser2 remaining1\n\n            // test the result for Failure/Success\n            match result2 with \n            | Failure err ->\n                // return error from parser2 \n                Failure err \n\n            | Success (value2,remaining2) -> \n                // combine both values as a pair\n                let newValue = (value1,value2)\n                // return remaining input after parser2\n                Success (newValue,remaining2)\n\n    // return the inner function\n    Parser innerFn \n\n/// Infix version of andThen\nlet ( .>>. ) = andThen\n\n/// Combine two parsers as \"A orElse B\"\nlet orElse parser1 parser2 =\n    let innerFn input =\n        // run parser1 with the input\n        let result1 = run parser1 input\n\n        // test the result for Failure/Success\n        match result1 with\n        | Success result -> \n            // if success, return the original result\n            result1\n\n        | Failure err -> \n            // if failed, run parser2 with the input\n            let result2 = run parser2 input\n\n            // return parser2's result\n            result2 \n\n    // return the inner function\n    Parser innerFn \n\n/// Infix version of orElse\nlet ( <|> ) = orElse\n\n/// Choose any of a list of parsers\nlet choice listOfParsers = \n    List.reduce ( <|> ) listOfParsers \n\n/// Choose any of a list of characters\nlet anyOf listOfChars = \n    listOfChars\n    |> List.map pchar // convert into parsers\n    |> choice \n```", "```\nlet pstring str = \n    str\n    |> Seq.map pchar // convert into parsers\n    |> Seq.reduce andThen \n```", "```\nlet parseDigit =\n    anyOf ['0'..'9']\n\nlet parseThreeDigits = \n    parseDigit .>>. parseDigit .>>. parseDigit \n```", "```\nrun parseThreeDigits \"123A\" \n```", "```\nSuccess ((('1', '2'), '3'), \"A\") \n```", "```\nlet mapP f parser = \n    let innerFn input =\n        // run parser with the input\n        let result = run parser input\n\n        // test the result for Failure/Success\n        match result with\n        | Success (value,remaining) -> \n            // if success, return the value transformed by f\n            let newValue = f value\n            Success (newValue, remaining)\n\n        | Failure err -> \n            // if failed, return the error\n            Failure err\n    // return the inner function\n    Parser innerFn \n```", "```\nval mapP : \n    f:('a -> 'b) -> Parser<'a> -> Parser<'b> \n```", "```\nlet ( <!> ) = mapP \n```", "```\nlet ( |>> ) x f = mapP f x \n```", "```\nlet parseDigit = anyOf ['0'..'9']\n\nlet parseThreeDigitsAsStr = \n    // create a parser that returns a tuple\n    let tupleParser = \n        parseDigit .>>. parseDigit .>>. parseDigit\n\n    // create a function that turns the tuple into a string\n    let transformTuple ((c1, c2), c3) = \n        String [| c1; c2; c3 |]\n\n    // use \"map\" to combine them\n    mapP transformTuple tupleParser \n```", "```\nlet parseThreeDigitsAsStr = \n    (parseDigit .>>. parseDigit .>>. parseDigit)\n    |>> fun ((c1, c2), c3) -> String [| c1; c2; c3 |] \n```", "```\nrun parseThreeDigitsAsStr \"123A\"  // Success (\"123\", \"A\") \n```", "```\nlet parseThreeDigitsAsInt = \n    mapP int parseThreeDigitsAsStr \n```", "```\nrun parseThreeDigitsAsInt \"123A\"  // Success (123, \"A\") \n```", "```\nval parseThreeDigitsAsInt : Parser<int> \n```", "```\nlet returnP x = \n    let innerFn input =\n        // ignore the input and return x\n        Success (x,input )\n    // return the inner function\n    Parser innerFn \n```", "```\nval returnP : \n    'a -> Parser<'a> \n```", "```\nlet applyP fP xP = \n    // create a Parser containing a pair (f,x)\n    (fP .>>. xP) \n    // map the pair by applying f to x\n    |> mapP (fun (f,x) -> f x) \n```", "```\nlet ( <*> ) = applyP \n```", "```\nval applyP : \n    Parser<('a -> 'b)> -> Parser<'a> -> Parser<'b> \n```", "```\n// lift a two parameter function to Parser World\nlet lift2 f xP yP =\n    returnP f <*> xP <*> yP \n```", "```\nval lift2 : \n    f:('a -> 'b -> 'c) -> Parser<'a> -> Parser<'b> -> Parser<'c> \n```", "```\nlet addP = \n    lift2 (+) \n```", "```\nval addP : \n    Parser<int> -> Parser<int> -> Parser<int> \n```", "```\nlet startsWith (str:string) prefix =\n    str.StartsWith(prefix)  \n\nlet startsWithP =\n    lift2 startsWith \n```", "```\nval startsWith : \n    str:string -> prefix:string -> bool\n\nval startsWithP : \n    Parser<string> -> Parser<string> -> Parser<bool> \n```", "```\nlet rec sequence parserList =\n    // define the \"cons\" function, which is a two parameter function\n    let cons head tail = head::tail\n\n    // lift it to Parser World\n    let consP = lift2 cons\n\n    // process the list of parsers recursively\n    match parserList with\n    | [] -> \n        returnP []\n    | head::tail ->\n        consP head (sequence tail) \n```", "```\nval sequence : \n    Parser<'a> list -> Parser<'a list> \n```", "```\nlet parsers = [ pchar 'A'; pchar 'B'; pchar 'C' ]\nlet combined = sequence parsers\n\nrun combined \"ABCD\" \n// Success (['A'; 'B'; 'C'], \"D\") \n```", "```\n/// Helper to create a string from a list of chars\nlet charListToStr charList = \n     String(List.toArray charList)\n\n// match a specific string\nlet pstring str = \n    str\n    // convert to list of char\n    |> List.ofSeq\n    // map each char to a pchar\n    |> List.map pchar \n    // convert to Parser<char list>\n    |> sequence\n    // convert Parser<char list> to Parser<string>\n    |> mapP charListToStr \n```", "```\nlet parseABC = pstring \"ABC\"\n\nrun parseABC \"ABCDE\"  // Success (\"ABC\", \"DE\")\nrun parseABC \"A|CDE\"  // Failure \"Expecting 'B'. Got '|'\"\nrun parseABC \"AB|DE\"  // Failure \"Expecting 'C'. Got '|'\" \n```", "```\nlet rec parseZeroOrMore parser input =\n    // run parser with the input\n    let firstResult = run parser input \n    // test the result for Failure/Success\n    match firstResult with\n    | Failure err -> \n        // if parse fails, return empty list\n        ([],input)  \n    | Success (firstValue,inputAfterFirstParse) -> \n        // if parse succeeds, call recursively\n        // to get the subsequent values\n        let (subsequentValues,remainingInput) = \n            parseZeroOrMore parser inputAfterFirstParse\n        let values = firstValue::subsequentValues\n        (values,remainingInput) \n```", "```\n/// match zero or more occurences of the specified parser\nlet many parser = \n\n    let rec innerFn input =\n        // parse the input -- wrap in Success as it always succeeds\n        Success (parseZeroOrMore parser input)\n\n    Parser innerFn \n```", "```\nval many : \n    Parser<'a> -> Parser<'a list> \n```", "```\nlet manyA = many (pchar 'A')\n\n// test some success cases\nrun manyA \"ABCD\"  // Success (['A'], \"BCD\")\nrun manyA \"AACD\"  // Success (['A'; 'A'], \"CD\")\nrun manyA \"AAAD\"  // Success (['A'; 'A'; 'A'], \"D\")\n\n// test a case with no matches\nrun manyA \"|BCD\"  // Success ([], \"|BCD\") \n```", "```\nlet manyAB = many (pstring \"AB\")\n\nrun manyAB \"ABCD\"  // Success ([\"AB\"], \"CD\")\nrun manyAB \"ABABCD\"  // Success ([\"AB\"; \"AB\"], \"CD\")\nrun manyAB \"ZCD\"  // Success ([], \"ZCD\")\nrun manyAB \"AZCD\"  // Success ([], \"AZCD\") \n```", "```\nlet whitespaceChar = anyOf [' '; '\\t'; '\\n']\nlet whitespace = many whitespaceChar \n\nrun whitespace \"ABC\"  // Success ([], \"ABC\")\nrun whitespace \" ABC\"  // Success ([' '], \"ABC\")\nrun whitespace \"\\tABC\"  // Success (['\\t'], \"ABC\") \n```", "```\n/// match one or more occurences of the specified parser\nlet many1 parser = \n    let rec innerFn input =\n        // run parser with the input\n        let firstResult = run parser input \n        // test the result for Failure/Success\n        match firstResult with\n        | Failure err -> \n            Failure err // failed\n        | Success (firstValue,inputAfterFirstParse) -> \n            // if first found, look for zeroOrMore now\n            let (subsequentValues,remainingInput) = \n                parseZeroOrMore parser inputAfterFirstParse\n            let values = firstValue::subsequentValues\n            Success (values,remainingInput)  \n    Parser innerFn \n```", "```\nval many1 : \n    Parser<'a> -> Parser<'a list> \n```", "```\n// define parser for one digit\nlet digit = anyOf ['0'..'9']\n\n// define parser for one or more digits\nlet digits = many1 digit \n\nrun digits \"1ABC\"  // Success (['1'], \"ABC\")\nrun digits \"12BC\"  // Success (['1'; '2'], \"BC\")\nrun digits \"123C\"  // Success (['1'; '2'; '3'], \"C\")\nrun digits \"1234\"  // Success (['1'; '2'; '3'; '4'], \"\")\n\nrun digits \"ABC\"   // Failure \"Expecting '9'. Got 'A'\" \n```", "```\nlet pint = \n    // helper\n    let resultToInt digitList = \n        // ignore int overflow for now\n        String(List.toArray digitList) |> int\n\n    // define parser for one digit\n    let digit = anyOf ['0'..'9']\n\n    // define parser for one or more digits\n    let digits = many1 digit \n\n    // map the digits to an int\n    digits \n    |> mapP resultToInt \n```", "```\nrun pint \"1ABC\"  // Success (1, \"ABC\")\nrun pint \"12BC\"  // Success (12, \"BC\")\nrun pint \"123C\"  // Success (123, \"C\")\nrun pint \"1234\"  // Success (1234, \"\")\n\nrun pint \"ABC\"   // Failure \"Expecting '9'. Got 'A'\" \n```", "```\nlet opt p = \n    let some = p |>> Some\n    let none = returnP None\n    some <|> none \n```", "```\nlet digit = anyOf ['0'..'9']\nlet digitThenSemicolon = digit .>>. opt (pchar ';')\n\nrun digitThenSemicolon \"1;\"  // Success (('1', Some ';'), \"\")\nrun digitThenSemicolon \"1\"   // Success (('1', None), \"\") \n```", "```\nlet pint = \n    // helper\n    let resultToInt (sign,charList) = \n        let i = String(List.toArray charList) |> int\n        match sign with\n        | Some ch -> -i  // negate the int\n        | None -> i\n\n    // define parser for one digit\n    let digit = anyOf ['0'..'9']\n\n    // define parser for one or more digits\n    let digits = many1 digit \n\n    // parse and convert\n    opt (pchar '-') .>>. digits \n    |>> resultToInt \n```", "```\nrun pint \"123C\"   // Success (123, \"C\")\nrun pint \"-123C\"  // Success (-123, \"C\") \n```", "```\n/// Keep only the result of the left side parser\nlet (.>>) p1 p2 = \n    // create a pair\n    p1 .>>. p2 \n    // then only keep the first value\n    |> mapP (fun (a,b) -> a) \n\n/// Keep only the result of the right side parser \nlet (>>.) p1 p2 = \n    // create a pair\n    p1 .>>. p2 \n    // then only keep the second value\n    |> mapP (fun (a,b) -> b) \n```", "```\nlet digit = anyOf ['0'..'9']\n\n// use .>> below\nlet digitThenSemicolon = digit .>> opt (pchar ';')  \n\nrun digitThenSemicolon \"1;\"  // Success ('1', \"\")\nrun digitThenSemicolon \"1\"   // Success ('1', \"\") \n```", "```\nlet whitespaceChar = anyOf [' '; '\\t'; '\\n']\nlet whitespace = many1 whitespaceChar \n\nlet ab = pstring \"AB\"\nlet cd = pstring \"CD\"\nlet ab_cd = (ab .>> whitespace) .>>. cd\n\nrun ab_cd \"AB \\t\\nCD\"   // Success ((\"AB\", \"CD\"), \"\") \n```", "```\n/// Keep only the result of the middle parser\nlet between p1 p2 p3 = \n    p1 >>. p2 .>> p3 \n```", "```\nlet pdoublequote = pchar '\"'\nlet quotedInteger = between pdoublequote pint pdoublequote\n\nrun quotedInteger \"\\\"1234\\\"\"   // Success (1234, \"\")\nrun quotedInteger \"1234\"       // Failure \"Expecting '\"'. Got '1'\" \n```", "```\n/// Parses one or more occurrences of p separated by sep\nlet sepBy1 p sep =\n    let sepThenP = sep >>. p            \n    p .>>. many sepThenP \n    |>> fun (p,pList) -> p::pList \n```", "```\n/// Parses zero or more occurrences of p separated by sep\nlet sepBy p sep =\n    sepBy1 p sep <|> returnP [] \n```", "```\nlet comma = pchar ',' \nlet digit = anyOf ['0'..'9']\n\nlet zeroOrMoreDigitList = sepBy digit comma\nlet oneOrMoreDigitList = sepBy1 digit comma\n\nrun oneOrMoreDigitList \"1;\"      // Success (['1'], \";\")\nrun oneOrMoreDigitList \"1,2;\"    // Success (['1'; '2'], \";\")\nrun oneOrMoreDigitList \"1,2,3;\"  // Success (['1'; '2'; '3'], \";\")\nrun oneOrMoreDigitList \"Z;\"      // Failure \"Expecting '9'. Got 'Z'\"\n\nrun zeroOrMoreDigitList \"1;\"     // Success (['1'], \";\")\nrun zeroOrMoreDigitList \"1,2;\"   // Success (['1'; '2'], \";\")\nrun zeroOrMoreDigitList \"1,2,3;\" // Success (['1'; '2'; '3'], \";\")\nrun zeroOrMoreDigitList \"Z;\"     // Success ([], \"Z;\") \n```", "```\n/// \"bindP\" takes a parser-producing function f, and a parser p\n/// and passes the output of p into f, to create a new parser\nlet bindP f p =\n    let innerFn input =\n        let result1 = run p input \n        match result1 with\n        | Failure err -> \n            // return error from parser1\n            Failure err  \n        | Success (value1,remainingInput) ->\n            // apply f to get a new parser\n            let p2 = f value1\n            // run parser with remaining input\n            run p2 remainingInput\n    Parser innerFn \n```", "```\nval bindP : \n    f:('a -> Parser<'b>) -> Parser<'a> -> Parser<'b> \n```", "```\nlet ( >>= ) p f = bindP f p \n```", "```\nlet mapP f =         \n    bindP (f >> returnP)\n\nlet andThen p1 p2 =         \n    p1 >>= (fun p1Result -> \n    p2 >>= (fun p2Result -> \n        returnP (p1Result,p2Result) ))\n\nlet applyP fP xP =         \n    fP >>= (fun f -> \n    xP >>= (fun x -> \n        returnP (f x) ))\n\n// (assuming \"many\" is defined)\n\nlet many1 p =         \n    p      >>= (fun head -> \n    many p >>= (fun tail -> \n        returnP (head::tail) )) \n```", "```\nopen System\n\n/// Type that represents Success/Failure in parsing\ntype Result<'a> =\n    | Success of 'a\n    | Failure of string \n\n/// Type that wraps a parsing function\ntype Parser<'T> = Parser of (string -> Result<'T * string>)\n\n/// Parse a single character\nlet pchar charToMatch = \n    // define a nested inner function\n    let innerFn str =\n        if String.IsNullOrEmpty(str) then\n            Failure \"No more input\"\n        else\n            let first = str.[0] \n            if first = charToMatch then\n                let remaining = str.[1..]\n                Success (charToMatch,remaining)\n            else\n                let msg = sprintf \"Expecting '%c'. Got '%c'\" charToMatch first\n                Failure msg\n    // return the \"wrapped\" inner function\n    Parser innerFn \n\n/// Run a parser with some input\nlet run parser input = \n    // unwrap parser to get inner function\n    let (Parser innerFn) = parser \n    // call inner function with input\n    innerFn input\n\n/// \"bindP\" takes a parser-producing function f, and a parser p\n/// and passes the output of p into f, to create a new parser\nlet bindP f p =\n    let innerFn input =\n        let result1 = run p input \n        match result1 with\n        | Failure err -> \n            // return error from parser1\n            Failure err  \n        | Success (value1,remainingInput) ->\n            // apply f to get a new parser\n            let p2 = f value1\n            // run parser with remaining input\n            run p2 remainingInput\n    Parser innerFn \n\n/// Infix version of bindP\nlet ( >>= ) p f = bindP f p\n\n/// Lift a value to a Parser\nlet returnP x = \n    let innerFn input =\n        // ignore the input and return x\n        Success (x,input)\n    // return the inner function\n    Parser innerFn \n\n/// apply a function to the value inside a parser\nlet mapP f = \n    bindP (f >> returnP)\n\n/// infix version of mapP\nlet ( <!> ) = mapP\n\n/// \"piping\" version of mapP\nlet ( |>> ) x f = mapP f x\n\n/// apply a wrapped function to a wrapped value\nlet applyP fP xP =         \n    fP >>= (fun f -> \n    xP >>= (fun x -> \n        returnP (f x) ))\n\n/// infix version of apply\nlet ( <*> ) = applyP\n\n/// lift a two parameter function to Parser World\nlet lift2 f xP yP =\n    returnP f <*> xP <*> yP\n\n/// Combine two parsers as \"A andThen B\"\nlet andThen p1 p2 =         \n    p1 >>= (fun p1Result -> \n    p2 >>= (fun p2Result -> \n        returnP (p1Result,p2Result) ))\n\n/// Infix version of andThen\nlet ( .>>. ) = andThen\n\n/// Combine two parsers as \"A orElse B\"\nlet orElse p1 p2 =\n    let innerFn input =\n        // run parser1 with the input\n        let result1 = run p1 input\n\n        // test the result for Failure/Success\n        match result1 with\n        | Success result -> \n            // if success, return the original result\n            result1\n\n        | Failure err -> \n            // if failed, run parser2 with the input\n            let result2 = run p2 input\n\n            // return parser2's result\n            result2 \n\n    // return the inner function\n    Parser innerFn \n\n/// Infix version of orElse\nlet ( <|> ) = orElse\n\n/// Choose any of a list of parsers\nlet choice listOfParsers = \n    List.reduce ( <|> ) listOfParsers \n\n/// Choose any of a list of characters\nlet anyOf listOfChars = \n    listOfChars\n    |> List.map pchar // convert into parsers\n    |> choice\n\n/// Convert a list of Parsers into a Parser of a list\nlet rec sequence parserList =\n    // define the \"cons\" function, which is a two parameter function\n    let cons head tail = head::tail\n\n    // lift it to Parser World\n    let consP = lift2 cons\n\n    // process the list of parsers recursively\n    match parserList with\n    | [] -> \n        returnP []\n    | head::tail ->\n        consP head (sequence tail)\n\n/// (helper) match zero or more occurences of the specified parser\nlet rec parseZeroOrMore parser input =\n    // run parser with the input\n    let firstResult = run parser input \n    // test the result for Failure/Success\n    match firstResult with\n    | Failure err -> \n        // if parse fails, return empty list\n        ([],input)  \n    | Success (firstValue,inputAfterFirstParse) -> \n        // if parse succeeds, call recursively\n        // to get the subsequent values\n        let (subsequentValues,remainingInput) = \n            parseZeroOrMore parser inputAfterFirstParse\n        let values = firstValue::subsequentValues\n        (values,remainingInput)  \n\n/// matches zero or more occurences of the specified parser\nlet many parser = \n    let rec innerFn input =\n        // parse the input -- wrap in Success as it always succeeds\n        Success (parseZeroOrMore parser input)\n\n    Parser innerFn\n\n/// matches one or more occurences of the specified parser\nlet many1 p =         \n    p      >>= (fun head -> \n    many p >>= (fun tail -> \n        returnP (head::tail) ))\n\n/// Parses an optional occurrence of p and returns an option value.\nlet opt p = \n    let some = p |>> Some\n    let none = returnP None\n    some <|> none\n\n/// Keep only the result of the left side parser\nlet (.>>) p1 p2 = \n    // create a pair\n    p1 .>>. p2 \n    // then only keep the first value\n    |> mapP (fun (a,b) -> a) \n\n/// Keep only the result of the right side parser\nlet (>>.) p1 p2 = \n    // create a pair\n    p1 .>>. p2 \n    // then only keep the second value\n    |> mapP (fun (a,b) -> b) \n\n/// Keep only the result of the middle parser\nlet between p1 p2 p3 = \n    p1 >>. p2 .>> p3 \n\n/// Parses one or more occurrences of p separated by sep\nlet sepBy1 p sep =\n    let sepThenP = sep >>. p            \n    p .>>. many sepThenP \n    |>> fun (p,pList) -> p::pList\n\n/// Parses zero or more occurrences of p separated by sep\nlet sepBy p sep =\n    sepBy1 p sep <|> returnP [] \n```", "```\nlet parseDigit = anyOf ['0'..'9']\nrun parseDigit \"|ABC\"  // Failure \"Expecting '9'. Got '|'\" \n```", "```\ntype Parser<'a> = Parser of (string -> Result<'a * string>) \n```", "```\ntype ParserLabel = string\n\n/// A Parser structure has a parsing function & label\ntype Parser<'a> = {\n    parseFn : (string -> Result<'a * string>)\n    label:  ParserLabel \n    } \n```", "```\n// Aliases \ntype ParserLabel = string\ntype ParserError = string\n\ntype Result<'a> =\n    | Success of 'a\n    | Failure of ParserLabel * ParserError \n```", "```\nlet printResult result =\n    match result with\n    | Success (value,input) -> \n        printfn \"%A\" value\n    | Failure (label,error) -> \n        printfn \"Error parsing %s\\n%s\" label error \n```", "```\n/// \"bindP\" takes a parser-producing function f, and a parser p\n/// and passes the output of p into f, to create a new parser\nlet bindP f p =\n    let label = \"unknown\"           // <====== \"label\" is new! \n    let innerFn input =\n        ...\n        match result1 with\n        | Failure (label,err) ->    // <====== \"label\" is new!\n            ...\n        | Success (value1,remainingInput) ->\n            ...\n    {parseFn=innerFn; label=label}  // <====== \"parseFn\" and \"label\" are new! \n```", "```\n/// Update the label in the parser\nlet setLabel parser newLabel = \n    // change the inner function to use the new label\n    let newInnerFn input = \n        let result = parser.parseFn input\n        match result with\n        | Success s ->\n            // if Success, do nothing\n            Success s \n        | Failure (oldLabel,err) -> \n            // if Failure, return new label\n            Failure (newLabel,err)        // <====== use newLabel here\n    // return the Parser\n    {parseFn=newInnerFn; label=newLabel}  // <====== use newLabel here \n```", "```\n/// infix version of setLabel\nlet ( <?> ) = setLabel \n```", "```\nlet parseDigit_WithLabel = \n    anyOf ['0'..'9'] \n    <?> \"digit\"\n\nrun parseDigit_WithLabel \"|ABC\"  \n|> printResult \n```", "```\nError parsing digit\nUnexpected '|' \n```", "```\n/// Combine two parsers as \"A andThen B\"\nlet andThen p1 p2 =         \n    let label = sprintf \"%s andThen %s\" (getLabel p1) (getLabel p2)\n    p1 >>= (fun p1Result -> \n    p2 >>= (fun p2Result -> \n        returnP (p1Result,p2Result) ))\n    <?> label         // <====== provide a custom label\n\n// combine two parsers as \"A orElse B\"\nlet orElse parser1 parser2 =\n    // construct a new label\n    let label =       // <====== provide a custom label\n        sprintf \"%s orElse %s\" (getLabel parser1) (getLabel parser2)\n\n    let innerFn input =\n       ... etc ...\n\n/// choose any of a list of characters\nlet anyOf listOfChars = \n    let label = sprintf \"any of %A\" listOfChars \n    listOfChars\n    |> List.map pchar \n    |> choice\n    <?> label         // <====== provide a custom label \n```", "```\n/// Match an input token if the predicate is satisfied\nlet satisfy predicate label =\n    let innerFn input =\n        if String.IsNullOrEmpty(input) then\n            Failure (label,\"No more input\")\n        else\n            let first = input.[0] \n            if predicate first then      // <====== use predicate here\n                let remainingInput = input.[1..]\n                Success (first,remainingInput)\n            else\n                let err = sprintf \"Unexpected '%c'\" first\n                Failure (label,err)\n    // return the parser\n    {parseFn=innerFn;label=label} \n```", "```\nlet satisfy predicate label =\n    ...\n    if predicate first then\n    ... \n```", "```\n/// parse a char \nlet pchar charToMatch = \n    let predicate ch = (ch = charToMatch) \n    let label = sprintf \"%c\" charToMatch \n    satisfy predicate label \n```", "```\n/// parse a digit\nlet digitChar = \n    anyOf ['0'..'9'] \n```", "```\n/// parse a digit\nlet digitChar = \n    let predicate = Char.IsDigit \n    let label = \"digit\"\n    satisfy predicate label \n```", "```\n/// parse a whitespace char\nlet whitespaceChar = \n    let predicate = Char.IsWhiteSpace \n    let label = \"whitespace\"\n    satisfy predicate label \n```", "```\ntype Position = {\n    line : int\n    column : int\n}\n\n/// define an initial position\nlet initialPos = {line=0; column=0}\n\n/// increment the column number\nlet incrCol pos = \n    {pos with column=pos.column + 1}\n\n/// increment the line number and set the column to 0\nlet incrLine pos = \n    {line=pos.line + 1; column=0} \n```", "```\n/// Define the current input state\ntype InputState = {\n    lines : string[]\n    position : Position \n} \n```", "```\n/// Create a new InputState from a string\nlet fromStr str = \n    if String.IsNullOrEmpty(str) then\n        {lines=[||]; position=initialPos}\n    else\n        let separators = [| \"\\r\\n\"; \"\\n\" |]\n        let lines = str.Split(separators, StringSplitOptions.None)\n        {lines=lines; position=initialPos} \n```", "```\n// return the current line\nlet currentLine inputState = \n    let linePos = inputState.position.line\n    if linePos < inputState.lines.Length then\n        inputState.lines.[linePos]\n    else\n        \"end of file\"\n\n/// Get the next character from the input, if any\n/// else return None. Also return the updated InputState\n/// Signature: InputState -> InputState * char option \nlet nextChar input =\n    let linePos = input.position.line\n    let colPos = input.position.column\n    // three cases\n    // 1) if line >= maxLine -> \n    //       return EOF\n    // 2) if col less than line length -> \n    //       return char at colPos, increment colPos\n    // 3) if col at line length -> \n    //       return NewLine, increment linePos\n\n    if linePos >= input.lines.Length then\n        input, None\n    else\n        let currentLine = currentLine input\n        if colPos < currentLine.Length then\n            let char = currentLine.[colPos]\n            let newPos = incrCol input.position \n            let newState = {input with position=newPos}\n            newState, Some char\n        else \n            // end of line, so return LF and move to next line\n            let char = '\\n'\n            let newPos = incrLine input.position \n            let newState = {input with position=newPos}\n            newState, Some char \n```", "```\nlet rec readAllChars input =\n    [\n        let remainingInput,charOpt = nextChar input \n        match charOpt with\n        | None -> \n            // end of input\n            ()\n        | Some ch -> \n            // return first character\n            yield ch\n            // return the remaining characters\n            yield! readAllChars remainingInput\n    ] \n```", "```\nfromStr \"\" |> readAllChars       // []\nfromStr \"a\" |> readAllChars      // ['a'; '\\n']\nfromStr \"ab\" |> readAllChars     // ['a'; 'b'; '\\n']\nfromStr \"a\\nb\" |> readAllChars   // ['a'; '\\n'; 'b'; '\\n'] \n```", "```\n/// Stores information about the parser position for error messages\ntype ParserPosition = {\n    currentLine : string\n    line : int\n    column : int\n    } \n```", "```\nlet parserPositionFromInputState (inputState:Input) = {\n    currentLine = TextInput.currentLine inputState\n    line = inputState.position.line\n    column = inputState.position.column\n    } \n```", "```\n// Result type\ntype Result<'a> =\n    | Success of 'a\n    | Failure of ParserLabel * ParserError * ParserPosition \n```", "```\ntype Input = TextInput.InputState  // type alias\n\n/// A Parser structure has a parsing function & label\ntype Parser<'a> = {\n    parseFn : (Input -> Result<'a * Input>)\n    label:  ParserLabel \n    } \n```", "```\nlet printResult result =\n    match result with\n    | Success (value,input) -> \n        printfn \"%A\" value\n    | Failure (label,error,parserPos) -> \n        let errorLine = parserPos.currentLine\n        let colPos = parserPos.column\n        let linePos = parserPos.line\n        let failureCaret = sprintf \"%*s^%s\" colPos \"\" error\n        printfn \"Line:%i Col:%i Error parsing %s\\n%s\\n%s\" linePos colPos label errorLine failureCaret \n```", "```\nlet exampleError = \n    Failure (\"identifier\", \"unexpected |\",\n             {currentLine = \"123 ab|cd\"; line=1; column=6})\n\nprintResult exampleError \n```", "```\nLine:1 Col:6 Error parsing identifier\n123 ab|cd\n      ^unexpected | \n```", "```\n/// Run the parser on a InputState\nlet runOnInput parser input = \n    // call inner function with input\n    parser.parseFn input\n\n/// Run the parser on a string\nlet run parser inputStr = \n    // call inner function with input\n    runOnInput parser (TextInput.fromStr inputStr) \n```", "```\n/// Match an input token if the predicate is satisfied\nlet satisfy predicate label =\n    let innerFn input =\n        let remainingInput,charOpt = TextInput.nextChar input \n        match charOpt with\n        | None -> \n            let err = \"No more input\"\n            let pos = parserPositionFromInputState input\n            //Failure (label,err)     // <====== old version\n            Failure (label,err,pos)   // <====== new version\n        | Some first -> \n            if predicate first then\n                Success (first,remainingInput)\n            else\n                let err = sprintf \"Unexpected '%c'\" first\n                let pos = parserPositionFromInputState input\n                //Failure (label,err)     // <====== old version\n                Failure (label,err,pos)   // <====== new version\n    // return the parser\n    {parseFn=innerFn;label=label} \n```", "```\n/// \"bindP\" takes a parser-producing function f, and a parser p\n/// and passes the output of p into f, to create a new parser\nlet bindP f p =\n    let label = \"unknown\"\n    let innerFn input =\n        let result1 = runOnInput p input \n        match result1 with\n        | Failure (label,err,pos) ->     // <====== new with pos\n            // return error from parser1\n            Failure (label,err,pos)  \n        | Success (value1,remainingInput) ->\n            // apply f to get a new parser\n            let p2 = f value1\n            // run parser with remaining input\n            runOnInput p2 remainingInput\n    {parseFn=innerFn; label=label} \n```", "```\nlet parseAB = \n    pchar 'A' .>>. pchar 'B' \n    <?> \"AB\"\n\nrun parseAB \"A|C\"  \n|> printResult \n```", "```\n// Line:0 Col:1 Error parsing AB\n// A|C\n//  ^Unexpected '|' \n```", "```\n/// parse a char \nlet pchar charToMatch = \n    // label is just the character\n    let label = sprintf \"%c\" charToMatch \n\n    let predicate ch = (ch = charToMatch) \n    satisfy predicate label \n\n/// Choose any of a list of characters\nlet anyOf listOfChars = \n    let label = sprintf \"anyOf %A\" listOfChars \n    listOfChars\n    |> List.map pchar // convert into parsers\n    |> choice\n    <?> label\n\n/// Convert a list of chars to a string\nlet charListToStr charList =\n    String(List.toArray charList) \n\n/// Parses a sequence of zero or more chars with the char parser cp. \n/// It returns the parsed chars as a string.\nlet manyChars cp =\n    many cp\n    |>> charListToStr\n\n/// Parses a sequence of one or more chars with the char parser cp. \n/// It returns the parsed chars as a string.\nlet manyChars1 cp =\n    many1 cp\n    |>> charListToStr\n\n/// parse a specific string\nlet pstring str = \n    // label is just the string\n    let label = str \n\n    str\n    // convert to list of char\n    |> List.ofSeq\n    // map each char to a pchar\n    |> List.map pchar \n    // convert to Parser<char list>\n    |> sequence\n    // convert Parser<char list> to Parser<string>\n    |> mapP charListToStr \n    <?> label \n```", "```\nrun (pstring \"AB\") \"ABC\"  \n|> printResult   \n// Success\n// \"AB\"\n\nrun (pstring \"AB\") \"A|C\"  \n|> printResult\n// Line:0 Col:1 Error parsing AB\n// A|C\n//  ^Unexpected '|' \n```", "```\n/// parse a whitespace char\nlet whitespaceChar = \n    let predicate = Char.IsWhiteSpace \n    let label = \"whitespace\"\n    satisfy predicate label \n\n/// parse zero or more whitespace char\nlet spaces = many whitespaceChar\n\n/// parse one or more whitespace char\nlet spaces1 = many1 whitespaceChar \n```", "```\nrun spaces \" ABC\"  \n|> printResult   \n// [' ']\n\nrun spaces \"A\"  \n|> printResult\n// []\n\nrun spaces1 \" ABC\"  \n|> printResult   \n// [' ']\n\nrun spaces1 \"A\"  \n|> printResult\n// Line:0 Col:0 Error parsing many1 whitespace\n// A\n// ^Unexpected 'A' \n```", "```\n/// parse a digit\nlet digitChar = \n    let predicate = Char.IsDigit \n    let label = \"digit\"\n    satisfy predicate label \n\n// parse an integer\nlet pint = \n    let label = \"integer\" \n\n    // helper\n    let resultToInt (sign,digits) = \n        let i = digits |> int  // ignore int overflow for now\n        match sign with\n        | Some ch -> -i  // negate the int\n        | None -> i\n\n    // define parser for one or more digits\n    let digits = manyChars1 digitChar \n\n    // an \"int\" is optional sign + one or more digits\n    opt (pchar '-') .>>. digits \n    |> mapP resultToInt\n    <?> label\n\n// parse a float\nlet pfloat = \n    let label = \"float\" \n\n    // helper\n    let resultToFloat (((sign,digits1),point),digits2) = \n        let fl = sprintf \"%s.%s\" digits1 digits2 |> float\n        match sign with\n        | Some ch -> -fl  // negate the float\n        | None -> fl\n\n    // define parser for one or more digits \n    let digits = manyChars1 digitChar \n\n    // a float is sign, digits, point, digits (ignore exponents for now)\n    opt (pchar '-') .>>. digits .>>. pchar '.' .>>. digits \n    |> mapP resultToFloat\n    <?> label \n```", "```\nrun pint \"-123Z\" \n|> printResult   \n// -123\n\nrun pint \"-Z123\" \n|> printResult\n// Line:0 Col:1 Error parsing integer\n// -Z123\n//  ^Unexpected 'Z'\n\nrun pfloat \"-123.45Z\" \n|> printResult   \n// -123.45\n\nrun pfloat \"-123Z45\" \n|> printResult\n// Line:0 Col:4 Error parsing float\n// -123Z45\n//     ^Unexpected 'Z' \n```", "```\n#load \"ParserLibrary.fsx\"\n\nopen System\nopen ParserLibrary \n```", "```\ntype JValue = \n    | JString of string\n    | JNumber of float\n    | JBool   of bool\n    | JNull\n    | JObject of Map<string, Json>\n    | JArray  of Json list \n```", "```\nlet jNull = \n    pstring \"null\" \n    |>> (fun _ -> JNull)  // map to JNull\n    <?> \"null\"            // give it a label \n```", "```\n// applies the parser p, ignores the result, and returns x.\nlet (>>%) p x =\n    p |>> (fun _ -> x) \n```", "```\nlet jNull = \n    pstring \"null\" \n    >>% JNull   // using new utility combinator\n    <?> \"null\" \n```", "```\nrun jNull \"null\"   \n// Success: JNull\n\nrun jNull \"nulp\" |> printResult  \n// Line:0 Col:3 Error parsing null\n// nulp\n//    ^Unexpected 'p' \n```", "```\nlet jBool =   \n    let jtrue = \n        pstring \"true\" \n        >>% JBool true   // map to JBool\n    let jfalse = \n        pstring \"false\" \n        >>% JBool false  // map to JBool \n\n    // choose between true and false\n    jtrue <|> jfalse\n    <?> \"bool\"           // give it a label \n```", "```\nrun jBool \"true\"   \n// Success: JBool true\n\nrun jBool \"false\"\n// Success: JBool false\n\nrun jBool \"truX\" |> printResult  \n// Line:0 Col:0 Error parsing bool\n// truX\n// ^Unexpected 't' \n```", "```\nlet jUnescapedChar = \n    let label = \"char\"\n    satisfy (fun ch -> ch <> '\\\\' && ch <> '\\\"') label \n```", "```\nrun jUnescapedChar \"a\"   // Success 'a'\n\nrun jUnescapedChar \"\\\\\" |> printResult\n// Line:0 Col:0 Error parsing char\n// \\\n// ^Unexpected '\\' \n```", "```\n/// Parse an escaped char\nlet jEscapedChar = \n    [ \n    // (stringToMatch, resultChar)\n    (\"\\\\\\\"\",'\\\"')      // quote\n    (\"\\\\\\\\\",'\\\\')      // reverse solidus \n    (\"\\\\/\",'/')        // solidus\n    (\"\\\\b\",'\\b')       // backspace\n    (\"\\\\f\",'\\f')       // formfeed\n    (\"\\\\n\",'\\n')       // newline\n    (\"\\\\r\",'\\r')       // cr\n    (\"\\\\t\",'\\t')       // tab\n    ] \n    // convert each pair into a parser\n    |> List.map (fun (toMatch,result) -> \n        pstring toMatch >>% result)\n    // and combine them into one\n    |> choice\n    <?> \"escaped char\" // set label \n```", "```\nrun jEscapedChar \"\\\\\\\\\" // Success '\\'\nrun jEscapedChar \"\\\\t\"  // Success '\\009'\n\nrun jEscapedChar \"a\" |> printResult\n// Line:0 Col:0 Error parsing escaped char\n// a\n// ^Unexpected 'a' \n```", "```\n/// Parse a unicode char\nlet jUnicodeChar = \n\n    // set up the \"primitive\" parsers \n    let backslash = pchar '\\\\'\n    let uChar = pchar 'u'\n    let hexdigit = anyOf (['0'..'9'] @ ['A'..'F'] @ ['a'..'f'])\n\n    // convert the parser output (nested tuples)\n    // to a char\n    let convertToChar (((h1,h2),h3),h4) = \n        let str = sprintf \"%c%c%c%c\" h1 h2 h3 h4\n        Int32.Parse(str,Globalization.NumberStyles.HexNumber) |> char\n\n    // set up the main parser\n    backslash  >>. uChar >>. hexdigit .>>. hexdigit .>>. hexdigit .>>. hexdigit\n    |>> convertToChar \n```", "```\nrun jUnicodeChar \"\\\\u263A\" \n```", "```\nlet quotedString = \n    let quote = pchar '\\\"' <?> \"quote\"\n    let jchar = jUnescapedChar <|> jEscapedChar <|> jUnicodeChar \n\n    // set up the main parser\n    quote >>. manyChars jchar .>> quote \n```", "```\n/// Parse a JString\nlet jString = \n    // wrap the string in a JString\n    quotedString\n    |>> JString           // convert to JString\n    <?> \"quoted string\"   // add label \n```", "```\nrun jString \"\\\"\\\"\"    // Success \"\"\nrun jString \"\\\"a\\\"\"   // Success \"a\"\nrun jString \"\\\"ab\\\"\"  // Success \"ab\"\nrun jString \"\\\"ab\\\\tde\\\"\"      // Success \"ab\\tde\"\nrun jString \"\\\"ab\\\\u263Ade\\\"\"  // Success \"ab?de\" \n```", "```\nlet optSign = opt (pchar '-')\n\nlet zero = pstring \"0\"\n\nlet digitOneNine = \n    satisfy (fun ch -> Char.IsDigit ch && ch <> '0') \"1-9\"\n\nlet digit = \n    satisfy (fun ch -> Char.IsDigit ch ) \"digit\"\n\nlet point = pchar '.'\n\nlet e = pchar 'e' <|> pchar 'E'\n\nlet optPlusMinus = opt (pchar '-' <|> pchar '+') \n```", "```\nlet nonZeroInt = \n    digitOneNine .>>. manyChars digit \n    |>> fun (first,rest) -> string first + rest\n\nlet intPart = zero <|> nonZeroInt \n```", "```\nlet fractionPart = point >>. manyChars1 digit \n```", "```\nlet exponentPart = e >>. optPlusMinus .>>. manyChars1 digit \n```", "```\noptSign .>>. intPart .>>. opt fractionPart .>>. opt exponentPart\n|>> convertToJNumber\n<?> \"number\"   // add label \n```", "```\n// utility function to convert an optional value to a string, or \"\" if missing\nlet ( |>? ) opt f = \n    match opt with\n    | None -> \"\"\n    | Some x -> f x \n```", "```\nlet convertToJNumber (((optSign,intPart),fractionPart),expPart) = \n    // convert to strings and let .NET parse them! - crude but ok for now.\n\n    let signStr = \n        optSign \n        |>? string   // e.g. \"-\"\n\n    let fractionPartStr = \n        fractionPart \n        |>? (fun digits -> \".\" + digits )  // e.g. \".456\"\n\n    let expPartStr = \n        expPart \n        |>? fun (optSign, digits) ->\n            let sign = optSign |>? string\n            \"e\" + sign + digits          // e.g. \"e-12\"\n\n    // add the parts together and convert to a float, then wrap in a JNumber\n    (signStr + intPart + fractionPartStr + expPartStr)\n    |> float\n    |> JNumber \n```", "```\n/// Parse a JNumber\nlet jNumber = \n\n    // set up the \"primitive\" parsers \n    let optSign = opt (pchar '-')\n\n    let zero = pstring \"0\"\n\n    let digitOneNine = \n        satisfy (fun ch -> Char.IsDigit ch && ch <> '0') \"1-9\"\n\n    let digit = \n        satisfy (fun ch -> Char.IsDigit ch ) \"digit\"\n\n    let point = pchar '.'\n\n    let e = pchar 'e' <|> pchar 'E'\n\n    let optPlusMinus = opt (pchar '-' <|> pchar '+')\n\n    let nonZeroInt = \n        digitOneNine .>>. manyChars digit \n        |>> fun (first,rest) -> string first + rest\n\n    let intPart = zero <|> nonZeroInt\n\n    let fractionPart = point >>. manyChars1 digit\n\n    let exponentPart = e >>. optPlusMinus .>>. manyChars1 digit\n\n    // utility function to convert an optional value to a string, or \"\" if missing\n    let ( |>? ) opt f = \n        match opt with\n        | None -> \"\"\n        | Some x -> f x\n\n    let convertToJNumber (((optSign,intPart),fractionPart),expPart) = \n        // convert to strings and let .NET parse them! - crude but ok for now.\n\n        let signStr = \n            optSign \n            |>? string   // e.g. \"-\"\n\n        let fractionPartStr = \n            fractionPart \n            |>? (fun digits -> \".\" + digits )  // e.g. \".456\"\n\n        let expPartStr = \n            expPart \n            |>? fun (optSign, digits) ->\n                let sign = optSign |>? string\n                \"e\" + sign + digits          // e.g. \"e-12\"\n\n        // add the parts together and convert to a float, then wrap in a JNumber\n        (signStr + intPart + fractionPartStr + expPartStr)\n        |> float\n        |> JNumber\n\n    // set up the main parser\n    optSign .>>. intPart .>>. opt fractionPart .>>. opt exponentPart\n    |>> convertToJNumber\n    <?> \"number\"   // add label \n```", "```\nrun jNumber \"123\"     // JNumber 123.0\nrun jNumber \"-123\"    // JNumber -123.0\nrun jNumber \"123.4\"   // JNumber 123.4 \n```", "```\nrun jNumber \"-123.\"   // JNumber -123.0 -- should fail!\nrun jNumber \"00.1\"    // JNumber 0      -- should fail! \n```", "```\nlet jNumber_ = jNumber .>> spaces1 \n```", "```\nrun jNumber_ \"123\"     // JNumber 123.0\nrun jNumber_ \"-123\"    // JNumber -123.0\n\nrun jNumber_ \"-123.\" |> printResult\n// Line:0 Col:4 Error parsing number andThen many1 whitespace\n// -123.\n//     ^Unexpected '.' \n```", "```\nrun jNumber_ \"123.4\"   // JNumber 123.4\n\nrun jNumber_ \"00.4\" |> printResult\n// Line:0 Col:1 Error parsing number andThen many1 whitespace\n// 00.4\n//  ^Unexpected '0' \n```", "```\n// exponent only\nrun jNumber_ \"123e4\"     // JNumber 1230000.0\n\n// fraction and exponent \nrun jNumber_ \"123.4e5\"   // JNumber 12340000.0\nrun jNumber_ \"123.4e-5\"  // JNumber 0.001234 \n```", "```\nlet jArray = \n\n    let left = pchar '[' .>> spaces\n    let right = pchar ']' .>> spaces\n    let comma = pchar ',' .>> spaces\n    let value = jValue .>> spaces \n```", "```\nlet jArray = \n    ...\n\n    // set up the list parser\n    let values = sepBy1 value comma\n\n    // set up the main parser\n    between left values right \n    |>> JArray\n    <?> \"array\" \n```", "```\nlet jArray = \n    ...\n    let value = jValue .>> spaces    // <=== what is \"jValue\"?\n    ... \n```", "```\nlet createParserForwardedToRef<'a>() =\n\n    let dummyParser= \n        let innerFn input : Result<'a * Input> = failwith \"unfixed forwarded parser\"\n        {parseFn=innerFn; label=\"unknown\"}\n\n    // ref to placeholder Parser\n    let parserRef = ref dummyParser \n\n    // wrapper Parser\n    let innerFn input = \n        // forward input to the placeholder\n        runOnInput !parserRef input \n    let wrapperParser = {parseFn=innerFn; label=\"unknown\"}\n\n    wrapperParser, parserRef \n```", "```\nlet jValue,jValueRef = createParserForwardedToRef<JValue>() \n```", "```\nlet jArray = \n\n    // set up the \"primitive\" parsers \n    let left = pchar '[' .>> spaces\n    let right = pchar ']' .>> spaces\n    let comma = pchar ',' .>> spaces\n    let value = jValue .>> spaces   \n\n    // set up the list parser\n    let values = sepBy1 value comma\n\n    // set up the main parser\n    between left values right \n    |>> JArray\n    <?> \"array\" \n```", "```\nrun jArray \"[ 1, 2 ]\"\n\n// System.Exception: unfixed forwarded parser \n```", "```\njValueRef := jNumber \n```", "```\nrun jArray \"[ 1, 2 ]\"\n// Success (JArray [JNumber 1.0; JNumber 2.0],\n\nrun jArray \"[ 1, 2, ]\" |> printResult\n// Line:0 Col:6 Error parsing array\n// [ 1, 2, ]\n//       ^Unexpected ',' \n```", "```\nlet jObject = \n\n    // set up the \"primitive\" parsers \n    let left = pchar '{' .>> spaces\n    let right = pchar '}' .>> spaces\n    let colon = pchar ':' .>> spaces\n    let comma = pchar ',' .>> spaces\n    let key = quotedString .>> spaces \n    let value = jValue .>> spaces\n\n    // set up the list parser\n    let keyValue = (key .>> colon) .>>. value\n    let keyValues = sepBy1 keyValue comma\n\n    // set up the main parser\n    between left keyValues right \n    |>> Map.ofList  // convert the list of keyValues into a Map\n    |>> JObject     // wrap in JObject \n    <?> \"object\"    // add label \n```", "```\nrun jObject \"\"\"{ \"a\":1, \"b\"  :  2 }\"\"\"\n// JObject (map [(\"a\", JNumber 1.0); (\"b\", JNumber 2.0)]),\n\nrun jObject \"\"\"{ \"a\":1, \"b\"  :  2, }\"\"\" |> printResult\n// Line:0 Col:18 Error parsing object\n// { \"a\":1, \"b\"  :  2, }\n//                   ^Unexpected ',' \n```", "```\njValueRef := choice \n    [\n    jNull \n    jBool\n    jNumber\n    jString\n    jArray\n    jObject\n    ] \n```", "```\nlet example1 = \"\"\"{\n    \"name\" : \"Scott\",\n    \"isMale\" : true,\n    \"bday\" : {\"year\":2001, \"month\":12, \"day\":25 },\n    \"favouriteColors\" : [\"blue\", \"green\"]\n}\"\"\"\nrun jValue example1 \n```", "```\nJObject\n    (map\n        [(\"bday\", JObject(map\n                [(\"day\", JNumber 25.0); \n                (\"month\", JNumber 12.0);\n                (\"year\", JNumber 2001.0)]));\n        (\"favouriteColors\", JArray [JString \"blue\"; JString \"green\"]);\n        (\"isMale\", JBool true); \n        (\"name\", JString \"Scott\")\n        ]) \n```", "```\nlet example2= \"\"\"{\"widget\": {\n    \"debug\": \"on\",\n    \"window\": {\n        \"title\": \"Sample Konfabulator Widget\",\n        \"name\": \"main_window\",\n        \"width\": 500,\n        \"height\": 500\n    },\n    \"image\": { \n        \"src\": \"Images/Sun.png\",\n        \"name\": \"sun1\",\n        \"hOffset\": 250,\n        \"vOffset\": 250,\n        \"alignment\": \"center\"\n    },\n    \"text\": {\n        \"data\": \"Click Here\",\n        \"size\": 36,\n        \"style\": \"bold\",\n        \"name\": \"text1\",\n        \"hOffset\": 250,\n        \"vOffset\": 100,\n        \"alignment\": \"center\",\n        \"onMouseUp\": \"sun1.opacity = (sun1.opacity / 100) * 90;\"\n    }\n}}  \"\"\"\n\nrun jValue example2 \n```", "```\nJObject(map\n    [(\"widget\",JObject(map\n            [(\"debug\", JString \"on\");\n            (\"image\",JObject(map\n                [(\"alignment\", JString \"center\");\n                    (\"hOffset\", JNumber 250.0); (\"name\", JString \"sun1\");\n                    (\"src\", JString \"Images/Sun.png\");\n                    (\"vOffset\", JNumber 250.0)]));\n            (\"text\",JObject(map\n                [(\"alignment\", JString \"center\");\n                    (\"data\", JString \"Click Here\");\n                    (\"hOffset\", JNumber 250.0); \n                    (\"name\", JString \"text1\");\n                    (\"onMouseUp\", JString \"sun1.opacity = (sun1.opacity / 100) * 90;\");\n                    (\"size\", JNumber 36.0); \n                    (\"style\", JString \"bold\");\n                    (\"vOffset\", JNumber 100.0)]));\n            (\"window\",JObject(map\n                [(\"height\", JNumber 500.0);\n                    (\"name\", JString \"main_window\");\n                    (\"title\", JString \"Sample Konfabulator Widget\");\n                    (\"width\", JNumber 500.0)]))]))]), \n```", "```\n#load \"ParserLibrary.fsx\"\n\nopen System\nopen ParserLibrary\n\n(*\n// --------------------------------\nJSON spec from http://www.json.org/\n// --------------------------------\n\nThe JSON spec is available at [json.org](http://www.json.org/). I'll paraphase it here:\n\n* A `value` can be a `string` or a `number` or a `bool` or `null` or an `object` or an `array`. \n  * These structures can be nested.\n* A `string` is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. \n* A `number` is very much like a C or Java number, except that the octal and hexadecimal formats are not used.\n* A `boolean` is the literal `true` or `false`\n* A `null` is the literal `null`\n* An `object` is an unordered set of name/value pairs. \n  * An object begins with { (left brace) and ends with } (right brace). \n  * Each name is followed by : (colon) and the name/value pairs are separated by , (comma).\n* An `array` is an ordered collection of values. \n  * An array begins with [ (left bracket) and ends with ] (right bracket). \n  * Values are separated by , (comma).\n* Whitespace can be inserted between any pair of tokens. \n\n*)\n\ntype JValue = \n    | JString of string\n    | JNumber of float\n    | JBool   of bool\n    | JNull\n    | JObject of Map<string, JValue>\n    | JArray  of JValue list\n\n// ======================================\n// Forward reference\n// ======================================\n\n/// Create a forward reference\nlet createParserForwardedToRef<'a>() =\n\n    let dummyParser= \n        let innerFn input : Result<'a * Input> = failwith \"unfixed forwarded parser\"\n        {parseFn=innerFn; label=\"unknown\"}\n\n    // ref to placeholder Parser\n    let parserRef = ref dummyParser \n\n    // wrapper Parser\n    let innerFn input = \n        // forward input to the placeholder\n        runOnInput !parserRef input \n    let wrapperParser = {parseFn=innerFn; label=\"unknown\"}\n\n    wrapperParser, parserRef\n\nlet jValue,jValueRef = createParserForwardedToRef<JValue>()\n\n// ======================================\n// Utility function\n// ======================================\n\n// applies the parser p, ignores the result, and returns x.\nlet (>>%) p x =\n    p |>> (fun _ -> x)\n\n// ======================================\n// Parsing a JNull\n// ======================================\n\nlet jNull = \n    pstring \"null\" \n    >>% JNull   // map to JNull\n    <?> \"null\"  // give it a label\n\n// ======================================\n// Parsing a JBool\n// ======================================\n\nlet jBool =   \n    let jtrue = \n        pstring \"true\" \n        >>% JBool true   // map to JBool\n    let jfalse = \n        pstring \"false\" \n        >>% JBool false  // map to JBool \n\n    // choose between true and false\n    jtrue <|> jfalse\n    <?> \"bool\"           // give it a label\n\n// ======================================\n// Parsing a JString\n// ======================================\n\n/// Parse an unescaped char\nlet jUnescapedChar = \n    satisfy (fun ch -> ch <> '\\\\' && ch <> '\\\"') \"char\"\n\n/// Parse an escaped char\nlet jEscapedChar = \n    [ \n    // (stringToMatch, resultChar)\n    (\"\\\\\\\"\",'\\\"')      // quote\n    (\"\\\\\\\\\",'\\\\')      // reverse solidus \n    (\"\\\\/\",'/')        // solidus\n    (\"\\\\b\",'\\b')       // backspace\n    (\"\\\\f\",'\\f')       // formfeed\n    (\"\\\\n\",'\\n')       // newline\n    (\"\\\\r\",'\\r')       // cr\n    (\"\\\\t\",'\\t')       // tab\n    ] \n    // convert each pair into a parser\n    |> List.map (fun (toMatch,result) -> \n        pstring toMatch >>% result)\n    // and combine them into one\n    |> choice\n\n/// Parse a unicode char\nlet jUnicodeChar = \n\n    // set up the \"primitive\" parsers        \n    let backslash = pchar '\\\\'\n    let uChar = pchar 'u'\n    let hexdigit = anyOf (['0'..'9'] @ ['A'..'F'] @ ['a'..'f'])\n\n    // convert the parser output (nested tuples)\n    // to a char\n    let convertToChar (((h1,h2),h3),h4) = \n        let str = sprintf \"%c%c%c%c\" h1 h2 h3 h4\n        Int32.Parse(str,Globalization.NumberStyles.HexNumber) |> char\n\n    // set up the main parser\n    backslash  >>. uChar >>. hexdigit .>>. hexdigit .>>. hexdigit .>>. hexdigit\n    |>> convertToChar \n\n/// Parse a quoted string\nlet quotedString = \n    let quote = pchar '\\\"' <?> \"quote\"\n    let jchar = jUnescapedChar <|> jEscapedChar <|> jUnicodeChar \n\n    // set up the main parser\n    quote >>. manyChars jchar .>> quote \n\n/// Parse a JString\nlet jString = \n    // wrap the string in a JString\n    quotedString\n    |>> JString           // convert to JString\n    <?> \"quoted string\"   // add label\n\n// ======================================\n// Parsing a JNumber\n// ======================================\n\n/// Parse a JNumber\nlet jNumber = \n\n    // set up the \"primitive\" parsers        \n    let optSign = opt (pchar '-')\n\n    let zero = pstring \"0\"\n\n    let digitOneNine = \n        satisfy (fun ch -> Char.IsDigit ch && ch <> '0') \"1-9\"\n\n    let digit = \n        satisfy (fun ch -> Char.IsDigit ch ) \"digit\"\n\n    let point = pchar '.'\n\n    let e = pchar 'e' <|> pchar 'E'\n\n    let optPlusMinus = opt (pchar '-' <|> pchar '+')\n\n    let nonZeroInt = \n        digitOneNine .>>. manyChars digit \n        |>> fun (first,rest) -> string first + rest\n\n    let intPart = zero <|> nonZeroInt\n\n    let fractionPart = point >>. manyChars1 digit\n\n    let exponentPart = e >>. optPlusMinus .>>. manyChars1 digit\n\n    // utility function to convert an optional value to a string, or \"\" if missing\n    let ( |>? ) opt f = \n        match opt with\n        | None -> \"\"\n        | Some x -> f x\n\n    let convertToJNumber (((optSign,intPart),fractionPart),expPart) = \n        // convert to strings and let .NET parse them! - crude but ok for now.\n\n        let signStr = \n            optSign \n            |>? string   // e.g. \"-\"\n\n        let fractionPartStr = \n            fractionPart \n            |>? (fun digits -> \".\" + digits )  // e.g. \".456\"\n\n        let expPartStr = \n            expPart \n            |>? fun (optSign, digits) ->\n                let sign = optSign |>? string\n                \"e\" + sign + digits          // e.g. \"e-12\"\n\n        // add the parts together and convert to a float, then wrap in a JNumber\n        (signStr + intPart + fractionPartStr + expPartStr)\n        |> float\n        |> JNumber\n\n    // set up the main parser\n    optSign .>>. intPart .>>. opt fractionPart .>>. opt exponentPart\n    |>> convertToJNumber\n    <?> \"number\"   // add label\n\n// ======================================\n// Parsing a JArray\n// ======================================\n\nlet jArray = \n\n    // set up the \"primitive\" parsers        \n    let left = pchar '[' .>> spaces\n    let right = pchar ']' .>> spaces\n    let comma = pchar ',' .>> spaces\n    let value = jValue .>> spaces   \n\n    // set up the list parser\n    let values = sepBy1 value comma\n\n    // set up the main parser\n    between left values right \n    |>> JArray\n    <?> \"array\"\n\n// ======================================\n// Parsing a JObject\n// ======================================\n\nlet jObject = \n\n    // set up the \"primitive\" parsers        \n    let left = pchar '{' .>> spaces\n    let right = pchar '}' .>> spaces\n    let colon = pchar ':' .>> spaces\n    let comma = pchar ',' .>> spaces\n    let key = quotedString .>> spaces \n    let value = jValue .>> spaces\n\n    // set up the list parser\n    let keyValue = (key .>> colon) .>>. value\n    let keyValues = sepBy1 keyValue comma\n\n    // set up the main parser\n    between left keyValues right \n    |>> Map.ofList  // convert the list of keyValues into a Map\n    |>> JObject     // wrap in JObject     \n    <?> \"object\"    // add label\n\n// ======================================\n// Fixing up the jValue ref\n// ======================================\n\n// fixup the forward ref\njValueRef := choice \n    [\n    jNull \n    jBool\n    jNumber\n    jString\n    jArray\n    jObject\n    ] \n```"]