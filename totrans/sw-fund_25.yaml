- en: StlcPropProperties of STLC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Types.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: Module STLCProp.
  prefs: []
  type: TYPE_NORMAL
- en: Import STLC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Canonical Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw for the simple calculus in the [Types](Types.html) chapter, the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: first step in establishing basic properties of reduction and types
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is to identify the possible *canonical forms* (i.e., well-typed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: closed values) belonging to each type.  For Bool, these are the boolean
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values ttrue and tfalse.  For arrow types, the canonical forms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are lambda-abstractions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *progress* theorem tells us that closed, well-typed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'terms are not stuck: either a well-typed term is a value, or it'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can take a reduction step.  The proof is a relatively
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: straightforward extension of the progress proof we saw in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Types](Types.html) chapter.  We''ll give the proof in English first, then'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the formal version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Proof*: By induction on the derivation of ⊢ t ∈ T.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last rule of the derivation cannot be T_Var, since a variable is never well
    typed in an empty context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The T_True, T_False, and T_Abs cases are trivial, since in each of these cases
    we can see by inspecting the rule that t is a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the last rule of the derivation is T_App, then t has the form t[1] t[2] for
    some t[1] and t[2], where ⊢ t[1] ∈ T[2] → T and ⊢ t[2] ∈ T[2] for some type T[2].
    By the induction hypothesis, either t[1] is a value or it can take a reduction
    step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If t[1] is a value, then consider t[2], which by the other induction hypothesis
    must also either be a value or take a step.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose t[2] is a value. Since t[1] is a value with an arrow type, it must be
    a lambda abstraction; hence t[1] t[2] can take a step by ST_AppAbs.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, t[2] can take a step, and hence so can t[1] t[2] by ST_App2.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If t[1] can take a step, then so can t[1] t[2] by ST_App1.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the last rule of the derivation is T_If, then t = if t[1] then t[2] else
    t[3], where t[1] has type Bool. By the IH, t[1] either is a value or takes a step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If t[1] is a value, then since it has type Bool it must be either true or false.
    If it is true, then t steps to t[2]; otherwise it steps to t[3].
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, t[1] takes a step, and therefore so does t (by ST_If).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, advanced (progress_from_term_ind)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show that progress can also be proved by induction on terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: instead of induction on typing derivations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Free Occurrences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variable x *appears free in* a term *t* if t contains some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: occurrence of x that is not under an abstraction labeled x.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: y appears free, but x does not, in \x:T→U. x y
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: both x and y appear free in (λx:T→U. x y) x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: no variables appear free in \x:T→U. \y:T. x y
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Formally:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The *free variables* of a term are just the variables that appear
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: free in it.  A term with no free variables is said to be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*closed*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: An *open* term is one that is not closed (or not known to be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: closed).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 starM (afi)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the space below, write out the rules of the appears_free_in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation in informal inference-rule notation.  (Use whatever
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: notational conventions you like — the point of the exercise is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: just for you to think a bit about the meaning of each rule.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although this is a rather low-level, technical definition,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: understanding it is crucial to understanding substitution and its
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: properties, which are really the crux of the lambda-calculus.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma free_in_context : ∀x t T Γ,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: Γ ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: ∃T', Γ x = Some T'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros x t T Γ H H[0]. generalize dependent Γ.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent T.
  prefs: []
  type: TYPE_NORMAL
- en: induction H;
  prefs: []
  type: TYPE_NORMAL
- en: intros; try solve [inversion H[0]; eauto].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* afi_abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[1]; subst.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHappears_free_in in H[7].
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [update_neq](Maps.html#update_neq) in H[7]; assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Corollary typable_empty__closed : ∀t T,'
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ t ∈ T  →
  prefs: []
  type: TYPE_NORMAL
- en: closed t.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Sometimes, when we have a proof Γ ⊢ t : T, we will need to'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: replace Γ by a different context Γ'.  When is it safe
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to do this?  Intuitively, it must at least be the case that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Γ' assigns the same types as Γ to all the variables
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that appear free in t. In fact, this is the only condition that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Proof*: By induction on the derivation of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Γ ⊢ t ∈ T.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the last rule in the derivation was T_Var, then t = x and Γ x = T. By assumption,
    Γ' x = T as well, and hence Γ' ⊢ t ∈ T by T_Var.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the last rule was T_Abs, then t = \y:T[11]. t[12], with T = T[11] → T[12]
    and Γ, y:T[11] ⊢ t[12] ∈ T[12]. The induction hypothesis is that, for any context
    Γ'', if Γ, y:T[11] and Γ'' assign the same types to all the free variables in
    t[12], then t[12] has type T[12] under Γ''. Let Γ' be a context which agrees with
    Γ on the free variables in t; we must show Γ' ⊢ \y:T[11]. t[12] ∈ T[11] → T[12].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By T_Abs, it suffices to show that Γ', y:T[11] ⊢ t[12] ∈ T[12]. By the IH (setting
    Γ'' = Γ', y:T[11]), it suffices to show that Γ, y:T[11] and Γ', y:T[11] agree
    on all the variables that appear free in t[12].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Any variable occurring free in t[12] must be either y or some other variable.
    Γ, y:T[11] and Γ', y:T[11] clearly agree on y. Otherwise, note that any variable
    other than y that occurs free in t[12] also occurs free in t = \y:T[11]. t[12],
    and by assumption Γ and Γ' agree on all such variables; hence so do Γ, y:T[11]
    and Γ', y:T[11].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the last rule was T_App, then t = t[1] t[2], with Γ ⊢ t[1] ∈ T[2] → T and
    Γ ⊢ t[2] ∈ T[2]. One induction hypothesis states that for all contexts Γ', if
    Γ' agrees with Γ on the free variables in t[1], then t[1] has type T[2] → T under
    Γ'; there is a similar IH for t[2]. We must show that t[1] t[2] also has type
    T under Γ', given the assumption that Γ' agrees with Γ on all the free variables
    in t[1] t[2]. By T_App, it suffices to show that t[1] and t[2] each have the same
    type under Γ' as under Γ. But all free variables in t[1] are also free in t[1]
    t[2], and similarly for t[2]; hence the desired result follows from the induction
    hypotheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we come to the conceptual heart of the proof that reduction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: preserves types — namely, the observation that *substitution*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: preserves types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Formally, the so-called *substitution lemma* says this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suppose we have a term t with a free variable x, and suppose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we've assigned a type T to t under the assumption that x has
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: some type U.  Also, suppose that we have some other term v and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that we've shown that v has type U.  Then, since v satisfies
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the assumption we made about x when typing t, we can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: substitute v for each of the occurrences of x in t and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: obtain a new term that still has type T.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Lemma*: If Γ,x:U ⊢ t ∈ T and ⊢ v ∈ U, then Γ ⊢ [x:=v]t ∈ T.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: One technical subtlety in the statement of the lemma is that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we assign v the type U in the *empty* context — in other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: words, we assume v is closed.  This assumption considerably
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplifies the T_Abs case of the proof (compared to assuming
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Γ ⊢ v ∈ U, which would be the other reasonable assumption
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: at this point) because the context invariance lemma then tells us
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that v has type U in any context at all — we don't have to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: worry about free variables in v clashing with the variable being
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: introduced into the context by T_Abs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The substitution lemma can be viewed as a kind of commutation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: property.  Intuitively, it says that substitution and typing can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'be done in either order: we can either assign types to the terms'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: t and v separately (under suitable contexts) and then combine
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: them using substitution, or we can substitute first and then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assign a type to [x:=v] t — the result is the same either
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Proof*: We show, by induction on t, that for all T and'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Γ, if Γ,x:U ⊢ t ∈ T and ⊢ v ∈ U, then Γ ⊢ [x:=v]t ∈ T.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If t is a variable there are two cases to consider, depending on whether t is
    x or some other variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If t = x, then from the fact that Γ, x:U ⊢ x ∈ T we conclude that U = T. We
    must show that [x:=v]x = v has type T under Γ, given the assumption that v has
    type U = T under the empty context. This follows from context invariance: if a
    closed term has type T in the empty context, it has that type in any context.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If t is some variable y that is not equal to x, then we need only note that
    y has the same type under Γ, x:U as under Γ.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If t is an abstraction \y:T[11]. t[12], then the IH tells us, for all Γ' and
    T', that if Γ',x:U ⊢ t[12] ∈ T' and ⊢ v ∈ U, then Γ' ⊢ [x:=v]t[12] ∈ T'.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The substitution in the conclusion behaves differently depending on whether
    x and y are the same variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, suppose x = y. Then, by the definition of substitution, [x:=v]t = t,
    so we just need to show Γ ⊢ t ∈ T. But we know Γ,x:U ⊢ t : T, and, since y does
    not appear free in \y:T[11]. t[12], the context invariance lemma yields Γ ⊢ t
    ∈ T.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Second, suppose x ≠ y. We know Γ,x:U,y:T[11] ⊢ t[12] ∈ T[12] by inversion of
    the typing relation, from which Γ,y:T[11],x:U ⊢ t[12] ∈ T[12] follows by the context
    invariance lemma, so the IH applies, giving us Γ,y:T[11] ⊢ [x:=v]t[12] ∈ T[12].
    By T_Abs, Γ ⊢ \y:T[11]. [x:=v]t[12] ∈ T[11]→T[12], and by the definition of substitution
    (noting that x ≠ y), Γ ⊢ \y:T[11]. [x:=v]t[12] ∈ T[11]→T[12] as required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If t is an application t[1] t[2], the result follows straightforwardly from
    the definition of substitution and the induction hypotheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining cases are similar to the application case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Technical note*: This proof is a rare case where an'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction on terms, rather than typing derivations, yields a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simpler argument.  The reason for this is that the assumption
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: update Γ x U ⊢ t ∈ T is not completely generic, in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sense that one of the "slots" in the typing relation — namely the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: context — is not just a variable, and this means that Coq's
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: native induction tactic does not give us the induction hypothesis
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that we want.  It is possible to work around this, but the needed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: generalization is a little tricky.  The term t, on the other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hand, is completely generic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Main Theorem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have the tools we need to prove preservation: if a closed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: term t has type T and takes a step to t', then t'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is also a closed term with type T.  In other words, the small-step
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reduction relation preserves types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Proof*: By induction on the derivation of ⊢ t ∈ T.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can immediately rule out T_Var, T_Abs, T_True, and T_False as the final rules
    in the derivation, since in each of these cases t cannot take a step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the last rule in the derivation is T_App, then t = t[1] t[2]. There are three
    cases to consider, one for each rule that could be used to show that t[1] t[2]
    takes a step to t'.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If t[1] t[2] takes a step by ST_App1, with t[1] stepping to t[1]', then by the
    IH t[1]' has the same type as t[1], and hence t[1]' t[2] has the same type as
    t[1] t[2].
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The ST_App2 case is similar.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If t[1] t[2] takes a step by ST_AppAbs, then t[1] = \x:T[11].t12 and t[1] t[2]
    steps to [x:=t[2]]t[12]; the desired result now follows from the fact that substitution
    preserves types.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the last rule in the derivation is T_If, then t = if t[1] then t[2] else
    t[3], and there are again three cases depending on how t steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If t steps to t[2] or t[3], the result is immediate, since t[2] and t[3] have
    the same type as t.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, t steps by ST_If, and the desired conclusion follows directly from
    the induction hypothesis.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, recommendedM (subject_expansion_stlc)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An exercise in the [Types](Types.html) chapter asked about the *subject expansion*
    property for the simple language of arithmetic and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: boolean expressions.  Does this property hold for STLC?  That is,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is it always the case that, if t ⇒ t' and has_type t' T,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then empty ⊢ t ∈ T?  If so, prove it.  If not, give a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: counter-example not involving conditionals.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition stuck (t:tm) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: (normal_form step) t ∧ ¬ value t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Corollary soundness : ∀t t'' T,'
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: t ⇒* t' →
  prefs: []
  type: TYPE_NORMAL
- en: ~(stuck t').
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t t' T Hhas_type Hmulti. unfold [stuck](StlcProp.html#STLCProp.stuck).
  prefs: []
  type: TYPE_NORMAL
- en: intros [Hnf Hnot_val]. unfold [normal_form](Smallstep.html#normal_form) in Hnf.
  prefs: []
  type: TYPE_NORMAL
- en: induction Hmulti.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Uniqueness of Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exercise: 3 starsM (types_unique)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another nice property of the STLC is that types are unique: a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given term (in a given context) has at most one type.  Formalize this statement
    and prove it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: End STLCProp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Module STLCArith.
  prefs: []
  type: TYPE_NORMAL
- en: Import STLC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive ty : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| TArrow : ty → ty → ty'
  prefs: []
  type: TYPE_NORMAL
- en: '| TNat   : ty.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive tm : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| tvar : id → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tapp : tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tabs : id → ty → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tnat  : nat → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tsucc : tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tpred : tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tmult : tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tif0  : tm → tm → tm → tm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: End STLCArith.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
