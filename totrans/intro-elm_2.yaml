- en: Core Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Core Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will walk you through Elm's simple core language.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works best when you follow along, so after [installing](install.html),
    start up `elm-repl` in the terminal. (Or use the [online REPL](http://elmrepl.cuberoot.in/).)
    Either way, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The REPL prints out the type of every result, but **we will leave the type annotations
    off in this tutorial** for the sake of introducing concepts gradually.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover [values](#values), [functions](#functions), [lists](#lists), [tuples](#tuples),
    and [records](#records). These building blocks all correspond pretty closely with
    structures in languages like JavaScript, Python, and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started with some strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Elm uses the `(++)` operator to put strings together. Notice that both strings
    are preserved exactly as is when they are put together so when we combine `"hello"`
    and `"world"` the result has no spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Math looks normal too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unlike JavaScript, Elm makes a distinction between integers and floating point
    numbers. Just like Python 3, there is both floating point division `(/)` and integer
    division `(//)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by writing a function `isNegative` that takes in some number and
    checks if it is less than zero. The result will be `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that function application looks different than in languages like JavaScript
    and Python and Java. Instead of wrapping all arguments in parentheses and separating
    them with commas, we use spaces to apply the function. So `(add(3,4))` becomes
    `(add 3 4)` which ends up avoiding a bunch of parens and commas as things get
    bigger. Ultimately, this looks much cleaner once you get used to it! [The elm-html
    package](http://elm-lang.org/blog/blazing-fast-html) is a good example of how
    this keeps things feeling light.
  prefs: []
  type: TYPE_NORMAL
- en: If Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you want to have conditional behavior in Elm, you use an if-expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The keywords `if` `then` `else` are used to separate the conditional and the
    two branches so we do not need any parentheses or curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Elm does not have a notion of “truthiness” so numbers and strings and lists
    cannot be used as boolean values. If we try it out, Elm will tell us that we need
    to work with a real boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's make a function that tells us if a number is over 9000.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using a backslash in the REPL lets us split things on to multiple lines. We
    use this in the definition of `over9000` above. Furthermore, it is best practice
    to always bring the body of a function down a line. It makes things a lot more
    uniform and easy to read, so you want to do this with all the functions and values
    you define in normal code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Make sure that you add a whitespace before the second line of the
    function. Elm has a "syntactically significant whitespace" meaning that indentation
    is a part of its syntax.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lists are one of the most common data structures in Elm. They hold a sequence
    of related things, similar to arrays in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists can hold many values. Those values must all have the same type. Here
    are a few examples that use functions from [the `List` library](http://package.elm-lang.org/packages/elm-lang/core/latest/List):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Again, all elements of the list must have the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tuples are another useful data structure. A tuple can hold a fixed number of
    values, and each value can have any type. A common use is if you need to return
    more than one value from a function. The following function gets a name and gives
    a message for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This can be quite handy, but when things start becoming more complicated, it
    is often best to use records instead of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A record is a set of key-value pairs, similar to objects in JavaScript or Python.
    You will find that they are extremely common and useful in Elm! Let's see some
    basic examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So we can create records using curly braces and access fields using a dot. Elm
    also has a version of record access that works like a function. By starting the
    variable with a dot, you are saying *please access the field with the following
    name*. This means that `.name` is a function that gets the `name` field of the
    record.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When it comes to making functions with records, you can do some pattern matching
    to make things a bit lighter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So we can pass any record in as long as it has an `age` field that holds a number.
  prefs: []
  type: TYPE_NORMAL
- en: It is often useful to update the values in a record.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is important to notice that we do not make *destructive* updates. When we
    update some fields of `bill` we actually create a new record rather than overwriting
    the existing one. Elm makes this efficient by sharing as much content as possible.
    If you update one of ten fields, the new record will share the nine unchanged
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Records and Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Records in Elm are *similar* to objects in JavaScript, but there are some crucial
    differences. The major differences are that with records:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot ask for a field that does not exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No field will ever be undefined or null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot create recursive records with a `this` or `self` keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elm encourages a strict separation of data and logic, and the ability to say
    `this` is primarily used to break this separation. This is a systemic problem
    in Object Oriented languages that Elm is purposely avoiding.
  prefs: []
  type: TYPE_NORMAL
- en: Records also support [structural typing](https://en.wikipedia.org/wiki/Structural_type_system
    "Structural Types") which means records in Elm can be used in any situation as
    long as the necessary fields exist. This gives us flexibility without compromising
    reliability.
  prefs: []
  type: TYPE_NORMAL
