- en: Dynamic Storage Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lecture Notes for CS 140
  prefs: []
  type: TYPE_NORMAL
- en: Spring 2014
  prefs: []
  type: TYPE_NORMAL
- en: John Ousterhout
  prefs: []
  type: TYPE_NORMAL
- en: 'Readings for this topic from *Operating Systems: Principles and Practice*:
    none.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static memory allocation is simple and convenient, but it's not sufficient for
    everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two basic operations in dynamic storage management:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocate a given number of bytes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Free a previously allocated block
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two general approaches to dynamic storage allocation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stack allocation (hierarchical): restricted, but simple and efficient.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heap allocation: more general, but more difficult to implement, less efficient.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack Allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A stack can be used when memory allocation and freeing are partially predictable:
    memory is freed in opposite order from allocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example: procedure call. X calls Y calls Y again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stacks are also useful for lots of other things: tree traversal, expression
    evaluation, top-down recursive descent parsers, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stack-based organization keeps all the free space together in one place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap Allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heap allocation must be used when allocation and release are unpredictable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory consists of allocated areas and free areas (or holes). Inevitably end
    up with lots of holes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Goal: reuse the space in holes to keep the number of holes small, keep their
    size large.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fragmentation*: inefficient use of memory because of lots of small holes.
    Stack allocation is perfect: all free space is in one large hole.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heap allocators must keep track of the storage that is not in use: *free list*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Best fit*: keep linked list of free blocks, search the whole list on each
    allocation, choose block that comes closest to matching the needs of the allocation,
    save the excess for later. During release operations, merge adjacent free blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*First fit*: just scan list for the first hole that is large enough. Free excess.
    Also merge on releases. Most first fit implementations are rotating first fit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Problem: over time, holes tend to fragment, approaching the size of the smallest
    objects allocated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bit map*: alternate representation of the free list, useful if storage comes
    in fixed-size chunks (e.g. disk blocks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a large array of bits, one for each chunk.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If bit is 0 it means chunk is in use, if bit is 1 it means chunk is free.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pools*: keep a separate linked list for each popular size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocation is fast, no fragmentation.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What's wrong with this?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage Reclamation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do we know when dynamically-allocated memory can be freed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy when a chunk is only used in one place.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reclamation is hard when information is shared: it can''t be recycled until
    all of the users are finished.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage is indicated by the presence of *pointers* to the data. Without a pointer,
    can't access (can't find it).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two problems in reclamation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dangling pointers: better not recycle storage while it''s still being used.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory leaks: storage gets "lost" because no one freed it even though it can''t
    ever be used again.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reference counts*: keep count of the number of outstanding pointers to each
    chunk of memory. When this becomes zero, free the memory. Example: Smalltalk,
    file descriptors in Unix.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Garbage collection*: storage isn''t freed explicitly (using free operation),
    but rather implicitly: just delete pointers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the system needs storage, it searches through all of the pointers (must
    be able to find them all!) and collects things that aren't used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If structures are circular then this is the only way to reclaim space.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collectors typically *compact* memory, moving objects to coalesce all
    free space.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One way to implement garbage collection: *mark and copy*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be able to find all objects.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be able to find all pointers to objects.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pass 1: mark. Go through all statically-allocated and procedure-local variables,
    looking for pointers (*roots*). Mark each object pointed to, and recursively mark
    all objects it points to. The compiler has to cooperate by saving information
    about where the pointers are within structures.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pass 2: copy and compact. Go through all objects, copy live Objects into contiguous
    memory; then free any remaining space.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Garbage collection is often expensive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10-20% of all CPU time in systems that use it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uses memory inefficiently: 2-5x overallocation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
