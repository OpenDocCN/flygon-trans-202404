- en: Argus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6.824 2015 Lecture 20: Argus'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.824 [course website](http://nil.csail.mit.edu/6.824/2015/schedule.html)
    from Spring 2015.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Atomic commit: two-phase commit'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: how to use two-phase commit for distributed transactions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a bunch of computers that do different things (not replicas). Like
    two computers, one stores events for people in A-L, another for people in M-Z.
    If you want to create an event for Alice and Mike you need to interact with both
    servers and make sure that the event is either created on both or on neither.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: The challenges are *crashes* and *network failures* which inject ambiguities
    ( not responding cause of crash or network failure?)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: In Ivy and TreadMarks if one of the machines crashed it had no way to recover.
    We also saw MapReduce and Spark which had a story for crash recovery.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Idea 1: tentative changes'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Idea 2: single machine/entity (transaction coordinator) decides'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Properties:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'state: unknown, committed, aborted'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if any thinks "committed", then none think "aborted"
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if any think "aborted", then none think "committed"
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two-phase commit (2PC)
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Used frequently in real distributed databases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Prepare` asks "are you still alive and willing to commit this transaction?"'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: servers may say no
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: servers may be unreachable
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Termination protocol
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: maybe the TC has a timeout while it's waiting for the yes/no response to one
    or more prepare messages
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: at this point, it can abort the transaction, because no one has started a commit
    (since the TC did not send it, since it was waiting on yes/no)
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: B times out while waiting for prepare message
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` B hasn''t replied to prepare `=>` TC hasn''t sent commit to the participants
    `=>` TC can send abort'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: B times out waiting for commit/abort after saying *no* to prepare
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` B can abort because it knows the TC will abort everyone'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: B times out waiting for commit/abort after saying *yes* to prepare
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=>` B said yes to TC and TC could have received `yes` from everyone else (or
    not) `=>` outcome can be either commit or abort `=>` B has to wait'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: there are some lucky cases in which `B` could decide to abort/commit if `A`
    tells it via another channel
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this waiting make 2PC impractical? People are split up?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: What about reboots? If one of the participants said yes to a prepare, it has
    to remember that across reboots or crashes, so that it can be able to finish the
    transaction (commit or abort).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: in the calendar example, it would also need to remember the tentative schedule
    in `tent[]`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'extra note: since in the diagram the TC did not wait for ACKs on commit/abort
    the participants need to persist their locks around the transaction so that they
    don''t do a subsequent transaction before this one is finished'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if TC crashes in the middle of sending commits?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: it has to remember all committed/non-committed transactions
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resemblance to Paxos?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Paxos is a way to build highly available systems by replication (all servers
    have all data and are doing the same thing)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paxos是通过复制构建高可用系统的一种方式（所有服务器都拥有所有数据并执行相同的操作）。
- en: Paxos system can proceed even if some of the servers are down
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使一些服务器宕机，Paxos系统也可以继续运行
- en: 2PC you cannot make progress even if just one server is down
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使只有一个服务器宕机，2PC也无法取得进展
- en: each server is doing a *different thing* (want every server to do its own part
    in a transaction)
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务器都在执行*不同的操作*（希望每个服务器在事务中执行自己的部分）
- en: While 2PC helps a set of servers reach agreement, it it not fault tolerant or
    available (it cannot proceed when servers are down)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然2PC帮助一组服务器达成一致，但它不具备容错性或可用性（当服务器宕机时无法继续进行）。
- en: You might think you can do the calendar scheduling with Paxos by having both
    servers agree on the schedule op. However, while agreeing on the op will work,
    committing the op will not. For instance, what if one server's user is busy during
    the scheduled time? Then it cannot commit the op while the other one might be
    able to. Paxos doesn't help solve that conflict.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能认为可以通过Paxos来进行日历调度，让两个服务器就日程安排达成一致。然而，虽然就操作达成一致是可行的，但提交操作却不行。例如，如果一个服务器的用户在预定时间忙碌，那么它无法提交操作，而另一个可能可以。Paxos无法解决这种冲突。
- en: 'Atomic distributed transactions: write your transaction code without thinking
    about what other transactions could be going on'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 原子分布式事务：编写事务代码时不考虑其他可能正在进行的事务。
- en: 'Bank example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 银行示例：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is called *serializability*: The effect of running a bunch of transactions
    is the same as if they were run in some sequential order (no interleaving allowed:
    exec first half of T1, exec first half of T2, finish second half of T1, finish
    T2).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*可串行性*：运行一系列事务的效果与它们按某种顺序运行的效果相同（不允许交错：执行T1的前半部分，执行T2的前半部分，完成T1的后半部分，完成T2）。
- en: One way to implement transactions is to use locks for each data record that
    are acquired before a transaction begins operating on those records and holds
    them until it commits or aborts. This is called **two-phase locking**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实现事务的一种方式是在事务开始操作这些记录之前获取每个数据记录的锁，并在提交或中止之前一直持有这些锁。这被称为**两阶段锁定**。
- en: 'Deadlock can occur if T1 acquires x and then y while T2 acquires y and then
    x. Database systems for instance have ways to deal with this::'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果T1先获取x然后获取y，而T2先获取y然后获取x，就会发生死锁。例如，数据库系统有处理这种情况的方法：
- en: timeout on acquiring locks and retry
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取锁时设置超时并重试
- en: only allow transactions to acquire locks in a certain order
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许事务按特定顺序获取锁
- en: perform deadlock detection if single-machine setup
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是单机设置，则执行死锁检测
- en: Nobody ever likes to use 2PC.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人喜欢使用2PC。
- en: because of the waiting/blocking issue when a server times out waiting for a
    commit/abort after having said "no" to a prepare
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当服务器在准备阶段回复“否”后超时等待提交/中止时，会出现等待/阻塞问题。
- en: When participants acquire locks they are holding them across multiple RTTs in
    the network because you have to wait for the commit message.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当参与者获取锁时，它们在网络中跨越多个RTT持有这些锁，因为你必须等待提交消息。
- en: Argus
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Argus
- en: the cool thing is that it attempts to absorb as much of the nitty-gritty junk
    of distributed systems programming inside the language
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人兴奋的是，它试图将分布式系统编程的许多细节混杂在语言内部
- en: the desire was to have a clean story for handling RPC failures
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望是为处理RPC失败提供一个清晰的解决方案。
- en: Argus sets up a framework where RPC failures can be handled cleanly
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argus建立了一个框架，可以清晰地处理RPC失败。
- en: does all the bookkeeping required to rollback the transactions
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行所有必要的工作以回滚事务
- en: Argus has to know about the data in order to be able to rollback
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argus必须了解数据才能进行回滚操作。
- en: it needs to create tentative updates and so on
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要创建临时更新等等
- en: 6.824 notes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.824笔记
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
