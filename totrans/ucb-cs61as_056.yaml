- en: Example - Playing Cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How cool would it be if we could represent a card game using abstract data types?
    Let's create a more complex interface than rational numbers that will allow us
    to represent cards, hands, and decks. With these abstractions, we will be able
    to play some simple card games!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you look at any card, the two properties that identify it as a playing
    card are its rank and its suit. Sure, you can observe other properties, such as
    it''s rectangular shape or its plastic-y surface, but those aren''t the important
    qualities that you can use to identify the card. Thus, here we have our `make-card`
    constructor, which takes in a `rank` and a `suit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are its selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And so we can create a card and extract its properties with the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've just created the king of hearts card.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Hand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like how a hand of cards is a collection of cards in real life, in our
    abstraction, a hand will be a **list** of cards. We''ve defined the constructor
    and selectors below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we defined `make-hand` as a **variable** assigned to the procedure
    `list`. This is because we don''t want to specify how many arguments `make-hand`
    should take in - we can create a hand of any length. All we want `make-hand` to
    do is take in an arbitrary number of cards and store them into a list. Here are
    some example calls to our ADT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using Our Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That's all we'll need to represent cards! You have cards, and you have a collection
    of cards. Everything else can be defined in terms these two objects. For example,
    a deck is just a hand with a card for every combination of rank and suit (plus
    two jokers, but we'll omit that for now).
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to write some procedures with our implementation. For most card
    games, the rank of the cards represent its *value*. Let's write a procedure that
    finds the total value of your hand. `total` takes in a hand and returns the sum
    of all the values of your cards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Changing the Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What would happen if we changed the way we represented cards? Would our code
    for `total` still work?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is yes, `total` will work because there is a layer of *abstraction*
    that separates it from the way cards or hands are implemented. As long as we keep
    the same names for our constructors and selectors, all the procedures we built
    off of it will continue to work. Let''s say we changed the way we represent cards
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our `total` procedure will still work with this implementation too. Try it out
    on the Racket interpreter!
  prefs: []
  type: TYPE_NORMAL
- en: With this style of programming, we can create even bigger programs.
  prefs: []
  type: TYPE_NORMAL
