- en: Security and identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security and identity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a major concern of any modern web application or API. It's important
    to keep your user or customer data safe and out of the hands of attackers. This
    encompasses things like
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizing data input to prevent SQL injection attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing cross-domain (XSRF) attacks in forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTTPS (TLS) so data can't be intercepted as it travels over the Internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving users a way to securely sign in with a password or social login credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing password reset or multi-factor authentication flows with security
    in mind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ASP.NET Core can help make all of this easier to implement. The first two (protection
    against SQL injection and cross-domain attacks) are already built-in, and you
    can add a few lines of code to enable HTTPS support. This chapter will mainly
    focus on the **identity** aspects of security: handling user accounts (registration,
    login), authenticating (logging in) your users securely, and making authorization
    decisions once they are authenticated.'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization are distinct ideas that are often confused.
    **Authentication** deals with whether a user is logged in, while **authorization**
    deals with what they are allowed to do *after* they log in. You can think of authentication
    as asking the question, "Do I know who this user is?" While authorization asks,
    "Does this user have permission to do X?"
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The MVC + Individual Authentication template you used to scaffold the project
    includes a number of classes built on top of ASP.NET Core Identity, an authentication
    and identity system that's part of ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: What is ASP.NET Core Identity?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core Identity is the identity system that ships with ASP.NET Core. Like
    everything else in the ASP.NET Core ecosystem, it's a set of NuGet packages that
    can be installed in any project (and are already included if you use the default
    template).
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core Identity takes care of storing user accounts, hashing and storing
    passwords, and managing roles for users. It supports email/password login, multi-factor
    authentication, social login with providers like Google and Facebook, as well
    as connecting to other services using protocols like OAuth 2.0 and OpenID Connect.
  prefs: []
  type: TYPE_NORMAL
- en: The Register and Login views that ship with the MVC + Individual Auth template
    already take advantage of ASP.NET Core Identity, and they already work! Try registering
    for an account and logging in.
  prefs: []
  type: TYPE_NORMAL
- en: Add Facebook login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add Facebook login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Out of the box, the Individual Auth template includes functionality for registering
    using an email and password. You can extend this by plugging in additional identity
    providers like Google and Facebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any external provider, you typically need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an app (sometimes called a *client*) on the external provider that represents
    your application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the ID and secret generated by the provider and put them in your code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an app in Facebook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create new Facebook apps using the Facebook Developer console at [https://developers.facebook.com/apps](https://developers.facebook.com/apps).
    Click **Add a New App** and follow the instructions to create an app ID.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have a Facebook account, you can set up Google or Twitter login
    instead. The steps on the provider's site will be different, but the code is almost
    identical.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, set up Facebook Login and then click Settings on the left side, under
    Facebook Login:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Settings button](facebook-login-settings.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following URL to the **Valid OAuth redirect URIs** box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The port that your application runs on may differ. It's typically port 5000
    if you use `dotnet start`, but if you're on Windows, it could be a random port
    like 54574\. Either way, you can always see the port your application is running
    on in the address bar of your web browser.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Click **Save Changes** and then head over to the Dashboard page. Here you can
    see the app ID and secret generated by Facebook, which you'll need in a moment
    (keep this tab open).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Facebook login in ASP.NET Core Identity, add this code anywhere in
    the `ConfigureServices` method in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instead of hardcoding the Facebook app ID and secret in your code, the values
    are pulled from the configuration system. The `appsettings.json` file is normally
    the place to store configuration data for your project. However, since it's checked
    into source control, it's not good for sensitive data like an app secret. (If
    your app secret was pushed to GitHub, for example, anyone could steal it and do
    bad things on your behalf.)
  prefs: []
  type: TYPE_NORMAL
- en: Store secrets safely with the Secrets Manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the Secrets Manager tool for sensitive data like an app secret.
    Run this line in the terminal to make sure it''s installed (make sure you''re
    currently in the project directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the app ID and secret from the Facebook app dashboard and use the `set`
    command to save the values in the Secrets Manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The values from the Secrets Manager are loaded into the `Configuration` property
    when your application starts up, so they're available to the code in `ConfigureServices`
    you added before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your application and click the Login link in the navbar. You''ll see a
    new button for logging in with Facebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facebook login button](facebook-login-button.png)'
  prefs: []
  type: TYPE_IMG
- en: Try logging in with Facebook. You'll be redirected and prompted to give your
    app permission in Facebook, then redirected back and logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Require authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Require authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often you'll want to require the user to log in before they can access certain
    parts of your application. For example, it makes sense to show the home page to
    everyone (whether you're logged in or not), but only show your to-do list after
    you've logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `[Authorize]` attribute in ASP.NET Core to require a logged-in
    user for a particular action, or an entire controller. To require authentication
    for all actions of the `TodoController`, add the attribute above the first line
    of the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this `using` statement at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Try running the application and accessing `/todo` without being logged in. You'll
    be redirected to the login page automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the name of the attribute, we are really doing an authentication check
    here, not an authorization check. Sorry to be confusing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using identity in the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using identity in the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The to-do list items themselves are still shared between all users, because
    the to-do entities aren't tied to a particular user. Now that the `[Authorize]`
    attribute ensures that you must be logged in to see the to-do view, you can filter
    the database query based on who is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, inject a `UserManager<ApplicationUser>` into the `TodoController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Controllers/TodoController.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll need to add a new `using` statement at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserManager` class is part of ASP.NET Core Identity. You can use it to
    look up the current user in the `Index` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The new code at the top of the action method uses the `UserManager` to get
    the current user from the `User` property available in the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If there is a logged-in user, the `User` property contains a lightweight object
    with some (but not all) of the user's information. The `UserManager` uses this
    to look up the full user details in the database via the `GetUserAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of `currentUser` should never be null, because the `[Authorize]`
    attribute is present on the controller. However, it''s a good idea to do a sanity
    check, just in case. You can use the `Challenge()` method to force the user to
    log in again if their information is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you''re now passing an `ApplicationUser` parameter to `GetIncompleteItemsAsync`,
    you''ll need to update the `ITodoItemService` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Services/ITodoItemService.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to update the database query and show only items owned by the
    current user.
  prefs: []
  type: TYPE_NORMAL
- en: Update the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You''ll need to add a new property to the `TodoItem` entity model so each item
    can reference the user that owns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since you updated the entity model used by the database context, you also need
    to migrate the database. Create a new migration using `dotnet ef` in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new migration called `AddItemOwner` which will add a new column
    to the `Items` table, mirroring the change you made to the `TodoItem` entity model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: You''ll need to manually tweak the migration file if you''re using SQLite
    as your database. See the *Create a migration* section in the *Use a database*
    chapter for more details.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Use `dotnet ef` again to apply it to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Update the service class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the database and the database context updated, you can now update the
    `GetIncompleteItemsAsync` method in the `TodoItemService` and add another clause
    to the `Where` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Services/TodoItemService.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you run the application and register or log in, you'll see an empty to-do
    list once again. Unfortunately, any items you try to add disappear into the ether,
    because you haven't updated the Add Item operation to save the current user to
    new items.
  prefs: []
  type: TYPE_NORMAL
- en: Update the Add Item and Mark Done operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll need to use the `UserManager` to get the current user in the `AddItem`
    and `MarkDone` action methods, just like you did in `Index`. The only difference
    is that these methods will return a `401 Unauthorized` response to the frontend
    code, instead of challenging and redirecting the user to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are both updated methods in the `TodoController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Both service methods must now accept an `ApplicationUser` parameter. Update
    the interface definition in `ITodoItemService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And finally, update the service method implementations in the `TodoItemService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `AddItemAsync` method, set the `Owner` property when you construct
    a `new TodoItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Where` clause in the `MarkDoneAsync` method also needs to check for the
    user''s ID, so a rogue user can''t complete someone else''s items by guessing
    their IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All done! Try using the application with two different user accounts. The to-do
    items stay private for each account.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization with roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authorization with roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Roles are a common approach to handling authorization and permissions in a web
    application. For example, you might have an Administrator role that allows admins
    to see and manage all the users registered for your app, while normal users can
    only see their own information.
  prefs: []
  type: TYPE_NORMAL
- en: Add a Manage Users page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, create a new controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Controllers/ManageUsersController.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `Roles` property on the `[Authorize]` attribute will ensure that
    the user must be logged in **and** assigned the `Administrator` role in order
    to view the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a view model:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Models/ManageUsersViewModel.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a view for the Index action:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Views/ManageUsers/Index.cshtml`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Start up the application and try to access the `/ManageUsers` route while logged
    in as a normal user. You''ll see this access denied page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Access denied error](access-denied.png)'
  prefs: []
  type: TYPE_IMG
- en: That's because users aren't assigned the `Administrator` role automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Create a test administrator account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For obvious security reasons, there isn't a checkbox on the registration page
    that makes it easy for anyone to create an administrator account. Instead, you
    can write some code in the `Startup` class that will create a test admin account
    the first time the application starts up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to the `if (env.IsDevelopment())` branch of the `Configure` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Startup.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EnsureRolesAsync` and `EnsureTestAdminAsync` methods will need access
    to the `RoleManager` and `UserManager` services. You can inject them into the
    `Configure` method, just like you inject any service into your controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the two new methods below the `Configure` method. First, the `EnsureRolesAsync`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This method checks to see if an `Administrator` role exists in the database.
    If not, it creates one. Instead of repeatedly typing the string `"Administrator"`,
    create a small class called `Constants` to hold the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Constants.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to update the `ManageUsersController` you created before to use this
    constant value as well.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, write the `EnsureTestAdminAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Startup.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If there isn't already a user with the username `admin@todo.local` in the database,
    this method will create one and assign a temporary password. After you log in
    for the first time, you should change the account's password to something secure.
  prefs: []
  type: TYPE_NORMAL
- en: Because these two methods are asynchronous and return a `Task`, the `Wait` method
    must be used in `Configure` to make sure they finish before `Configure` moves
    on. You'd normally use `await` for this, but for technical reasons you can't use
    `await` in `Configure`. This is a rare exception - you should use `await` everywhere
    else!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you start the application next, the `admin@todo.local` account will be
    created and assigned the `Administrator` role. Try logging in with this account,
    and navigating to `http://localhost:5000/ManageUsers`. You'll see a list of all
    users registered for the application.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra challenge, try adding more administration features to this page.
    For example, you could add a button that gives an administrator the ability to
    delete a user account.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Check for authorization in a view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `[Authorize]` attribute makes it easy to perform an authorization check
    in a controller or action method, but what if you need to check authorization
    in a view? For example, it would be nice to display a "Manage users" link in the
    navigation bar if the logged-in user is an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can inject the `UserManager` directly into a view to do these types of
    authorization checks. To keep your views clean and organized, create a new partial
    view that will add an item to the navbar in the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Views/Shared/_AdminActionsPartial.cshtml`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A **partial view** is a small piece of a view that gets embedded into another
    view. It's common to name partial views starting with an `_` underscore, but it's
    not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: This partial view first uses the `SignInManager` to quickly determine whether
    the user is logged in. If they aren't, the rest of the view code can be skipped.
    If there *is* a logged-in user, the `UserManager` is used to look up their details
    and perform an authorization check with `IsInRoleAsync`. If all checks succeed,
    a navbar item is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include this partial in the main layout, edit `_Layout.cshtml` and add it
    in the navbar section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Views/Shared/_Layout.cshtml`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When you log in with an administrator account, you''ll now see a new item on
    the top right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manage Users link](manage-users.png)'
  prefs: []
  type: TYPE_IMG
- en: Wrap up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ASP.NET Core Identity is a powerful security and identity system that helps
    you add authentication and authorization checks, and makes it easy to integrate
    with external identity providers. The `dotnet new` templates give you pre-built
    views and controllers that handle common scenarios like login and registration
    so you can get up and running quickly.
  prefs: []
  type: TYPE_NORMAL
- en: There's much more that ASP.NET Core Identity can do. You can learn more in the
    documentation and examples available at [https://docs.asp.net](https://docs.asp.net).
  prefs: []
  type: TYPE_NORMAL
