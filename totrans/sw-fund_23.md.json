["```\n\n    Our next major topic is *type systems* \u2014 static program\n    analyses that classify expressions according to the \"shapes\" of\n    their results.  We'll begin with a typed version of the simplest\n    imaginable language, to introduce the basic ideas of types and\n    typing rules and the fundamental theorems about type systems:\n    *type preservation* and *progress*.  In chapter [Stlc](Stlc.html) we'll move\n    on to the *simply typed lambda-calculus*, which lives at the core\n    of every modern functional programming language (including\n    Coq!).\n\n```", "```\n\n# Typed Arithmetic Expressions\n\n    To motivate the discussion of type systems, let's begin as\n    usual with a tiny toy language.  We want it to have the potential\n    for programs to go wrong because of runtime type errors, so we\n    need something a tiny bit more complex than the language of\n    constants and addition that we used in chapter [Smallstep](Smallstep.html): a\n    single kind of data (e.g., numbers) is too simple, but just two\n    kinds (numbers and booleans) gives us enough material to tell an\n    interesting story.\n\n    The language definition is completely routine.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0t\u00a0::=\u00a0true\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0false\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0if\u00a0t\u00a0then\u00a0t\u00a0else\u00a0t\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a00\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0succ\u00a0t\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0pred\u00a0t\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0iszero\u00a0t\n\n    And here it is formally:\n\n```", "```\n\n    *Values* are true, false, and numeric values...\n\n```", "```\n\n## Operational Semantics\n\n    Here is the single-step relation, first informally... \n\n           |\n\n                        (ST_IfTrue) \u00a0\n           |\n\n* * *\n\n           |\n\n                        if\u00a0true\u00a0then\u00a0t[1]\u00a0else\u00a0t[2]\u00a0\u21d2\u00a0t[1]\n           |\n\n                     |\n\n           |\n\n                        (ST_IfFalse) \u00a0\n           |\n\n* * *\n\n           |\n\n                        if\u00a0false\u00a0then\u00a0t[1]\u00a0else\u00a0t[2]\u00a0\u21d2\u00a0t[2]\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_If) \u00a0\n           |\n\n* * *\n\n           |\n\n                        if\u00a0t[1]\u00a0then\u00a0t[2]\u00a0else\u00a0t[3]\u00a0\u21d2\u00a0if\u00a0t[1]'\u00a0then\u00a0t[2]\u00a0else\u00a0t[3]\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Succ) \u00a0\n           |\n\n* * *\n\n           |\n\n                        succ\u00a0t[1]\u00a0\u21d2\u00a0succ\u00a0t[1]'\n           |\n\n                     |\n\n           |\n\n                        (ST_PredZero) \u00a0\n           |\n\n* * *\n\n           |\n\n                        pred\u00a00\u00a0\u21d2\u00a00\n           |\n\n                     |\n\n                        numeric\u00a0value\u00a0v[1]\n           |\n\n                        (ST_PredSucc) \u00a0\n           |\n\n* * *\n\n           |\n\n                        pred\u00a0(succ\u00a0v[1])\u00a0\u21d2\u00a0v[1]\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Pred) \u00a0\n           |\n\n* * *\n\n           |\n\n                        pred\u00a0t[1]\u00a0\u21d2\u00a0pred\u00a0t[1]'\n           |\n\n                     |\n\n           |\n\n                        (ST_IszeroZero) \u00a0\n           |\n\n* * *\n\n           |\n\n                        iszero\u00a00\u00a0\u21d2\u00a0true\n           |\n\n                     |\n\n                        numeric\u00a0value\u00a0v[1]\n           |\n\n                        (ST_IszeroSucc) \u00a0\n           |\n\n* * *\n\n           |\n\n                        iszero\u00a0(succ\u00a0v[1])\u00a0\u21d2\u00a0false\n           |\n\n                     |\n\n                        t[1]\u00a0\u21d2\u00a0t[1]'\n           |\n\n                        (ST_Iszero) \u00a0\n           |\n\n* * *\n\n           |\n\n                        iszero\u00a0t[1]\u00a0\u21d2\u00a0iszero\u00a0t[1]'\n           |\n\n                     |\n\n    ... and then formally:\n\n```", "```\n\n    Notice that the step relation doesn't care about whether\n    expressions make global sense \u2014 it just checks that the operation\n    in the *next* reduction step is being applied to the right kinds\n    of operands.  For example, the term succ true (i.e., \n    tsucc ttrue in the formal syntax) cannot take a step, but the\n    almost as obviously nonsensical term\n\n```", "```\n\n## Normal Forms and Values\n\n    The first interesting thing to notice about this step relation\n    is that the strong progress theorem from the [Smallstep](Smallstep.html) chapter\n    fails here.  That is, there are terms that are normal forms (they\n    can't take a step) but not values (because we have not included\n    them in our definition of possible \"results of reduction\").  Such\n    terms are *stuck*.\n\n```", "```\n\n#### Exercise: 2 stars (some_term_is_stuck)\n\n```", "```\n\n    \u2610 \n\n    However, although values and normal forms are *not* the same in this\n    language, the set of values is included in the set of normal\n    forms.  This is important because it shows we did not accidentally\n    define things so that some value could still take a step. \n\n#### Exercise: 3 stars (value_is_nf)\n\n```", "```\n\n    (Hint: You will reach a point in this proof where you need to\n    use an induction to reason about a term that is known to be a\n    numeric value.  This induction can be performed either over the\n    term itself or over the evidence that it is a numeric value.  The\n    proof goes through in either case, but you will find that one way\n    is quite a bit shorter than the other.  For the sake of the\n    exercise, try to complete the proof both ways.)  \u2610 \n\n#### Exercise: 3 stars, optional (step_deterministic)\n\n    Use value_is_nf to show that the step relation is also\n    deterministic.\n\n```", "```\n\n    \u2610\n\n```", "```\nInductive ty : Type :=\n\u00a0\u00a0| TBool : ty\n\u00a0\u00a0| TNat : ty.\n\n```", "```\nReserved Notation \"'\u22a2' t '\u2208' T\" (at level 40).\n\nInductive has_type : tm \u2192 ty \u2192 Prop :=\n\u00a0\u00a0| T_True :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 ttrue \u2208 TBool\n\u00a0\u00a0| T_False :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 tfalse \u2208 TBool\n\u00a0\u00a0| T_If : \u2200t[1] t[2] t[3] T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 t[1] \u2208 TBool \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 t[2] \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 t[3] \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 tif t[1] t[2] t[3] \u2208 T\n\u00a0\u00a0| T_Zero :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 tzero \u2208 TNat\n\u00a0\u00a0| T_Succ : \u2200t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 tsucc t[1] \u2208 TNat\n\u00a0\u00a0| T_Pred : \u2200t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 tpred t[1] \u2208 TNat\n\u00a0\u00a0| T_Iszero : \u2200t[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 t[1] \u2208 TNat \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2 tiszero t[1] \u2208 TBool\n\nwhere \"'\u22a2' t '\u2208' T\" := (has_type t T).\n\nHint Constructors has_type.\n\nExample has_type_1 :\n\u00a0\u00a0\u22a2 tif tfalse tzero (tsucc tzero) \u2208 TNat.\nProof.\n\u00a0\u00a0apply T_If.\n\u00a0\u00a0\u00a0\u00a0- apply T_False.\n\u00a0\u00a0\u00a0\u00a0- apply T_Zero.\n\u00a0\u00a0\u00a0\u00a0- apply T_Succ.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ apply T_Zero.\nQed.\n\n```", "```\nExample has_type_not :\n\u00a0\u00a0\u00ac (\u22a2 tif tfalse tzero ttrue \u2208 TBool).\n\n    Proof.\n\u00a0\u00a0intros Contra. solve_by_inverts 2\\. Qed.\n\n```", "```\nExample succ_hastype_nat__hastype_nat : \u2200t,\n\u00a0\u00a0\u22a2 tsucc t \u2208 TNat \u2192\n\u00a0\u00a0\u22a2 t \u2208 TNat.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n### Canonical forms\n\n    The following two lemmas capture the fundamental property that the\n    definitions of boolean and numeric values agree with the typing\n    relation.\n\n```", "```\n\n## Progress\n\n    The typing relation enjoys two critical properties.  The first is\n    that well-typed normal forms are not stuck \u2014 or conversely, if a\n    term is well typed, then either it is a value or it can take at\n    least one step.  We call this *progress*. \n\n#### Exercise: 3 stars (finish_progress)\n\n```", "```\n\n    Complete the formal proof of the progress property.  (Make sure\n    you understand the parts we've given of the informal proof in the\n    following exercise before starting \u2014 this will save you a lot of\n    time.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, advancedM (finish_progress_informal)\n\n    Complete the corresponding informal proof: \n\n    *Theorem*: If \u22a2 t \u2208 T, then either t is a value or else\n    t \u21d2 t' for some t'. \n\n    *Proof*: By induction on a derivation of \u22a2 t \u2208 T.\n\n*   If the last rule in the derivation is T_If, then t = if t[1] then t[2] else t[3], with \u22a2 t[1] \u2208 Bool, \u22a2 t[2] \u2208 T and \u22a2 t[3] \u2208 T. By the IH, either t[1] is a value or else t[1] can step to some t[1]'. \n\n    *   If t[1] is a value, then by the canonical forms lemmas and the fact that \u22a2 t[1] \u2208 Bool we have that t[1] is a bvalue \u2014 i.e., it is either true or false. If t[1] = true, then t steps to t[2] by ST_IfTrue, while if t[1] = false, then t steps to t[3] by ST_IfFalse. Either way, t can step, which is what we wanted to show. \n\n    *   If t[1] itself can take a step, then, by ST_If, so can t. \n\n*   (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n    This theorem is more interesting than the strong progress theorem\n    that we saw in the [Smallstep](Smallstep.html) chapter, where *all* normal forms\n    were values.  Here a term can be stuck, but only if it is ill\n    typed.\n\n```", "```\nTheorem preservation : \u2200t t' T,\n\u00a0\u00a0\u22a2 t \u2208 T \u2192\n\u00a0\u00a0t \u21d2 t' \u2192\n\u00a0\u00a0\u22a2 t' \u2208 T.\n\n```", "```\n\n    Proof with auto.\n\u00a0\u00a0intros t t' T HT HE.\n\u00a0\u00a0generalize dependent t'.\n\u00a0\u00a0induction HT;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(*\u00a0every\u00a0case\u00a0needs\u00a0to\u00a0introduce\u00a0a\u00a0couple\u00a0of\u00a0things\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros t' HE;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(*\u00a0and\u00a0we\u00a0can\u00a0deal\u00a0with\u00a0several\u00a0impossible \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cases\u00a0all\u00a0at\u00a0once\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try solve_by_invert.\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0T_If\u00a0*) inversion HE; subst; clear HE.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_IFTrue\u00a0*) assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_IfFalse\u00a0*) assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_If\u00a0*) apply [T_If](Types.html#T_If); try assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHHT1; assumption.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem preservation' : \u2200t t' T,\n\u00a0\u00a0\u22a2 t \u2208 T \u2192\n\u00a0\u00a0t \u21d2 t' \u2192\n\u00a0\u00a0\u22a2 t' \u2208 T.\nProof with eauto.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Type Soundness\n\n    Putting progress and preservation together, we see that a\n    well-typed term can never reach a stuck state.\n\n```", "```\n\n# Aside: the normalize Tactic\n\n    When experimenting with definitions of programming languages\n    in Coq, we often want to see what a particular concrete term steps\n    to \u2014 i.e., we want to find proofs for goals of the form t \u21d2* t', where t is a completely concrete term and t' is unknown.\n    These proofs are quite tedious to do by hand.  Consider, for\n    example, reducing an arithmetic expression using the small-step\n    relation astep.\n\n```", "```\n\n    The proof repeatedly applies multi_step until the term reaches a\n    normal form.  Fortunately The sub-proofs for the intermediate\n    steps are simple enough that auto, with appropriate hints, can\n    solve them.\n\n```", "```\n\n    The following custom Tactic Notation definition captures this\n    pattern.  In addition, before each step, we print out the current\n    goal, so that we can follow how the term is being reduced.\n\n```", "```\n\n    The normalize tactic also provides a simple way to calculate the\n    normal form of a term, by starting with a goal with an existentially\n    bound variable.\n\n```", "```\n\n#### Exercise: 1 star (normalize_ex)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 1 star, optional (normalize_ex')\n\n    For comparison, prove it using apply instead of eapply.\n\n```", "```\n\n    \u2610\n\n```", "```\n\n## Additional Exercises\n\n#### Exercise: 2 stars, recommendedM (subject_expansion)\n\n    Having seen the subject reduction property, one might\n    wonder whether the opposity property \u2014 subject *expansion* \u2014\n    also holds.  That is, is it always the case that, if t \u21d2 t'\n    and \u22a2 t' \u2208 T, then \u22a2 t \u2208 T?  If so, prove it.  If\n    not, give a counter-example.  (You do not need to prove your\n    counter-example in Coq, but feel free to do so.)\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 starsM (variation1)\n\n    Suppose, that we add this new rule to the typing relation:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0ST_Funny1\u00a0:\u00a0\u2200t[2]\u00a0t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif\u00a0ttrue\u00a0t[2]\u00a0t[3])\u00a0\u21d2\u00a0t[3]\n\n    Which of the above properties become false in the presence of\n   this rule?  For each one that does, give a counter-example.\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (variation3)\n\n    Suppose instead that we add this rule:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0ST_Funny3\u00a0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tpred\u00a0tfalse)\u00a0\u21d2\u00a0(tpred\u00a0(tpred\u00a0tfalse))\n\n    Which of the above properties become false in the presence of\n   this rule?  For each one that does, give a counter-example.\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (variation5)\n\n    Suppose instead that we add this rule:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0T_Funny5\u00a0:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u22a2\u00a0tpred\u00a0tzero\u00a0\u2208\u00a0TBool\n\n    Which of the above properties become false in the presence of\n   this rule?  For each one that does, give a counter-example.\n\n    \u2610 \n\n#### Exercise: 3 stars, optional (more_variations)\n\n    Make up some exercises of your own along the same lines as\n    the ones above.  Try to find ways of selectively breaking\n    properties \u2014 i.e., ways of changing the definitions that\n    break just one of the properties and leave the others alone.\n    \u2610 \n\n#### Exercise: 1 starM (remove_predzero)\n\n    The reduction rule E_PredZero is a bit counter-intuitive: we\n    might feel that it makes more sense for the predecessor of zero to\n    be undefined, rather than being defined to be zero.  Can we\n    achieve this simply by removing the rule from the definition of\n    step?  Would doing so create any problems elsewhere?\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 4 stars, advancedM (prog_pres_bigstep)\n\n    Suppose our evaluation relation is defined in the big-step style.\n    What are the appropriate analogs of the progress and preservation\n    properties?  (You do not need to prove them.)\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]