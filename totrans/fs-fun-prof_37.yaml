- en: We don't need no stinking UML diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don't need no stinking UML diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In my talk on [functional DDD](http://fsharpforfunandprofit.com/ddd/), I often
    use this slide (*[in context](http://www.slideshare.net/ScottWlaschin/ddd-with-fsharptypesystemlondonndc2013/45)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![We don''t need no stinking UML diagrams](no-uml-diagrams.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Which is of course is a misquote of [this famous scene](https://www.youtube.com/watch?v=gx6TBrfCW54).
    Oops, I mean [this one](https://www.youtube.com/watch?v=VqomZQMZQCQ).
  prefs: []
  type: TYPE_NORMAL
- en: Ok, I might be exaggerating a bit. Some UML diagrams are useful (I like sequence
    diagrams for example) and in general, I do think a good picture or diagram can
    be worth 1000 words.
  prefs: []
  type: TYPE_NORMAL
- en: But I believe that, in many cases, using UML for class diagrams is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, a concise language like F# (or OCaml or Haskell) can convey the same
    meaning in a way that is easier to read, easier to write, and most important,
    easier to turn into *working code*!
  prefs: []
  type: TYPE_NORMAL
- en: With UML diagrams, you need to translate them to code, with the possibility
    of losing something in translation. But if the design is documented in your programming
    language itself, there is no translation phase, and so the design must always
    be in sync with the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this in practice, I decided to scour the internet for some good
    (and not-so-good) UML class diagrams, and convert them into F# code. You can compare
    them for yourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a classic one: regular expressions (*[source](http://zenit.senecac.on.ca/wiki/index.php/Interpreter)*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](uml-regex.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s the F# equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Student enrollment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s another classic one: enrollment (*[source](http://www.agilemodeling.com/artifacts/classDiagram.htm)*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](uml-enrollment.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s the F# equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The F# mirrors the UML diagram, but I find that by writing functions for all
    the activities rather than drawing pictures, holes in the original requirements
    are revealed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `GetSeminarsTaken` method in the UML diagram, where is the
    list of seminars stored? If it is in the `Student` class (as implied by the diagram)
    then we have a mutual recursion between `Student` and `Seminar` and the whole
    tree of every student and seminar is interconnected and must be loaded at the
    same time unless [hacks are used](https://stackoverflow.com/questions/19371214/entity-framework-code-first-circular-dependices).
  prefs: []
  type: TYPE_NORMAL
- en: Instead, for the functional version, I created an `EnrollmentRepository` to
    decouple the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, it's not clear how enrollment actually works, so I created an `EnrollStudent`
    function to make it clear what inputs are needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because the function returns an `option`, it is immediately clear that enrollment
    might fail (e.g student is not eligible to enroll, or is enrolling twice by mistake).
  prefs: []
  type: TYPE_NORMAL
- en: Order and customer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's another one (*[source](http://www.tutorialspoint.com/uml/uml_class_diagram.htm)*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](uml-order.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s the F# equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I'm just copying the UML diagram, but I have to say that I hate this design.
    It's crying out to have more fine grained states.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the `Confirm` and `Dispatch` functions are horrible -- they give
    no idea of what else is needed as input or what the effects will be. This is where
    writing real code can force you to think a bit more deeply about the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Order and customer, version 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's a much better version of orders and customers (*[source](http://edn.embarcadero.com/article/31863)*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](uml-order2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here''s the F# equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I've done some minor tweaking, adding units of measure for the weight, creating
    types to represent `Qty` and `Price`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this design might be improved with more fine grained states, such as
    creating a separate `AuthorizedPayment` type (to ensure that an order can only
    be paid with authorized payments) and a separate `PaidOrder` type (e.g. to stop
    you paying for the same order twice).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the kind of thing I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Hotel Booking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's one from the JetBrains IntelliJ documentation (*[source](https://www.jetbrains.com/idea/help/viewing-diagram.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](uml-hotel.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the F# equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I have to stop there, sorry. The design is driving me crazy. I can't even.
  prefs: []
  type: TYPE_NORMAL
- en: What are these `EntityManager` and `FacesMessages` fields? And logging is important
    of course, but why is `Log` a field in the domain object?
  prefs: []
  type: TYPE_NORMAL
- en: By the way, in case you think that I am deliberately picking bad examples of
    UML design, all these diagrams come from the top results in an image search for
    ["uml class diagram"](https://www.google.com/search?q=uml+class+diagram&tbm=isch).
  prefs: []
  type: TYPE_NORMAL
- en: Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This one is better, a library domain (*[source](http://www.uml-diagrams.org/library-domain-uml-class-diagram-example.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](uml-library.png)'
  prefs: []
  type: TYPE_IMG
- en: Here's the F# equivalent. Note that because it is code, I can add comments to
    specific types and fields, which is doable but awkward with UML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that I can say `ISBN: string option` to indicate an optional ISBN
    rather that the awkward `[0..1]` syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since the Search and Manage interfaces are undefined, we can just use placeholders
    (`unit`) for the inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this might not be the perfect design. For example, it''s not clear that
    only `Active` accounts could borrow a book, which I might represent in F# as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you want to see a more modern approach to modelling this domain using CQRS
    and event sourcing, see [this post](http://thinkbeforecoding.com/post/2009/11/02/Event-Sourcing-and-CQRS-Lets-use-it).
  prefs: []
  type: TYPE_NORMAL
- en: Software licensing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final example is from a software licensing domain (*[source](http://www.uml-diagrams.org/software-licensing-domain-diagram-example.html?context=cls-examples)*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](uml-hasp.png)'
  prefs: []
  type: TYPE_IMG
- en: Here's the F# equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This diagram is just pure data and no methods, so there are no function types.
    I have a feeling that there are some important business rules that have not been
    captured.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you read the comments in the source, you'll see that there are
    some interesting constraints around `EntitlementType` and `LockingType`. Only
    certain locking types can be used with certain entitlement types.
  prefs: []
  type: TYPE_NORMAL
- en: That might be something that we could consider modelling in the type system,
    but I haven't bothered. I've just tried to reproduct the UML as is.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I think that's enough to get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: My general feeling about UML class diagrams is that they are OK for a sketch,
    if a bit heavyweight compared to a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: For detailed designs, though, they are not nearly detailed enough. Critical
    things like context and dependencies are not at all obvious. In my opinion, none
    of the UML diagrams I've shown have been good enough to write code from, even
    as a basic design.
  prefs: []
  type: TYPE_NORMAL
- en: Even more seriously, a UML diagram can be very misleading to non-developers.
    It looks "official" and can give the impression that the design has been thought
    about deeply, when in fact the design is actually shallow and unusable in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Disagree? Let me know in the comments!
  prefs: []
  type: TYPE_NORMAL
