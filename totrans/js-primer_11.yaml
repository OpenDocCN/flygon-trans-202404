- en: データ型とリテラル
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/data-type/](https://jsprimer.net/basic/data-type/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](#data-type)*データ型*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*JavaScriptは動的型付け言語に分類される言語であるため、静的型付け言語のような**変数の型**はありません。 しかし、文字列、数値、真偽値といった**値の型**は存在します。
    これらの値の型のことを**データ型**と呼びます。'
  prefs: []
  type: TYPE_NORMAL
- en: データ型を大きく分けると、**プリミティブ型**と**オブジェクト**の2つに分類されます。
  prefs: []
  type: TYPE_NORMAL
- en: プリミティブ型（基本型）は、真偽値や数値などの基本的な値の型のことです。 プリミティブ型の値は、一度作成したらその値自体を変更できないというイミュータブル（immutable）の特性を持ちます。
    JavaScriptでは、文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種として扱われます。
  prefs: []
  type: TYPE_NORMAL
- en: 一方、プリミティブ型ではないものをオブジェクト（複合型）と呼び、 オブジェクトは複数のプリミティブ型の値またはオブジェクトからなる集合です。 オブジェクトは、一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性を持ちます。
    オブジェクトは、値そのものではなく値への参照を経由して操作されるため、参照型のデータとも言います。
  prefs: []
  type: TYPE_NORMAL
- en: データ型を細かく見ていくと、7つのプリミティブ型とオブジェクトからなります。
  prefs: []
  type: TYPE_NORMAL
- en: プリミティブ型（基本型）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '真偽値（Boolean）: `true`または`false`のデータ型'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '数値（Number）: `42` や `3.14159` などの数値のデータ型'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '巨大な整数（BigInt）: ES2020から追加された`9007199254740992n`などの任意精度の整数のデータ型'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '文字列（String）: `"JavaScript"` などの文字列のデータ型'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'undefined: 値が未定義であることを意味するデータ型'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'null: 値が存在しないことを意味するデータ型'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: オブジェクト（複合型）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: プリミティブ型以外のデータ
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: オブジェクト、配列、関数、クラス、正規表現、Dateなど
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: プリミティブ型でないものは、オブジェクトであると覚えていれば問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: '`typeof`演算子を使うことで、次のようにデータ型を調べることができます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: プリミティブ型の値は、それぞれ`typeof`演算子の評価結果として、その値のデータ型を返します。 一方で、オブジェクトに分類される値は`"object"`となります。
  prefs: []
  type: TYPE_NORMAL
- en: 配列(`[]`)とオブジェクト(`{}`)は、どちらも`"object"`という判定結果になります。 そのため、`typeof`演算子ではオブジェクトの詳細な種類を正しく判定することはできません。
    ただし、関数はオブジェクトの中でも特別扱いされているため、`typeof`演算子の評価結果は`"function"`となります。 また、`typeof null`が`"object"`となるのは、歴史的経緯のある仕様のバグ^([1](#fn_1))です。
  prefs: []
  type: TYPE_NORMAL
- en: このことからもわかるように`typeof`演算子は、プリミティブ型またはオブジェクトかを判別するものです。 `typeof`演算子では、オブジェクトの詳細な種類を判定できないことは、覚えておくとよいでしょう。
    各オブジェクトの判定方法については、それぞれのオブジェクトの章で見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#literal)*リテラル*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*プリミティブ型の値や一部のオブジェクトは、**リテラル**を使うことで簡単に定義できるようになっています。'
  prefs: []
  type: TYPE_NORMAL
- en: リテラルとはプログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたものです。 たとえば、`"`と`"`で囲んだ範囲が文字列リテラルで、これは文字列型のデータを表現しています。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`"こんにちは"`という文字列型のデータを初期値に持つ変数`str`を定義しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: リテラル表現がない場合は、その値を作る関数に引数を渡して作成する形になります。 そのような冗長な表現を避ける方法として、よく利用される主要なデータ型にはリテラルが用意されています。
  prefs: []
  type: TYPE_NORMAL
- en: 次の5つのプリミティブ型は、それぞれリテラル表現を持っています。
  prefs: []
  type: TYPE_NORMAL
- en: 真偽値
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 数値
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BigInt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 文字列
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: また、オブジェクトの中でもよく利用されるものに関してはリテラル表現が用意されています。
  prefs: []
  type: TYPE_NORMAL
- en: オブジェクト
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 配列
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 正規表現
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: これらのリテラルについて、まずはプリミティブ型から順番に見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#boolean)*真偽値（Boolean）*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*真偽値には`true`と`false`のリテラルがあります。 それぞれは`true`と`false`の値を返すリテラルで、見た目どおりの意味となります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[](#number)*数値（Number）*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*数値には`42`のような整数リテラルと`3.14159`のような浮動小数点数リテラルがあります。'
  prefs: []
  type: TYPE_NORMAL
- en: これらのリテラルで表現できる数値は[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)の倍精度浮動小数として扱われます。
    倍精度浮動小数では64ビットで数値を表現します。 64ビットのうち52ビットを数字の格納のために使い、11ビットを小数点の位置に使い、残りの1ビットはプラスとマイナスの符号です。
    そのため、正確に扱える数値の最大値は`2^53-1`（2の53乗から1引いた値）となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#integer-literal)*整数リテラル*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*整数リテラルには次の4種類があります。'
  prefs: []
  type: TYPE_NORMAL
- en: '10進数: 数字の組み合わせ'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ただし、複数の数字を組み合わせた際に、先頭を`0`から開始すると8進数として扱われる場合があります
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 例）`0`、`2`、`10`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '2進数: `0b`（または`0B`）の後ろに、`0`または`1`の数字の組み合わせ'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 例）`0b0`、`0b10`、`0b1010`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '8進数: `0o`（または`0O`）の後ろに、`0`から`7`までの数字の組み合わせ'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0o` は数字のゼロと小文字アルファベットの`o`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 例）`0o644`、`0o777`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '16進数: `0x`（または`0X`）の後ろに、`0`から`9`までの数字と`a`から`f`または`A`から`F`のアルファベットの組み合わせ'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: アルファベットの大文字・小文字の違いは値には影響しません
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 例）`0x30A2`、`0xEEFF`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 0から9の数字のみで書かれた数値は、10進数として扱われます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`0b`からはじまる2進数リテラルは、ビットを表現するのによく利用されています。 `b`は2進数を表すbinaryを意味しています。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`0o`からはじまる8進数リテラルは、ファイルのパーミッションを表現するのによく利用されています。 `o`は8進数を表すoctalを意味しています。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 次のように、`0`からはじまり、`0`から`7`の数字を組み合わせた場合も8進数として扱われます。 しかし、この表記は10進数と紛らわしいものであったため、ES2015で`0o`の8進数リテラルが新たに導入されました。
    また、strict modeではこの書き方は例外が発生するため、次のような8進数の書き方は避けるべきです（詳細は「[JavaScriptとは](../introduction/)」の[strict
    mode](../introduction/#strict-mode)を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`0x`からはじまる16進数リテラルは、文字のコードポイントやRGB値の表現などに利用されています。 `x`は16進数を表すhexを意味しています。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| 名前 | 表記例 | 用途 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 10進数 | 42 | 数値 |'
  prefs: []
  type: TYPE_TB
- en: '| 2進数 | 0b0001 | ビット演算など |'
  prefs: []
  type: TYPE_TB
- en: '| 8進数 | 0o777 | ファイルのパーミッションなど |'
  prefs: []
  type: TYPE_TB
- en: '| 16進数 | 0xEEFF | 文字のコードポイント、RGB値など |'
  prefs: []
  type: TYPE_TB
- en: '[](#floating-point-number-literal)*浮動小数点数リテラル*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*浮動小数点数をリテラルとして書く場合には、次の2種類の表記が利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`3.14159` のような `.`（ドット）を含んだ数値'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2e8` のような `e` または `E` を含んだ数値'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`からはじまる浮動小数点数は、`0`を省略して書くことができます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: しかし、JavaScriptでは`.`をオブジェクトにおいて利用する機会が多いため、 `0`からはじまる場合でも省略せずに書いたほうが意図しない挙動を減らせるでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** 変数名を数字からはじめることができないのは、数値リテラルと衝突してしまうからです。'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`e`は指数（exponent）を意味する記号で、`e`のあとには指数部の値を書きます。 たとえば、`2e8`は2×10の8乗となるので、10進数で表すと`200000000`となります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[](#bigint-literal)*[ES2020] BigInt*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptでは、`1`や`3.14159`などの数値リテラルは[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)で定義された倍精度浮動小数となります。
    倍精度浮動小数で正確に扱える数値の最大値は`2^53-1`（2の53乗から1引いた値である`9007199254740991`）です。 この数値リテラルで安全に表せる最大の数値は`Number.MAX_SAFE_INTEGER`として定義されています。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 数値リテラルで`2^53-1`（`9007199254740991`）よりも大きな値を表現したり計算すると間違った結果となる場合があります。
  prefs: []
  type: TYPE_NORMAL
- en: この問題を解決するために、ES2020では`BigInt`という新しい整数型のデータ型とリテラルが追加されました。 数値リテラルは倍精度浮動小数（64ビット）で数値を扱うのに対して、BigIntでは任意の精度の整数を扱えます。
    そのため、BigIntでは`2^53-1`（`9007199254740991`）よりも大きな整数を正しく表現できます。
  prefs: []
  type: TYPE_NORMAL
- en: BigIntリテラルは、数値の後ろに`n`をつけます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: BigIntは整数を扱うデータ型であるため、次のように小数点を含めた場合は構文エラーとなります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[](#numeric-separators)*[ES2021] Numeric Separators*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*数値が大きくなるほど、桁数の見間違いなどが発生しやすくなります。 次のコードは、1兆を数値リテラルで書いていますが、桁数を読み取りにくいです。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: ES2021から、数値リテラル内の区切り文字として`_`を追加できるNumeric Separatorsがサポートされています。 Numeric Separatorsは、数値リテラル内では区切り文字として`_`が追加できます。
    次のコードも、1兆を数値リテラルで書いています。数値リテラルを評価する際に`_`は単純に無視されるため同じ意味となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Numeric Separatorsは数値リテラルである整数、浮動小数点、BigIntのリテラル内でのみ利用できます。 また、`_`はリテラルの先頭や数値の最後に追加することはできません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[](#string)*文字列（String）*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*文字列リテラル共通のルールとして、同じ記号で囲んだ内容を文字列として扱います。 文字列リテラルとして次の3種類のリテラルがありますが、その評価結果はすべて同じ`"文字列"`になります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[](#double-quote-and-single-quote)*ダブルクォートとシングルクォート*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*`"`（ダブルクォート）と`''`（シングルクォート）はまったく同じ意味となります。 PHPやRubyなどとは違い、どちらのリテラルでも評価結果は同じとなります。'
  prefs: []
  type: TYPE_NORMAL
- en: 文字列リテラルは同じ記号で囲む必要があるため、次のように文字列の中に同じ記号が出現した場合は、 `\'`のように`\`（バックスラッシュ）を使ってエスケープしなければなりません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: また、文字列内部に出現しない別のクォート記号を使うことで、エスケープをせずに書くこともできます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できません。 次のように改行を含んだ文字列は定義できないため、構文エラー（`SyntaxError`）となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 改行の代わりに改行記号のエスケープシーケンス（`\n`）を使うことで複数行の文字列を書くことができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: シングルクォートとダブルクォートの文字列リテラルに改行を入れるには、エスケープシーケンスを使わないといけません。 これに対してES2015から導入されたテンプレートリテラルでは、複数行の文字列を直感的に書くことができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#template-literal)*[ES2015] テンプレートリテラル*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*テンプレートリテラルは、[PRE21]で囲めば、そのまま書くことができます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: また、名前のとおりテンプレートのような機能も持っています。 テンプレートリテラル内で`${変数名}`と書いた場合に、その変数の値を埋め込むことができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: テンプレートリテラルも他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、`\`を使ってエスケープする必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[](#null-literal)*nullリテラル*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*nullリテラルは`null`値を返すリテラルです。 `null`は「値がない」ということを表現する値です。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のように、未定義の変数を参照した場合は、 参照できないため`ReferenceError`の例外が投げられます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`foo`には値がないということを表現したい場合は、 `null`値を代入することで、`null`値を持つ`foo`という変数を定義できます。 これにより、`foo`を値がない変数として定義し、参照できるようになります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[](#undefined-is-not-literal)*[コラム] undefinedはリテラルではない*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*プリミティブ型として紹介した`undefined`はリテラルではありません。 `undefined`はただのグローバル変数で、`undefined`という値を持っているだけです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のように、`undefined`はただのグローバル変数であるため、同じ`undefined`という名前のローカル変数を宣言できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: これに対して`true`、`false`、`null`などはグローバル変数ではなくリテラルであるため、同じ名前の変数を定義することはできません。 リテラルは変数名として利用できない予約語のようなものであるため、再定義しようとすると構文エラー（SyntaxError）となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ここでは、説明のために`undefined`というローカル変数を宣言しましたが、`undefined`の再定義は非推奨です。 無用な混乱を生むだけなので避けるべきです。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#object)*オブジェクトリテラル*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptにおいて、オブジェクトはあらゆるものの基礎となります。 そのオブジェクトを作成する方法として、オブジェクトリテラルがあります。
    オブジェクトリテラルは`{}`（中カッコ）を書くことで、新しいオブジェクトを作成できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: オブジェクトリテラルはオブジェクトの作成と同時に中身を定義できます。 オブジェクトのキーと値を`:`で区切ったものを `{}` の中に書くことで作成と初期化が同時に行えます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードで作成したオブジェクトは `key` というキー名と `"value"` という文字列の値を持つオブジェクトを作成しています。 キー名には、文字列またはSymbolを指定し、値にはプリミティブ型の値からオブジェクトまで何でも入れることができます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: このとき、オブジェクトが持つキーのことをプロパティ名と呼びます。 この場合、 `obj`というオブジェクトは`key`というプロパティを持っていると言います。
  prefs: []
  type: TYPE_NORMAL
- en: '`obj`の`key`プロパティを参照するには、`.`（ドット）でつないで参照する方法と、 `[]`（ブラケット）で参照する方法があります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: ドット記法では、プロパティ名が変数名と同じく識別子である必要があります。 そのため、次のように識別子として利用できないプロパティ名はドット記法として書くことができません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: オブジェクトはとても重要で、これから紹介する配列や正規表現もこのオブジェクトが元となっています。 詳細は「[オブジェクト](../object/)」の章で解説します。
    ここでは、オブジェクトリテラル（`{`と`}`）が出てきたら、新しいオブジェクトを作成しているんだなと思ってください。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#array)*配列リテラル*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*オブジェクトリテラルと並んで、よく使われるリテラルとして配列リテラルがあります。 配列リテラルは`[`と`]`で値をカンマ区切りで囲み、その値を持つArrayオブジェクトを作成します。
    配列（Arrayオブジェクト）とは、複数の値に順序をつけて格納できるオブジェクトの一種です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 配列は`0`からはじまるインデックス（添字）に、対応した値を保持しています。 作成した配列の要素を取得するには、配列に対して`array[index]`という構文で指定したインデックスの値を参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 配列についての詳細は「[配列](../array/)」の章で解説します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#regexp-literal)*正規表現リテラル*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptは正規表現をリテラルで書くことができます。 正規表現リテラルは`/`（スラッシュ）と`/`（スラッシュ）で正規表現のパターン文字列を囲みます。
    正規表現のパターン内では、`+`などの特定の記号や`\`（バックスラッシュ）からはじまる特殊文字が特別な意味を持ちます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、数字にマッチする特殊文字である`\d`を使い、1文字以上の数字にマッチする正規表現をリテラルで表現しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`RegExp`コンストラクタを使うことで、文字列から正規表現オブジェクトを作成できます。 しかし、特殊文字の二重エスケープが必要になり直感的に書くことが難しくなります。'
  prefs: []
  type: TYPE_NORMAL
- en: 正規表現オブジェクトについて詳しくは、「[文字列](../string/)」の章で紹介します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#primitive-and-wrapper-object)*プリミティブ型とオブジェクト*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*プリミティブ型は基本的にリテラルで表現しますが、真偽値（Boolean）、数値（Number）、文字列（String）はそれぞれオブジェクトとして表現する方法もあります。
    これらはプリミティブ型の値をラップしたようなオブジェクトであるため**ラッパーオブジェクト**と呼ばれます。'
  prefs: []
  type: TYPE_NORMAL
- en: ラッパーオブジェクトは、`new`演算子と対応するコンストラクタ関数を利用して作成できます。 たとえば、文字列のプリミティブ型に対応するコンストラクタ関数は`String`となります。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`String`のラッパーオブジェクトを作成しています。 ラッパーオブジェクトは、名前のとおりオブジェクトの一種であるため`typeof`演算子の結果も`"object"`です。
    また、オブジェクトであるため`length`プロパティなどのオブジェクトが持つプロパティを参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: しかし、明示的にラッパーオブジェクトを使うべき理由はありません。 なぜなら、JavaScriptではプリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがあるためです。
    次のコードでは、プリミティブ型の文字列データに対しても`length`プロパティへアクセスできています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: これは、プリミティブ型のデータのプロパティへアクセスする際に、対応するラッパーオブジェクトへ暗黙的に変換してからプロパティへアクセスするためです。 また、ラッパーオブジェクトを明示的に作成するには、リテラルに比べて冗長な書き方が必要になります。
    このように、ラッパーオブジェクトを明示的に作成する必要はないため、常にリテラルでプリミティブ型のデータを表現することを推奨します。
  prefs: []
  type: TYPE_NORMAL
- en: このラッパーオブジェクトへの暗黙的な型変換の仕組みについては「[ラッパーオブジェクト](../wrapper-object/)」の章で解説します。 現時点では、プリミティブ型のデータであってもオブジェクトのようにプロパティ（メソッドなども含む）を参照できるということだけを知っていれば問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#data-type-summary)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では、データ型とリテラルについて学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: 7種類のプリミティブ型とオブジェクトがある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: リテラルはデータ型の値を直接記述できる構文として定義されたもの
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: プリミティブ型の真偽値、数値、BigInt、文字列、nullはリテラル表現がある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: オブジェクト型のオブジェクト、配列、正規表現にはリテラル表現がある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: プリミティブ型のデータでもプロパティアクセスができる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ¹. JavaScriptが最初にNetscapeで実装された際に`typeof null === "object"`となるバグがありました。このバグを修正するとすでにこの挙動に依存しているコードが壊れるため、修正が見送られ現在の挙動が仕様となりました。
    詳しくは[https://2ality.com/2013/10/typeof-null.html](https://2ality.com/2013/10/typeof-null.html)を参照。
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")******************
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
