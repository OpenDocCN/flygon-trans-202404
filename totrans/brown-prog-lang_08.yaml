- en: 8Collections of Structured Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [8.1 Lists as Collective Data](#%28part._.Lists_as_.Collective_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [8.2 Sets as Collective Data](#%28part._sets-as-collections%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [8.2.1 Picking Elements from Sets](#%28part._.Picking_.Elements_from_.Sets%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [8.2.2 Computing with Sets](#%28part._.Computing_with_.Sets%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [8.3 Combining Structured and Collective Data](#%28part._.Combining_.Structured_and_.Collective_.Data%29)
    |'
  prefs: []
  type: TYPE_TB
- en: 'As we were looking at structured data [[Introduction to Structured Data](intro-struct-data.html)],
    we came across several situations where we have not one but many data: not one
    song but a playlist of them, not one animal but a zoo full of them, not one notification
    but several, not just one message (how we wish!) but many in our inbox, and so
    on. In general, then, we rarely have just a single structured datum: One notable
    exception: consider the configuration or preference information for a system.
    This might be stored in a file and updated through a user interface. Even though
    there is (usually) only one configuration at a time, it may have so many pieces
    that we won’t want to clutter our program with a large number of variables; instead,
    we might create a structure representing the configuration, and load just one
    instance of it. In effect, what would have been unconnected variables now become
    a set of linked fields. if we know we have only one, we might just have a few
    separate variables representing the pieces without going to the effort of creating
    and taking apart a structure. In general, therefore, we want to talk about collections
    of structured. Here are more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The set of messages matching a tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of messages in a conversation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of friends of a user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How are collective data different from structured data?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In structured data, we have a fixed number of possibly different kinds of values.
    In collective data, we have a variable number the same kind of value. For instance,
    we don’t say up front how many songs must be in a playlist or how many pages a
    user can have; but every one of them must be a song or a page. (A page may, of
    course, may be conditionally defined, but ultimately everything in the collection
    is still a page.)
  prefs: []
  type: TYPE_NORMAL
- en: Observe that we’ve mentioned both sets and lists above. The difference between
    a set and a list is that a set has no order, but a list has an order. This distinction
    is not vital now but we will return to it later [REF].
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, sets and lists are not the only kinds of collective data we can
    have. Here are some more:'
  prefs: []
  type: TYPE_NORMAL
- en: A family tree of people.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filesystem on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A seating chart at a party.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A social network of pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and so on. For the most part these are just as easy to program and manipulate
    as the earlier collective data once we have some experience, though some of them
    [REF] can involve more subtlety.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen tables [[Introduction to Tabular Data](intro-tabular-data.html)],
    which are a form of collective, structured data. Now we will look at a few more,
    and how to program them.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1Lists as Collective Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen one example of a collection in some depth before: lists.
    A list is not limited to numbers or strings; it can contain any kind of value,
    including structured ones. For instance, using our examples from earlier [[Defining
    and Creating Structured Data](intro-struct-data.html#%28part._struct-data-eg%29)],
    we can make a list of songs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a three-element list where each element is a song:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Thus, what we have seen earlier about building functions over lists [[Processing
    Lists](processing-lists.html)] applies here too. To illustrate, suppose we wish
    to write the function oldest-song-age, which consumes a list of songs and produces
    the oldest song in the list. (There may be more than one song from the same year;
    the age—<wbr>by our measure—<wbr>of all those songs will be the same. If this
    happens, we just pick one of the songs from the list. Because of this, however,
    it would be more accurate to say “an” rather than “the” oldest song.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s work through this with examples. To keep our examples easy to write, instead
    of writing out the full data for the songs, we’ll refer to them just by their
    variable names. Clearly, the oldest song in our list is bound to lvar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What do we write in the last case? Recall that we saw this problem earlier
    [[my-max: Examples](processing-lists.html#%28part._my-max%29)]: there is no answer
    in the empty case. In fact, the computation here is remarkably similar to that
    of my-max, because it is essentially the same computation, just asking for the
    minimum year (which would make the song the oldest).'
  prefs: []
  type: TYPE_NORMAL
- en: From our examples, we can see a solution structure echoing that of my-max. For
    the empty list, we signal an error. Otherwise, we compute the oldest song in the
    rest of the list, and compare its year against that of the first. Whichever has
    the older year is the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no guarantee there will be only oldest song, and this is
    reflected in the possibility that osr.year may equal f.year. However, our problem
    statement allowed us to pick just one such song, which is what we’ve done.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the solution above to oldest-song-age, which computes the age of the
    oldest song(s).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Haha, just kidding! You shouldn’t modify the previous solution at all! Instead,
    you should leave it alone—<wbr>it may come in handy for other purposes—<wbr>and
    instead build a new function to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 8.2Sets as Collective Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we’ve already seen, for some problems we don’t care about the order of inputs,
    nor about duplicates. Here are more examples where we don’t care about order or
    duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: Your Web browser records which Web pages you’ve visited, and some Web sites
    use this information to color visited links differently than ones you haven’t
    seen. This color is typically independent of how many times you have visited the
    page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During an election, a poll agent might record that you have voted, but does
    not need to record how many times you have voted, and does not care about the
    order in which people vote.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For such problems a list is a bad fit relative to a set. Here we will see how
    Pyret’s built-in sets work. Later [[Sets Appeal](set-representations.html)] we
    will see how we can build sets for ourselves.First, we can define sets just as
    easily as we can lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Of course, due to the nature of the language’s syntax, we have to list the elements
    in some order. Does it matter?
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How can we tell whether Pyret cares about the order?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here’s the simplest way to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we want to be especially cautious, we can write down all the other orderings
    of the elements as well, and see that Pyret doesn’t care.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many different orders are there?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Similarly for duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can again try several different kinds of duplication and confirm that sets
    ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.1Picking Elements from Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This lack of an ordering, however, poses a problem. With lists, it was meaningful
    to talk about the “first” and corresponding “rest”. By definition, with sets there
    is not “first” element. In fact, Pyret does not even offer fields similar to first
    and rest. In its place is something a little more accurate but complex.
  prefs: []
  type: TYPE_NORMAL
- en: The function set-pick returns a random element of a set. It produces a value
    of type Pick (which we get from the pick library). When we pick an element, there
    are two possibilities. One is that the set is empty (analogous to a list being
    empty), which gives us a pick-none value. The other option is called pick-some,
    which gives us an actual member of the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pick-some variant of Pick has two fields, not one. To understand why takes
    a moment’s work. Let’s explore it by choosing an element of a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (Notice that we aren’t using the r field in the pick-some case.)
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you guess why we didn’t write examples for an-elt?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run an-elt(song-set). What element do you get?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Run it again. Run it five more times.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you get the same element every time?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'No you don’t!Well, actually, it’s impossible to be certain you don’t. There
    is a very, very small likelihood you get the exact same element on every one of
    six runs. If it happens to you, keep running it more times! Pyret is designed
    to not always return the same element when picking from a set. This is on purpose:
    it’s to drive home the random nature of choosing from a set, and to prevent your
    program from accidentally depending on a particular order that Pyret might use.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given that an-elt does not return a predictable element, what if any tests can
    we write for it?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that though we can’t predict which element an-elt will produce, we do
    not it will produce an element of the set. Therefore, what we can write are tests
    that ensure the resulting element is a member of the set—<wbr>though in this case,
    that would not be particularly surprising.
  prefs: []
  type: TYPE_NORMAL
- en: 8.2.2Computing with Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have picked an element from a set, it’s often useful to obtain the
    set consisting of the remaining elements. We have already seen that choosing the
    first field of a pick-some is similar to taking the “first” of a set. We therefore
    want a way to get the “rest” of the set. However, we want the rest to what we
    obtain after excluding this particular “first”. That’s what the second field of
    a pick-some is: what’s left of the set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this, we can write functions over sets that look roughly analogous to
    functions over lists. For instance, suppose we want to compute the size of a set.
    The function looks similar to my-len [[Some Example Exercises](processing-lists.html#%28part._my-len%29)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Though the process of deriving this is similar to that we used for my-len, the
    random nature of picking elements makes it harder to write examples that the actual
    function’s behavior will match.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3Combining Structured and Collective Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the above examples illustrate, a program’s data organization will often involve
    multiple kinds of compound data, often deeply intertwined. Let’s first think of
    these in pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Come up with examples that combine:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: structured and conditional data,
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: structured and collective data, and
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: conditional and collective data.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You’ve actually seen examples of each of these above. Identify them.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finally, we might even have all three at once. For instance, a filesystem is
    usually a list (collective) of files and folders (conditional) where each file
    has several attributes (structured). Similarly, a social network has a set of
    pages (collective) where each page is for a person, organization, or other thing
    (conditional), and each page has several attributes (structured). Therefore, as
    you can see, combinations of these arise naturally in all kinds of applications
    that we deal with on a daily basis.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Take three of your favorite Web sites or apps. Identify the kinds of data they
    present. Classify these as structured, conditional, and collective. How do they
    combine these data?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
