["```\n\n```", "```\n\n    Up to now, we've used the more manual part of Coq's tactic\n    facilities.  In this chapter, we'll learn more about some of Coq's\n    powerful automation features: proof search via the auto tactic,\n    automated forward reasoning via the Ltac hypothesis matching\n    machinery, and deferred instantiation of existential variables\n    using eapply and eauto.  Using these features together with\n    Ltac's scripting facilities will enable us to make our proofs\n    startlingly short!  Used properly, they can also make proofs more\n    maintainable and robust to changes in underlying definitions.  A\n    deeper treatment of auto and eauto can be found in the\n    UseAuto chapter.\n\n    There's another major category of automation we haven't discussed\n    much yet, namely built-in decision procedures for specific kinds\n    of problems: omega is one example, but there are others.  This\n    topic will be deferred for a while longer.\n\n    Our motivating example will be this proof, repeated with just a\n    few small changes from the [Imp](Imp.html) chapter.  We will simplify\n    this proof in several stages.\n\n```", "```\n\n# The auto Tactic\n\n    Thus far, our proof scripts mostly apply relevant hypotheses or\n    lemmas by name, and one at a time.\n\n```", "```\n\n    The auto tactic frees us from this drudgery by *searching* for a\n    sequence of applications that will prove the goal\n\n```", "```\n\n    The auto tactic solves goals that are solvable by any combination of\n\n*   intros and\n\n*   apply (of hypotheses from the local context, by default).\n\n    Using auto is always \"safe\" in the sense that it will never fail\n    and will never change the proof state: either it completely solves\n    the current goal, or it does nothing. \n\n    Here is a more interesting example showing auto's power:\n\n```", "```\n\n    Proof search could, in principle, take an arbitrarily long time,\n    so there are limits to how far auto will search by default.\n\n```", "```\n\n    When searching for potential proofs of the current goal,\n    auto considers the hypotheses in the current context together\n    with a *hint database* of other lemmas and constructors.  Some\n    common lemmas about equality and logical operators are installed\n    in this hint database by default.\n\n```", "```\n\n    We can extend the hint database just for the purposes of one\n    application of auto by writing auto using ....\n\n```", "```\n\n    Of course, in any given development there will probably be\n    some specific constructors and lemmas that are used very often in\n    proofs.  We can add these to the global hint database by writing\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Hint\u00a0Constructors\u00a0c.\n\n    to tell Coq to do a Hint Resolve for *all* of the constructors\n    from the inductive definition of c.\n\n    It is also sometimes necessary to add\n\n```", "```\nHint Resolve le_antisym.\n\nExample auto_example_6' : \u2200n m p : nat,\n\u00a0\u00a0(n\u2264 p \u2192 (n \u2264 m \u2227 m \u2264 n)) \u2192\n\u00a0\u00a0n \u2264 p \u2192\n\u00a0\u00a0n = m.\nProof.\n\u00a0\u00a0intros.\n\u00a0\u00a0auto. (*\u00a0picks\u00a0up\u00a0hint\u00a0from\u00a0database\u00a0*)\nQed.\n\nDefinition is_fortytwo x := x = 42.\n\nExample auto_example_7: \u2200x, (x \u2264 42 \u2227 42 \u2264 x) \u2192 is_fortytwo x.\nProof.\n\u00a0\u00a0auto. (*\u00a0does\u00a0nothing\u00a0*)\nAbort.\n\nHint Unfold is_fortytwo.\n\nExample auto_example_7' : \u2200x, (x \u2264 42 \u2227 42 \u2264 x) \u2192 is_fortytwo x.\nProof. auto. Qed.\n\n```", "```\nTheorem ceval_deterministic': \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0induction E[1]; intros st[2] E[2]; inv E[2]; auto.\n\u00a0\u00a0- (*\u00a0E_Seq\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1] by auto.\n\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0auto.\n\u00a0\u00a0- (*\u00a0E_IfTrue\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite H in H[5]. inversion H[5].\n\u00a0\u00a0- (*\u00a0E_IfFalse\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite H in H[5]. inversion H[5].\n\u00a0\u00a0- (*\u00a0E_WhileEnd\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite H in H[2]. inversion H[2].\n\u00a0\u00a0(*\u00a0E_WhileLoop\u00a0*)\n\u00a0\u00a0- (*\u00a0b\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[4]. inversion H[4].\n\u00a0\u00a0- (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1] by auto.\n\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0auto.\nQed.\n\n```", "```\nTheorem ceval_deterministic'_alt: \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\n\n    Proof with auto.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2];\n\u00a0\u00a0generalize dependent st[2];\n\u00a0\u00a0induction E[1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros st[2] E[2]; inv E[2]...\n\u00a0\u00a0- (*\u00a0E_Seq\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1]...\n\u00a0\u00a0\u00a0\u00a0subst st'0...\n\u00a0\u00a0- (*\u00a0E_IfTrue\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite H in H[5]. inversion H[5].\n\u00a0\u00a0- (*\u00a0E_IfFalse\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite H in H[5]. inversion H[5].\n\u00a0\u00a0- (*\u00a0E_WhileEnd\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite H in H[2]. inversion H[2].\n\u00a0\u00a0(*\u00a0E_WhileLoop\u00a0*)\n\u00a0\u00a0- (*\u00a0b\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[4]. inversion H[4].\n\u00a0\u00a0- (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1]...\n\u00a0\u00a0\u00a0\u00a0subst st'0...\n    Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0H[1]:\u00a0beval\u00a0st\u00a0b\u00a0=\u00a0false\n\n    and\n\n```", "```\nLtac rwinv H[1] H[2] := rewrite H[1] in H[2]; inv H[2].\n\nTheorem ceval_deterministic'': \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2];\n\u00a0\u00a0induction E[1]; intros st[2] E[2]; inv E[2]; auto.\n\u00a0\u00a0- (*\u00a0E_Seq\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1] by auto.\n\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0auto.\n\u00a0\u00a0- (*\u00a0E_IfTrue\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rwinv H H[5].\n\u00a0\u00a0- (*\u00a0E_IfFalse\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rwinv H H[5].\n\u00a0\u00a0- (*\u00a0E_WhileEnd\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rwinv H H[2].\n\u00a0\u00a0(*\u00a0E_WhileLoop\u00a0*)\n\u00a0\u00a0- (*\u00a0b\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rwinv H H[4].\n\u00a0\u00a0- (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1] by auto.\n\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0auto. Qed.\n\n```", "```\nLtac find_rwinv :=\n\u00a0\u00a0match goal with\n\u00a0\u00a0\u00a0\u00a0H[1]: ?E = true,\n\u00a0\u00a0\u00a0\u00a0H[2]: ?E = false\n\u00a0\u00a0\u00a0\u00a0\u22a2 _ \u21d2 rwinv H[1] H[2]\n\u00a0\u00a0end.\n\n```", "```\nTheorem ceval_deterministic''': \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2];\n\u00a0\u00a0induction E[1]; intros st[2] E[2]; inv E[2]; try find_rwinv; auto.\n\u00a0\u00a0- (*\u00a0E_Seq\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1] by auto.\n\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0auto.\n\u00a0\u00a0- (*\u00a0E_WhileLoop\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1] by auto.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto. Qed.\n\n```", "```\nTheorem ceval_deterministic'''': \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2];\n\u00a0\u00a0induction E[1]; intros st[2] E[2]; inv E[2]; try find_rwinv; auto.\n\u00a0\u00a0- (*\u00a0E_Seq\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite (IHE1_1 st'0 H[1]) in *. auto.\n\u00a0\u00a0- (*\u00a0E_WhileLoop\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite (IHE1_1 st'0 H[3]) in *. auto. Qed.\n\n```", "```\nLtac find_eqn :=\n\u00a0\u00a0match goal with\n\u00a0\u00a0\u00a0\u00a0H[1]: \u2200x, ?P x \u2192 ?L = ?R,\n\u00a0\u00a0\u00a0\u00a0H[2]: ?P ?X\n\u00a0\u00a0\u00a0\u00a0\u22a2 _ \u21d2 rewrite (H[1] X H[2]) in *\n\u00a0\u00a0end.\n\n```", "```\nTheorem ceval_deterministic''''': \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2];\n\u00a0\u00a0induction E[1]; intros st[2] E[2]; inv E[2]; try find_rwinv;\n\u00a0\u00a0\u00a0\u00a0repeat find_eqn; auto.\nQed.\n\n```", "```\nModule Repeat.\n\nInductive com : Type :=\n\u00a0\u00a0| CSkip : com\n\u00a0\u00a0| CAsgn : id \u2192 aexp \u2192 com\n\u00a0\u00a0| CSeq : com \u2192 com \u2192 com\n\u00a0\u00a0| CIf : bexp \u2192 com \u2192 com \u2192 com\n\u00a0\u00a0| CWhile : bexp \u2192 com \u2192 com\n\u00a0\u00a0| CRepeat : com \u2192 bexp \u2192 com.\n\n```", "```\nNotation \"'SKIP'\" :=\n\u00a0\u00a0CSkip.\nNotation \"c1 ; c2\" :=\n\u00a0\u00a0(CSeq c[1] c[2]) (at level 80, right associativity).\nNotation \"X '::=' a\" :=\n\u00a0\u00a0(CAsgn X a) (at level 60).\nNotation \"'WHILE' b 'DO' c 'END'\" :=\n\u00a0\u00a0(CWhile b c) (at level 80, right associativity).\nNotation \"'IFB' e1 'THEN' e2 'ELSE' e3 'FI'\" :=\n\u00a0\u00a0(CIf e[1] e[2] e[3]) (at level 80, right associativity).\nNotation \"'REPEAT' e1 'UNTIL' b2 'END'\" :=\n\u00a0\u00a0(CRepeat e[1] b[2]) (at level 80, right associativity).\n\nInductive ceval : state \u2192 com \u2192 state \u2192 Prop :=\n\u00a0\u00a0| E_Skip : \u2200st,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st SKIP st\n\u00a0\u00a0| E_Ass  : \u2200st a[1] n X,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aeval st a[1] = n \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st (X ::= a[1]) (t_update st X n)\n\u00a0\u00a0| E_Seq : \u2200c[1] c[2] st st' st'',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st c[1] st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st' c[2] st'' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st (c[1] ; c[2]) st''\n\u00a0\u00a0| E_IfTrue : \u2200st st' b[1] c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st b[1] = true \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st c[1] st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st (IFB b[1] THEN c[1] ELSE c[2] FI) st'\n\u00a0\u00a0| E_IfFalse : \u2200st st' b[1] c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st b[1] = false \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st c[2] st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st (IFB b[1] THEN c[1] ELSE c[2] FI) st'\n\u00a0\u00a0| E_WhileEnd : \u2200b[1] st c[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st b[1] = false \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st (WHILE b[1] DO c[1] END) st\n\u00a0\u00a0| E_WhileLoop : \u2200st st' st'' b[1] c[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st b[1] = true \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st c[1] st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st' (WHILE b[1] DO c[1] END) st'' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st (WHILE b[1] DO c[1] END) st''\n\u00a0\u00a0| E_RepeatEnd : \u2200st st' b[1] c[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st c[1] st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st' b[1] = true \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st (CRepeat c[1] b[1]) st'\n\u00a0\u00a0| E_RepeatLoop : \u2200st st' st'' b[1] c[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st c[1] st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0beval st' b[1] = false \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st' (CRepeat c[1] b[1]) st'' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ceval st (CRepeat c[1] b[1]) st''.\n\nNotation \"c1 '/' st '\u21d3' st'\" := (ceval st c[1] st')\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 40, st at level 39).\n\n```", "```\nTheorem ceval_deterministic: \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2];\n\u00a0\u00a0induction E[1];\n\u00a0\u00a0\u00a0\u00a0intros st[2] E[2]; inv E[2]; try find_rwinv; repeat find_eqn; auto.\n\u00a0\u00a0- (*\u00a0E_RepeatEnd\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0find_rwinv.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(*\u00a0oops:\u00a0why\u00a0didn't\u00a0find_rwinv\u00a0solve\u00a0this\u00a0for\u00a0us\u00a0already? \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0answer:\u00a0we\u00a0did\u00a0things\u00a0in\u00a0the\u00a0wrong\u00a0order.\u00a0*)\n\u00a0\u00a0- (*\u00a0E_RepeatLoop\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0b\u00a0evaluates\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0find_rwinv.\nQed.\n\n```", "```\nTheorem ceval_deterministic': \u2200c st st[1] st[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2];\n\u00a0\u00a0induction E[1];\n\u00a0\u00a0\u00a0\u00a0intros st[2] E[2]; inv E[2]; repeat find_eqn; try find_rwinv; auto.\nQed.\n\nEnd Repeat.\n\n```", "```\nExample ceval_example1:\n\u00a0\u00a0\u00a0\u00a0(X ::= ANum 2;;\n\u00a0\u00a0\u00a0\u00a0\u00a0IFB BLe (AId X) (ANum 1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0THEN Y ::= ANum 3\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ELSE Z ::= ANum 4\n\u00a0\u00a0\u00a0\u00a0\u00a0FI)\n\u00a0\u00a0\u00a0/ empty_state\n\u00a0\u00a0\u00a0\u21d3 (t_update (t_update empty_state X 2) Z 4).\nProof.\n\u00a0\u00a0(*\u00a0We\u00a0supply\u00a0the\u00a0intermediate\u00a0state\u00a0st'...\u00a0*)\n\u00a0\u00a0apply E_Seq with (t_update empty_state X 2).\n\u00a0\u00a0- apply E_Ass. reflexivity.\n\u00a0\u00a0- apply E_IfFalse. reflexivity. apply E_Ass. reflexivity.\nQed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0E_Seq\u00a0:\u00a0\u2200c[1]\u00a0c[2]\u00a0st\u00a0st'\u00a0st'',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1]\u00a0/\u00a0st\u00a0\u00a0\u21d3\u00a0st'\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[2]\u00a0/\u00a0st'\u00a0\u21d3\u00a0st''\u00a0\u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(c[1]\u00a0;;\u00a0c[2])\u00a0/\u00a0st\u00a0\u21d3\u00a0st''\n\n    is quantified over a variable, st', that does not appear in its\n   conclusion, so unifying its conclusion with the goal state doesn't\n   help Coq find a suitable value for this variable.  If we leave\n   out the with, this step fails (\"Error: Unable to find an\n   instance for the variable st'\").\n\n    What's silly about this error is that the appropriate value for st'\n   will actually become obvious in the very next step, where we apply\n   E_Ass.  If Coq could just wait until we get to this step, there\n   would be no need to give the value explicitly.  This is exactly what\n   the eapply tactic gives us:\n\n```", "```\n\n    The tactic eapply H tactic behaves just like apply H except\n    that, after it finishes unifying the goal state with the\n    conclusion of H, it does not bother to check whether all the\n    variables that were introduced in the process have been given\n    concrete values during unification.\n\n    If you step through the proof above, you'll see that the goal\n    state at position 1 mentions the *existential variable* ?st'\n    in both of the generated subgoals.  The next step (which gets us\n    to position 2) replaces ?st' with a concrete value.  This new\n    value contains a new existential variable ?n, which is\n    instantiated in its turn by the following reflexivity step,\n    position 3.  When we start working on the second\n    subgoal (position 4), we observe that the occurrence of ?st'\n    in this subgoal has been replaced by the value that it was given\n    during the first subgoal. \n\n    Several of the tactics that we've seen so far, including \u2203,\n    constructor, and auto, have e... variants.  For example,\n    here's a proof using eauto:\n\n```", "```\n\n    The eauto tactic works just like auto, except that it uses\n    eapply instead of apply. \n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]