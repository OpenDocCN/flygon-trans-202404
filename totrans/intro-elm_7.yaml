- en: Scaling The Elm Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scaling The Elm Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are coming from JavaScript, you are probably wondering “where are my
    reusable components?” and “how do I do parent-child communication between them?”
    A great deal of time and effort is spent on these questions in JavaScript, but
    it just works different in Elm. **We do not think in terms of reusable components.**
    Instead, we focus on reusable *functions*. It is a functional language after all!
  prefs: []
  type: TYPE_NORMAL
- en: So this chapter will go through a few examples that show how we create **reusable
    views** by breaking out helper functions to display our data. We will also learn
    about Elm’s *module system* which helps you break your code into multiple files
    and hide implementation details. These are the core tools and techniques of building
    large app with Elm.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, I think we end up with something far more flexible and reliable
    than “reusable components” and there is no real trick. We will just be using the
    fundamental tools of functional programming!
  prefs: []
  type: TYPE_NORMAL
- en: Labeled Checkboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Labeled Checkboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Follow along in the [online editor](http://elm-lang.org/examples/checkboxes).
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your app will probably have some options people can mess with. If something
    happens, should you send them an email notification? If they come across a video,
    should it start playing by itself? That kind of thing. So you will need to create
    some HTML like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That will let people toggle the checkboxes, and using `<label>` means they
    get a much bigger area they can click on. Let’s write an Elm program that manages
    all this interaction! As always, we will take a guess at our `Model`. We know
    we need to track the user’s settings so we will put them in our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, we will want to figure out our messages and update function. Maybe
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That seems fine. Now to create our view!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not too crazy, but we are repeating ourselves a bit. How can we make
    our `view` function nicer? If you are coming from JavaScript, your first instinct
    is probably that we should make a “labeled checkbox component” but it is easier
    to just create a helper function! Here is the `view` function with a `checkbox`
    helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a highly configurable `checkbox` function. It takes two arguments
    to configure how it works: the message it produces on clicks and some text to
    show next to the checkbox. Now if we decide we want all checkboxes to have a certain
    `class`, we just add it in the `checkbox` function and it shows up everywhere!
    This is the essense of **reusable views** in Elm. Create helper functions!'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Reusable Views to Reusable Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have enough information to do a simple comparison of these approaches.
    Reusable views have a few major advantages over components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It is just functions.** We are not doing anything special here. Functions
    have all the power we need, and they are very simple to create. It is the most
    basic building block of Elm!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No parent-child communication.** If we had made a “checkbox component” we
    would have to figure out how to synchronize the state in the checkbox component
    with our overall model. “That checkbox says notifications are on, but the model
    says they are off!” Maybe we need a Flux store now? By using functions instead,
    we are able to have reuse in our view *without* disrupting our `Model` or `update`.
    They work exactly the same as before, no need to touch them!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means we can always create reusable `view` code without changing our overall
    architecture or introducing any fancy ideas. Just write smaller functions. That
    sounds nice, but let’s see some more examples to make sure it is true!
  prefs: []
  type: TYPE_NORMAL
- en: Radio Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Radio Buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Follow along in the [online editor](http://elm-lang.org/examples/radio-buttons).
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have a website that is primarily about reading, like this guide! You
    may want to have a way to choose between small, medium, and large fonts so your
    readers can customize it for their preferences. In that case, you will want some
    HTML like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Just like in the checkbox example from the previous page, this will let people
    choose the one they want, and using `<label>` means they get a much bigger area
    they can click on. Like always, we start with our `Model`. This one is kind of
    interesting because we can use [union types](union_types.html) to make it very
    reliable!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This means there are exactly three possible font sizes: `Small`, `Medium`,
    and `Large`. It is impossible to have any other value in our `fontSize` field.
    If you are coming from JavaScript, you know their alternative is to use strings
    or numbers and just hope that there is never a typo or mistake. You *could* use
    values like that in Elm, but why open yourself up to bugs for no reason?!'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** You should always be looking for opportunities to use union types
    in your data. The best way to avoid invalid states is to make them impossible
    to represent in the first place!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Alright, now we need to `update` our model. In this case we just want to switch
    between font sizes as the user toggles the radio buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to describe how to show our `Model` on screen. First let’s see
    the one where we put all our code in one function and repeat ourselves a bunch
    of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That is kind of a mess! The best thing to do is to start making helper functions
    (not components!). We see some repetition in the radio buttons, so we will start
    there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our `view` function is quite a bit easier to read now. Great!
  prefs: []
  type: TYPE_NORMAL
- en: 'If that is the only chunk of radio buttons on your page, you are done. But
    perhaps you have a couple sets of radio buttons. For example, this guide not only
    lets you set font size, but also color scheme and whether you use a serif or sans-serif
    font. Each of those can be implemented as a set of radio buttons, so we could
    do a bit more refactoring, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So if we want to let users choose a color scheme or toggle serifs, the `view`
    can reuse `viewPicker` for each case. If we do that, we may want to add additional
    arguments to the `viewPicker` function. If we want to be able to set a class on
    each `<fieldset>`, we could add an argument like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if we wanted even more flexibility, we could let people pass in whatever
    attributes they please, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And if we wanted even MORE flexibility, we could let people pass in attributes
    for each radio button too! There is really no end to what can be configured. You
    just add a bit more information to an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Too Much Reuse?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this case, we saw quite a few ways to write the same code. But which way
    is the *right* way to do it? A good rule to pick an API is **choose the absolute
    simplest thing that does everything you need**. Here are some scenarios that test
    this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: There is the only radio button thing on your page. In that case, just make them!
    Do not worry about making a highly configurable and reusable function for radio
    buttons. Refactoring is easy in Elm, so wait for a legitimate need before doing
    that work!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a couple radio button things on your page, all with the same styling.
    That is how the options on this guide look. This is a great case for sharing a
    view function. You may not even need to change any classes or add any custom attributes.
    If you do not need that, do not design for it! It is easy to add later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are a couple radio button things on your page, but they are very different.
    You could do an extremely flexible picker that lets you configure everything,
    but at some point, things that *look* similar are not actually similar enough
    for this to be worth it. So if you ever find yourself with tons of complex arguments
    configuring a view function, you may have overdone it on the reuse. I personally
    would prefer to have two chunks of *similar* view code that are both simple and
    easy to change than one chunk of view code that is complex and hard to understand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Point is, there is no magic recipe here. The answer will depend on the particulars
    of your application, and you should always try to find the simplest approach.
    Sometimes that means sharing code. Sometimes it means writing *similar* code.
    It takes practice and experience to get good at this, so do not be afraid to experiment
    to find simpler ways!
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few sections, we learned how to create reusable views. Whenever
    you start seeing a pattern in your `view` code, you can break it out into a helper
    function. But so far, we have just been growing our files longer and longer. At
    some point this gets out of control though, we do not want to have 2000 line files!
  prefs: []
  type: TYPE_NORMAL
- en: So Elm has *modules* to help you grow your codebase in a nice way. On the most
    basic level, modules let you break your code into multiple files. Like everything
    else in Elm, you should only reach for a fancier tool when you feel you *need*
    it. So if you have a 400 line file and notice that a bunch of code is all related
    to showing radio buttons in a certain way, it may be a good idea to move all the
    relevant functions and types into their own module.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the nuances of using modules *appropriately*, let’s learn
    how to use them at all!
  prefs: []
  type: TYPE_NORMAL
- en: Defining Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every module starts with a *module declaration*. So if I wanted to define my
    own version of the `Maybe` module, I might start with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The new thing here is that first line. You can read it as “This module is named
    `Optional` and it exposes *everything* to people who use the module.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Exposing everything is fine for prototyping and exploration, but a serious
    project will want to make the exposed values explicit, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Read this as “This module is named `Optional` and it exposes the `Optional`
    type, the `Some` and `None` constructors, and the `isNone` function to people
    who use the module.” Now there is no reason to list *everything* that is defined,
    so later we will see how this can be used to hide implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** If you forget to add a module declaration, Elm will use this one
    instead:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This makes things easier for beginners working in just one file. They should
    not be confronted with the module system on their first day!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay, we have our `Optional` module, but how do we use it? We can create `import`
    declarations at the top of files that describe which modules are needed. So if
    we wanted to make the “No shoes, no shirt, no service” policy explicit in code,
    we could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `import Optional` line means you can use anything exposed by the module
    as long as you put `Optional.` before it. So in the `noService` function, you
    see `Optional.Optional` and `Optional.isNone`. These are called *qualified* names.
    Which `isNone` is it? The one from the `Optional` module! It says it right there
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it is best to always use qualified names. In a project with twenty
    imports, it is extremely helpful to be able to quickly see where a value comes
    from.
  prefs: []
  type: TYPE_NORMAL
- en: That said, there are a few ways to customize an import that can come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: As
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `as` keyword to provide a shorter name. To stick with the `Optional`
    module, we could abbreviate it to just `Opt` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can refer to `Opt.Optional` and `Opt.isNone`. It is kind of nice in
    this case, but this feature is best used on very long module names. Cases like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It would be annoying to type out the whole module name every time we need a
    function from it, so we shorten it to a name that is clear and helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the `exposing` keyword to bring in the contents of the module
    *without* a qualifier. You will sometimes see things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This way you can refer to the `Optional` type directly, but still need to say
    `Optional.isNone` and `Optional.None` for everything else exposed by the module.
  prefs: []
  type: TYPE_NORMAL
- en: This `exposing` keyword works just like it does in module declarations. If you
    want to expose everything you use `exposing (..)`. If you want to expose everything
    explicitly, you would say `exposing ( Optional(..), isNone )`.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing Both
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to use `as` and `exposing` together. You could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: No matter how you choose to `import` a module, you will only be able to refer
    to types and values that the module has made publicly available. You may get to
    see only one function from a module that has twenty. That is up to the author
    of the module!
  prefs: []
  type: TYPE_NORMAL
- en: Building Projects with Multiple Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know what the Elm code looks like now, but how do we get `elm-make` to recognize
    our modules?
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Elm project has an `elm-package.json` file at its root. It will look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important parts for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"source-directories"` — This is a list of all the directories that `elm-make`
    will search through to find modules. Saying `import Optional` means `elm-make`
    will search for `src/Optional.elm` and `benchmarks/src/Optional.elm`. Notice that
    the name of the module needs to match the name of the file exactly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"dependencies"` — This lists all the [community packages](http://package.elm-lang.org/)
    you depend on. Saying `import Optional` means `elm-make` will also search the
    [`elm-lang/core`](http://package.elm-lang.org/packages/elm-lang/core/latest/)
    and [`elm-lang/html`](http://package.elm-lang.org/packages/elm-lang/html/latest/)
    packages for modules named `Optional`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typically, you will say `"source-directories": [ "src" ]` and have your project
    set up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And when you want to compile your `Main.elm` file, you say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this setup, `elm-make` will know exactly where to find the `Optional` module.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** If you want fancier directory structure for your Elm code, you can
    use module names like `Facebook.Feed.Story`. That module would need to live in
    a file at `Facebook/Feed/Story.elm` so that the file name matches the module name.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right now this section gives a brief introduction to **reusable views**. Instead
    of thinking about components, you create simple functions and configure them by
    passing in arguments. You can see the most extreme versions of this by checking
    out the following projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`evancz/elm-sortable-table`](https://github.com/evancz/elm-sortable-table)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`thebritican/elm-autocomplete`](https://github.com/thebritican/elm-autocomplete)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The README of `elm-sortable-table` has some nice guidance on how to use APIs
    like these and why they are designed as they are. You can also watch the API design
    session where Greg and I figured out an API for `elm-autocomplete` here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](466d7e55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Video link](http://youtube.com/watch?v=KSuCYUqY058)'
  prefs: []
  type: TYPE_NORMAL
- en: We talk through a lot of the design considerations that go into APIs like these.
    One big takeaway is that you should not expect to do something as elaborate as
    this for every single thing in your app! As of this writing, NoRedInk has more
    than 30k lines of Elm and one or two instances where they felt it made sense to
    design something as elaborate as this.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully those resources help guide you as you make larger and larger programs!
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** I plan to fill this section in with more examples of growing your
    `Model` and `update` functions. It is roughly the same ideas though. If you find
    yourself repeating yourself, maybe break things out. If a function gets too big,
    make a helper function. If you see related things, maybe move them to a module.
    But at the end of the day, it is not a huge deal if you let things get big. Elm
    is great at finding problems and making refactors easy, so it is not actually
    a huge deal if you have a bunch of entries in your `Model` because it does not
    seem better to break them out in some way. I will be writing more about this!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
