- en: Bad advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bad Advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some truly terrible ideas are commonly circulated as "best practice". In this
    section we provide examples and explain why they should be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Single Exit Point Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bad Advice - Single Exit Point Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some coding standards mandate that all methods should have a single exit point.
  prefs: []
  type: TYPE_NORMAL
- en: Doing so can be damaging, particularly when it is enforced by static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Single exit point is an idea with a long history dating back to the era of liberally
    applied gotos and spaghetti code.
  prefs: []
  type: TYPE_NORMAL
- en: In that context, adding constraints on what could happen within a function was
    helpful. Knowing that there is only one point that a large function can exit from
    makes it easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Many modern functional languages continue to either enforce or encourage single
    exit points.
  prefs: []
  type: TYPE_NORMAL
- en: So it must be a good idea to add this constraint to Java right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets look what happens when we are told we must only have one exit point:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single exit with statements**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we remove the single exit point constraint we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple exit**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Which version is better?
  prefs: []
  type: TYPE_NORMAL
- en: There isn't much in it, but the multiple exit point version is easier to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to apply the single exit point constraint resulted in an additional local
    variable to hold return state. In the multi exit version we can clearly see what
    is returned when none of the conditions match. In the single exit version it is
    slightly less clear as the returned value is declared at the start of the method
    then overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: So does this mean that single exit point methods are bad?
  prefs: []
  type: TYPE_NORMAL
- en: No.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to write alternate single exit implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've addressed the issues we identified earlier. We only assign to `retVal`
    once and it is clear what is assigned when none of the conditions match.
  prefs: []
  type: TYPE_NORMAL
- en: Is this superior in some way to the multi exit version?
  prefs: []
  type: TYPE_NORMAL
- en: Not really.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write a single exit method using the `?` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single exit with the ? operator**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have switched from using a statement (if) to working with expressions (i.e.
    things that return a value). This allows us to get rid of the additional variable
    while maintaining a single exit point.
  prefs: []
  type: TYPE_NORMAL
- en: Is this version clearer than the multi-exit version? That is debatable and ultimately
    a matter of personal taste.
  prefs: []
  type: TYPE_NORMAL
- en: The code using `?` is terse and some will find it harder to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The multi-exit version is more verbose but its proponents would argue it is
    easier to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: If your personal preference is for the `?` operator version, it still does not
    follow that the single exit point rule is something you should try to universally
    apply.
  prefs: []
  type: TYPE_NORMAL
- en: The most likely result is that you will push people towards writing code like
    the earlier bloated version of our method. As Java is a largely statement-based
    language, you will also encounter logic where the multi-exit version is undeniably
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Martin Fowler and Kent Beck express things nicely in "Refactoring: Improving
    the Design of Existing Code"'
  prefs: []
  type: TYPE_NORMAL
- en: '". . . one exit point is really not a useful rule. Clarity is the key principle:
    If the method is clearer with one exit point, use one exit point; otherwise don''t"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There is nothing wrong with single exit functions, but only write them when
    it makes sense to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Always Use A StringBuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bad Advice - Always Use a StringBuffer to Concatenate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This advice is doubly wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly it advocates using the synchronized `StringBuffer` rather than a `StringBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly it is an oversimplification or misunderstanding of the more nuanced
    and reasonable advice to not concatenate Strings in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding concatenation in a loop is reasonable. Using a `StringBuilder` is likely
    to be more efficient if the loop executes a reasonable number of times as it will
    avoid string allocations.
  prefs: []
  type: TYPE_NORMAL
- en: The performance difference is unlikely to be significant in most cases, but
    the resulting code isn't noticeably less-readable - so it is a premature optimization
    without a cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets see what happens when we apply this advice when no loop is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `concat` version is far clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Is it less efficient?
  prefs: []
  type: TYPE_NORMAL
- en: 'The eclipse compiler generates the following bytecode for `concat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A `StringBuilder` is created by the compiler behind the scenes to handle the
    concatenation so our simpler cleaner code produces identical bytecode to the more
    verbose option.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of loops in the code may prevent the compiler performing this optimization,
    but code without branches will be optimized every time. Although compilers may
    exist that do not support this optimization it is unlikely that you will ever
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Hungarian Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bad Advice - Hungarian Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of Hungarian notation and similar schemes is to reflect the type, scope
    or other attribute of a variable in its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: bFlag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nSize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: m_nSize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where `b` indicates a Boolean type, `n` an integer type and `m_` that the named
    variable is a field.
  prefs: []
  type: TYPE_NORMAL
- en: This is a terrible idea.
  prefs: []
  type: TYPE_NORMAL
- en: Such notation *might* be useful if you are reading code printed to paper, but
    all the information it provides is readily available in a modern IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Naming things is hard enough without adding additional concerns that the name
    must handle.
  prefs: []
  type: TYPE_NORMAL
- en: These types of notation are like comments. They add noise and must be maintained
    in tandem with the information they duplicate. If extra effort is not spent to
    maintain them they become misleading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uncle Bob Martin puts it nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '"nowadays, HN and other forms of type encoding are simply impediments. They
    make it harder to change the name or type of a variable, function, member or class.
    They make it harder to read the code. And they create the possibility that the
    encoding system will mislead the reader"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
