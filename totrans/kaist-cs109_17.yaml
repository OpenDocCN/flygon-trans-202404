- en: Classes with methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects are the basis of object-oriented programming. In Scala, every piece
    of data is an object. The type of the object determines what you can do with the
    object. Classes can contain data (the state of the object) and methods (what you
    can do with the object). You can think about a class as a blueprint for objects.
    Once you define a class, you can create objects from the blueprint using the keyword new.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an object as an atomic unit. Clients (that's the term for program code
    that uses the object) do not care about the implementation of the object, they
    only use the exposed methods and fields. "Exposed" means here that they are made
    available by the class for use by clients.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A date consists of three attributes: year, month, and day, all of them integers.
    We could thus store a date as a triple Triple<Int, Int, Int>, but then we may
    be confused if they indicate year-month-day, or day-month-year. It''s better to
    create a [data class](tutorial-data-classes.html) with three attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both methods, however, do not guarantee that our date objects will be consistent.
    Consistency means that the attributes take on only legal, meaningful values, and
    that the values of each attribute are consistent with each other. For instance,
    a day value of 31 is consistent with a month value of 3, but not with a month
    value of 4. A day value of 29 and a month value of 2 are consistent only if the
    year value indicates a leap year. With the data class defined above, there is
    nothing stopping us from making mistakes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that our Date objects are always consistent, we can add four require
    statements in the constructor of the object. It is indicated by the keyword init,
    followed by statements that are executed every time an object of this type is
    created ([days1.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/50-objects/days1.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the values are okay, nothing happens. Otherwise require throws an exception,
    and we know immediately that something is wrong. Since the Date object is immutable,
    the consistent state that is guaranteed when the object is constructed can never
    be broken and made inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: It is helpful if objects guarantee that their state is consistent. It makes
    it possible for functions working with the objects to proceed without error checking,
    and simplifies debugging since we will notice quickly when something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use my new Date object, I have to compile the definition, and can then test
    it interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the past, we had functions that took arguments of a particular type, such
    as a function date2num that converted a date, represented as year, month, and
    day, into a day index starting on January 1, 1901.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, we prefer to define functions that work on a
    specific type as a method of that type. One advantage is that it clearly documents
    the available functions for a given type (for instance, to find out what you can
    do with a String, you would look at the list of methods of the String class).
    The main advantage, however, will be the possibility of hiding or protecting information
    inside the object, as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the moment, let us add methods to convert a Date object into a day index,
    and to return the day of the week of a Date ([days3.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/50-objects/days3.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A method looks like a function definition, but is placed inside the body of
    the class. The body of the method can refer to the names of the object''s fields:
    Note the use of the fields year, month, and day in the method dayIndex.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A method can only be called if we have a reference to an object of that type
    available, and so whenever a method is executed, there is always a "current" object.
    The field names refer to the fields of this "current" object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Printing pretty dates
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Every object in Kotlin or Java can be converted to a string, and that is what
    happens when you look at an object in the interactive mode, or using println:
    the object is first converted to a string using its toString method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since we defined Date as a data class, the compiler is providing a reasonable
    toString method that shows the name of the class and the value of each field.
  prefs: []
  type: TYPE_NORMAL
- en: 'In production quality code, we may want a nice representation of dates. We
    can achieve this by overriding the default definition of the toString method,
    like this ([days4.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/50-objects/days4.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note the keyword override. It is necessary because every object already has
    a toString method. So we are not adding a new method, we are overriding the previous
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method, our object looks much prettier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Operators are methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s add a method to compute the number of days between two dates. Since
    we already have dayIndex(), this is very easy to implement ([days5.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/50-objects/days5.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And it works well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But wouldn't it be nice if we could write d2 - d1 for the difference between
    two dates instead of the not-so-pretty d2.diff(d1)?
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, unlike in Java, this is possible. In fact, in Kotlin, there is no
    difference at all between operators like + and methods like take—they are all
    implemented as methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the - operator, all we have to do is to rename our diff method into
    minus, and to add the keyword operator ([days6.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/50-objects/days6.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now calculate with dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It can be fun to define your own operators, but don't go overboard—it is only
    useful when it makes the code more readable!
  prefs: []
  type: TYPE_NORMAL
- en: Overloading
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Scala, like Java and C++ but unlike C, allows the overloading of method names:
    It is allowed to have different methods that have the same name, and only differ
    in the type of arguments they accept. Here is a simple example ([overloading.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/05-basic/overloading.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The compiler correctly determines that f(17) is a call to the first function,
    while f("CS109") is a call to the second function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of overloading to add more operators to our Date class. We
    will allow adding or subtracting a number of days to a date to obtain a new date
    ([days7.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/50-objects/days7.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there are two minus operators defined for the Date class. The compiler
    correctly selects the one we need depending on the type of the right-hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A real program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since we now have a nice date class, let''s write a program to use it ([days.kt](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/50-objects/days.kt)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As explained in the [previous section](tutorial-compiling.html), the program
    starts through the main function, which receives the command line arguments in
    the form of parameter args.
  prefs: []
  type: TYPE_NORMAL
- en: 'We compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler produces a class DaysKt for the source file containing the main
    function, so this is the class we need to call to run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
