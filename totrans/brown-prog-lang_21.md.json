["```\ndata Element:\n  | elt(val, ref parent :: Option<Element>)\nend\n```", "```\nfun is-in-same-set(e1 :: Element, e2 :: Element) -> Boolean:\n  s1 = fynd(e1)\n  s2 = fynd(e2)\n  identical(s1, s2)\nend\n```", "```\nfun update-set-with(child :: Element, parent :: Element):\n  child!{parent: some(parent)}\nend\n```", "```\nfun union(e1 :: Element, e2 :: Element):\n  s1 = fynd(e1)\n  s2 = fynd(e2)\n  if identical(s1, s2):\n    s1\n  else:\n    update-set-with(s1, s2)\n  end\nend\n```", "```\nfun fynd(e :: Element) -> Element:\n  cases (Option) e!parent:\n    | none => e\n    | some(p) => fynd(p)\nend\n```", "```\nfun fynd(e :: Element) -> Element:\n  cases (Option) e!parent block:\n    | none => e\n    | some(p) =>\n      new-parent = fynd(p)\n      e!{parent: some(new-parent)}\n      new-parent\n  end\nend\n```", "```\n[list: true, false, false, false, false]\n```", "```\n[list: 5, false, false, false, false]\n```", "```\n[list: [list: 5], empty, empty, empty, empty]\n```", "```\n[list: [list: 5, 10], empty, empty, empty, empty]\n```", "```\nSIZE = 19\nv = array-of(empty, SIZE)\n```", "```\nfun find-bucket(n): num-modulo(n, SIZE) end\n```", "```\nfun get-bucket(n): array-get-now(v, find-bucket(n)) end\nfun is-in(n): get-bucket(n).member(n) end\n```", "```\nfun set-bucket(n, anew): array-set-now(v, find-bucket(n), anew) end\nfun put(n):\n  when not(is-in(n)):\n    set-bucket(n, link(n, get-bucket(n)))\n  end\nend\n```", "```\nfun catalan(n):\n  if n == 0: 1\n  else if n > 0:\n    for fold(acc from 0, k from range(0, n)):\n      acc + (catalan(k) * catalan(n - 1 - k))\n    end\n  end\nend\n```", "```\ndata MemoryCell:\n  | mem(in, out)\nend\n\nvar memory :: List<MemoryCell> = empty\n```", "```\nfun catalan(n :: Number) -> Number:\n  answer = find(lam(elt): elt.in == n end, memory)\n  cases (Option) answer block:\n    | none =>\n      result =\n        if n == 0: 1\n        else if n > 0:\n          for fold(acc from 0, k from range(0, n)):\n            acc + (catalan(k) * catalan(n - 1 - k))\n          end\n        end\n      memory := link({in: n, out: result}, memory)\n      result\n    | some(v) => v.out\n  end\nend\n```", "```\ndata MemoryCell:\n  | mem(in, out)\nend\n\nfun memoize-1<T, U>(f :: (T -> U)) -> (T -> U):\n\n  var memory :: List<MemoryCell> = empty\n\n  lam(n):\n    answer = find(lam(elt): elt.in == n end, memory)\n    cases (Option) answer block:\n      | none =>\n        result = f(n)\n        memory := link({in: n, out: result}, memory)\n        result\n      | some(v) => v.out\n    end\n  end\nend\n```", "```\nrec catalan :: (Number -> Number) =\n  memoize-1(\n    lam(n):\n      if n == 0: 1\n      else if n > 0:\n        for fold(acc from 0, k from range(0, n)):\n          acc + (catalan(k) * catalan(n - 1 - k))\n        end\n      end\n    end)\n```", "```\nfun min3(a :: Number, b :: Number, c :: Number):\n  num-min(a, num-min(b, c))\nend\n```", "```\ndata MemoryCell2<T, U, V>:\n  | mem(in-1 :: T, in-2 :: U, out :: V)\nend\n\nfun memoize-2<T, U, V>(f :: (T, U -> V)) -> (T, U -> V):\n\n  var memory :: List<MemoryCell2<T, U, V>> = empty\n\n  lam(p, q):\n    answer = find(\n      lam(elt): (elt.in-1 == p) and (elt.in-2 == q) end,\n      memory)\n    cases (Option) answer block:\n      | none =>\n        result = f(p, q)\n        memory :=\n        link({in-1: p, in-2: q, out: result}, memory)\n        result\n      | some(v) => v.out\n    end\n  end\nend\n```", "```\nMAX-CAT = 11\n\nanswers :: Array<Option<Number>> = array-of(none, MAX-CAT + 1)\n```", "```\nfun catalan(n):\n  cases (Option) array-get-now(answers, n):\n    | none => raise(\"looking at uninitialized value\")\n    | some(v) => v\n  end\nend\n```", "```\nfun fill-catalan(upper):\n  array-set-now(answers, 0, some(1))\n  when upper > 0:\n    for map(n from range(1, upper + 1)):\n      block:\n        cat-at-n =\n          for fold(acc from 0, k from range(0, n)):\n            acc + (catalan(k) * catalan(n - 1 - k))\n          end\n        array-set-now(answers, n, some(cat-at-n))\n      end\n    end\n  end\nend\n\nfill-catalan(MAX-CAT)\n```", "```\nfun levenshtein(s1 :: List<String>, s2 :: List<String>):\n  s1-len = s1.length()\n  s2-len = s2.length()\n  answers = array2d(s1-len + 1, s2-len + 1, none)\n\n  for each(s1i from range(0, s1-len + 1)):\n    put(s1i, 0, s1i)\n  end\n  for each(s2i from range(0, s2-len + 1)):\n    put(0, s2i, s2i)\n  end\n\n  for each(s1i from range(0, s1-len)):\n    for each(s2i from range(0, s2-len)):\n      dist =\n        if index(s1, s1i) == index(s2, s2i):\n          lookup(s1i, s2i)\n        else:\n          min3(\n            1 + lookup(s1i, s2i + 1),\n            1 + lookup(s1i + 1, s2i),\n            1 + lookup(s1i, s2i))\n        end\n      put(s1i + 1, s2i + 1, dist)\n    end\n  end\n\n  lookup(s1-len, s2-len)\nend\n```"]