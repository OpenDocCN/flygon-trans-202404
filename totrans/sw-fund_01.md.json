["```\n\n```", "```\n\n# Overview\n\n    Building reliable software is hard.  The scale and complexity of\n    modern systems, the number of people involved in building them,\n    and the range of demands placed on them make it extremely\n    difficult to build software that is even more-or-less correct,\n    much less 100% correct.  At the same time, the increasing degree\n    to which information processing is woven into every aspect of\n    society greatly amplifies the cost of bugs and insecurities.\n\n    Computer scientists and software engineers have responded to these\n    challenges by developing a whole host of techniques for improving\n    software reliability, ranging from recommendations about managing\n    software projects teams (e.g., extreme programming) to design\n    philosophies for libraries (e.g., model-view-controller,\n    publish-subscribe, etc.) and programming languages (e.g.,\n    object-oriented programming, aspect-oriented programming,\n    functional programming, ...) to mathematical techniques for\n    specifying and reasoning about properties of software and tools\n    for helping validate these properties.  The present course is\n    focused on this last set of techniques.\n\n    The text weaves together five conceptual threads:\n\n    (1) basic tools from *logic* for making and justifying precise\n        claims about programs;\n\n    (2) the use of *proof assistants* to construct rigorous logical\n        arguments;\n\n    (3) *functional programming*, both as a method of programming that\n        simplifies reasoning about programs and as a bridge between\n        programming and logic;\n\n    (4) formal techniques for *reasoning about the properties of specific programs* (e.g., the fact that a sorting function or\n        a compiler obeys some formal specification); and\n\n    (5) the use of *type systems* for establishing well-behavedness\n        guarantees for *all* programs in a given programming\n        language (e.g., the fact that well-typed Java programs cannot\n        be subverted at runtime).\n\n    Each of these is easily rich enough to fill a whole course in its\n    own right, and tackling all of them together naturally means that\n    much will be left unsaid.  Nevertheless, we hope readers will find\n    that these themes illuminate and amplify each other and that\n    bringing them together creates a good foundation for digging into\n    any of them more deeply.  Some suggestions for further reading can\n    be found in the [Postscript](Postscript.html) chapter.  Bibliographic\n    information for all cited works can be found in the file\n    [Bib](Bib.html). \n\n## Logic\n\n    Logic is the field of study whose subject matter is *proofs* \u2014\n    unassailable arguments for the truth of particular propositions.\n    Volumes have been written about the central role of logic in\n    computer science.  Manna and Waldinger called it \"the calculus of\n    computer science,\" while Halpern et al.'s paper *On the Unusual Effectiveness of Logic in Computer Science* catalogs scores of\n    ways in which logic offers critical tools and insights.  Indeed,\n    they observe that, \"As a matter of fact, logic has turned out to\n    be significiantly more effective in computer science than it has\n    been in mathematics.  This is quite remarkable, especially since\n    much of the impetus for the development of logic during the past\n    one hundred years came from mathematics.\"\n\n    In particular, the fundamental tools of *inductive proof* are\n    ubiquitous in all of computer science.  You have surely seen them\n    before, perhaps in a course on discrete math or analysis of\n    algorithms, but in this course we will examine them much more\n    deeply than you have probably done so far. \n\n## Proof Assistants\n\n    The flow of ideas between logic and computer science has not been\n    unidirectional: CS has also made important contributions to logic.\n    One of these has been the development of software tools for\n    helping construct proofs of logical propositions.  These tools\n    fall into two broad categories:\n\n*   *Automated theorem provers* provide \"push-button\" operation: you give them a proposition and they return either *true* or *false* (or, sometimes, *don't know: ran out of time*). Although their capabilities are still limited to specific domains, they have matured tremendously in recent years and are used now in a multitude of settings. Examples of such tools include SAT solvers, SMT solvers, and model checkers. \n\n*   *Proof assistants* are hybrid tools that automate the more routine aspects of building proofs while depending on human guidance for more difficult aspects. Widely used proof assistants include Isabelle, Agda, Twelf, ACL2, PVS, and Coq, among many others.\n\n    This course is based around Coq, a proof assistant that has been\n    under development since 1983 and that in recent years has\n    attracted a large community of users in both research and\n    industry.  Coq provides a rich environment for interactive\n    development of machine-checked formal reasoning.  The kernel of\n    the Coq system is a simple proof-checker, which guarantees that\n    only correct deduction steps are ever performed.  On top of this\n    kernel, the Coq environment provides high-level facilities for\n    proof development, including a large library of common definitions\n    and lemmas, powerful tactics for constructing complex proofs\n    semi-automatically, and a special-purpose programming language for\n    defining new proof-automation tactics for specific situations.\n\n    Coq has been a critical enabler for a huge variety of work across\n    computer science and mathematics:\n\n*   As a *platform for modeling programming languages*, it has become a standard tool for researchers who need to describe and reason about complex language definitions. It has been used, for example, to check the security of the JavaCard platform, obtaining the highest level of common criteria certification, and for formal specifications of the x[86] and LLVM instruction sets and programming languages such as C. \n\n*   As an *environment for developing formally certified software and hardware*, Coq has been used, for example, to build CompCert, a fully-verified optimizing compiler for C, and CertiKos, a fully verified hypervisor, for proving the correctness of subtle algorithms involving floating point numbers, and as the basis for CertiCrypt, an environment for reasoning about the security of cryptographic algorithms. It is also being used to build verified implementations of the open-source RISC-V processor. \n\n*   As a *realistic environment for functional programming with dependent types*, it has inspired numerous innovations. For example, the Ynot system embeds \"relational Hoare reasoning\" (an extension of the *Hoare Logic* we will see later in this course) in Coq. \n\n*   As a *proof assistant for higher-order logic*, it has been used to validate a number of important results in mathematics. For example, its ability to include complex computations inside proofs made it possible to develop the first formally verified proof of the 4-color theorem. This proof had previously been controversial among mathematicians because part of it included checking a large number of configurations using a program. In the Coq formalization, everything is checked, including the correctness of the computational part. More recently, an even more massive effort led to a Coq formalization of the Feit-Thompson Theorem \u2014 the first major step in the classification of finite simple groups.\n\n    By the way, in case you're wondering about the name, here's what\n   the official Coq web site at INRIA (the French national research\n   lab where Coq has mostly been developed) says about it: \"Some\n   French computer scientists have a tradition of naming their\n   software as animal species: Caml, Elan, Foc or Phox are examples of\n   this tacit convention. In French, 'coq' means rooster, and it\n   sounds like the initials of the Calculus of Constructions (CoC) on\n   which it is based.\"  The rooster is also the national symbol of\n   France, and C-o-q are the first three letters of the name of\n   Thierry Coquand, one of Coq's early developers. \n\n## Functional Programming\n\n    The term *functional programming* refers both to a collection of\n    programming idioms that can be used in almost any programming\n    language and to a family of programming languages designed to\n    emphasize these idioms, including Haskell, OCaml, Standard ML,\n    F#, Scala, Scheme, Racket, Common Lisp, Clojure, Erlang, and Coq.\n\n    Functional programming has been developed over many decades \u2014\n    indeed, its roots go back to Church's lambda-calculus, which was\n    invented in the 1930s, well before the first computers (at least\n    the first electronic ones)!  But since the early '90s it has\n    enjoyed a surge of interest among industrial engineers and\n    language designers, playing a key role in high-value systems at\n    companies like Jane St. Capital, Microsoft, Facebook, and\n    Ericsson.\n\n    The most basic tenet of functional programming is that, as much as\n    possible, computation should be *pure*, in the sense that the only\n    effect of execution should be to produce a result: it should be\n    free from *side effects* such as I/O, assignments to mutable\n    variables, redirecting pointers, etc.  For example, whereas an\n    *imperative* sorting function might take a list of numbers and\n    rearrange its pointers to put the list in order, a pure sorting\n    function would take the original list and return a *new* list\n    containing the same numbers in sorted order.\n\n    A significant benefit of this style of programming is that it\n    makes programs easier to understand and reason about.  If every\n    operation on a data structure yields a new data structure, leaving\n    the old one intact, then there is no need to worry about how that\n    structure is being shared and whether a change by one part of the\n    program might break an invariant that another part of the program\n    relies on.  These considerations are particularly critical in\n    concurrent systems, where every piece of mutable state that is\n    shared between threads is a potential source of pernicious bugs.\n    Indeed, a large part of the recent interest in functional\n    programming in industry is due to its simpler behavior in the\n    presence of concurrency.\n\n    Another reason for the current excitement about functional\n    programming is related to the first: functional programs are often\n    much easier to parallelize than their imperative counterparts.  If\n    running a computation has no effect other than producing a result,\n    then it does not matter *where* it is run.  Similarly, if a data\n    structure is never modified destructively, then it can be copied\n    freely, across cores or across the network.  Indeed, the\n    \"Map-Reduce\" idiom, which lies at the heart of massively\n    distributed query processors like Hadoop and is used by Google to\n    index the entire web is a classic example of functional\n    programming.\n\n    For purposes of this course, functional programming has yet\n    another significant attraction: it serves as a bridge between\n    logic and computer science.  Indeed, Coq itself can be viewed as a\n    combination of a small but extremely expressive functional\n    programming language plus a set of tools for stating and proving\n    logical assertions.  Moreover, when we come to look more closely,\n    we find that these two sides of Coq are actually aspects of the\n    very same underlying machinery \u2014 i.e., *proofs are programs*.  \n\n## Program Verification\n\n    Approximately the first third of *Software Foundations* is devoted\n    to developing the conceptual framework of logic and functional\n    programming and gaining enough fluency with Coq to use it for\n    modeling and reasoning about nontrivial artifacts.  In the middle\n    third, we turn our attention to two broad topics of critical\n    importance in building reliable software (and hardware):\n    techniques for proving specific properties of particular\n    *programs* and for proving general properties of whole programming\n    *languages*.\n\n    For both of these, the first thing we need is a way of\n    representing programs as mathematical objects, so we can talk\n    about them precisely, plus ways of describing their behavior in\n    terms of mathematical functions or relations.  Our main tools for\n    these tasks are *abstract syntax* and *operational semantics*, a\n    method of specifying programming languages by writing abstract\n    interpreters.  At the beginning, we work with operational\n    semantics in the so-called \"big-step\" style, which leads to simple\n    and readable definitions when it is applicable.  Later on, we\n    switch to a lower-level \"small-step\" style, which helps make some\n    useful distinctions (e.g., between different sorts of\n    nonterminating program behaviors) and which is applicable to a\n    broader range of language features, including concurrency.\n\n    The first programming language we consider in detail is *Imp*, a\n    tiny toy language capturing the core features of conventional\n    imperative programming: variables, assignment, conditionals, and\n    loops.\n\n    We study two different ways of reasoning about the properties of\n    Imp programs.  First, we consider what it means to say that two\n    Imp programs are *equivalent* in the intuitive sense that they\n    exhibit the same behavior when started in any initial memory\n    state.  This notion of equivalence then becomes a criterion for\n    judging the correctness of *metaprograms* \u2014 programs that\n    manipulate other programs, such as compilers and optimizers.  We\n    build a simple optimizer for Imp and prove that it is correct.\n\n    Second, we develop a methodology for proving that a given Imp\n    program satisfies some formal specifications of its behavior.  We\n    introduce the notion of *Hoare triples* \u2014 Imp programs annotated\n    with pre- and post-conditions describing what they expect to be\n    true about the memory in which they are started and what they\n    promise to make true about the memory in which they terminate \u2014\n    and the reasoning principles of *Hoare Logic*, a domain-specific\n    logic specialized for convenient compositional reasoning about\n    imperative programs, with concepts like \"loop invariant\" built in.\n\n    This part of the course is intended to give readers a taste of the\n    key ideas and mathematical tools used in a wide variety of\n    real-world software and hardware verification tasks. \n\n## Type Systems\n\n    Our final major topic, covering approximately the last third of\n    the course, is *type systems*, which are powerful tools for\n    establishing properties of *all* programs in a given language.\n\n    Type systems are the best established and most popular example of\n    a highly successful class of formal verification techniques known\n    as *lightweight formal methods*.  These are reasoning techniques\n    of modest power \u2014 modest enough that automatic checkers can be\n    built into compilers, linkers, or program analyzers and thus be\n    applied even by programmers unfamiliar with the underlying\n    theories.  Other examples of lightweight formal methods include\n    hardware and software model checkers, contract checkers, and\n    run-time monitoring techniques.\n\n    This also completes a full circle with the beginning of the book:\n    the language whose properties we study in this part, the *simply typed lambda-calculus*, is essentially a simplified model of the\n    core of Coq itself!\n\n```", "```\n\n# Practicalities\n\n## Chapter Dependencies\n\n    A diagram of the dependencies between chapters and some \n    paths through the material can be found in the file [deps.html](deps.html). \n\n## System Requirements\n\n    Coq runs on Windows, Linux, and OS X.  You will need:\n\n*   A current installation of Coq, available from the Coq home page. Everything should work with version 8.4 (or 8.5). \n\n*   An IDE for interacting with Coq. Currently, there are two choices: \n\n    *   Proof General is an Emacs-based IDE. It tends to be preferred by users who are already comfortable with Emacs. It requires a separate installation (google \"Proof General\"). \n\n         Adventurous users of Coq within Emacs may also want to check out extensions such as company-coq and control-lock. \n\n    *   CoqIDE is a simpler stand-alone IDE. It is distributed with Coq, so it should be available once you have Coq installed. It can also be compiled from scratch, but on some platforms this may involve installing additional packages for GUI libraries and such.\n\n## Exercises\n\n    Each chapter includes numerous exercises.  Each is marked with a\n    \"star rating,\" which can be interpreted as follows:\n\n*   One star: easy exercises that underscore points in the text and that, for most readers, should take only a minute or two. Get in the habit of working these as you reach them. \n\n*   Two stars: straightforward exercises (five or ten minutes). \n\n*   Three stars: exercises requiring a bit of thought (ten minutes to half an hour). \n\n*   Four and five stars: more difficult exercises (half an hour and up).\n\n    Also, some exercises are marked \"advanced,\" and some are marked\n    \"optional.\"  Doing just the non-optional, non-advanced exercises\n    should provide good coverage of the core material.  Optional\n    exercises provide a bit of extra practice with key concepts and\n    introduce secondary themes that may be of interest to some\n    readers.  Advanced exercises are for readers who want an extra\n    challenge and a deeper cut at the material.\n\n    *Please do not post solutions to the exercises in a public places*: \n    Software Foundations is widely used both for self-study and for\n    university courses.  Having solutions easily available makes it\n    much less useful for courses, which typically have graded homework\n    assignments.  We especially request that readers not post\n    solutions to the exercises anyplace where they can be found by\n    search engines.\n\n## Downloading the Coq Files\n\n    A tar file containing the full sources for the \"release version\"\n    of this book (as a collection of Coq scripts and HTML files) is\n    available here:\n\n```", "```\n\n    (If you are using the book as part of a class, your professor may\n    give you access to a locally modified version of the files, which\n    you should use instead of the release version.)\n\n```", "```\n\n# Translations\n\n    Thanks to the efforts of a team of volunteer translators,\n    *Software Foundations* can be enjoyed in Japanese at\n    [http://proofcafe.org/sf](http://proofcafe.org/sf).  A Chinese translation is underway. \n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]