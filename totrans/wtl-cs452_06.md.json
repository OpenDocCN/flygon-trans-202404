["```\nkernel( ) {\n  initialize( );  // includes starting the first user task\n  FOREVER {\n    request = getNextRequest( );\n    handle( request );\n  }\n}\n```", "```\nint getNextRequest( ) {\n  active = schedule( ... );\n  return activate( active );\n```", "```\n         ldr  pc, [pc, #0x18] ; 0xe590f018 is the binary encoding\n        ```", "```\n; In calling code\n                      ; store values of r0-r3\n                      ; load arguments into r0-r3\n   bl  <entry point>  ; this treats the pc and lr specially\n                      ; lr <- pc, pc <- <entry point>\n                      ; r0 has the return value\n                      ; r1-r3 have useless junk\n\n; In called code\nentry point:\n   mov     ip, sp\n   stmdb   sp!, {fp, ip, lr} ; and usually others, \n                             ; determined by the registers the function uses\n   ...\n   ldmia   sp, {fp, sp, pc} ; and whatever others\n                            ; exact inverse of stmdb\n```", "```\n   ldmia   sp, {fp, sp, lr}\n   mov     pc, lr\n```", "```\n   bl   junk\n   .\n   .\n   .\njunk:\n   mov   pc, lr\n```", "```\n; In calling code\n                          ; Store r0-r3\n                          ; Put arguments into r0-r3\n                          ; 0x08 holds the kernel entry point\n   swi  n                 ; n identifies which system call you are calling\n                          ; retrieve return value from r0\n                          ; r1-r3 have even more useless junk\n\n; In kernel\nkernel entry:\n; Change to system mode\n; Save user state on user stack\n; Return to supervisor mode\n   ldr    r4, [lr, #-4]    ; gets the request type\n; At this point you can get the arguments\n; Where are they? Why couldn't you retrieve them earlier?\n; Retrieve kernel state from kernel stack\n; Do kernel work\n```", "```\n   swi   n\n   .\n   .\n   .\nkernel entry:\n   movs   pc, lr\n```", "```\nkernel entry:\n```", "```\n    ldr r3, [lr, #-4]\n    ```", "```\n    movs   pc, lr\n    ```"]