- en: '31Mutation: Structures and Variables'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 31Mutation：结构和变量
- en: '|     [31.1 Separating Meaning from Notation](#%28part._mutation-notation%29)
    |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [31.1 将含义与符号分离](#%28part._mutation-notation%29) |'
- en: '|     [31.2 Mutation and Closures](#%28part._.Mutation_and_.Closures%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [31.2 变异和闭包](#%28part._.Mutation_and_.Closures%29) |'
- en: '|     [31.3 Mutable Structures](#%28part._.Mutable_.Structures%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [31.3 可变结构](#%28part._.Mutable_.Structures%29) |'
- en: '|       [31.3.1 Extending the Language Representation](#%28part._.Extending_the_.Language_.Representation%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.1 扩展语言表示](#%28part._.Extending_the_.Language_.Representation%29)
    |'
- en: '|       [31.3.2 The Interpretation of Boxes](#%28part._.The_.Interpretation_of_.Boxes%29)
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.2 方框的解释](#%28part._.The_.Interpretation_of_.Boxes%29) |'
- en: '|       [31.3.3 Can the Environment Help?](#%28part._.Can_the_.Environment_.Help_%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.3 环境是否有助于？](#%28part._.Can_the_.Environment_.Help_%29) |'
- en: '|       [31.3.4 Welcome to the Store](#%28part._.Welcome_to_the_.Store%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.4 欢迎来到商店](#%28part._.Welcome_to_the_.Store%29) |'
- en: '|       [31.3.5 Interpreting Boxes](#%28part._store-passing-style%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.5 解释方框](#%28part._store-passing-style%29) |'
- en: '|       [31.3.6 Implementing Mutation: Subtleties and Variations](#%28part._.Implementing_.Mutation__.Subtleties_and_.Variations%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [31.3.6 实现变异：微妙和变化](#%28part._.Implementing_.Mutation__.Subtleties_and_.Variations%29)
    |'
- en: '|     [31.4 Variables](#%28part._mut-vars%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|     [31.4 变量](#%28part._mut-vars%29) |'
- en: '|       [31.4.1 The Syntax of Variable Assignment](#%28part._.The_.Syntax_of_.Variable_.Assignment%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [31.4.1 变量赋值的语法](#%28part._.The_.Syntax_of_.Variable_.Assignment%29)
    |'
- en: '|       [31.4.2 Interpreting Variables](#%28part._interp-vars%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|       [31.4.2 解释变量](#%28part._interp-vars%29) |'
- en: '|       [31.4.3 Reference Parameter Passing](#%28part._reference-param%29)
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|       [31.4.3 引用参数传递](#%28part._reference-param%29) |'
- en: '|     [31.5 The Design of Stateful Language Operations](#%28part._design-of-state-ops%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|     [31.5 有状态语言操作的设计](#%28part._design-of-state-ops%29) |'
- en: '|     [31.6 Typing State](#%28part._typing-state%29) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|     [31.6 键入状态](#%28part._typing-state%29) |'
- en: '|       [31.6.1 Mutation and Polymorphism](#%28part._.Mutation_and_.Polymorphism%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|       [31.6.1 变异和多态](#%28part._.Mutation_and_.Polymorphism%29) |'
- en: '|       [31.6.2 Typing the Initial Value](#%28part._.Typing_the_.Initial_.Value%29)
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|       [31.6.2 键入初始值](#%28part._.Typing_the_.Initial_.Value%29) |'
- en: 31.1Separating Meaning from Notation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31.1将含义与符号分离
- en: Which of these is the same?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中哪一个是相同的？
- en: f = 3
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: f = 3
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: o.f = 3
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: o.f = 3
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: f = 3
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: f = 3
- en: 'Assuming all three are in Java, the first and third could behave exactly like
    each other or exactly like the second: it all depends on whether f is a local
    identifier (such as a parameter) or a field of the object (i.e., the code is really
    this.f = 3).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这三者都在Java中，则第一种和第三种可能会完全像第二种一样，也可能会完全像第二种一样：这完全取决于f是局部标识符（例如参数）还是对象的字段（即，代码实际上是this.f
    = 3）。
- en: 'In either case, we are asking the evaluator to permanently change the value
    bound to f. This has important implications for other observers. Until now, for
    a given set of inputs, a computation always returned the same value. Now, the
    answer depends on when it was invoked: above, it depends on whether it was invoked
    before or after the value of f was changed. The introduction of time has profound
    effects on predicting the behavior of programs.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一情况下，我们都要求评估器永久更改绑定到f的值。 这对其他观察者有重要的影响。 到目前为止，对于给定的输入集，计算总是返回相同的值。 现在，答案取决于何时调用它：在上面，它取决于在f的值更改之前还是之后调用了它。
    时间的引入对于预测程序行为具有深远的影响。
- en: However, there are really two quite different notions of change buried in the
    uniform syntax above. Changing the value of a field (o.f = 3 or this.f = 3) is
    extremely different from changing that of an identifier (f = 3 where f is bound
    as a parameter or a local inside the method, not by the object). We will explore
    these in turn. We’ll tackle fields below, and return to identifiers in [Variables](#%28part._mut-vars%29).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在上述统一语法中实际上有两种完全不同的变化概念。 更改字段的值（o.f = 3或this.f = 3）与更改标识符的值极为不同（f = 3其中f是方法内的参数或本地绑定，而不是由对象绑定）。
    我们将依次探讨这些。 我们将在下面处理字段，并在[变量](#%28part._mut-vars%29)中返回标识符。
- en: 'To study both these features, we will as usual write interpreters. However,
    to make sure we expose their essence, we will write these interpreters without
    the use of state. That is, we will do something quite remarkable: write mutation-free
    interpreters that faithfully mimic languages with mutation. The key to this will
    be a special pattern of passing information around in a computation.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了研究这两个特性，我们通常会编写解释器。然而，为了确保我们暴露它们的本质，我们将写这些解释器而不使用状态。也就是说，我们将做一些非常了不起的事情：编写无突变的解释器，其忠实地模拟了具有突变的语言。这其中的关键是一种特殊的计算中传递信息的模式。
- en: 31.2Mutation and Closures
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 31.2突变和闭包
- en: 'Before we proceed, make sure you’ve understood boxes ([A Canonical Mutable
    Structure](State__Change__and_More_Equality.html#%28part._mutable-structures%29)),
    and especially the interaction between mutation and closures ([Interaction of
    Mutation with Closures: Counters](State__Change__and_More_Equality.html#%28part._state-closures-counter%29)).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们继续之前，请确保你已经理解了boxes（[A Canonical Mutable Structure](State__Change__and_More_Equality.html#%28part._mutable-structures%29)），特别是突变和闭包之间的交互（[Interaction
    of Mutation with Closures: Counters](State__Change__and_More_Equality.html#%28part._state-closures-counter%29)）。'
- en: 'The interaction with closures (and their first-cousin, objects [REF]) is particularly
    subtle. Consider the following situation:This example was described to me by Corky
    Cartwright. you are writing a GUI program to implement a calculator. The GUI element
    corresponding to each calculator button needs a callback—<wbr>essentially a closure—<wbr>that,
    when invoked, will report that that particular button was pressed. Therefore,
    it is tempting to initialize this as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与闭包（及其近亲对象[REF]）的交互尤其微妙。考虑以下情况：这个例子是由Corky Cartwright描述给我的。你正在编写一个GUI程序来实现一个计算器。与每个计算器按钮对应的GUI元素需要一个回调——实质上是一个闭包——当调用时，它将报告该特定按钮被按下。因此，很容易这样初始化：
- en: '| for(var i = 0; i < 10; i++) { |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| for(var i = 0; i < 10; i++) { |'
- en: '|   button[i] = function() { return i; } |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|   button[i] = function() { return i; } |'
- en: '| } |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: 'This pseudo-code translates with minimal change to any number of languages,
    with and without static types, ranging from Python to Swift. (Assume button has
    been initialized appropriately.)Notice that the closures created above all have
    i in their environment. Now let us try to inspect the behavior of these closures:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪代码几乎不需要任何改变就可以转换成任意数量的语言，包括有静态类型和没有静态类型的语言，从Python到Swift都可以。（假设button已经被适当初始化。）请注意，上面创建的所有闭包都在它们的环境中具有i。现在让我们试着检查这些闭包的行为：
- en: '| for(var i = 0; i < 10; i++) { |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| for(var i = 0; i < 10; i++) { |'
- en: '|   println(button[i]()) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|   println(button[i]()) |'
- en: '| } |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: That is, we extract the ith closure from button and apply it to no arguments.
    This evaluates the return i statement.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们从button中提取第i个闭包，并将其应用到无参数上。这会评估返回i语句。
- en: 'We might have liked this to produce the sequence of values 0, 1, 2, and so
    on through to 9. In fact, however, it produces ten outputs, all the same: 10.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望这会产生0、1、2等值的序列，一直到9。但实际上，它产生了十个相同的输出：10。
- en: Do Now!
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see why? How would you fix this?
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你看明白了吗？你会如何修复这个问题？
- en: The problem is that i in the for loop is allocated only once. Therefore, all
    the closures share the same i. Because that value had to become 10 for the for
    loop to terminate, all the closures report the value 10.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于for循环中的i只分配一次。因此，所有的闭包共享相同的i。因为那个值必须变成10才能让for循环终止，所以所有的闭包都报告值为10。
- en: With traditional for loops, there is no obvious way out of this problem. This
    seemingly confusing behavior often confounds programmers new to languages that
    make extensive use of closures. Because they cannot change the behavior of for
    loops, many languages have introduced new versions of for (or new keywords inside
    for) to address this problem. The solution is always to allocate a fresh i on
    each iteration, so that each closure is over a different variable; the looping
    construct copies the previous value of i as the initial value of the new one before
    applying the updater (in this case, i++) and then performing the comparison and
    loop body.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统的for循环，这个问题并没有明显的解决方法。这种看似令人困惑的行为经常让那些刚接触闭包语言的程序员感到困惑。因为他们无法改变for循环的行为，所以许多语言都引入了新版本的for（或者for内部的新关键字）来解决这个问题。解决方案始终是在每次迭代时分配一个新的i，这样每个闭包就都是对不同的变量进行操作；循环结构会将上一个i的值复制为新的i的初始值，然后应用更新器（在本例中为i++），然后执行比较和循环体。
- en: 'Observe that when programming functionally, the desired behavior comes for
    free. For instance:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数式编程时，期望的行为是免费的。例如：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It is easier to see why the definition of funs works by writing the use of
    map more explicitly:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|     Box<Integer> b1 = new Box<Integer>(1); |'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Thus, we can see that on each iteration the outer lam(i): ... is applied, allocating
    a new i, which is the one closed over by the inner lam(): ....'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 setboxC 表达式中，盒位置和其新值都是表达式。后者并不奇怪，但前者可能会。这意味着我们可以在相应的 Pyret 中编写这样的程序：
- en: 31.3Mutable Structures
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '| where: |'
- en: 'Equipped with these examples, let us now return to adding mutation to the language
    in the form of mutable structures (which are also a good basis for mutable objects
    [REF]). Besides mutable structures themselves, note that we must sometimes perform
    mutation in groups (e.g., removing money from one bank account and depositing
    it in another). Therefore, it is useful to be able to sequence a group of mutable
    operations. We will call this begin: it evaluates its sub-terms terms in order
    and returns the value of the last one.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 装备了这些例子，现在让我们回到以可变结构的形式向语言添加突变（这也是可变对象的一个很好的基础[REF]）。
- en: Exercise
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|   index(l, 0)!{v : 1} |'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does it matter whether begin evaluates its sub-terms in some particular,
    specified order?
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|   l = [list: b0, b1] |'
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter what this order is?
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '| public static void main (String[] args) { |'
- en: Exercise
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个顺序很重要吗？
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define begin by desugaring into let (and hence into anonymous functions).
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '|   b1 = box(1) |'
- en: 'This is an excellent illustration of the non-canonical nature of desguaring.
    We’ve chosen to add to the core a construct that is certainly not necessary. If
    our goal was to shrink the size of the interpreter—<wbr>perhaps at some cost to
    the size of the input program—<wbr>we would not make this choice. But our goal
    here is to understand key ideas in languages, so we choose the combination of
    features that will be most instructive. Even though it is possible to eliminate
    begin as syntactic sugar, it will prove extremely useful for understanding how
    mutation works. Therefore, we will add a simple, two-term version of sequencing
    (seqC) to the core. In turn, because our core language is becoming unwieldy, we
    will drop Boolean values and conditional values except where their presence makes
    things more interesting: and it does not here.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解糖非规范性质的一个很好的例证。我们选择向核心添加一个构造，这个构造确实是不必要的。如果我们的目标是缩小解释器的大小—<wbr>也许以某种对输入程序大小的代价—<wbr>我们不会做出这个选择。但我们这里的目标是理解语言中的关键思想，因此我们选择组合最具教学意义的功能。即使可以消除
    begin 作为语法糖，但它将证明对理解突变的工作方式非常有用。因此，我们将向核心添加一个简单的两项版本的序列（seqC）。反过来，由于我们的核心语言变得难以操纵，我们将放弃布尔值和条件值，除非它们的存在使事情更有趣：在这里并不是。
- en: 31.3.1Extending the Language Representation
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 funs 的定义写得更加明确以更好地理解其工作原理是更容易的：
- en: 'First, let’s extend our core language datatype:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们扩展我们的核心语言数据类型：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Observe that in a setboxC expression, both the box position and its new value
    are expressions. The latter is unsurprising, but the former might be. It means
    we can write programs such as this in corresponding Pyret:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可变结构本身之外，注意我们有时必须以组的形式执行突变（例如，从一个银行账户中取钱并将其存入另一个账户）。因此，能够按顺序对一组可变操作进行排序是很有用的。我们将其称为开始：它按顺序评估其子项项，并返回最后一个的值。
- en: '| fun make-box-list(): |'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: 为什么开始要按特定的顺序评估其子项项呢？
- en: '|   b0 = box(0) |'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| end |'
- en: '|   b1 = box(1) |'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: 练习
- en: '|   l = [list: b0, b1] |'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '因此，我们可以看到，在每次迭代中，外部 lam(i): ... 被应用，分配一个新的 i，这是内部 lam(): ... 所闭合的 i。'
- en: '|   index(l, 0)!{v : 1} |'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   l = make-box-list() |'
- en: '|   index(l, 1)!{v : 2} |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '这将评估为一个包含 1 和第二个包含 2 的盒子列表。注意，在每个突变语句中，我们都使用了一个复杂的表达式—<wbr>例如，index(l, 0)—<wbr>而不是一个字面值或标识符来获取盒子并进行突变（!{v
    : 1}）。这正是类似于 Java 的语言，其中可以（在某种类型上采取自由）编写'
- en: '|   l |'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   b0 = box(0) |'
- en: '| where: |'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| fun make-box-list(): |'
- en: '|   l = make-box-list() |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: 31.3 可变结构
- en: '|   index(l, 0)!v is 1 |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   index(l, 0)!v is 1 |'
- en: '|   index(l, 1)!v is 2 |'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     Box<Integer> b0 = new Box<Integer>(0); |'
- en: '| end |'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: 31.3.1 扩展语言表示
- en: 'This evaluates to a list of boxes, the first containing 1 and the second 2.
    Observe that in each of the mutation statements, we are using a complex expression—<wbr>e.g.,
    index(l, 0)—<wbr>rather than a literal or an identifier to obtain the box before
    mutating it (!{v : 1}). the first argument to the This is precisely analogous
    to languages like Java, where one can (taking some type liberties) write'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '|   index(l, 1)!v is 2 |'
- en: '| public static void main (String[] args) { |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   index(l, 1)!{v : 2} |'
- en: '|     Box<Integer> b0 = new Box<Integer>(0); |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: 练习
- en: '|     Box<Integer> b1 = new Box<Integer>(1); |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: 通过将 begin 解糖为 let（因此解糖为匿名函数）来定义 begin。
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|   l |'
- en: '|     ArrayList<Box<Integer>> l = new ArrayList<Box<Integer>>(); |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|     ArrayList<Box<Integer>> l = new ArrayList<Box<Integer>>(); |'
- en: '|     l.add(b0); |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|     l.add(b0); |'
- en: '|     l.add(b1); |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|     l.add(b1); |'
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|     l.get(0).set(1); |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|     l.get(0).set(1); |'
- en: '|     l.get(1).set(2); |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|     l.get(1).set(2); |'
- en: '| } |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: Notice that l.get(0) is a compound expression being used to find the appropriate
    box, and evaluates to the box object on which set is invoked.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意l.get(0)是一个复合表达式，用于找到适当的盒子，并评估为调用set的盒子对象。
- en: For convenience, we will assume that we have implemented desguaring to provide
    us with (a) let and (b) if necessary, more than two terms in a sequence (which
    can be desugared into nested sequences). We will also sometimes write expressions
    in the original Pyret syntax, both for brevity (because the core language terms
    can grow quite large and unwieldy) and so that you can run these same terms in
    Pyret and observe what answers they produce. As this implies, we are taking the
    behavior in Pyret—<wbr>which mutable structures are similar in behavior to those
    of just about every mainstream language with mutable objects and structures—<wbr>as
    the reference behavior.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将假设我们已经实现了解糖以提供（a）let和（b）如果需要，一个序列中超过两个术语的解糖（可以解糖为嵌套序列）。我们有时也会用原始的Pyret语法编写表达式，既为了简洁（因为核心语言术语可能会变得相当庞大和笨重），也为了让你能够在Pyret中运行相同的术语并观察它们产生的答案。正如这意味着的那样，我们正在以Pyret中的行为为参考行为，其中可变结构的行为类似于几乎所有主流语言中可变对象和结构的行为。
- en: 31.3.2The Interpretation of Boxes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.2盒子的解释
- en: First, because we’ve introduced a new kind of value, the box, we have to update
    the set of values:<mut-str-value/1> ::=
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为我们引入了一种新的值，即盒子，我们必须更新值的集合：<mut-str-value/1> ::=
- en: '|   data Value: |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|   data Value: |'
- en: '|     &#124; numV(n :: Number) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; numV(n :: Number) |'
- en: '|     &#124; closV(f :: ExprC%(is-fdC), e :: Env) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; closV(f :: ExprC%(is-fdC), e :: Env) |'
- en: '|     &#124; boxV(v :: Value) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; boxV(v :: Value) |'
- en: '|   end |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: Now let’s begin by reproducing our current interpreter:<mut-str-interp/1> ::=
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始重现我们当前的解释器：<mut-str-interp/1> ::=
- en: '|   fun interp(e :: ExprC, nv :: Env) -> Value: |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|   fun interp(e :: ExprC, nv :: Env) -> Value: |'
- en: '|     cases (ExprC) e: |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|     cases (ExprC) e: |'
- en: '|       &#124; numC(n) => numV(n) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; numC(n) => numV(n) |'
- en: '|       &#124; plusC(l, r) => plus-v(interp(l, nv), interp(r, nv)) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; plusC(l, r) => plus-v(interp(l, nv), interp(r, nv)) |'
- en: '|       &#124; multC(l, r) => mult-v(interp(l, nv), interp(r, nv)) |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; multC(l, r) => mult-v(interp(l, nv), interp(r, nv)) |'
- en: '|       &#124; idC(s) => lookup(s, nv) |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; idC(s) => lookup(s, nv) |'
- en: '|       &#124; fdC(_, _) => closV(e, nv) |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; fdC(_, _) => closV(e, nv) |'
- en: '|       &#124; appC(f, a) => |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; appC(f, a) => |'
- en: '|         clos = interp(f, nv) |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|         clos = interp(f, nv) |'
- en: '|         arg-val = interp(a, nv) |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|         arg-val = interp(a, nv) |'
- en: '|         interp(clos.f.body, |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|         interp(clos.f.body, |'
- en: '|           xtnd-env(bind(clos.f.arg, arg-val), clos.e)) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|           xtnd-env(bind(clos.f.arg, arg-val), clos.e)) |'
- en: '|       [<mut-str-interp/1-boxC>](#%28elem._mut-str-interp%2F1-box.C%29) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/1-boxC>](#%28elem._mut-str-interp%2F1-box.C%29) |'
- en: '|       [<mut-str-interp/1-unboxC>](#%28elem._mut-str-interp%2F1-unbox.C%29)
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/1-unboxC>](#%28elem._mut-str-interp%2F1-unbox.C%29)
    |'
- en: '|       [<mut-str-interp/1-seqC>](#%28elem._mut-str-interp%2F1-seq.C%29) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/1-seqC>](#%28elem._mut-str-interp%2F1-seq.C%29) |'
- en: '|     end |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: (You’ll soon see why the setboxC case is missing.)Two of these cases should
    be easy. When we’re given a box expression, we simply evaluate the content and
    return it wrapped in a boxV:<mut-str-interp/1-boxC> ::=
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (很快你就会明白为什么缺少setboxC的情况。这两种情况应该很容易。当我们得到一个盒子表达式时，我们只需评估内容并将其包装在盒子V中返回：<mut-str-interp/1-boxC>
    ::=
- en: '|   &#124; boxC(v) => boxV(interp(v, nv)) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; boxC(v) => boxV(interp(v, nv)) |'
- en: Similarly, extracting a value from a box is easy:<mut-str-interp/1-unboxC> ::=
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，从盒子中提取值很容易：<mut-str-interp/1-unboxC> ::=
- en: '|   &#124; unboxC(b) => interp(b, nv).v |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; unboxC(b) => interp(b, nv).v |'
- en: By now, you should be constructing a healthy set of test cases to make sure
    these behave as you’d expect.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该正在构建一组健康的测试用例，以确保它们的行为符合你的期望。
- en: Of course, we haven’t done any hard work yet. All the interesting behavior is,
    presumably, hidden in the treatment of setboxC. It may therefore surprise you
    that we’re going to look at seqC first instead (and you’ll see why we included
    it in the core).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还没有做任何艰苦的工作。所有有趣的行为，大概都隐藏在setboxC的处理中。因此，也许会让你惊讶的是，我们将首先看seqC而不是setboxC（你将看到为什么我们将其包含在核心中）。
- en: Let’s take the most natural implementation of a sequence of two instructions:<mut-str-interp/1-seqC>
    ::=
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采用最自然的两条指令序列的实现：<mut-str-interp/1-seqC> ::=
- en: '|   &#124; seqC(b1, b2) => |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; seqC(b1, b2) => |'
- en: '|     b1-value = interp(b1, nv) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|     b1-value = interp(b1, nv) |'
- en: '|     b2-value = interp(b2, nv) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|     b2-value = interp(b2, nv) |'
- en: '|     b2-value |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|     b2-value |'
- en: 'That is, we evaluate the first term, then the second, and return the result
    of the second.You should immediately spot something troubling. We bound the result
    of evaluating the first term, but didn’t subsequently do anything with it. That’s
    okay: presumably the first term contained a mutation expression of some sort,
    and its value is uninteresting. Thus, an equivalent implementation might be this:<mut-str-interp/1-seqC/2>
    ::='
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，我们先评估第一个表达式，然后再评估第二个，并返回第二个的结果。你应该立即发现了一些令人不安的地方。我们绑定了评估第一个表达式的结果，但随后没有对其进行任何操作。没关系：可能第一个表达式包含了某种变异表达式，它的值是无趣的。因此，等价的实现可能是这样的：<mut-str-interp/1-seqC/2>
    ::=
- en: '|   &#124; seqC(b1, b2) => |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; seqC(b1, b2) => |'
- en: '|     interp(b1, nv) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b1, nv) |'
- en: '|     interp(b2, nv) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b2, nv) |'
- en: Not only is this slightly dissatisfying in that it just uses Pyret’s sequential
    behavior, it can’t possibly be right! This can only work only if the result of
    the mutation is being stored somewhere. But because our interpreter only computes
    values and does not perform any mutation itself—<wbr>because that would be cheating—<wbr>any
    mutations in interp(b1, nv) are completely lost. This is obviously not what we
    want. (And therefore, we’re not going to even attempt to define what to do in
    the setbox case.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅略显不满，因为它只使用了 Pyret 的顺序行为，而且肯定是错误的！只有当变异的结果被存储在某个地方时，这才能起作用。但是因为我们的解释器只计算值，并且不执行任何变异本身——因为那样就是作弊——interp(b1,
    nv) 中的任何变异都完全丢失了。这显然不是我们想要的。（因此，我们甚至不打算定义在 setbox 情况下该怎么办。）
- en: 31.3.3Can the Environment Help?
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.3 环境能起到帮助作用吗？
- en: 'Here is an input example that can help:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以帮助的输入示例：
- en: '| (let ([b (box 0)]) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (begin (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|   (begin (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|                 (set-box! b (+ 1 (unbox b)))) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|                 (set-box! b (+ 1 (unbox b)))) |'
- en: '|          (unbox b))) |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|          (unbox b))) |'
- en: In Racket, this evaluates to 2.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Racket 中，这个求值结果为 2。
- en: Exercise
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Represent this expression in ExprC.
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 ExprC 中表示此表达式。
- en: Let’s consider the evaluation of the inner sequence. In both cases, the expression
    (the representation of (set-box! ...)) is exactly identical. Yet something is
    changing underneath, because this causes the value of the box to go from 0 to
    2! We can “see” this even more clearly if instead we evaluate
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑内部序列的评估。在两种情况下，表达式（即 (set-box! ...) 的表示）完全相同。但是底层发生了一些变化，因为这导致箱子的值从 0 变为
    2！如果我们改为评估以下表达式，我们可以更清楚地“看到”这一点
- en: '| (let ([b (box 0)]) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| (let ([b (box 0)]) |'
- en: '|   (+ (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|   (+ (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|             (unbox b)) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|             (unbox b)) |'
- en: '|      (begin (set-box! b (+ 1 (unbox b))) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|      (begin (set-box! b (+ 1 (unbox b))) |'
- en: '|             (unbox b)))) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|             (unbox b)))) |'
- en: which evaluates to 3. Here, the two calls to interp in the rule for addition
    are evaluating exactly the same textual expression in both cases. Yet somehow
    the effects from the left branch of the addition are being felt in the right branch.Spukhafte
    Fernwirkung.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估为 3。在这里，对加法规则中的两次 interp 调用在两种情况下都评估完全相同的文本表达式。但是不知何故，左分支的效果在右分支中产生了影响。远程神秘作用。
- en: If the interpreter is being given precisely the same expression, how can it
    possibly avoid producing precisely the same answer? The most obvious way is if
    the interpreter’s other parameter, the environment, were somehow different. As
    of now the exact same environment is sent to both both branches of the sequence
    and both arms of the addition, so our interpreter—<wbr>which produces the same
    output every time on a given input—<wbr>cannot possibly produce the answers we
    want.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解释器被给予完全相同的表达式，它如何可能避免产生完全相同的答案？最明显的方法是，如果解释器的另一个参数，即环境，在某种程度上是不同的。到目前为止，完全相同的环境被发送到序列的两个分支和加法的两个分支，因此我们的解释器——在给定输入时每次产生相同的输出——无法产生我们想要的答案。
- en: 'Here is what we know so far:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所知道的是：
- en: We must somehow make sure the interpreter is fed different arguments on calls
    that are expected to potentially produce different results.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须确保解释器在调用时得到不同的参数，以期望产生不同的结果。
- en: We must return from the interpreter some record of the mutations made when evaluating
    its argument expression.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须返回解释器在评估其参数表达式时所做的变异的记录。
- en: 'Because the expression is what it is, the first point suggests that we might
    try to use the environment to reflect the differences between invocations. In
    turn, the second point suggests that each invocation of the interpreter should
    also return the environment, so it can be passed to the next invocation. So the
    interpreter should presumably be modified to return both the value and an updated
    environment. That is, the interpreter consumes an expression and environment;
    it evaluates in that environment, updating it as it proceeds; when the expression
    is done evaluating, the interpreter returns the answer (as it did before), along
    with an updated environment, which in turn is sent to the next invocation of the
    interpreter. And the treatment of setboxC would somehow impact the environment
    to reflect the mutation.Before we dive into the implementation, however, we should
    consider the consequences of such a change. The environment already serves an
    important purpose: it holds deferred substitutions. In that respect, it already
    has a precise semantics—<wbr>given by substitution—<wbr>and we must be careful
    to not alter that. One consequence of its tie to substitution is that it is also
    the repository of lexical scope information. If we were to allow the extended
    environment escape from one branch of addition and be used in the other, for instance,
    consider the impact on the equivalent of the following program:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因为表达式是什么样子的，第一个观点表明我们可以尝试使用环境来反映调用之间的差异。反过来，第二个观点表明解释器的每次调用也应该返回环境，以便可以传递给下一次调用。因此，解释器应该被修改为同时返回值和更新后的环境。也就是说，解释器接受一个表达式和环境；它在该环境中进行评估，并随着过程的进行更新它；当表达式完成评估时，解释器返回答案（就像以前一样），以及一个更新后的环境，然后将其发送到解释器的下一次调用。而且，对setboxC的处理应该以某种方式影响环境以反映变化。然而，在我们深入实施之前，我们应该考虑这种变化的后果。环境已经发挥了重要作用：它保存了延迟替换。在这方面，它已经具有了精确的语义——由替换给出——我们必须小心不要改变它。与替换的联系的一个结果是它也是词法作用域信息的存储库。例如，如果我们允许扩展环境从一个加法分支逃逸并在另一个分支中使用，那么考虑以下程序的等效物的影响：
- en: '| (+ (let ([b (box 0)]) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| (+ (let ([b (box 0)]) |'
- en: '|      1) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|      1) |'
- en: '|    b) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|    b) |'
- en: 'It should be evident that this program has an error: b in the right branch
    of the addition is unbound (the scope of the b in the left branch ends with the
    closing of the let—<wbr>if this is not evident, desugar the above expression to
    use functions). But the extended environment at the end of interpreting the let
    clearly has b bound in it.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个程序有一个错误：加法的右分支中的b是未绑定的（左分支中b的作用域在let结束时结束——如果这不明显，请将上述表达式去糖以使用函数）。但在解释let结束时，扩展环境中明显有b绑定。
- en: Exercise
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Work out the above problem in detail and make sure you understand it.
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 详细解决上述问题并确保你理解它。
- en: You could try various other related proposals, but they are likely to all have
    similar failings. For instance, you may decide that, because the problem has to
    do with additional bindings in the environment, you will instead remove all added
    bindings in the returned environment. Sounds attractive? Did you remember we have
    closures?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试各种其他相关的提案，但它们很可能都存在类似的缺陷。例如，你可能会决定，由于问题涉及到环境中的附加绑定，你将在返回的环境中删除所有添加的绑定。听起来不错？你还记得我们有闭包吗？
- en: Exercise
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Consider the representation of the following program:'
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑以下程序的表示：
- en: ''
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| (let ([a (box 1)]) |'
  id: totrans-169
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([a (box 1)]) |'
- en: '|   (let ([f (fun x (+ x (unbox a)))]) |'
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (let ([f (fun x (+ x (unbox a)))]) |'
- en: '|     (begin |'
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|     （开始 |'
- en: '|       (set-box! a 2) |'
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (set-box! a 2) |'
- en: '|       (f 10)))) |'
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '|       (f 10)))) |'
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What problems does this example cause?
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个例子引起了什么问题？
- en: Rather, we should note that while the constraints described above are all valid,
    the solution we proposed is not the only one. Observe that neither condition actually
    requires the environment to be the responsible agent. Indeed, it is quite evident
    that the environment cannot be the principal agent. We need something else.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该注意到，虽然上述描述的约束都是有效的，但我们提出的解决方案并不是唯一的解决方案。请注意，实际上，这两个条件都不要求环境成为负责的代理。事实上，很明显环境不能是主要的代理。我们需要其他东西。
- en: 31.3.4Welcome to the Store
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.4欢迎来到商店
- en: The preceding discussion tells us that we need two repositories to accompany
    the expression, not one. One of them, the environment, continues to be responsible
    for maintaining lexical scope. But the environment cannot directly map identifiers
    to their value, because the value might change. Instead, something else needs
    to be responsible for maintaining the dynamic state of mutated boxes. This latter
    data structure is called the store.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的讨论告诉我们，我们需要两个存储库来陪伴表达式，而不是一个。其中一个，环境，继续负责维护词法范围。但环境不能直接将标识符映射到它们的值，因为值可能会改变。相反，需要有其他东西负责维护突变框的动态状态。这后一个数据结构称为存储器。
- en: 'Like the environment, the store is a partial map. Its domain could be any abstract
    set of names, but it is natural to think of these as numbers, meant to stand for
    memory locations. This is because the store in the semantics maps directly onto
    (abstracted) physical memory in the machine, which is traditionally addressed
    by numbers. Thus the environment maps names to locations, and the store maps locations
    to values:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 像环境一样，存储器是一个部分映射。其定义域可以是任何抽象名称集合，但自然地将其视为数字，表示内存位置。这是因为语义中的存储器直接映射到（抽象化的）机器物理内存，传统上由数字地址寻址。因此，环境将名称映射到位置，而存储器将位置映射到值：
- en: '[PRE3]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We’ll also equip ourselves with a function to look up values in the store,
    just as we already have one for the environment (which now returns locations instead):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将配备一个函数来在存储器中查找值，就像我们已经为环境配备了一个函数一样（它现在返回位置而不是值）：
- en: '[PRE4]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exercise
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fill in the bodies of lookup and fetch.
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 填写查找和提取的主体。
- en: With this, we can refine our notion of values to the correct one:<mut-str-value>
    ::=
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以将值的概念精确化为正确的：<mut-str-value> ::=
- en: '|   data Value: |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|   data Value: |'
- en: '|     &#124; numV(n :: Number) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; numV(n :: Number) |'
- en: '|     &#124; closV(f :: ExprC, e :: Env) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; closV(f :: ExprC, e :: Env) |'
- en: '|     &#124; boxV(l :: Number) |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|     &#124; boxV(l :: Number) |'
- en: '|   end |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: 31.3.5Interpreting Boxes
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 31.3.5解释框箱
- en: 'Now we have something that the interpreter can return, updated, reflecting
    mutations during the evaluation of the expression, without having to change the
    environment in any way. Because a function can return only one value, we will
    use an ad hoc object with two fields: v for the value (which will (effectively)
    be the same as the one the interpreter originally returned), and st for the (potentially)
    updated store. We will use the following helper function to assemble the result:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了解释器可以返回的东西，经过更新，反映了在表达式评估过程中的突变，而不需要以任何方式更改环境。因为函数只能返回一个值，我们将使用一个具有两个字段的特设对象：v用于值（它将（有效地）与解释器最初返回的值相同），st用于（潜在地）更新的存储器。我们将使用以下辅助函数来组装结果：
- en: '[PRE5]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Exercise
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we say “effectively” and “potentially” above?
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么我们在上面说“有效地”和“潜在地”？
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Hint for “effectively”: look at closures.'
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “有效地”的提示：看闭包。
- en: Thus our interpreter becomes:<mut-str-interp> ::=
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的解释器变成了：<mut-str-interp> ::=
- en: '|   fun interp(e :: ExprC, nv :: Env, st :: Store): |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|   fun interp(e :: ExprC, nv :: Env, st :: Store): |'
- en: '|     cases (ExprC) e: |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|     cases (ExprC) e: |'
- en: '|       [<mut-str-interp/numC>](#%28elem._mut-str-interp%2Fnum.C%29) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/numC>](#%28elem._mut-str-interp%2Fnum.C%29) |'
- en: '|       [<mut-str-interp/plusC>](#%28elem._mut-str-interp%2Fplus.C%29) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/plusC>](#%28elem._mut-str-interp%2Fplus.C%29) |'
- en: '|       [<mut-str-interp/idC>](#%28elem._mut-str-interp%2Fid.C%29) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/idC>](#%28elem._mut-str-interp%2Fid.C%29) |'
- en: '|       [<mut-str-interp/fdC>](#%28elem._mut-str-interp%2Ffd.C%29) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/fdC>](#%28elem._mut-str-interp%2Ffd.C%29) |'
- en: '|       [<mut-str-interp/appC>](#%28elem._mut-str-interp%2Fapp.C%29) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/appC>](#%28elem._mut-str-interp%2Fapp.C%29) |'
- en: '|       [<mut-str-interp/boxC>](#%28elem._mut-str-interp%2Fbox.C%29) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/boxC>](#%28elem._mut-str-interp%2Fbox.C%29) |'
- en: '|       [<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29) |'
- en: '|       [<mut-str-interp/setboxC>](#%28elem._mut-str-interp%2Fsetbox.C%29)
    |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/setboxC>](#%28elem._mut-str-interp%2Fsetbox.C%29)
    |'
- en: '|       [<mut-str-interp/seqC>](#%28elem._mut-str-interp%2Fseq.C%29) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|       [<mut-str-interp/seqC>](#%28elem._mut-str-interp%2Fseq.C%29) |'
- en: '|     end |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: The easiest one to dispatch is numbers. Remember that we have to return the
    store reflecting all mutations that happened while evaluating the given expression.
    Because a number is a constant, no mutations could have happened, so the returned
    store is the same as the one passed in:<mut-str-interp/numC> ::=
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易分配的是数字。记住，我们必须返回反映在评估给定表达式时发生的所有突变的存储。因为数字是一个常数，所以不可能发生突变，所以返回的存储与传入的存储相同：<mut-str-interp/numC>
    ::=
- en: '|   &#124; numC(n) => ret(numV(n), st) |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; numC(n) => ret(numV(n), st) |'
- en: A similar argument applies to closure creation; observe that we are speaking
    of the creation, not use, of closures:<mut-str-interp/fdC> ::=
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于闭包的创建也适用类似的论点；请注意我们正在讨论闭包的创建，而不是使用：<mut-str-interp/fdC> ::=
- en: '|   &#124; fdC(_, _) => ret(closV(e, nv), st) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; fdC(_, _) => ret(closV(e, nv), st) |'
- en: Identifiers are almost as straightforward, though if you are simplistic, you’ll
    get a type error that will alert you that to obtain a value, you must now look
    up both in the environment and in the store:<mut-str-interp/idC> ::=
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符几乎和数字一样简单，但是如果你太简单化了，你会得到一个类型错误，提示你要获取一个值，你现在必须在环境和存储中查找：<mut-str-interp/idC>
    ::=
- en: '|   &#124; idC(s) => ret(fetch(lookup(s, nv), st), st) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; idC(s) => ret(fetch(lookup(s, nv), st), st) |'
- en: Notice how lookup and fetch compose to produce the same result that lookup alone
    produced before.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意查找和提取如何组合以产生与之前仅使用查找产生的相同结果。
- en: Now things get interesting.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事情变得有趣起来了。
- en: Let’s take sequencing. Clearly, we need to interpret the two terms.<mut-str-interp/seqC/alt>
    ::=
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈序列。显然，我们需要解释这两个项。<mut-str-interp/seqC/alt> ::=
- en: '|   &#124; seqC(b1, b2) => |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; seqC(b1, b2) => |'
- en: '|     interp(b1, nv, st) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b1, nv, st) |'
- en: '|     interp(b2, nv, st) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b2, nv, st) |'
- en: Oh, but wait. The whole point was to evaluate the second term in the store returned
    by the first one—<wbr>otherwise there would have been no point to all these changes.
    Therefore, instead we must evaluate the first term, capture the resulting store,
    and use it to evaluate the second. (Evaluating the first term also yields its
    value, but sequencing ignores this value and assumes the first term was run purely
    for its potential mutations.) Thus:<mut-str-interp/seqC> ::=
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，等等。整个重点是评估由第一个返回的存储中的第二项——否则所有这些变化就没有意义。因此，相反地，我们必须评估第一项，捕获结果存储，并使用它来评估第二项。（评估第一项还产生它的值，但是顺序忽略了这个值，并假定第一项纯粹是为了其潜在的突变而运行。）因此：<mut-str-interp/seqC>
    ::=
- en: '|   &#124; seqC(b1, b2) => |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; seqC(b1, b2) => |'
- en: '|     b1-value = interp(b1, nv, st) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|     b1-value = interp(b1, nv, st) |'
- en: '|     interp(b2, nv, b1-value.st) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|     interp(b2, nv, b1-value.st) |'
- en: 'This says to interpret the first term: interp(b1, nv, st); name the resulting
    value, which contains v and st fields, b1-value; and evaluate the second term
    in the store from the first: interp(b2, nv, b1-value.st). The result will be the
    value and store returned by the second term, which is what we expect. The fact
    that the first term’s effect is only on the store can be read from the code because
    we never use b1-value.v.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要解释第一项：interp(b1, nv, st)；给产生的值，其中包含v和st字段，命名为b1-value；并在第一个存储中评估第二项：interp(b2,
    nv, b1-value.st)。结果将是第二项返回的值和存储，这是我们预期的。因为我们从未使用b1-value.v，所以第一项的影响仅仅是在存储上，这可以从代码中看出。
- en: Do Now!
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Spend a moment contemplating the code above. You’ll soon need to adjust your
    eyes to read this pattern fluently.
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 花一会儿时间思考上面的代码。你很快就需要调整你的眼睛来流畅地阅读这种模式。
- en: Now let’s move on to the binary arithmetic primitives. These are similar to
    sequencing in that they have two sub-terms, but in this case we really do care
    about the value from each branch. As usual, we’ll look at only plusC since multC
    is virtually identical.<mut-str-interp/plusC> ::=
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论二进制算术原语。这些与序列相似，因为它们有两个子项，但在这种情况下，我们确实关心每个分支的值。像往常一样，我们只看plusC，因为multC几乎相同。<mut-str-interp/plusC>
    ::=
- en: '|   &#124; plusC(l, r) => |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; plusC(l, r) => |'
- en: '|     lv = interp(l, nv, st) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|     lv = interp(l, nv, st) |'
- en: '|     rv = interp(r, nv, lv.st) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|     rv = interp(r, nv, lv.st) |'
- en: '|     ret(plus-v(lv.v, rv.v), rv.st) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|     ret(plus-v(lv.v, rv.v), rv.st) |'
- en: Observe that we’ve repeated the pattern because we have two sub-expressions
    to evaluate whose values we want to use. Thus the first store (lv.st) is used
    to interpret the second expression, and the overall result returns that of the
    second (rv.st).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们重复了这个模式，因为我们有两个子表达式要评估，我们希望使用它们的值。因此，第一个存储（lv.st）用于解释第二个表达式，并且总体结果返回第二个表达式的结果（rv.st）。
- en: 'Here’s an important distinction. When we evaluate a term, we usually use the
    same environment for all its sub-terms in accordance with the scoping rules of
    the language. The environment thus flows in a recursive-descent pattern. In contrast,
    the store is threaded: rather than using the same store in all branches, we take
    the store from one branch and pass it on to the next, and take the result and
    send it back out. This pattern is called store-passing style.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the penny drops. We see that store-passing style is our secret ingredient:
    it enables the environment to preserve lexical scope while still giving a binding
    structure that can reflect changes. Our intution told us that the environment
    had to somehow participate in obtaining different results for the same syntactic
    expression, and we can now see how it does: not directly, by itself changing,
    but indirectly, by referring to the store, which updates. Now we only need to
    see how the store itself “changes”.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with boxing. To store a value in a box, we have to first allocate
    a new place in the store where its value will reside. The value corresponding
    to a box will then remember this location, for use in box mutation. To obtain
    a fresh value each time, we will use the stateful counter example we have seen
    earlier ([Interaction of Mutation with Closures: Counters](State__Change__and_More_Equality.html#%28part._state-closures-counter%29)):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Given this, we can now define the interpretation of box creation:<mut-str-interp/boxC>
    ::=
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; boxC(v) => |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '|     val = interp(v, nv, st) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '|     loc = new-loc() |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '|     ret(boxV(loc), |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '|       xtnd-sto(cell(loc, val.v), st)) |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: Do Now!
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that we have relied above on new-loc, which is itself implemented in
    terms of boxes! This is outright cheating. How would you modify the interpreter
    so that we no longer need mutation for this little bit of state?
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To eliminate new-loc, the simplest option would be to add another parameter
    to and return value from the interpreter, representing the largest address used
    so far. Every operation that allocates in the store would return an incremented
    address, while all others would return it unchanged. In other words, this is precisely
    another application of the store-passing pattern. Writing the interpreter this
    way would make it extremely unwieldy and might obscure the more important use
    of store-passing for the store itself, which is why we have not done so. However,
    it is important to make sure that we can: that’s what tells us that we are not
    reliant on state to add state to the language.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Now that boxes are recording the location in memory, getting the value corresponding
    to them is easy.<mut-str-interp/unboxC> ::=
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; unboxC(b) => |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '|     val = interp(b, nv, st) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '|     ret(fetch(val.v.l, val.st), val.st) |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: It’s the same pattern we saw before, where we have to use fetch to obtain the
    actual value residing at that location. Note that we are relying on Racket to
    halt with an error if the underlying value isn’t actually a boxV; otherwise it
    would be dangerous to not check, since this would be tantamount to dereferencing
    arbitrary memory [REF memory safety].
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how to update the value held in a box. First we have to evaluate
    the box expression to obtain a box, and the value expression to obtain the new
    value to store in it. The box’s value is going to be a boxV holding a location.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In principle we want to “change”, or override, the value at that location in
    the store. We can do this in two ways.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: One is to traverse the store, find the old binding for that location, and replace
    it with the new one, copying all the other store bindings unchanged.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other, lazier, option is to simply extend the store with a new binding for
    that location, which works provided we always obtain the most recent binding for
    a location (which is how lookup works in the environment, so fetch can do the
    same in the store).Observe that this latter option forces us to commit to lists
    rather than to sets.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code below is written to be independent of these options:<mut-str-interp/setboxC>
    ::=
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; setboxC(b, v) => |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
- en: '|     b-val = interp(b, nv, st) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '|     v-val = interp(v, nv, b-val.st) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: '|     ret(v-val.v, |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
- en: '|       xtnd-sto(cell(b-val.v.l, v-val.v), v-val.st)) |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: If we’ve implemented xtnd-sto as link above, we’ve actually taken the lazier
    (and slightly riskier, because of its dependence on the implementation of fetch)
    option.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the other version of store alteration, whereby we update an existing
    binding and thereby avoid multiple bindings for a location in the store.
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When we look for a location to override the value stored at it, can the location
    fail to be present? If so, write a program that demonstrates this. If not, explain
    what invariant of the interpreter prevents this from happening.
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Alright, we’re now done with everything other than application! Most of application
    should already be familiar: evaluate the function position, evaluate the argument
    position, interpret the closure body in an extension of the closure’s environment...but
    how do stores interact with this?<mut-str-interp/appC> ::='
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; appC(f, a) => |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
- en: '|     clos = interp(f, nv, st) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
- en: '|     clos-v :: Value = clos.v |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
- en: '|     clos-st :: Store = clos.st |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
- en: '|     arg-val = interp(a, nv, clos-st) |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
- en: '|     [<mut-str-interp/appC/core>](#%28elem._mut-str-interp%2Fapp.C%2Fcore%29)
    |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
- en: Let’s start by thinking about extending the closure environment. The name we’re
    extending it with is obviously the name of the function’s formal parameter. But
    what location do we bind it to? To avoid any confusion with already-used locations
    (a confusion we will explicitly introduce later!—<wbr>[Reference Parameter Passing](#%28part._reference-param%29)),
    let’s just allocate a new location. This location is used in the environment,
    and the value of the argument resides at this location in the store:<mut-str-interp/appC/core>
    ::=
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '|   new-loc = new-loc() |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '|   interp(clos-v.f.body, |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '|     xtnd-env(bind(clos-v.f.arg, new-loc), clos-v.e), |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '|     xtnd-sto(cell(new-loc, arg-val.v), arg-val.st)) |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: 'Because we have not said the function parameter is mutable, there is no real
    need to have implemented procedure calls this way. We could instead have followed
    the same strategy as before. Indeed, observe that the mutability of this location
    will never be used: only setboxC changes what’s in an existing store location
    (the xtnd-sto above is technically a store initialization), and then only when
    they are referred to by boxVs, but no box is being allocated above.You could call
    this the useless app store. However, we have chosen to implement application this
    way for uniformity, and to reduce the number of cases we’d have to handle.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s a useful exercise to try to limit the use of store locations only to boxes.
    How many changes would you need to make?
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '31.3.6Implementing Mutation: Subtleties and Variations'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we’ve finished the implementation, there are still many subtleties
    and insights to discuss.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit in our implementation is a subtle and important decision: the order
    of evaluation. For instance, why did we not implement addition thus?'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <mut-str-interp/plusC/alt> ::=
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|   &#124; plusC(l, r) => |'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|     rv = interp(r, nv, st) |'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|     lv = interp(l, nv, rv.st) |'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|     ret(plus-v(lv.v, rv.v), lv.st) |'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'It would have been perfectly consistent to do so. Similarly, embodied in the
    pattern of store-passing is the decision to evaluate the function position before
    the argument. Observe that:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Previously, we delegated such decisions to the underlying language implementation.
    Now, store-passing has forced us to sequentialize the computation, and hence make
    this decision ourselves (whether we realized it or not).
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Even more importantly, this decision is now a semantic one. Before there were
    mutations, one branch of an addition, for instance, could not affect the value
    produced by the other branch.The only effect they could have was halting with
    an error or failing to terminate—<wbr>which, to be sure, are certainly observable
    effects, but at a much more gross level. A program would not terminate with two
    different answers depending on the order of evaluation. Because each branch can
    have mutations that impact the value of the other, we must choose some order so
    that programmers can predict what their program is going to do! Being forced to
    write a store-passing interpreter has made this clear.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更重要的是，这个决定现在是一个语义决定。在没有变异之前，例如，加法的一个分支不能影响另一个分支产生的值。它们唯一的影响是停止并出现错误或���法终止——<wbr>这确实是可观察的效果，但在更粗略的层面上。程序不会因为评估顺序的不同而以两个不同的答案终止。因为每个分支都可能有影响其他分支值的变异，所以我们必须选择某种顺序，以便程序员可以预测他们的程序将要做什么！被迫编写一个传递存储的解释器已经让这一点变得清楚。
- en: Observe that in the application rule, we are passing along the dynamic store,
    i.e., the one resulting from evaluating both function and argument. This is precisely
    the opposite of what we said to do with the environment. This distinction is critical.
    The store is, in effect, “dynamically scoped”, in that it reflects the history
    of the computation, not its lexical shape. Because we are already using the term
    “scope” to refer to the bindings of identifiers, however, it would be confusing
    to say “dynamically scoped” to refer to the store. Instead, we simply say that
    it is persistent.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在应用规则中，我们传递了动态存储，即从评估函数和参数得到的存储。这恰恰与我们对环境的要求相反。这种区别至关重要。存储实际上是“动态作用域的”，因为它反映了计算的历史，而不是其词法形状。然而，由于我们已经使用术语“作用域”来指代标识符的绑定，因此说“动态作用域”来指代存储会令人困惑。相反，我们只是说它是持久的。
- en: 'Languages sometimes dangerously conflate these two. In C, for instance, values
    bound to local identifiers are allocated (by default) on the stack. However, the
    stack matches the environment, and hence disappears upon completion of the call.
    If the call, however, returned references to any of these values, these references
    are now pointing to unused or even overridden memory: a genuine source of serious
    errors in C programs. The problem is that programmers want the values themselves
    to persist; but the storage for those values has been conflated with that for
    identifiers, who come and go with lexical scope.'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时语言会危险地混淆这两者。例如，在C语言中，绑定到本地标识符的值（默认情况下）是在堆栈上分配的。然而，堆栈与环境匹配，因此在调用完成后会消失。然而，如果调用返回对这些值的引用，这些引用现在指向未使用或甚至被覆盖的内存：这是C程序中严重错误的真正来源。问题在于程序员希望值本身保持持久；但是为这些值分配的存储与标识符的存储混为一谈，后者随着词法范围的出现和消失而变化。
- en: 'We have already discussed how there are two strategies for overriding the store:
    to simply extend it (and rely on fetch to extract the newest one) or to “search-and-replace”.
    The latter strategy has the virtue of not holding on to useless store bindings
    that will can never be obtained again.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经讨论了覆盖存储的两种策略：简单地扩展它（并依赖于提取最新存储的fetch）或“搜索和替换”。后一种策略的优点是不保留永远无法再次获得的无用存储绑定。
- en: 'However, this does not cover all the wasted memory. Over time, we cease to
    be able to access some boxes entirely: e.g., if they are bound to only one identifier,
    and that identifier is no longer in scope. These locations are called garbage.
    Thinking more conceptually, garbage locations are those whose elimination does
    not have any impact on the value produced by a program. There are many strategies
    for automatically identifying and reclaiming garbage locations, usually called
    garbage collection [REF].'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这并不能覆盖所有浪费的内存。随着时间的推移，我们将无法访问某些盒子：例如，如果它们仅绑定到一个标识符，而该标识符不再在作用域内。这些位置被称为垃圾。从更概念上来看，垃圾位置是那些消除对程序产生的值没有任何影响的位置。通常有许多自动识别和回收垃圾位置的策略，通常称为垃圾收集[REF]。
- en: It’s very important to evaluate every expression position and thread the store
    that results from it. Consider, for instance, this alternate implementation of
    unboxC (compare with [<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29)):<mut-str-interp/unboxC/alt-1>
    ::=
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个表达式位置进行评估并穿插结果存储非常重要。例如，考虑unboxC的另一种实现（与[<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29)进行比较）：<mut-str-interp/unboxC/alt-1>
    ::=
- en: '|   &#124; unboxC(b) => |'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|   &#124; unboxC(b) => |'
- en: '|     val = interp(b, nv, st) |'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|     ret(fetch(val.v.l, st), val.st) |'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Did you notice? We fetched the location from st, not val.st. But st reflects
    mutations up to but before the evaluation of the unboxC expression, not any within
    it. Could there possibly be any? Mais oui!
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| (let ([b (box 0)]) |'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|   (unbox (begin (set-box! b 1) |'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|                 b))) |'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: With the incorrect code above, this would evaluate to 0 rather than 1.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here’s another, similar, error (again compare with [<mut-str-interp/unboxC>](#%28elem._mut-str-interp%2Funbox.C%29)):<mut-str-interp/unboxC/alt-2>
    ::=
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|   &#124; unboxC(b) => |'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|     val = interp(b, nv, st) |'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|     ret(fetch(val.v.l, val.st), st) |'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: How do we break this? In the end we’re returning the old store, the one before
    any mutations in the unboxC happened. Thus, we just need the outside context to
    depend on one of them.
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| (let ([b (box 0)]) |'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|   (+ (unbox (begin (set-box! b 1) |'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|                    b)) |'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '|      (unbox b))) |'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: This should evaluate to 2, but because the store being returned is one where
    b’s location is bound to the representation of 0, the result is 1.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we combined both bugs above—<wbr>i.e., using st twice in the last line instead
    of s-a twice—<wbr>this expression would evaluate to 0 rather than 2.
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Go through the interpreter; replace every reference to an updated store with
    a reference to one before update; make sure your test cases catch all the introduced
    errors!
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Observe that these uses of “old” stores enable us to perform a kind of time
    travel: because mutation introduces a notion of time, these enable us to go back
    in time to when the mutation had not yet occurred. This sounds both interesting
    and perverse; does it have any use?'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It does! Imagine that instead of directly mutating the store, we introduce
    the idea of a journal of intended updates to the store. The journal flows in a
    threaded manner just like the real store itself. Some instruction creates a new
    journal; after that, all lookups first check the journal, and only if the journal
    cannot find a binding for a location is it looked for in the actual store. There
    are two other new instructions: one to discard the journal (i.e., travel back
    in time), and the other to commit it (i.e., all of its edits get applied to the
    real store).'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the essence of software transactional memory. Each thread maintains
    its own journal. Thus, one thread does not see the edits made by the other before
    committing (because each thread sees only its own journal and the global store,
    but not the journals of other threads). At the same time, each thread gets its
    own consistent view of the world (it sees edits it made, because these are recorded
    in the journal). If the transaction ends successfully, all threads atomically
    see the updated global store. If the transaction aborts, the discarded journal
    takes with it all changes and the state of the thread reverts (modulo global changes
    committed by other threads).
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Software transactional memory offers one of the most sensible approaches to
    tackling the difficulties of multi-threaded programming, if we insist on programming
    with shared mutable state. Because most computers have only one global store,
    however, maintaining the journals can be expensive, and much effort goes into
    optimizing them. As an alternative, some hardware architectures have begun to
    provide direct support for transactional memory by making the creation, maintenance,
    and commitment of journals as efficient as using the global store, removing one
    important barrier to the adoption of this idea.
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Augment the language with the journal features of software transactional memory.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An alternate implementation strategy is to have the environment map names to
    boxed Values. We don’t do it here because it: (a) would be cheating, (b) wouldn’t
    tell us how to implement the same feature in a language without boxes, (c) doesn’t
    necessarily carry over to other mutation operations, and (d) most of all, doesn’t
    really give us insight into what is happening here.'
  id: totrans-339
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is nevertheless useful to understand, not least because you may find it a
    useful strategy to adopt when implementing your own language. Therefore, alter
    the implementation to obey this strategy. Do you still need store-passing style?
    Why or why not?
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 31.4Variables
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve got structure mutation worked out, let’s consider the other
    case: variable mutation. We have already discussed ([From Identifiers to Variables](State__Change__and_More_Equality.html#%28part._mutable-variables%29))
    our choice of terminology, and seen examplse of their use in Pyret. In particular,
    Whereas other languages overload the mutation syntax, as we have seen ([Separating
    Meaning from Notation](#%28part._mutation-notation%29)), in Pyret they are kept
    distinct: ! mutates fields of objects while := mutates variables. This forces
    Pyret programmers to confront the distinction we introduced at the beginning of
    [Separating Meaning from Notation](#%28part._mutation-notation%29). We will, of
    course, sidestep these syntactic issues in our core language by using different
    constructs for boxes and for variables.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 31.4.1The Syntax of Variable Assignment
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing to note about variable mutation is that, although it too has
    two sub-terms like box mutation (setboxC), its syntax is fundamentally different.
    To understand why, let’s return to our Java fragment:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '| x = 3; |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: 'In this setting, we cannot write an arbitrary expression in place of x: we
    must literally write the name of the identifier itself. That is because, if it
    were an expression position, then we could evaluate it, yielding a value: for
    instance, if x were previously bound to 1, this would be tantamout to writing
    the following statement:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 = 3; |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: 'But this is, of course, nonsensical! We can’t assign a new value to 1, and
    indeed 1 is pretty much the definition of immutable. What we instead want is to
    find where x is in the store, and change the value held over there.Here’s another
    way to see this. Suppose, in Java, the local variable o is already bound to some
    String object:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '| o = new String("an initial string"); |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: Say the program now executes
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '| o = new String("a new string"); |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: 'Is it trying to change the content of the original string ("an initial string")?
    Certainly not: the second assignment intends to leave that original string alone;
    it only wants to change the value that o is referring to, so that subsequent references
    evaluate to this new string ("a new string") object instead.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 31.4.2Interpreting Variables
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll start by reflecting this in our syntax:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Observe that we’ve jettisoned the box operations, but kept sequencing because
    it’s handy around mutation. Importantly, we’ve now added the setC case, and its
    first sub-term is not an expression but the literal name of a variable. We’ve
    also renamed idC to varC.Because we’ve gotten rid of boxes, we can also get rid
    of the special box values. When the only kind of mutation you have is variables,
    you don’t need new kinds of values.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you might imagine, to support variables we need the same store-passing style
    that we’ve seen before ([Interpreting Boxes](#%28part._store-passing-style%29)),
    and for the same reasons. What differs is in precisely how we use it. Because
    sequencing is interpreted in just the same way (observe that the verb for it does
    not depend on boxes versus variables), that leaves us just the variable mutation
    case to handle.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: First, we might as well evaluate the value expression and obtain the updated
    store:<mut-var-interp/setC> ::=
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '|   &#124; setC(v, b) => |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '|     new-val = interp(b, nv, st) |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '|     [<mut-var-interp/setC/core>](#%28elem._mut-var-interp%2Fset.C%2Fcore%29)
    |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: What now? Remember we just said that we don’t want to fully evaluate the variable,
    because that would just give the value it is bound to. Instead, we want to know
    which memory location it corresponds to, and update what is stored at that memory
    location; this latter part is just the same thing we did when mutating boxes:<mut-var-interp/setC/core>
    ::=
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '|   var-loc = lookup(v, nv) |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '|   ret(new-val.v, |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '|     xtnd-sto(cell(var-loc, new-val.v), new-val.st)) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: 'The very interesting new pattern we have here is this. When we added boxes,
    in the idC case ([<mut-str-interp/idC>](#%28elem._mut-str-interp%2Fid.C%29)),
    we looked up an identifier in the environment (just as above), and then immediately
    fetched the value at that location from the store; the composition yielded a value,
    just as it used to before we added stores. Now, however, we have a new pattern:
    looking up an identifier in the environment without subsequently fetching its
    value from the store, i.e., we have “half” of a variable’s evaluation. The result
    of invoking just lookup is traditionally called an l-value, for “left-hand-side
    (of an assignment) value”. This is a fancy way of saying “memory address”, and
    stands in contast to the actual values that the store yields: observe that it
    does not directly correspond to anything in the type Value.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: And we’re done! We did all the hard work when we implemented store-passing style
    (and also in that application allocated new locations for variables).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 31.4.3Reference Parameter Passing
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s return to the parenthetical statement above: that every application allocates
    a fresh location in the store for the parameter.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Why does this matter? Consider the following Pyret program:'
  id: totrans-374
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-375
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-376
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ''
  id: totrans-377
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: After this runs, what do we expect to be the value of y?
  id: totrans-378
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the example above, y evaluates to 5, not 3. That is because the value of
    the formal parameter x is held at a different location than that of the actual
    parameter y, so the mutation affects the location of x, leaving y unscathed.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose, instead, that application behaved as follows. When the actual
    parameter is a variable, and hence has a location in memory, instead of allocating
    a new location for the value, it simply passes along the existing one for the
    variable. Now the formal parameter is referring to the same store location as
    the actual: i.e., they are variable aliases. Thus any mutation on the formal will
    leak back out into the calling context; the above program would evaluate to 3
    rather than 5. These is called a call-by-reference parameter-passing strategy.Instead,
    our interpreter implements call-by-value, and this is the same strategy followed
    by languages like Java. This causes confusion because when the value is itself
    mutable, changes made to the value in the callee are observed by the caller. However,
    that is simply an artifact of mutable values, not of the calling strategy. Please
    avoid this confusion!'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'For some years, this power was considered a good idea. It was useful because
    programmers could write abstractions such as swap, which swaps the value of two
    variables in the caller. However, the disadvantages greatly outweigh the advantages:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: A careless programmer can alias a variable in the caller and modify it without
    realizing they have done so, and the caller may not even realize this has happened
    until some obscure condition triggers it.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some people thought this was necessary for efficiency: they assumed the alternative
    was to copy large data structures. However, call-by-value is compatible with passing
    just the address of the data structure. You only need make a copy if (a) the data
    structure is mutable, (b) you do not want the caller to be able to mutate it,
    and (c) the language does not itself provide immutability annotations or other
    mechanisms.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can force non-local and hence non-modular reasoning. For instance, suppose
    we have the procedure:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the language were to permit by-reference parameter passing, then the programmer
    cannot locally—<wbr>i.e., just from the above code—<wbr>determine what the value
    of x will be in the ellipses, because it depends on precisely who the callee (which
    is being passed in as a parameter) will be, and what it might do, which in turn
    may depend on dynamic conditions (including the phase of the moon).
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the very least, then, if the language is going to permit by-reference parameters,
    it should let the caller determine whether to pass the reference—<wbr>i.e., let
    the callee share the memory address of the caller’s variable—<wbr>or not. However,
    even this option is not quite as attractive as it may sound, because now the callee
    faces a symmetric problem, not knowing whether its parameters are aliased or not.
    In traditional, sequential programs this is less of a concern, but if the procedure
    is reentrant, the callee faces precisely the same predicaments.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: At some point, therefore, we should consider whether any of this fuss is worthwhile.
    Instead, callers who want the callee to perform a mutation could simply send a
    boxed value to the callee. The box signals that the caller accepts—<wbr>indeed,
    invites—<wbr>the callee to perform a mutation, and the caller can extract the
    value when it’s done. This does obviate the ability to write a simple swapper,
    but that’s a small price to pay for genuine software engineering concerns.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 31.5The Design of Stateful Language Operations
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though most programming languages include one or both kinds of state we have
    studied, their admission should not be regarded as a trivial or foregone matter.
    On the one hand, state brings some vital benefits:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'State provides a form of modularity. As our very interpreter demonstrates,
    without explicit stateful operations, to achieve the same effect:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We would need to add explicit parameters and return values that pass the equivalent
    of the store around.
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These changes would have to be made to all procedures that may be involved in
    a communication path between producers and consumers of state.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, a different way to think of state in a programming language is that it
    is an implicit parameter already passed to and returned from all procedures, without
    imposing that burden on the programmer. This enables procedures to communicate
    “at a distance” without all the intermediaries having to be aware of the communication.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: State makes it possible to construct dynamic, cyclic data structures, or at
    least to do so in a relatively straightforward manner ([Graphs](graphs.html)).
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State gives procedures memory, such as new-loc above. If a procedure could not
    remember things for itself, the callers would need to perform the remembering
    on its behalf, employing the moral equivalent of (at least local) store-passing.
    This is not only unwieldy, it creates the potential for a caller to interfere
    with the memory for its own nefarious purposes (e.g., a caller might purposely
    send back an old store, thereby obtaining a reference already granted to some
    other party, through which it might launch a correctness or security attack).
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, state imposes real costs on programmers as well as on programs
    that process programs (such as compilers). One is “aliasing”, which we discuss
    later [REF]. Another is “referential transparency”, which too I hope to return
    to [REF]. Finally, we have described above how state provides a form of modularity.
    However, this same description could be viewed as that of a back-channel of communication
    that the intermediaries did not know and could not monitor. In some (especially
    security and distributed system) settings, such back-channels can lead to collusion,
    and can hence be extremely dangerous and undesirable.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no optimal answer, it is probably wise to include mutation
    operators but to carefully delinate them. In Standard ML, for instance, there
    is no variable mutation, because it is considered unnecessary. Instead, the language
    has the equivalent of boxes (called refs). One can easily simulate variables using
    boxes, so no expressive power is lost, though it does create more potential for
    aliasing than variables alone would have ([REF aliasing]) if the boxes are not
    used carefully.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'In return, however, developers obtain expressive types: every data structure
    is considered immutable unless it contains a ref, and the presence of a ref is
    a warning to both developers and programs (such as compilers) that the underlying
    value may keep changing.This same argument applies to Pyret, where the absence
    of a ref declaration means that a field is immutable, and the absence of a var
    declaration means an identifier is immutable, i.e., not a variable. Thus, for
    instance, suppose b is a box and v is bound to the unboxing of b. A developer
    should be aware that replacing all instances of the unboxing b with references
    to v is not safe, because the former always fetches the current value in the box
    while the latter holds the value only at the instant when v was computed, and
    may now be inconsistent. The declaration that a field is mutable provides this
    information to both the developer and to programming tools (such as compilers);
    in particular, the absence of such a declaration permits caching of values, thereby
    trading computation time for space.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 31.6Typing State
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding stateful operations to a type-checker is easy: the only safe thing to
    do is make sure the type of the new value is exactly the same as that of the old
    one. If that is true, the behavior of the program will be indistinguishable to
    the type system before and after the mutation. That is, it is safest to follow
    invariance ([The Principle of Substitutability](types.html#%28part._type-substitutability%29)).'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 31.6.1Mutation and Polymorphism
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Later, once we encounter subtyping ([Subtyping](objects.html#%28part._subtyping%29)),
    we will find it is no longer trivial to type mutation. Already, however, mutation
    is complex in the presence of polymorphism. Let us first give polymorphic types
    to boxes, where Box is a type constructor for boxes:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: (assuming that the mutation operation, set-box, returns the box as its result).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the above three functions.
  id: totrans-408
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now let us consider a simple example that uses these:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initially, the type of f is Box((A -> A)) where (A -> A) represents the type
    of the polymorphic identity function. When performing inference, a copy of this
    type certainly unifies with Number -> Number, the type of lam(x): x + 5 end. Another
    copy is used at the application site; the argument type unifies with that of true,
    giving the whole expression the type Boolean. However, when the actual function
    is applied, it attempts to add true to 5, resulting in a run-time error. If the
    compiler had assumed the type-system was sound and had not compiled in checks,
    this program could even result in a segmentation fault.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to try to understand this problem, which is beyond the scope
    of this study. The simplest way is that polymorphism and mutation do not work
    together well. The essence of polymorphism is to imagine a quantified type is
    instantiated at each use; however, the essence of mutation is to silently transmit
    values from one part of the program to the other. Thus, the values being unified
    at two different sites are only guaranteed to be compatible with the let-bound
    identifier—<wbr>not with each other. This is normally not a problem because the
    two do not communicate directly, except where mutation is involved. Therefore,
    a simple solution in this case is to prevent polymorphic generalization for mutable
    let-bound identifiers.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 31.6.2Typing the Initial Value
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one last issue we should address where mutation is concerned: the
    typing of cycle creation, and in particular dealing with the problem of [Premature
    Evaluation](State__Change__and_More_Equality.html#%28part._premature-eval%29).
    We have discussed several approaches to handling the initial value; each of these
    has consequences for typing:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Using a fixed initial value of a standard type means the value subsequently
    mutated into place may not be type-compatible, thereby failing invariance.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a different initial value of the type that will eventually be put into
    the mutable has the problem that prematurely observing it is even more deadly,
    because it may not be distinguishable from the eventual value.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a new value just for this case works provided there is one of each type.
    Otherwise, again, we violate invariance. But having one of each type is a problem
    in itself, because now the run-time system has to check for all of them.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Syntactically restricting recursion to functions is the safest, because the
    initial value is never seen. As a result, there is no need to provide any meaningful
    type for it.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In short, this is a place where we have to confront unsurmountable trade-offs.
    The first option sacrifices typability; the second option sacrifices program reliability
    (because the dummy values are of the right type, and may hence be inadvertently
    used without noticing they are wrong); the third sacrifices run-time simplicity;
    and the fourth sacrifices programmer flexibility.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
