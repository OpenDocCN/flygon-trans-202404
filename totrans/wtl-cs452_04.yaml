- en: Lecture 4 - Tasks & Kernels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pubilc Service Annoucements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due date for assignment 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some clean-up needed in course account, cleaned up course introduction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RTS/CTS
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The train controller asserts RTS when its UART is ready to receive a byte.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: RTS is connected to the ARM UART's CTS bit.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You check the modem status register
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You transmit a byte to the train controller only when CTS is asserted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You do **not** transmit when CTS is negated.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'News group: `uw.cs.cs452`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Course email account: `cs452@cgl.uwaterloo.ca`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Documentation expected for assignment 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partners
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel of a Real-time Operating System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The base unit of a polling loop is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: Think of `action` as the performance of a task, such as washing dishes. Think
    of `condition` as a signal from outside that tells you it's time to perform the
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actions are not independent of one another: washing dishes requires hot water,
    dish soap, etc., which are provided by other actions. Communication is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus tasks need some support.
  prefs: []
  type: TYPE_NORMAL
- en: the ability to execute instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: code with the pc pointing into it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: state, in the form of memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the ability to communicate with one another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pass data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: synchronization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the ability to receive information from the real world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: provide data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: possibly nothing but symchronization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These basic needs are provided by the kernel of an operating system. The kernel
    we create in cs452 is a microkernel, because it provides these capabilities and
    nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: We build the microkernel in four assignments
  prefs: []
  type: TYPE_NORMAL
- en: task creation and scheduling
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: inter-task communication
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: an interrupt primitive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: complex servers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Microkernels](http://en.wikipedia.org/wiki/Microkernel)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The real-time operating system we build consists of
  prefs: []
  type: TYPE_NORMAL
- en: an uninterruptible microkernel, plus
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: interruptible device-handling server tasks that run in user-space with permissions
    allowing them to access hardware.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Does a Microkernel Provide?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Program is conceived as a collection of co-operating tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide applications with modularity. Task structure as a method of program
    organization is discussed about the time you are finishing the OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consist of
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: instructions, common to all tasks of the same kind,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: global **constants**, such as strings used for formatting messages, and
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: local state, different state in different tasks of the same kind, which requires
    a separate block of memory for each instantiation of a task..
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How tasks work together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: synchronization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: communication
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'combined into one mechanism: message passing'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are tasks important?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking about one thing at a time is easy.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about the options you expect to have after you graduate.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking about more than one thing at a time is hard.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep on thinking, and at the same time listen to me talking about tasks
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parenthetical remark. While walking you may have been talking to somebody, or
    thinking about something. You did both effortlessly. How?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking about more than one thing at a time, in real-time, is very hard
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about turning the wheel, peddling and balancing while learning to ride
    a bicycle
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How did you learn to coordinate all these activities in real-time?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks allow a programmer to produce each component of a activity into a sequential
    set of instructions that includes communication with other tasks..
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Communication has two aspects
  prefs: []
  type: TYPE_NORMAL
- en: sharing information, requesting service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: synchronization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use Send/Receive/Reply (SRR) to do both.
  prefs: []
  type: TYPE_NORMAL
- en: Send blocks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Receive blocks: is synchronous with the call to send'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reply doesn''t block: is synchronous with the return from send'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Between tasks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coordination of execution in co-operating tasks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses SRR
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With internal events
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Real-time by synchronizing with a real-time clock: e.g. clock server'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ordering execution: e.g. name server, bounded buffer'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses SRR
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: With external events
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: interrupts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Input from the outside world
  prefs: []
  type: TYPE_NORMAL
- en: Provide the information you polled for
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ISR OS design, which is essentially a jump table, which separates testing from
    acting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are the same actions you implemented in your polling loop,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and the have all the same problems.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Somthing to think about
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling loop was single-threaded
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You were guaranteed not to be in the middle of a computation when you got the
    signal to start another one.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ISRs are not necessarily single-threaded
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You could get back the polling loop by turning off interrupts during the action.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No hierarchy of importance among ISRs
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling loop hierarchy was in the polling structure
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Selective interrupt masking can reproduce the hierarchy,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But then you have to save state
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is a task?
  prefs: []
  type: TYPE_NORMAL
- en: A set of instructions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Current state, which is changed by executing instructions, which includes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: values of its variables, which are automatic variables maintained on the stack
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: contents of its registers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: other processor state such as the PSR
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: processor mode
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: condition codes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: etc.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: its run state and other things maintained by the kernel
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two tasks can use the same set of instructions, but
  prefs: []
  type: TYPE_NORMAL
- en: every task has its own state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, no static variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel keeps track of every task's state
  prefs: []
  type: TYPE_NORMAL
- en: In essence, servicing a request amounts to changing the state of one or more
    tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel maintains a task descriptor (TD) for each created task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is, to create a task the kernel must allocate a TD and initialize it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TD normally contains
  prefs: []
  type: TYPE_NORMAL
- en: The task's stack pointer, which points to a private stack, in the memory of
    the task, containing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PC
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: other registers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: local variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: all ready to be reloaded whenever the task next runs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Possibly the return value for when the task is next activated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task's parent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task's state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Links to queues on which the task is located
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel uses these to find the task when it is ervicing a request
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible states of the task
  prefs: []
  type: TYPE_NORMAL
- en: 'Active: running or about to run'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a single processor system only one task can ever be active.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But we would like to generalize smoothly to more than one processor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ready: can run if scheduled'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Need a queue used by the scheduler when deciding which task should be the next
    active task
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blocked: waiting for something to happen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Need several queues, one for each thing that could happen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The kernel is just a function like any other, but which runs forever.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Where is the OS?
  prefs: []
  type: TYPE_NORMAL
- en: requests come from running user tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in essence system calls
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: one type of request creates a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There needs to be a first task that gets everything going
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: All the interesting stuff inside done by the kernel is hidden inside `getNextRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What's inside `activate( active )`?
  prefs: []
  type: TYPE_NORMAL
- en: transfer of control to the active task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: execution to completion of the active task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`to completion'' means until the active task sends a request to the kernel'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: transfer of control back to the kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: getting the request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hard part to get right is `transfer of control'
  prefs: []
  type: TYPE_NORMAL
- en: which we call a context switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bill Cowan''s lecture notes for CS452 in s12](index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s Spring 2012 CS452 page](../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s CS452 page](../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s teaching page](../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s home page](../../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
