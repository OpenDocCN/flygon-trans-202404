- en: Incremental testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write a program, it is tempting to write the whole program, and then
    start debugging it.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this is very bad strategy. It is much more effective to test every
    function immediately after you have written it.
  prefs: []
  type: TYPE_NORMAL
- en: Continue working on the next function only after the first one works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, we can test functions interactively using the interactive mode.
    We use the :load command inside the interactive mode. The same command allows
    us to reload our code after we have made changes to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A worked out example: the Collatz problem'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's practice incremental testing on an example, the so-called Collatz problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a sequence of integers following the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: \[ n_{i+1} = \left\{ \begin{array}{ll} 3n_i + 1 & \text{if $n_i$ is odd}\\ n_i/2
    & \text{if $n_i$ is even} \end{array} \right. \]
  prefs: []
  type: TYPE_NORMAL
- en: 'If you provide a starting value \(n_0\), this determines an entire sequence.
    Here are a few examples, with starting values 5, 34, 7, and 672:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can notice that all four example sequences reach the number 1 (and then
    of course the sequence starts cycling: 1 4 2 1 4 2 1 4 2 1...).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is conjectured that this is always true: for any starting value, the sequence
    arrives at 1.'
  prefs: []
  type: TYPE_NORMAL
- en: We want to do some experiments with this conjecture, for instance to determine
    experimentally which starting value gives long chains. So we want to write functions
    that, given the starting value, can print out the entire sequence, and can print
    the number of steps until 1 is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the basic function: Given \(n_i\), compute the next number
    \(n_{i+1}\). I create a file [collatz.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/07-collatz/collatz1.kts)
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We test this function by loading the file and checking that it correctly handles
    both the even and the odd case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions seems to work, so the next step is to write a function that prints
    the entire sequence starting from a given starting value. We add the function
    collatz to our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'I reload the file and test it on an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And already I notice my mistake: the loop doesn''t print the final 1. So I
    change my function as follows ([collatz.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/07-collatz/collatz2.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And I can continue testing by reloading the file and trying again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now it seems to work well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function will count the number of steps done from a given starting
    value until we reach 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I test this by comparing the result with the output of collatz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I''ll write a function that tries all starting values between 2 and
    a given maximum \(n\), and reports the starting value with the longest sequence
    ([collatz3.kts](https://github.com/otfried/cs109-kotlin/raw/master/tutorial/07-collatz/collatz3.kts)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result of testing this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a large program, it is common to write a separate test program for every
    function or class. These test programs are called unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers even write the tests before the code!
  prefs: []
  type: TYPE_NORMAL
- en: The unit tests remain useful even when the program is finished. All software
    needs to be maintained. Whenever a change is made to the software, we can run
    the unit tests again to get confidence that we didn’t break anything.
  prefs: []
  type: TYPE_NORMAL
- en: On many software projects, unit tests are automated and run every night, to
    ensure that the changes made during the day didn’t create any new bugs.
  prefs: []
  type: TYPE_NORMAL
- en: We will not ask you to write unit tests in CS109, but you should get in the
    habit of testing your functions. Often you can test by hand, interactively. But
    when you need more than two or three lines of code to test a function, it makes
    sense to write extra testing functions. Keep those in your code, so that you can
    use them again later to check your program when you have made changes.
  prefs: []
  type: TYPE_NORMAL
