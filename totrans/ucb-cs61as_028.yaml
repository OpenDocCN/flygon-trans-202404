- en: Evaluating Combinations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Does Evaluate Mean?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we type a Racket expression such as `(+ 2 3)` into the interpreter, we
    as humans know immediately that that is really just `5`. But all the computer
    sees is open parentheses, plus, two, three, close parentheses. How does it get
    from the Racket expression to the value `5`? It *evaluates* the expression and
    gets the value 5 from there. How does it evaluate it?
  prefs: []
  type: TYPE_NORMAL
- en: How the Interpreter Evaluates Things
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way the interpreter evaluates things can be a little confusing at first,
    but will make sense soon. To evaluate a Racket expression, first evaluate the
    subexpressions of the expression. In other words, you first evaluate the operands
    fully, and then apply the operator. When you reach a procedure call, apply the
    operator to the operands and repeat. Note that evaluation is recursive--in order
    to evaluate an expression, we need to first evaluate its subexpressions. In order
    to evaluate the subexpressions, we need to evaluate *their* subexpressions, and
    so on until we reach a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: A Recursion Tree'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s try evaluating the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(* (+ 2 (* 4 6))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 3 5 7))`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly complicated expression, and without recursion it would be very
    difficult to evaluate. Evaluating this requires that the evaluation rule be applied
    four different times. If we represent the evaluation process as a tree, it becomes
    a little easier to understand. This tree, unlike real trees, has its roots in
    the air and its branches sticking into the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Each combination is represented by a node with branches corresponding to a subexpression.
    The end branches are operators or numbers. We can imagine that the values of the
    operands swim upwards, starting at the bottom of the tree, getting evaluated at
    each branch, and resulting in a new value which is further evaluated at a higher
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursion Tree](../Images/ec7ad933748d031f908ecb610b8aa307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A more detailed explanation is given in the [wiki entry](https://edge.edx.org/courses/uc-berkeley/cs61as-1x/SICP/wiki/cs61as-
    1x/eval/) for eval, and it will be further explained in the sections about the
    substitution model.
  prefs: []
  type: TYPE_NORMAL
- en: Define?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about `define`? It turns out that the ordinary evaluation rules don't work
    for `define`, since `(define x 3)` doesn't apply `define` to two arguments; it
    instead stores the value of `x` as 3\. Define is what is known as a [special form](https://edge.edx.org/courses/uc-berkeley/cs61as-1x/SICP/wiki
    /cs61as-1x/special-form/), and special forms are the only exceptions to the rules
    of evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is not a primitive function in Racket?
  prefs: []
  type: TYPE_NORMAL
