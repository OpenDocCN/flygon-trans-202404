["```\n\n```", "```\n\n    The [Equiv](Equiv.html) chapter introduced constant folding as an example of a\n    program transformation and proved that it preserves the meaning of\n    programs.  Constant folding operates on manifest constants such as\n    ANum expressions.  For example, it simplifies the command Y ::= APlus (ANum 3) (ANum 1) to the command Y ::= ANum 4.  However,\n    it does not propagate known constants along data flow.  For\n    example, it does not simplify the sequence\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0ANum\u00a03;;\u00a0Y\u00a0::=\u00a0ANum\u00a04\n\n    because it forgets that X is 3 by the time it gets to Y.\n\n    We might naturally want to enhance constant folding so that it\n    propagates known constants and uses them to simplify programs.\n    Doing so constitutes a rudimentary form of *partial evaluation*.\n    As we will see, partial evaluation is so called because it is like\n    running a program, except only part of the program can be\n    evaluated because only part of the input to the program is known.\n    For example, we can only simplify the program\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0ANum\u00a03;;\u00a0Y\u00a0::=\u00a0AMinus\u00a0(ANum\u00a04)\u00a0(AId\u00a0Y)\n\n    without knowing the initial value of Y.\n\n```", "```\n\n# Generalizing Constant Folding\n\n    The starting point of partial evaluation is to represent our\n    partial knowledge about the state.  For example, between the two\n    assignments above, the partial evaluator may know only that X is\n    3 and nothing about any other variable. \n\n## Partial States\n\n    Conceptually speaking, we can think of such partial states as the\n    type id \u2192 option nat (as opposed to the type id \u2192 nat of\n    concrete, full states).  However, in addition to looking up and\n    updating the values of individual variables in a partial state, we\n    may also want to compare two partial states to see if and where\n    they differ, to handle conditional control flow.  It is not possible\n    to compare two arbitrary functions in this way, so we represent\n    partial states in a more concrete format: as a list of id * nat\n    pairs.\n\n```", "```\n\n    The idea is that a variable id appears in the list if and only\n    if we know its current nat value.  The pe_lookup function thus\n    interprets this concrete representation.  (If the same variable\n    id appears multiple times in the list, the first occurrence\n    wins, but we will define our partial evaluator to never construct\n    such a pe_state.)\n\n```", "```\n\n    For example, empty_pe_state represents complete ignorance about\n    every variable \u2014 the function that maps every id to None.\n\n```", "```\n\n    More generally, if the list representing a pe_state does not\n    contain some id, then that pe_state must map that id to\n    None.  Before we prove this fact, we first define a useful\n    tactic for reasoning with id equality.  The tactic\n\n```", "```\nTactic Notation \"compare\" ident(i) ident(j) :=\n\u00a0\u00a0let H := fresh \"Heq\" i j in\n\u00a0\u00a0destruct (beq_idP i j);\n\u00a0\u00a0[ subst j | ].\n\nTheorem pe_domain: \u2200pe_st V n,\n\u00a0\u00a0pe_lookup pe_st V = Some n \u2192\n\u00a0\u00a0In V (map (@fst _ _) pe_st).\nProof. intros pe_st V n H. induction pe_st as [| [V' n'] pe_st].\n\u00a0\u00a0- (*\u00a0\u00a0*) inversion H.\n\u00a0\u00a0- (*\u00a0::\u00a0*) simpl in H. simpl. compare V V'; auto. Qed. \n```", "```\nPrint In.\n(*\u00a0===>\u00a0Fixpoint\u00a0In\u00a0{A:Type}\u00a0(a:\u00a0A)\u00a0(l:list\u00a0A)\u00a0:\u00a0Prop\u00a0:= \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0match\u00a0l\u00a0with \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0=>\u00a0False \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0b\u00a0::\u00a0m\u00a0=>\u00a0b\u00a0=\u00a0a\u00a0\\/\u00a0In\u00a0a\u00a0m \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0:\u00a0forall\u00a0A\u00a0:\u00a0Type,\u00a0A\u00a0->\u00a0list\u00a0A\u00a0->\u00a0Prop\u00a0*) \n```", "```\nCheck filter_In.\n(*\u00a0===>\u00a0filter_In\u00a0:\u00a0forall\u00a0(A\u00a0:\u00a0Type)\u00a0(f\u00a0:\u00a0A\u00a0->\u00a0bool)\u00a0(x\u00a0:\u00a0A)\u00a0(l\u00a0:\u00a0list\u00a0A), \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0In\u00a0x\u00a0(filter\u00a0f\u00a0l)\u00a0<->\u00a0In\u00a0x\u00a0l\u00a0/\\\u00a0f\u00a0x\u00a0=\u00a0true\u00a0\u00a0*)\n\n```", "```\nFixpoint inb {A : Type} (beq : A \u2192 A \u2192 bool) (a : A) (l : list A) :=\n\u00a0\u00a0match l with\n\u00a0\u00a0| [] \u21d2 false\n\u00a0\u00a0| a'::l' \u21d2 beq a a' || inb beq a l'\n\u00a0\u00a0end.\n\n```", "```\nLemma inbP : \u2200A : Type, \u2200beq : A\u2192A\u2192bool,\n\u00a0\u00a0(\u2200a[1] a[2], reflect (a[1] = a[2]) (beq a[1] a[2])) \u2192\n\u00a0\u00a0\u2200a l, reflect (In a l) (inb beq a l).\nProof.\n\u00a0\u00a0intros A beq beqP a l.\n\u00a0\u00a0induction l as [|a' l' IH].\n\u00a0\u00a0- constructor. intros [].\n\u00a0\u00a0- simpl. destruct (beqP a a').\n\u00a0\u00a0\u00a0\u00a0+ subst. constructor. left. reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ simpl. destruct IH; constructor.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* right. trivial.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* intros [H[1] | H[2]]; congruence.\nQed.\n\n```", "```\nFixpoint pe_aexp (pe_st : pe_state) (a : aexp) : aexp :=\n\u00a0\u00a0match a with\n\u00a0\u00a0| ANum n \u21d2 ANum n\n\u00a0\u00a0| AId i \u21d2 match pe_lookup pe_st i with (*\u00a0<-----\u00a0NEW\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| Some n \u21d2 ANum n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| None \u21d2 AId i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0| APlus a[1] a[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0match (pe_aexp pe_st a[1], pe_aexp pe_st a[2]) with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| (ANum n[1], ANum n[2]) \u21d2 ANum (n[1] + n[2])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| (a[1]', a[2]') \u21d2 APlus a[1]' a[2]'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0| AMinus a[1] a[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0match (pe_aexp pe_st a[1], pe_aexp pe_st a[2]) with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| (ANum n[1], ANum n[2]) \u21d2 ANum (n[1] - n[2])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| (a[1]', a[2]') \u21d2 AMinus a[1]' a[2]'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0| AMult a[1] a[2] \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0match (pe_aexp pe_st a[1], pe_aexp pe_st a[2]) with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| (ANum n[1], ANum n[2]) \u21d2 ANum (n[1] * n[2])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| (a[1]', a[2]') \u21d2 AMult a[1]' a[2]'\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0end.\n\n```", "```\nExample test_pe_aexp1:\n\u00a0\u00a0pe_aexp [(X,3)] (APlus (APlus (AId X) (ANum 1)) (AId Y))\n\u00a0\u00a0= APlus (ANum 4) (AId Y).\n\n    Proof. reflexivity. Qed.\n\nExample text_pe_aexp2:\n\u00a0\u00a0pe_aexp [(Y,3)] (APlus (APlus (AId X) (ANum 1)) (AId Y))\n\u00a0\u00a0= APlus (APlus (AId X) (ANum 1)) (ANum 3).\n\n    Proof. reflexivity. Qed.\n\n```", "```\nDefinition pe_consistent (st:state) (pe_st:pe_state) :=\n\u00a0\u00a0\u2200V n, Some n = pe_lookup pe_st V \u2192 st V = n.\n\nTheorem pe_aexp_correct_weak: \u2200st pe_st, pe_consistent st pe_st \u2192\n\u00a0\u00a0\u2200a, aeval st a = aeval st (pe_aexp pe_st a).\nProof. unfold pe_consistent. intros st pe_st H a.\n\u00a0\u00a0induction a; simpl;\n\u00a0\u00a0\u00a0\u00a0try reflexivity;\n\u00a0\u00a0\u00a0\u00a0try (destruct (pe_aexp pe_st a[1]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (pe_aexp pe_st a[2]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite IHa1; rewrite IHa2; reflexivity).\n\u00a0\u00a0(*\u00a0Compared\u00a0to\u00a0fold_constants_aexp_sound, \u00a0\u00a0\u00a0\u00a0\u00a0the\u00a0only\u00a0interesting\u00a0case\u00a0is\u00a0AId\u00a0*)\n\u00a0\u00a0- (*\u00a0AId\u00a0*)\n\u00a0\u00a0\u00a0\u00a0remember (pe_lookup pe_st i) as l. destruct l.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0Some\u00a0*) rewrite H with (n:=n) by apply Heql. reflexivity.\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0None\u00a0*) reflexivity.\nQed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0ANum\u00a03;;\u00a0Y\u00a0::=\u00a0AMinus\u00a0(AId\u00a0X)\u00a0(AId\u00a0Y);;\u00a0X\u00a0::=\u00a0ANum\u00a04\n\n    to just\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0pe_aexp\u00a0[(X,3)]\u00a0(AMinus\u00a0(AId\u00a0X)\u00a0(AId\u00a0Y))\n\n    to be equal to AMinus (ANum 3) (AId Y) and *not* the original\n    expression AMinus (AId X) (AId Y).  After all, it would be\n    incorrect, not just inefficient, to transform\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0AMinus\u00a0(AId\u00a0X)\u00a0(AId\u00a0Y);;\u00a0X\u00a0::=\u00a0ANum\u00a04\n\n    even though the output expressions AMinus (ANum 3) (AId Y) and\n    AMinus (AId X) (AId Y) both satisfy the correctness criterion\n    that we just proved.  Indeed, if we were to just define pe_aexp pe_st a = a then the theorem pe_aexp_correct' would already\n    trivially hold.\n\n    Instead, we want to prove that the pe_aexp is correct in a\n    stronger sense: evaluating the expression produced by partial\n    evaluation (aeval st (pe_aexp pe_st a)) must not depend on those\n    parts of the full state st that are already specified in the\n    partial state pe_st.  To be more precise, let us define a\n    function pe_override, which updates st with the contents of\n    pe_st.  In other words, pe_override carries out the\n    assignments listed in pe_st on top of st.\n\n```", "```\n\n    Although pe_update operates on a concrete list representing\n    a pe_state, its behavior is defined entirely by the pe_lookup\n    interpretation of the pe_state.\n\n```", "```\n\n    We can relate pe_consistent to pe_update in two ways.\n    First, overriding a state with a partial state always gives a\n    state that is consistent with the partial state.  Second, if a\n    state is already consistent with a partial state, then overriding\n    the state with the partial state gives the same state.\n\n```", "```\n\n    Now we can state and prove that pe_aexp is correct in the\n    stronger sense that will help us define the rest of the partial\n    evaluator.\n\n    Intuitively, running a program using partial evaluation is a\n    two-stage process.  In the first, *static* stage, we partially\n    evaluate the given program with respect to some partial state to\n    get a *residual* program.  In the second, *dynamic* stage, we\n    evaluate the residual program with respect to the rest of the\n    state.  This dynamic state provides values for those variables\n    that are unknown in the static (partial) state.  Thus, the\n    residual program should be equivalent to *prepending* the\n    assignments listed in the partial state to the original program.\n\n```", "```\n\n## Boolean Expressions\n\n    The partial evaluation of boolean expressions is similar.  In\n    fact, it is entirely analogous to the constant folding of boolean\n    expressions, because our language has no boolean variables.\n\n```", "```\n\n    The correctness of pe_bexp is analogous to the correctness of\n    pe_aexp above.\n\n```", "```\n\n# Partial Evaluation of Commands, Without Loops\n\n    What about the partial evaluation of commands?  The analogy\n    between partial evaluation and full evaluation continues: Just as\n    full evaluation of a command turns an initial state into a final\n    state, partial evaluation of a command turns an initial partial\n    state into a final partial state.  The difference is that, because\n    the state is partial, some parts of the command may not be\n    executable at the static stage.  Therefore, just as pe_aexp\n    returns a residual aexp and pe_bexp returns a residual bexp\n    above, partially evaluating a command yields a residual command.\n\n    Another way in which our partial evaluator is similar to a full\n    evaluator is that it does not terminate on all commands.  It is\n    not hard to build a partial evaluator that terminates on all\n    commands; what is hard is building a partial evaluator that\n    terminates on all commands yet automatically performs desired\n    optimizations such as unrolling loops.  Often a partial evaluator\n    can be coaxed into terminating more often and performing more\n    optimizations by writing the source program differently so that\n    the separation between static and dynamic information becomes more\n    apparent.  Such coaxing is the art of *binding-time improvement*.\n    The binding time of a variable tells when its value is known \u2014\n    either \"static\", or \"dynamic.\"\n\n    Anyway, for now we will just live with the fact that our partial\n    evaluator is not a total function from the source command and the\n    initial partial state to the residual command and the final\n    partial state.  To model this non-termination, just as with the\n    full evaluation of commands, we use an inductively defined\n    relation.  We write\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(X\u00a0::=\u00a0ANum\u00a03\u00a0;;\u00a0Y\u00a0::=\u00a0AMult\u00a0(AId\u00a0Z)\u00a0(APlus\u00a0(AId\u00a0X)\u00a0(AId\u00a0X)))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/\u00a0[]\u00a0\u21d3\u00a0(Y\u00a0::=\u00a0AMult\u00a0(AId\u00a0Z)\u00a0(ANum\u00a06))\u00a0/\u00a0[(X,3)]\n\n    to hold.  The assignment to X appears in the final partial state,\n    not the residual command. \n\n## Assignment\n\n    Let's start by considering how to partially evaluate an\n    assignment.  The two assignments in the source program above needs\n    to be treated differently.  The first assignment X ::= ANum 3,\n    is *static*: its right-hand-side is a constant (more generally,\n    simplifies to a constant), so we should update our partial state\n    at X to 3 and produce no residual code.  (Actually, we produce\n    a residual SKIP.)  The second assignment Y ::= AMult (AId Z) (APlus (AId X) (AId X)) is *dynamic*: its right-hand-side does\n    not simplify to a constant, so we should leave it in the residual\n    code and remove Y, if present, from our partial state.  To\n    implement these two cases, we define the functions pe_add and\n    pe_remove.  Like pe_update above, these functions operate on\n    a concrete list representing a pe_state, but the theorems\n    pe_add_correct and pe_remove_correct specify their behavior by\n    the pe_lookup interpretation of the pe_state.\n\n```", "```\n\n    We will use the two theorems below to show that our partial\n    evaluator correctly deals with dynamic assignments and static\n    assignments, respectively.\n\n```", "```\n\n## Conditional\n\n    Trickier than assignments to partially evaluate is the\n    conditional, IFB b[1] THEN c[1] ELSE c[2] FI.  If b[1] simplifies to\n    BTrue or BFalse then it's easy: we know which branch will be\n    taken, so just take that branch.  If b[1] does not simplify to a\n    constant, then we need to take both branches, and the final\n    partial state may differ between the two branches!\n\n    The following program illustrates the difficulty:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SKIP;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IFB\u00a0BLe\u00a0(AId\u00a0Y)\u00a0(ANum\u00a04)\u00a0THEN\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SKIP;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SKIP;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0ANum\u00a04\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ELSE\u00a0SKIP\u00a0FI\n\n    Programming this case in Coq calls for several auxiliary\n    functions: we need to compute the intersection of two pe_states\n    and turn their difference into sequences of assignments.\n\n    First, we show how to compute whether two pe_states to disagree\n    at a given variable.  In the theorem pe_disagree_domain, we\n    prove that two pe_states can only disagree at variables that\n    appear in at least one of them.\n\n```", "```\n\n    We define the pe_compare function to list the variables where\n    two given pe_states disagree.  This list is exact, according to\n    the theorem pe_compare_correct: a variable appears on the list\n    if and only if the two given pe_states disagree at that\n    variable.  Furthermore, we use the pe_unique function to\n    eliminate duplicates from the list.\n\n```", "```\n\n    The intersection of two partial states is the result of removing\n    from one of them all the variables where the two disagree.  We\n    define the function pe_removes, in terms of pe_remove above,\n    to perform such a removal of a whole list of variables at once.\n\n    The theorem pe_compare_removes testifies that the pe_lookup\n    interpretation of the result of this intersection operation is the\n    same no matter which of the two partial states we remove the\n    variables from.  Because pe_update only depends on the\n    pe_lookup interpretation of partial states, pe_update also\n    does not care which of the two partial states we remove the\n    variables from; that theorem pe_compare_update is used in the\n    correctness proof shortly.\n\n```", "```\n\n    Finally, we define an assign function to turn the difference\n    between two partial states into a sequence of assignment commands.\n    More precisely, assign pe_st ids generates an assignment command\n    for each variable listed in ids.\n\n```", "```\n\n    The command generated by assign always terminates, because it is\n    just a sequence of assignments.  The (total) function assigned\n    below computes the effect of the command on the (dynamic state).\n    The theorem assign_removes then confirms that the generated\n    assignments perfectly compensate for removing the variables from\n    the partial state.\n\n```", "```\n\n## The Partial Evaluation Relation\n\n    At long last, we can define a partial evaluator for commands\n    without loops, as an inductive relation!  The inequality\n    conditions in PE_AssDynamic and PE_If are just to keep the\n    partial evaluator deterministic; they are not required for\n    correctness.\n\n```", "```\n\n## Examples\n\n    Below are some examples of using the partial evaluator.  To make\n    the pe_com relation actually usable for automatic partial\n    evaluation, we would need to define more automation tactics in\n    Coq.  That is not hard to do, but it is not needed here.\n\n```", "```\n\n## Correctness of Partial Evaluation\n\n    Finally let's prove that this partial evaluator is correct!\n\n```", "```\n\n    The main theorem. Thanks to David Menendez for this formulation!\n\n```", "```\n\n# Partial Evaluation of Loops\n\n    It may seem straightforward at first glance to extend the partial\n    evaluation relation pe_com above to loops.  Indeed, many loops\n    are easy to deal with.  Considered this repeated-squaring loop,\n    for example:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0AMult\u00a0(AId\u00a0Y)\u00a0(AId\u00a0Y);;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0AMult\u00a0(AId\u00a0Y)\u00a0(AId\u00a0Y);;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0AMult\u00a0(AId\u00a0Y)\u00a0(AId\u00a0Y)\n\n    if X is initially 3 (and finally 0).  In general, a loop is\n    easy to partially evaluate if the final partial state of the loop\n    body is equal to the initial state, or if its guard condition is\n    static.\n\n    But there are other loops for which it is hard to express the\n    residual program we want in Imp.  For example, take this program\n    for checking whether Y is even or odd:\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0BLe\u00a0(ANum\u00a01)\u00a0(AId\u00a0Y)\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0AMinus\u00a0(AId\u00a0Y)\u00a0(ANum\u00a01);;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IF\u00a0BLe\u00a0(ANum\u00a01)\u00a0(AId\u00a0Y)\u00a0THEN\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0AMinus\u00a0(AId\u00a0Y)\u00a0(ANum\u00a01)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ELSE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0ANum\u00a01;;\u00a0EXIT\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FI\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0END;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0ANum\u00a00\n\n    Unfortunately, there is no EXIT command in Imp.  Without\n    extending the range of control structures available in our\n    language, the best we can do is to repeat loop-guard tests or add\n    flag variables.  Neither option is terribly attractive.\n\n    Still, as a digression, below is an attempt at performing partial\n    evaluation on Imp commands.  We add one more command argument\n    c'' to the pe_com relation, which keeps track of a loop to\n    roll up.\n\n```", "```\n\n## Examples\n\n```", "```\n\n## Correctness\n\n    Because this partial evaluator can unroll a loop n-fold where n is\n    a (finite) integer greater than one, in order to show it correct\n    we need to perform induction not structurally on dynamic\n    evaluation but on the number of times dynamic evaluation enters a\n    loop body.\n\n```", "```\n\n# Partial Evaluation of Flowchart Programs\n\n    Instead of partially evaluating WHILE loops directly, the\n    standard approach to partially evaluating imperative programs is\n    to convert them into *flowcharts*.  In other words, it turns out\n    that adding labels and jumps to our language makes it much easier\n    to partially evaluate.  The result of partially evaluating a\n    flowchart is a residual flowchart.  If we are lucky, the jumps in\n    the residual flowchart can be converted back to WHILE loops, but\n    that is not possible in general; we do not pursue it here. \n\n## Basic blocks\n\n    A flowchart is made of *basic blocks*, which we represent with the\n    inductive type block.  A basic block is a sequence of\n    assignments (the constructor Assign), concluding with a\n    conditional jump (the constructor If) or an unconditional jump\n    (the constructor Goto).  The destinations of the jumps are\n    specified by *labels*, which can be of any type.  Therefore, we\n    parameterize the block type by the type of labels.\n\n```", "```\n\n    We use the \"even or odd\" program, expressed above in Imp, as our\n    running example.  Converting this program into a flowchart turns\n    out to require 4 labels, so we define the following type.\n\n```", "```\n\n    The following block is the basic block found at the body label\n    of the example program.\n\n```", "```\n\n    To evaluate a basic block, given an initial state, is to compute\n    the final state and the label to jump to next.  Because basic\n    blocks do not *contain* loops or other control structures,\n    evaluation of basic blocks is a total function \u2014 we don't need to\n    worry about non-termination.\n\n```", "```\n\n## Flowchart programs\n\n    A flowchart program is simply a lookup function that maps labels\n    to basic blocks.  Actually, some labels are *halting states* and\n    do not map to any basic block.  So, more precisely, a flowchart\n    program whose labels are of type L is a function from L to\n    option (block L).\n\n```", "```\n\n    Unlike a basic block, a program may not terminate, so we model the\n    evaluation of programs by an inductive relation peval rather\n    than a recursive function.\n\n```", "```\n\n## Partial Evaluation of Basic Blocks and Flowchart Programs\n\n    Partial evaluation changes the label type in a systematic way: if\n    the label type used to be L, it becomes pe_state * L.  So the\n    same label in the original program may be unfolded, or blown up,\n    into multiple labels by being paired with different partial\n    states.  For example, the label loop in the parity program\n    will become two labels: ([(X,0)], loop) and ([(X,1)], loop).\n    This change of label type is reflected in the types of pe_block\n    and pe_program defined presently.\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]