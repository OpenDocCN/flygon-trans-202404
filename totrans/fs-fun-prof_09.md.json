["```\nAdd1(x) = x+1 \n```", "```\nlet add1 x = x + 1 \n```", "```\nval add1 : int -> int \n```", "```\nint add1(int input) { \n   switch (input)\n   {\n   case 0: return 1;\n   case 1: return 2;\n   case 2: return 3;\n   case 3: return 4;\n   etc ad infinitum\n   }\n} \n```", "```\nx = 5\ny = x+1 \n```", "```\nlet add1 x = x + 1 \n```", "```\nlet add1 x = x + 1\nadd1 5\n// replace \"x\" with \"5\"\n// add1 5 = 5 + 1 = 6\n// result is 6 \n```", "```\nlet add1 x = x + 1\nlet plus1 = add1\nadd1 5\nplus1 5 \n```", "```\nval functionName : domain -> range \n```", "```\nlet c = 5 \n```", "```\nval c : int = 5 \n```", "```\nval aName: type = constant     // Note that there is no arrow \n```", "```\nlet c = fun()->5    \n// or\nlet c() = 5 \n```", "```\nval c : unit -> int \n```", "```\nval c : int = 5 \n```", "```\n\"abc\".Length \n```", "```\nA'b'c     begin'  // valid names \n```", "```\nlet f = x\nlet f' = derivative f\nlet f'' = derivative f' \n```", "```\nlet if' b t f = if b then t else f \n```", "```\n``this is a name``  ``123``    //valid names \n```", "```\nlet ``begin`` = \"begin\" \n```", "```\nlet ``is first time customer?`` = true\nlet ``add gift to order`` = ()\nif ``is first time customer?`` then ``add gift to order``\n\n// Unit test \nlet [<Test>] ``When input is 2 then expect square is 4``=  \n   // code here\n\n// BDD clause\nlet [<Given>] ``I have (.*) N products in my cart`` (n:int) =  \n   // code here \n```", "```\nval functionName : domain -> range \n```", "```\nlet intToString x = sprintf \"x is %i\" x  // format int to string\nlet stringToInt x = System.Int32.Parse(x) \n```", "```\nval intToString : int -> string\nval stringToInt : string -> int \n```", "```\nlet intToFloat x = float x // \"float\" fn. converts ints to floats\nlet intToBool x = (x = 2)  // true if x equals 2\nlet stringToString x = x + \" world\" \n```", "```\nval intToFloat : int -> float\nval intToBool : int -> bool\nval stringToString : string -> string \n```", "```\nlet stringLength x = x.Length         \n   => error FS0072: Lookup on object of indeterminate type \n```", "```\nlet stringLength (x:string) = x.Length \n```", "```\nlet stringLengthAsInt (x:string) :int = x.Length \n```", "```\nlet evalWith5ThenAdd2 fn = fn 5 + 2     // same as fn(5) + 2 \n```", "```\nval evalWith5ThenAdd2 : (int -> int) -> int \n```", "```\nlet add1 x = x + 1      // define a function of type (int -> int)\nevalWith5ThenAdd2 add1  // test it \n```", "```\nval add1 : int -> int\nval it : int = 8 \n```", "```\nlet times3 x = x * 3      // a function of type (int -> int)\nevalWith5ThenAdd2 times3  // test it \n```", "```\nval times3 : int -> int\nval it : int = 17 \n```", "```\nlet times3float x = x * 3.0  // a function of type (float->float) \nevalWith5ThenAdd2 times3float \n```", "```\nerror FS0001: Type mismatch. Expecting a int -> int but \n              given a float -> float \n```", "```\nlet adderGenerator numberToAdd = (+) numberToAdd \n```", "```\nval adderGenerator : int -> (int -> int) \n```", "```\nlet add1 = adderGenerator 1\nlet add2 = adderGenerator 2 \n```", "```\nval add1 : (int -> int)\nval add2 : (int -> int) \n```", "```\nadd1 5    // val it : int = 6\nadd2 5    // val it : int = 7 \n```", "```\nlet evalWith5ThenAdd2 fn = fn 5 +2\n    => val evalWith5ThenAdd2 : (int -> int) -> int \n```", "```\nlet evalWith5 fn = fn 5 \n```", "```\nlet evalWith5AsInt (fn:int->int) = fn 5\nlet evalWith5AsFloat (fn:int->float) = fn 5 \n```", "```\nlet evalWith5AsString fn :string = fn 5 \n```", "```\nlet printInt x = printf \"x is %i\" x        // print to console \n```", "```\nval printInt : int -> unit \n```", "```\nlet whatIsThis = () \n```", "```\nval whatIsThis : unit = () \n```", "```\nval printInt : int -> unit \n```", "```\nlet printHello = printf \"hello world\"        // print to console \n```", "```\nhello world\nval printHello : unit = () \n```", "```\nval aName: type = constant \n```", "```\nlet printHelloFn () = printf \"hello world\"    // print to console \n```", "```\nval printHelloFn : unit -> unit \n```", "```\nprintHelloFn () \n```", "```\ndo 1+1     // => FS0020: This expression should have type 'unit'\n\nlet something = \n  2+2      // => FS0020: This expression should have type 'unit'\n  \"hello\" \n```", "```\ndo (1+1 |> ignore)  // ok\n\nlet something = \n  2+2 |> ignore     // ok\n  \"hello\" \n```", "```\nlet onAStick x = x.ToString() + \" on a stick\" \n```", "```\nval onAStick : 'a -> string \n```", "```\nstring onAStick<a>();   \n\n//or more idiomatically \nstring OnAStick<TObject>();   // F#'s use of 'a is like \n                              // C#'s \"TObject\" convention \n```", "```\nonAStick 22\nonAStick 3.14159\nonAStick \"hello\" \n```", "```\nlet concatString x y = x.ToString() + y.ToString() \n```", "```\nval concatString : 'a -> 'b -> string \n```", "```\nlet isEqual x y = (x=y) \n```", "```\nval isEqual : 'a -> 'a -> bool \n```", "```\nstring * int      // (\"hello\", 1) \n```", "```\nint list          // List type  e.g. [1;2;3]\nstring list       // List type  e.g. [\"a\";\"b\";\"c\"]\nseq<int>          // Seq type   e.g. seq{1..10}\nint []            // Array type e.g. [|1;2;3|] \n```", "```\nint option        // Some(1) \n```", "```\nlet testA   = float 2\nlet testB x = float 2\nlet testC x = float 2 + x\nlet testD x = x.ToString().Length\nlet testE (x:float) = x.ToString().Length\nlet testF x = printfn \"%s\" x\nlet testG x = printfn \"%f\" x\nlet testH   = 2 * 2 |> ignore\nlet testI x = 2 * 2 |> ignore\nlet testJ (x:int) = 2 * 2 |> ignore\nlet testK   = \"hello\"\nlet testL() = \"hello\"\nlet testM x = x=x\nlet testN x = x 1          // hint: what kind of thing is x?\nlet testO x:string = x 1   // hint: what does :string modify? \n```", "```\n//normal version\nlet printTwoParameters x y = \n   printfn \"x=%i y=%i\" x y \n```", "```\n//explicitly curried version\nlet printTwoParameters x  =    // only one parameter!\n   let subFunction y = \n      printfn \"x=%i y=%i\" x y  // new function with one param\n   subFunction                 // return the subfunction \n```", "```\n// eval with one argument\nprintTwoParameters 1 \n\n// get back a function!\nval it : (int -> unit) = <fun:printTwoParameters@286-3> \n```", "```\n// step by step version\nlet x = 6\nlet y = 99\nlet intermediateFn = printTwoParameters x  // return fn with \n                                           // x \"baked in\"\nlet result  = intermediateFn y \n\n// inline version of above\nlet result  = (printTwoParameters x) y\n\n// normal version\nlet result  = printTwoParameters x y \n```", "```\n//normal version\nlet addTwoParameters x y = \n   x + y\n\n//explicitly curried version\nlet addTwoParameters x  =      // only one parameter!\n   let subFunction y = \n      x + y                    // new function with one param\n   subFunction                 // return the subfunction\n\n// now use it step by step \nlet x = 6\nlet y = 99\nlet intermediateFn = addTwoParameters x  // return fn with \n                                         // x \"baked in\"\nlet result  = intermediateFn y \n\n// normal version\nlet result  = addTwoParameters x y \n```", "```\n// using plus as a single value function \nlet x = 6\nlet y = 99\nlet intermediateFn = (+) x     // return add with x baked in\nlet result  = intermediateFn y \n\n// using plus as a function with two parameters\nlet result  = (+) x y          \n\n// normal version of plus as infix operator\nlet result  = x + y \n```", "```\n// normal version of multiply\nlet result  = 3 * 5\n\n// multiply as a one parameter function\nlet intermediateFn = (*) 3   // return multiply with \"3\" baked in\nlet result  = intermediateFn 5\n\n// normal version of printfn\nlet result  = printfn \"x=%i y=%i\" 3 5  \n\n// printfn as a one parameter function\nlet intermediateFn = printfn \"x=%i y=%i\" 3  // \"3\" is baked in\nlet result  = intermediateFn 5 \n```", "```\nval printTwoParameters : int -> (int -> unit) \n```", "```\nval printTwoParameters : int -> int -> unit \n```", "```\nlet add1Param x = (+) x    \n// signature is = int -> (int -> int) \n```", "```\nlet add2Params x y = (+) x y    \n// signature is = int -> int -> int \n```", "```\nlet multiParamFn (p1:int)(p2:bool)(p3:string)(p4:float)=\n   ()   //do nothing\n\nlet intermediateFn1 = multiParamFn 42    \n   // intermediateFn1 takes a bool \n   // and returns a new function (string -> float -> unit)\nlet intermediateFn2 = intermediateFn1 false    \n   // intermediateFn2 takes a string \n   // and returns a new function (float -> unit)\nlet intermediateFn3 = intermediateFn2 \"hello\"  \n   // intermediateFn3 takes a float \n   // and returns a simple value (unit)\nlet finalResult = intermediateFn3 3.141 \n```", "```\nval multiParamFn : int -> bool -> string -> float -> unit \n```", "```\nval intermediateFn1 : (bool -> string -> float -> unit)\nval intermediateFn2 : (string -> float -> unit)\nval intermediateFn3 : (float -> unit)\nval finalResult : unit = () \n```", "```\nint->int->int      // two int parameters and returns an int\n\nstring->bool->int  // first param is a string, second is a bool, \n                   // returns an int\n\nint->string->bool->unit // three params (int,string,bool) \n                        // returns nothing (unit)\n\n(int->string)->int      // has only one parameter, a function\n                        // value (from int to string)\n                        // and returns a int\n\n(int->string)->(int->bool) // takes a function (int to string) \n                           // returns a function (int to bool) \n```", "```\n// create a function\nlet printHello() = printfn \"hello\" \n```", "```\n// call it\nprintHello \n```", "```\nlet addXY x y = \n    printfn \"x=%i y=%i\" x     \n    x + y \n```", "```\nprintfn \"x=%i y=%i\" x\n//^^^^^^^^^^^^^^^^^^^^^\n//warning FS0193: This expression is a function value, i.e. is missing\n//arguments. Its type is  ^a -> unit. \n```", "```\nlet reader = new System.IO.StringReader(\"hello\");\n\nlet line1 = reader.ReadLine        // wrong but compiler doesn't \n                                   // complain\nprintfn \"The line is %s\" line1     //compiler error here!\n// ==> error FS0001: This expression was expected to have \n// type string but here has type unit -> string \n\nlet line2 = reader.ReadLine()      //correct\nprintfn \"The line is %s\" line2     //no compiler error \n```", "```\nprintfn \"hello\" 42\n// ==> error FS0001: This expression was expected to have \n//                   type 'a -> 'b but here has type unit \n\nprintfn \"hello %i\" 42 43\n// ==> Error FS0001: Type mismatch. Expecting a 'a -> 'b -> 'c \n//                   but given a 'a -> unit \n\nprintfn \"hello %i %i\" 42 43 44\n// ==> Error FS0001: Type mismatch. Expecting a 'a->'b->'c->'d \n//                   but given a 'a -> 'b -> unit \n```", "```\nlet add1 x = x + 1\nlet x = add1 2 3\n// ==>   error FS0003: This value is not a function \n//                     and cannot be applied \n```", "```\nlet add1 x = x + 1\nlet intermediateFn = add1 2   //returns a simple value\nlet x = intermediateFn 3      //intermediateFn is not a function!\n// ==>   error FS0003: This value is not a function \n//                     and cannot be applied \n```", "```\n// create an \"adder\" by partial application of add\nlet add42 = (+) 42    // partial application\nadd42 1\nadd42 3\n\n// create a new list by applying the add42 function \n// to each element\n[1;2;3] |> List.map add42 \n\n// create a \"tester\" by partial application of \"less than\"\nlet twoIsLessThan = (<) 2   // partial application\ntwoIsLessThan 1\ntwoIsLessThan 3\n\n// filter each element with the twoIsLessThan function\n[1;2;3] |> List.filter twoIsLessThan \n\n// create a \"printer\" by partial application of printfn\nlet printer = printfn \"printing param=%i\" \n\n// loop over each element and call the printer function\n[1;2;3] |> List.iter printer \n```", "```\n// an example using List.map\nlet add1 = (+) 1\nlet add1ToEach = List.map add1   // fix the \"add1\" function\n\n// test\nadd1ToEach [1;2;3;4]\n\n// an example using List.filter\nlet filterEvens = \n   List.filter (fun i -> i%2 = 0) // fix the filter function\n\n// test\nfilterEvens [1;2;3;4] \n```", "```\n// create an adder that supports a pluggable logging function\nlet adderWithPluggableLogger logger x y = \n    logger \"x\" x\n    logger \"y\" y\n    let result = x + y\n    logger \"x+y\"  result \n    result \n\n// create a logging function that writes to the console\nlet consoleLogger argName argValue = \n    printfn \"%s=%A\" argName argValue \n\n//create an adder with the console logger partially applied\nlet addWithConsoleLogger = adderWithPluggableLogger consoleLogger \naddWithConsoleLogger  1 2 \naddWithConsoleLogger  42 99\n\n// create a logging function that creates popup windows\nlet popupLogger argName argValue = \n    let message = sprintf \"%s=%A\" argName argValue \n    System.Windows.Forms.MessageBox.Show(\n                                 text=message,caption=\"Logger\") \n      |> ignore\n\n//create an adder with the popup logger partially applied\nlet addWithPopupLogger  = adderWithPluggableLogger popupLogger \naddWithPopupLogger  1 2 \naddWithPopupLogger  42 99 \n```", "```\n// create a another adder with 42 baked in\nlet add42WithConsoleLogger = addWithConsoleLogger 42 \n[1;2;3] |> List.map add42WithConsoleLogger  \n[1;2;3] |> List.map add42               //compare without logger \n```", "```\nList-function [function parameter(s)] [list] \n```", "```\nList.map    (fun i -> i+1) [0;1;2;3]\nList.filter (fun i -> i>1) [0;1;2;3]\nList.sortBy (fun i -> -i ) [0;1;2;3] \n```", "```\nlet eachAdd1 = List.map (fun i -> i+1) \neachAdd1 [0;1;2;3]\n\nlet excludeOneOrLess = List.filter (fun i -> i>1) \nexcludeOneOrLess [0;1;2;3]\n\nlet sortDesc = List.sortBy (fun i -> -i) \nsortDesc [0;1;2;3] \n```", "```\n// piping using list functions\nlet result = \n   [1..10]\n   |> List.map (fun i -> i+1)\n   |> List.filter (fun i -> i>5) \n```", "```\nlet compositeOp = List.map (fun i -> i+1) \n                  >> List.filter (fun i -> i>5)\nlet result = compositeOp [1..10] \n```", "```\n// create wrappers for .NET string functions\nlet replace oldStr newStr (s:string) = \n  s.Replace(oldValue=oldStr, newValue=newStr)\n\nlet startsWith lookFor (s:string) = \n  s.StartsWith(lookFor) \n```", "```\nlet result = \n     \"hello\" \n     |> replace \"h\" \"j\" \n     |> startsWith \"j\"\n\n[\"the\"; \"quick\"; \"brown\"; \"fox\"] \n     |> List.filter (startsWith \"f\") \n```", "```\nlet compositeOp = replace \"h\" \"j\" >> startsWith \"j\"\nlet result = compositeOp \"hello\" \n```", "```\nlet (|>) x f = f x \n```", "```\nlet doSomething x y z = x+y+z\ndoSomething 1 2 3       // all parameters after function \n```", "```\nlet doSomething x y  = \n   let intermediateFn z = x+y+z\n   intermediateFn        // return intermediateFn\n\nlet doSomethingPartial = doSomething 1 2\ndoSomethingPartial 3     // only one parameter after function now\n3 |> doSomethingPartial  // same as above - last parameter piped in \n```", "```\n\"12\" |> int               // parses string \"12\" to an int\n1 |> (+) 2 |> (*) 3       // chain of arithmetic \n```", "```\nlet (<|) f x = f x \n```", "```\nprintf \"%i\" 1+2          // error\nprintf \"%i\" (1+2)        // using parens\nprintf \"%i\" <| 1+2       // using reverse pipe \n```", "```\nlet add x y = x + y\n(1+2) add (3+4)          // error\n1+2 |> add <| 3+4        // pseudo infix \n```", "```\nlet F x y z = x y z \n```", "```\nlet F x y z = x (y z) \n```", "```\nlet F x y z = (x y) z \n```", "```\nlet F x y z = x (y z)\nlet F x y z = y z |> x    // using forward pipe\nlet F x y z = x <| y z    // using backward pipe \n```", "```\nlet f (x:int) = float x * 3.0  // f is int->float\nlet g (x:float) = x > 4.0      // g is float->bool \n```", "```\nlet h (x:int) = \n    let y = f(x)\n    g(y)                   // return output of g \n```", "```\nlet h (x:int) = g ( f(x) ) // h is int->bool\n\n//test\nh 1\nh 2 \n```", "```\nlet compose f g x = g ( f(x) ) \n```", "```\nval compose : ('a -> 'b) -> ('b -> 'c) -> 'a -> 'c \n```", "```\nlet (>>) f g x = g ( f(x) ) \n```", "```\nlet add1 x = x + 1\nlet times2 x = x * 2\nlet add1Times2 x = (>>) add1 times2 x\n\n//test\nadd1Times2 3 \n```", "```\nlet add1Times2 = (>>) add1 times2 \n```", "```\nlet add1Times2 = add1 >> times2 \n```", "```\nlet add1 x = x + 1\nlet times2 x = x * 2\n\n//old style\nlet add1Times2 x = times2(add1 x)\n\n//new style\nlet add1Times2 = add1 >> times2 \n```", "```\nlet add n x = x + n\nlet times n x = x * n\nlet add1Times2 = add 1 >> times 2\nlet add5Times3 = add 5 >> times 3\n\n//test\nadd5Times3 1 \n```", "```\nlet twice f = f >> f    //signature is ('a -> 'a) -> ('a -> 'a) \n```", "```\nlet add1 = (+) 1           // signature is (int -> int)\nlet add1Twice = twice add1 // signature is also (int -> int)\n\n//test\nadd1Twice 9 \n```", "```\nlet addThenMultiply = (+) >> (*) \n```", "```\nlet add1ThenMultiply = (+) 1 >> (*) \n// (+) 1 has signature (int -> int) and output is an 'int'\n\n//test\nadd1ThenMultiply 2 7 \n```", "```\nlet times2Add1 = add 1 << times 2\ntimes2Add1 3 \n```", "```\nlet myList = []\nmyList |> List.isEmpty |> not    // straight pipeline\n\nmyList |> (not << List.isEmpty)  // using reverse composition \n```", "```\nlet (|>) x f = f x \n```", "```\nlet doSomething x y z = x+y+z\ndoSomething 1 2 3       // all parameters after function\n3 |> doSomething 1 2    // last parameter piped in \n```", "```\n3 >> doSomething 1 2     // not allowed\n// f >> g is the same as  g(f(x)) so rewriting it we have:\ndoSomething 1 2 ( 3(x) ) // implies 3 should be a function!\n// error FS0001: This expression was expected to have type 'a->'b \n//               but here has type int \n```", "```\nlet (>>) f g x = g ( f(x) )\n\nlet add n x = x + n\nlet times n x = x * n\nlet add1Times2 = add 1 >> times 2 \n```", "```\nlet add1Times2 = add 1 |> times 2   // not allowed\n// x |> f is the same as  f(x) so rewriting it we have:\nlet add1Times2 = times 2 (add 1)    // add1 should be an int\n// error FS0001: Type mismatch. 'int -> int' does not match 'int' \n```", "```\nlet add x y = x + y \n```", "```\nfun parameter1 parameter2 etc -> expression \n```", "```\nlet add = fun x y -> x + y \n```", "```\nlet add x y = x + y \n```", "```\n// with separately defined function\nlet add1 i = i + 1\n[1..10] |> List.map add1\n\n// inlined without separately defined function\n[1..10] |> List.map (fun i -> i + 1) \n```", "```\n// original definition\nlet adderGenerator x = (+) x\n\n// definition using lambda\nlet adderGenerator x = fun y -> x + y \n```", "```\nlet adderGenerator = fun x -> (fun y -> x + y) \n```", "```\nlet adderGenerator1 x y = x + y \nlet adderGenerator2 x   = fun y -> x + y\nlet adderGenerator3     = fun x -> (fun y -> x + y) \n```", "```\ntype Name = {first:string; last:string} // define a new type\nlet bob = {first=\"bob\"; last=\"smith\"}   // define a value \n\n// single parameter style\nlet f1 name =                       // pass in single parameter \n   let {first=f; last=l} = name     // extract in body of function \n   printfn \"first=%s; last=%s\" f l\n\n// match in the parameter itself\nlet f2 {first=f; last=l} =          // direct pattern matching \n   printfn \"first=%s; last=%s\" f l \n\n// test\nf1 bob\nf2 bob \n```", "```\nlet f3 (x::xs) =            // use pattern matching on a list\n   printfn \"first element is=%A\" x \n```", "```\n// a function that takes two distinct parameters\nlet addTwoParams x y = x + y\n\n// a function that takes a single tuple parameter\nlet addTuple aTuple = \n   let (x,y) = aTuple\n   x + y\n\n// another function that takes a single tuple parameter \n// but looks like it takes two ints\nlet addConfusingTuple (x,y) = x + y \n```", "```\nval addTwoParams : int -> int -> int        // two params\nval addTuple : int * int -> int             // tuple->int\nval addConfusingTuple : int * int -> int    // tuple->int \n```", "```\n//test\naddTwoParams 1 2      // ok - uses spaces to separate args\naddTwoParams (1,2)    // error trying to pass a single tuple \n//   => error FS0001: This expression was expected to have type\n//                    int but here has type 'a * 'b \n```", "```\naddTuple (1,2)           // ok\naddConfusingTuple (1,2)  // ok\n\nlet x = (1,2)                 \naddTuple x               // ok\n\nlet y = 1,2              // it's the comma you need, \n                         // not the parentheses! \naddTuple y               // ok\naddConfusingTuple y      // ok \n```", "```\naddConfusingTuple 1 2    // error trying to pass two args \n// => error FS0003: This value is not a function and \n//                  cannot be applied \n```", "```\nlet f (x,y,z) = x + y * z\n// type is int * int * int -> int\n\n// test\nf (1,2,3) \n```", "```\n// correct\nSystem.String.Compare(\"a\",\"b\")\n\n// incorrect\nSystem.String.Compare \"a\" \"b\" \n```", "```\nlet tuple = (\"a\",\"b\")\nSystem.String.Compare tuple   // error \n\nSystem.String.Compare \"a\",\"b\" // error \n```", "```\n// create a wrapper function\nlet strCompare x y = System.String.Compare(x,y)\n\n// partially apply it\nlet strCompareWithB = strCompare \"B\"\n\n// use it with a higher order function\n[\"A\";\"B\";\"C\"]\n|> List.map strCompareWithB \n```", "```\n// Pass in two numbers for addition. \n// The numbers are independent, so use two parameters\nlet add x y = x + y\n\n// Pass in two numbers as a geographical co-ordinate. \n// The numbers are dependent, so group them into a tuple or record\nlet locateOnMap (xCoord,yCoord) = // do something\n\n// Set first and last name for a customer.\n// The values are dependent, so group them into a record.\ntype CustomerName = {First:string; Last:string}\nlet setCustomerName aCustomerName = // good\nlet setCustomerName first last = // not recommended\n\n// Set first and last name and and pass the \n// authorizing credentials as well.\n// The name and credentials are independent, keep them separate\nlet setCustomerName myCredentials aName = //good \n```", "```\nlet sayHello = printfn \"Hello World!\"     // not what we want \n```", "```\nlet sayHello() = printfn \"Hello World!\"           // good\nlet sayHello = fun () -> printfn \"Hello World!\"   // good \n```", "```\n// call it\nsayHello() \n```", "```\nConsole.ReadLine()\nSystem.Environment.GetCommandLineArgs()\nSystem.IO.Directory.GetCurrentDirectory() \n```", "```\n// define\nlet (.*%) x y = x + y + 1 \n```", "```\nlet ( *+* ) x y = x + y + 1 \n```", "```\nlet result = (.*%) 2 3 \n```", "```\nlet result = 2 .*% 3 \n```", "```\nlet (~%%) (s:string) = s.ToCharArray()\n\n//use\nlet result = %% \"hello\" \n```", "```\nlet add x y = x + y   // explicit\nlet add x = (+) x     // point free\n\nlet add1Times2 x = (x + 1) * 2    // explicit\nlet add1Times2 = (+) 1 >> (*) 2   // point free\n\nlet sum list = List.reduce (fun sum e -> sum+e) list // explicit\nlet sum = List.reduce (+)                            // point free \n```", "```\nlet (|>) x f = f x             // forward pipe\nlet (<|) f x = f x             // reverse pipe\nlet (>>) f g x = g (f x)       // forward composition\nlet (<<) g f x = g (f x)       // reverse composition \n```", "```\nlet I x = x                // identity function, or the Idiot bird\nlet K x y = x              // the Kestrel\nlet M x = x >> x           // the Mockingbird\nlet T x y = y x            // the Thrush (this looks familiar!)\nlet Q x y z = y (x z)      // the Queer bird (also familiar!)\nlet S x y z = x z (y z)    // The Starling\n// and the infamous...\nlet rec Y f x = f (Y f) x  // Y-combinator, or Sage bird \n```", "```\nlet fib i = \n   match i with\n   | 1 -> 1\n   | 2 -> 1\n   | n -> fib(n-1) + fib(n-2) \n```", "```\nerror FS0039: The value or constructor 'fib' is not defined \n```", "```\nlet rec fib i = \n   match i with\n   | 1 -> 1\n   | 2 -> 1\n   | n -> fib(n-1) + fib(n-2) \n```", "```\n[1;2;3]      // a normal expression\nint list     // a type expression \n\nSome 1       // a normal expression\nint option   // a type expression \n\n(1,\"a\")      // a normal expression\nint * string // a type expression \n```", "```\n// expression syntax          // type syntax\nlet add1 x = x + 1            // int -> int \nlet add x y = x + y           // int -> int -> int\nlet print x = printf \"%A\" x   // 'a -> unit\nSystem.Console.ReadLine       // unit -> string\nList.sum                      // 'a list -> 'a\nList.filter                   // ('a -> bool) -> 'a list -> 'a list\nList.map                      // ('a -> 'b) -> 'a list -> 'b list \n```", "```\n// function signature 1\nint -> int -> int \n```", "```\n// function signature 2\nint -> unit \n```", "```\n// function signature 3\nunit -> string \n```", "```\n// function signature 4\nint -> (unit -> string) \n```", "```\n// function signature 5\n'a list -> 'a \n```", "```\n// function signature 6\n('a -> bool) -> 'a list -> 'a list \n```", "```\n// function signature 7\n('a -> 'b) -> 'a list -> 'b list \n```", "```\n'a list -> 'a list -> 'a list \n```", "```\nappend : 'T list -> 'T list -> 'T list \n```", "```\ntype Adder = int -> int\ntype AdderGenerator = int -> Adder \n```", "```\nlet a:AdderGenerator = fun x -> (fun y -> x + y)\nlet b:AdderGenerator = fun (x:float) -> (fun y -> x + y)\nlet c                = fun (x:float) -> (fun y -> x + y) \n```", "```\nval testA = int -> int\nval testB = int -> int -> int\nval testC = int -> (int -> int)      \nval testD = (int -> int) -> int\nval testE = int -> int -> int -> int\nval testF = (int -> int) -> (int -> int)\nval testG = int -> (int -> int) -> int\nval testH = (int -> int -> int) -> int \n```", "```\nlet addThreeNumbers x y z  = \n\n    //create a nested helper function\n    let add n = \n       fun x -> x + n\n\n    // use the helper function \n    x |> add y |> add z\n\n// test\naddThreeNumbers 2 3 4 \n```", "```\nlet validateSize max n  = \n\n    //create a nested helper function with no params\n    let printError() = \n        printfn \"Oops: '%i' is bigger than max: '%i'\" n max\n\n    // use the helper function \n    if n > max then printError()\n\n// test\nvalidateSize 10 9\nvalidateSize 10 11 \n```", "```\nlet sumNumbersUpTo max = \n\n    // recursive helper function with accumulator \n    let rec recursiveSum n sumSoFar = \n        match n with\n        | 0 -> sumSoFar\n        | _ -> recursiveSum (n-1) (n+sumSoFar)\n\n    // call helper function with initial values\n    recursiveSum max 0\n\n// test\nsumNumbersUpTo 10 \n```", "```\n// wtf does this function do?\nlet f x = \n    let f2 y = \n        let f3 z = \n            x * z\n        let f4 z = \n            let f5 z = \n                y * z\n            let f6 () = \n                y * x\n            f6()\n        f4 y\n    x * f2 x \n```", "```\nmodule MathStuff = \n\n    let add x y  = x + y\n    let subtract x y  = x - y \n```", "```\nstatic class MathStuff\n{\n    static public int add(int x, int y) {\n        return x + y;\n    }\n\n    static public int subtract(int x, int y) {\n        return x - y;\n    }\n} \n```", "```\nmodule MathStuff = \n\n    let add x y  = x + y\n    let subtract x y  = x - y\n\nmodule OtherStuff = \n\n    // use a function from the MathStuff module\n    let add1 x = MathStuff.add x 1 \n```", "```\nmodule OtherStuff = \n    open MathStuff  // make all functions accessible\n\n    let add1 x = add x 1 \n```", "```\nmodule MathStuff = \n\n    let add x y  = x + y\n    let subtract x y  = x - y\n\n    // nested module \n    module FloatLib = \n\n        let add x y :float = x + y\n        let subtract x y :float  = x - y \n```", "```\nmodule OtherStuff = \n    open MathStuff\n\n    let add1 x = add x 1\n\n    // fully qualified\n    let add1Float x = MathStuff.FloatLib.add x 1.0\n\n    //with a relative path\n    let sub1Float x = FloatLib.subtract x 1.0 \n```", "```\n// top level module\nmodule MathStuff\n\nlet add x y  = x + y\nlet subtract x y  = x - y\n\n// nested module \nmodule FloatLib = \n\n    let add x y :float = x + y\n    let subtract x y :float  = x - y \n```", "```\nmodule MathStuff = \n\n    // functions\n    let add x y  = x + y\n    let subtract x y  = x - y\n\n    // type definitions\n    type Complex = {r:float; i:float}\n    type IntegerFunction = int -> int -> int\n    type DegreesOrRadians = Deg | Rad\n\n    // \"constant\"\n    let PI = 3.141\n\n    // \"variable\"\n    let mutable TrigType = Deg\n\n    // initialization / static constructor\n    do printfn \"module initialized\" \n```", "```\nmodule MathStuff = \n\n    let add x y  = x + y\n    let subtract x y  = x - y\n\n    // nested module \n    module FloatLib = \n\n        let add x y :float = x + y\n        let subtract x y :float  = x - y \n```", "```\nopen  MathStuff\nopen  MathStuff.FloatLib\n\nlet result = add 1 2  // Compiler error: This expression was expected to \n                      // have type float but here has type int \n```", "```\n[<RequireQualifiedAccess>]\nmodule MathStuff = \n\n    let add x y  = x + y\n    let subtract x y  = x - y\n\n    // nested module \n    [<RequireQualifiedAccess>]    \n    module FloatLib = \n\n        let add x y :float = x + y\n        let subtract x y :float  = x - y \n```", "```\nopen  MathStuff   // error\nopen  MathStuff.FloatLib // error \n```", "```\nlet result = MathStuff.add 1 2  \nlet result = MathStuff.FloatLib.add 1.0 2.0 \n```", "```\nnamespace Utilities\n\nmodule MathStuff = \n\n    // functions\n    let add x y  = x + y\n    let subtract x y  = x - y \n```", "```\nmodule Utilities.MathStuff  \n\n// functions\nlet add x y  = x + y\nlet subtract x y  = x - y \n```", "```\nnamespace Core.Utilities\n\nmodule MathStuff = \n    let add x y  = x + y \n```", "```\nnamespace Core.Utilities\n\nmodule MathStuff = \n    let add x y  = x + y\n\nnamespace Core.Extra\n\nmodule MoreMathStuff = \n    let add x y  = x + y \n```", "```\nnamespace Core.Utilities\n\nmodule MathStuff = \n    let add x y  = x + y\n\nnamespace Core\n\n// fully qualified name of module\n// is Core.Utilities \n// Collision with namespace above!\nmodule Utilities = \n    let add x y  = x + y \n```", "```\n// top-level module\nnamespace Example\n\n// declare the type outside the module\ntype PersonType = {First:string; Last:string}\n\n// declare a module for functions that work on the type\nmodule Person = \n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // method that works on the type\n    let fullName {First=first; Last=last} = \n        first + \" \" + last\n\n// test\nlet person = Person.create \"john\" \"doe\" \nPerson.fullName person |> printfn \"Fullname=%s\" \n```", "```\nmodule Customer = \n\n    // Customer.T is the primary type for this module\n    type T = {AccountId:int; Name:string}\n\n    // constructor\n    let create id name = \n        {T.AccountId=id; T.Name=name}\n\n    // method that works on the type\n    let isValid {T.AccountId=id; } = \n        id > 0\n\n// test\nlet customer = Customer.create 42 \"bob\" \nCustomer.isValid customer |> printfn \"Is valid?=%b\" \n```", "```\n// top-level module\nmodule Example\n\n// declare the type inside a module\ntype PersonType = {First:string; Last:string}\n\n// no functions in the module, just types... \n```", "```\n// use a namespace \nnamespace Example\n\n// declare the type outside any module\ntype PersonType = {First:string; Last:string} \n```", "```\nmodule Person = \n    type T = {First:string; Last:string} with\n        // member defined with type declaration\n        member this.FullName = \n            this.First + \" \" + this.Last\n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n// test\nlet person = Person.create \"John\" \"Doe\"\nlet fullname = person.FullName \n```", "```\nmodule Person = \n    type T = {First:string; Last:string} with\n       // member defined with type declaration\n        member this.FullName = \n            this.First + \" \" + this.Last\n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // another member added later\n    type T with \n        member this.SortableName = \n            this.Last + \", \" + this.First        \n// test\nlet person = Person.create \"John\" \"Doe\"\nlet fullname = person.FullName\nlet sortableName = person.SortableName \n```", "```\nmodule Person = \n    type T = {First:string; Last:string} with\n       // member defined with type declaration\n        member this.FullName = \n            this.First + \" \" + this.Last\n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // another member added later\n    type T with \n        member this.SortableName = \n            this.Last + \", \" + this.First \n```", "```\n// in a different module\nmodule PersonExtensions = \n\n    type Person.T with \n    member this.UppercaseName = \n        this.FullName.ToUpper() \n```", "```\nlet person = Person.create \"John\" \"Doe\"\nlet uppercaseName = person.UppercaseName \n```", "```\n// bring the extension into scope first!\nopen PersonExtensions\n\nlet person = Person.create \"John\" \"Doe\"\nlet uppercaseName = person.UppercaseName \n```", "```\ntype int with\n    member this.IsEven = this % 2 = 0 \n```", "```\ntype System.Int32 with\n    member this.IsEven = this % 2 = 0\n\n//test\nlet i = 20\nif i.IsEven then printfn \"'%i' is even\" i \n```", "```\nmodule Person = \n    type T = {First:string; Last:string} with\n        // member defined with type declaration\n        member this.FullName = \n            this.First + \" \" + this.Last\n\n        // static constructor\n        static member Create first last = \n            {First=first; Last=last}\n\n// test\nlet person = Person.T.Create \"John\" \"Doe\"\nlet fullname = person.FullName \n```", "```\ntype System.Int32 with\n    static member IsOdd x = x % 2 = 1\n\ntype System.Double with\n    static member Pi = 3.141\n\n//test\nlet result = System.Int32.IsOdd 20 \nlet pi = System.Double.Pi \n```", "```\nlet list = [1..10]\n\n// functional style\nlet len1 = List.length list\n\n// OO style\nlet len2 = list.Length \n```", "```\nmodule Person = \n    // type with no members initially\n    type T = {First:string; Last:string} \n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // standalone function \n    let fullName {First=first; Last=last} = \n        first + \" \" + last\n\n    // attach preexisting function as a member \n    type T with \n        member this.FullName = fullName this\n\n// test\nlet person = Person.create \"John\" \"Doe\"\nlet fullname = Person.fullName person  // functional style\nlet fullname2 = person.FullName        // OO style \n```", "```\nmodule Person = \n    // type with no members initially\n    type T = {First:string; Last:string} \n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // standalone function \n    let hasSameFirstAndLastName (person:T) otherFirst otherLast = \n        person.First = otherFirst && person.Last = otherLast\n\n    // attach preexisting function as a member \n    type T with \n        member this.HasSameFirstAndLastName = hasSameFirstAndLastName this\n\n// test\nlet person = Person.create \"John\" \"Doe\"\nlet result1 = Person.hasSameFirstAndLastName person \"bob\" \"smith\" // functional style\nlet result2 = person.HasSameFirstAndLastName \"bob\" \"smith\" // OO style \n```", "```\ntype Product = {SKU:string; Price: float} with\n\n    // curried style\n    member this.CurriedTotal qty discount = \n        (this.Price * float qty) - discount\n\n    // tuple style\n    member this.TupleTotal(qty,discount) = \n        (this.Price * float qty) - discount \n```", "```\nlet product = {SKU=\"ABC\"; Price=2.0}\nlet total1 = product.CurriedTotal 10 1.0 \nlet total2 = product.TupleTotal(10,1.0) \n```", "```\nlet totalFor10 = product.CurriedTotal 10\nlet discounts = [1.0..5.0] \nlet totalForDifferentDiscounts \n    = discounts |> List.map totalFor10 \n```", "```\nlet product = {SKU=\"ABC\"; Price=2.0}\nlet total3 = product.TupleTotal(qty=10,discount=1.0)\nlet total4 = product.TupleTotal(discount=1.0, qty=10) \n```", "```\ntype Product = {SKU:string; Price: float} with\n\n    // optional discount\n    member this.TupleTotal2(qty,?discount) = \n        let extPrice = this.Price * float qty\n        match discount with\n        | None -> extPrice\n        | Some discount -> extPrice - discount \n```", "```\nlet product = {SKU=\"ABC\"; Price=2.0}\n\n// discount not specified\nlet total1 = product.TupleTotal2(10)\n\n// discount specified\nlet total2 = product.TupleTotal2(10,1.0) \n```", "```\ntype Product = {SKU:string; Price: float} with\n\n    // optional discount\n    member this.TupleTotal2(qty,?discount) = \n        let extPrice = this.Price * float qty\n        let discount = defaultArg discount 0.0\n        //return\n        extPrice - discount \n```", "```\ntype Product = {SKU:string; Price: float} with\n\n    // no discount\n    member this.TupleTotal3(qty) = \n        printfn \"using non-discount method\"\n        this.Price * float qty\n\n    // with discount\n    member this.TupleTotal3(qty, discount) = \n        printfn \"using discount method\"\n        (this.Price * float qty) - discount \n```", "```\nlet product = {SKU=\"ABC\"; Price=2.0}\n\n// discount not specified\nlet total1 = product.TupleTotal3(10) \n\n// discount specified\nlet total2 = product.TupleTotal3(10,1.0) \n```", "```\nmodule Person = \n    // type with no members initially\n    type T = {First:string; Last:string} \n\n    // constructor\n    let create first last = \n        {First=first; Last=last}\n\n    // standalone function \n    let fullName {First=first; Last=last} = \n        first + \" \" + last\n\n    // function as a member \n    type T with \n        member this.FullName = fullName this \n```", "```\nopen Person\n\n// using standalone function \nlet printFullName person = \n    printfn \"Name is %s\" (fullName person) \n\n// type inference worked:\n//    val printFullName : Person.T -> unit \n```", "```\nopen Person\n\n// using method with \"dotting into\"\nlet printFullName2 person = \n    printfn \"Name is %s\" (person.FullName) \n```", "```\nopen Person\n\nlet list = [\n    Person.create \"Andy\" \"Anderson\";\n    Person.create \"John\" \"Johnson\"; \n    Person.create \"Jack\" \"Jackson\"]\n\n//get all the full names at once\nlist |> List.map fullName \n```", "```\nopen Person\n\nlet list = [\n    Person.create \"Andy\" \"Anderson\";\n    Person.create \"John\" \"Johnson\"; \n    Person.create \"Jack\" \"Jackson\"]\n\n//get all the full names at once\nlist |> List.map (fun p -> p.FullName) \n```", "```\nEMPTY ONE THREE ADD TWO MUL SHOW \n```", "```\ntype Stack = float list \n```", "```\ntype Stack = StackContents of float list \n```", "```\nlet newStack = StackContents [1.0;2.0;3.0] \n```", "```\nlet (StackContents contents) = newStack \n\n// \"contents\" value set to \n// float list = [1.0; 2.0; 3.0] \n```", "```\nlet push x aStack =   \n    let (StackContents contents) = aStack\n    let newContents = x::contents\n    StackContents newContents \n```", "```\nInput: a Stack plus other parameters\nOutput: a new Stack \n```", "```\nlet push x (StackContents contents) =   \n    StackContents (x::contents) \n```", "```\nval push : float -> Stack -> Stack \n```", "```\nlet emptyStack = StackContents []\nlet stackWith1 = push 1.0 emptyStack \nlet stackWith2 = push 2.0 stackWith1 \n```", "```\nlet ONE stack = push 1.0 stack\nlet TWO stack = push 2.0 stack \n```", "```\nlet ONE = push 1.0\nlet TWO = push 2.0\nlet THREE = push 3.0\nlet FOUR = push 4.0\nlet FIVE = push 5.0 \n```", "```\nlet EMPTY = StackContents [] \n```", "```\nlet stackWith1 = ONE EMPTY \nlet stackWith2 = TWO stackWith1\nlet stackWith3  = THREE stackWith2 \n```", "```\nStack -> Stack \n```", "```\nlet result123 = EMPTY |> ONE |> TWO |> THREE \nlet result312 = EMPTY |> THREE |> ONE |> TWO \n```", "```\n/// Pop a value from the stack and return it \n/// and the new stack as a tuple\nlet pop (StackContents contents) = \n    match contents with \n    | top::rest -> \n        let newStack = StackContents rest\n        (top,newStack) \n```", "```\n/// Pop a value from the stack and return it \n/// and the new stack as a tuple\nlet pop (StackContents contents) = \n    match contents with \n    | top::rest -> \n        let newStack = StackContents rest\n        (top,newStack)\n    | [] -> \n        failwith \"Stack underflow\" \n```", "```\nlet initialStack = EMPTY  |> ONE |> TWO \nlet popped1, poppedStack = pop initialStack\nlet popped2, poppedStack2 = pop poppedStack \n```", "```\nlet _ = pop EMPTY \n```", "```\nlet ADD stack =\n   let x,s = pop stack  //pop the top of the stack\n   let y,s2 = pop s     //pop the result stack\n   let result = x + y   //do the math\n   push result s2       //push back on the doubly-popped stack\n\nlet MUL stack = \n   let x,s = pop stack  //pop the top of the stack\n   let y,s2 = pop s     //pop the result stack\n   let result = x * y   //do the math \n   push result s2       //push back on the doubly-popped stack \n```", "```\nlet add1and2 = EMPTY |> ONE |> TWO |> ADD\nlet add2and3 = EMPTY |> TWO |> THREE |> ADD\nlet mult2and3 = EMPTY |> TWO |> THREE |> MUL \n```", "```\nlet binary mathFn stack = \n    // pop the top of the stack\n    let y,stack' = pop stack    \n    // pop the top of the stack again\n    let x,stack'' = pop stack'  \n    // do the math\n    let z = mathFn x y\n    // push the result value back on the doubly-popped stack\n    push z stack'' \n```", "```\nlet ADD aStack = binary (fun x y -> x + y) aStack \n```", "```\nlet ADD aStack = binary (+) aStack \n```", "```\nlet ADD = binary (+) \n```", "```\nlet SUB = binary (-)\nlet MUL = binary (*)\nlet DIV = binary (../) \n```", "```\nlet div2by3 = EMPTY |> THREE|> TWO |> DIV\nlet sub2from5 = EMPTY  |> TWO |> FIVE |> SUB\nlet add1and2thenSub3 = EMPTY |> ONE |> TWO |> ADD |> THREE |> SUB \n```", "```\nlet unary f stack = \n    let x,stack' = pop stack  //pop the top of the stack\n    push (f x) stack'         //push the function value on the stack \n```", "```\nlet NEG = unary (fun x -> -x)\nlet SQUARE = unary (fun x -> x * x) \n```", "```\nlet neg3 = EMPTY  |> THREE|> NEG\nlet square2 = EMPTY  |> TWO |> SQUARE \n```", "```\nlet SHOW stack = \n    let x,_ = pop stack\n    printfn \"The answer is %f\" x\n    stack  // keep going with same stack \n```", "```\nEMPTY |> ONE |> THREE |> ADD |> TWO |> MUL |> SHOW \n```", "```\n/// Duplicate the top value on the stack\nlet DUP stack = \n    // get the top of the stack\n    let x,_ = pop stack  \n    // push it onto the stack again\n    push x stack \n\n/// Swap the top two values\nlet SWAP stack = \n    let x,s = pop stack  \n    let y,s' = pop s\n    push y (push x s')   \n\n/// Make an obvious starting point\nlet START  = EMPTY \n```", "```\nSTART\n    |> ONE |> TWO |> SHOW\n\nSTART\n    |> ONE |> TWO |> ADD |> SHOW \n    |> THREE |> ADD |> SHOW \n\nSTART\n    |> THREE |> DUP |> DUP |> MUL |> MUL // 27\n\nSTART\n    |> ONE |> TWO |> ADD |> SHOW  // 3\n    |> THREE |> MUL |> SHOW       // 9\n    |> TWO |> SWAP |> DIV |> SHOW // 9 div 2 = 4.5 \n```", "```\nStack -> Stack \n```", "```\n// define a new function\nlet ONE_TWO_ADD = \n    ONE >> TWO >> ADD \n\n// test it\nSTART |> ONE_TWO_ADD |> SHOW\n\n// define a new function\nlet SQUARE = \n    DUP >> MUL \n\n// test it\nSTART |> TWO |> SQUARE |> SHOW\n\n// define a new function\nlet CUBE = \n    DUP >> DUP >> MUL >> MUL \n\n// test it\nSTART |> THREE |> CUBE |> SHOW\n\n// define a new function\nlet SUM_NUMBERS_UPTO = \n    DUP                     // n \n    >> ONE >> ADD           // n+1\n    >> MUL                  // n(n+1)\n    >> TWO >> SWAP >> DIV   // n(n+1) / 2 \n\n// test it\nSTART |> THREE |> SQUARE |> SUM_NUMBERS_UPTO |> SHOW \n```", "```\nlet COMPOSED_SQUARE = DUP >> MUL \n```", "```\nlet PIPED_SQUARE = DUP |> MUL \n```", "```\nlet stackWith2 = EMPTY |> TWO\nlet twoSquared = stackWith2 |> DUP |> MUL \n```", "```\nlet LAMBDA_SQUARE = unary (fun x -> x * x) \n```", "```\n// ==============================================\n// Types\n// ==============================================\n\ntype Stack = StackContents of float list\n\n// ==============================================\n// Stack primitives\n// ==============================================\n\n/// Push a value on the stack\nlet push x (StackContents contents) =   \n    StackContents (x::contents)\n\n/// Pop a value from the stack and return it \n/// and the new stack as a tuple\nlet pop (StackContents contents) = \n    match contents with \n    | top::rest -> \n        let newStack = StackContents rest\n        (top,newStack)\n    | [] -> \n        failwith \"Stack underflow\"\n\n// ==============================================\n// Operator core\n// ==============================================\n\n// pop the top two elements\n// do a binary operation on them\n// push the result \nlet binary mathFn stack = \n    let y,stack' = pop stack    \n    let x,stack'' = pop stack'  \n    let z = mathFn x y\n    push z stack''      \n\n// pop the top element\n// do a unary operation on it\n// push the result \nlet unary f stack = \n    let x,stack' = pop stack  \n    push (f x) stack'         \n\n// ==============================================\n// Other core \n// ==============================================\n\n/// Pop and show the top value on the stack\nlet SHOW stack = \n    let x,_ = pop stack\n    printfn \"The answer is %f\" x\n    stack  // keep going with same stack\n\n/// Duplicate the top value on the stack\nlet DUP stack = \n    let x,s = pop stack  \n    push x (push x s)   \n\n/// Swap the top two values\nlet SWAP stack = \n    let x,s = pop stack  \n    let y,s' = pop s\n    push y (push x s')   \n\n/// Drop the top value on the stack\nlet DROP stack = \n    let _,s = pop stack  //pop the top of the stack\n    s                    //return the rest\n\n// ==============================================\n// Words based on primitives\n// ==============================================\n\n// Constants\n// -------------------------------\nlet EMPTY = StackContents []\nlet START  = EMPTY\n\n// Numbers\n// -------------------------------\nlet ONE = push 1.0\nlet TWO = push 2.0\nlet THREE = push 3.0\nlet FOUR = push 4.0\nlet FIVE = push 5.0\n\n// Math functions\n// -------------------------------\nlet ADD = binary (+)\nlet SUB = binary (-)\nlet MUL = binary (*)\nlet DIV = binary (../)\n\nlet NEG = unary (fun x -> -x)\n\n// ==============================================\n// Words based on composition\n// ==============================================\n\nlet SQUARE =  \n    DUP >> MUL \n\nlet CUBE = \n    DUP >> DUP >> MUL >> MUL \n\nlet SUM_NUMBERS_UPTO = \n    DUP                     // n  \n    >> ONE >> ADD           // n+1\n    >> MUL                  // n(n+1)\n    >> TWO >> SWAP >> DIV   // n(n+1) / 2 \n```"]