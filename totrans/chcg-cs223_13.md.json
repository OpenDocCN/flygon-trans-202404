["```\ntype Color = R | B\ntype Tree  = E | T Color Tree Int Tree\n\ncolor t = case t of {T c _ _ _ -> c; E -> B} \n```", "```\n    bso t = case t of\n      E         -> True\n      T _ l x r -> (l == E || root l < x) &&\n                   (r == E || x < root r) &&\n                   bso l && bso r\n\n    root t = case t of {T _ _ x _ -> x} \n    ```", "```\n    noRedRed t = case t of\n      E                   -> True\n      T R (T R _ _ _) _ _ -> False\n      T R _ _ (T R _ _ _) -> False\n      T _ l _ r           -> List.all noRedRed [l, r] \n    ```", "```\n    okBlack t = case blackHeight t of {Just _ -> True; _ -> False}\n\n    blackHeight t = case t of\n      E -> Just 0\n      T c l _ r ->\n        let i = case c of {B -> 1; R -> 0} in\n        case (blackHeight l, blackHeight r) of\n          (Just n, Just m) -> if\n            | n == m    -> Just (i + n)\n            | otherwise -> Nothing\n          _ -> Nothing \n    ```", "```\n    bh = fromJust << blackHeight\n\n    fromJust mx = case mx of Just x -> x \n    ```", "```\nrb t = bso t && color t == B && noRedRed t && okBlack t \n```", "```\nheight t = case t of\n  E         -> 0\n  T _ l _ r -> 1 + max (height l) (height r)\n\nsize t = case t of\n  E         -> 0\n  T _ l _ r -> 1 + size l + size r \n```", "```\nmember : Int -> Tree -> Bool\nmember x t = case t of\n  E -> False\n  T _ l y r -> if\n    | x == y    -> True\n    | x <  y    -> member x l\n    | otherwise -> member x r \n```", "```\nins : Int -> Tree -> Tree\nins x t =\n  case t of\n    E -> T R E x E\n    T c l y r -> if\n      | x == y    -> t\n      | x <  y    -> balance c (ins x l) y r\n      | otherwise -> balance c l y (ins x r) \n```", "```\nbalance : Color -> Tree -> Int -> Tree -> Tree\nbalance c l val r =\n  case (c, l, val, r) of\n    (B, T R (T R a x b) y c, z, d) -> T R (T B a x b) y (T B c z d)\n    (B, T R a x (T R b y c), z, d) -> T R (T B a x b) y (T B c z d)\n    (B, a, x, T R (T R b y c) z d) -> T R (T B a x b) y (T B c z d)\n    (B, a, x, T R b y (T R c z d)) -> T R (T B a x b) y (T B c z d)\n    _                              -> T c l val r \n```", "```\ninsert : Int -> Tree -> Tree\ninsert x t =\n  let (T _ l y r) = ins x t in\n    T B l y r \n```", "```\n\\x -> e \n```", "```\n\\x ->\n  let _ =\n    if | pArg x    -> ()\n       | otherwise -> Debug.crash \"...\" in\n  let ret = e in\n    if | pRet ret  -> ret\n       | otherwise -> Debug.crash \"...\" \n```", "```\ncheck s p x =\n  if | p x       -> x\n     | otherwise -> Debug.crash (s ++ \"\\n\" ++ toString x)\n\ncheckArg s = check (\"ARG CONTRACT ERROR: \" ++ s)\ncheckRet s = check (\"RET CONTRACT ERROR: \" ++ s) \n```", "```\ninsert' x t_ =\n  let t = checkArg \"[insert']\" rb t_ in\n  let ret =\n    let (T _ l y r) = ins' x t in\n       T B l y r\n  in\n  checkRet \"[insert']\" rb ret \n```", "```\nins' x t_ =\n  let t = checkArg \"[ins']\" rbExceptRoot t_ in\n  let ret =\n    case t of\n      E -> T R E x E\n      T c l y r -> if\n        | x == y    -> t\n        | x <  y    -> balance' c (ins' x l) y r\n        | otherwise -> balance' c l y (ins' x r)\n  in\n  checkRet \"[ins']\" (\\t' -> bh t' == bh t && maybeOneRedRed t') ret\n\nrbExceptRoot t = bso t && noRedRed t && okBlack t\n\nmaybeOneRedRed t = oneRedRed t || noRedRed t\n\noneRedRed t = case t of\n  E                             -> False\n  T R (T R _ _ _) _ (T R _ _ _) -> False\n  T R (T R l1 _ r1) _ r         -> List.all noRedRed [l1, r1, r]\n  T R l _ (T R l2 _ r2)         -> List.all noRedRed [l, l2, r2]\n  T _ l _ r                     -> False \n```", "```\nbalance' c l val r_ =\n  let r = \n    checkArg \"[balance']\" (\ufffdrg ->\n      (bh l == bh arg) &&\n      (xor [  noRedRed l &&  noRedRed arg\n           , oneRedRed l &&  noRedRed arg\n           ,  noRedRed l && oneRedRed arg ])) r_\n  in\n  let ret =\n    case (c, l, val, r) of\n      (B, T R (T R a x b) y c, z, d) -> T R (T B a x b) y (T B c z d)\n      (B, T R a x (T R b y c), z, d) -> T R (T B a x b) y (T B c z d)\n      (B, a, x, T R (T R b y c) z d) -> T R (T B a x b) y (T B c z d)\n      (B, a, x, T R b y (T R c z d)) -> T R (T B a x b) y (T B c z d)\n      _                              -> T c l val r\n  in\n  checkRet \"[balance']\"\n    (\\t' -> maybeOneRedRed t' && bh t' == bh (T c l val r)) ret\n\nxor bs = List.filter (\\b -> b == True) bs == [True] \n```", "```\n> t = buildRandom insert 1000        -- fast\n\n> t' = buildRandom insert' 1000      -- slow\n\n> t == t'\nTrue : Bool \n```", "```\ninsert' : x:Int -> t:Tree{rb t} -> t':Tree{rb t'}\n\nins' : x:Int -> t:Tree{rb t} -> t':Tree{bh t' == bh t && maybeOneRedRed t'}\n\nbalance' : c:Color\n        -> l:Tree\n        -> val:Int\n        -> r:Tree{bh l == bh r && xor [ ... ]}\n        -> t':Tree{bh t' == bh (T c l val r) && maybeOneRedRed t'} \n```", "```\n> buildRandom insert 1000        -- fast\n\n> buildRandom insert 10000\nRangeError: Maximum call stack size exceeded \n```", "```\n> randomInts 1000\n...\n\n> randomInts 10000\nRangeError: Maximum call stack size exceeded \n```"]