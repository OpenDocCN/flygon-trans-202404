- en: Add more features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add more features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've connected to a database using Entity Framework Core, you're
    ready to add some more features to the application. First, you'll make it possible
    to mark a to-do item as complete by checking its checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Add new to-do items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add new to-do items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The user will add new to-do items with a simple form below the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final form](final-form.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Adding this feature requires a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding JavaScript that will send the data to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new action on the controller to handle this request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding code to the service layer to update the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add JavaScript code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Todo/Index.cshtml` view already includes an HTML form that has a textbox
    and a button for adding a new item. You'll use jQuery to send a POST request to
    the server when the Add button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `wwwroot/js/site.js` file and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write the `addItem` function at the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function will send a POST request to `http://localhost:5000/Todo/AddItem`
    with the name the user typed. The third parameter passed to the `$.post` method
    (the function) is a success handler that will run if the server responds with
    `200 OK`. The success handler function uses `window.location` to refresh the page
    (by setting the location to `/Todo`, the same page the browser is currently on).
    If the server responds with `400 Bad Request`, the `fail` handler attached to
    the `$.post` method will try to pull out an error message and display it in a
    the `<div>` with id `add-item-error`.
  prefs: []
  type: TYPE_NORMAL
- en: Add an action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The above JavaScript code won't work yet, because there isn't any action that
    can handle the `/Todo/AddItem` route. If you try it now, ASP.NET Core will return
    a `404 Not Found` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll need to create a new action called `AddItem` on the `TodoController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The method signature defines a `NewTodoItem` parameter, which is a new model
    that doesn''t exist yet. You''ll need to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Models/NewTodoItem.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This model definition (one property called `Title`) matches the data you''re
    sending to the action with jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ASP.NET Core uses a process called **model binding** to match up the parameters
    submitted in the POST request to the model definition you created. If the parameter
    names match (ignoring things like case), the request data will be placed into
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: After binding the request data to the model, ASP.NET Core also performs **model
    validation**. The `[Required]` attribute on the `Title` property informs the validator
    that the `Title` property should not be missing (blank). The validator won't throw
    an error if the model fails validation, but the validation status will be saved
    so you can check it in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sidebar: It would have been possible to reuse the `TodoItem` model instead
    of creating the `NewTodoItem` model, but `TodoItem` contains properties that will
    never be submitted by the user (ID and done). It''s cleaner to declare a new model
    that represents the exact set of properties that are relevant when adding a new
    item.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Back to the `AddItem` action method on the `TodoController`: the first block
    checks whether the model passed the model validation process. It''s customary
    to do this right at the beginning of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the `ModelState` is invalid (because the required property is empty), the
    action will return 400 Bad Request along with the model state, which is automatically
    converted into an error message that tells the user what is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the controller calls into the service layer to do the actual database
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `AddItemAsync` method will return `true` or `false` depending on whether
    the item was successfully added to the database. If it fails for some reason,
    the action will return `400 Bad Request` along with an object that contains an
    `error` property.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if everything completed without errors, the action returns `200 OK`.
  prefs: []
  type: TYPE_NORMAL
- en: Add a service method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're using a code editor that understands C#, you'll see red squiggely
    lines under `AddItemAsync` because the method doesn't exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, you need to add a method to the service layer. First, add it
    to the interface definition in `ITodoItemService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the actual implementation in `TodoItemService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method creates a new `TodoItem` (the model that represents the database
    entity) and copies the `Title` from the `NewTodoItem` model. Then, it adds it
    to the context and uses `SaveChangesAsync` to persist the entity in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sidebar: The above is just one way to build this functionality. If you want
    to display a separate page for adding a new item (for a complicated entity that
    contains a lot of properties, for example), you could create a new view that''s
    bound to the model you need the user to provide values for. ASP.NET Core can render
    a form automatically for the properties of the model using a feature called **tag
    helpers**. You can find examples in the ASP.NET Core documentation at [https://docs.asp.net](https://docs.asp.net).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run the application and add some items to your to-do list with the form. Since
    the items are being stored in the database, they'll still be there even after
    you stop and start the application again.
  prefs: []
  type: TYPE_NORMAL
- en: As a further challenge, try adding a date picker using HTML and JavaScript,
    and let the user choose an (optional) date for the `DueAt` property. Then, use
    that date instead of always making new tasks that are due in 3 days.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Complete items with a checkbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complete items with a checkbox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding items to your to-do list is great, but eventually you''ll need to get
    things done, too. In the `Views/Todo/Index.cshtml` view, a checkbox is rendered
    for each to-do item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The item's ID (a guid) is saved in the `name` attribute of the element. You
    can use this ID to tell your ASP.NET Core code to update that entity in the database
    when the checkbox is checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the whole flow will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: The user checks the box, which triggers a JavaScript function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript is used to make an API call to an action on the controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action calls into the service layer to update the item in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A response is sent back to the JavaScript function to indicate the update was
    successful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTML on the page is updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add JavaScript code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, open `site.js` and add this code to the `$(document).ready` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '**wwwroot/js/site.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `markCompleted` function at the bottom of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code uses jQuery to send an HTTP POST request to `http://localhost:5000/Todo/MarkDone`.
    Included in the request will be one parameter, `id`, containing the item's ID
    (pulled from the `name` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the Network Tools in your web browser and click on a checkbox,
    you''ll see a request like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The success handler function passed to `$.post` uses jQuery to add a class to
    the table row that the checkbox sits in. With the row marked with the `done` class,
    a CSS rule in the page stylesheet will change the way the row looks.
  prefs: []
  type: TYPE_NORMAL
- en: Add an action to the controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you''ve probably guessed, you need to add a `MarkDone` action on the `TodoController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's step through each piece of this action method. First, the method accepts
    a `Guid` parameter called `id` in the method signature. Unlike the `AddItem` action,
    which used a model (the `NewTodoItem` model) and model binding/validation, the
    `id` parameter is very simple. If the incoming request includes a parameter called
    `id`, ASP.NET Core will try to parse it as a guid.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no `ModelState` to check for validity, but you can still check to
    make sure the guid was valid. If for some reason the `id` parameter in the request
    was missing couldn''t be parsed as a guid, it will have a value of `Guid.Empty`.
    If that''s the case, the action can return early:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `BadRequest()` method is a helper method that simply returns the HTTP status
    code `400 Bad Request`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the controller needs to call down into the service to update the database.
    This will be handled by a new method called `MarkDoneAsync` on the `ITodoItemService`,
    which will return true or false depending on if the update succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if everything looks good, the `Ok()` method is used to return status
    code `200 OK`. More complex APIs might return JSON or other data as well, but
    for now returning a status code is all you need.
  prefs: []
  type: TYPE_NORMAL
- en: Add a service method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, add `MarkDoneAsync` to the interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Services/ITodoItemService.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the concrete implementation to the `TodoItemService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`Services/TodoItemService.cs`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This method uses Entity Framework Core and `Where` to find an entity by ID in
    the database. The `SingleOrDefaultAsync` method will return either the item (if
    it exists) or `null` if the ID was bogus. If it didn't exist, the code can return
    early.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re sure that `item` isn''t null, it''s a simple matter of setting
    the `IsDone` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Changing the property only affects the local copy of the item until `SaveChangesAsync`
    is called to persist your changes back to the database. `SaveChangesAsync` returns
    an integer that reflects how many entities were updated during the save operation.
    In this case, it'll either be 1 (the item was updated) or 0 (something went wrong).
  prefs: []
  type: TYPE_NORMAL
- en: Try it out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run the application and try checking some items off the list. Refresh the page
    and they'll disappear completely, because of the `Where` filter in the `GetIncompleteItemsAsync`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the application contains a single, shared to-do list. It'd be even
    more useful if it kept track of individual to-do lists for each user. In the next
    chapter, you'll use ASP.NET Core Identity to add security and authentication features
    to the project.
  prefs: []
  type: TYPE_NORMAL
