- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Elm's major benefits is that **users do not see runtime errors in practice**.
    This is possible because the Elm compiler can analyze your source code very quickly
    to see how values flow through your program. If a value can ever be used in an
    invalid way, the compiler tells you about it with a friendly error message. This
    is called *type inference*. The compiler figures out what *type* of values flow
    in and out of all your functions.
  prefs: []
  type: TYPE_NORMAL
- en: An Example of Type Inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code defines a `toFullName` function which extracts a persons
    full name as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Like in JavaScript or Python, we just write the code with no extra clutter.
    Do you see the bug though?
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, the equivalent code spits out `"undefined Hesse"`. Not even
    an error! Hopefully one of your users will tell you about it when they see it
    in the wild. In contrast, the Elm compiler just looks at the source code and tells
    you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It sees that `toFullName` is getting the wrong *type* of argument. Like the
    hint in the error message says, someone accidentally wrote `fist` instead of `first`.
  prefs: []
  type: TYPE_NORMAL
- en: It is great to have an assistant for simple mistakes like this, but it is even
    more valuable when you have hundreds of files and a bunch of collaborators making
    changes. No matter how big and complex things get, the Elm compiler checks that
    *everything* fits together properly just based on the source code.
  prefs: []
  type: TYPE_NORMAL
- en: The better you understand types, the more the compiler feels like a friendly
    assistant. So let's start learning more!
  prefs: []
  type: TYPE_NORMAL
- en: Reading Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the [Core Language](core_language.html) section of this book, we ran a bunch
    of code in the REPL. Well, we are going to do it again, but now with an emphasis
    on the types that are getting spit out. So type `elm repl` in your terminal again.
    You should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Primitives and Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s enter some simple expressions and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In these three examples, the REPL tells us the resulting value along with what
    *type* of value it happens to be. The value `"hello"` is a `String`. The value
    `3` is an `Int`. Nothing too crazy here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens with lists holding different types of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, we have a `List` filled with `String` values. In the second,
    the `List` is filled with `Float` values. In the third case the list is empty,
    so we do not actually know what kind of values are in the list. So the type `List
    a` is saying "I know I have a list, but it could be filled with anything". The
    lower-case `a` is called a *type variable*, meaning that there are no constraints
    in our program that pin this down to some specific type. In other words, the type
    can vary based on how it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see the type of some functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `String.length` has type `String -> Int`. This means it *must*
    take in a `String` argument, and it will definitely return an integer result.
    So let''s try giving it an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The important thing to understand here is how the type of the result `Int` is
    built up from the initial expression. We have a `String -> Int` function and give
    it a `String` argument. This results in an `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you do not give a `String` though?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A `String -> Int` function *must* get a `String` argument!
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Elm has a feature called *anonymous functions*. Basically, you can create a
    function without naming it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Between the backslash and the arrow, you list the arguments of the function,
    and on the right of the arrow, you say what to do with those arguments. In this
    example, it is saying: I take in some argument I will call `n` and then I am going
    to divide it by two.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use anonymous functions directly. Here is us using our anonymous function
    with `128` as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We start with a `Float -> Float` function and give it a `Float` argument. The
    result is another `Float`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Notes:** The backslash that starts an anonymous function is supposed to look
    like a lambda `Î»` if you squint. This is a possibly ill-conceived wink to the
    intellectual history that led to languages like Elm.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also, when we wrote the expression `(\n -> n / 2) 128`, it is important that
    we put parentheses around the anonymous function. After the arrow, Elm is just
    going to keep reading code as long as it can. The parentheses put bounds on this,
    indicating where the function body ends.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Named Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the same way that we can name a value, we can name an anonymous function.
    So rebellious!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the end, it works just like when nothing was named. You have a `Float ->
    Float` function, you give it a `Float`, and you end up with another `Float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the crazy secret though: this is how all functions are defined! You
    are just giving a name to an anonymous function. So when you see things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can think of it as a convenient shorthand for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is true for all functions, no matter how many arguments they have. So
    now let''s take that a step farther and think about what it means for functions
    with *multiple* arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That seems fine, but why are there *two* arrows in the type for `divide`?! To
    start out, it is fine to think that "all the arguments are separated by arrows,
    and whatever is last is the result of the function". So `divide` takes two arguments
    and returns a `Float`.
  prefs: []
  type: TYPE_NORMAL
- en: To really understand why there are two arrows in the type of `divide`, it helps
    to convert the definition to use anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these are totally equivalent. We just moved the arguments over, turning
    them into anonymous functions one at a time. So when we run an expression like
    `divide 3 2` we are actually doing a bunch of evaluation steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After you expand `divide`, you actually provide the arguments one at a time.
    Replacing `x` and `y` are actually two different steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break that down a bit more to see how the types work. In evaluation
    step #3 we saw the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It is a `Float -> Float` function, just like `half`. Now in step #2 we saw
    a fancier function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Well, we are starting with `\x -> ...` so we know the type is going to be something
    like `Float -> ...`. We also know that `(\y -> x / y)` has type `Float -> Float`.
  prefs: []
  type: TYPE_NORMAL
- en: So if you actually wrote down all the parentheses in the type, it would instead
    say **`Float -> (Float -> Float)`**. You provide arguments one at a time. So when
    you replace `x`, the result is actually *another function*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is the same with all functions in Elm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is really `Int -> (String -> String)` because you are providing the arguments
    one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because all functions in Elm work this way, you do not need to give all the
    arguments at once. It is possible to say things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is called *partial application*. It lets us use [the `|>` operator](http://package.elm-lang.org/packages/elm-lang/core/latest/Basics#|>)
    to chain functions together in a nice way, and it is why function types have so
    many arrows!
  prefs: []
  type: TYPE_NORMAL
- en: Type Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we have just let Elm figure out the types, but it also lets you write
    a *type annotation* on the line above a definition if you want. So when you are
    writing code, you can say things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: People can make mistakes in type annotations, so what happens if they say the
    wrong thing? Well, the compiler does not make mistakes, so it still figures out
    the type on its own. It then checks that your annotation matches the real answer.
    In other words, the compiler will always verify that all the annotations you add
    are correct.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Some folks feel that it is odd that the type annotation goes on the
    line above the actual definition. The reasoning is that it should be easy and
    noninvasive to add a type annotation *later*. This way you can turn a sloppy prototype
    into higher-quality code just by adding lines.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Type Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole point of type aliases is to make your type annotations easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'As your programs get more complicated, you find yourself working with larger
    and more complex data. For example, maybe you are making twitter-for-dogs and
    you need to represent a user. And maybe you want a function that checks to see
    if a user has a bio or not. You might write a function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That type annotation is kind of a mess, and users do not even have that many
    details! Imagine if there were ten fields. Or if you had a function that took
    users as an argument and gave users as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases like this, you should create a *type alias* for your data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is saying, wherever you see `User`, replace it by all this other stuff.
    So now we can rewrite our `hasBio` function in a much nicer way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Looks way better! It is important to emphasize that *these two definitions are
    exactly the same*. We just made an alias so we can say the same thing in fewer
    key strokes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we write a function to add a bio, it would be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Imagine what that type annotation would look like if we did not have the `User`
    type alias. Bad!
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases are not just about cosmetics though. They can help you think more
    clearly. When writing Elm programs, it is often best to *start* with the type
    alias before writing a bunch of functions. I find it helps direct my progress
    in a way that ends up being more efficient overall. Suddenly you know exactly
    what kind of data you are working with. If you need to add stuff to it, the compiler
    will tell you about any existing code that is affected by it. I think most experienced
    Elm folks use a similar process when working with records especially.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** When you create a type alias specifically for a record, it also generates
    a *record constructor*. So our `User` type alias will also generate this function:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The arguments are in the order they appear in the type alias declaration, so
    in the REPL you could do this:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This can be pretty handy!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Union Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Union Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many languages have trouble expressing data with weird shapes. They give you
    a small set of built-in types, and you have to represent everything with them.
    So you often find yourself using `null` or booleans or strings to encode details
    in a way that is quite error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Elm's *union types* let you represent complex data much more naturally. We will
    go through a couple concrete examples to build some intuition about how and when
    to use union types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Union types are sometimes called [tagged unions](https://en.wikipedia.org/wiki/Tagged_union).
    Some communities call them [ADTs](https://en.wikipedia.org/wiki/Algebraic_data_type).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Filtering a Todo List
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem:** We are creating a [todo list](http://evancz.github.io/elm-todomvc/)
    full of tasks. We want to have three views: show *all* tasks, show only *active*
    tasks, and show only *completed* tasks. How do we represent which of these three
    states we are in?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Whenever you have weird shaped data in Elm, you want to reach for a union type.
    In this case, we would create a type `Visibility` that has three possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have these three cases defined, we want to create a function `keep`
    that will properly filter our tasks. It should work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So the `keep` function needs to look at its first argument, and depending on
    what it is, filter the list in various ways. We use a `case` expression to do
    this. It is like an `if` on steroids:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `case` is saying, look at the structure of `visibility`. If it is `All`,
    just give back all the tasks. If it is `Active`, keep only the tasks that are
    not complete. If it is `Completed`, keep only the tasks that are complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cool thing about `case` expressions is that all the branches are checked
    by the compiler. This has some nice benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: If you mistype `Compleet` by accident, you get a hint about the typo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you forget to handle a case, the compiler will figure it out and tell you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So say you want to add `Recent` as a fourth possible `Visibility` value. The
    compiler will find all the `case` expressions in your code that work with `Visibility`
    values and remind you to handle the new possibility! This means you can change
    and extend `Visibility` without the risk of silently creating bugs in existing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Imagine how you would solve this same problem in JavaScript.
    Three strings? A boolean that can be `null`? What would the definition of `keep`
    look like? What sort of tests would you want to write to make sure adding new
    code later was safe.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Anonymous Users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem:** We have a chat room where people can post whatever they want.
    Some users are logged in and some are anonymous. How should we represent a user?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Again, whenever there is weird shaped data, you want to reach for a union type.
    For this case, we want one where users are either anonymous or named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So creating the type `User` also created constructors named `Anonymous` and
    `Named`. If you want to create a `User` you *must* use one of these two constructors.
    This guarantees that all the possible `User` values are things like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a representation of a user, lets say we want to get a photo
    of them to show next to their posts. Again, we need to use a `case` expression
    to work with our `User` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are two possible cases when we have a `User`. If they are `Anonymous`
    we show a dummy picture. If they are `Named` we construct the URL of their photo.
    This `case` is slightly fancier than the one we saw before. Notice that the second
    branch has a lower case variable `name`. This means that when we see a value like
    `Named "AzureDiamond"`, the `name` variable will be bound to `"AzureDiamond"`
    so we can do other things with it. This is called *pattern matching*.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine we have a bunch of users in a chat room and we want to show their
    pictures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The nice thing about creating a type like `User` is that no one in your whole
    codebase can ever "forget" that some users may be anonymous. Anyone who can get
    a hold of a `User` needs to use a `case` to get any information out of it, and
    the compiler guarantees every `case` and handles all possible scenarios!
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** Think about how you would solve this problem in some other language.
    A string where empty string means they are anonymous? A string that can be null?
    How much testing would you want to do to make sure that everyone handles these
    special cases correctly?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Widget Dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem:** You are creating a dashboard with three different kinds of widgets.
    One shows recent log data, one shows time plots, and one shows scatter plots.
    How do you represent a widget?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Alright, we are getting a bit fancier now. In Elm, you want to start by solving
    each case individually. (As you get more experience, you will see that Elm *wants*
    you to build programs out of small, reusable parts. It is weird.) So I would create
    representations for each of our three scenarios, along with `view` functions to
    actually turn them into HTML or SVG or whatever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have created all the helper functions needed to work with
    these three cases totally independent from each other. Someone can come along
    later and say, "I need a nice way to show scatter plots" and use just that part
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the question is really: how do I put these three standalone things together
    for my particular scenario?'
  prefs: []
  type: TYPE_NORMAL
- en: Again, union types are there to put together a bunch of different types!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So we created a `Widget` type that can only be created with these constructor
    functions. You can think of these constructors as *tagging* the data so we can
    tell it apart at runtime. Now we can write something to render a widget like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: One nice thing about this approach is that there is no mystery about what kind
    of widgets are supported. There are exactly three. If someone wants to add a fourth,
    they modify the `Widget` type. This means you can never be surprised by the data
    you get, even if someone on a different team is messing with your code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Takeaways:**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solve each subproblem first.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Use union types to put together all the solutions.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a union type generates a bunch of *constructors*.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: These constuctors *tag* data so that we can differentiate it at runtime.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: A `case` expression lets us tear data apart based on these tags.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The same strategies can be used if you are making a game and have a bunch of
    different bad guys. Goombas should update one way, but Koopa Troopas do something
    totally different. Solve each problem independently, and then use a union type
    to put them all together.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Linked Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem:** You are stuck on a bus speeding down the highway. If the bus slows
    down, it will blow up. The only way to save yourself and everyone on the bus is
    to reimplement linked lists in Elm. HURRY, WE ARE RUNNING OUT OF GAS!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yeah, yeah, the problem is contrived this time, but it is important to see some
    of the more advanced things you can do with union types!
  prefs: []
  type: TYPE_NORMAL
- en: 'A [linked list](https://en.wikipedia.org/wiki/Linked_list) is a sequence of
    values. If you are looking at a linked list, it is either empty or it is a value
    and more list. That list is either empty or is a value and more list. etc. This
    intuitive definition works pretty directly in Elm. Let''s see it for lists of
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we did two new things here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Node` constructor takes *two* arguments instead of one. This is fine. In
    fact, you can have them take as many arguments as you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our union type is *recursive*. An `IntList` may hold another `IntList`. Again,
    this is fine if you are using union types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The nice thing about our `IntList` type is that now we can only build valid
    linked lists. Every linked list needs to start with `Empty` and the only way to
    add a new value is with `Node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is equally nice to work with. Let''s say we want to compute the sum of all
    of the numbers in a list. Just like with any other union type, we need to use
    a `case` and handle all possible scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we get an `Empty` value, the sum is 0\. If we have a `Node` we add the first
    element to the sum of all the remaining ones. So an expression like `(sum (Node
    1 (Node 2 (Node 3 Empty))))` is evaluated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: On each line, we see one evaluation step. When we call `sum` it transforms the
    list based on whether it is looking at a `Node` or an `Empty` value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** This is the first recursive function we have written together! Notice
    that `sum` calls itself to get the sum. It can be tricky to get into the mindset
    of writing recursive functions, so I wanted to share one weird trick. **Pretend
    you are already done.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I always start with a `case` and all of the branches listed but not filled in.
    From there, I solve each branch one at a time, pretending that nothing else exists.
    So with `sum` I'd look at `Empty ->` and say, an empty list has to sum to zero.
    Then I'd look at the `Node n remainingNumbers ->` branch and think, well, I know
    I have a number, a list, and a `sum` function that definitely already exists and
    totally works. I can just use that and add a number to it!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Generic Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem:** The last section showed linked lists that only worked for integers.
    That is pretty lame. How can we make linked lists that hold any kind of value?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Everything is going to be pretty much the same, except we are going to introduce
    a *type variable* in our definition of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The fancy part comes in the `Node` constructor. Instead of pinning the data
    to `Int` and `IntList`, we say that it can hold `a` and `List a`. Basically, you
    can add a value as long as it is the same type of value as everything else in
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: Everything else is the same. You pattern match on lists with `case` and you
    write recursive functions. The only difference is that our lists can hold anything
    now!
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise:** This is exactly how the `List` type in Elm works, so take a look
    at [the `List` library](http://package.elm-lang.org/packages/elm-lang/core/latest/List)
    and see if you can implement some of those functions yourself.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Additional Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen a couple scenarios, but the best way to get more comfortable is
    to use union types more! So here are two examples that are kind of fun.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Binary trees](https://en.wikipedia.org/wiki/Binary_tree) are almost exactly
    the same as linked lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: A tree is either empty or it is a node with a value and two children. Check
    out [this example](http://elm-lang.org/examples/binary-tree) for more info on
    this. If you can do all of the exercises at the end of that link, consider yourself
    a capable user of union types!
  prefs: []
  type: TYPE_NORMAL
- en: Languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can even model a programming language as data if we want to go really crazy!
    In this case, it is one that only deals with [Boolean algebra](https://en.wikipedia.org/wiki/Boolean_algebra#Operations):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Once we have modeled the possible values we can define functions like `eval`
    which evaluates any `Boolean` to `True` or `False`. See [this example](http://elm-lang.org/examples/boolean-expressions)
    for more about representing boolean expressions.
  prefs: []
  type: TYPE_NORMAL
