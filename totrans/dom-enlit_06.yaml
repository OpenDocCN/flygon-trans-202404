- en: Chapter 1 - Node Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1.1 The Document Object Model (aka the DOM) is a hierarchy/tree of JavaScript
    node objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write an HTML document you encapsulate HTML content inside of other
    HTML content. By doing this you setup a hierarchy that can be expressed as a [tree](http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#trees).
    Often this hierarchy or encapsulation system is indicated visually by indenting
    markup in an HTML document. The browser when loading the HTML document interrupts
    and [parses this hierarchy to create a tree of node objects](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Parsing_general)
    that simulates how the markup is encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above HTML code when parsed by a browser creates a document that contains
    nodes structrured in a tree format (i.e. DOM). Below I reveal the tree struture
    from the above HTML document using Opera's Dragonfly DOM inspector.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c1sec1.png)'
  prefs: []
  type: TYPE_IMG
- en: On the left you see the HTML document in its tree form. And on the right you
    see the corresponding JavaScript object that represents the selected element on
    the left. For example, the selected *<body>* element highlighted in blue, is an
    element node and an instance of the *HTMLBodyElement* interface.
  prefs: []
  type: TYPE_NORMAL
- en: What you should take away here is that html documents get parsed by a browser
    and converted into a tree structure of node objects representing a live document.
    The purpose of the DOM is to provide a programatic interface for scripting (removing,
    adding, replacing, eventing, modifiying) this live document using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DOM originally was an application programming interface for XML documents
    that has been extended for use in HTML documents.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Node object types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common (I'm not highlighting all of them in the list below) types of
    nodes (i.e. *nodeType*/node classifications) one encounters when working with
    HTML documents are listed below.
  prefs: []
  type: TYPE_NORMAL
- en: '*DOCUMENT_NODE* (e.g. *window.document*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ELEMENT_NODE* (e.g. *<body>*, *<a>*, *<p>*, *<script>*, *<style>*, *<html>*,
    *<h1>* etc...)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ATTRIBUTE_NODE* (e.g. *class="funEdges"*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TEXT_NODE* (e.g. text characters in an html document including carriage returns
    and white space)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DOCUMENT_FRAGMENT_NODE* (e.g. *document.createDocumentFragment()*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*DOCUMENT_TYPE_NODE* (e.g. *<!DOCTYPE html>*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I've listed the node types above formatted (all uppercase with _ separating
    words) exactly as the constant property is written in the JavaScript browser environment
    as a property of the *Node* object. These *Node* properties are constant values
    and are used to store numeric code values which map to a specific type of node
    object. For example in the following code example, *Node.ELEMENT_NODE* is equal
    to *1*. And *1* is the code value used to identify element nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/BAVrs](http://jsfiddle.net/domenlightenment/BAVrs)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the code below I log all of the node types and there values.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/YcXGD](http://jsfiddle.net/domenlightenment/YcXGD)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example gives an exhaustive list of all node types. For the
    purpose of this book I'll be discussing the shorter list of node types listed
    at the start of this section. These nodes will most likely be the ones you come
    in contact with when scripting an HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: In the table below I list the name given to the interface/constructor that instantiates
    the most common node types and their corresponding *nodeType* classification by
    number and name. What I hope you take away from the table below is the *nodeType*
    value (i.e. *1*) is just a numeric classificaiton used to describe a certain type
    of node constructed from a certain JavaScript interface/constructor. For example,
    the *HTMLBodyElement* interface reprsents a node object that has a node type of
    *1*, which is a classification for *ELEMENT_NODE*'s.
  prefs: []
  type: TYPE_NORMAL
- en: '| [Node](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1950641247)
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| Interface/Constructor: | nodeType (returned from *.nodeType*): |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [HTML*Element](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-58190037),
    (e.g. [HTMLBodyElement](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-62018039))
    | **1** (i.e. *ELEMENT_NODE*) |'
  prefs: []
  type: TYPE_TB
- en: '| [Text](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1312295772)
    | **3** (i.e. *TEXT_NODE*) |'
  prefs: []
  type: TYPE_TB
- en: '| [Attr](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-637646024)
    | **2** (i.e. *ATTRIBUTE_NODE*) |'
  prefs: []
  type: TYPE_TB
- en: '| [HTMLDocument](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-26809268)
    | **9** (i.e. *DOCUMENT_NODE*) |'
  prefs: []
  type: TYPE_TB
- en: '| [DocumentFragment](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-B63ED1A3)
    | **11** (i.e. *DOCUMENT_FRAGMENT_NODE*) |'
  prefs: []
  type: TYPE_TB
- en: '| [DocumentType](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-412266927)
    | **10** (i.e. *DOCUMENT_TYPE_NODE*) |'
  prefs: []
  type: TYPE_TB
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DOM specification semantically labels nodes like *Node*, *Element*, *Text*,
    *Attr*, and *HTMLAnchorElement* as an interface, which it is, but keep in mind
    its also the name given to the JavaScript constructor function that constructs
    the nodes. As you read this book I will be referring to these interfaces (i.e.
    *Element*, *Text*, *Attr*, *HTMLAnchorElement*) as objects or constructor functions
    while the specification refers to them as interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The *ATTRIBUTE_NODE* is not actually part of a tree but listed for historical
    reasons. In this book I do not provide a chapter on attribute nodes and instead
    discuss them in the *Element* node chapter given that attributes nodes are sub-like
    nodes of element nodes with no particiipation in the actual DOM tree structure.
    Be aware the ATTRIBUTE_NODE is being depreciated in DOM 4.
  prefs: []
  type: TYPE_NORMAL
- en: I've not included detail in this book on the *COMMENT_NODE* but you should be
    aware that comments in an HTML document are *Comment* nodes and similar in nature
    to *Text* nodes.
  prefs: []
  type: TYPE_NORMAL
- en: As I discuss nodes throughout the book I will rarely refer to a specific node
    using its *nodeType* name (e.g. *ELEMENT_NODE*). This is done to be consistent
    with verbiage used in the specifications provided by the W3C & WHATWG.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Sub-node objects inherit from the *Node* object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each node object in a typical DOM tree inherits properties and methods from
    *Node*. Depending upon the type of node in the document there are also additional
    sub node object/interfaces that extend the *Node* object. Below I detail the inheritance
    model implemented by browsers for the most common node interfaces (< indicates
    inherited from).
  prefs: []
  type: TYPE_NORMAL
- en: '*Object* < *Node* <  *Element* < *HTMLElement* <  (e.g. *HTML*Element*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object* <*Node* <  *Attr* (This is deprecated in DOM 4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object* <*Node* <  *CharacterData* <  *Text*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object* <*Node* <  *Document* <  *HTMLDocument*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object* <*Node* <  *DocumentFragment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its important not only to remember that all nodes types inherit from *Node*
    but that the chain of inheritance can be long. For example, all *HTMLAnchorElement*
    nodes inherit properties and methods from *HTMLElement*, *Element*, *Node*, and
    *Object* objects.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Node* is just a JavaScript constructor function. And so logically *Node* inherits
    from *Object.prototype* just like all objects in JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: To verify that all node types inherit properties & methods from the *Node* object
    lets loop over an *Element* node object and examine its properties and methods
    (including inherited).
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/6ukxe/](http://jsfiddle.net/domenlightenment/6ukxe)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you run the above code in a web browser you will see a long list of properties
    that are available to the element node object. The properties & methods inherited
    from the *Node* object are in this list as well as a great deal of other inherited
    properties and methods from the *Element*, *HTMLElement*, *HTMLAnchorElement*,
    *Node*, and *Object* object. Its not my point to examine all of these properties
    and methods now but simply to point out that all nodes inherit a set of baseline
    properties and methods from its constructor as well as properties from the prototype
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: If you are more of visual learner consider the inheritance chain denoted from
    examining the above HTML document with Opera's DOM inspector.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c1sec3.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the anchor node inherits from *HTMLAnchorElement*, *HTMLElement*,
    *Element*, *Node*, and *Object* all shown in the list of properties highlighted
    with a gray background. This inheritance chain provides a great deal of shared
    methods and properties to all node types.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can extend the DOM. But its likley not a [good idea to extend host objects](http://perfectionkills.com/whats-wrong-with-extending-the-dom/).
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Properties and methods for working nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like we have been discussing all node objects (e.g *Element*, *Attr*, *Text*
    etc...) inherit properties and methods from a primary *Node* object. These properties
    and methods are the baseline values and functions for manipulating, inspecting,
    and traversing the DOM. In addtion to the properties and methods provided by the
    node interface there are a great deal of other relevant properties and methods
    that are provided by sub node interfaces such as the *document*, *HTMLElement*,
    or *HTML*Element* interface.
  prefs: []
  type: TYPE_NORMAL
- en: Below I list out the most common *Node* properties and methods inherited by
    all node objects including the relevant inherited properties for working with
    nodes from sub-node interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node Properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '*childNodes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*firstChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lastChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nextSibling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nodeName*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nodeType*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nodeValue*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*parentNode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*previousSibling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '*appendChild()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*cloneNode()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*compareDocumentPosition()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*contains()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*hasChildNodes()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*insertBefore()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*isEqualNode()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*removeChild()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*replaceChild()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Document Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '*document.createElement()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*document.createTextNode()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTML * Element Properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '*innerHTML*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*outerHTML*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*textContent*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*innerText*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*outerText*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*firstElementChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lastElementChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nextElementChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*previousElementChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*children*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTML element Methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '*insertAdjacentHTML()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.5 Identifying the type and name of a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every node has a *nodeType* and *nodeName* property that is inherited from *Node*.
    For example *Text* nodes have a *nodeType* code of *3* and *nodeName* value of
    *'#text'*. As previously mentioned the numeric value *3* is a numeric code representing
    the type of underlying object the node represents (i.e. *Node.TEXT_NODE === 3*).
  prefs: []
  type: TYPE_NORMAL
- en: Below I detail the values returned for *nodeType* and *nodeName* for the node
    objects discussed in this book. It makes sense to simply memorize these numeric
    code's for the more common nodes given that we are only dealing with 5 numeric
    codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/8EwNu](http://jsfiddle.net/domenlightenment/8EwNu)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '***If its not obvious the fastest way to determine if a node is of a certain
    type is too simply check its *nodeType* property. Below we check to see if the
    anchor element has a node number of 1\. If it does than we can conclude that its
    an *Element* node because *Node.ELEMENT_NODE === 1*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/ydzWL](http://jsfiddle.net/domenlightenment/ydzWL)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Determining the type of node that you might be scripting becomes very handy
    so that you might know which properties and methods are available to script the
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The values returned by the *nodeName* property vary according to the node type.
    Have a look at the [DOM 4 specification](http://www.w3.org/TR/dom/#dom-node-nodename)
    provided for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 Getting a nodes value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *nodeValue* property returns *null* for most of the node types (except *Text*,
    and *Comment*). It's use is centered around extracting actual text strings from
    *Text* and *Comment* nodes. In the code below I demonstrate its use on all the
    nodes discussed in this book
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/LNyA4](http://jsfiddle.net/domenlightenment/LNyA4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**### Notes'
  prefs: []
  type: TYPE_NORMAL
- en: '*Text* or *Comment* node values can be set by providing new strings values
    for the *nodeValue* property(i.e. *document.body.firstElementChild.nodeValue =
    ''hi''*).'
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Creating element and text nodes using JavaScript methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a browser parses an HTML document it constructs the nodes and tree based
    on the contents of the HTML file. The browser deals with the creation of nodes
    for the intial loading of the HTML document. However its possible to create your
    own nodes using JavaScript. The following two methods allow us to programatically
    create *Element* and *Text* nodes using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '*createElement()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*createTextNode()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other methods are avaliable but are not commonly used (e.g. *createAttribute()*
    and *createComment()*) . In the code below I show how simple it is to create element
    and text nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/Vj2Tc](http://jsfiddle.net/domenlightenment/Vj2Tc)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *createElement()* method accepts one parameter which is a string specifying
    the element to be created. The string is the same string that is returned from
    the *tagName* property of an *Element* object.
  prefs: []
  type: TYPE_NORMAL
- en: The *createAttribute()* method is depricated and should not be used for creating
    attribute nodes. Instead developers typically use *getAttribute()*, *setAttribute()*,
    and *removeAttribute()* methods. I will discus this in more detail in the *Element*
    node chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The *createDocumentFragment()* will be discussed in the chapter covering this
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You should be aware that a *createComment()* method is available for creating
    comment nodes. Its not discussed in this book but is very much available to a
    developer who finds its usage valuable.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 Creating and adding element and text nodes to the DOM using JavaScript strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *innerHTML*, *outerHTML*, *textContent* and *insertAdjacentHTML()* properties
    and methods provide the functionality to create and add nodes to the DOM using
    JavaScript strings.
  prefs: []
  type: TYPE_NORMAL
- en: In the code below we are using the *innerHTML*, *outerHTML*, and *textContent*
    properties to create nodes from JavaScript strings that are then immediately added
    to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/UrNT3](http://jsfiddle.net/domenlightenment/UrNT3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The *insertAdjacentHTML()* method which only works on *Element* nodes is a good
    deal more precise than the previously mentioned methods*. Using this method its
    possible to insert nodes before the beginning tag, after the beginning tag, before
    the end tag, and after the end tag. Below I construct a sentence using the *insertAdjacentHTML()*
    method.*
  prefs: []
  type: TYPE_NORMAL
- en: '*live code: [http://jsfiddle.net/domenlightenment/tvpA6](http://jsfiddle.net/domenlightenment/tvpA6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *innerHTML* property will convert html elements found in the string to actual
    DOM nodes while the *textContent* can only be used to construct text nodes. If
    you pass *textContent* a string containing html elements it will simply spit it
    out as text.
  prefs: []
  type: TYPE_NORMAL
- en: '*document.write()* can also be used to simultaneously create and add nodes
    to the DOM. However its typically not used anymore unless its usage is required
    to accomplish 3rd party scripting tasks. Basically the *write()* method will output
    the values passed to it into the page during page loading/parsing. You should
    be aware that using the *write()* method will stall/block the parsing of the html
    document being loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: '*innerHTML* invokes a heavy & expensive HTML parser where as text node generation
    is trivial thus use the innerHTML & friends sparingly'
  prefs: []
  type: TYPE_NORMAL
- en: The *insertAdjacentHTML* options "beforebegin" and "afterend" will only work
    if the node is in the DOM tree and has a parent element.
  prefs: []
  type: TYPE_NORMAL
- en: Support for *outerHTML* was not available natively in Firefox until version
    11\. A [polyfill](https://gist.github.com/1044128) is avaliable.
  prefs: []
  type: TYPE_NORMAL
- en: '*textContent* gets the content of all elements, including *<script>* and *<style>* elements, *innerText*
    does not'
  prefs: []
  type: TYPE_NORMAL
- en: '*innerText* is aware of style and will not return the text of hidden elements,
    whereas *textContent* will'
  prefs: []
  type: TYPE_NORMAL
- en: Avaliable to all modern browser except Firefox is *insertAdjacentElement()*
    and *insertAdjacentText()*
  prefs: []
  type: TYPE_NORMAL
- en: 1.9 Extracting parts of the DOM tree as JavaScript strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same exact properties (*innerHTML*, *outerHTML*, *textContent*) that we
    use to create and add nodes to the DOM can also be used to extract parts of the
    DOM (or really the entire DOM) as a JavaScript string. In the code example below
    I use these properties to return a string value containing text and html values
    from the HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/mMYWc](http://jsfiddle.net/domenlightenment/mMYWc)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *textContent*, *innerText*, *outerText* property when being read will return
    all of the text nodes contained within the selected node. So for example (not
    a good idea in practice), *document.body.textContent* will get all the text nodes
    contained in the body element not just the first text node.
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 Adding node objects to the DOM using *appendChild()*& *insertBefore()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *appendChild()* and *insertBefore()* *Node* methods allow us to insert JavaScript
    node objects into the DOM tree. The *appendChild()* method will append a node(s)
    to the end of the child node(s) of the node the method is called on. If there
    are no child node(s) then the node being appended is appended as the first child. 
    For example in the code below we are creating a element node (*<strong>*) and
    text node (*Dude*). Then the *<p>* is selected from the DOM and our *<strong>*
    element is appended using *appendChild()*. Notice that the *<strong>* element
    is encapsulated inside of the *<p>* element and added as the last child node.
    Next the *<strong>* element is selected and the text *'Dude'* is appended to the
    *<strong>* element.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/HxjFt](http://jsfiddle.net/domenlightenment/HxjFt)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When it becomes necessary to control the location of insertion beyond appending
    nodes to the end of a child list of nodes we can use *insertBefore()*. In the
    code below I am inserting the *<li>* element before the first child node of the
    *<ul>* element.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/UmkME](http://jsfiddle.net/domenlightenment/UmkME)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The *insertBefore()* requires two parameters, the node to be inserted and the
    reference node in the document you would like the node inserted before.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you do not pass the *insertBefore()* method a second parameter then it functions
    just like *appendChild()*.
  prefs: []
  type: TYPE_NORMAL
- en: We have [more methods](http://www.w3.org/TR/dom/#mutation-methods) (e.g. *prepend()*,
    *append()*, *before()*, *after()*) to look forward too in DOM 4.
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 Removing and replacing nodes using *removeChild()* and *replaceChild()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Removing a node from the DOM is a bit of a multi-step process. First you have
    to select the node you want to remove. Then you need to gain access to its parent
    element typically using the *parentNode* property. Its on the parent node that
    you invoke the *removeChild()* method passing it the reference to the node to
    be removed. Below I demonstrate its use on an element node and text node.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/VDZgP](http://jsfiddle.net/domenlightenment/VDZgP)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Replacing an element or text node is not unlike removing one. In the code below
    I use the same html structure used in the previous code example except this time
    I use *replaceChild()* to update the nodes instead of removing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/zgE8M](http://jsfiddle.net/domenlightenment/zgE8M)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending upon what you are removing or replacing simply providing the *innerHTML*,
    *outerHTML*, and *textContent* properties with an empty string might be easier
    and faster. [Careful memory leaks in brwoser might get you however](http://javascript.crockford.com/memory/leak.html).
  prefs: []
  type: TYPE_NORMAL
- en: Both *replaceChild()* and *removeChild()* return the replaced or remove node.
    Basically its not gone just because you replace it or remove. All this does is
    takes it out of the current live document. You still have a reference to it in
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: We have [more methods](http://www.w3.org/TR/dom/#mutation-methods) (e.g.*replace()*,
    *remove()*) to look forward too in DOM 4.
  prefs: []
  type: TYPE_NORMAL
- en: 1.12 Cloning nodes using *cloneNode()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the *cloneNode()* method its possible to duplicate a single node or a
    node and all its children nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In the code below I clone only the *<ul>* (i.e. *HTMLUListElement)* which once
    cloned can be treated like any node reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/6DHgC](http://jsfiddle.net/domenlightenment/6DHgC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To clone a node and all of its children nodes you pass the *cloneNode()* method
    a parameter of of *true*. Below I use the *cloneNode()* method again but this
    time we clone all of the child nodes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/EyFEC](http://jsfiddle.net/domenlightenment/EyFEC)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When cloning an *Element* node all attributes and values are also cloned. In
    fact, only attributes are copied! Everything else you can add (e.g. event handlers)
    to a DOM node is lost when cloning.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that cloning a node and its children using *cloneNode(true)*
    would return a *NodeList* but it in fact does not.
  prefs: []
  type: TYPE_NORMAL
- en: '*cloneNode()* may lead to duplicate element IDs in a document'
  prefs: []
  type: TYPE_NORMAL
- en: 1.13 Grokking node collections (i.e. *Nodelist* & *HTMLcollection*)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When selecting groups of nodes from a tree (cover in chaper 3) or accessing
    pre-defined sets of nodes, the nodes are either placed in a [*NodeList*](http://www.w3.org/TR/dom/#nodelist)
    (e.g. *document.querySelectorAll('*')*) or [*HTMLCollection*](http://www.w3.org/TR/dom/#htmlcollection)
    (e.g. *document.scripts*). These array like (i.e. not a real *Array*) object collections
    that have the following characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: A collection can either be live or static. Meaning that the nodes contained
    in the collection are either literally part of the live document or a snapshot
    of the live document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default nodes are sorted inside of the collection by tree order. Meaning
    the order matches the liner path from tree trunk to branches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collections have a *length* property that reflects the number of elements
    in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.14 Gettting a list/collection of all immediate child nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the *childNodes* property produces an array like list (i.e. [NodeList](https://developer.mozilla.org/En/DOM/NodeList))
    of the immediate child nodes. Below I select the *<ul>* element which I then use
    to create a list of all of the immediate child nodes contained inside of the *<ul>*.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/amDev](http://jsfiddle.net/domenlightenment/amDev)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *NodeList* returned by *childNodes* only contains immediate child nodes
  prefs: []
  type: TYPE_NORMAL
- en: Be aware *childNodes* contains not only *Element* nodes but also all other node
    types (e.g. *Text* and *Comment* nodes)
  prefs: []
  type: TYPE_NORMAL
- en: '*[].forEach* was implemented in ECMAScript 5th edtion'
  prefs: []
  type: TYPE_NORMAL
- en: 1.15 Convert a *NodeList* or *HTMLCollection* to JavaScript *Array*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node lists and html collections are array like but not a true JavaScript array
    which inherits array methods. In the code below we programtically confirm this
    using *isArray()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/n53Xk](http://jsfiddle.net/domenlightenment/n53Xk)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Array.isArray* was implemented in ECMAScript 5th edtion or ES5'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a node list and html collection list to a true JavaScript array can
    provide a good deal of advantages. For one it gives us the ability to create a
    snapshot of the list that is not tied to the live DOM considering that *NodeList*
    and *HTMLCollection* are [live](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#td-live)
    lists. Secondly, converting a list to a JavaScript array gives access to the methods
    provided by the *Array* object (e.g. *forEach*, *pop*, *map*, *reduce* etc...).
  prefs: []
  type: TYPE_NORMAL
- en: To convert an array like list to a true JavaScript array pass the array-like
    list to *call()* or *apply()*, in which the *call()* or *apply()* is calling a
    method that returns an un-altered true JavaScript array. In the code below I use
    the *.slice()* method, which doesn't really slice anything I am just using it
    to convert the list to a JavaScript *Array* due to the fact the *slice()* returns
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/jHgTY](http://jsfiddle.net/domenlightenment/jHgTY)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In ECMAScript 6th edtion we have *Array.from* to look forward to which converts
    a single argument that is an array-like object or list (eg. *arguments*, *NodeList*,
    *DOMTokenList* (used by *classList*), *NamedNodeMap* (used by *attributes* property))
    into a *new Array()* and returns it
  prefs: []
  type: TYPE_NORMAL
- en: 1.16 Traversing nodes in the DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From a node reference (i.e. *document.querySelector(''ul'')*) its possible
    to get a different node reference by traversing the DOM using the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '*parentNode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*firstChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lastChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nextSibling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*previousSibling*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the code example below we examine the *Node* properties providing DOM traversal
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/Hvfhv](http://jsfiddle.net/domenlightenment/Hvfhv)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*If you have been around the DOM much then it should be no surprise that traversing
    the DOM includes not just traversing element nodes but also text and comment nodes.
    I believe the last code example makes this clear, and this is not exactly ideal.
    Using the following properties we can traverse the DOM ignoring text and comment
    nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*firstElementChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lastElementChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*nextElementChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*previousElementChild*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*children*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *childElementCount* is not mentioned but you should be aware of its avaliablity
    for calculating the number of child elements a node contains.
  prefs: []
  type: TYPE_NORMAL
- en: Examine our code example again using only element traversing methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/Wh7nf](http://jsfiddle.net/domenlightenment/Wh7nf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*## 1.17 Verify a node position in the DOM tree with *contains()* & *compareDocumentPosition()*'
  prefs: []
  type: TYPE_NORMAL
- en: Its possible to know if a node is contained inside of another node by using
    the *contains()* *Node* method. In the code below I ask if *<body>* is contained
    inside of *<html lang="en">*.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/ENU4w](http://jsfiddle.net/domenlightenment/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you need more robust information about the position of a node in the DOM
    tree in regards to the nodes around it you can use the *compareDocumentPosition()*
    *Node* method. Basically this method gives you the ability to request information
    about a selected node relative to the node passed in. The information that you
    get back is a number that corresponds to the following information.
  prefs: []
  type: TYPE_NORMAL
- en: '| number code returned from *compareDocumentPosition()*: | number code info:
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Elements are identical. |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | DOCUMENT_POSITION_DISCONNECTED Set when selected node and passed in node
    are not in the same document. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | DOCUMENT_POSITION_PRECEDING Set when passed in node is preceding selected
    node. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | DOCUMENT_POSITION_FOLLOWING Set when passed in node is following selected
    node. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | DOCUMENT_POSITION_CONTAINS Set when passed in node is an ancestor of
    selected node. |'
  prefs: []
  type: TYPE_TB
- en: '| 16, 10 | DOCUMENT_POSITION_CONTAINED_BY (16, 10 in hexadecimal) Set when
    passed in node is a descendant of selected node. |'
  prefs: []
  type: TYPE_TB
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*contains()* will return *true* if the node selected and node passed in are
    identical.'
  prefs: []
  type: TYPE_NORMAL
- en: '*compareDocumentPosition()* can be rather confusing because its possible for
    a node to have more than one type of relationship with another node. For example
    when a node both contains (16) and precedes (4) the returned value from *compareDocumentPosition()*
    will be 20.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.18 How to determine if two nodes are identical
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[According to the DOM 3 specification](http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode)
    two nodes are equal if and only if the following conditions are satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: The two nodes are of the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following string attributes are equal: *nodeName*, *localName*, *namespaceURI*, *prefix*, *nodeValue*.
    That is: they are both null, or they have the same length and are character for
    character identical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *attributes* *NamedNodeMaps* are equal. That is: they are both *null*,
    or they have the same length and for each node that exists in one map there is
    a node that exists in the other map and is equal, although not necessarily at
    the same index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *childNodes* *NodeLists* are equal. That is: they are both *null*, or they
    have the same length and contain equal nodes at the same index. Note that normalization
    can affect equality; to avoid this, nodes should be normalized before being compared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the *.isEqualNode()* method on a node in the DOM will ask if that node
    is equal to the node that you pass it as a parameter. Below I exhibt a case of
    an two equal nodes and two non-identical nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/xw68Q](http://jsfiddle.net/domenlightenment/xw68Q)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't care about two nodes being exactly equal but instead want to know
    if two node references refer to the same node you can simply check it using the
    *===* opertor (i.e. *document.body === document.body*). This will tell us if they
    are identical but no equal.********
  prefs: []
  type: TYPE_NORMAL
