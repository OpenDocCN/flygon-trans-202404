- en: Chapter 1 - Node Overview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章 - 节点概述
- en: 1.1 The Document Object Model (aka the DOM) is a hierarchy/tree of JavaScript
    node objects
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 文档对象模型（即 DOM）是 JavaScript 节点对象的层次结构/树
- en: When you write an HTML document you encapsulate HTML content inside of other
    HTML content. By doing this you setup a hierarchy that can be expressed as a [tree](http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#trees).
    Often this hierarchy or encapsulation system is indicated visually by indenting
    markup in an HTML document. The browser when loading the HTML document interrupts
    and [parses this hierarchy to create a tree of node objects](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Parsing_general)
    that simulates how the markup is encapsulated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 HTML 文档时，你将 HTML 内容封装在其他 HTML 内容中。通过这样做，你建立了一个可以表示为[树](http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#trees)的层次结构。通常，这种层次结构或封装系统在
    HTML 文档中通过缩进标记来直观表示。浏览器在加载 HTML 文档时会解析这个层次结构，创建一个模拟标记封装方式的节点对象树。
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above HTML code when parsed by a browser creates a document that contains
    nodes structrured in a tree format (i.e. DOM). Below I reveal the tree struture
    from the above HTML document using Opera's Dragonfly DOM inspector.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 HTML 代码在被浏览器解析时创建了一个包含以树形式结构化的节点的文档（即 DOM）。下面我使用 Opera 的 Dragonfly DOM 检查器展示了上述
    HTML 文档的树结构。
- en: '![](../Images/c1sec1.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c1sec1.png)'
- en: On the left you see the HTML document in its tree form. And on the right you
    see the corresponding JavaScript object that represents the selected element on
    the left. For example, the selected *<body>* element highlighted in blue, is an
    element node and an instance of the *HTMLBodyElement* interface.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧你可以看到 HTML 文档的树形式。右侧是表示左侧选定元素的相应 JavaScript 对象。例如，被突出显示为蓝色的选定*<body>*元素是一个元素节点，是*HTMLBodyElement*接口的一个实例。
- en: What you should take away here is that html documents get parsed by a browser
    and converted into a tree structure of node objects representing a live document.
    The purpose of the DOM is to provide a programatic interface for scripting (removing,
    adding, replacing, eventing, modifiying) this live document using JavaScript.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你应该明白的是，HTML 文档会被浏览器解析，并转换为表示实时文档的节点对象树结构。DOM 的目的是提供一个用 JavaScript 脚本编程的接口，以操作（移除、添加、替换、事件、修改）这个实时文档。
- en: Notes
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The DOM originally was an application programming interface for XML documents
    that has been extended for use in HTML documents.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 最初是用于 XML 文档的应用程序编程接口，已经扩展用于 HTML 文档。
- en: 1.2 Node object types
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 节点对象类型
- en: The most common (I'm not highlighting all of them in the list below) types of
    nodes (i.e. *nodeType*/node classifications) one encounters when working with
    HTML documents are listed below.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 HTML 文档时，遇到的最常见的节点类型（即*nodeType* / 节点分类）如下所示。
- en: '*DOCUMENT_NODE* (e.g. *window.document*)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DOCUMENT_NODE*（例如*window.document*）'
- en: '*ELEMENT_NODE* (e.g. *<body>*, *<a>*, *<p>*, *<script>*, *<style>*, *<html>*,
    *<h1>* etc...)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ELEMENT_NODE*（例如*<body>*，*<a>*，*<p>*，*<script>*，*<style>*，*<html>*，*<h1>*等...）'
- en: '*ATTRIBUTE_NODE* (e.g. *class="funEdges"*)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ATTRIBUTE_NODE*（例如*class="funEdges"*）'
- en: '*TEXT_NODE* (e.g. text characters in an html document including carriage returns
    and white space)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TEXT_NODE*（例如 HTML 文档中的文本字符，包括换行符和空格）'
- en: '*DOCUMENT_FRAGMENT_NODE* (e.g. *document.createDocumentFragment()*)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DOCUMENT_FRAGMENT_NODE*（例如*document.createDocumentFragment()*）'
- en: '*DOCUMENT_TYPE_NODE* (e.g. *<!DOCTYPE html>*)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DOCUMENT_TYPE_NODE*（例如*<!DOCTYPE html>*）'
- en: I've listed the node types above formatted (all uppercase with _ separating
    words) exactly as the constant property is written in the JavaScript browser environment
    as a property of the *Node* object. These *Node* properties are constant values
    and are used to store numeric code values which map to a specific type of node
    object. For example in the following code example, *Node.ELEMENT_NODE* is equal
    to *1*. And *1* is the code value used to identify element nodes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经列出了上面的节点类型，格式化为全大写，单词之间用下划线分隔，与 JavaScript 浏览器环境中的*Node*对象的常量属性写法完全一致。这些*Node*属性是常量值，用于存储映射到特定节点对象类型的数值代码值。例如，在下面的代码示例中，*Node.ELEMENT_NODE*
    等于*1*。而*1*是用于标识元素节点的代码值。
- en: 'live code: [http://jsfiddle.net/domenlightenment/BAVrs](http://jsfiddle.net/domenlightenment/BAVrs)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/BAVrs](http://jsfiddle.net/domenlightenment/BAVrs)
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the code below I log all of the node types and there values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我记录了所有节点类型及其值。
- en: 'live code: [http://jsfiddle.net/domenlightenment/YcXGD](http://jsfiddle.net/domenlightenment/YcXGD)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/YcXGD](http://jsfiddle.net/domenlightenment/YcXGD)
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous code example gives an exhaustive list of all node types. For the
    purpose of this book I'll be discussing the shorter list of node types listed
    at the start of this section. These nodes will most likely be the ones you come
    in contact with when scripting an HTML page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例给出了所有节点类型的详尽列表。为了本书的目的，我将讨论本节开头列出的节点类型较短的列表。当编写 HTML 页面脚本时，您可能会接触到这些节点。
- en: In the table below I list the name given to the interface/constructor that instantiates
    the most common node types and their corresponding *nodeType* classification by
    number and name. What I hope you take away from the table below is the *nodeType*
    value (i.e. *1*) is just a numeric classificaiton used to describe a certain type
    of node constructed from a certain JavaScript interface/constructor. For example,
    the *HTMLBodyElement* interface reprsents a node object that has a node type of
    *1*, which is a classification for *ELEMENT_NODE*'s.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了实例化最常见节点类型及其对应的 *nodeType* 分类的接口/构造函数的名称。我希望你从下表中了解到的是 *nodeType* 值（即 *1*）只是一个用于描述从某个特定
    JavaScript 接口/构造函数构造的某种类型节点的数值分类。例如，*HTMLBodyElement* 接口代表一个具有 *1* 类型的节点对象，该类型是
    *ELEMENT_NODE* 的分类。
- en: '| [Node](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1950641247)
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| [Node](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1950641247)
    |'
- en: '| --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Interface/Constructor: | nodeType (returned from *.nodeType*): |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 接口/构造函数： | nodeType（从 *.nodeType* 返回）： |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [HTML*Element](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-58190037),
    (e.g. [HTMLBodyElement](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-62018039))
    | **1** (i.e. *ELEMENT_NODE*) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| [HTML*元素](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-58190037)，（例如
    [HTMLBodyElement](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-62018039)）
    | **1**（即 *ELEMENT_NODE*） |'
- en: '| [Text](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1312295772)
    | **3** (i.e. *TEXT_NODE*) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| [文本](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1312295772)
    | **3**（即 *TEXT_NODE*） |'
- en: '| [Attr](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-637646024)
    | **2** (i.e. *ATTRIBUTE_NODE*) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| [Attr](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-637646024)
    | **2**（即 *ATTRIBUTE_NODE*） |'
- en: '| [HTMLDocument](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-26809268)
    | **9** (i.e. *DOCUMENT_NODE*) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| [HTMLDocument](http://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/html.html#ID-26809268)
    | **9**（即 *DOCUMENT_NODE*） |'
- en: '| [DocumentFragment](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-B63ED1A3)
    | **11** (i.e. *DOCUMENT_FRAGMENT_NODE*) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| [DocumentFragment](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-B63ED1A3)
    | **11**（即 *DOCUMENT_FRAGMENT_NODE*） |'
- en: '| [DocumentType](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-412266927)
    | **10** (i.e. *DOCUMENT_TYPE_NODE*) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| [DocumentType](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-412266927)
    | **10**（即 *DOCUMENT_TYPE_NODE*） |'
- en: Notes
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The DOM specification semantically labels nodes like *Node*, *Element*, *Text*,
    *Attr*, and *HTMLAnchorElement* as an interface, which it is, but keep in mind
    its also the name given to the JavaScript constructor function that constructs
    the nodes. As you read this book I will be referring to these interfaces (i.e.
    *Element*, *Text*, *Attr*, *HTMLAnchorElement*) as objects or constructor functions
    while the specification refers to them as interfaces.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 规范在语义上将节点标记为 *Node*、*Element*、*Text*、*Attr* 和 *HTMLAnchorElement*，它们是接口，但请记住，它们也是用于构造节点的
    JavaScript 构造函数的名称。当你阅读本书时，我将把这些接口（即 *Element*、*Text*、*Attr*、*HTMLAnchorElement*）称为对象或构造函数，而规范则将它们称为接口。
- en: The *ATTRIBUTE_NODE* is not actually part of a tree but listed for historical
    reasons. In this book I do not provide a chapter on attribute nodes and instead
    discuss them in the *Element* node chapter given that attributes nodes are sub-like
    nodes of element nodes with no particiipation in the actual DOM tree structure.
    Be aware the ATTRIBUTE_NODE is being depreciated in DOM 4.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*ATTRIBUTE_NODE* 实际上不是树的一部分，但出于历史原因列出。在本书中，我没有提供有关属性节点的章节，而是在 *Element* 节点章节中讨论它们，因为属性节点是元素节点的子节点，不参与实际的
    DOM 树结构。请注意，ATTRIBUTE_NODE 在 DOM 4 中已被弃用。'
- en: I've not included detail in this book on the *COMMENT_NODE* but you should be
    aware that comments in an HTML document are *Comment* nodes and similar in nature
    to *Text* nodes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书中没有详细介绍*COMMENT_NODE*，但你应该知道HTML文档中的注释是*Comment*节点，类似于*Text*节点。
- en: As I discuss nodes throughout the book I will rarely refer to a specific node
    using its *nodeType* name (e.g. *ELEMENT_NODE*). This is done to be consistent
    with verbiage used in the specifications provided by the W3C & WHATWG.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中讨论节点时，我很少使用*nodeType*名称（例如*ELEMENT_NODE*）来引用特定节点。这是为了与W3C和WHATWG提供的规范中使用的措辞保持一致。
- en: 1.3 Sub-node objects inherit from the *Node* object
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 子节点对象从*Node*对象继承
- en: Each node object in a typical DOM tree inherits properties and methods from
    *Node*. Depending upon the type of node in the document there are also additional
    sub node object/interfaces that extend the *Node* object. Below I detail the inheritance
    model implemented by browsers for the most common node interfaces (< indicates
    inherited from).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 典型DOM树中的每个节点对象都从*Node*继承属性和方法。根据文档中节点的类型，还有其他扩展*Node*对象的子节点对象/接口。下面我详细描述了浏览器为最常见的节点接口实现的继承模型（<表示继承自）。
- en: '*Object* < *Node* <  *Element* < *HTMLElement* <  (e.g. *HTML*Element*)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Object* < *Node* <  *Element* < *HTMLElement* < （例如*HTMLElement*）'
- en: '*Object* <*Node* <  *Attr* (This is deprecated in DOM 4)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Object* <*Node* <  *Attr*（在DOM 4��已弃用）'
- en: '*Object* <*Node* <  *CharacterData* <  *Text*'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Object* <*Node* <  *CharacterData* <  *Text*'
- en: '*Object* <*Node* <  *Document* <  *HTMLDocument*'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Object* <*Node* <  *Document* <  *HTMLDocument*'
- en: '*Object* <*Node* <  *DocumentFragment*'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Object* <*Node* <  *DocumentFragment*'
- en: Its important not only to remember that all nodes types inherit from *Node*
    but that the chain of inheritance can be long. For example, all *HTMLAnchorElement*
    nodes inherit properties and methods from *HTMLElement*, *Element*, *Node*, and
    *Object* objects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅要记住所有节点类型都继承自*Node*，而且继承链可能会很长。例如，所有*HTMLAnchorElement*节点都继承自*HTMLElement*、*Element*、*Node*和*Object*对象的属性和方法。
- en: Notes
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Node* is just a JavaScript constructor function. And so logically *Node* inherits
    from *Object.prototype* just like all objects in JavaScript'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*Node*只是一个JavaScript构造函数。因此，逻辑上*Node*像JavaScript中的所有对象一样继承自*Object.prototype*。'
- en: To verify that all node types inherit properties & methods from the *Node* object
    lets loop over an *Element* node object and examine its properties and methods
    (including inherited).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证所有节点类型都从*Node*对象继承属性和方法，让我们循环遍历一个*Element*节点对象并检查其属性和方法（包括继承的）。
- en: 'live code: [http://jsfiddle.net/domenlightenment/6ukxe/](http://jsfiddle.net/domenlightenment/6ukxe)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/6ukxe/](http://jsfiddle.net/domenlightenment/6ukxe)
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you run the above code in a web browser you will see a long list of properties
    that are available to the element node object. The properties & methods inherited
    from the *Node* object are in this list as well as a great deal of other inherited
    properties and methods from the *Element*, *HTMLElement*, *HTMLAnchorElement*,
    *Node*, and *Object* object. Its not my point to examine all of these properties
    and methods now but simply to point out that all nodes inherit a set of baseline
    properties and methods from its constructor as well as properties from the prototype
    chain.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Web浏览器中运行上述代码，你将看到一个长长的属性列表，这些属性可用于元素节点对象。从*Node*对象继承的属性和方法在此列表中，以及从*Element*、*HTMLElement*、*HTMLAnchorElement*、*Node*和*Object*对象继承的许多其他属性和方法。现在不是检查所有这些属性和方法的时候，而只是简单指出所有节点从其构造函数继承一组基线属性和方法，以及从原型链继承的属性。
- en: If you are more of visual learner consider the inheritance chain denoted from
    examining the above HTML document with Opera's DOM inspector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢视觉学习者，可以考虑通过使用Opera的DOM检查器检查上述HTML文档来表示继承链。
- en: '![](../Images/c1sec3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c1sec3.png)'
- en: Notice that the anchor node inherits from *HTMLAnchorElement*, *HTMLElement*,
    *Element*, *Node*, and *Object* all shown in the list of properties highlighted
    with a gray background. This inheritance chain provides a great deal of shared
    methods and properties to all node types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意锚节点继承自*HTMLAnchorElement*、*HTMLElement*、*Element*、*Node*和*Object*，所有这些都在灰色背景突出显示的属性列表中。这种继承链为所有节点类型提供了大量共享的方法和属性。
- en: Notes
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can extend the DOM. But its likley not a [good idea to extend host objects](http://perfectionkills.com/whats-wrong-with-extending-the-dom/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以扩展DOM。但是扩展宿主对象可能不是一个[好主意](http://perfectionkills.com/whats-wrong-with-extending-the-dom/)。
- en: 1.4 Properties and methods for working nodes
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 用于操作节点的属性和方法
- en: Like we have been discussing all node objects (e.g *Element*, *Attr*, *Text*
    etc...) inherit properties and methods from a primary *Node* object. These properties
    and methods are the baseline values and functions for manipulating, inspecting,
    and traversing the DOM. In addtion to the properties and methods provided by the
    node interface there are a great deal of other relevant properties and methods
    that are provided by sub node interfaces such as the *document*, *HTMLElement*,
    or *HTML*Element* interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们一直讨论的，所有节点对象（例如*Element*、*Attr*、*Text*等）都继承自主要的*Node*对象的属性和方法。这些属性和方法是操作、检查和遍历DOM的基线值和函数。除了节点接口提供的属性和方法之外，还有许多其他相关的属性和方法由子节点接口（如*document*、*HTMLElement*或*HTML*Element*接口）提供。
- en: Below I list out the most common *Node* properties and methods inherited by
    all node objects including the relevant inherited properties for working with
    nodes from sub-node interfaces.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我列出了所有节点对象继承的最常见的*Node*属性和方法，包括用于处理来自子节点接口的节点的相关继承属性。
- en: 'Node Properties:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 节点属性：
- en: '*childNodes*'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*childNodes*'
- en: '*firstChild*'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*firstChild*'
- en: '*lastChild*'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lastChild*'
- en: '*nextSibling*'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nextSibling*'
- en: '*nodeName*'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nodeName*'
- en: '*nodeType*'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nodeType*'
- en: '*nodeValue*'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nodeValue*'
- en: '*parentNode*'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*parentNode*'
- en: '*previousSibling*'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*previousSibling*'
- en: 'Node Methods:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 节点方法：
- en: '*appendChild()*'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*appendChild()*'
- en: '*cloneNode()*'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*cloneNode()*'
- en: '*compareDocumentPosition()*'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*compareDocumentPosition()*'
- en: '*contains()*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*contains()*'
- en: '*hasChildNodes()*'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*hasChildNodes()*'
- en: '*insertBefore()*'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*insertBefore()*'
- en: '*isEqualNode()*'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*isEqualNode()*'
- en: '*removeChild()*'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*removeChild()*'
- en: '*replaceChild()*'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*replaceChild()*'
- en: 'Document Methods:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 文档方法：
- en: '*document.createElement()*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*document.createElement()*'
- en: '*document.createTextNode()*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*document.createTextNode()*'
- en: 'HTML * Element Properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: HTML *元素属性：
- en: '*innerHTML*'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*innerHTML*'
- en: '*outerHTML*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*outerHTML*'
- en: '*textContent*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*textContent*'
- en: '*innerText*'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*innerText*'
- en: '*outerText*'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*outerText*'
- en: '*firstElementChild*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*firstElementChild*'
- en: '*lastElementChild*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lastElementChild*'
- en: '*nextElementChild*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nextElementChild*'
- en: '*previousElementChild*'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*previousElementChild*'
- en: '*children*'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*children*'
- en: 'HTML element Methods:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: HTML元素方法：
- en: '*insertAdjacentHTML()*'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*insertAdjacentHTML()*'
- en: 1.5 Identifying the type and name of a node
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 识别节点的类型和名称
- en: Every node has a *nodeType* and *nodeName* property that is inherited from *Node*.
    For example *Text* nodes have a *nodeType* code of *3* and *nodeName* value of
    *'#text'*. As previously mentioned the numeric value *3* is a numeric code representing
    the type of underlying object the node represents (i.e. *Node.TEXT_NODE === 3*).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都有一个继承自*Node*的*nodeType*和*nodeName*属性。例如，*Text*节点的*nodeType*代码为*3*，*nodeName*值为*'#text'*。如前所述，数字值*3*是表示节点代表的底层对象类型的数字代码（即*Node.TEXT_NODE
    === 3*）。
- en: Below I detail the values returned for *nodeType* and *nodeName* for the node
    objects discussed in this book. It makes sense to simply memorize these numeric
    code's for the more common nodes given that we are only dealing with 5 numeric
    codes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面详细说明了本书讨论的节点对象的*nodeType*和*nodeName*返回的值。对于更常见的节点，简单地记住这些数字代码是有意义的，因为我们只处理5个数字代码。
- en: 'live code: [http://jsfiddle.net/domenlightenment/8EwNu](http://jsfiddle.net/domenlightenment/8EwNu)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/8EwNu](http://jsfiddle.net/domenlightenment/8EwNu)
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***If its not obvious the fastest way to determine if a node is of a certain
    type is too simply check its *nodeType* property. Below we check to see if the
    anchor element has a node number of 1\. If it does than we can conclude that its
    an *Element* node because *Node.ELEMENT_NODE === 1*.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '***如果不明显，确定节点是否属于某种类型的最快方法是简单地检查其*nodeType*属性。下面我们检查锚元素是否具有节点编号1。如果是，那么我们可以得出结论它是一个*Element*节点，因为*Node.ELEMENT_NODE
    === 1*。'
- en: 'live code: [http://jsfiddle.net/domenlightenment/ydzWL](http://jsfiddle.net/domenlightenment/ydzWL)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/ydzWL](http://jsfiddle.net/domenlightenment/ydzWL)
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Determining the type of node that you might be scripting becomes very handy
    so that you might know which properties and methods are available to script the
    node.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确定您可能正在编写脚本的节点类型非常方便，这样您就可以知道可用于编写节点的属性和方法。
- en: Notes
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The values returned by the *nodeName* property vary according to the node type.
    Have a look at the [DOM 4 specification](http://www.w3.org/TR/dom/#dom-node-nodename)
    provided for the details.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*nodeName*属性返回的值根据节点类型而变化。查看[DOM 4规范](http://www.w3.org/TR/dom/#dom-node-nodename)以获取详细信息。'
- en: 1.6 Getting a nodes value
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 获取节点的值
- en: The *nodeValue* property returns *null* for most of the node types (except *Text*,
    and *Comment*). It's use is centered around extracting actual text strings from
    *Text* and *Comment* nodes. In the code below I demonstrate its use on all the
    nodes discussed in this book
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*nodeValue*属性对大多数节点类型（除了*Text*和*Comment*）返回*null*。它的用途集中在从*Text*和*Comment*节点中提取实际文本字符串。在下面的代码中，我演示了它在本书中讨论的所有节点上的用法。'
- en: 'live code: [http://jsfiddle.net/domenlightenment/LNyA4](http://jsfiddle.net/domenlightenment/LNyA4)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/LNyA4](http://jsfiddle.net/domenlightenment/LNyA4)
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**### Notes'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**### 注意'
- en: '*Text* or *Comment* node values can be set by providing new strings values
    for the *nodeValue* property(i.e. *document.body.firstElementChild.nodeValue =
    ''hi''*).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*Text*或*Comment*节点的值可以通过为*nodeValue*属性提供新的字符串值来设置（即*document.body.firstElementChild.nodeValue
    = ''hi''*）。'
- en: 1.7 Creating element and text nodes using JavaScript methods
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 使用JavaScript方法创建元素和文本节点
- en: When a browser parses an HTML document it constructs the nodes and tree based
    on the contents of the HTML file. The browser deals with the creation of nodes
    for the intial loading of the HTML document. However its possible to create your
    own nodes using JavaScript. The following two methods allow us to programatically
    create *Element* and *Text* nodes using JavaScript.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器解析HTML文档时，它根据HTML文件的内容构造节点和树。浏览器处理HTML文档的初始加载时的节点创建。但是，可以使用JavaScript创建自己的节点。以下两种方法允许我们使用JavaScript编程方式创建*Element*和*Text*节点。
- en: '*createElement()*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*createElement()*'
- en: '*createTextNode()*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*createTextNode()*'
- en: Other methods are avaliable but are not commonly used (e.g. *createAttribute()*
    and *createComment()*) . In the code below I show how simple it is to create element
    and text nodes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可用，但通常不常用（例如*createAttribute()*和*createComment()*）。在下面的代码中，我展示了创建元素和文本节点是多么简单。
- en: 'live code: [http://jsfiddle.net/domenlightenment/Vj2Tc](http://jsfiddle.net/domenlightenment/Vj2Tc)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/Vj2Tc](http://jsfiddle.net/domenlightenment/Vj2Tc)
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notes
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *createElement()* method accepts one parameter which is a string specifying
    the element to be created. The string is the same string that is returned from
    the *tagName* property of an *Element* object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*createElement()*方法接受一个参数，该参数是指定要创建的元素的字符串。该字符串与*Element*对象的*tagName*属性返回的字符串相同。'
- en: The *createAttribute()* method is depricated and should not be used for creating
    attribute nodes. Instead developers typically use *getAttribute()*, *setAttribute()*,
    and *removeAttribute()* methods. I will discus this in more detail in the *Element*
    node chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*createAttribute()*方法已被弃用，不应用于创建属性节点。相反，开发人员通常使用*getAttribute()*、*setAttribute()*和*removeAttribute()*方法。我将在*Element*节点章节中更详细地讨论这一点。'
- en: The *createDocumentFragment()* will be discussed in the chapter covering this
    method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*createDocumentFragment()*将在涵盖此方法的章节中讨论。'
- en: You should be aware that a *createComment()* method is available for creating
    comment nodes. Its not discussed in this book but is very much available to a
    developer who finds its usage valuable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，有一个*createComment()*方法可用于创建注释节点。虽然本书没有讨论它，但对于发现其用途有价值的开发人员来说，它是完全可用的。
- en: 1.8 Creating and adding element and text nodes to the DOM using JavaScript strings
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 使用JavaScript字符串创建和添加元素和文本节点到DOM
- en: The *innerHTML*, *outerHTML*, *textContent* and *insertAdjacentHTML()* properties
    and methods provide the functionality to create and add nodes to the DOM using
    JavaScript strings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*innerHTML*、*outerHTML*、*textContent*和*insertAdjacentHTML()*属性和方法提供了使用JavaScript字符串创建和添加节点到DOM的功能。'
- en: In the code below we are using the *innerHTML*, *outerHTML*, and *textContent*
    properties to create nodes from JavaScript strings that are then immediately added
    to the DOM.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用*innerHTML*、*outerHTML*和*textContent*属性，从JavaScript字符串创建节点，然后立即将其添加到DOM中。
- en: 'live code: [http://jsfiddle.net/domenlightenment/UrNT3](http://jsfiddle.net/domenlightenment/UrNT3)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/UrNT3](http://jsfiddle.net/domenlightenment/UrNT3)
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The *insertAdjacentHTML()* method which only works on *Element* nodes is a good
    deal more precise than the previously mentioned methods*. Using this method its
    possible to insert nodes before the beginning tag, after the beginning tag, before
    the end tag, and after the end tag. Below I construct a sentence using the *insertAdjacentHTML()*
    method.*
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*insertAdjacentHTML()* 方法仅适用于*Element*节点，比先前提到的方法更加精确。使用这种方法，可以在开始标签之前、开始标签之后、结束标签之前和结束标签之后插入节点。下面我使用*insertAdjacentHTML()*方法构造一个句子。'
- en: '*live code: [http://jsfiddle.net/domenlightenment/tvpA6](http://jsfiddle.net/domenlightenment/tvpA6)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/tvpA6](http://jsfiddle.net/domenlightenment/tvpA6)
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notes
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笔记
- en: The *innerHTML* property will convert html elements found in the string to actual
    DOM nodes while the *textContent* can only be used to construct text nodes. If
    you pass *textContent* a string containing html elements it will simply spit it
    out as text.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*innerHTML*属性将字符串中找到的html元素转换为实际的DOM节点，而*textContent*只能用于构建文本节点。如果你向*textContent*传递包含html元素的字符串，它将简单地将其输出为文本。'
- en: '*document.write()* can also be used to simultaneously create and add nodes
    to the DOM. However its typically not used anymore unless its usage is required
    to accomplish 3rd party scripting tasks. Basically the *write()* method will output
    the values passed to it into the page during page loading/parsing. You should
    be aware that using the *write()* method will stall/block the parsing of the html
    document being loaded.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*document.write()*也可以用于同时创建和添加节点到DOM。然而，除非需要完成第三方脚本任务，否则通常不再使用它。基本上，*write()*方法会在页面加载/解析期间将传递给它的值输出到页面上。您应该知道使用*write()*方法会阻止正在加载的html文档的解析。'
- en: '*innerHTML* invokes a heavy & expensive HTML parser where as text node generation
    is trivial thus use the innerHTML & friends sparingly'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*innerHTML*调用了一个复杂且昂贵的HTML解析器，而文本节点生成是微不足道的，因此要谨慎使用innerHTML及其相关方法'
- en: The *insertAdjacentHTML* options "beforebegin" and "afterend" will only work
    if the node is in the DOM tree and has a parent element.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*insertAdjacentHTML*选项"beforebegin"和"afterend"只有在节点在DOM树中并且有父元素时才会起作用。'
- en: Support for *outerHTML* was not available natively in Firefox until version
    11\. A [polyfill](https://gist.github.com/1044128) is avaliable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 直到版本11，火狐浏览器才原生支持*outerHTML*。有一个[兼容性解决方案](https://gist.github.com/1044128)。
- en: '*textContent* gets the content of all elements, including *<script>* and *<style>* elements, *innerText*
    does not'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*textContent*获取所有元素的内容，包括*<script>*和*<style>*元素，而*innerText*不会'
- en: '*innerText* is aware of style and will not return the text of hidden elements,
    whereas *textContent* will'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*innerText*知道样式并且不会返回隐藏元素的文本，而*textContent*会'
- en: Avaliable to all modern browser except Firefox is *insertAdjacentElement()*
    and *insertAdjacentText()*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了火狐浏览器之外，所有现代浏览器都支持*insertAdjacentElement()*和*insertAdjacentText()*
- en: 1.9 Extracting parts of the DOM tree as JavaScript strings
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9 提取DOM树的部分作为JavaScript字符串
- en: The same exact properties (*innerHTML*, *outerHTML*, *textContent*) that we
    use to create and add nodes to the DOM can also be used to extract parts of the
    DOM (or really the entire DOM) as a JavaScript string. In the code example below
    I use these properties to return a string value containing text and html values
    from the HTML document.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于创建和添加节点到DOM的完全相同的属性（*innerHTML*、*outerHTML*、*textContent*）也可以用于提取DOM的部分（或者实际上整个DOM）作为JavaScript字符串。在下面的代码示例中，我使用这些属性返回一个包含HTML文档中文本和html值的字符串值。
- en: 'live code: [http://jsfiddle.net/domenlightenment/mMYWc](http://jsfiddle.net/domenlightenment/mMYWc)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/mMYWc](http://jsfiddle.net/domenlightenment/mMYWc)
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notes
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笔记
- en: The *textContent*, *innerText*, *outerText* property when being read will return
    all of the text nodes contained within the selected node. So for example (not
    a good idea in practice), *document.body.textContent* will get all the text nodes
    contained in the body element not just the first text node.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取*textContent*、*innerText*、*outerText*属性时，将返回所选节点中包含的所有文本节点。因此，例如（实际上不是一个好主意），*document.body.textContent*将获取包含在body元素中的所有文本节点，而不仅仅是第一个文本节点。
- en: 1.10 Adding node objects to the DOM using *appendChild()*& *insertBefore()*
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10 使用*appendChild()*和*insertBefore()*向DOM添加节点对象
- en: The *appendChild()* and *insertBefore()* *Node* methods allow us to insert JavaScript
    node objects into the DOM tree. The *appendChild()* method will append a node(s)
    to the end of the child node(s) of the node the method is called on. If there
    are no child node(s) then the node being appended is appended as the first child. 
    For example in the code below we are creating a element node (*<strong>*) and
    text node (*Dude*). Then the *<p>* is selected from the DOM and our *<strong>*
    element is appended using *appendChild()*. Notice that the *<strong>* element
    is encapsulated inside of the *<p>* element and added as the last child node.
    Next the *<strong>* element is selected and the text *'Dude'* is appended to the
    *<strong>* element.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*appendChild()*和*insertBefore()* *Node*方法允许我们将 JavaScript 节点对象插入 DOM 树中。*appendChild()*方法将节点追加到调用该方法的节点的子节点的末尾。如果没有子节点，则被追加的节点将作为第一个子节点追加。例如，在下面的代码中，我们创建了一个元素节点（*<strong>*）和文本节点（*Dude*）。然后从
    DOM 中选择了*<p>*，并使用*appendChild()*追加了我们的*<strong>*元素。注意，*<strong>*元素被封装在*<p>*元素内，并作为最后一个子节点添加。接下来选择*<strong>*元素，并将文本*''Dude''*追加到*<strong>*元素中。'
- en: 'live code: [http://jsfiddle.net/domenlightenment/HxjFt](http://jsfiddle.net/domenlightenment/HxjFt)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/HxjFt](http://jsfiddle.net/domenlightenment/HxjFt)
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When it becomes necessary to control the location of insertion beyond appending
    nodes to the end of a child list of nodes we can use *insertBefore()*. In the
    code below I am inserting the *<li>* element before the first child node of the
    *<ul>* element.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要控制插入位置超出将节点追加到节点子列表末尾时，可以使用*insertBefore()*。在下面的代码中，我在*<ul>*元素的第一个子节点之前插入了*<li>*元素。
- en: 'live code: [http://jsfiddle.net/domenlightenment/UmkME](http://jsfiddle.net/domenlightenment/UmkME)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/UmkME](http://jsfiddle.net/domenlightenment/UmkME)
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The *insertBefore()* requires two parameters, the node to be inserted and the
    reference node in the document you would like the node inserted before.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*insertBefore()*需要两个参数，要插入的节点和要在文档中插入节点之前的参考节点。'
- en: Notes
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: If you do not pass the *insertBefore()* method a second parameter then it functions
    just like *appendChild()*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不给*insertBefore()*方法传递第二个参数，则其功能与*appendChild()*相同。
- en: We have [more methods](http://www.w3.org/TR/dom/#mutation-methods) (e.g. *prepend()*,
    *append()*, *before()*, *after()*) to look forward too in DOM 4.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 DOM 4 中还有[更多方法](http://www.w3.org/TR/dom/#mutation-methods)（例如*prepend()*、*append()*、*before()*、*after()*）可以期待。
- en: 1.11 Removing and replacing nodes using *removeChild()* and *replaceChild()*
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11 使用*removeChild()*和*replaceChild()*来移除和替换节点
- en: Removing a node from the DOM is a bit of a multi-step process. First you have
    to select the node you want to remove. Then you need to gain access to its parent
    element typically using the *parentNode* property. Its on the parent node that
    you invoke the *removeChild()* method passing it the reference to the node to
    be removed. Below I demonstrate its use on an element node and text node.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DOM 中移除节点是一个多步骤的过程。首先你需要选择要移除的节点。然后通常使用*parentNode*属性获得其父元素的访问权限。在父节点上调用*removeChild()*方法，传递要移除的节点的引用。下面我演示了如何在元素节点和文本节点上使用它。
- en: 'live code: [http://jsfiddle.net/domenlightenment/VDZgP](http://jsfiddle.net/domenlightenment/VDZgP)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/VDZgP](http://jsfiddle.net/domenlightenment/VDZgP)
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Replacing an element or text node is not unlike removing one. In the code below
    I use the same html structure used in the previous code example except this time
    I use *replaceChild()* to update the nodes instead of removing them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 替换元素或文本节点与移除类似。在下面的代码中，我使用了前一个代码示例中使用的相同的 HTML 结构，但这次我使用*replaceChild()*来更新节点而不是移除它们。
- en: 'live code: [http://jsfiddle.net/domenlightenment/zgE8M](http://jsfiddle.net/domenlightenment/zgE8M)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/zgE8M](http://jsfiddle.net/domenlightenment/zgE8M)
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notes
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Depending upon what you are removing or replacing simply providing the *innerHTML*,
    *outerHTML*, and *textContent* properties with an empty string might be easier
    and faster. [Careful memory leaks in brwoser might get you however](http://javascript.crockford.com/memory/leak.html).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你要移除或替换的内容，仅仅提供*innerHTML*、*outerHTML*和*textContent*属性为空字符串可能更容易更快。[但要小心浏览器中的内存泄漏](http://javascript.crockford.com/memory/leak.html)。
- en: Both *replaceChild()* and *removeChild()* return the replaced or remove node.
    Basically its not gone just because you replace it or remove. All this does is
    takes it out of the current live document. You still have a reference to it in
    memory.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*replaceChild()*和*removeChild()*都会返回被替换或移除的节点。基本上，它并没有因为你替换或移除而消失。这只是将其从当前实时文档中取出。你仍然在内存中有对它的引用。'
- en: We have [more methods](http://www.w3.org/TR/dom/#mutation-methods) (e.g.*replace()*,
    *remove()*) to look forward too in DOM 4.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在DOM 4中还有[更多方法](http://www.w3.org/TR/dom/#mutation-methods)（例如*replace()*、*remove()*）可以期待。
- en: 1.12 Cloning nodes using *cloneNode()*
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.12 使用*cloneNode()*克隆节点
- en: Using the *cloneNode()* method its possible to duplicate a single node or a
    node and all its children nodes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*cloneNode()*方法，可以复制单个节点或节点及其所有子节点。
- en: In the code below I clone only the *<ul>* (i.e. *HTMLUListElement)* which once
    cloned can be treated like any node reference.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我仅克隆了*<ul>*（即*HTMLUListElement*），一旦克隆，它就可以像任何节点引用一样对待。
- en: 'live code: [http://jsfiddle.net/domenlightenment/6DHgC](http://jsfiddle.net/domenlightenment/6DHgC)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/6DHgC](http://jsfiddle.net/domenlightenment/6DHgC)
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To clone a node and all of its children nodes you pass the *cloneNode()* method
    a parameter of of *true*. Below I use the *cloneNode()* method again but this
    time we clone all of the child nodes as well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要克隆节点及其所有子节点，你需要向*cloneNode()*方法传递一个*true*参数。下面我再次使用*cloneNode()*方法，但这次我们也克隆了所有子节点。
- en: 'live code: [http://jsfiddle.net/domenlightenment/EyFEC](http://jsfiddle.net/domenlightenment/EyFEC)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/EyFEC](http://jsfiddle.net/domenlightenment/EyFEC)
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notes
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: When cloning an *Element* node all attributes and values are also cloned. In
    fact, only attributes are copied! Everything else you can add (e.g. event handlers)
    to a DOM node is lost when cloning.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当克隆*Element*节点时，所有属性和值也会被克隆。事实上，只有属性被复制！当克隆时，任何你可以添加到DOM节点的东西（例如事件处理程序）都会丢失。
- en: You might think that cloning a node and its children using *cloneNode(true)*
    would return a *NodeList* but it in fact does not.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为使用*cloneNode(true)*克隆节点及其子节点会返回一个*NodeList*，但事实上并不是这样。
- en: '*cloneNode()* may lead to duplicate element IDs in a document'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*cloneNode()*可能会导致文档中出现重复的元素ID。
- en: 1.13 Grokking node collections (i.e. *Nodelist* & *HTMLcollection*)
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.13 理解节点集合（即*Nodelist*和*HTMLcollection*）
- en: When selecting groups of nodes from a tree (cover in chaper 3) or accessing
    pre-defined sets of nodes, the nodes are either placed in a [*NodeList*](http://www.w3.org/TR/dom/#nodelist)
    (e.g. *document.querySelectorAll('*')*) or [*HTMLCollection*](http://www.w3.org/TR/dom/#htmlcollection)
    (e.g. *document.scripts*). These array like (i.e. not a real *Array*) object collections
    that have the following characteristics.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当从树中选择节点组（在第3章中讨论）或访问预定义节点集时，节点要么放置在[*NodeList*](http://www.w3.org/TR/dom/#nodelist)（例如*document.querySelectorAll('*')*）中，要么放置在[*HTMLCollection*](http://www.w3.org/TR/dom/#htmlcollection)（例如*document.scripts*）中。这些类似数组（即不是真正的*Array*）的对象集合具有以下特点。
- en: A collection can either be live or static. Meaning that the nodes contained
    in the collection are either literally part of the live document or a snapshot
    of the live document.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合可以是实时的或静态的。这意味着集合中包含的节点要么是实时文档的一部分，要么是实时文档的快照。
- en: By default nodes are sorted inside of the collection by tree order. Meaning
    the order matches the liner path from tree trunk to branches.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，节点在集合内按树的顺序排序。这意味着顺序与从树干到树枝的线性路径相匹配。
- en: The collections have a *length* property that reflects the number of elements
    in the list
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些集合具有一个*length*属性，反映列表中元素的数量。
- en: 1.14 Gettting a list/collection of all immediate child nodes
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.14 获取所有直接子节点的列表/集合
- en: Using the *childNodes* property produces an array like list (i.e. [NodeList](https://developer.mozilla.org/En/DOM/NodeList))
    of the immediate child nodes. Below I select the *<ul>* element which I then use
    to create a list of all of the immediate child nodes contained inside of the *<ul>*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*childNodes*属性会产生一个类似数组的列表（即[NodeList](https://developer.mozilla.org/En/DOM/NodeList)），包含了直接子节点。下面我选择了*<ul>*元素，然后使用它来创建包含在*<ul>*中的所有直接子节点的列表。
- en: 'live code: [http://jsfiddle.net/domenlightenment/amDev](http://jsfiddle.net/domenlightenment/amDev)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/amDev](http://jsfiddle.net/domenlightenment/amDev)
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notes
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The *NodeList* returned by *childNodes* only contains immediate child nodes
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由*childNodes*返回的*NodeList*只包含直接子节点。
- en: Be aware *childNodes* contains not only *Element* nodes but also all other node
    types (e.g. *Text* and *Comment* nodes)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*childNodes*不仅包含*Element*节点，还包括所有其他节点类型（例如*Text*和*Comment*节点）。
- en: '*[].forEach* was implemented in ECMAScript 5th edtion'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*[].forEach* 是在 ECMAScript 5th edtion 中实现的。'
- en: 1.15 Convert a *NodeList* or *HTMLCollection* to JavaScript *Array*
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.15 将 *NodeList* 或 *HTMLCollection* 转换为 JavaScript *Array*
- en: Node lists and html collections are array like but not a true JavaScript array
    which inherits array methods. In the code below we programtically confirm this
    using *isArray()*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 节点列表和 HTML 集合类似于数组，但不是真正的 JavaScript 数组，它们不继承数组方法。在下面的代码中，我们使用 *isArray()* 来程序确认这一点。
- en: 'live code: [http://jsfiddle.net/domenlightenment/n53Xk](http://jsfiddle.net/domenlightenment/n53Xk)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/n53Xk](http://jsfiddle.net/domenlightenment/n53Xk)
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notes
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Array.isArray* was implemented in ECMAScript 5th edtion or ES5'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array.isArray* 是在 ECMAScript 5th edtion 或 ES5 中实现的。'
- en: Converting a node list and html collection list to a true JavaScript array can
    provide a good deal of advantages. For one it gives us the ability to create a
    snapshot of the list that is not tied to the live DOM considering that *NodeList*
    and *HTMLCollection* are [live](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#td-live)
    lists. Secondly, converting a list to a JavaScript array gives access to the methods
    provided by the *Array* object (e.g. *forEach*, *pop*, *map*, *reduce* etc...).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将节点列表和 HTML 集合列表转换为真正的 JavaScript 数组可以带来很多好处。首先，它使我们能够创建列表的快照，而不是与实时 DOM 绑定，考虑到
    *NodeList* 和 *HTMLCollection* 是 [实时](http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#td-live)
    列表。其次，将列表转换为 JavaScript 数组可以访问 *Array* 对象提供的方法（例如 *forEach*、*pop*、*map*、*reduce*
    等）。
- en: To convert an array like list to a true JavaScript array pass the array-like
    list to *call()* or *apply()*, in which the *call()* or *apply()* is calling a
    method that returns an un-altered true JavaScript array. In the code below I use
    the *.slice()* method, which doesn't really slice anything I am just using it
    to convert the list to a JavaScript *Array* due to the fact the *slice()* returns
    an array.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要将类似数组的列表转换为真正的 JavaScript 数组，请将类似数组的列表传递给 *call()* 或 *apply()*，其中 *call()*
    或 *apply()* 调用返回一个未改变的真正的 JavaScript 数组。在下面的代码中，我使用了 *.slice()* 方法，它实际上并没有切片任何东西，我只是用它来将列表转换为
    JavaScript *Array*，因为 *slice()* 返回一个数组。
- en: 'live code: [http://jsfiddle.net/domenlightenment/jHgTY](http://jsfiddle.net/domenlightenment/jHgTY)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/jHgTY](http://jsfiddle.net/domenlightenment/jHgTY)
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notes
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In ECMAScript 6th edtion we have *Array.from* to look forward to which converts
    a single argument that is an array-like object or list (eg. *arguments*, *NodeList*,
    *DOMTokenList* (used by *classList*), *NamedNodeMap* (used by *attributes* property))
    into a *new Array()* and returns it
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ECMAScript 6th edtion 中，我们期待有 *Array.from*，它将一个参数转换为一个数组对象或列表（例如 *arguments*、*NodeList*、*DOMTokenList*（被
    *classList* 使用）、*NamedNodeMap*（被 *attributes* 属性使用））并返回一个 *new Array()*。
- en: 1.16 Traversing nodes in the DOM
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.16 遍历 DOM 中的节点
- en: 'From a node reference (i.e. *document.querySelector(''ul'')*) its possible
    to get a different node reference by traversing the DOM using the following properties:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点引用（即 *document.querySelector('ul')*）可以通过以下属性遍历 DOM 来获取不同的节点引用：
- en: '*parentNode*'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*parentNode*'
- en: '*firstChild*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*firstChild*'
- en: '*lastChild*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lastChild*'
- en: '*nextSibling*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nextSibling*'
- en: '*previousSibling*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*previousSibling*'
- en: In the code example below we examine the *Node* properties providing DOM traversal
    functionality.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们检查提供 DOM 遍历功能的 *Node* 属性。
- en: 'live code: [http://jsfiddle.net/domenlightenment/Hvfhv](http://jsfiddle.net/domenlightenment/Hvfhv)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/Hvfhv](http://jsfiddle.net/domenlightenment/Hvfhv)
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*If you have been around the DOM much then it should be no surprise that traversing
    the DOM includes not just traversing element nodes but also text and comment nodes.
    I believe the last code example makes this clear, and this is not exactly ideal.
    Using the following properties we can traverse the DOM ignoring text and comment
    nodes.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你对 DOM 比较熟悉，那么遍历 DOM 包括遍历元素节点、文本节点和注释节点就不足为奇了。我相信最后一个代码示例清楚地表明了这一点，而这并不完全理想。使用以下属性，我们可以遍历
    DOM 而忽略文本和注释节点。'
- en: '*firstElementChild*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*firstElementChild*'
- en: '*lastElementChild*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lastElementChild*'
- en: '*nextElementChild*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*nextElementChild*'
- en: '*previousElementChild*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*previousElementChild*'
- en: '*children*'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*children*'
- en: Notes
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *childElementCount* is not mentioned but you should be aware of its avaliablity
    for calculating the number of child elements a node contains.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*childElementCount* 没有提到，但你应该知道它可用于计算节点包含的子元素数量。'
- en: Examine our code example again using only element traversing methods.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看我们的代码示例，只使用元素遍历方法。
- en: 'live code: [http://jsfiddle.net/domenlightenment/Wh7nf](http://jsfiddle.net/domenlightenment/Wh7nf)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/Wh7nf](http://jsfiddle.net/domenlightenment/Wh7nf)
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*## 1.17 Verify a node position in the DOM tree with *contains()* & *compareDocumentPosition()*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*## 1.17 使用 *contains()* 和 *compareDocumentPosition()* 验证节点在 DOM 树中的位置'
- en: Its possible to know if a node is contained inside of another node by using
    the *contains()* *Node* method. In the code below I ask if *<body>* is contained
    inside of *<html lang="en">*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 *contains()* *Node* 方法知道一个节点是否包含在另一个节点中。在下面的代码中，我询问 *<body>* 是否包含在 *<html
    lang="en">* 中。
- en: 'live code: [http://jsfiddle.net/domenlightenment/ENU4w](http://jsfiddle.net/domenlightenment/)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 实时代码：[http://jsfiddle.net/domenlightenment/ENU4w](http://jsfiddle.net/domenlightenment/)
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you need more robust information about the position of a node in the DOM
    tree in regards to the nodes around it you can use the *compareDocumentPosition()*
    *Node* method. Basically this method gives you the ability to request information
    about a selected node relative to the node passed in. The information that you
    get back is a number that corresponds to the following information.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多关于节点在 DOM 树中位置的有关信息，可以使用 *compareDocumentPosition()* *Node* 方法。基本上，此方法使您能够请求有关所选节点相对于传入节点的信息。您得到的信息是一个与以下信息对应的数字。
- en: '| number code returned from *compareDocumentPosition()*: | number code info:
    |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 从 *compareDocumentPosition()* 返回的数字代码： | 数字代码信息： |'
- en: '| --- | --- |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Elements are identical. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 元素相同。 |'
- en: '| 1 | DOCUMENT_POSITION_DISCONNECTED Set when selected node and passed in node
    are not in the same document. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 1 | DOCUMENT_POSITION_DISCONNECTED 当所选节点和传入的节点不在同一文档中时设置。 |'
- en: '| 2 | DOCUMENT_POSITION_PRECEDING Set when passed in node is preceding selected
    node. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 2 | DOCUMENT_POSITION_PRECEDING 当传入的节点在所选节点之前时设置。 |'
- en: '| 3 | DOCUMENT_POSITION_FOLLOWING Set when passed in node is following selected
    node. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 3 | DOCUMENT_POSITION_FOLLOWING 当传入的节点在所选节点之后时设置。 |'
- en: '| 8 | DOCUMENT_POSITION_CONTAINS Set when passed in node is an ancestor of
    selected node. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 8 | DOCUMENT_POSITION_CONTAINS 当传入的节点是所选节点的祖先时设置。 |'
- en: '| 16, 10 | DOCUMENT_POSITION_CONTAINED_BY (16, 10 in hexadecimal) Set when
    passed in node is a descendant of selected node. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 16, 10 | DOCUMENT_POSITION_CONTAINED_BY (16, 10 十六进制) 当传入的节点是所选节点的后代时设置。
    |'
- en: Notes
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '*contains()* will return *true* if the node selected and node passed in are
    identical.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*contains()* 如果所选节点和传入节点相同，则返回 *true*。'
- en: '*compareDocumentPosition()* can be rather confusing because its possible for
    a node to have more than one type of relationship with another node. For example
    when a node both contains (16) and precedes (4) the returned value from *compareDocumentPosition()*
    will be 20.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*compareDocumentPosition()* 可能会令人困惑，因为一个节点可能与另一个节点具有多种关系。例如，当一个节点既包含（16）又在前面（4）时，*compareDocumentPosition()*
    返回的值将是 20。'
- en: 1.18 How to determine if two nodes are identical
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.18 如何确定两个节点是否相同
- en: '[According to the DOM 3 specification](http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode)
    two nodes are equal if and only if the following conditions are satisfied:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[根据 DOM 3 规范](http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode)，只有当满足以下条件时，两个节点才相等：'
- en: The two nodes are of the same type.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个节点是相同类型的。
- en: 'The following string attributes are equal: *nodeName*, *localName*, *namespaceURI*, *prefix*, *nodeValue*.
    That is: they are both null, or they have the same length and are character for
    character identical.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下字符串属性相等：*nodeName*、*localName*、*namespaceURI*、*prefix*、*nodeValue*。也就是说：它们都是
    *null*，或者它们具有相同的长度，并且每个字符都完全相同。
- en: 'The *attributes* *NamedNodeMaps* are equal. That is: they are both *null*,
    or they have the same length and for each node that exists in one map there is
    a node that exists in the other map and is equal, although not necessarily at
    the same index.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*attributes* *NamedNodeMaps* 相等。也就是说：它们都是 *null*，或者它们具有相同的长度，并且对于存在于一个映射中的每个节点，存在于另一个映射中的节点是相等的，尽管不一定在相同的索引处。'
- en: 'The *childNodes* *NodeLists* are equal. That is: they are both *null*, or they
    have the same length and contain equal nodes at the same index. Note that normalization
    can affect equality; to avoid this, nodes should be normalized before being compared.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*childNodes* *NodeLists* 相等。也就是说：它们都是 *null*，或者它们具有相同的长度，并且在相同的索引处包含相同的节点。请注意，规范化可能会影响相等性；为了避免这种情况，在比较之前应该对节点进行规范化。'
- en: Calling the *.isEqualNode()* method on a node in the DOM will ask if that node
    is equal to the node that you pass it as a parameter. Below I exhibt a case of
    an two equal nodes and two non-identical nodes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DOM 中对节点调用 *.isEqualNode()* 方法将询问该节点是否等于您传递的节点。下面我展示了两个相同节点和两个不同节点的情况。
- en: 'live code: [http://jsfiddle.net/domenlightenment/xw68Q](http://jsfiddle.net/domenlightenment/xw68Q)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在线代码：[http://jsfiddle.net/domenlightenment/xw68Q](http://jsfiddle.net/domenlightenment/xw68Q)
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notes
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't care about two nodes being exactly equal but instead want to know
    if two node references refer to the same node you can simply check it using the
    *===* opertor (i.e. *document.body === document.body*). This will tell us if they
    are identical but no equal.********
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不关心两个节点是否完全相等，而是想知道两个节点引用是否指向同一个节点，你可以简单地使用*===*运算符进行检查（即*document.body ===
    document.body*）。这将告诉我们它们是否相同但不相等。
