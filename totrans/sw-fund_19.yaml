- en: Hoare2Hoare Logic, Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.Bool.Bool.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.EqNat.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Hoare.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: X ::= m;;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= p;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z - 1;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '{{ True }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= m;;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= p;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z - 1;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '{{ True }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ m = m }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= m;;
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = m }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = m ∧ p = p }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= p;
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X = m ∧ Z = p }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z - X = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z - X = p - m ∧ X ≠ 0 }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ (Z - 1) - (X - 1) = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z - 1;;
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z - (X - 1) = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z - X = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z - X = p - m ∧ ¬ (X ≠ 0) }} ⇾ {{ Z = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '{{ P }} SKIP {{ P }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{{ P }} c[1];; {{ Q }} c[2] {{ R }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{{ P [X ↦ a] }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: X ::= a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{{ P }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IFB b THEN
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P ∧ b }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c[1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ Q }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ELSE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P ∧ ¬b }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c[2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ Q }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FI
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ Q }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{{ P }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WHILE b DO
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P ∧ b }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c[1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: END
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P ∧ ¬b }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '{{ P }} ⇾'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{ P'' }}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Example: Swapping Using Addition and Subtraction'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a program that swaps the values of two variables using
  prefs: []
  type: TYPE_NORMAL
- en: addition and subtraction (instead of by assigning to a temporary
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can prove using decorations that this program is correct —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: i.e., it always swaps the values of variables X and Y.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '['
  prefs: []
  type: TYPE_NORMAL
- en: (1)     {{ X = m ∧ Y = n }} ⇾
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (2)     {{ (X + Y) - ((X + Y) - Y) = n ∧ (X + Y) - Y = m }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: X ::= X + Y;;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (3)     {{ X - (X - Y) = n ∧ X - Y = m }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Y ::= X - Y;;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (4)     {{ X - Y = n ∧ Y = m }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: X ::= X - Y
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (5)     {{ X = n ∧ Y = m }}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: 'These decorations can be constructed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We begin with the undecorated program (the unnumbered lines).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add the specification — i.e., the outer precondition (1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and postcondition (5). In the precondition we use parameters
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: m and n to remember the initial values of variables X
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: and Y, so that we can refer to them in the
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: postcondition (5).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We work backwards mechanically, starting from (5) and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: proceeding until we get to (2). At each step, we obtain the
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: precondition of the assignment from its postcondition by
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: substituting the assigned variable with the right-hand-side of
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: the assignment. For instance, we obtain (4) by substituting
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: X with X - Y in (5), and (3) by substituting Y with X -
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Y in (4).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we verify that (1) logically implies (2) — i.e.,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: that the step from (1) to (2) is a valid use of the law of
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: consequence. For this we substitute X by m and Y by n
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'and calculate as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that, since we are working with natural numbers rather than
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fixed-width machine integers, we don't need to worry about the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: possibility of arithmetic overflow anywhere in this argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This makes life quite a bit simpler!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: (1)     {{True}}
  prefs: []
  type: TYPE_NORMAL
- en: IFB X ≤ Y THEN
  prefs: []
  type: TYPE_NORMAL
- en: (2)       {{True ∧ X ≤ Y}} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: (3)       {{(Y - X) + X = Y ∨ (Y - X) + Y = X}}
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Y - X
  prefs: []
  type: TYPE_NORMAL
- en: (4)       {{Z + X = Y ∨ Z + Y = X}}
  prefs: []
  type: TYPE_NORMAL
- en: ELSE
  prefs: []
  type: TYPE_NORMAL
- en: (5)       {{True ∧ ~(X ≤ Y) }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: (6)       {{(X - Y) + X = Y ∨ (X - Y) + Y = X}}
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= X - Y
  prefs: []
  type: TYPE_NORMAL
- en: (7)       {{Z + X = Y ∨ Z + Y = X}}
  prefs: []
  type: TYPE_NORMAL
- en: FI
  prefs: []
  type: TYPE_NORMAL
- en: (8)     {{Z + X = Y ∨ Z + Y = X}}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '{{ True }}'
  prefs: []
  type: TYPE_NORMAL
- en: IFB X ≤ Y THEN
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Y - X
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }}'
  prefs: []
  type: TYPE_NORMAL
- en: ELSE
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= X + Z
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }}'
  prefs: []
  type: TYPE_NORMAL
- en: FI
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Y = X + Z }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Reduce to Zero'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a WHILE loop that is so simple it needs no
  prefs: []
  type: TYPE_NORMAL
- en: invariant (i.e., the invariant True will do the job).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The decorations can be constructed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the outer precondition (1) and postcondition (6).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the format dictated by the hoare_while rule, we
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: copy (1) to (4). We conjoin (1) with the guard to obtain (2) and
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: with the negation of the guard to obtain (5). Note that, because
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: the outer postcondition (6) does not syntactically match (5), we
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: need a trivial use of the consequence rule from (5) to (6).
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Assertion (3) is the same as (4), because X does not appear in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4, so the substitution in the assignment rule is trivial.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, the implication between (2) and (3) is also trivial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this informal proof, it is easy to read off a formal proof
  prefs: []
  type: TYPE_NORMAL
- en: using the Coq versions of the Hoare rules.  Note that we do *not*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold the definition of hoare_triple anywhere in this proof —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the idea is to use the Hoare rules as a "self-contained" logic for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reasoning about programs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Division'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following Imp program calculates the integer quotient and
  prefs: []
  type: TYPE_NORMAL
- en: remainder of two numbers m and n that are arbitrary constants
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In we replace m and n by concrete numbers and execute the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: program, it will terminate with the variable X set to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: remainder when m is divided by n and Y set to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: quotient.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to give a specification to this program we need to
  prefs: []
  type: TYPE_NORMAL
- en: remember that dividing m by n produces a reminder X and a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: quotient Y such that n * Y + X = m ∧ X < n.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It turns out that we get lucky with this program and don't have to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'think very hard about the loop invariant: the invariant is just'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the first conjunct n * Y + X = m, and we can use this to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: decorate the program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Assertions (4), (5), (8), and (9) are derived mechanically from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the invariant and the loop's guard.  Assertions (8), (7), and (6)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are derived using the assignment rule going backwards from (8)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to (6).  Assertions (4), (3), and (2) are again backwards
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: applications of the assignment rule.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we've decorated the program it only remains to check that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the two uses of the consequence rule are correct — i.e., that (1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: implies (2) and that (5) implies (6).  This is indeed the case, so
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we have a valid decorated program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '{{ X = m ∧ Y = n }}'
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Y = n - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: (1)      {{ X = m ∧ Y = n }}  ⇾             (a)
  prefs: []
  type: TYPE_NORMAL
- en: (2)      {{ I }}
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: (3)        {{ I ∧ X ≠ 0 }}  ⇾              (c)
  prefs: []
  type: TYPE_NORMAL
- en: (4)        {{ I [X ↦ X-1] [Y ↦ Y-1] }}
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  prefs: []
  type: TYPE_NORMAL
- en: (5)        {{ I [X ↦ X-1] }}
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: (6)        {{ I }}
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: (7)      {{ I ∧ ¬ (X ≠ 0) }}  ⇾            (b)
  prefs: []
  type: TYPE_NORMAL
- en: (8)      {{ Y = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: (1)      {{ X = m ∧ Y = n }} ⇾       (a - OK)
  prefs: []
  type: TYPE_NORMAL
- en: (2)      {{ True }}
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: (3)        {{ True ∧ X ≠ 0 }}  ⇾    (c - OK)
  prefs: []
  type: TYPE_NORMAL
- en: (4)        {{ True }}
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  prefs: []
  type: TYPE_NORMAL
- en: (5)        {{ True }}
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: (6)        {{ True }}
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: (7)      {{ True ∧ X = 0 }}  ⇾       (b - WRONG!)
  prefs: []
  type: TYPE_NORMAL
- en: (8)      {{ Y = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: (1)      {{ X = m ∧ Y = n }}  ⇾          (a - WRONG!)
  prefs: []
  type: TYPE_NORMAL
- en: (2)      {{ Y = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: (3)        {{ Y = n - m ∧ X ≠ 0 }}  ⇾   (c - WRONG!)
  prefs: []
  type: TYPE_NORMAL
- en: (4)        {{ Y - 1 = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  prefs: []
  type: TYPE_NORMAL
- en: (5)        {{ Y = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: (6)        {{ Y = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: (7)      {{ Y = n - m ∧ X = 0 }}  ⇾      (b - OK)
  prefs: []
  type: TYPE_NORMAL
- en: (8)      {{ Y = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: (1)      {{ X = m ∧ Y = n }}  ⇾               (a - OK)
  prefs: []
  type: TYPE_NORMAL
- en: (2)      {{ Y - X = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: (3)        {{ Y - X = n - m ∧ X ≠ 0 }}  ⇾    (c - OK)
  prefs: []
  type: TYPE_NORMAL
- en: (4)        {{ (Y - 1) - (X - 1) = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  prefs: []
  type: TYPE_NORMAL
- en: (5)        {{ Y - (X - 1) = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: (6)        {{ Y - X = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: (7)      {{ Y - X = n - m ∧ X = 0 }}  ⇾       (b - OK)
  prefs: []
  type: TYPE_NORMAL
- en: (8)      {{ Y = n - m }}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Slow Assignment'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise: 2 starsM (slow_assignment)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A roundabout way of assigning a number currently stored in X to
  prefs: []
  type: TYPE_NORMAL
- en: the variable Y is to start Y at 0, then decrement X until
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it hits 0, incrementing Y at each step. Here is a program that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'implements this idea:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Write an informal decorated program showing that this procedure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: WHILE X ≠ 0 DO
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z + 1;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Parity'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a cute little program for computing the parity of the
  prefs: []
  type: TYPE_NORMAL
- en: value initially stored in X (due to Daniel Cristofani).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The mathematical parity function used in the specification is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'defined in Coq as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The postcondition does not hold at the beginning of the loop,
  prefs: []
  type: TYPE_NORMAL
- en: since m = parity m does not hold for an arbitrary m, so we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cannot use that as an invariant.  To find an invariant that works,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let's think a bit about what this loop does.  On each iteration it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: decrements X by 2, which preserves the parity of X.  So the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parity of X does not change, i.e., it is invariant.  The initial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: value of X is m, so the parity of X is always equal to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parity of m. Using parity X = parity m as an invariant we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'obtain the following decorated program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this invariant, conditions (a), (b), and (c) are all
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: satisfied. For verifying (b), we observe that, when X < 2, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have parity X = X (we can easily see this in the definition of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parity).  For verifying (c), we observe that, when 2 ≤ X, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have parity X = parity (X-2).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (parity_formal)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Translate this proof to Coq. Refer to the reduce_to_zero example
  prefs: []
  type: TYPE_NORMAL
- en: 'for ideas. You may find the following two lemmas useful:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '{{ X=m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 0;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (Z+1)*(Z+1) ≤ X DO
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z+1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z*Z≤m ∧ m<(Z+1)*(Z+1) }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: (1)  {{ X=m }}  ⇾           (a - second conjunct of (2) WRONG!)
  prefs: []
  type: TYPE_NORMAL
- en: (2)  {{ 0*0 ≤ m ∧ m<1*1 }}
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 0;;
  prefs: []
  type: TYPE_NORMAL
- en: (3)  {{ Z*Z ≤ m ∧ m<(Z+1)*(Z+1) }}
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (Z+1)*(Z+1) ≤ X DO
  prefs: []
  type: TYPE_NORMAL
- en: (4)    {{ Z*Z≤m ∧ (Z+1)*(Z+1)≤X }}  ⇾             (c - WRONG!)
  prefs: []
  type: TYPE_NORMAL
- en: (5)    {{ (Z+1)*(Z+1)≤m ∧ m<(Z+2)*(Z+2) }}
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z+1
  prefs: []
  type: TYPE_NORMAL
- en: (6)    {{ Z*Z≤m ∧ m<(Z+1)*(Z+1) }}
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: (7)  {{ Z*Z≤m ∧ m<(Z+1)*(Z+1) ∧ ~((Z+1)*(Z+1)≤X) }}  ⇾ (b - OK)
  prefs: []
  type: TYPE_NORMAL
- en: (8)  {{ Z*Z≤m ∧ m<(Z+1)*(Z+1) }}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '{{ X=m }}  ⇾                                      (a - OK)'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ 0*0 ≤ m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 0;
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ Z*Z ≤ m }}'
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (Z+1)*(Z+1) ≤ X DO
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ Z*Z≤m ∧ (Z+1)*(Z+1)≤X }}  ⇾        (c - OK)'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ (Z+1)*(Z+1)≤m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z+1
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ Z*Z≤m }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ Z*Z≤m ∧ X<(Z+1)*(Z+1) }}  ⇾           (b - OK)'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z*Z≤m ∧ m<(Z+1)*(Z+1) }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Squaring'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a program that squares X by repeated addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that the loop reads X but doesn't
  prefs: []
  type: TYPE_NORMAL
- en: change its value. As we saw in the previous example, it is a good idea
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in such cases to add X = m to the invariant.  The other thing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that we know is often useful in the invariant is the postcondition,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so let's add that too, leading to the invariant candidate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Z = m * m ∧ X = m.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Conditions (a) and (c) fail because of the Z = m*m part.  While
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Z starts at 0 and works itself up to m*m, we can't expect
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Z to be m*m from the start.  If we look at how Z progesses
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the loop, after the 1st iteration Z = m, after the 2nd
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: iteration Z = 2*m, and at the end Z = m*m.  Since the variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Y tracks how many times we go through the loop, this leads us to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'derive a new invariant candidate: Z = Y*m ∧ X = m.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This new invariant makes the proof go through: all three'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conditions are easy to check.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is worth comparing the postcondition Z = m*m and the Z =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Y*m conjunct of the invariant. It is often the case that one has
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to replace parameters with variables — or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with expressions involving both variables and parameters, like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: m - Y — when going from postconditions to invariants.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '{{ X = m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1 ;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0
  prefs: []
  type: TYPE_NORMAL
- en: DO
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y * X ;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Y = m! }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '{{ X = m }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0
  prefs: []
  type: TYPE_NORMAL
- en: DO   {{                                      }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y * X;;
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Y = m! }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: Min'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise: 3 starsM (Min_Hoare)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fill in valid decorations for the following program.
  prefs: []
  type: TYPE_NORMAL
- en: For the ⇒ steps in your annotations, you may rely (silently)
  prefs: []
  type: TYPE_NORMAL
- en: on the following facts about min
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: plus standard high-school algebra, as always.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: 3 starsM (two_loops)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is a very inefficient way of adding 3 numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Show that it does what it should by filling in the blanks in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: following decorated program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: X ::= 0;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ m DO
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 2 * Z;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y + Z;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X + 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Weakest Preconditions (Optional)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Hoare triples are more interesting than others.
  prefs: []
  type: TYPE_NORMAL
- en: For example,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'is *not* very interesting: although it is perfectly valid, it'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tells us nothing useful.  Since the precondition isn't satisfied
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by any state, it doesn't describe any situations where we can use
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the command X ::= Y + 1 to achieve the postcondition X ≤ 5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By contrast,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'is useful: it tells us that, if we can somehow create a situation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in which we know that Y ≤ 4 ∧ Z = 0, then running this command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: will produce a state satisfying the postcondition.  However, this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: triple is still not as useful as it could be, because the Z = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: clause in the precondition actually has nothing to do with the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postcondition X ≤ 5.  The *most* useful triple (for this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'command and postcondition) is this one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In other words, Y ≤ 4 is the *weakest* valid precondition of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the command X ::= Y + 1 for the postcondition X ≤ 5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, we say that "P is the weakest precondition of
  prefs: []
  type: TYPE_NORMAL
- en: command c for postcondition Q" if {{P}} c {{Q}} and if,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: whenever P' is an assertion such that {{P'}} c {{Q}}, it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the case that P' st implies P st for all states st.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That is, P is the weakest precondition of c for Q
  prefs: []
  type: TYPE_NORMAL
- en: if (a) P *is* a precondition for Q and c, and (b) P is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*weakest* (easiest to satisfy) assertion that guarantees that'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Q will hold after executing c.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, optional (wp)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What are the weakest preconditions of the following commands
  prefs: []
  type: TYPE_NORMAL
- en: for the following postconditions?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced, optional (is_wp_formal)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove formally, using the definition of hoare_triple, that Y ≤ 4
  prefs: []
  type: TYPE_NORMAL
- en: is indeed the weakest precondition of X ::= Y + 1 with respect to
  prefs: []
  type: TYPE_NORMAL
- en: postcondition X ≤ 5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, advanced, optional (hoare_asgn_weakest)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show that the precondition in the rule hoare_asgn is in fact the
  prefs: []
  type: TYPE_NORMAL
- en: weakest precondition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, advanced, optional (hoare_havoc_weakest)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show that your havoc_pre rule from the himp_hoare exercise
  prefs: []
  type: TYPE_NORMAL
- en: in the [Hoare](Hoare.html) chapter returns the weakest precondition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive dcom : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSkip :  Assertion → dcom'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSeq : dcom → dcom → dcom'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCAsgn : id → aexp →  Assertion → dcom'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCIf : bexp →  Assertion → dcom →  Assertion → dcom'
  prefs: []
  type: TYPE_NORMAL
- en: → Assertion→ dcom
  prefs: []
  type: TYPE_NORMAL
- en: '| DCWhile : bexp → Assertion → dcom → Assertion → dcom'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPre : Assertion → dcom → dcom'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPost : dcom → Assertion → dcom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive decorated : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated : Assertion → dcom → decorated.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'SKIP' {{ P }}"
  prefs: []
  type: TYPE_NORMAL
- en: := (DCSkip P)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 10) : dcom_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "l '::=' a {{ P }}"
  prefs: []
  type: TYPE_NORMAL
- en: := (DCAsgn l a P)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 60, a at next level) : dcom_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'WHILE' b 'DO' {{ Pbody }} d 'END' {{ Ppost }}"
  prefs: []
  type: TYPE_NORMAL
- en: := (DCWhile b Pbody d Ppost)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 80, right associativity) : dcom_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'IFB' b 'THEN' {{ P }} d 'ELSE' {{ P' }} d' 'FI' {{ Q }}"
  prefs: []
  type: TYPE_NORMAL
- en: := (DCIf b P d P' d' Q)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 80, right associativity)  : dcom_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'⇾' {{ P }} d"
  prefs: []
  type: TYPE_NORMAL
- en: := (DCPre P d)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 90, right associativity)  : dcom_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "d '⇾' {{ P }}"
  prefs: []
  type: TYPE_NORMAL
- en: := (DCPost d P)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 80, right associativity)  : dcom_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation " d ;; d' "
  prefs: []
  type: TYPE_NORMAL
- en: := (DCSeq d d')
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 80, right associativity)  : dcom_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "{{ P }} d"
  prefs: []
  type: TYPE_NORMAL
- en: := (Decorated P d)
  prefs: []
  type: TYPE_NORMAL
- en: '(at level 90)  : dcom_scope.'
  prefs: []
  type: TYPE_NORMAL
- en: Delimit Scope dcom_scope with dcom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Example dec_while : decorated := ('
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True }}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BNot (BEq (AId X) (ANum 0)))'
  prefs: []
  type: TYPE_NORMAL
- en: DO
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True ∧ st X ≠ 0}}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= (AMinus (AId X) (ANum 1))
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun _ ⇒ True }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True ∧ st X = 0}} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = 0 }}'
  prefs: []
  type: TYPE_NORMAL
- en: ) % dcom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint extract (d:dcom) : com :='
  prefs: []
  type: TYPE_NORMAL
- en: match d with
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSkip _           ⇒ SKIP'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSeq d[1] d[2]        ⇒ (extract d[1] ;; extract d[2])'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCAsgn X a _       ⇒ X ::= a'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCIf b _ d[1] _ d[2] _ ⇒ IFB b THEN extract d[1] ELSE extract d[2] FI'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCWhile b _ d _    ⇒ WHILE b DO extract d END'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPre _ d          ⇒ extract d'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPost d _         ⇒ extract d'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition extract_dec (dec : decorated) : com :='
  prefs: []
  type: TYPE_NORMAL
- en: match dec with
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated P d ⇒ extract d'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '{{P}} ({{P}} SKIP {{P}}) ;; ({{P}} SKIP {{P}}) {{P}},'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint post (d:dcom) : Assertion :='
  prefs: []
  type: TYPE_NORMAL
- en: match d with
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSkip P                ⇒ P'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSeq d[1] d[2]             ⇒ post d[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCAsgn X a Q            ⇒ Q'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCIf  _ _ d[1] _ d[2] Q     ⇒ Q'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCWhile b Pbody c Ppost ⇒ Ppost'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPre _ d               ⇒ post d'
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPost c Q              ⇒ Q'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition pre_dec (dec : decorated) : Assertion :='
  prefs: []
  type: TYPE_NORMAL
- en: match dec with
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated P d ⇒ P'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition post_dec (dec : decorated) : Assertion :='
  prefs: []
  type: TYPE_NORMAL
- en: match dec with
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated P d ⇒ post d'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition dec_correct (dec : decorated) :='
  prefs: []
  type: TYPE_NORMAL
- en: '{{pre_dec dec}} (extract_dec dec) {{post_dec dec}}.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint verification_conditions (P : Assertion) (d:dcom)'
  prefs: []
  type: TYPE_NORMAL
- en: ': Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: match d with
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSkip Q ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: (P ⇾ Q)
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSeq d[1] d[2] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: verification_conditions P d[1]
  prefs: []
  type: TYPE_NORMAL
- en: ∧ verification_conditions (post d[1]) d[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| DCAsgn X a Q ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: (P ⇾ Q [X ↦ a])
  prefs: []
  type: TYPE_NORMAL
- en: '| DCIf b P[1] d[1] P[2] d[2] Q ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: ((fun st ⇒ P st ∧ bassn b st) ⇾ P[1])
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ((fun st ⇒ P st ∧ ¬ (bassn b st)) ⇾ P[2])
  prefs: []
  type: TYPE_NORMAL
- en: ∧ (post d[1] ⇾ Q) ∧ (post d[2] ⇾ Q)
  prefs: []
  type: TYPE_NORMAL
- en: ∧ verification_conditions P[1] d[1]
  prefs: []
  type: TYPE_NORMAL
- en: ∧ verification_conditions P[2] d[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| DCWhile b Pbody d Ppost ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: (* post d is the loop invariant and the initial
  prefs: []
  type: TYPE_NORMAL
- en: precondition *)
  prefs: []
  type: TYPE_NORMAL
- en: (P ⇾ post d)
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ((fun st ⇒ post d st ∧ bassn b st) ⇾ Pbody)
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ((fun st ⇒ post d st ∧ ~(bassn b st)) ⇾ Ppost)
  prefs: []
  type: TYPE_NORMAL
- en: ∧ verification_conditions Pbody d
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPre P'' d ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: (P ⇾ P') ∧ verification_conditions P' d
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPost d Q ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: verification_conditions P d ∧ (post d ⇾ Q)
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem verification_correct : ∀d P,'
  prefs: []
  type: TYPE_NORMAL
- en: verification_conditions P d → {{P}} (extract d) {{post d}}.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: induction d; intros P H; simpl in *.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Skip *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre).
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_skip](Hoare.html#hoare_skip).
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Seq *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [H[1] H[2]]. clear H.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_seq](Hoare.html#hoare_seq).
  prefs: []
  type: TYPE_NORMAL
- en: apply IHd2. apply H[2].
  prefs: []
  type: TYPE_NORMAL
- en: apply IHd1. apply H[1].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Asgn *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre).
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_asgn](Hoare.html#hoare_asgn).
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* If *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [HPre1 [HPre2 [Hd[1] [Hd[2] [HThen HElse]]]]].
  prefs: []
  type: TYPE_NORMAL
- en: clear H.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHd1 in HThen. clear IHd1.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHd2 in HElse. clear IHd2.
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_if](Hoare.html#hoare_if).
  prefs: []
  type: TYPE_NORMAL
- en: + eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post) with (Q':=[post](Hoare2.html#post)
    d[1]); eauto.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre); eauto.
  prefs: []
  type: TYPE_NORMAL
- en: + eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post) with (Q':=[post](Hoare2.html#post)
    d[2]); eauto.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre); eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* While *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [Hpre [Hbody1 [Hpost1  Hd]]]. clear H.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre); eauto.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post); eauto.
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_while](Hoare.html#hoare_while).
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre); eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Pre *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [HP Hd]; clear H.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre). apply IHd.
    apply Hd. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Post *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [Hd HQ]; clear H.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post). apply IHd.
    apply Hd. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition verification_conditions_dec (dec : decorated) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: match dec with
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated P d ⇒ verification_conditions P d'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma verification_correct_dec : ∀dec,'
  prefs: []
  type: TYPE_NORMAL
- en: verification_conditions_dec dec → dec_correct dec.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros [P d]. apply verification_correct.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Eval simpl in (verification_conditions_dec dec_while).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: ⇒ (((fun _ : state ⇒ True) ⇾ (fun _ : state ⇒ True)) ∧
  prefs: []
  type: TYPE_NORMAL
- en: ((fun st : state ⇒ True ∧ bassn (BNot (BEq (AId X) (ANum 0))) st) ⇾
  prefs: []
  type: TYPE_NORMAL
- en: (fun st : state ⇒ True ∧ st X ≠ 0)) ∧
  prefs: []
  type: TYPE_NORMAL
- en: ((fun st : state ⇒ True ∧ ¬ bassn (BNot (BEq (AId X) (ANum 0))) st) ⇾
  prefs: []
  type: TYPE_NORMAL
- en: (fun st : state ⇒ True ∧ st X = 0)) ∧
  prefs: []
  type: TYPE_NORMAL
- en: (fun st : state ⇒ True ∧ st X ≠ 0) ⇾
  prefs: []
  type: TYPE_NORMAL
- en: (fun _ : state ⇒ True) [X ↦ AMinus (AId X) (ANum 1)]) ∧
  prefs: []
  type: TYPE_NORMAL
- en: (fun st : state ⇒ True ∧ st X = 0) ⇾ (fun st : state ⇒ st X = 0)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Tactic Notation "verify" :=
  prefs: []
  type: TYPE_NORMAL
- en: apply verification_correct;
  prefs: []
  type: TYPE_NORMAL
- en: repeat split;
  prefs: []
  type: TYPE_NORMAL
- en: simpl; unfold assert_implies;
  prefs: []
  type: TYPE_NORMAL
- en: unfold bassn in *; unfold beval in *; unfold aeval in *;
  prefs: []
  type: TYPE_NORMAL
- en: unfold assn_sub; intros;
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite t_update_eq;
  prefs: []
  type: TYPE_NORMAL
- en: repeat (rewrite t_update_neq; [| (intro X; inversion X)]);
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *;
  prefs: []
  type: TYPE_NORMAL
- en: 'repeat match goal with [H : _ ∧ _ ⊢ _] ⇒ destruct H end;'
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite not_true_iff_false in *;
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite not_false_iff_true in *;
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite negb_true_iff in *;
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite negb_false_iff in *;
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite beq_nat_true_iff in *;
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite beq_nat_false_iff in *;
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite leb_iff in *;
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite leb_iff_conv in *;
  prefs: []
  type: TYPE_NORMAL
- en: try subst;
  prefs: []
  type: TYPE_NORMAL
- en: repeat
  prefs: []
  type: TYPE_NORMAL
- en: match goal with
  prefs: []
  type: TYPE_NORMAL
- en: '[st : state ⊢ _] ⇒'
  prefs: []
  type: TYPE_NORMAL
- en: match goal with
  prefs: []
  type: TYPE_NORMAL
- en: '[H : st _ = _ ⊢ _] ⇒ rewrite → H in *; clear H'
  prefs: []
  type: TYPE_NORMAL
- en: '| [H : _ = st _ ⊢ _] ⇒ rewrite ← H in *; clear H'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end;
  prefs: []
  type: TYPE_NORMAL
- en: try eauto; try omega.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem dec_while_correct :'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct dec_while.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. verify. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Example subtract_slowly_dec (m:nat) (p:nat) : decorated := ('
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Z = p }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z - st X = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId X) (ANum 0))'
  prefs: []
  type: TYPE_NORMAL
- en: DO   {{ fun st ⇒ st Z - st X = p - m ∧ st X ≠ 0 }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z - 1) - (st X - 1) = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMinus (AId Z) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z - (st X - 1) = p - m }} ;;'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z - st X = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z - st X = p - m ∧ st X = 0 }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = p - m }}'
  prefs: []
  type: TYPE_NORMAL
- en: ) % dcom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem subtract_slowly_dec_correct : ∀m p,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (subtract_slowly_dec m p).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros m p. verify. (* this grinds for a bit! *) Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition swap : com :='
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (AId Y);;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId X) (AId Y);;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (AId Y).
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition swap_dec m n : decorated :='
  prefs: []
  type: TYPE_NORMAL
- en: ({{ fun st ⇒ st X = m ∧ st Y = n}} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X + st Y) - ((st X + st Y) - st Y) = n'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ (st X + st Y) - st Y = m }}
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (AId Y)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X - (st X - st Y) = n ∧ st X - st Y = m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId X) (AId Y)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X - st Y = n ∧ st Y = m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (AId Y)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = n ∧ st Y = m}})%dcom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem swap_correct : ∀m n,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (swap_dec m n).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros; verify. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Definition if_minus_plus_com :=
  prefs: []
  type: TYPE_NORMAL
- en: IFB (BLe (AId X) (AId Y))
  prefs: []
  type: TYPE_NORMAL
- en: THEN (Z ::= AMinus (AId Y) (AId X))
  prefs: []
  type: TYPE_NORMAL
- en: ELSE (Y ::= APlus (AId X) (AId Z))
  prefs: []
  type: TYPE_NORMAL
- en: FI.
  prefs: []
  type: TYPE_NORMAL
- en: Definition if_minus_plus_dec :=
  prefs: []
  type: TYPE_NORMAL
- en: ({{fun st ⇒ True}}
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''ELSE''_''{{''_x_''}}''_x_''FI''_''{{''_x_''}}''">IFB (BLe
    (AId X) (AId Y)) THEN'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True ∧ st X ≤ st Y }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = st X + (st Y - st X) }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMinus (AId Y) (AId X)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = st X + st Z }}'
  prefs: []
  type: TYPE_NORMAL
- en: ELSE
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True ∧ ~(st X ≤ st Y) }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X + st Z = st X + st Z }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId X) (AId Z)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = st X + st Z }}'
  prefs: []
  type: TYPE_NORMAL
- en: FI
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st Y = st X + st Z}})%dcom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem if_minus_plus_correct :'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct if_minus_plus_dec.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros; verify. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Definition if_minus_dec :=
  prefs: []
  type: TYPE_NORMAL
- en: ( {{fun st ⇒ True}}
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''ELSE''_''{{''_x_''}}''_x_''FI''_''{{''_x_''}}''">IFB (BLe
    (AId X) (AId Y)) THEN'
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ True ∧ st X ≤ st Y }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ (st Y - st X) + st X = st Y'
  prefs: []
  type: TYPE_NORMAL
- en: ∨ (st Y - st X) + st Y = st X}}
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMinus (AId Y) (AId X)
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}}'
  prefs: []
  type: TYPE_NORMAL
- en: ELSE
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ True ∧ ~(st X ≤ st Y) }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ (st X - st Y) + st X = st Y'
  prefs: []
  type: TYPE_NORMAL
- en: ∨ (st X - st Y) + st Y = st X}}
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMinus (AId X) (AId Y)
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}}'
  prefs: []
  type: TYPE_NORMAL
- en: FI
  prefs: []
  type: TYPE_NORMAL
- en: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}})%dcom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem if_minus_correct :'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct if_minus_dec.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. verify. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition div_mod_dec (a b : nat) : decorated := ('
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * 0 + a = a }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum a
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * 0 + st X = a }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * st Y + st X = a }};;'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BLe (ANum b) (AId X)) DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * st Y + st X = a ∧ b ≤ st X }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * (st Y + 1) + (st X - b) = a }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum b)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * (st Y + 1) + st X = a }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId Y) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * st Y + st X = a }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * st Y + st X = a ∧ ~(b ≤ st X) }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ b * st Y + st X = a ∧ (st X < b) }}'
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem div_mod_dec_correct : ∀a b,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (div_mod_dec a b).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros a b. verify.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite mult_plus_distr_l. omega.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition find_parity : com :='
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (BLe (ANum 2) (AId X)) DO
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 2)
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive ev : nat → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ev_0 : ev O'
  prefs: []
  type: TYPE_NORMAL
- en: '| ev_SS : ∀n:nat, ev n → ev (S (S n)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition find_parity_dec m : decorated :='
  prefs: []
  type: TYPE_NORMAL
- en: ({{ fun st ⇒ st X = m}} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X ≤ m ∧ ev (m - st X) }}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BLe (ANum 2) (AId X)) DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X ≤ m ∧ ev (m - st X)) ∧ 2 ≤ st X }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X - 2 ≤ m ∧ (ev (m - (st X - 2))) }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 2)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X ≤ m ∧ ev (m - st X) }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X ≤ m ∧ ev (m - st X)) ∧ st X < 2 }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X=0 ↔ ev m }})%dcom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[1] : ∀m n p,'
  prefs: []
  type: TYPE_NORMAL
- en: p ≤ n →
  prefs: []
  type: TYPE_NORMAL
- en: n ≤ m →
  prefs: []
  type: TYPE_NORMAL
- en: m - (n - p) = m - n + p.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. omega. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[2] : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: ev m →
  prefs: []
  type: TYPE_NORMAL
- en: ev (m + 2).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. rewrite plus_comm. simpl. constructor. assumption. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[3]'' : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: ev m →
  prefs: []
  type: TYPE_NORMAL
- en: ¬ev (S m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. induction m; intros H[1] H[2]. inversion H[2]. apply IHm.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[2]; subst; assumption. assumption. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[3] : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: 1 ≤ m →
  prefs: []
  type: TYPE_NORMAL
- en: ev m →
  prefs: []
  type: TYPE_NORMAL
- en: ev (m - 1) →
  prefs: []
  type: TYPE_NORMAL
- en: False.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. apply l[2] in H[1].
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (G : m - 1 + 2 = S m). clear H[0] H[1]. omega.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite G in H[1]. apply l[3]' in H[0]. apply H[0]. assumption. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem find_parity_correct : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (find_parity_dec m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intro m. verify;
  prefs: []
  type: TYPE_NORMAL
- en: (* simplification too aggressive ... reverting a bit *)
  prefs: []
  type: TYPE_NORMAL
- en: fold (leb 2 (st X)) in *;
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff in *;
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff_conv in *; eauto; try omega.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant holds initially *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite minus_diag. constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite l[1]; try assumption.
  prefs: []
  type: TYPE_NORMAL
- en: apply l[2]; assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough to imply conclusion'
  prefs: []
  type: TYPE_NORMAL
- en: (-> direction) *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← minus_n_O in H[2]. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough to imply conclusion'
  prefs: []
  type: TYPE_NORMAL
- en: (<- direction) *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct (st X) as [| [| n]].
  prefs: []
  type: TYPE_NORMAL
- en: (* by H[1] X can only be 0 or 1 *)
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 0 *)
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 1 *)
  prefs: []
  type: TYPE_NORMAL
- en: apply l[3] in H; try assumption. inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 2 *)
  prefs: []
  type: TYPE_NORMAL
- en: clear H[0] H[2]. (* omega confused otherwise *)
  prefs: []
  type: TYPE_NORMAL
- en: omega.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition find_parity_dec'' m : decorated :='
  prefs: []
  type: TYPE_NORMAL
- en: ({{ fun st ⇒ st X = m}} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ ev (st X) ↔ ev m }}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BLe (ANum 2) (AId X)) DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (ev (st X) ↔ ev m) ∧ 2 ≤ st X }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (ev (st X - 2) ↔ ev m) }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 2)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (ev (st X) ↔ ev m) }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (ev (st X) ↔ ev m) ∧ ~(2 ≤ st X) }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X=0 ↔ ev m }})%dcom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[4] : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: 2 ≤ m →
  prefs: []
  type: TYPE_NORMAL
- en: (ev (m - 2) ↔ ev m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: induction m; intros. split; intro; constructor.
  prefs: []
  type: TYPE_NORMAL
- en: destruct m. inversion H. inversion H[1]. simpl in *.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← minus_n_O in *. split; intro.
  prefs: []
  type: TYPE_NORMAL
- en: constructor. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0]. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem find_parity_correct'' : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (find_parity_dec' m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros m. verify;
  prefs: []
  type: TYPE_NORMAL
- en: (* simplification too aggressive ... reverting a bit *)
  prefs: []
  type: TYPE_NORMAL
- en: fold (leb 2 (st X)) in *;
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff in *;
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff_conv in *; intuition; eauto; try omega.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved (part 1) *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite l[4] in H[0]; eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved (part 2) *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite l[4]; eauto.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough to imply conclusion'
  prefs: []
  type: TYPE_NORMAL
- en: (-> direction) *)
  prefs: []
  type: TYPE_NORMAL
- en: apply H[0]. constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough to imply conclusion'
  prefs: []
  type: TYPE_NORMAL
- en: (<- direction) *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct (st X) as [| [| n]]. (* by H[1] X can only be 0 or 1 *)
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 0 *)
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 1 *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 2 *)
  prefs: []
  type: TYPE_NORMAL
- en: clear H[0] H H[3]. (* omega confused otherwise *)
  prefs: []
  type: TYPE_NORMAL
- en: omega.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition parity_dec m : decorated :='
  prefs: []
  type: TYPE_NORMAL
- en: ({{ fun st ⇒ st X = m}} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X) = parity m }}'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BLe (ANum 2) (AId X)) DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X) = parity m ∧ 2 ≤ st X }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X - 2) = parity m }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 2)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X) = parity m }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X) = parity m ∧ ~(2 ≤ st X) }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = parity m }})%dcom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem parity_dec_correct : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (parity_dec m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. verify;
  prefs: []
  type: TYPE_NORMAL
- en: (* simplification too aggressive ... reverting a bit *)
  prefs: []
  type: TYPE_NORMAL
- en: fold (leb 2 (st X)) in *;
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff in *;
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff_conv in *; eauto; try omega.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H. apply parity_ge_2. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H. symmetry. apply parity_lt_2. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition sqrt_dec m : decorated := ('
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ 0*0 ≤ m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Z*st Z ≤ m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BLe (AMult (APlus (AId Z) (ANum
    1))'
  prefs: []
  type: TYPE_NORMAL
- en: (APlus (AId Z) (ANum 1)))
  prefs: []
  type: TYPE_NORMAL
- en: (AId X) DO
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X = m ∧ st Z*st Z≤m)'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ (st Z + 1)*(st Z + 1) ≤ st X }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ (st Z+1)*(st Z+1)≤m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Z*st Z≤m }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X = m ∧ st Z*st Z≤m)'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ~((st Z + 1)*(st Z + 1) ≤ st X) }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z*st Z≤m ∧ m<(st Z+1)*(st Z+1) }})%dcom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem sqrt_correct : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (sqrt_dec m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intro m. verify. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition square_dec (m : nat) : decorated := ('
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AId X
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Y = m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Y = m ∧ st Z = 0}} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * st Y = m * m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId Y) (ANum 0))
    DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * st Y = m * m ∧ st Y ≠ 0 }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z + st X) + st X * (st Y - 1) = m * m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (AId X)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * (st Y - 1) = m * m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId Y) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * st Y = m * m }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * st Y = m * m ∧ st Y = 0 }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = m * m }}'
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem square_dec_correct : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (square_dec m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intro n. verify.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct (st Y) as [| y']. apply False_ind. apply H[0].
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite ← minus_n_O.
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (G : ∀n m, n * S m = n + n * m). {'
  prefs: []
  type: TYPE_NORMAL
- en: clear. intros. induction n. reflexivity. simpl.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite IHn. omega. }
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H. rewrite G. rewrite plus_assoc. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition square_dec'' (n : nat) : decorated := ('
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum n
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = n }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AId X
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = n ∧ st Y = n }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = n ∧ st Y = n ∧ st Z = 0 }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X * (st X - st Y)'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X }};;
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId Y) (ANum 0))
    DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = st X * (st X - st Y)'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X)
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Y ≠ 0 }}
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (AId X)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X * (st X - (st Y - 1))'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X }};;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId Y) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X * (st X - st Y)'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X }}
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = st X * (st X - st Y)'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X)
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Y = 0 }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = n * n }}'
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem square_dec''_correct : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (square_dec' n).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intro n. verify.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant holds initially *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite minus_diag. omega.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved *) subst.'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite mult_minus_distr_l.
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite mult_minus_distr_l. rewrite mult_1_r.
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (G : ∀n m p,'
  prefs: []
  type: TYPE_NORMAL
- en: m ≤ n → p ≤ m → n - (m - p) = n - m + p).
  prefs: []
  type: TYPE_NORMAL
- en: intros. omega.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite G. reflexivity. apply mult_le_compat_l. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (st Y). apply False_ind. apply H[0]. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: clear. rewrite mult_succ_r. rewrite plus_comm.
  prefs: []
  type: TYPE_NORMAL
- en: apply le_plus_l.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant + negation of guard imply'
  prefs: []
  type: TYPE_NORMAL
- en: desired postcondition *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← minus_n_O. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition square_simpler_dec (m : nat) : decorated := ('
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ 0 = 0*m ∧ st X = m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ 0 = (st Y)*m ∧ st X = m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = (st Y)*m ∧ st X = m }}⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = (st Y)*m ∧ st X = m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId Y) (AId X)) DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = (st Y)*m ∧ st X = m)'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Y ≠ st X }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X = ((st Y) + 1)*m ∧ st X = m }}'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (AId X)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = ((st Y) + 1)*m ∧ st X = m }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId Y) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = (st Y)*m ∧ st X = m }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = (st Y)*m ∧ st X = m) ∧ st Y = st X }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = m*m }}'
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem square_simpler_dec_correct : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (square_simpler_dec m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intro m. verify.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite mult_plus_distr_r. simpl. rewrite ← plus_n_O.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition two_loops_dec (a b c : nat) : decorated :='
  prefs: []
  type: TYPE_NORMAL
- en: ( {{ fun st ⇒ True }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ c = 0 + c ∧ 0 = 0 }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ c = st X + c ∧ 0 = 0 }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ c = st X + c ∧ st Y = 0 }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum c
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X + c ∧ st Y = 0 }};;'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId X) (ANum a))
    DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = st X + c ∧ st Y = 0) ∧ st X ≠ a }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + 1 = st X + 1 + c ∧ st Y = 0 }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + 1 = st X + c ∧ st Y = 0 }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X + c ∧ st Y = 0 }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = st X + c ∧ st Y = 0) ∧ st X = a }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = a + st Y + c }};;'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId Y) (ANum b))
    DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = a + st Y + c ∧ st Y ≠ b }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + 1 = a + st Y + 1 + c }}'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId Y) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + 1 = a + st Y + c }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = a + st Y + c }}'
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = a + st Y + c) ∧ st Y = b }} ⇾'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = a + b + c }}'
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem two_loops_correct : ∀a b c,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (two_loops_dec a b c).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros a b c. verify. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Fixpoint pow2 n :=
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ 2 * (pow2 n'')'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Definition dpow2_down n :=
  prefs: []
  type: TYPE_NORMAL
- en: ( {{ fun st ⇒ True }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ 1 = (pow2 (0 + 1))-1 ∧ 1 = pow2 0 }}'
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum 0
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ 1 = (pow2 (0 + 1))-1 ∧ 1 = pow2 (st X) }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 1
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = (pow2 (st X + 1))-1 ∧ 1 = pow2 (st X) }};;'
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 1
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = (pow2 (st X + 1))-1 ∧ st Z = pow2 (st X) }};;'
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId X) (ANum n))
    DO'
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Y = (pow2 (st X + 1))-1 ∧ st Z = pow2 (st X))'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X ≠ n }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y + 2 * st Z = (pow2 (st X + 2))-1'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ 2 * st Z = pow2 (st X + 1) }}
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMult (ANum 2) (AId Z)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y + st Z = (pow2 (st X + 2))-1'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Z = pow2 (st X + 1) }};;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId Y) (AId Z)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = (pow2 (st X + 2))-1'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Z = pow2 (st X + 1) }};;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = (pow2 (st X + 1))-1'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Z = pow2 (st X) }}
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Y = (pow2 (st X + 1))-1 ∧ st Z = pow2 (st X))'
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n }} ⇾
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = pow2 (n+1) - 1 }}'
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma pow2_plus_1 : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: pow2 (n+1) = pow2 n + pow2 n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. induction n; simpl. reflexivity. omega. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma pow2_le_1 : ∀n, pow2 n ≥ 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. induction n. simpl. constructor. simpl. omega. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem dpow2_down_correct : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (dpow2_down n).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intro m. verify.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 1 *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite pow2_plus_1. rewrite ← H[0]. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 2 *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← plus_n_O.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pow2_plus_1. remember (st X) as n.
  prefs: []
  type: TYPE_NORMAL
- en: replace (pow2 (n + 1) - 1 + pow2 (n + 1))
  prefs: []
  type: TYPE_NORMAL
- en: with (pow2 (n + 1) + pow2 (n + 1) - 1) by omega.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pow2_plus_1.
  prefs: []
  type: TYPE_NORMAL
- en: replace (n + 1 + 1) with (n + 2) by omega.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 3 *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← plus_n_O. rewrite ← pow2_plus_1.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 4 *)'
  prefs: []
  type: TYPE_NORMAL
- en: replace (st X + 1 + 1) with (st X + 2) by omega.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Example slow_assignment_dec (m:nat) : decorated'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem slow_assignment_dec_correct : ∀m,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (slow_assignment_dec m).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint real_fact (n:nat) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ n * (real_fact n'')'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Fixpoint fib n :=
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| _ ⇒ fib (pred n) + fib (pred (pred n))'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Fixpoint fib n :=
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ match n'' with'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ 1'
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'''' ⇒ fib n'' + fib n'''''
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma fib_eqn : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: n > 0 →
  prefs: []
  type: TYPE_NORMAL
- en: fib n + fib (Init.Nat.pred n) = fib (n + 1).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: X ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ n+1 DO
  prefs: []
  type: TYPE_NORMAL
- en: T ::= Z;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z + Y;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= T;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X + 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '{{True}} dfib {{ Y = fib n }}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition T : id := Id "T".'
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition dfib (n:nat) : decorated'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem dfib_correct : ∀n,'
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (dfib n).
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
