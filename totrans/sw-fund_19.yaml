- en: Hoare2Hoare Logic, Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hoare2Hoare逻辑，第二部分
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Import Coq.Bool.Bool.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Bool.Bool.
- en: Require Import Coq.Arith.Arith.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Arith.Arith.
- en: Require Import Coq.Arith.EqNat.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Arith.EqNat.
- en: Require Import Coq.omega.Omega.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.omega.Omega.
- en: Require Import Maps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Maps.
- en: Require Import Imp.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Imp.
- en: Require Import Hoare.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Hoare.
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: X ::= m;;
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= m;;
- en: Z ::= p;
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= p;
- en: WHILE X ≠ 0 DO
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE X ≠ 0 DO
- en: Z ::= Z - 1;;
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= Z - 1;;
- en: X ::= X - 1
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= X - 1
- en: END
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '{{ True }}'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ True }}'
- en: X ::= m;;
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= m;;
- en: Z ::= p;
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= p;
- en: WHILE X ≠ 0 DO
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE X ≠ 0 DO
- en: Z ::= Z - 1;;
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= Z - 1;;
- en: X ::= X - 1
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= X - 1
- en: END
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: '{{ Z = p - m }}'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ Z = p - m }}'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '{{ True }} ⇾'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ True }} ⇾'
- en: '{{ m = m }}'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ m = m }}'
- en: X ::= m;;
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= m;;
- en: '{{ X = m }} ⇾'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ X = m }} ⇾'
- en: '{{ X = m ∧ p = p }}'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ X = m ∧ p = p }}'
- en: Z ::= p;
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= p;
- en: '{{ X = m ∧ Z = p }} ⇾'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ X = m ∧ Z = p }} ⇾'
- en: '{{ Z - X = p - m }}'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ Z - X = p - m }}'
- en: WHILE X ≠ 0 DO
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE X ≠ 0 DO
- en: '{{ Z - X = p - m ∧ X ≠ 0 }} ⇾'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ Z - X = p - m ∧ X ≠ 0 }} ⇾'
- en: '{{ (Z - 1) - (X - 1) = p - m }}'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ (Z - 1) - (X - 1) = p - m }}'
- en: Z ::= Z - 1;;
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= Z - 1;;
- en: '{{ Z - (X - 1) = p - m }}'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ Z - (X - 1) = p - m }}'
- en: X ::= X - 1
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= X - 1
- en: '{{ Z - X = p - m }}'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ Z - X = p - m }}'
- en: END
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: '{{ Z - X = p - m ∧ ¬ (X ≠ 0) }} ⇾ {{ Z = p - m }}'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ Z - X = p - m ∧ ¬ (X ≠ 0) }} ⇾ {{ Z = p - m }}'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '{{ P }} SKIP {{ P }}'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }} SKIP {{ P }}'
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '{{ P }} c[1];; {{ Q }} c[2] {{ R }}'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }} c[1];; {{ Q }} c[2] {{ R }}'
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '{{ P [X ↦ a] }}'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P [X ↦ a] }}'
- en: X ::= a
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: X ::= a
- en: '{{ P }}'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }}'
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '{{ P }}'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }}'
- en: IFB b THEN
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IFB b THEN
- en: '{{ P ∧ b }}'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P ∧ b }}'
- en: c[1]
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c[1]
- en: '{{ Q }}'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ Q }}'
- en: ELSE
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ELSE
- en: '{{ P ∧ ¬b }}'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P ∧ ¬b }}'
- en: c[2]
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c[2]
- en: '{{ Q }}'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ Q }}'
- en: FI
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FI
- en: '{{ Q }}'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ Q }}'
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '{{ P }}'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }}'
- en: WHILE b DO
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WHILE b DO
- en: '{{ P ∧ b }}'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P ∧ b }}'
- en: c[1]
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c[1]
- en: '{{ P }}'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }}'
- en: END
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: END
- en: '{{ P ∧ ¬b }}'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P ∧ ¬b }}'
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '{{ P }} ⇾'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P }} ⇾'
- en: '{{ P'' }}'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{{ P'' }}'
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Example: Swapping Using Addition and Subtraction'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子：使用加法和减法交换
- en: Here is a program that swaps the values of two variables using
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用加法和减法交换两个变量值的程序
- en: addition and subtraction (instead of by assigning to a temporary
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加法和减法（而不是通过分配给临时变量
- en: variable).
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量)。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can prove using decorations that this program is correct —
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用装饰证明这个程序是正确的 —
- en: i.e., it always swaps the values of variables X and Y.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，它总是交换变量X和Y的值。
- en: '['
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: (1)     {{ X = m ∧ Y = n }} ⇾
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (1)     {{ X = m ∧ Y = n }} ⇾
- en: (2)     {{ (X + Y) - ((X + Y) - Y) = n ∧ (X + Y) - Y = m }}
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (2)     {{ (X + Y) - ((X + Y) - Y) = n ∧ (X + Y) - Y = m }}
- en: X ::= X + Y;;
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: X ::= X + Y;;
- en: (3)     {{ X - (X - Y) = n ∧ X - Y = m }}
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (3)     {{ X - (X - Y) = n ∧ X - Y = m }}
- en: Y ::= X - Y;;
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Y ::= X - Y;;
- en: (4)     {{ X - Y = n ∧ Y = m }}
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (4)     {{ X - Y = n ∧ Y = m }}
- en: X ::= X - Y
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: X ::= X - Y
- en: (5)     {{ X = n ∧ Y = m }}
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (5)     {{ X = n ∧ Y = m }}
- en: ']'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: 'These decorations can be constructed as follows:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些装饰可以按以下方式构建：
- en: We begin with the undecorated program (the unnumbered lines).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从未装饰的程序开始（未编号的行）。
- en: We add the specification — i.e., the outer precondition (1)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加规范 — 即，外部前置条件(1)
- en: and postcondition (5). In the precondition we use parameters
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和后置条件(5)。在前置条件中，我们使用参数
- en: m and n to remember the initial values of variables X
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: m和n以记住变量X的初始值
- en: and Y, so that we can refer to them in the
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和Y，这样我们可以在
- en: postcondition (5).
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后置条件(5)。
- en: We work backwards mechanically, starting from (5) and
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从(5)开始机械地向后工作，并
- en: proceeding until we get to (2). At each step, we obtain the
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继续，直到我们到达(2)。在每一步中，我们获得
- en: precondition of the assignment from its postcondition by
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从其后置条件到前置条件
- en: substituting the assigned variable with the right-hand-side of
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过用右侧替换分配变量
- en: the assignment. For instance, we obtain (4) by substituting
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分配。例如，我们通过替换获得(4)
- en: X with X - Y in (5), and (3) by substituting Y with X -
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: X用X - Y替换在(5)中，并通过用X -替换Y
- en: Y in (4).
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Y在(4)中。
- en: Finally, we verify that (1) logically implies (2) — i.e.,
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们验证(1)逻辑上蕴含(2) — 即，
- en: that the step from (1) to (2) is a valid use of the law of
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从(1)到(2)是法则的有效使用
- en: consequence. For this we substitute X by m and Y by n
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果。为此，我们将X替换为m，Y替换为n
- en: 'and calculate as follows:'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并计算如下：
- en: '[PRE12]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that, since we are working with natural numbers rather than
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，由于我们使用自然数而不是
- en: fixed-width machine integers, we don't need to worry about the
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 固定宽度的机器整数，我们不需要担心
- en: possibility of arithmetic overflow anywhere in this argument.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个论点中的任何地方都有算术溢出的可能性。
- en: This makes life quite a bit simpler!
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使生活变得简单多了！
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (1)     {{True}}
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: (1)     {{True}}
- en: IFB X ≤ Y THEN
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: IFB X ≤ Y THEN
- en: (2)       {{True ∧ X ≤ Y}} ⇾
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: (2)       {{True ∧ X ≤ Y}} ⇾
- en: (3)       {{(Y - X) + X = Y ∨ (Y - X) + Y = X}}
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: (3)       {{(Y - X) + X = Y ∨ (Y - X) + Y = X}}
- en: Z ::= Y - X
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= Y - X
- en: (4)       {{Z + X = Y ∨ Z + Y = X}}
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (4)       {{Z + X = Y ∨ Z + Y = X}}
- en: ELSE
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE
- en: (5)       {{True ∧ ~(X ≤ Y) }} ⇾
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (5)       {{True ∧ ~(X ≤ Y) }} ⇾
- en: (6)       {{(X - Y) + X = Y ∨ (X - Y) + Y = X}}
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: (6)       {{(X - Y) + X = Y ∨ (X - Y) + Y = X}}
- en: Z ::= X - Y
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= X - Y
- en: (7)       {{Z + X = Y ∨ Z + Y = X}}
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: (7)       {{Z + X = Y ∨ Z + Y = X}}
- en: FI
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: FI
- en: (8)     {{Z + X = Y ∨ Z + Y = X}}
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (8)     {{Z + X = Y ∨ Z + Y = X}}
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '{{ True }}'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ True }}'
- en: IFB X ≤ Y THEN
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: IFB X ≤ Y THEN
- en: '{{                         }} ⇾'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Y - X
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: ELSE
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }} ⇾'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }}'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= X + Z
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '{{                         }}'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: FI
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Y = X + Z }}'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Example: Reduce to Zero'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a WHILE loop that is so simple it needs no
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: invariant (i.e., the invariant True will do the job).
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The decorations can be constructed as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Start with the outer precondition (1) and postcondition (6).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the format dictated by the hoare_while rule, we
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: copy (1) to (4). We conjoin (1) with the guard to obtain (2) and
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: with the negation of the guard to obtain (5). Note that, because
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: the outer postcondition (6) does not syntactically match (5), we
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: need a trivial use of the consequence rule from (5) to (6).
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Assertion (3) is the same as (4), because X does not appear in
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4, so the substitution in the assignment rule is trivial.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, the implication between (2) and (3) is also trivial.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From this informal proof, it is easy to read off a formal proof
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: using the Coq versions of the Hoare rules.  Note that we do *not*
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold the definition of hoare_triple anywhere in this proof —
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the idea is to use the Hoare rules as a "self-contained" logic for
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reasoning about programs.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Example: Division'
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following Imp program calculates the integer quotient and
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: remainder of two numbers m and n that are arbitrary constants
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the program.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In we replace m and n by concrete numbers and execute the
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: program, it will terminate with the variable X set to the
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: remainder when m is divided by n and Y set to the
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: quotient.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to give a specification to this program we need to
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: remember that dividing m by n produces a reminder X and a
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: quotient Y such that n * Y + X = m ∧ X < n.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It turns out that we get lucky with this program and don't have to
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'think very hard about the loop invariant: the invariant is just'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the first conjunct n * Y + X = m, and we can use this to
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: decorate the program.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Assertions (4), (5), (8), and (9) are derived mechanically from
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the invariant and the loop's guard.  Assertions (8), (7), and (6)
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are derived using the assignment rule going backwards from (8)
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to (6).  Assertions (4), (3), and (2) are again backwards
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: applications of the assignment rule.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we've decorated the program it only remains to check that
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the two uses of the consequence rule are correct — i.e., that (1)
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: implies (2) and that (5) implies (6).  This is indeed the case, so
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we have a valid decorated program.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '{{ X = m ∧ Y = n }}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Y = n - m }}'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: (1)      {{ X = m ∧ Y = n }}  ⇾             (a)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: (2)      {{ I }}
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: (3)        {{ I ∧ X ≠ 0 }}  ⇾              (c)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: (4)        {{ I [X ↦ X-1] [Y ↦ Y-1] }}
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: (5)        {{ I [X ↦ X-1] }}
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: (6)        {{ I }}
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: (7)      {{ I ∧ ¬ (X ≠ 0) }}  ⇾            (b)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: (8)      {{ Y = n - m }}
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: (1)      {{ X = m ∧ Y = n }} ⇾       (a - OK)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: (2)      {{ True }}
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: (3)        {{ True ∧ X ≠ 0 }}  ⇾    (c - OK)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: (4)        {{ True }}
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: (5)        {{ True }}
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: (6)        {{ True }}
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: (7)      {{ True ∧ X = 0 }}  ⇾       (b - WRONG!)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: (8)      {{ Y = n - m }}
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: (1)      {{ X = m ∧ Y = n }}  ⇾          (a - WRONG!)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: (2)      {{ Y = n - m }}
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: (3)        {{ Y = n - m ∧ X ≠ 0 }}  ⇾   (c - WRONG!)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: (4)        {{ Y - 1 = n - m }}
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: (5)        {{ Y = n - m }}
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: (6)        {{ Y = n - m }}
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: (7)      {{ Y = n - m ∧ X = 0 }}  ⇾      (b - OK)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: (8)      {{ Y = n - m }}
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: (1)      {{ X = m ∧ Y = n }}  ⇾               (a - OK)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: (2)      {{ Y - X = n - m }}
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0 DO
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: (3)        {{ Y - X = n - m ∧ X ≠ 0 }}  ⇾    (c - OK)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: (4)        {{ (Y - 1) - (X - 1) = n - m }}
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1;;
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: (5)        {{ Y - (X - 1) = n - m }}
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: (6)        {{ Y - X = n - m }}
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: (7)      {{ Y - X = n - m ∧ X = 0 }}  ⇾       (b - OK)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: (8)      {{ Y = n - m }}
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Exercise: Slow Assignment'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise: 2 starsM (slow_assignment)'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A roundabout way of assigning a number currently stored in X to
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: the variable Y is to start Y at 0, then decrement X until
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it hits 0, incrementing Y at each step. Here is a program that
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'implements this idea:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Write an informal decorated program showing that this procedure
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is correct.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ☐
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: WHILE X ≠ 0 DO
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z + 1;;
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: (* FILL IN HERE *)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Example: Parity'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is a cute little program for computing the parity of the
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: value initially stored in X (due to Daniel Cristofani).
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The mathematical parity function used in the specification is
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'defined in Coq as follows:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The postcondition does not hold at the beginning of the loop,
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: since m = parity m does not hold for an arbitrary m, so we
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cannot use that as an invariant.  To find an invariant that works,
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let's think a bit about what this loop does.  On each iteration it
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: decrements X by 2, which preserves the parity of X.  So the
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parity of X does not change, i.e., it is invariant.  The initial
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: value of X is m, so the parity of X is always equal to the
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parity of m. Using parity X = parity m as an invariant we
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'obtain the following decorated program:'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this invariant, conditions (a), (b), and (c) are all
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: satisfied. For verifying (b), we observe that, when X < 2, we
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have parity X = X (we can easily see this in the definition of
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parity).  For verifying (c), we observe that, when 2 ≤ X, we
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have parity X = parity (X-2).
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (parity_formal)'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Translate this proof to Coq. Refer to the reduce_to_zero example
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'for ideas. You may find the following two lemmas useful:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ☐
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '{{ X=m }}'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 0;;
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (Z+1)*(Z+1) ≤ X DO
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z+1
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z*Z≤m ∧ m<(Z+1)*(Z+1) }}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: (1)  {{ X=m }}  ⇾           (a - second conjunct of (2) WRONG!)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: (2)  {{ 0*0 ≤ m ∧ m<1*1 }}
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 0;;
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: (3)  {{ Z*Z ≤ m ∧ m<(Z+1)*(Z+1) }}
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (Z+1)*(Z+1) ≤ X DO
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: (4)    {{ Z*Z≤m ∧ (Z+1)*(Z+1)≤X }}  ⇾             (c - WRONG!)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: (5)    {{ (Z+1)*(Z+1)≤m ∧ m<(Z+2)*(Z+2) }}
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z+1
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: (6)    {{ Z*Z≤m ∧ m<(Z+1)*(Z+1) }}
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: (7)  {{ Z*Z≤m ∧ m<(Z+1)*(Z+1) ∧ ~((Z+1)*(Z+1)≤X) }}  ⇾ (b - OK)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: (8)  {{ Z*Z≤m ∧ m<(Z+1)*(Z+1) }}
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '{{ X=m }}  ⇾                                      (a - OK)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ 0*0 ≤ m }}'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 0;
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ Z*Z ≤ m }}'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: WHILE (Z+1)*(Z+1) ≤ X DO
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ Z*Z≤m ∧ (Z+1)*(Z+1)≤X }}  ⇾        (c - OK)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ (Z+1)*(Z+1)≤m }}'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z+1
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ Z*Z≤m }}'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '{{ X=m ∧ Z*Z≤m ∧ X<(Z+1)*(Z+1) }}  ⇾           (b - OK)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Z*Z≤m ∧ m<(Z+1)*(Z+1) }}'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Example: Squaring'
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a program that squares X by repeated addition:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first thing to note is that the loop reads X but doesn't
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: change its value. As we saw in the previous example, it is a good idea
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in such cases to add X = m to the invariant.  The other thing
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that we know is often useful in the invariant is the postcondition,
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so let's add that too, leading to the invariant candidate
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Z = m * m ∧ X = m.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Conditions (a) and (c) fail because of the Z = m*m part.  While
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Z starts at 0 and works itself up to m*m, we can't expect
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Z to be m*m from the start.  If we look at how Z progesses
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the loop, after the 1st iteration Z = m, after the 2nd
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: iteration Z = 2*m, and at the end Z = m*m.  Since the variable
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Y tracks how many times we go through the loop, this leads us to
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'derive a new invariant candidate: Z = Y*m ∧ X = m.'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This new invariant makes the proof go through: all three'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conditions are easy to check.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is worth comparing the postcondition Z = m*m and the Z =
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Y*m conjunct of the invariant. It is often the case that one has
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to replace parameters with variables — or
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with expressions involving both variables and parameters, like
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: m - Y — when going from postconditions to invariants.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '{{ X = m }}'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1 ;;
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: DO
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y * X ;;
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Y = m! }}'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '{{ X = m }} ⇾'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ 0
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: DO   {{                                      }} ⇾
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y * X;;
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X - 1
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }}'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '{{                                      }} ⇾'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '{{ Y = m! }}'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Exercise: Min'
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise: 3 starsM (Min_Hoare)'
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fill in valid decorations for the following program.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: For the ⇒ steps in your annotations, you may rely (silently)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: on the following facts about min
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: plus standard high-school algebra, as always.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ☐
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: 3 starsM (two_loops)'
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is a very inefficient way of adding 3 numbers:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Show that it does what it should by filling in the blanks in the
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: following decorated program.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ☐
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: X ::= 0;;
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 1;;
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ m DO
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 2 * Z;;
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y + Z;;
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X + 1
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: (* FILL IN HERE *)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Weakest Preconditions (Optional)
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some Hoare triples are more interesting than others.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: For example,
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'is *not* very interesting: although it is perfectly valid, it'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tells us nothing useful.  Since the precondition isn't satisfied
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by any state, it doesn't describe any situations where we can use
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the command X ::= Y + 1 to achieve the postcondition X ≤ 5.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By contrast,
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'is useful: it tells us that, if we can somehow create a situation'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是有用的：它告诉我们，如果我们可以以某种方式创造一种情况
- en: in which we know that Y ≤ 4 ∧ Z = 0, then running this command
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们知道Y ≤ 4 ∧ Z = 0的情况下，然后运行此命令
- en: will produce a state satisfying the postcondition.  However, this
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将产生一个满足后置条件的状态。然而，这
- en: triple is still not as useful as it could be, because the Z = 0
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 三元组仍然不如它本应该的那么有用，因为Z = 0
- en: clause in the precondition actually has nothing to do with the
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前提子句实际上与
- en: postcondition X ≤ 5.  The *most* useful triple (for this
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后置条件X ≤ 5。*最*有用的三元组（对于这个
- en: 'command and postcondition) is this one:'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令和后置条件）是这个：
- en: '[PRE54]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In other words, Y ≤ 4 is the *weakest* valid precondition of
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，Y ≤ 4是X ::= Y + 1的*最弱*有效前置条件
- en: the command X ::= Y + 1 for the postcondition X ≤ 5.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令X ::= Y + 1的后置条件为X ≤ 5。
- en: In general, we say that "P is the weakest precondition of
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们说“P是c的最弱前置条件
- en: command c for postcondition Q" if {{P}} c {{Q}} and if,
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果{{P}} c {{Q}}，并且，
- en: whenever P' is an assertion such that {{P'}} c {{Q}}, it is
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当P'是一个断言，使得{{P'}} c {{Q}}，它就是
- en: the case that P' st implies P st for all states st.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果P' st意味着对于所有状态st都成立。
- en: '[PRE55]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: That is, P is the weakest precondition of c for Q
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，P是Q的c的最弱前置条件
- en: if (a) P *is* a precondition for Q and c, and (b) P is the
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果（a）P *是* Q和c的前提条件，且（b）P是
- en: '*weakest* (easiest to satisfy) assertion that guarantees that'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*最弱*（最容易满足）的断言，保证'
- en: Q will hold after executing c.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Q将在执行c后成立。
- en: 'Exercise: 1 star, optional (wp)'
  id: totrans-437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星，可选（wp）
- en: What are the weakest preconditions of the following commands
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令的最弱前置条件是什么
- en: for the following postconditions?
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下后置条件？
- en: '[PRE56]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ☐
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, advanced, optional (is_wp_formal)'
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，高级，可选（is_wp_formal）
- en: Prove formally, using the definition of hoare_triple, that Y ≤ 4
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 正式证明，使用hoare_triple的定义，Y ≤ 4
- en: is indeed the weakest precondition of X ::= Y + 1 with respect to
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上是X ::= Y + 1的最弱前置条件
- en: postcondition X ≤ 5.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件X ≤ 5。
- en: '[PRE58]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ☐
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars, advanced, optional (hoare_asgn_weakest)'
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星，高级，可选（hoare_asgn_weakest）
- en: Show that the precondition in the rule hoare_asgn is in fact the
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 显示hoare_asgn规则中的前置条件实际上是
- en: weakest precondition.
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最弱前置条件。
- en: '[PRE59]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ☐
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars, advanced, optional (hoare_havoc_weakest)'
  id: totrans-454
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星，高级，可选（hoare_havoc_weakest）
- en: Show that your havoc_pre rule from the himp_hoare exercise
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 显示你从himp_hoare练习中的havoc_pre规则
- en: in the [Hoare](Hoare.html) chapter returns the weakest precondition.
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[Hoare](Hoare.html)章节中返回最弱的前置条件。
- en: '[PRE60]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ☐
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE61]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Inductive dcom : Type :='
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳dcom：类型：=
- en: '| DCSkip :  Assertion → dcom'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '| DCSkip：  断言 → dcom'
- en: '| DCSeq : dcom → dcom → dcom'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '| DCSeq：dcom → dcom → dcom'
- en: '| DCAsgn : id → aexp →  Assertion → dcom'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '| DCAsgn：id → aexp →  断言 → dcom'
- en: '| DCIf : bexp →  Assertion → dcom →  Assertion → dcom'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '| DCIf：bexp →  断言 → dcom →  断言 → dcom'
- en: → Assertion→ dcom
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: → 断言→ dcom
- en: '| DCWhile : bexp → Assertion → dcom → Assertion → dcom'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '| DCWhile：bexp → 断言 → dcom → 断言 → dcom'
- en: '| DCPre : Assertion → dcom → dcom'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '| DCPre：断言 → dcom → dcom'
- en: '| DCPost : dcom → Assertion → dcom.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '| DCPost：dcom → 断言 → dcom。'
- en: 'Inductive decorated : Type :='
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳装饰：类型：=
- en: '| Decorated : Assertion → dcom → decorated.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '| 装饰：断言 → dcom → 装饰。'
- en: Notation "'SKIP' {{ P }}"
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"'SKIP' {{ P }}"
- en: := (DCSkip P)
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: :=（DCSkip P）
- en: '(at level 10) : dcom_scope.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: （在10级别）：dcom_scope。
- en: Notation "l '::=' a {{ P }}"
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"l '::=' a {{ P }}"
- en: := (DCAsgn l a P)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: :=（DCAsgn l a P）
- en: '(at level 60, a at next level) : dcom_scope.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: （在60级别，下一个级别为a）：dcom_scope。
- en: Notation "'WHILE' b 'DO' {{ Pbody }} d 'END' {{ Ppost }}"
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"'WHILE' b 'DO' {{ Pbody }} d 'END' {{ Ppost }}"
- en: := (DCWhile b Pbody d Ppost)
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: :=（DCWhile b Pbody d Ppost）
- en: '(at level 80, right associativity) : dcom_scope.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: （在80级别，右结合性）：dcom_scope。
- en: Notation "'IFB' b 'THEN' {{ P }} d 'ELSE' {{ P' }} d' 'FI' {{ Q }}"
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"'IFB' b 'THEN' {{ P }} d 'ELSE' {{ P' }} d' 'FI' {{ Q }}"
- en: := (DCIf b P d P' d' Q)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: :=（DCIf b P d P' d' Q）
- en: '(at level 80, right associativity)  : dcom_scope.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: （在80级别，右结合性）：dcom_scope。
- en: Notation "'⇾' {{ P }} d"
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"'⇾' {{ P }} d"
- en: := (DCPre P d)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: :=（DCPre P d）
- en: '(at level 90, right associativity)  : dcom_scope.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: （在90级别，右结合性）：dcom_scope。
- en: Notation "d '⇾' {{ P }}"
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"d '⇾' {{ P }}"
- en: := (DCPost d P)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: :=（DCPost d P）
- en: '(at level 80, right associativity)  : dcom_scope.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: （在80级别，右结合性）：dcom_scope。
- en: Notation " d ;; d' "
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"d ;; d' "
- en: := (DCSeq d d')
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: :=（DCSeq d d'）
- en: '(at level 80, right associativity)  : dcom_scope.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: （在80级别，右结合性）：dcom_scope。
- en: Notation "{{ P }} d"
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"{{ P }} d"
- en: := (Decorated P d)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: :=（Decorated P d）
- en: '(at level 90)  : dcom_scope.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: （在90级别）：dcom_scope。
- en: Delimit Scope dcom_scope with dcom.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 使用dcom的Delimit Scope dcom_scope。
- en: '[PRE62]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Example dec_while : decorated := ('
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 示例dec_while：装饰 := (
- en: '{{ fun st ⇒ True }}'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ True }}'
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BNot (BEq (AId X) (ANum 0)))'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE（BNot（BEq（AId X）（ANum 0）））'
- en: DO
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 做
- en: '{{ fun st ⇒ True ∧ st X ≠ 0}}'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ True ∧ st X ≠ 0}}'
- en: X ::= (AMinus (AId X) (ANum 1))
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun _ ⇒ True }}'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True ∧ st X = 0}} ⇾'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = 0 }}'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: ) % dcom.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Fixpoint extract (d:dcom) : com :='
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: match d with
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSkip _           ⇒ SKIP'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSeq d[1] d[2]        ⇒ (extract d[1] ;; extract d[2])'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '| DCAsgn X a _       ⇒ X ::= a'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '| DCIf b _ d[1] _ d[2] _ ⇒ IFB b THEN extract d[1] ELSE extract d[2] FI'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '| DCWhile b _ d _    ⇒ WHILE b DO extract d END'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPre _ d          ⇒ extract d'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPost d _         ⇒ extract d'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition extract_dec (dec : decorated) : com :='
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: match dec with
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated P d ⇒ extract d'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '{{P}} ({{P}} SKIP {{P}}) ;; ({{P}} SKIP {{P}}) {{P}},'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Fixpoint post (d:dcom) : Assertion :='
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: match d with
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSkip P                ⇒ P'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSeq d[1] d[2]             ⇒ post d[2]'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '| DCAsgn X a Q            ⇒ Q'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '| DCIf  _ _ d[1] _ d[2] Q     ⇒ Q'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '| DCWhile b Pbody c Ppost ⇒ Ppost'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPre _ d               ⇒ post d'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPost c Q              ⇒ Q'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Definition pre_dec (dec : decorated) : Assertion :='
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: match dec with
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated P d ⇒ P'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition post_dec (dec : decorated) : Assertion :='
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: match dec with
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated P d ⇒ post d'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Definition dec_correct (dec : decorated) :='
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '{{pre_dec dec}} (extract_dec dec) {{post_dec dec}}.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Fixpoint verification_conditions (P : Assertion) (d:dcom)'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: ': Prop :='
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: match d with
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSkip Q ⇒'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: (P ⇾ Q)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '| DCSeq d[1] d[2] ⇒'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: verification_conditions P d[1]
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: ∧ verification_conditions (post d[1]) d[2]
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '| DCAsgn X a Q ⇒'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: (P ⇾ Q [X ↦ a])
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '| DCIf b P[1] d[1] P[2] d[2] Q ⇒'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: ((fun st ⇒ P st ∧ bassn b st) ⇾ P[1])
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ((fun st ⇒ P st ∧ ¬ (bassn b st)) ⇾ P[2])
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: ∧ (post d[1] ⇾ Q) ∧ (post d[2] ⇾ Q)
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: ∧ verification_conditions P[1] d[1]
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: ∧ verification_conditions P[2] d[2]
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '| DCWhile b Pbody d Ppost ⇒'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: (* post d is the loop invariant and the initial
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: precondition *)
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: (P ⇾ post d)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ((fun st ⇒ post d st ∧ bassn b st) ⇾ Pbody)
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ((fun st ⇒ post d st ∧ ~(bassn b st)) ⇾ Ppost)
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: ∧ verification_conditions Pbody d
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPre P'' d ⇒'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: (P ⇾ P') ∧ verification_conditions P' d
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '| DCPost d Q ⇒'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: verification_conditions P d ∧ (post d ⇾ Q)
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Theorem verification_correct : ∀d P,'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: verification_conditions P d → {{P}} (extract d) {{post d}}.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: induction d; intros P H; simpl in *.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Skip *)'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_skip](Hoare.html#hoare_skip).
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Seq *)'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [H[1] H[2]]. clear H.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_seq](Hoare.html#hoare_seq).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: apply IHd2. apply H[2].
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: apply IHd1. apply H[1].
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Asgn *)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_asgn](Hoare.html#hoare_asgn).
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: assumption.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '- (* If *)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [HPre1 [HPre2 [Hd[1] [Hd[2] [HThen HElse]]]]].
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: clear H.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: apply IHd1 in HThen. clear IHd1.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: apply IHd2 in HElse. clear IHd2.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_if](Hoare.html#hoare_if).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: + eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post) with (Q':=[post](Hoare2.html#post)
    d[1]); eauto.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre); eauto.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: + eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post) with (Q':=[post](Hoare2.html#post)
    d[2]); eauto.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre); eauto.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '- (* While *)'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [Hpre [Hbody1 [Hpost1  Hd]]]. clear H.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre); eauto.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post); eauto.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: apply [hoare_while](Hoare.html#hoare_while).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre); eauto.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Pre *)'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [HP Hd]; clear H.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_pre](Hoare.html#hoare_consequence_pre). apply IHd.
    apply Hd. assumption.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '- (* Post *)'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [Hd HQ]; clear H.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: eapply [hoare_consequence_post](Hoare.html#hoare_consequence_post). apply IHd.
    apply Hd. assumption.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Definition verification_conditions_dec (dec : decorated) : Prop :='
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: match dec with
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '| Decorated P d ⇒ verification_conditions P d'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma verification_correct_dec : ∀dec,'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: verification_conditions_dec dec → dec_correct dec.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: intros [P d]. apply verification_correct.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Eval simpl in (verification_conditions_dec dec_while).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ⇒ (((fun _ : state ⇒ True) ⇾ (fun _ : state ⇒ True)) ∧
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: ((fun st : state ⇒ True ∧ bassn (BNot (BEq (AId X) (ANum 0))) st) ⇾
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: (fun st : state ⇒ True ∧ st X ≠ 0)) ∧
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: ((fun st : state ⇒ True ∧ ¬ bassn (BNot (BEq (AId X) (ANum 0))) st) ⇾
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: (fun st : state ⇒ True ∧ st X = 0)) ∧
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: (fun st : state ⇒ True ∧ st X ≠ 0) ⇾
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: (fun _ : state ⇒ True) [X ↦ AMinus (AId X) (ANum 1)]) ∧
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: (fun st : state ⇒ True ∧ st X = 0) ⇾ (fun st : state ⇒ st X = 0)
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Tactic Notation "verify" :=
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: apply verification_correct;
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: repeat split;
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: simpl; unfold assert_implies;
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: unfold bassn in *; unfold beval in *; unfold aeval in *;
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: unfold assn_sub; intros;
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite t_update_eq;
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: repeat (rewrite t_update_neq; [| (intro X; inversion X)]);
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: simpl in *;
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'repeat match goal with [H : _ ∧ _ ⊢ _] ⇒ destruct H end;'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite not_true_iff_false in *;
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite not_false_iff_true in *;
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite negb_true_iff in *;
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite negb_false_iff in *;
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite beq_nat_true_iff in *;
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite beq_nat_false_iff in *;
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite leb_iff in *;
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite leb_iff_conv in *;
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: try subst;
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: repeat
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: match goal with
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[st : state ⊢ _] ⇒'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: match goal with
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[H : st _ = _ ⊢ _] ⇒ rewrite → H in *; clear H'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '| [H : _ = st _ ⊢ _] ⇒ rewrite ← H in *; clear H'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: end;
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: try eauto; try omega.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Theorem dec_while_correct :'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct dec_while.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Proof. verify. Qed.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Example subtract_slowly_dec (m:nat) (p:nat) : decorated := ('
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Z = p }} ⇾'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z - st X = p - m }}'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId X) (ANum 0))'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: DO   {{ fun st ⇒ st Z - st X = p - m ∧ st X ≠ 0 }} ⇾
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z - 1) - (st X - 1) = p - m }}'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMinus (AId Z) (ANum 1)
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z - (st X - 1) = p - m }} ;;'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 1)
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z - st X = p - m }}'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z - st X = p - m ∧ st X = 0 }} ⇾'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = p - m }}'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: ) % dcom.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: ) % dcom。
- en: 'Theorem subtract_slowly_dec_correct : ∀m p,'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 subtract_slowly_dec_correct：∀m p，
- en: dec_correct (subtract_slowly_dec m p).
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: dec_correct (subtract_slowly_dec m p).
- en: Proof. intros m p. verify. (* this grinds for a bit! *) Qed.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 m p。验证。(* 这个需要花点时间！ *) Qed.
- en: '[PRE76]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Definition swap : com :='
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 定义交换：com :=
- en: X ::= APlus (AId X) (AId Y);;
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= APlus (AId X) (AId Y);;
- en: Y ::= AMinus (AId X) (AId Y);;
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AMinus (AId X) (AId Y);;
- en: X ::= AMinus (AId X) (AId Y).
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (AId X) (AId Y)。
- en: 'Definition swap_dec m n : decorated :='
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 swap_dec m n：decorated :=
- en: ({{ fun st ⇒ st X = m ∧ st Y = n}} ⇾
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: ({{ fun st ⇒ st X = m ∧ st Y = n}} ⇾
- en: '{{ fun st ⇒ (st X + st Y) - ((st X + st Y) - st Y) = n'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ (st X + st Y) - ((st X + st Y) - st Y) = n'
- en: ∧ (st X + st Y) - st Y = m }}
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: ∧ (st X + st Y) - st Y = m }}
- en: X ::= APlus (AId X) (AId Y)
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= APlus (AId X) (AId Y)
- en: '{{ fun st ⇒ st X - (st X - st Y) = n ∧ st X - st Y = m }};;'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ st X - (st X - st Y) = n ∧ st X - st Y = m }};;'
- en: Y ::= AMinus (AId X) (AId Y)
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AMinus (AId X) (AId Y)
- en: '{{ fun st ⇒ st X - st Y = n ∧ st Y = m }};;'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ st X - st Y = n ∧ st Y = m }};;'
- en: X ::= AMinus (AId X) (AId Y)
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (AId X) (AId Y)
- en: '{{ fun st ⇒ st X = n ∧ st Y = m}})%dcom.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ st X = n ∧ st Y = m}})%dcom。'
- en: 'Theorem swap_correct : ∀m n,'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 swap_correct：∀m n，
- en: dec_correct (swap_dec m n).
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: dec_correct (swap_dec m n)。
- en: Proof. intros; verify. Qed.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入；验证。Qed。
- en: '[PRE77]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Definition if_minus_plus_com :=
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 if_minus_plus_com :=
- en: IFB (BLe (AId X) (AId Y))
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (BLe (AId X) (AId Y))
- en: THEN (Z ::= AMinus (AId Y) (AId X))
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 (Z ::= AMinus (AId Y) (AId X))
- en: ELSE (Y ::= APlus (AId X) (AId Z))
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 否则 (Y ::= APlus (AId X) (AId Z))
- en: FI.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: FI。
- en: Definition if_minus_plus_dec :=
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 if_minus_plus_dec :=
- en: ({{fun st ⇒ True}}
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: ({{fun st ⇒ True}}
- en: '{{''_x_''}}''_x_''ELSE''_''{{''_x_''}}''_x_''FI''_''{{''_x_''}}''">IFB (BLe
    (AId X) (AId Y)) THEN'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '{{''_x_''}}''_x_''ELSE''_''{{''_x_''}}''_x_''FI''_''{{''_x_''}}''">如果 (BLe
    (AId X) (AId Y)) 则'
- en: '{{ fun st ⇒ True ∧ st X ≤ st Y }} ⇾'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ True ∧ st X ≤ st Y }} ⇾'
- en: '{{ fun st ⇒ st Y = st X + (st Y - st X) }}'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ st Y = st X + (st Y - st X) }}'
- en: Z ::= AMinus (AId Y) (AId X)
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= AMinus (AId Y) (AId X)
- en: '{{ fun st ⇒ st Y = st X + st Z }}'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ st Y = st X + st Z }}'
- en: ELSE
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: '{{ fun st ⇒ True ∧ ~(st X ≤ st Y) }} ⇾'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ True ∧ ~(st X ≤ st Y) }} ⇾'
- en: '{{ fun st ⇒ st X + st Z = st X + st Z }}'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ st X + st Z = st X + st Z }}'
- en: Y ::= APlus (AId X) (AId Z)
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= APlus (AId X) (AId Z)
- en: '{{ fun st ⇒ st Y = st X + st Z }}'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ st Y = st X + st Z }}'
- en: FI
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: FI
- en: '{{fun st ⇒ st Y = st X + st Z}})%dcom.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ st Y = st X + st Z}})%dcom。'
- en: 'Theorem if_minus_plus_correct :'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 if_minus_plus_correct：
- en: dec_correct if_minus_plus_dec.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: dec_correct if_minus_plus_dec。
- en: Proof. intros; verify. Qed.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入；验证。Qed。
- en: Definition if_minus_dec :=
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 if_minus_dec :=
- en: ( {{fun st ⇒ True}}
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: ( {{fun st ⇒ True}}
- en: '{{''_x_''}}''_x_''ELSE''_''{{''_x_''}}''_x_''FI''_''{{''_x_''}}''">IFB (BLe
    (AId X) (AId Y)) THEN'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '{{''_x_''}}''_x_''ELSE''_''{{''_x_''}}''_x_''FI''_''{{''_x_''}}''">如果 (BLe
    (AId X) (AId Y)) 则'
- en: '{{fun st ⇒ True ∧ st X ≤ st Y }} ⇾'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ True ∧ st X ≤ st Y }} ⇾'
- en: '{{fun st ⇒ (st Y - st X) + st X = st Y'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ (st Y - st X) + st X = st Y'
- en: ∨ (st Y - st X) + st Y = st X}}
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: ∨ (st Y - st X) + st Y = st X}}
- en: Z ::= AMinus (AId Y) (AId X)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= AMinus (AId Y) (AId X)
- en: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}}'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}}'
- en: ELSE
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: '{{fun st ⇒ True ∧ ~(st X ≤ st Y) }} ⇾'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ True ∧ ~(st X ≤ st Y) }} ⇾'
- en: '{{fun st ⇒ (st X - st Y) + st X = st Y'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ (st X - st Y) + st X = st Y'
- en: ∨ (st X - st Y) + st Y = st X}}
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: ∨ (st X - st Y) + st Y = st X}}
- en: Z ::= AMinus (AId X) (AId Y)
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= AMinus (AId X) (AId Y)
- en: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}}'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}}'
- en: FI
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: FI
- en: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}})%dcom.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '{{fun st ⇒ st Z + st X = st Y ∨ st Z + st Y = st X}})%dcom。'
- en: 'Theorem if_minus_correct :'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 if_minus_correct：
- en: dec_correct if_minus_dec.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: dec_correct if_minus_dec。
- en: Proof. verify. Qed.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。验证。Qed.
- en: '[PRE78]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Definition div_mod_dec (a b : nat) : decorated := ('
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 div_mod_dec (a b : 自然数)：decorated := ('
- en: '{{ fun st ⇒ True }} ⇾'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ True }} ⇾'
- en: '{{ fun st ⇒ b * 0 + a = a }}'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * 0 + a = a }}'
- en: X ::= ANum a
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= ANum a
- en: '{{ fun st ⇒ b * 0 + st X = a }};;'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * 0 + st X = a }};;'
- en: Y ::= ANum 0
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= ANum 0
- en: '{{ fun st ⇒ b * st Y + st X = a }};;'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * st Y + st X = a }};;'
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BLe (ANum b) (AId X)) DO'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">当 (BLe (ANum b) (AId X)) 时'
- en: '{{ fun st ⇒ b * st Y + st X = a ∧ b ≤ st X }} ⇾'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * st Y + st X = a ∧ b ≤ st X }} ⇾'
- en: '{{ fun st ⇒ b * (st Y + 1) + (st X - b) = a }}'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * (st Y + 1) + (st X - b) = a }}'
- en: X ::= AMinus (AId X) (ANum b)
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (AId X) (ANum b)
- en: '{{ fun st ⇒ b * (st Y + 1) + st X = a }};;'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * (st Y + 1) + st X = a }};;'
- en: Y ::= APlus (AId Y) (ANum 1)
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= APlus (AId Y) (ANum 1)
- en: '{{ fun st ⇒ b * st Y + st X = a }}'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * st Y + st X = a }}'
- en: END
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: '{{ fun st ⇒ b * st Y + st X = a ∧ ~(b ≤ st X) }} ⇾'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * st Y + st X = a ∧ ~(b ≤ st X) }} ⇾'
- en: '{{ fun st ⇒ b * st Y + st X = a ∧ (st X < b) }}'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '{{ fun st ⇒ b * st Y + st X = a ∧ (st X < b) }}'
- en: )%dcom.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: )%dcom。
- en: 'Theorem div_mod_dec_correct : ∀a b,'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 div_mod_dec_correct：∀a b，
- en: dec_correct (div_mod_dec a b).
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: dec_correct (div_mod_dec a b)。
- en: Proof. intros a b. verify.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。引入 a b。验证。
- en: rewrite mult_plus_distr_l. omega.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 mult_plus_distr_l。omega。
- en: Qed.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: Qed.
- en: '[PRE79]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Definition find_parity : com :='
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 定义找奇偶性：com :=
- en: WHILE (BLe (ANum 2) (AId X)) DO
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 当 (BLe (ANum 2) (AId X)) 时
- en: X ::= AMinus (AId X) (ANum 2)
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (AId X) (ANum 2)
- en: END.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE80]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Inductive ev : nat → Prop :='
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 ev：自然数 → 命题 :=
- en: '| ev_0 : ev O'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '| ev_0 : ev O'
- en: '| ev_SS : ∀n:nat, ev n → ev (S (S n)).'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition find_parity_dec m : decorated :='
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: ({{ fun st ⇒ st X = m}} ⇾
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X ≤ m ∧ ev (m - st X) }}'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BLe (ANum 2) (AId X)) DO'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X ≤ m ∧ ev (m - st X)) ∧ 2 ≤ st X }} ⇾'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X - 2 ≤ m ∧ (ev (m - (st X - 2))) }}'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 2)
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X ≤ m ∧ ev (m - st X) }}'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X ≤ m ∧ ev (m - st X)) ∧ st X < 2 }} ⇾'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X=0 ↔ ev m }})%dcom.'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[1] : ∀m n p,'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: p ≤ n →
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: n ≤ m →
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: m - (n - p) = m - n + p.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. omega. Qed.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[2] : ∀m,'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: ev m →
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: ev (m + 2).
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. rewrite plus_comm. simpl. constructor. assumption. Qed.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[3]'' : ∀m,'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: ev m →
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: ¬ev (S m).
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: Proof. induction m; intros H[1] H[2]. inversion H[2]. apply IHm.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[2]; subst; assumption. assumption. Qed.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[3] : ∀m,'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: 1 ≤ m →
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: ev m →
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: ev (m - 1) →
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: False.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. apply l[2] in H[1].
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (G : m - 1 + 2 = S m). clear H[0] H[1]. omega.'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: rewrite G in H[1]. apply l[3]' in H[0]. apply H[0]. assumption. Qed.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem find_parity_correct : ∀m,'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (find_parity_dec m).
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: intro m. verify;
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: (* simplification too aggressive ... reverting a bit *)
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: fold (leb 2 (st X)) in *;
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff in *;
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff_conv in *; eauto; try omega.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant holds initially *)'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: rewrite minus_diag. constructor.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved *)'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: rewrite l[1]; try assumption.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: apply l[2]; assumption.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough to imply conclusion'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: (-> direction) *)
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← minus_n_O in H[2]. assumption.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough to imply conclusion'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: (<- direction) *)
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: destruct (st X) as [| [| n]].
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: (* by H[1] X can only be 0 or 1 *)
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 0 *)
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 1 *)
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: apply l[3] in H; try assumption. inversion H.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 2 *)
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: clear H[0] H[2]. (* omega confused otherwise *)
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: omega.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Definition find_parity_dec'' m : decorated :='
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: ({{ fun st ⇒ st X = m}} ⇾
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ ev (st X) ↔ ev m }}'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BLe (ANum 2) (AId X)) DO'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (ev (st X) ↔ ev m) ∧ 2 ≤ st X }} ⇾'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (ev (st X - 2) ↔ ev m) }}'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 2)
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (ev (st X) ↔ ev m) }}'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (ev (st X) ↔ ev m) ∧ ~(2 ≤ st X) }} ⇾'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X=0 ↔ ev m }})%dcom.'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma l[4] : ∀m,'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: 2 ≤ m →
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: (ev (m - 2) ↔ ev m).
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: induction m; intros. split; intro; constructor.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: destruct m. inversion H. inversion H[1]. simpl in *.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← minus_n_O in *. split; intro.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: constructor. assumption.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0]. assumption.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem find_parity_correct'' : ∀m,'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (find_parity_dec' m).
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: intros m. verify;
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: (* simplification too aggressive ... reverting a bit *)
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: fold (leb 2 (st X)) in *;
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff in *;
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff_conv in *; intuition; eauto; try omega.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved (part 1) *)'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: rewrite l[4] in H[0]; eauto.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved (part 2) *)'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: rewrite l[4]; eauto.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough to imply conclusion'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: (-> direction) *)
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: apply H[0]. constructor.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough to imply conclusion'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: (<- direction) *)
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: destruct (st X) as [| [| n]]. (* by H[1] X can only be 0 or 1 *)
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 0 *)
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 1 *)
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: inversion H.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: + (* st X = 2 *)
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: clear H[0] H H[3]. (* omega confused otherwise *)
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: omega.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Definition parity_dec m : decorated :='
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: ({{ fun st ⇒ st X = m}} ⇾
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X) = parity m }}'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE (BLe (ANum 2) (AId X)) DO'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X) = parity m ∧ 2 ≤ st X }} ⇾'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X - 2) = parity m }}'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 2)
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X) = parity m }}'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ parity (st X) = parity m ∧ ~(2 ≤ st X) }} ⇾'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = parity m }})%dcom.'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem parity_dec_correct : ∀m,'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (parity_dec m).
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: intros. verify;
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: (* simplification too aggressive ... reverting a bit *)
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: fold (leb 2 (st X)) in *;
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff in *;
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: try rewrite leb_iff_conv in *; eauto; try omega.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved *)'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H. apply parity_ge_2. assumption.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant strong enough *)'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H. symmetry. apply parity_lt_2. assumption.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Definition sqrt_dec m : decorated := ('
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m }} ⇾'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ 0*0 ≤ m }}'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 0
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Z*st Z ≤ m }};;'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BLe (AMult (APlus (AId Z) (ANum
    1))'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: (APlus (AId Z) (ANum 1)))
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: (AId X) DO
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X = m ∧ st Z*st Z≤m)'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: ∧ (st Z + 1)*(st Z + 1) ≤ st X }} ⇾
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ (st Z+1)*(st Z+1)≤m }}'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (ANum 1)
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Z*st Z≤m }}'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st X = m ∧ st Z*st Z≤m)'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: ∧ ~((st Z + 1)*(st Z + 1) ≤ st X) }} ⇾
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z*st Z≤m ∧ m<(st Z+1)*(st Z+1) }})%dcom.'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem sqrt_correct : ∀m,'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (sqrt_dec m).
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intro m. verify. Qed.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Definition square_dec (m : nat) : decorated := ('
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m }}'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AId X
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Y = m }};;'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 0
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m ∧ st Y = m ∧ st Z = 0}} ⇾'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * st Y = m * m }};;'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId Y) (ANum 0))
    DO'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * st Y = m * m ∧ st Y ≠ 0 }} ⇾'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z + st X) + st X * (st Y - 1) = m * m }}'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (AId X)
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * (st Y - 1) = m * m }};;'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId Y) (ANum 1)
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * st Y = m * m }}'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X * st Y = m * m ∧ st Y = 0 }} ⇾'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = m * m }}'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem square_dec_correct : ∀m,'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (square_dec m).
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: intro n. verify.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved *)'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: destruct (st Y) as [| y']. apply False_ind. apply H[0].
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite ← minus_n_O.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (G : ∀n m, n * S m = n + n * m). {'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: clear. intros. induction n. reflexivity. simpl.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: rewrite IHn. omega. }
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H. rewrite G. rewrite plus_assoc. reflexivity.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition square_dec'' (n : nat) : decorated := ('
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ True }}'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum n
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = n }};;'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AId X
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = n ∧ st Y = n }};;'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 0
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = n ∧ st Y = n ∧ st Z = 0 }} ⇾'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X * (st X - st Y)'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X }};;
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId Y) (ANum 0))
    DO'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = st X * (st X - st Y)'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X)
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Y ≠ 0 }}
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (AId X)
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X * (st X - (st Y - 1))'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X }};;
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMinus (AId Y) (ANum 1)
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X * (st X - st Y)'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X }}
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = st X * (st X - st Y)'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n ∧ st Y ≤ st X)
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Y = 0 }} ⇾
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = n * n }}'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem square_dec''_correct : ∀n,'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (square_dec' n).
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: intro n. verify.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant holds initially *)'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: rewrite minus_diag. omega.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant preserved *) subst.'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: rewrite mult_minus_distr_l.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: repeat rewrite mult_minus_distr_l. rewrite mult_1_r.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (G : ∀n m p,'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: m ≤ n → p ≤ m → n - (m - p) = n - m + p).
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: intros. omega.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: rewrite G. reflexivity. apply mult_le_compat_l. assumption.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: destruct (st Y). apply False_ind. apply H[0]. reflexivity.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: clear. rewrite mult_succ_r. rewrite plus_comm.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: apply le_plus_l.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '- (* invariant + negation of guard imply'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: desired postcondition *)
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← minus_n_O. reflexivity.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition square_simpler_dec (m : nat) : decorated := ('
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st X = m }} ⇾'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ 0 = 0*m ∧ st X = m }}'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 0
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ 0 = (st Y)*m ∧ st X = m }};;'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 0
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = (st Y)*m ∧ st X = m }}⇾'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = (st Y)*m ∧ st X = m }};;'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId Y) (AId X)) DO'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = (st Y)*m ∧ st X = m)'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Y ≠ st X }} ⇾
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + st X = ((st Y) + 1)*m ∧ st X = m }}'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (AId X)
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = ((st Y) + 1)*m ∧ st X = m }};;'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId Y) (ANum 1)
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = (st Y)*m ∧ st X = m }}'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = (st Y)*m ∧ st X = m) ∧ st Y = st X }} ⇾'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = m*m }}'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem square_simpler_dec_correct : ∀m,'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (square_simpler_dec m).
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: intro m. verify.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: rewrite mult_plus_distr_r. simpl. rewrite ← plus_n_O.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Definition two_loops_dec (a b c : nat) : decorated :='
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: ( {{ fun st ⇒ True }} ⇾
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ c = 0 + c ∧ 0 = 0 }}'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum 0
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ c = st X + c ∧ 0 = 0 }};;'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 0
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ c = st X + c ∧ st Y = 0 }};;'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum c
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X + c ∧ st Y = 0 }};;'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId X) (ANum a))
    DO'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = st X + c ∧ st Y = 0) ∧ st X ≠ a }} ⇾'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + 1 = st X + 1 + c ∧ st Y = 0 }}'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (ANum 1)
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + 1 = st X + c ∧ st Y = 0 }};;'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (ANum 1)
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = st X + c ∧ st Y = 0 }}'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = st X + c ∧ st Y = 0) ∧ st X = a }} ⇾'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = a + st Y + c }};;'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId Y) (ANum b))
    DO'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = a + st Y + c ∧ st Y ≠ b }} ⇾'
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + 1 = a + st Y + 1 + c }}'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId Y) (ANum 1)
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z + 1 = a + st Y + c }};;'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= APlus (AId Z) (ANum 1)
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = a + st Y + c }}'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Z = a + st Y + c) ∧ st Y = b }} ⇾'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Z = a + b + c }}'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem two_loops_correct : ∀a b c,'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (two_loops_dec a b c).
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros a b c. verify. Qed.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Fixpoint pow2 n :=
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ 1'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ 2 * (pow2 n'')'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: Definition dpow2_down n :=
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: ( {{ fun st ⇒ True }} ⇾
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ 1 = (pow2 (0 + 1))-1 ∧ 1 = pow2 0 }}'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum 0
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ 1 = (pow2 (0 + 1))-1 ∧ 1 = pow2 (st X) }};;'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 1
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = (pow2 (st X + 1))-1 ∧ 1 = pow2 (st X) }};;'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 1
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = (pow2 (st X + 1))-1 ∧ st Z = pow2 (st X) }};;'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '{{''_x_''}}''_x_''END''_''{{''_x_''}}''">WHILE BNot (BEq (AId X) (ANum n))
    DO'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Y = (pow2 (st X + 1))-1 ∧ st Z = pow2 (st X))'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X ≠ n }} ⇾
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y + 2 * st Z = (pow2 (st X + 2))-1'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: ∧ 2 * st Z = pow2 (st X + 1) }}
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMult (ANum 2) (AId Z)
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y + st Z = (pow2 (st X + 2))-1'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Z = pow2 (st X + 1) }};;
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= APlus (AId Y) (AId Z)
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = (pow2 (st X + 2))-1'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Z = pow2 (st X + 1) }};;
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: X ::= APlus (AId X) (ANum 1)
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = (pow2 (st X + 1))-1'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st Z = pow2 (st X) }}
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ (st Y = (pow2 (st X + 1))-1 ∧ st Z = pow2 (st X))'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: ∧ st X = n }} ⇾
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '{{ fun st ⇒ st Y = pow2 (n+1) - 1 }}'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: )%dcom.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma pow2_plus_1 : ∀n,'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: pow2 (n+1) = pow2 n + pow2 n.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: Proof. induction n; simpl. reflexivity. omega. Qed.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma pow2_le_1 : ∀n, pow2 n ≥ 1.'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: Proof. induction n. simpl. constructor. simpl. omega. Qed.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem dpow2_down_correct : ∀n,'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (dpow2_down n).
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: intro m. verify.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 1 *)'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: rewrite pow2_plus_1. rewrite ← H[0]. reflexivity.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 2 *)'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← plus_n_O.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pow2_plus_1. remember (st X) as n.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: replace (pow2 (n + 1) - 1 + pow2 (n + 1))
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: with (pow2 (n + 1) + pow2 (n + 1) - 1) by omega.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← pow2_plus_1.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: replace (n + 1 + 1) with (n + 2) by omega.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 3 *)'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← plus_n_O. rewrite ← pow2_plus_1.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 4 *)'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: replace (st X + 1 + 1) with (st X + 2) by omega.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Example slow_assignment_dec (m:nat) : decorated'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem slow_assignment_dec_correct : ∀m,'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (slow_assignment_dec m).
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* FILL IN HERE *) Admitted.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Fixpoint real_fact (n:nat) : nat :='
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ 1'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ n * (real_fact n'')'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: (* FILL IN HERE *)
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Fixpoint fib n :=
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ 1'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 ⇒ 1'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: '| _ ⇒ fib (pred n) + fib (pred (pred n))'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Fixpoint fib n :=
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: match n with
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ 1'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'' ⇒ match n'' with'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 ⇒ 1'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '| S n'''' ⇒ fib n'' + fib n'''''
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Lemma fib_eqn : ∀n,'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: n > 0 →
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: fib n + fib (Init.Nat.pred n) = fib (n + 1).
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: X ::= 1;;
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= 1;;
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: WHILE X ≠ n+1 DO
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: T ::= Z;
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z + Y;;
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= T;;
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: X ::= X + 1
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '{{True}} dfib {{ Y = fib n }}'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-1185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Definition T : id := Id "T".'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition dfib (n:nat) : decorated'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem dfib_correct : ∀n,'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: dec_correct (dfib n).
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: (* FILL IN HERE *)
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: (* FILL IN HERE *)
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-1197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
