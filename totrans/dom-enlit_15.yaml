- en: Chapter 10 - JavaScript in the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 10.1 Inserting & executing JavaScript overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript can be inserted in to an HTML document in a modern way by including
    external JavaScript files or writing page level inline JavaScript, which is basically
    the contents of an external JavaScript file literally embed in the HTML page as
    a text node. Don't confuse element inline JavaScript contained in attribute event
    handlers (i.e. *<div onclick="alert('yo')"></div>*) with page inline JavaScript
    (i.e. *<script>alert('hi')</script>*).
  prefs: []
  type: TYPE_NORMAL
- en: Both methods of inserting JavaScript into an HTML document require the use of
    a *[<script>](http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#the-script-element)*
    [element node](http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#the-script-element).
    The *<script>* element can contain JavaScript code or can be used to link to external
    JavaScript files using the *src* attribute. Both methods are explored in the code
    example below.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/g6T5F](http://jsfiddle.net/domenlightenment/g6T5F)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Its possible to insert and execute JavaScript in the DOM by placing JavaScript
    in an element attribute event handler (i.e. *<div onclick="alert('yo')"></div>*)
    and using the *javascript:* protocal (e.g. *<a href="javascript:alert('yo')"></a>*)
    but this is no longer considered a modern practice.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to include an external JavaScript file and writing page inline JavaScript
    using the same *<script>* element will result in the page inline JavaScript being
    ignored and the exterenal JavaScript file being downloaded and exectued
  prefs: []
  type: TYPE_NORMAL
- en: Self-closing scripts tags (i.e. *<script src="" />* ) should be avoid unless
    you are rocking some old school XHTML
  prefs: []
  type: TYPE_NORMAL
- en: 'The *<script>* element does not have any required attributes but offers the
    follow optional attribures: *async*, *charset*, *defer*, *src*, and *type*'
  prefs: []
  type: TYPE_NORMAL
- en: Page inline JavaScript produces a text node. Which permits the usage of *innerHTML*
    and *textContent* to retrieve the contents of a line *<script>*. However, appending
    a new text node made up of JavaScript code to the DOM after the browser has already
    parsed the DOM will not execute the new JavaScript code. It simply replaces the
    text.
  prefs: []
  type: TYPE_NORMAL
- en: If JavaScript code contains the string *'</script>'* you will have to escape
    the closing *'/'* with *'<\/script>'* so that the parser does not think this is
    the real closing *</script>* element
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 JavaScript is parsed synchronously by default
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default when the DOM is being parsed and it encounters a *<script>* element
    it will stop parsing the document, block any further rendering & downloading,
    and exectue the JavaScript. Because this behavior is blocking and does not permit
    parallel parsing of the DOM or exection of JavaScriopt its consider to be synchronous.
    If the JavaScript is external to the html document the blocking is exacerbated
    because the JavaScript must first be downloaed before it can be parsed. In the
    code example below I comment what is occuring during browser rendering when the
    browser encoutners several *<script>* elements in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/rF3Lh](http://jsfiddle.net/domenlightenment/rF3Lh)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*****You should make note of the differences between an inline script''s and
    external scripts as it pertains to the loading phase.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default blocking nature of a *<script>* element can have a significant effect
    on the perfomrance & percived performance of the visual rendering of a HTML web
    page. If you have a couple of script elements at the start of an html page nothing
    else is happening (e.g. DOM parsing & resource loading) until each one is downloaed
    and executed sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Defering the downloading & exectuion of external JavaScript using *defer*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *<script>* element has an attribute called *defer* that will defer the blocking,
    downloading, and executing of an external JavaScript file until the browser has
    parsed the closing *<html>* node. Using this attribute simply defers what normally
    occurs when a web browser encoutners a *<script>* node. In the code below I defer
    each external JavaScript file until the final *<html>* is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/HDegp](http://jsfiddle.net/domenlightenment/HDegp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the specification defered scripts are suppose to be exectued in
    document order and before the *DOMContentLoaded* event. However, adherence to
    this specification among modern browsers is inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: '*defer* is a boolan attribute it does not have a value'
  prefs: []
  type: TYPE_NORMAL
- en: Some browers support defered inline scripts but this is not common among modern
    browsers
  prefs: []
  type: TYPE_NORMAL
- en: By using *defer* the assummption is that *document.write()* is not being used
    in the JavaScript that will be defered
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Asynchronously downloading & executing external JavaScript files using
    *async*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *<script>* element has an attribute called *async* that will override the
    sequential blocking nature of *<script>* elements when the DOM is being constructed
    by a web browser. By using this attribute, we are telling the browser not to block
    the construction (i.e. DOM parsing, including downloading other assets e.g. images,
    style sheets, etc...) of the html page and forgo the the sequential loading as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: What happens by using the *async* attribute is the files are loaded in parallel
    and parsed in order of download once they are fully downloaded. In the code below
    I comment what is happening when the HTML document is being parsed and render
    by the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/](http://jsfiddle.net/domenlightenment/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '***### Notes'
  prefs: []
  type: TYPE_NORMAL
- en: IE 10 has support for *async*, but IE 9 does not
  prefs: []
  type: TYPE_NORMAL
- en: A major drawback to using the *async* attribute is JavaScript files potentially
    get parsed out of the order they are included in the DOM. This raises a dependency
    management issue.
  prefs: []
  type: TYPE_NORMAL
- en: '*async* is a boolan attribute it does not have a value'
  prefs: []
  type: TYPE_NORMAL
- en: By using *async* the assummption is that *document.write()* is not being used
    in the JavaScript that will be defered
  prefs: []
  type: TYPE_NORMAL
- en: The *async* attribute will trump the *defer* if both are used on a *<script>*
    element
  prefs: []
  type: TYPE_NORMAL
- en: 10.5 Forcing asynchronous downloading & parsing of external JavaScript using
    dynamic *<script>*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A known hack for forcing a web browser into asynchronous JavaScript downloading
    and parsing without using the *async* attribure is to programatically create *<script>*
    elements that include external JavaScript files and insert them in the DOM. In
    the code below I programatically create the *<script>* element node and then append
    it to the *<body>* element which forces the browser to treat the *<script>* element
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/du94d](http://jsfiddle.net/domenlightenment/du94d)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*### Notes'
  prefs: []
  type: TYPE_NORMAL
- en: A major drawback to using dynamic *<script>* elements is JavaScript files potentially
    get parsed out of the order they are included in the DOM. This raises a dependency
    management issue.
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Using the *onload* call back for asynchronous *<script>*'s so we know when
    its loaded
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *<script>* element [supports a load event](http://pieisgood.org/test/script-link-events/)
    handler (ie. *onload*) that will execute once an external JavaScript file has
    been loaded and executed. In the code below I leverage the *onload* event to create
    a callback programatically notifying us when the JavaScript file has been downloaded
    and exectued.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/XzAFx](http://jsfiddle.net/domenlightenment/XzAFx)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *onload* event is only the tip of the iceberg [avaliable where *onload*
    is supported](http://pieisgood.org/test/script-link-events/) you also have use
    of *onerror*, *load*, and, *error*.
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Be mindful of *<script>* 's placement in HTML for DOM manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given a *<script>* elements synchronous nature, placing one in the *<head>*
    element of an HTML document presents a timing problem if the JavaScript execution
    is dependant upon any of the DOM that proceeds the *<script>*. In a nut shell,
    if JavaScript is executed at the begining of a document that manipulates the DOM,
    that proceeds it, you are going to get a JavaScript error. Proven by the following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Many developers, myself being one of them, for this reason will attempt to place
    all *<script>* elements before the closing *</body>* element. By doing this you
    can rest assured the DOM in front of the *<script>*'s has been parsed and is ready
    for scripting. As well, this strategy will remove a dependancy on DOM ready events
    that can liter a code base.
  prefs: []
  type: TYPE_NORMAL
- en: 10.8 Getting a list of *<script>*'s in the DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *document.scripts* property avaliable from the document object provides
    a list (i.e. an *HTMLCollection*) of all of the scripts currently in the DOM.
    In the code below I leverage this property to gain access to each of the *<script>*
    elements *src* attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]*********'
  prefs: []
  type: TYPE_NORMAL
