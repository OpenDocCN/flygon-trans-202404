- en: 'Recitation 23: Recurrences'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asymptotic complexity has limitations, but it is still a useful tool analyzing
    and improving program performance. The use of big-O notation simplifies the task
    of analyzing performance. For OCaml, we assume that all the reductions performed
    during evaluation take constant time, including all arithmetic operations and
    pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: This assumption may be surprising if you think in terms of the substitution
    model. Substitution may require a lot of work, because a substituted variable
    may appear at many different places in the code. However, the OCaml implementation
    is closer to the environment model of evaluation, in which the actual substitutions
    are never done, but bindings are recorded in a separate *environment* for later
    lookup. Environments can be implemented so that all environment operations, including
    lookup, can be performed in constant time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following multiplication routine for nonnegative integers is correct, but
    not very efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is the order of growth of the time required by `times1` as a function of
    *n*, where *n* is the magnitude of the parameter `b`? Note that the "size" of
    a number can be measured either in terms of its magnitude or in terms of the number
    of digits (the space it takes to write the number down). Often the number of digits
    is used, but here we use the magnitude. Note that it takes only about *log[10]
    x* digits to write down a number of magnitude *x*, thus these two measures are
    very different.
  prefs: []
  type: TYPE_NORMAL
- en: 'We assume that all the primitive operations in the `times1` function (`if`,
    `+`, `=`, and `-`) and the overhead for function calls take constant time. Thus
    if *n*=0, the routine takes some constant time *c*[2]. If *n*>0, the time taken
    on an input of magnitude *n* is at most some constant *c*[1] plus the time taken
    by the recursive call on *n**`-`*`1`. In other words, there are constants *c*[1]
    and *c*[2] such that *T(n)* satisfies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a **recurrence relation** (or simply **recurrence**) defining a function
    T(n). It simply states that the time to multiply a number *a* by another number
    *b* of size *n > 0* is the time required to multiply *a* by a number of size *n`-`1*
    plus a constant amount of work (the primitive operations performed).
  prefs: []
  type: TYPE_NORMAL
- en: The recurrence relation is an inductive definition of a function. This particular
    recurrence relation has a unique **closed-form solution** that defines T(n) without
    any recursion. In order to determine the running time of recursive functions we
    will write recurrences that describe the running time, find closed form solutions
    to them, and express those solutions in terms of Big-O notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding out this particular recurrence gives some idea of how to convert
    it to closed form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: which is *O(n)*.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, we guess a closed form solution for a recurrence, and then prove
    by induction that it holds. Sometimes expanding out the recurrence for a few steps
    can help with the guessing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider a different procedure for multiplying two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Again we want an expression for the running time in terms of *n*, the magnitude
    of the parameter `b`. We assume that double and half operations are constant time
    (these could be done in constant time using arithmetic shift) as well as the standard
    primitives. The recurrence relation for this problem is more complicated than
    the previous one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We somehow need to figure out how often the first versus the second branch
    of this recurrence relation will be taken. It''s easy if *n* is a power of two,
    i.e. if *n = 2^m* for some integer *m*. In this case, the second branch of will
    only get taken when *n* = 1, because *2^m* is even except when *m* = 0, i.e. when
    *n* = 1\. Thus, for this special case we can use the expansion technique above
    to get a closed form in terms of *m*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: which is *O(log n)*. We can show that this is the case using induction.
  prefs: []
  type: TYPE_NORMAL
- en: Strong Induction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strong induction has the same steps as ordinary induction, which you will recall
    from CS 2800, but the induction hypothesis is a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: State the proposition to be proved in terms of *P*(*n*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Base case: show *P*(*n*[0]) is true'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Induction hypothesis: Assume that *P*(*m*) is true for all *n*[0] ≤ *m* ≤ *n*.
    This is different from ordinary induction where we only assume that *P*(*m*) is
    true for *m* = *n*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Induction step: Using the induction hypothesis, prove *P*(*n*+1) is true.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conclusion:  *P*(*n*) is true for all *n* ≥ *n*[0].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can formalize this process as an inference rule that gives us a way to prove
    a proposition ∀n.P(n) for some predicate P. Here are the rules for weak (ordinary)
    and strong induction respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Weak induction:**'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; P(0) &#124; ∀n (P(n) ⇒ P(n+1)) &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ∀n P(n) &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Strong induction:**'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ∀n (∀m (m < n ⇒ P(m)) ⇒ P(n)) &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; ∀n P(n) &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: 'Note that the base case does not occur explicitly in the strong induction rule.
    However, it is still there implicitly: for n=0, you must prove ∀m (m < 0 ⇒ P(m))
    ⇒ P(0), which reduces to P(0) since ∀m (m < 0 ⇒ P(m)) is vacuously true, as there
    are no m < 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, it is often easier to prove asymptotic complexity bounds with
    strong induction than with weak induction, because you have a stronger induction
    hypothesis to work with, namely ∀m m < n ⇒ P(m) rather than P(n). However, the
    two rules are logically equivalent: one can prove the validity of the strong rule
    using the weak rule with the induction hypothesis P''(n) = ∀m (m < n ⇒ P(m)).'
  prefs: []
  type: TYPE_NORMAL
- en: Running Time of times2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s return to the analysis of `times2`. When *n* is a power of 2, we have
    the following recurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We show *T(n) = c[2] log n + c[4]* is the solution to this recurrence using
    strong induction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Base case: *T(1) = c[4] = c[2] log 1 + c[4]*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Induction hypothesis: *T(m) = c[2] log m + c[4]* for all *1 ≤ m < n*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = T(n/2) + c[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*= c[2] log(n/2) + c[4] + c[2]* by I.H.'
  prefs: []
  type: TYPE_NORMAL
- en: '*= c[2](log n − log 2) + c[4] + c[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*= c[2] log n − c[2] + c[4] + c[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*= c[2] log n + c[4]*.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus in the case of an input of size *n* which is a power of 2, the running
    time of `times2` is *O(log n)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the general case, the running time of `times2` is also *O(log n)*, but we
    need a slightly different recurrence to make this easier to show. Note that it
    is not possible for the parameter `b` to be odd on two successive recursive calls
    of `times2`, because when it is odd, one is subtracted making it even. Thus we
    can rewrite the original recurrence as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this new occurrence is analogous to rewriting the code so that both
    recursive calls divide the input size in half:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is a little difficult to come up with a closed form solution to this recurrence.
    However, using strong induction, we can show that whatever it is, it is bounded
    asymptotically by a function of the form *d log n + e* for sufficiently large
    constants *d* and *e*, and that is good enough to show that the solution is *O(log
    n)*. So we want to show by strong induction that *T(n) ≤ d log n + e* for some
    (as yet to be determined) constants *d* and *e*. To find suitable *d* and *e*,
    we'll just jump in and see what we need to make the proof work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Base case: We want *T(1) = c[4] ≤ d log 1 + e*. This will be true provided
    we choose *e ≥ c[4]*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Induction hypothesis: *T(m) ≤ d log m + e* for all *1 ≤ m < n*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step, *n* even:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = T(n/2) + c[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*≤ d log(n/2) + e + c[2]* by I.H.'
  prefs: []
  type: TYPE_NORMAL
- en: '*= d log n − d + e + c[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*≤ d log n + e*, provided we choose *d ≥ c[2]*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step, *n* odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = T((n−1)/2) + c[1] + c[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*≤ d log((n−1)/2) + e + c[1] + c[2]* by I.H.'
  prefs: []
  type: TYPE_NORMAL
- en: '*= d log(n−1) − d + e + c[1] + c[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*≤ d log n − d + e + c[1] + c[2]*'
  prefs: []
  type: TYPE_NORMAL
- en: '*≤ d log n + e*, provided we choose *d ≥ c[1] + c[2]*.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing *d* and *e* just large enough to satisfy all these conditions, we see
    that *T(n) ≤ (c[1] + c[2]) log n + c[4]* for all *n ≥ 1*, therefore *T(n)* is
    *O(log n)*.
  prefs: []
  type: TYPE_NORMAL
