- en: RelProperties of Relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export IndProp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition relation (X: Type) := X → X → Prop.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Print le.
  prefs: []
  type: TYPE_NORMAL
- en: (* ====> Inductive le (n : nat) : nat -> Prop :=              le_n : n <= n
               | le_S : forall m : nat, n <= m -> n <= S m *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check le : nat → nat → Prop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check le : relation nat.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Basic Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As anyone knows who has taken an undergraduate discrete math
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: course, there is a lot to be said about relations in general,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: including ways of classifying relations (as reflexive, transitive,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: etc.), theorems that can be proved generically about certain sorts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of relations, constructions that build one relation from another,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: etc.  For example...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Partial Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A relation R on a set X is a *partial function* if, for every
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x, there is at most one y such that R x y — i.e., R x y[1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and R x y[2] together imply y[1] = y[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For example, the next_nat relation defined earlier is a partial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, the ≤ relation on numbers is not a partial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function.  (Assume, for a contradiction, that ≤ is a partial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function.  But then, since 0 ≤ 0 and 0 ≤ 1, it follows that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 0 = 1.  This is nonsense, so our assumption was
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: contradictory.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show that the total_relation defined in earlier is not a partial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show that the empty_relation that we defined earlier is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: partial function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reflexive Relations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *reflexive* relation on a set X is one for which every element
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of X is related to itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Transitive Relations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A relation R is *transitive* if R a c holds whenever R a b
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and R b c do.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can also prove lt_trans more laboriously by induction,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: without using le_trans.  Do this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove the same thing again by induction on o.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The transitivity of le, in turn, can be used to prove some facts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that will be useful later (e.g., for the proof of antisymmetry
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: below)...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (le_Sn_n_inf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Provide an informal proof of the following theorem:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Theorem: For every n, ¬ (S n ≤ n)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A formal proof of this is an optional exercise below, but try
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: writing an informal proof without doing the formal proof first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Proof:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reflexivity and transitivity are the main concepts we'll need for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: later chapters, but, for a bit of additional practice working with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relations in Coq, let's look at a few other common ones...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Symmetric and Antisymmetric Relations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A relation R is *symmetric* if R a b implies R b a.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A relation R is *antisymmetric* if R a b and R b a together
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: imply a = b — that is, if the only "cycles" in R are trivial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ones.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Equivalence Relations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A relation is an *equivalence* if it's reflexive, symmetric, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: transitive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Partial Orders and Preorders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A relation is a *partial order* when it's reflexive,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*anti*-symmetric, and transitive.  In the Coq standard library'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it's called just "order" for short.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A preorder is almost like a partial order, but doesn't have to be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: antisymmetric.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Reflexive, Transitive Closure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *reflexive, transitive closure* of a relation R is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: smallest relation that contains R and that is both reflexive and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: transitive.  Formally, it is defined like this in the Relations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'module of the Coq standard library:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For example, the reflexive and transitive closure of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: next_nat relation coincides with the le relation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The above definition of reflexive, transitive closure is natural:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it says, explicitly, that the reflexive and transitive closure of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: R is the least relation that includes R and that is closed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: under rules of reflexivity and transitivity.  But it turns out
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that this definition is not very convenient for doing proofs,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: since the "nondeterminism" of the rt_trans rule can sometimes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lead to tricky inductions.  Here is a more useful definition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Our new definition of reflexive, transitive closure "bundles"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the rt_step and rt_trans rules into the single rule step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The left-hand premise of this step is a single use of R,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: leading to a much simpler induction principle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before we go on, we should check that the two definitions do
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: indeed define the same relation...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we prove two lemmas showing that clos_refl_trans_1n mimics
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the behavior of the two "missing" clos_refl_trans
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional (rsc_trans)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we use these facts to prove that the two definitions of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reflexive, transitive closure do indeed define the same
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (rtc_rsc_coincide)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
