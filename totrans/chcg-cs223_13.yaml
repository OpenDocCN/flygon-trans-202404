- en: Red-Black Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Red-black trees are binary search ordered trees that are roughly balanced, resulting
    in *O(log n)* membership, insertion, and deletion operations. The code for this
    lecture can be found in [`RedBlackTrees.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/RedBlackTrees.elm).
  prefs: []
  type: TYPE_NORMAL
- en: All nodes in a red-black tree are colored red or black. Empty nodes are considered
    to be black.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Invariants
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A tree `t` is a valid red-black tree if:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t` satisfies the binary search order property. That is, `bso t == True`, where'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The root node of `t` is black. That is, `color t == B`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No red node in `t` has a red child. That is, `noRedRed t == True`, where
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every path from the root of `t` to a leaf contains the same number of black
    nodes. That is, `okBlack t == True`, where
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When `blackHeight t == Just n`, we refer to `n` as the *black height* of `t`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we do not include `E` nodes in path lengths.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To summarize the invariants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A consequence of the `noRedRed` invariant is that the length of the longest
    path from root to leaf in a red-black tree `t` is at most twice the length of
    the shortest path. Thus, `height t <= 2 * bh t`, where
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**In-Class Exercise**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prove: *∀`t`. `rb t` ⇒ `size t` ≥ `2^(bh t) - 1`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prove: *∀`t`. `rb t` ⇒ `height t` ≤ `2(log(1 + size t))`*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, the height of a red-black tree `t` of size `n` is *O(`log n`)*.
  prefs: []
  type: TYPE_NORMAL
- en: Membership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding an element in a red-black tree proceeds just like finding an element
    in an unbalanced binary search tree (*cf.* [`findBST`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/lectures/AsymptoticAnalysis.html)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Insertion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When not worrying about maintaining the balancedness of a binary search tree,
    the insertion procedure walks down a path in the tree making left and right turns
    as necessary according to the order property. Then, if the element is found nowhere
    in the tree, it is added as a leaf.
  prefs: []
  type: TYPE_NORMAL
- en: This naive approach could simply add a black node at this final position, satisfying
    the `noRedRed` invariant, but unfortunately does not preserve the `blackHeight`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the idea behind the insertion algorithm is to color the new node red,
    possibly resulting in temporary red-red violation, and then walk back up the search
    path fixing and propagrating upwards any violations. The algorithm maintains the
    invariant that at most one red-red violation is allowed at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The `ins` function walks down the search path, inserts a red node as the new
    leaf, and walks back up the search path calling `balance` to fix any temporary
    red-red violations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `balance` function looks for red-red violations, which can occur in one
    of four configurations. In each case, the solution is the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `balance` function fixes a red-red violation when processing a black parent
    node that contains it. If `ins` propagates a red-red violation all the way up
    to the root, there is no call to `balance` to fix it. Therefore, the last step
    in the insertion algorithm is to unconditionally color the new root node black.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Contracts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although it is great to prove properties of pseudocode on paper, it is often
    useful to dynamically check that the input and output behavior of a function is
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: One style of such testing is referred to as *design by contract*, where a function
    may be decorated with predicates (`Bool`-valued functions) that describe preconditions
    on arguments that callers are expected to satisfy and a postconditions on return
    values that the callee is expected to establish.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: may expect `x` to satisfy some predicate `pArg` and may intend `e` to satisfy
    some predicate `pRet`. If either of these expectations is violated at run-time,
    an error should be reported (one that, ideally, can help to identify what part
    of the program is responsible for the failure).
  prefs: []
  type: TYPE_NORMAL
- en: Below is one way to rewrite the above function with such pre- and postconditions.
    Notice how this function is a "wrapper" around the original function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The insertion algorithm is a bit tricky, so let's define wrapper versions with
    contracts to gain more confidence that the implementation corresponds to the analysis
    that we have done on paper.
  prefs: []
  type: TYPE_NORMAL
- en: We start by defining some helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll define versions of the previous functions (labeled with a "`'`")
    that perform contract checks on each invocation. In practice, we would probably
    want to include more descriptive error strings to report upon failure.
  prefs: []
  type: TYPE_NORMAL
- en: The overall `insert'` algorithm expects its argument to satisfy `rb` and returns
    an updated tree that satisfies `rb`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The precondition for `ins'` is interesting, because its argument ought to satisfy
    all the red-black tree invariants except possibly that the color of the root is
    red. The resulting tree has the same `blackHeight` as the original tree and might
    have one red-red violation. We'll omit the `bso` post-condition from `ins'` (and
    `balance'` below) to save a bit of run-time overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `balance'` function expects the subtrees `l` and `r` to have the same `blackHeight`
    and that at most of them has a red-red violation. The resulting tree has the same
    `blackHeight` as a tree constructed directly with the `T` data constructor rather
    than via the different rotations. If one of the four rebalancing cases is triggered,
    then the resulting tree `t'` has `noRedRed` violation. Otherwise, the (untransformed)
    tree `t'` may have one. Therefore, the postcondition is `maybeOneRedRed`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Because pre- and post-conditions are evaluated on every function call (and the
    predicates we have supplied are linear in the size of their arguments), these
    versions run *much* slower than the original versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: During program development, however, we are often willing to trade performance
    in exchange for help with testing and identifying bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Try introducing some bugs into the implementation in order to trigger run-time
    contract violations.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages, such as [Racket](http://racket-lang.org/), provide extensive
    support for specifying and checking contracts. One might imagine an extension
    to Elm that allowed us to write the following more precise function types, which
    automatically get translated to the wrapped functions we have manually written
    above. Notice that, in this syntax, types are "refined" by predicate functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Better still would be for the language to *statically* figure out that these
    contracts will *never* violated at run-time and, hence, do not need to be checked
    dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Alas, in this course, we will not cover *software verification* techniques or
    *dependent type systems* that are able to reason about certain fine-grained program
    invariants like these. But this is a longstanding and very active area of research.
  prefs: []
  type: TYPE_NORMAL
- en: Deletion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting an element from a red-black tree is considerably harder that inserting
    an element. We will not go through the deletion algorithm in class. If you are
    curious, check out [this article](http://matt.might.net/articles/red-black-delete/)
    by Matt Might.
  prefs: []
  type: TYPE_NORMAL
- en: Busting the Stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's great that we have a fast, *O(log n)* insertion algorithm...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '... but the logarithm of `10000` is not very large, and yet we crash and burn.
    What gives?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Ah, the issue is with generating a large `List` of random numbers, not with
    our insertion algorithm. Bummer. Stay tuned for more.
  prefs: []
  type: TYPE_NORMAL
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Required
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Okasaki, Chapter 3.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
