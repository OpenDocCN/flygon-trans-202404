["```\n\n```", "```\n\n# Pairs of Numbers\n\n    In an Inductive type definition, each constructor can take\n    any number of arguments \u2014 none (as with true and O), one (as\n    with S), or more than one, as here:\n\n```", "```\n\n    This declaration can be read: \"There is just one way to\n    construct a pair of numbers: by applying the constructor pair to\n    two arguments of type nat.\"\n\n```", "```\n\n    Here are two simple functions for extracting the first and\n    second components of a pair.  The definitions also illustrate how\n    to do pattern matching on two-argument constructors.\n\n```", "```\n\n    Since pairs are used quite a bit, it is nice to be able to\n    write them with the standard mathematical notation (x,y) instead\n    of pair x y.  We can tell Coq to allow this with a Notation\n    declaration.\n\n```", "```\n\n    The new pair notation can be used both in expressions and in\n    pattern matches (indeed, we've actually seen this already in the\n    previous chapter, in the definition of the minus function \u2014\n    this works because the pair notation is also provided as part of\n    the standard library):\n\n```", "```\n\n    Let's try to prove a few simple facts about pairs.\n\n    If we state things in a particular (and slightly peculiar) way, we\n    can complete proofs with just reflexivity (and its built-in\n    simplification):\n\n```", "```\n\n    But reflexivity is not enough if we state the lemma in a more\n    natural way:\n\n```", "```\n\n    We have to expose the structure of p so that simpl can\n    perform the pattern match in fst and snd.  We can do this with\n    destruct.\n\n```", "```\n\n    Notice that, unlike its behavior with nats, destruct\n    generates just one subgoal here.  That's because natprods can\n    only be constructed in one way. \n\n#### Exercise: 1 star (snd_fst_is_swap)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 1 star, optional (fst_swap_is_snd)\n\n```", "```\n\n    \u2610\n\n```", "```\nInductive natlist : Type :=\n\u00a0\u00a0| nil  : natlist\n\u00a0\u00a0| cons : nat \u2192 natlist \u2192 natlist.\n\n```", "```\nDefinition mylist := cons 1 (cons 2 (cons 3 nil)).\n\n```", "```\nNotation \"x :: l\" := (cons x l)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 60, right associativity).\nNotation \"[ ]\" := nil.\nNotation \"[ x ; .. ; y ]\" := (cons x .. (cons y nil) ..).\n\n```", "```\nDefinition mylist1 := 1 :: (2 :: (3 :: nil)).\nDefinition mylist2 := 1 :: 2 :: 3 :: nil.\nDefinition mylist3 := [1;2;3].\n\n```", "```\n\u00a0\u00a0Notation\u00a0\"x + y\"\u00a0:=\u00a0(plus\u00a0x\u00a0y)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at\u00a0level\u00a050,\u00a0left\u00a0associativity).\n\n    the + operator will bind tighter than ::, so 1 + 2 :: [3]\n   will be parsed, as we'd expect, as (1 + 2) :: [3] rather than 1 + (2 :: [3]).\n\n    (Expressions like \"1 + 2 :: [3]\" can be a little confusing when\n   you read them in a .v file.  The inner brackets, around 3, indicate\n   a list, but the outer brackets, which are invisible in the HTML\n   rendering, are there to instruct the \"coqdoc\" tool that the bracketed\n   part should be displayed as Coq code rather than running text.)\n\n    The second and third Notation declarations above introduce the\n   standard square-bracket notation for lists; the right-hand side of\n   the third one illustrates Coq's syntax for declaring n-ary\n   notations and translating them to nested sequences of binary\n   constructors. \n\n### Repeat\n\n    A number of functions are useful for manipulating lists.\n    For example, the repeat function takes a number n and a\n    count and returns a list of length count where every element\n    is n.\n\n```", "```\n\n### Length\n\n    The length function calculates the length of a list.\n\n```", "```\n\n### Append\n\n    The app function concatenates (appends) two lists.\n\n```", "```\n\n    Actually, app will be used a lot in some parts of what\n    follows, so it is convenient to have an infix operator for it.\n\n```", "```\n\n### Head (with default) and Tail\n\n    Here are two smaller examples of programming with lists.\n    The hd function returns the first element (the \"head\") of the\n    list, while tl returns everything but the first\n    element (the \"tail\").\n    Of course, the empty list has no first element, so we\n    must pass a default value to be returned in that case.\n\n```", "```\n\n### Exercises\n\n#### Exercise: 2 stars, recommended (list_funs)\n\n    Complete the definitions of nonzeros, oddmembers and\n    countoddmembers below. Have a look at the tests to understand\n    what these functions should do.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, advanced (alternate)\n\n    Complete the definition of alternate, which \"zips up\" two lists\n    into one, alternating between elements taken from the first list\n    and elements from the second.  See the tests below for more\n    specific examples.\n\n    Note: one natural and elegant way of writing alternate will fail\n    to satisfy Coq's requirement that all Fixpoint definitions be\n    \"obviously terminating.\"  If you find yourself in this rut, look\n    for a slightly more verbose solution that considers elements of\n    both lists at the same time.  (One possible solution requires\n    defining a new kind of pairs, but this is not the only way.)\n\n```", "```\n\n    \u2610\n\n```", "```\nDefinition bag := natlist.\n\n```", "```\nFixpoint count (v:nat) (s:bag) : nat\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\n```", "```\nExample test_count1:              count 1 [1;2;3;1;4;1] = 3.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_count2:              count 6 [1;2;3;1;4;1] = 0.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition sum : bag \u2192 bag \u2192 bag\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_sum1:              count 1 (sum [1;2;3] [1;4;1]) = 3.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nDefinition add (v:nat) (s:bag) : bag\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_add1:                count 1 (add 1 [1;4;1]) = 3.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_add2:                count 5 (add 1 [1;4;1]) = 0.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nDefinition member (v:nat) (s:bag) : bool\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_member1:             member 1 [1;4;1] = true.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample test_member2:             member 2 [1;4;1] = false.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nFixpoint remove_one (v:nat) (s:bag) : bag\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_remove_one1:\n\u00a0\u00a0count 5 (remove_one 5 [2;1;5;4;1]) = 0.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample test_remove_one2:\n\u00a0\u00a0count 5 (remove_one 5 [2;1;4;1]) = 0.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample test_remove_one3:\n\u00a0\u00a0count 4 (remove_one 5 [2;1;4;5;1;4]) = 2.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample test_remove_one4:\n\u00a0\u00a0count 5 (remove_one 5 [2;1;5;4;5;1;4]) = 1.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nFixpoint remove_all (v:nat) (s:bag) : bag\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_remove_all1:  count 5 (remove_all 5 [2;1;5;4;1]) = 0.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_remove_all2:  count 5 (remove_all 5 [2;1;4;1]) = 0.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_remove_all3:  count 4 (remove_all 5 [2;1;4;5;1;4]) = 2.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_remove_all4:  count 5 (remove_all 5 [2;1;5;4;5;1;4;5;1;4]) = 0.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nFixpoint subset (s[1]:bag) (s[2]:bag) : bool\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_subset1:              subset [1;2] [2;1;4;1] = true.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\nExample test_subset2:              subset [1;2;2] [2;1;4;1] = false.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n(* Theorem\u00a0bag_theorem\u00a0:\u00a0... Proof. \u00a0\u00a0... Qed. *)\n\n```", "```\n\n# Reasoning About Lists\n\n    As with numbers, simple facts about list-processing\n    functions can sometimes be proved entirely by simplification.  For\n    example, the simplification performed by reflexivity is enough\n    for this theorem...\n\n```", "```\n\n    ... because the [] is substituted into the\n    \"scrutinee\" (the value being \"scrutinized\" by the match) in the\n    definition of app, allowing the match itself to be\n    simplified. \n\n    Also, as with numbers, it is sometimes helpful to perform case\n    analysis on the possible shapes (empty or non-empty) of an unknown\n    list.\n\n```", "```\n\n    Here, the nil case works because we've chosen to define\n    tl nil = nil. Notice that the as annotation on the destruct\n    tactic here introduces two names, n and l', corresponding to\n    the fact that the cons constructor for lists takes two\n    arguments (the head and tail of the list it is constructing). \n\n    Usually, though, interesting theorems about lists require\n    induction for their proofs.\n\n```", "```\n\n## Induction on Lists\n\n    Proofs by induction over datatypes like natlist are a\n    little less familiar than standard natural number induction, but\n    the idea is equally simple.  Each Inductive declaration defines\n    a set of data values that can be built up using the declared\n    constructors: a boolean can be either true or false; a number\n    can be either O or S applied to another number; a list can be\n    either nil or cons applied to a number and a list.\n\n    Moreover, applications of the declared constructors to one another\n    are the *only* possible shapes that elements of an inductively\n    defined set can have, and this fact directly gives rise to a way\n    of reasoning about inductively defined sets: a number is either\n    O or else it is S applied to some *smaller* number; a list is\n    either nil or else it is cons applied to some number and some\n    *smaller* list; etc. So, if we have in mind some proposition P\n    that mentions a list l and we want to argue that P holds for\n    *all* lists, we can reason as follows:\n\n*   First, show that P is true of l when l is nil. \n\n*   Then show that P is true of l when l is cons n l' for some number n and some smaller list l', assuming that P is true for l'.\n\n    Since larger lists can only be built up from smaller ones,\n    eventually reaching nil, these two arguments together establish\n    the truth of P for all lists l.  Here's a concrete example:\n\n```", "```\n\n    Notice that, as when doing induction on natural numbers, the\n    as... clause provided to the induction tactic gives a name to\n    the induction hypothesis corresponding to the smaller list l[1]'\n    in the cons case. Once again, this Coq proof is not especially\n    illuminating as a static written document \u2014 it is easy to see\n    what's going on if you are reading the proof in an interactive Coq\n    session and you can see the current goal and context at each\n    point, but this state is not visible in the written-down parts of\n    the Coq proof.  So a natural-language proof \u2014 one written for\n    human readers \u2014 will need to include more explicit signposts; in\n    particular, it will help the reader stay oriented if we remind\n    them exactly what the induction hypothesis is in the second\n    case. \n\n    For comparison, here is an informal proof of the same theorem. \n\n    *Theorem*: For all lists l[1], l[2], and l[3],\n   (l[1] ++ l[2]) ++ l[3] = l[1] ++ (l[2] ++ l[3]).\n\n    *Proof*: By induction on l[1].\n\n*   First, suppose l[1] = []. We must show \n\n    ```", "```\n\n*   Next, suppose l[1] = n::l[1]', with \n\n    ```", "```\n    \u00a0\u00a0((n\u00a0::\u00a0l[1]')\u00a0++\u00a0l[2])\u00a0++\u00a0l[3]\u00a0=\u00a0(n\u00a0::\u00a0l[1]')\u00a0++\u00a0(l[2]\u00a0++\u00a0l[3]).\n\n     By the definition of ++, this follows from \n\n    ```", "```\n\n    ```", "```\n\n### Reversing a List\n\n    For a slightly more involved example of inductive proof over\n    lists, suppose we use app to define a list-reversing function\n    rev:\n\n```", "```\n\n### Properties of rev\n\n    Now let's prove some theorems about our newly defined rev.\n    For something a bit more challenging than what we've seen, let's\n    prove that reversing a list does not change its length.  Our first\n    attempt gets stuck in the successor case...\n\n```", "```\n\n    So let's take the equation relating ++ and length that\n    would have enabled us to make progress and prove it as a separate\n    lemma.\n\n```", "```\n\n    Note that, to make the lemma as general as possible, we\n    quantify over *all* natlists, not just those that result from an\n    application of rev.  This should seem natural, because the truth\n    of the goal clearly doesn't depend on the list having been\n    reversed.  Moreover, it is easier to prove the more general\n    property. \n\n    Now we can complete the original proof.\n\n```", "```\n\n    For comparison, here are informal proofs of these two theorems:\n\n    *Theorem*: For all lists l[1] and l[2],\n       length (l[1] ++ l[2]) = length l[1] + length l[2].\n\n    *Proof*: By induction on l[1].\n\n*   First, suppose l[1] = []. We must show \n\n    ```", "```\n\n*   Next, suppose l[1] = n::l[1]', with \n\n    ```", "```\n    \u00a0\u00a0length\u00a0((n::l[1]')\u00a0++\u00a0l[2])\u00a0=\u00a0length\u00a0(n::l[1]')\u00a0+\u00a0length\u00a0l[2]).\n\n     This follows directly from the definitions of length and ++ together with the induction hypothesis. \u2610\n    ```", "```\n\n    *Theorem*: For all lists l, length (rev l) = length l.\n\n    *Proof*: By induction on l.\n\n*   First, suppose l = []. We must show \n\n    ```", "```\n\n*   Next, suppose l = n::l', with \n\n    ```", "```\n    \u00a0\u00a0length\u00a0(rev\u00a0(n\u00a0::\u00a0l'))\u00a0=\u00a0length\u00a0(n\u00a0::\u00a0l').\n\n     By the definition of rev, this follows from \n\n    ```", "```\n    \u00a0\u00a0length\u00a0(rev\u00a0l')\u00a0+\u00a0length\u00a0[n]\u00a0=\u00a0S\u00a0(length\u00a0l').\n\n     This follows directly from the induction hypothesis and the definition of length. \u2610\n    ```", "```\n\n    ```", "```\n\n    The style of these proofs is rather longwinded and pedantic.\n    After the first few, we might find it easier to follow proofs that\n    give fewer details (which can easily work out in our own minds or\n    on scratch paper if necessary) and just highlight the non-obvious\n    steps.  In this more compressed style, the above proof might look\n    like this: \n\n    *Theorem*:\n     For all lists l, length (rev l) = length l.\n\n    *Proof*: First, observe that length (l ++ [n]) = S (length l)\n     for any l (this follows by a straightforward induction on l).\n     The main property again follows by induction on l, using the\n     observation together with the induction hypothesis in the case\n     where l = n'::l'. \u2610 \n\n    Which style is preferable in a given situation depends on\n    the sophistication of the expected audience and how similar the\n    proof at hand is to ones that the audience will already be\n    familiar with.  The more pedantic style is a good default for our\n    present purposes.\n\n```", "```\n(*\u00a0\u00a0Search\u00a0rev.\u00a0*)\n\n```", "```\n\n## List Exercises, Part 1\n\n#### Exercise: 3 starsM (list_exercises)\n\n    More practice with lists:\n\n```", "```\n\n    There is a short solution to the next one.  If you find yourself\n    getting tangled up, step back and try to look for a simpler\n    way.\n\n```", "```\n\n    An exercise about your implementation of nonzeros:\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars (beq_natlist)\n\n    Fill in the definition of beq_natlist, which compares\n    lists of numbers for equality.  Prove that beq_natlist l l\n    yields true for every list l.\n\n```", "```\n\n    \u2610\n\n```", "```\nTheorem count_member_nonzero : \u2200(s : bag),\n\u00a0\u00a0leb 1 (count 1 (1 :: s)) = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem ble_n_Sn : \u2200n,\n\u00a0\u00a0leb n (S n) = true.\nProof.\n\u00a0\u00a0intros n. induction n as [| n' IHn'].\n\u00a0\u00a0- (*\u00a00\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. reflexivity.\n\u00a0\u00a0- (*\u00a0S\u00a0n'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. rewrite IHn'. reflexivity. Qed.\n\nTheorem remove_decreases_count: \u2200(s : bag),\n\u00a0\u00a0leb (count 0 (remove_one 0 s)) (count 0 s) = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u2200(l[1]\u00a0l[2]\u00a0:\u00a0natlist),\u00a0rev\u00a0l[1]\u00a0=\u00a0rev\u00a0l[2]\u00a0\u2192\u00a0l[1]\u00a0=\u00a0l[2].\n\n    (There is a hard way and an easy way to do this.)\n\n```", "```\n\n    \u2610\n\n```", "```\nFixpoint nth_bad (l:natlist) (n:nat) : nat :=\n\u00a0\u00a0match l with\n\u00a0\u00a0| nil \u21d2 42  (*\u00a0arbitrary!\u00a0*)\n\u00a0\u00a0| a :: l' \u21d2 match beq_nat n O with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| true \u21d2 a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| false \u21d2 nth_bad l' (pred n)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0end.\n\n```", "```\nInductive natoption : Type :=\n\u00a0\u00a0| Some : nat \u2192 natoption\n\u00a0\u00a0| None : natoption.\n\n```", "```\nFixpoint nth_error (l:natlist) (n:nat) : natoption :=\n\u00a0\u00a0match l with\n\u00a0\u00a0| nil \u21d2 None\n\u00a0\u00a0| a :: l' \u21d2 match beq_nat n O with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| true \u21d2 Some a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0| false \u21d2 nth_error l' (pred n)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0end.\n\nExample test_nth_error1 : nth_error [4;5;6;7] 0 = Some 4.\n\n    Proof. reflexivity. Qed.\n\nExample test_nth_error2 : nth_error [4;5;6;7] 3 = Some 7.\n\n    Proof. reflexivity. Qed.\n\nExample test_nth_error3 : nth_error [4;5;6;7] 9 = None.\n\n    Proof. reflexivity. Qed.\n\n```", "```\nFixpoint nth_error' (l:natlist) (n:nat) : natoption :=\n\u00a0\u00a0match l with\n\u00a0\u00a0| nil \u21d2 None\n\u00a0\u00a0| a :: l' \u21d2 if beq_nat n O then Some a\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else nth_error' l' (pred n)\n\u00a0\u00a0end.\n\n```", "```\nDefinition option_elim (d : nat) (o : natoption) : nat :=\n\u00a0\u00a0match o with\n\u00a0\u00a0| Some n' \u21d2 n'\n\u00a0\u00a0| None \u21d2 d\n\u00a0\u00a0end.\n\n```", "```\nDefinition hd_error (l : natlist) : natoption\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nExample test_hd_error1 : hd_error [] = None.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample test_hd_error2 : hd_error [1] = Some 1.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nExample test_hd_error3 : hd_error [5;6] = Some 5.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem option_elim_hd : \u2200(l:natlist) (default:nat),\n\u00a0\u00a0hd default l = option_elim default (hd_error l).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nEnd NatList.\n\n```", "```\nInductive id : Type :=\n\u00a0\u00a0| Id : nat \u2192 id.\n\n```", "```\nDefinition beq_id (x[1] x[2] : id) :=\n\u00a0\u00a0match x[1], x[2] with\n\u00a0\u00a0| Id n[1], Id n[2] \u21d2 beq_nat n[1] n[2]\n\u00a0\u00a0end.\n\n```", "```\nTheorem beq_id_refl : \u2200x, true = beq_id x x.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nModule PartialMap.\nExport NatList.\n\nInductive partial_map : Type :=\n\u00a0\u00a0| empty  : partial_map\n\u00a0\u00a0| record : id \u2192 nat \u2192 partial_map \u2192 partial_map.\n\n```", "```\nDefinition update (d : partial_map)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(x : id) (value : nat)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: partial_map :=\n\u00a0\u00a0record x value d.\n\n```", "```\nFixpoint find (x : id) (d : partial_map) : natoption :=\n\u00a0\u00a0match d with\n\u00a0\u00a0| empty         \u21d2 None\n\u00a0\u00a0| record y v d' \u21d2 if beq_id x y\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0then Some v\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else find x d'\n\u00a0\u00a0end.\n\n```", "```\nTheorem update_eq :\n\u00a0\u00a0\u2200(d : partial_map) (x : id) (v: nat),\n\u00a0\u00a0\u00a0\u00a0find x (update d x v) = Some v.\nProof.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem update_neq :\n\u00a0\u00a0\u2200(d : partial_map) (x y : id) (o: nat),\n\u00a0\u00a0\u00a0\u00a0beq_id x y = false \u2192 find x (update d y o) = find x d.\nProof.\n\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nEnd PartialMap.\n\n```", "```\nInductive baz : Type :=\n\u00a0\u00a0| Baz1 : baz \u2192 baz\n\u00a0\u00a0| Baz2 : baz \u2192 bool \u2192 baz.\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]