["```\n    /home/$USER/.mozilla/firefox/[PROFILE] \n    ```", "```\n    C:\\Users\\%USERNAME%\\[PROFILE] \n    ```", "```\nrequire 'sqlite3'\n\n# Browser history \ndb = SQLite3::Database.new \"places.sqlite\"\n\n# List all tables \ndb.execute  \"SELECT * FROM sqlite_master where type='table'\"\n\n# List all visited URLs (History)\ndb.execute  \"SELECT url FROM moz_places\"\n# List all bookmarks\ndb.execute  \"SELECT title FROM moz_bookmarks\"\n\n# List all Cookies\ndb = SQLite3::Database.new \"cookies.sqlite\"\ndb.execute  \"SELECT baseDomain, name, host, path, value FROM moz_cookies\"\n\n# List all form history\ndb = SQLite3::Database.new \"formhistory.sqlite\"\ndb.execute  \"SELECT fieldname, value FROM moz_formhistory\" \n```", "```\n    /home/$USER/.config/google-chrome/Default \n    ```", "```\n    C:\\Users\\%USERNAME%\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\ \n    ```", "```\nrequire 'sqlite3'\n\n# List all Cookies\ndb = SQLite3::Database.new \"Cookies\"\ndb.execute  \"SELECT host_key, path, name, value FROM cookies\" \n```", "```\nrequire 'win32/registry'\n\n# List keys\nkeyname = 'SOFTWARE\\Clients'\naccess  = Win32::Registry::KEY_ALL_ACCESS\nWin32::Registry::HKEY_LOCAL_MACHINE.open(keyname,  access).keys\n\n# List all MAC address keys\nkeyname= 'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkList\\Signatures\\Unmanaged' \naccess = Win32::Registry::KEY_ALL_ACCESS\nWin32::Registry::HKEY_LOCAL_MACHINE.open(ketname, access).keys\n\nkeyname= 'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkList\\Signatures\\Unmanaged' \naccess = Win32::Registry::KEY_ALL_ACCESS\nWin32::Registry::HKEY_LOCAL_MACHINE.open(keyname, access) do |reg|; \n  reg.each_key{|k, v| puts k, v}\nend \n```", "```\n    gem install ruby_apk \n    ```", "```\nrequire 'ruby_apk'\n\napk = Android::Apk.new('diva-beta.apk')\n\n# listing files in apk\napk.each_file do |name, data|\n  puts \"#{name}: #{data.size}bytes\" # puts file name and data size\nend\n\n# Extract icon data in Apk\nicons = apk.icon\nicons.each do |name, data|\n  File.open(File.basename(name), 'wb') {|f| f.write data } # save to file.\nend\n\n# Extract signature and certificate information from Apk\nsigns = apk.signs                   # retrun Hash(key: signature file path, value: OpenSSL::PKCS7)\nsigns.each do |path, sign|\n  puts path\n  puts sign\nend\n\n# Manifest\n## Get readable xml\nmanifest = apk.manifest\nputs manifest.to_xml\n\n## Listing components and permissions\nmanifest.components.each do |c|     # 'c' is Android::Manifest::Component object\n  puts \"#{c.type}: #{c.name}\"\n  c.intent_filters.each do |filter|\n    puts \"\\t#{filter.type}\"\n  end\nend\n\n## Extract application label string\nputs apk.manifest.label\n\n# Resource\n## Extract resource strings from apk\nrsc = apk.resource\nrsc.strings.each do |str|\n  puts str\nend\n\n## Parse resource file directly\nrsc_data = File.open('resources.arsc', 'rb').read{|f| f.read }\nrsc = Android::Resource.new(rsc_data)\n\n# Resolve resource id\nrsc = apk.resource\n\n## assigns readable resource id\nputs rsc.find('@string/app_name')   # => 'application name'\n\n## assigns hex resource id\nputs rsc.find('@0x7f040000')        # => 'application name'\n\n## you can set lang attribute.\nputs rsc.find('@0x7f040000', :lang => 'ja')\n\n# Dex\n## Extract dex information\ndex = apk.dex\n### listing string table in dex\ndex.strings.each do |str|\n  puts str\nend\n\n### listing all class names\ndex.classes.each do |cls|           # cls is Android::Dex::ClassInfo\n  puts \"class: #{cls.name}\"\n  cls.virtual_methods.each do |m|   # Android::Dex::MethodInfo\n    puts \"\\t#{m.definition}\"        # puts method definition\n  end\nend\n\n## Parse dex file directly\ndex_data = File.open('classes.dex','rb').read{|f| f.read }\ndex = Android::Dex.new(dex_data) \n```", "```\n@pids = []\nDir.glob('/proc/*/cmdline').each do |cmdline_file|\n  processes_name.each do |process|\n    if File.read(cmdline_file).include? \"gnome-keyring-daemon\"\n      @pids << cmdline_file.split('/')[2].to_i  # get the pid number from proc/nnn/cmdline\n    end\n  end\nend \n```", "```\n@pids_maps = []\n@pids.each do |pid|\n  # Open and parse maps file for each pid\n  File.readlines(\"/proc/#{pid}/maps\").each do |line|\n    address, permissions = line.split(' ').first(2)\n    # Find addresses in readable process memory pages\n    if permissions.match(/^r.*/)\n      # Find where pages starts and ends to read, no need to dump the whole memory.\n      memory_start, memory_stop = address.split('-').map{|r| r.to_i(16)}\n      chunk_size = memory_stop - memory_start\n      @pids_maps << {pid: pid, memory_start: memory_start, memory_stop: memory_stop, chunk: chunk_size}\n    end\n  end\nend \n```", "```\nmemory_dump = ''\n\n@pids_maps.each do |pid|\n  chunk_pointer = File.open(\"/proc/#{pid[:pid]}/mem\", 'rb')     # Open mem file\n  chunk_pointer.seek  pid[:memory_start]                        # put reading pointer where page starts\n  memory_dump << chunk_pointer\nend\n\nFile.open('gnome-keyring.dump', 'wb') {|f| f.print memory_dump} # Write dump to the desk as binary \n```", "```\nrequire 'packetfu'\npackets = PacketFu::PcapFile.read_packets 'packets.pcap' \n```", "```\n#!/usr/bin/env ruby\nrequire 'packetfu'\n\npcap_file = ARGV[0]\npackets = PacketFu::PcapFile.read_packets pcap_file\n\npackets.each_with_index do |packet, i|\n  if packet.tcp_dport == 21\n    if packet.payload.match(/(USER|PASS)/)\n      src = [packet.ip_src].pack('N').unpack('C4').join('.')\n      dst = [packet.ip_dst].pack('N').unpack('C4').join('.')\n      puts \"#{src} => #{dst}\"\n      print packet.payload\n    end\n  end\nend \n```", "```\n192.168.2.127 => 192.168.2.128\nUSER ayoi\n192.168.2.127 => 192.168.2.128\nPASS kambingakuilang \n```", "```\n#!/usr/bin/env ruby\n#\n# KING SABRI | @KINGSABRI\n#\nrequire 'socket'\n\nclass Pcap\n\n  def initialize(pcap_file)\n    @pcap_file = open(pcap_file, 'wb')\n    # Pcap Global https://wiki.wireshark.org/Development/LibpcapFileFormat#Global_Header\n    global_header = [\n        0xa1b2c3d4,   # magic_number: used to identify pcap files\n        2,            # version_major\n        4,            # version_minor\n        0,            # thiszone\n        0,            # sigfigs\n        65535,        # snaplen\n        1             # network (link-layer), 1 for Ethernet\n    ].pack('ISSIIII')\n    @pcap_file.write global_header\n  end\n\n  def write(data)\n    time_stamp  = Time.now.to_f.round(2).to_s.split('.').map(&:to_i)\n    data_length = data.length\n    # Pcap Record (Packet) Header: https://wiki.wireshark.org/Development/LibpcapFileFormat#Record_.28Packet.29_Header\n    packet_header = [\n        time_stamp[0],   # ts_sec timestamp seconds\n        time_stamp[1],   # ts_usec timestamp microseconds\n        data_length,     # incl_len the number of bytes of packet data actually captured\n        data_length      # orig_len the length of the packet as it appeared on the network when it was captured\n    ].pack('IIII')\n    record = \"#{packet_header}#{data}\"\n    @pcap_file.write(record)\n  rescue\n    @pcap_file.close\n  end\nend \n\npcap   = Pcap.new(ARGV[0])\nsocket = Socket.new(Socket::PF_PACKET, Socket::SOCK_RAW, 0x03_00)\nloop do\n  raw_data = socket.recvfrom(65535)[0]\n  pcap.write raw_data\nend \n```", "```\napache_logs = File.readlines \"/var/log/apache2/access.log\" \n```", "```\napache_regex = /(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}) - (.{0})- \\[([^\\]]+?)\\] \"(GET|POST|PUT|DELETE) ([^\\s]+?) (HTTP\\/1\\.1)\" (\\d+) (\\d+) \"-\" \"(.*)\"/ \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n\napache_logs = File.readlines \"/var/log/apache2/access.log\"\n\ndef parse(logs) \n\n  apache_regex = /(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}) - (.{0})- \\[([^\\]]+?)\\] \"(GET|POST|PUT|DELETE) ([^\\s]+?) (HTTP\\/1\\.1)\" (\\d+) (\\d+) ([^\\s]+?) \"(.*)\"/\n\n  result_parse = []\n  logs.each do |log|\n    parser = log.scan(apache_regex)[0]\n\n    # If can't parse the log line for any reason.\n    if log.scan(apache_regex)[0].nil?\n      puts \"Can't parse: #{log}\\n\\n\"\n      next\n    end\n\n    parse = \n        {\n          :ip         => parser[0],\n          :user       => parser[1],\n          :time       => parser[2],\n          :method     => parser[3],\n          :uri_path   => parser[4],\n          :protocol   => parser[5],\n          :code       => parser[6],\n          :res_size   => parser[7],\n          :referer    => parser[8],\n          :user_agent => parser[9]\n        }\n    result_parse << parse\n  end\n\n  return result_parse\nend \n\nrequire 'pp'\npp parse(apache_logs) \n```", "```\n[{:ip=>\"127.0.0.1\",\n  :user=>\"\",\n  :time=>\"12/Dec/2015:20:09:05 +0300\",\n  :method=>\"GET\",\n  :uri_path=>\"/\",\n  :protocol=>\"HTTP/1.1\",\n  :code=>\"200\",\n  :res_size=>\"3525\",\n  :referer=>\"\\\"-\\\"\",\n  :user_agent=>\n   \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.80 Safari/537.36\"},\n {:ip=>\"127.0.0.1\",\n  :user=>\"\",\n  :time=>\"12/Dec/2015:20:09:05 +0300\",\n  :method=>\"GET\",\n  :uri_path=>\"/icons/ubuntu-logo.png\",\n  :protocol=>\"HTTP/1.1\",\n  :code=>\"200\",                                                                                                                                                          \n  :res_size=>\"3689\",                                                                                                                                                     \n  :referer=>\"\\\"http://localhost/\\\"\",                                                                                                                                     \n  :user_agent=>                                                                                                                                                          \n   \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.80 Safari/537.36\"},                                                          \n {:ip=>\"127.0.0.1\",                                                                                                                                                      \n  :user=>\"\",                                                                                                                                                             \n  :time=>\"12/Dec/2015:20:09:05 +0300\",                                                                                                                                   \n  :method=>\"GET\",                                                                                                                                                        \n  :uri_path=>\"/favicon.ico\",                                                                                                                                             \n  :protocol=>\"HTTP/1.1\",                                                                                                                                                 \n  :code=>\"404\",                                                                                                                                                          \n  :res_size=>\"500\",                                                                                                                                                      \n  :referer=>\"\\\"http://localhost/\\\"\",                                                                                                                                     \n  :user_agent=>                                                                                                                                                          \n   \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.80 Safari/537.36\"}] \n```", "```\niis_regex = /(\\d{4}-\\d{2}-\\d{2}) (\\d{2}:\\d{2}:\\d{2}) (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}) ([^\\s]++?) (\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}) (\\d{2}) (GET|POST|PUT|DELETE) ([^\\s]++?) - (\\d+) (\\d+) (\\d+) (\\d+) ([^\\s]++?) (.*)/ \n```"]