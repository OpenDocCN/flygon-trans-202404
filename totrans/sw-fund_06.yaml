- en: TacticsMore Basic Tactics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export Poly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem silly1 : ∀(n m o p : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: n = m  →
  prefs: []
  type: TYPE_NORMAL
- en: '[n;o] = [n;p] →'
  prefs: []
  type: TYPE_NORMAL
- en: '[n;o] = [m;p].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m o p eq[1] eq[2].
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← eq[1].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: apply eq[2]. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem silly2 : ∀(n m o p : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: n = m  →
  prefs: []
  type: TYPE_NORMAL
- en: '(∀(q r : nat), q = r → [q;o] = [r;p]) →'
  prefs: []
  type: TYPE_NORMAL
- en: '[n;o] = [m;p].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m o p eq[1] eq[2].
  prefs: []
  type: TYPE_NORMAL
- en: apply eq[2]. apply eq[1]. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem silly2a : ∀(n m : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: (n,n) = (m,m)  →
  prefs: []
  type: TYPE_NORMAL
- en: '(∀(q r : nat), (q,q) = (r,r) → [q] = [r]) →'
  prefs: []
  type: TYPE_NORMAL
- en: '[n] = [m].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m eq[1] eq[2].
  prefs: []
  type: TYPE_NORMAL
- en: apply eq[2]. apply eq[1]. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem silly_ex :'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, evenb n = true → oddb (S n) = true) →
  prefs: []
  type: TYPE_NORMAL
- en: evenb 3 = true →
  prefs: []
  type: TYPE_NORMAL
- en: oddb 4 = true.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem silly3_firsttry : ∀(n : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: true = beq_nat n 5  →
  prefs: []
  type: TYPE_NORMAL
- en: beq_nat (S (S n)) 7 = true.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n H.
  prefs: []
  type: TYPE_NORMAL
- en: simpl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: symmetry.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. (* (This simpl is optional, since apply will perform             simplification first, if needed.) *)
  prefs: []
  type: TYPE_NORMAL
- en: apply H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem rev_exercise1 : ∀(l l'' : list nat),'
  prefs: []
  type: TYPE_NORMAL
- en: l = rev l' →
  prefs: []
  type: TYPE_NORMAL
- en: l' = rev l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The apply ... with ... Tactic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following silly example uses two rewrites in a row to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get from [a,b] to [e,f].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a common pattern, we might like to pull it out
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: as a lemma recording, once and for all, the fact that equality is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: transitive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should be able to use trans_eq to prove the above
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example.  However, to do this we need a slight refinement of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: apply tactic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we simply tell Coq apply trans_eq at this point, it can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tell (by matching the goal against the conclusion of the lemma)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that it should instantiate X with [nat], n with [a,b], and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: o with [e,f].  However, the matching process doesn't determine
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'an instantiation for m: we have to supply one explicitly by'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: adding with (m:=[c,d]) to the invocation of apply.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Actually, we usually don't have to include the name m in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the with clause; Coq is often smart enough to figure out which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'instantiation we''re giving. We could instead write: apply trans_eq with [c;d].'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (apply_with_exercise)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Inductive nat : Type :=
  prefs: []
  type: TYPE_NORMAL
- en: '| O : nat'
  prefs: []
  type: TYPE_NORMAL
- en: '| S : nat → nat.'
  prefs: []
  type: TYPE_NORMAL
- en: It is obvious from this definition that every number has one of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'two forms: either it is the constructor O or it is built by'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: applying the constructor S to another number.  But there is more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'here than meets the eye: implicit in the definition (and in our'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: informal understanding of how datatype declarations work in other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'programming languages) are two more facts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The constructor S is *injective*. That is, if S n = S m, it must be the case
    that n = m.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructors O and S are *disjoint*. That is, O is not equal to S n for
    any n.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar principles apply to all inductively defined types: all'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors are injective, and the values built from distinct
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors are never equal.  For lists, the cons constructor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is injective and nil is different from every non-empty list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For booleans, true and false are different.  (Since neither
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: true nor false take any arguments, their injectivity is not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: interesting.)  And so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq provides a tactic called inversion that allows us to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: exploit these principles in proofs. To see how to use it, let's
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'show explicitly that the S constructor is injective:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By writing inversion H at this point, we are asking Coq to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: generate all equations that it can infer from H as additional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypotheses, replacing variables in the goal as it goes. In the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'present example, this amounts to adding a new hypothesis H[1] : n = m and replacing
    n by m in the goal.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here's a more interesting example that shows how multiple
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equations can be derived at once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can name the equations that inversion generates with an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'as ... clause:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (inversion_ex[3])'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When used on a hypothesis involving an equality between
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*different* constructors (e.g., S n = O), inversion solves the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'goal immediately.  Consider the following proof:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can proceed by case analysis on n. The first case is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: trivial.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the second one doesn''t look so simple: assuming'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: beq_nat 0 (S n') = true, we must show S n' = 0, but the latter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: clearly contradictory!  The way forward lies in the assumption.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After simplifying the goal state, we see that beq_nat 0 (S n'') = true has
    become false = true:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we use inversion on this hypothesis, Coq notices that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the subgoal we are working on is impossible, and therefore removes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it from further consideration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is an instance of a logical principle known as the *principle of explosion*,
    which asserts that a contradictory hypothesis
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: entails anything, even false things!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you find the principle of explosion confusing, remember
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that these proofs are not actually showing that the conclusion of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the statement holds.  Rather, they are arguing that, if the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nonsensical situation described by the premise did somehow arise,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then the nonsensical conclusion would follow.  We'll explore the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: principle of explosion of more detail in the next chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (inversion_ex[6])'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To summarize this discussion, suppose H is a hypothesis in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: context or a previously proven lemma of the form
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem f_equal : ∀(A B : Type) (f: A → B) (x y: A),'
  prefs: []
  type: TYPE_NORMAL
- en: x = y → f x = f y.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros A B f x y eq. rewrite eq. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem S_inj : ∀(n m : nat) (b : bool),'
  prefs: []
  type: TYPE_NORMAL
- en: beq_nat (S n) (S m) = b  →
  prefs: []
  type: TYPE_NORMAL
- en: beq_nat n m = b.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m b H. simpl in H. apply H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem silly3'' : ∀(n : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: (beq_nat n 5 = true → beq_nat (S (S n)) 7 = true) →
  prefs: []
  type: TYPE_NORMAL
- en: true = beq_nat n 5  →
  prefs: []
  type: TYPE_NORMAL
- en: true = beq_nat (S (S n)) 7.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n eq H.
  prefs: []
  type: TYPE_NORMAL
- en: symmetry in H. apply eq in H. symmetry in H.
  prefs: []
  type: TYPE_NORMAL
- en: apply H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_n_n_injective : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: n + n = m + m →
  prefs: []
  type: TYPE_NORMAL
- en: n = m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n. induction n as [| n'].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Varying the Induction Hypothesis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is important to control the exact form of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction hypothesis when carrying out inductive proofs in Coq.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In particular, we need to be careful about which of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assumptions we move (using intros) from the goal to the context
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: before invoking the induction tactic.  For example, suppose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we want to show that the double function is injective — i.e.,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'that it maps different arguments to different results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: intros n. induction n.
  prefs: []
  type: TYPE_NORMAL
- en: all is well.  But if we begin it with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem double_injective_FAILED : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: double n = double m →
  prefs: []
  type: TYPE_NORMAL
- en: n = m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m. induction n as [| n'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = O *) simpl. intros eq. destruct m as [| m''].'
  prefs: []
  type: TYPE_NORMAL
- en: + (* m = O *) reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + (* m = S m' *) inversion eq.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = S n'' *) intros eq. destruct m as [| m''].'
  prefs: []
  type: TYPE_NORMAL
- en: + (* m = O *) inversion eq.
  prefs: []
  type: TYPE_NORMAL
- en: + (* m = S m' *) apply f_equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem double_injective : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: double n = double m →
  prefs: []
  type: TYPE_NORMAL
- en: n = m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n. induction n as [| n'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = O *) simpl. intros m eq. destruct m as [| m''].'
  prefs: []
  type: TYPE_NORMAL
- en: + (* m = O *) reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + (* m = S m' *) inversion eq.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = S n'' *) simpl.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: intros m eq.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: destruct m as [| m'].
  prefs: []
  type: TYPE_NORMAL
- en: + (* m = O *) simpl.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: inversion eq.
  prefs: []
  type: TYPE_NORMAL
- en: + (* m = S m' *)
  prefs: []
  type: TYPE_NORMAL
- en: apply f_equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: apply IHn'. inversion eq. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem beq_nat_true : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: beq_nat n m = true → n = m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem double_injective_take2_FAILED : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: double n = double m →
  prefs: []
  type: TYPE_NORMAL
- en: n = m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m. induction m as [| m'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* m = O *) simpl. intros eq. destruct n as [| n''].'
  prefs: []
  type: TYPE_NORMAL
- en: + (* n = O *) reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + (* n = S n' *) inversion eq.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* m = S m'' *) intros eq. destruct n as [| n''].'
  prefs: []
  type: TYPE_NORMAL
- en: + (* n = O *) inversion eq.
  prefs: []
  type: TYPE_NORMAL
- en: + (* n = S n' *) apply f_equal.
  prefs: []
  type: TYPE_NORMAL
- en: (* Stuck again here, just like before. *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem double_injective_take2 : ∀n m,'
  prefs: []
  type: TYPE_NORMAL
- en: double n = double m →
  prefs: []
  type: TYPE_NORMAL
- en: n = m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m.
  prefs: []
  type: TYPE_NORMAL
- en: (* n and m are both in the context *)
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent n.
  prefs: []
  type: TYPE_NORMAL
- en: (* Now n is back in the goal and we can do induction on      m and get a sufficiently general IH. *)
  prefs: []
  type: TYPE_NORMAL
- en: induction m as [| m'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* m = O *) simpl. intros n eq. destruct n as [| n''].'
  prefs: []
  type: TYPE_NORMAL
- en: + (* n = O *) reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + (* n = S n' *) inversion eq.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* m = S m'' *) intros n eq. destruct n as [| n''].'
  prefs: []
  type: TYPE_NORMAL
- en: + (* n = O *) inversion eq.
  prefs: []
  type: TYPE_NORMAL
- en: + (* n = S n' *) apply f_equal.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHm'. inversion eq. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem beq_id_true : ∀x y,'
  prefs: []
  type: TYPE_NORMAL
- en: beq_id x y = true → x = y.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros [m] [n]. simpl. intros H.
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (H'' : m = n). { apply beq_nat_true. apply H. }'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H'. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem nth_error_after_last: ∀(n : nat) (X : Type) (l : list X),'
  prefs: []
  type: TYPE_NORMAL
- en: length l = n →
  prefs: []
  type: TYPE_NORMAL
- en: nth_error l n = None.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Unfolding Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It sometimes happens that we need to manually unfold a Definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so that we can manipulate its right-hand side.  For example, if we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: define...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '... and try to prove a simple fact about square...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '... we get stuck: simpl doesn''t simplify anything at this point,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and since we haven't proved any other facts about square, there
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is nothing we can apply or rewrite with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To make progress, we can manually unfold the definition of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'square:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have plenty to work with: both sides of the equality are'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions involving multiplication, and we have lots of facts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about multiplication at our disposal.  In particular, we know that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is commutative and associative, and from these facts it is not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hard to finish the proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: At this point, a deeper discussion of unfolding and simplification
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is in order.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may already have observed that tactics like simpl,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reflexivity, and apply will often unfold the definitions of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: functions automatically when this allows them to make progress.  For
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example, if we define foo m to be the constant 5...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: then the simpl in the following proof (or the reflexivity, if
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we omit the simpl) will unfold foo m to (fun x ⇒ 5) m and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then further simplify this expression to just 5.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: However, this automatic unfolding is rather conservative.  For
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example, if we define a slightly more complicated function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involving a pattern match...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '...then the analogous proof will get stuck:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The reason that simpl doesn't make progress here is that it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: notices that, after tentatively unfolding bar m, it is left with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a match whose scrutinee, m, is a variable, so the match cannot
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: be simplified further.  (It is not smart enough to notice that the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: two branches of the match are identical.)  So it gives up on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfolding bar m and leaves it alone.  Similarly, tentatively
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfolding bar (m+1) leaves a match whose scrutinee is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function application (that, itself, cannot be simplified, even
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: after unfolding the definition of +), so simpl leaves it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: alone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, there are two ways to make progress.  One is to use
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: destruct m to break the proof into two cases, each focusing on a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: more concrete choice of m (O vs S _).  In each case, the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match inside of bar can now make progress, and the proof is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: easy to complete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This approach works, but it depends on our recognizing that the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match hidden inside bar is what was preventing us from making
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: progress.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A more straightforward way to make progress is to explicitly tell
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq to unfold bar.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now it is apparent that we are stuck on the match expressions on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: both sides of the =, and we can use destruct to finish the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof without thinking too hard.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Using destruct on Compound Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many examples where destruct is used to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: perform case analysis of the value of some variable.  But
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sometimes we need to reason by cases on the result of some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*expression*.  We can also do this with destruct.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: After unfolding sillyfun in the above proof, we find that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we are stuck on if (beq_nat n 3) then ... else ....  But either
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: n is equal to 3 or it isn't, so we can use destruct (beq_nat n 3) to let us
    reason about the two cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In general, the destruct tactic can be used to perform case
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: analysis of the results of arbitrary computations.  If e is an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expression whose type is some inductively defined type T, then,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for each constructor c of T, destruct e generates a subgoal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in which all occurrences of e (in the goal and in the context)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are replaced by c.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (combine_split)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, destructing compound expressions requires a bit of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: care, as such destructs can sometimes erase information we need
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to complete a proof.  For example, suppose we define a function sillyfun1 like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now suppose that we want to convince Coq of the (rather
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: obvious) fact that sillyfun1 n yields true only when n is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: odd.  By analogy with the proofs we did with sillyfun above, it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is natural to start the proof like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We get stuck at this point because the context does not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: contain enough information to prove the goal!  The problem is that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the substitution performed by destruct is too brutal — it threw
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: away every occurrence of beq_nat n 3, but we need to keep some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: memory of this expression and how it was destructed, because we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need to be able to reason that, since beq_nat n 3 = true in this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: branch of the case analysis, it must be that n = 3, from which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it follows that n is odd.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What we would really like is to substitute away all existing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: occurences of beq_nat n 3, but at the same time add an equation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'to the context that records which case we are in.  The eqn:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: qualifier allows us to introduce such an equation, giving it a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: name that we choose.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars (destruct_eqn_practice)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Additional Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (beq_nat_sym)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advancedM? (beq_nat_sym_informal)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Give an informal proof of this lemma that corresponds to your
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'formal proof above:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Theorem: For any nats n m, beq_nat n m = beq_nat m n.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Proof:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (beq_nat_trans)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advancedM (split_combine)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We proved, in an exercise above, that for all lists of pairs,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: combine is the inverse of split.  How would you formalize the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: statement that split is the inverse of combine?  When is this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: property true?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Complete the definition of split_combine_statement below with a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: property that states that split is the inverse of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: combine. Then, prove that the property holds. (Be sure to leave
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: your induction hypothesis general by not doing intros on more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'things than necessary.  Hint: what property do you need of l[1]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and l[2] for split combine l[1] l[2] = (l[1],l[2]) to be true?)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced (filter_exercise)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This one is a bit challenging.  Pay attention to the form of your
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction hypothesis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 stars, advanced, recommended (forall_exists_challenge)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define two recursive Fixpoints, forallb and existsb.  The
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: first checks whether every element in a list satisfies a given
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'predicate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: existsb (beq_nat 5) [0;2;3;6] = false
  prefs: []
  type: TYPE_NORMAL
- en: existsb (andb true) [true;true;false] = true
  prefs: []
  type: TYPE_NORMAL
- en: existsb oddb [1;0;0;0;0;3] = true
  prefs: []
  type: TYPE_NORMAL
- en: existsb evenb [] = false
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a *nonrecursive* version of existsb — call it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: existsb' — using forallb and negb.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, prove a theorem existsb_existsb' stating that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: existsb' and existsb have the same behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
