- en: Convenience Is not an -ility
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Convenience Is not an -ility
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much has been said about the importance and challenges of designing good API's.
    It's difficult to get right the first time and it's even more difficult to change
    later. Sort of like raising children. Most experienced programmers have learned
    that a good API follows a consistent level of abstraction, exhibits consistency
    and symmetry, and forms the vocabulary for an expressive language. Alas, being
    aware of the guiding principles does not automatically translate into appropriate
    behavior. Eating sweets is bad for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of preaching from on high, I want to pick on a particular API design
    ''strategy,'' one that I encounter time and again: the argument of convenience.
    It typically begins with one of the following ''insights:'''
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: I don't want other classes to have to make two separate calls to do this one
    thing.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should I make another method if it's almost the same as this method? I'll
    just add a simple switch.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'See, it''s very easy: If the second string parameter ends with ".txt", the
    method automatically assumes that the first parameter is a file name, so I really
    don''t need two methods.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While well intended, such arguments are prone to decrease the readability of
    code using the API. A method invocation like
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: is virtually meaningless without knowing the implementation or at least consulting
    the documentation. This method was likely designed for the convenience of the
    implementer as opposed to the convenience of the caller — "I don't want the caller
    to have to make two separate calls" translated into "I didn't want to code up
    two separate methods." There's nothing fundamentally wrong with convenience if
    it's intended to be the antidote to tediousness, clunkiness, or awkwardness. However,
    if we think a bit more carefully about it, the antidote to those symptoms is efficiency,
    consistency, and elegance, not necessarily convenience. APIs are supposed to hide
    underlying complexity, so we can realistically expect good API design to require
    some effort. A single large method could certainly be more convenient to write
    than a well thought-out set of operations, but would it be easier to use?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The metaphor of API as a language can guide us towards better design decisions
    in these situations. An API should provide an expressive language, which gives
    the next layer above sufficient vocabulary to ask and answer useful questions.
    This does not imply it should provide exactly one method, or verb, for each question
    that may be worth asking. A diverse vocabulary allows us to express subtleties
    in meaning. For example, we prefer to say run instead of walk(true), even though
    it could be viewed as essentially the same operation, just executed at different
    speeds. A consistent and well thought out API vocabulary makes for expressive
    and easy to understand code in the next layer up. More importantly, a composable
    vocabulary allows other programmers to use the API in ways you may not have anticipated
    — a great convenience indeed for the users of the API! Next time you are tempted
    to lump a few things together into one API method, remember that the English language
    does not have one word for `MakeUpYourRoomBeQuietAndDoYourHomeWork`, even though
    it would seem really convenient for such a frequently requested operation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将 API 比作一种语言的隐喻可以指导我们在这些情况下做出更好的设计决策。一个 API 应该提供一种表达丰富的语言，这给了上层足够的词汇来提出和回答有用的问题。这并不意味着它应该为每个可能值得提问的问题提供一个方法或动词。一个多样化的词汇可以让我们表达意义上的微妙之处。例如，我们更喜欢说
    run 而不是 walk(true)，尽管它可以被看作是本质上相同的操作，只是以不同的速度执行而已。一个一致而深思熟虑的 API 词汇使得上一层的代码表达丰富且易于理解。更重要的是，一个可组合的词汇允许其他程序员以你可能没有预料到的方式使用
    API —— 这对于 API 的用户来说确实是一个巨大的便利！下次当你想把一些东西捆绑到一个 API 方法中时，记住英语没有一个词对应`整理房间、安静做家庭作业`，尽管对于这样一个经常被请求的操作来说，这似乎真的非常方便。
- en: By [Gregor Hohpe](http://programmer.97things.oreilly.com/wiki/index.php/Gregor_Hohpe)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：[Gregor Hohpe](http://programmer.97things.oreilly.com/wiki/index.php/Gregor_Hohpe)
