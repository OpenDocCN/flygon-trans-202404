- en: PNUTS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PNUTS。
- en: '6.824 2015 Lecture 17: PNUTS'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.824 2015 年讲座 17：PNUTS。
- en: '**Note:** These lecture notes were slightly modified from the ones posted on
    the 6.824 [course website](http://nil.csail.mit.edu/6.824/2015/schedule.html)
    from Spring 2015.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 这些讲义内容稍作修改自 2015 年春季的 6.824 [课程网站](http://nil.csail.mit.edu/6.824/2015/schedule.html)
    上发布的内容。'
- en: PNUTS
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PNUTS。
- en: a solution to the same problem Spanner and memcached solved
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决相同问题的解决方案 Spanner 和 memcached 解决了。
- en: PNUTS is a more-principled designed than the memcache Facebook design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PNUTS 比 Facebook 的 memcache 设计更有原则性。
- en: '"it was actually designed"'
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"它实际上是经过设计的"。'
- en: make reads fast
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使读取快速。
- en: 'upside: web applications are able to do fast local reads due to replication'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优势：由于复制，Web 应用能够进行快速本地读取。
- en: 'downside: writes will be slow, because they need to be replicated'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：写入会很慢，因为它们需要复制。
- en: because writes have to be distributed to all the regions, there will be a fundamental
    delay between when writes happen and when the updates actually propagate
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为写入必须分布到所有区域，所以在写入发生和更新实际传播之间会有一个基本延迟。
- en: '`=>` potential for stale reads'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=>` 可能导致过期读取。'
- en: if there's data that could be updated by concurrent clients, there will be a
    problem with multiple writes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有数据可能被并发客户端更新，那么多次写入就会有问题。
- en: need all regions to see our writes in the same order
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要所有区域以相同的顺序看到我们的写入。
- en: 'Diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图表：。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: each region has its own set of webservers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区域都有自己的一组 Web 服务器。
- en: each region stores all data
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区域都存储所有数据。
- en: each table in a region is partitioned among storage units (SUs)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区域中的每个表都在存储单元（SUs）之间分区。
- en: routers know the partitioning
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器知道分区。
- en: each SU has a disk
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 SU 都有一个磁盘。
- en: Updates
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新。
- en: each record in PNUTS has its own master region through which all writes have
    to go
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PNUTS 中，每条记录都有自己的主区域，所有写入都必须通过它进行。
- en: different than memcache at facebook, they had a master region for *all* records
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Facebook 的 memcache 不同，他们有一个 *所有* 记录的主区域。
- en: in PNUTS every record has a different master
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PNUTS 中，每个记录都有一个不同的主人。
- en: 'Note: a record is just a row in a table (and has an extra field that stores
    its master)'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意：记录只是表中的一行（并有一个额外的字段存储其主人）。
- en: updating records that are in regions far away from the user will take longer
    of course
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新远离用户的区域中的记录将花费更长的时间。
- en: how does the webserver know where to send the update?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务器如何知道要将更新发送到哪里？
- en: contact one of the routers
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系一个路由器。
- en: router looks at the key, knows it's stored in say SU3
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器查看密钥，知道它存储在比如说 SU3 中。
- en: find out from SU3 that a different region `r2` has the master copy
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 SU3 获取信息，了解不同区域 `r2` 具有主副本。
- en: doesn't know which SU at `r2` the record is at
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不知道 `r2` 处的 SU 中记录的位置。
- en: contact one of the routers in `r2`
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系 `r2` 中的一个路由器。
- en: router tells you the SU to store it at
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由器告诉您要将其存储在的 SU。
- en: the SU then needs to send out the update to all the other regions
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 SU 需要将更新发送到所有其他区域。
- en: the SU sends the update to the message brokers
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SU 将更新发送到消息代理。
- en: not clear if SU applies the update to its own disk before
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不清楚 SU 是否在自己的磁盘上应用更新之前。
- en: the message broker writes a copy of the update to the disk because it is *committing*
    to actually sending the update everywhere
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理将更新的副本写入磁盘，因为它正在 *承诺* 实际发送更新到每个地方。
- en: important because we don't want a failed server to result in partially propagating
    the update
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很重要，因为我们不希望失败的服务器导致更新部分传播。
- en: the MB will send it out to other MBs at other sites
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MB 将它发送到其他站点的其他 MB。
- en: somehow the web app needs to find out that the write completes
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某种程度上，Web 应用需要找出写入何时完成。
- en: not clear who sends the ACK back
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不清楚谁发送 ACK 回来。
- en: seems that the MB replies back to the webserver app as soon as it commits the
    update to the disk
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看起来 MB 一旦提交更新到磁盘，就会立即回复给 Web 服务器应用程序。
- en: asynchronous writes because, from POV of webapp, write is done when MB has written
    it to its disk
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步写入，因为从 Web 应用的 POV 来看，写入在 MB 将其写入其磁盘时已完成。
- en: 'why isn''t the MB a bottleneck? It has to write a lot of stuff:'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MB 为什么不是瓶颈？它必须写入很多东西：
- en: different applications have a different message broker
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的应用程序有不同的消息代理。
- en: MB may be able to do much more batching of the writes
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MB 可能能够更多地批处理写入。
- en: maybe also MB writes are also less complex than normal database writes where
    you have to modify Btrees, maybe go through a file system, etc.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或许 MB 的写入也比普通数据库写入要简单，普通数据库写入需要修改 B 树，可能要经过文件系统等。
- en: because they funnel all the writes through some MB they get some semantics for
    writes
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为他们将所有写入通过一些 MB 进行汇集，他们获得了一些写入的语义。
- en: Write semantics
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入语义。
- en: Write order to single records
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对单个记录的写入顺序。
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alice writes where record which has 3 columns (Name, Where, What)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alice's application says `write(what=awake)`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: write goes through PNUTS
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Alice's application says `write(where=work)`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: write goes through PNUTS
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: useful semantics given by PNUTS
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other people in different regions might see
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: alice at home asleep
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: alice at home awake
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: alice at work awake
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: other people won't see a view of the record inconsistent with the order of the
    writes
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: alice at work asleep
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: kind of the main consistency semantics provided by PNUTS
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a result of sequencing the writes through the MBs
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: paper calls this *per-record timeline consistency*
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: note that their model restricts them to only have transactions on a single record
    basis
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When would you care about stale data?
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: after you added something to your shopping cart, you would expect to see it
    there
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads vs. staleness
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Writes, atomic updates
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Example: increment a counter in a record'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Question of the day
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alice comes back from spring break and she:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: removes her mom from her ACL
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: posts spring break photos
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can her mom see her photos due to out-of-order writes?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: If Alice has all the photos her mom can see in a single record, then no.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Assuming the code her mom is executing reads the full record (ACL + photos)
    when doing the check, and doesn't first read the ACL, wait a while and then read
    the photos
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Failures
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If webapp server fails in the middle of doing a bunch of writes, then only partial
    info would have been written to PNUTS, possibly leading to corruption.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: no transactions for multiple writes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If SU crashes and reboots, it can recover from disk and MB can keep retrying
    it
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: What happens when SU loses its disk? It needs to recover the data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: the paper says the SU will clone its data from a SU from another region
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: main challenge is that updates are being sent by MBs to records that are being
    copied
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: either updates go to source of copy, or destination of copy remembers the update
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ultimately they both need to have the update in the end
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Evaluation mostly focuses on latency and not on throughput. Maybe this is specific
    to their needs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Not clear how they can support millions of users with MBs that can only do hundreds
    of writes per second.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Why is it taking them 75ms to do a local update, where everyone is in the same
    region?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: computation, disk, network?
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 75ms is enormous for a write in a DB
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.824 notes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Brian F. Cooper, Raghu Ramakrishnan, Utkarsh Srivastava, Adam Silberstein,
    Philip Bohannon, Hans-Arno Jacobsen, Nick Puz, Daniel Weaver and Ramana Yerneni.
    PNUTS: Yahoo!''s Hosted Data Serving Platform. Proceedings of VLDB, 2008.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Why this paper?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: same basic goals as Facebook/memcache paper, more principled design
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: multi-region is very challenging -- 100ms network delays
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: conscious trade-off between consistency and performance
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is PNUTS' overall goal?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Diagram:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: overall story similar to that of Spanner and Facebook/memcache
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: data centers ("regions") all over the world
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: web applications, e.g. mail, shopping, social net
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: each app probably runs at all regions
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PNUTS keeps state for apps
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PNUTS 为应用程序保留状态
- en: 'per-user: profile, shopping cart, friend list'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个用户：个人资料，购物车，好友列表
- en: 'per-item: book popularity, user comments'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目：图书流行度，用户评论
- en: app might need any piece of data at any data center
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可能需要任何数据中心的任何数据片段
- en: need to handle lots of concurrent updates to different data
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要处理大量并发更新到不同数据的情况
- en: e.g. lots of users must be able to add items to shopping cart at same time thus
    1000s of PNUTS servers
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，许多用户必须能够同时向购物车添加项目，因此有数千个 PNUTS 服务器
- en: 1000s of servers => crashes must be frequent
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数千台服务器 => 崩溃可能频繁发生
- en: Overview
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'Diagram:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图表：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: each region has all data
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区域都有所有数据
- en: each table partitioned by key over storage units
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表按键在存储单元上分区
- en: tablet servers + routers know the partition plan
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平板服务器 + 路由器知道分区计划
- en: Why replicas of all data at multiple regions?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在多个区域复制所有数据的副本？
- en: multiple regions -> each user's data geographically close to user
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个区域 -> 每个用户的数据地理位置接近用户
- en: multiple complete replicas -> maybe survive entire region failure
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个完整副本 -> 可能在整个区域故障时幸存
- en: complete replicas -> read anything quickly
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整副本 -> 快速读取任何内容
- en: since some data used by many users / many regions
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为一些数据被许多用户/许多区域使用
- en: once you have multiple regions, fast reads are very important
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦有了多个区域，快速读取非常重要
- en: What are the drawbacks of a copy at each region?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区域复制的缺点是什么？
- en: updates will be slow, need to contact every region
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新将会很慢，需要联系每个区域
- en: local reads will probably be stale
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地读取可能会过时
- en: updates from multiple regions need to be sorted out
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自多个区域的更新需要进行排序
- en: keep replicas identical
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持副本相同
- en: avoid order anomalies
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免顺序异常
- en: don't lose updates (e.g. read-modify-write for counter)
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要丢失更新（例如用于计数器的读取-修改-写入）
- en: disk space probably not an issue for their uses
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于他们的用途，磁盘空间可能不是问题
- en: What is the data and query model?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据和查询模型是什么？
- en: basically key/value
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本上是键/值
- en: reads/writes probably by column
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读/写可能按列进行
- en: so a write might replace just one column, not whole record
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此写入可能只替换一个列，而不是整个记录
- en: range scan for ordered tables
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序表的范围扫描
- en: How do updates work?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 更新是如何工作的？
- en: app server gets web request, needs to write data in PNUTS
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用服务器收到 Web 请求，需要在 PNUTS 中写入数据
- en: need to update every region!
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要更新每个区域！
- en: why not just have app logic send update to every region?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么不让应用程序逻辑发送更新到每个区域？
- en: what if app crashes after updating only some regions?
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序在更新了一些区域后崩溃会怎样？
- en: what if concurrent updates to same record?
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对同一记录进行并发更新会怎样？
- en: PNUTS has a "record master" for each record
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PNUTS 为每个记录都有一个“记录主节点”
- en: all updates must go through that region
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有更新必须通过该区域进行
- en: each record has a hidden column indicating region of record master
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个记录都有一个隐藏列指示记录主节点的区域
- en: responsible storage unit executes updates one at a time per record
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责存储单元按记录逐个执行更新
- en: tells MB to broadcast update to all regions
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉 MB 广播更新到所有区域
- en: per-record master probably better than Facebook/memcache master region
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个记录的主节点可能比 Facebook/memcache 主节点区域更好
- en: 'So the complete update story (some guesswork):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此完整的更新故事（一些猜测）：
- en: App wants to update some columns of a record, knows key
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序想要更新记录的某些列，知道键
- en: app sends key and update to local SU1
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序发送键和更新到本地 SU1
- en: 'SU1 looks up record master for key: SI2'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SU1 查找键的记录主节点：SI2
- en: SU1 sends update request to router at SI2
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SU1 发送更新请求到 SI2 的路由器
- en: router at SI2 forwards update to local SU2 for key
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SI2 的路由器将更新转发给本地 SU2 以获取键
- en: SU2 sends update to local Message Broker (MB)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SU2 发送更新到本地消息代理（MB）
- en: 'MB stores on disk + backup MB, sends vers # to original app how does MB know
    the vers #? maybe SU2 told it or perhaps SU2 (not MB) replies to original app'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MB 存储在磁盘上 + 备份 MB，将版本号发送给原始应用程序，MB 如何知道版本号？也许是 SU2 告诉它，或者可能是 SU2（而不是 MB）回复给原始应用程序
- en: MB sends update to router at every region
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MB 发送更新到每个区域的路由器
- en: every region updates local copy
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个区域更新本地副本
- en: 'Puzzles:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 谜题：
- en: 3.2.1 says MB is commit point
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.2.1 表示 MB 是提交点
- en: i.e. MB writes to log on two disks, keeps trying to deliver why isn't MB disk
    a terrible bottleneck?
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即 MB 写入两个磁盘上的日志，不断尝试传递，为什么 MB 磁盘不是一个糟糕的瓶颈？
- en: does update go to MB then SU2? or SU2 then MB? or SU2, MB, SU2?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新是先到 MB 还是 SU2？还是 SU2 然后 MB？还是 SU2，MB，SU2？
- en: maybe MB then SU2, since MB is commit point
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是 MB 然后 SU2，因为 MB 是提交点
- en: maybe SU2 then MB, since SU2 has to check it's the record's master and perhaps
    pick the new version number, tho maybe not needed
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能是 SU2 然后 MB，因为 SU2 必须检查它是否是记录的主节点，也许选择新的版本号，尽管可能不需要
- en: 'who replies to client w/ new version #?'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁回复客户端并附带新的版本号？
- en: All writes are multi-region and thus slow -- why does it make sense?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有写入都是多区域的，因此很慢 -- 为什么这样做有意义？
- en: application waits for MB commit but not propagation ("asynchronous")
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序等待 MB 提交但不等待传播（“异步”）
- en: master likely to be local (they claim 80% of the time)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点可能是本地的（他们声称80%的时间是这样）
- en: so MB commit will often be quick
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以 MB 提交通常会很快
- en: and app/user will often see its own writes soon
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用/用户往往会很快看到自己的写入
- en: still, eval says 300ms if master is remote!
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然，如果主节点是远程的，评估会说300毫秒！
- en: 'down side: readers at non-master regions may see stale data'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：非主节点区域的读者可能会看到过时的数据
- en: How does a read-only query execute?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 只读查询如何执行？
- en: multiple kinds of reads (section 2.2) -- why?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多种类型的读取（第2.2节）——为什么？
- en: application gets to choose how consistent
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以选择一致性的方式
- en: '`read-any(k)`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read-any(k)`'
- en: read from local SU
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地 SU 读取
- en: might return stale data (even if you just wrote!)
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能返回过时的数据（即使你刚刚写入！）
- en: 'why: app wants speed but doesn''t care about freshness'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么：应用需要速度但不关心新鲜度
- en: '`read-critical(k, required_version)`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read-critical(k, required_version)`'
- en: maybe read from local SU if it has vers >= required_version
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果本地 SU 具有 vers >= required_version，则可能从本地 SU 读取
- en: otherwise read from master SU?
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则从主节点 SU 读取？
- en: 'why: app wants to see its own write'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么：应用需要看到自己的写入
- en: '`read-latest(k)`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read-latest(k)`'
- en: always read from master SU (? "if local copy too stale")
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是从主节点 SU 读取（? "如果本地副本太陈旧"）
- en: slow if master is remote!
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果主节点是远程的，速度会慢！
- en: 'why: app needs fresh data'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么：应用需要新鲜数据
- en: What if app needs to increment a counter stored in a record?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用需要递增存储在记录中的计数器怎么办？
- en: app reads old value, increments locally, writes new value
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序读取旧值，本地增加，写入新值
- en: what if the local read produced stale data?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果本地读取产生了过时的数据怎么办？
- en: what if read was OK, but concurrent updates?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果读取是OK的，但并发更新呢？
- en: '`test-and-set-write(version#, new value)` gives you atomic update to one record'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`test-and-set-write(version#, new value)` 为您提供对一条记录的原子更新'
- en: 'master rejects the write if current version # != version#'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前版本号不等于版本号，则主节点拒绝写入
- en: so if concurrent updates, one will lose and retry
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以如果并发更新，一个会失败并重试
- en: '`TestAndSet` example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestAndSet` 示例：'
- en: '[PRE7]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Question
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这个问题
- en: how does PNUTS cope with Example 1 (page 2)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PNUTS 如何应对示例1（第2页）？
- en: Initially Alice's mother is in Alice's ACL, so mother can see photos
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初 Alice 的母亲在 Alice 的 ACL 中，所以母亲可以看到照片
- en: Alice removes her mother from ACL
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 从 ACL 中移除她的母亲
- en: Alice posts spring-break photos
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Alice 发布春假照片
- en: 'could her mother see update #2 but not update #1?'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 她的母亲可以看到更新#2但看不到更新#1吗？
- en: esp if mother uses different region than Alice or if Alice does the updates
    from different regions
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是如果母亲使用的区域与 Alice 不同，或者如果 Alice 从不同的区域进行更新
- en: ACL and photo list must be in the same record
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACL 和照片列表必须在同一条记录中
- en: since PNUTS guarantees order only for updates to same record
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 PNUTS 仅保证对同一条记录的更新顺序
- en: Alice sends updates to her record's master region in order
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice 按顺序将更新发送到她记录的主区域
- en: master region broadcasts via MB in order
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点区域按顺序通过 MB 广播
- en: MB tells other regions to apply updates in order
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MB 告诉其他区域按顺序应用更新
- en: 'What if Alice''s mother:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Alice 的母亲怎么办：
- en: reads the old ACL, that includes mother
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取旧的 ACL，其中包括母亲
- en: reads the new photo list
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取新的照片列表
- en: 'answer: just one read of Alice''s record, has both ACL and photo list'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案：只需读取 Alice 的记录一次，包含 ACL 和照片列表
- en: if record doesn't have new ACL, order says it can't have new photos either
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果记录没有新的 ACL，那么顺序就说它也不能有新的照片
- en: How could a storage system get this wrong?
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储系统如何会出现这样的问题？
- en: No ordering through single master (e.g. Dynamo)
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有通过单一主节点进行排序（例如 Dynamo）
- en: How to change record's master if no failures?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有故障，如何更改记录的主节点？
- en: e.g. I move from Boston to LA
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如 我从波士顿搬到洛杉矶
- en: perhaps just update the record, via old master?
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能只需通过旧主节点更新记录？
- en: since ID of master region is stored in the record
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为主区域的 ID 存储在记录中
- en: old master announces change over MB
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧主节点通过 MB 宣布更改
- en: a few subsequent updates might go to the old master
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几次后续更新可能会发送到旧主节点
- en: it will reject them, app retries and finds new master?
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会拒绝它们，应用程序重试并找到新的主节点吗？
- en: What if we wanted to do bank transfers?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要进行银行转账怎么办？
- en: from one account (record) to another
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个账户（记录）到另一个
- en: can `t-a-s-w` be used for this?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t-a-s-w` 可以用于这个吗？'
- en: multi-record updates are not atomic
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多记录更新不是原子的
- en: other readers can see intermediate state
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他读者可以看到中间状态
- en: other writers are not locked out
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他写入者不被锁定
- en: multi-record reads are not atomic
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多记录读取不是原子的
- en: might read one account before xfer, other account after xfer
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能在转账之前读取一个账户，之后读取另一个账户
- en: Is lack of general transactions a problem for web applications?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序缺乏通用事务是一个问题吗？
- en: maybe not, if programmers know to expect it
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序员知道要期望它，可能不会
- en: What about tolerating failures?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如何容忍故障？
- en: App server crashes midway through a set of updates
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务器在更新集合过程中崩溃
- en: not a transaction, so only some of writes will happen
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是一个事务，所以只有一些写入会发生
- en: but master SU/MB either did or didn't get each write
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但主 SU/MB 要么得到了每次写入，要么没有
- en: so each write happens at all regions, or none
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此每次写入都会在所有地区发生，或者都不发生
- en: SU down briefly, or network temporarily broken/lossy
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: SU 短暂宕机，或网络暂时中断/丢包
- en: (I'm guessing here, could be wrong)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （我猜测，可能错误）
- en: MB keeps trying until SU acks
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MB 会不断尝试直到 SU 确认
- en: SU shouldn't ACK until safely on disk
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SU 在安全写入磁盘之前不应该发送 ACK
- en: SU loses disk contents, or doesn't automatically reboot
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: SU 丢失磁盘内容，或不会自动重启
- en: can apps read from remote regions?
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以从远程地区读取吗？
- en: paper doesn't say
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论文没有提到
- en: need to restore disk content from SUs at other regions
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要从其他地区的 SU 恢复磁盘内容
- en: subscribe to MB feed, and save them for now
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅 MB 订阅，并暂时保存它们
- en: copy content from SU at another region
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个地区的 SU 复制内容
- en: replay saved MB updates
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重放保存的 MB 更新
- en: 'Puzzle:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谜题：
- en: how to ensure we didn't miss any MB updates for this SU?
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保我们没有错过此 SU 的任��� MB 更新？
- en: e.g. subscribe to MB at time=100, but source SU only saw through 90?
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，订阅 MB 在时间=100，但源 SU 只看到了90？
- en: will replay apply updates twice? is that harmful?
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会重放应用更新两次吗？这有害吗？
- en: paper mentions sending checkpoint message through MB
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论文提到通过 MB 发送检查点消息
- en: maybe fetch copy as of when the checkpoint arrived
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能在检查点到达时获取副本副本
- en: and only replay after the checkpoint
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并且只在检查点之后重放
- en: BUT no ordering among MB streams from multiple regions
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但没有多个地区的 MB 流之间的排序
- en: MB crashes after accepting update
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: MB 在接受更新后崩溃
- en: logs to disks on two MB servers before ACKing
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ACK 之前将日志写入两个 MB 服务器的磁盘
- en: recovery looks at log, (re)sends logged msgs
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复查看日志，（重新）发送记录的消息
- en: record master SU maybe re-sends an update if MB crash before ACK
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录主 SU 可能在 MB 在 ACK 之前崩溃时重新发送更新
- en: 'maybe record version #s will allow SUs to ignore duplicate'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能记录版本号将允许 SU 忽略重复
- en: MB is a neat idea
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: MB 是一个很好的想法
- en: 'atomic: updates all replicas, or none'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子性：更新所有副本，或者不更新
- en: rather than app server updating replicas (crash...)
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是应用服务器更新副本（崩溃...）
- en: 'reliable: keeps trying, to cope with temporarily SU/region failure'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠：不断尝试，以应对暂时的 SU/地区故障
- en: 'async: apps don''t have to wait for write to complete, good for WAN'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步：应用程序无需等待写入完成，适用于广域网
- en: 'ordered: keeps replicas identical even w/ multiple writers'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序：即使有多个写入者，也保持副本相同
- en: Record's master region loses network connection
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的主地区失去网络连接
- en: can other regions designate a replacement RM?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他地区可以指定替代 RM 吗？
- en: 'no: original RM''s MB may have logged updates, only some sent out'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不：原始 RM 的 MB 可能已记录更新，只发送了一部分
- en: do other regions have to wait indefinitely? yes
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他地区必须无限等待吗？是的
- en: this is one price of ordered updates / strict-ish consistency
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是有序更新/严格一致性的代价之一
- en: Evaluation
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估
- en: Evaluation focuses on latency and scaling, not throughput
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 评估侧重于延迟和扩展性，而不是吞吐量
- en: '5.2: time for an insert while busy'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 5.2：繁忙时插入所需时间
- en: depends on how far away Record Master is
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取决于记录主的距离有多远
- en: 'RM local: 75.6 ms'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RM 本地：75.6 毫秒
- en: 'RM nearby: 131.5 ms'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RM 附近：131.5 毫秒
- en: 'RM other coast: 315.5 ms'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RM 其他海岸：315.5 毫秒
- en: What is 5.2 measuring? from what to what?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 5.2 在测量什么？从什么到什么？
- en: maybe web server starts insert, to RM replies w/ new version?
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能 Web 服务器开始插入，RM 回复新版本？
- en: not time for MB to propagate to all regions
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是 MB 传播到所有地区的时间
- en: since then local RM wouldn't be `< remote`
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '因为本地 RM 不会比远程 `<` '
- en: Why 75 ms?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是 75 毫秒？
- en: Is it 75 ms of network speed-of-light delay?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 75 毫秒是网络光速延迟吗？
- en: 'no: local'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不：本地
- en: Is the 75 ms mostly queuing, waiting for other client's operations?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 75 毫秒主要是排队等待其他客户端操作吗？
- en: 'no: they imply 100 clients was max that didn''t cause delay to rise'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不：他们暗示 100 个客户端是不会导致延迟上升的最大值
- en: End of 5.2 suggests 40 ms of 75 ms in in SU
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 5.2 结尾暗示 75 毫秒中有 40 毫秒在 SU 中
- en: how could it take 40 ms?
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么可能需要 40 毫秒？
- en: each key/value is one file?
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个键/值是一个文件吗？
- en: creating a file takes 3 disk writes (directory, inode, content)?
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个文件需要 3 次磁盘写入（目录，inode，内容）？
- en: what's the other 35 ms?
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外的 35 毫秒是什么？
- en: MB disk write?
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MB 磁盘写入？
- en: But only 33 ms (not 75) for "ordered table" (MySQL/Innodb)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 但“有序表”（MySQL/Innodb）只有 33 毫秒（不是 75）
- en: closer to the one or two disk write we'd expect
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更接近我们期望的一个或两次磁盘写入
- en: '5.3 / Figure 3: effect of increasing request rate'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 5.3 / 图 3：增加请求速率的影响
- en: what do we expect for graph w/ x-axis req rate, y-axis latency?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 x 轴请求速率，y 轴延迟的图表我们期望什么？
- en: system has some inherent capacity, e.g. total disk seeks/second
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统具有某种固有容量，例如总磁盘寻道/秒
- en: for lower rates, constant latency
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于较低速率，恒定延迟
- en: for higher rates, queue grows rapidly, avg latency blows up
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更高的速率，队列迅速增长，平均延迟急剧增加
- en: blow-up should be near max capacity of h/w
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爆炸应该接近硬件的最大容量
- en: 'e.g. # disk arms / seek time'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '例如 # 磁盘臂 / 寻道时间'
- en: we don't see that in Figure 3
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在图 3 中没有看到这一点
- en: apparently their clients were not able to generate too much load
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然他们的客户端无法产生太大的负载
- en: end of 5.3 says clients too slow
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 5.3 节结束时说客户端太慢了
- en: at >= 75 ms/op, 300 clients -> about 4000/sec
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 >= 75 ms/op 时，300 个客户端 -> 大约 4000/sec
- en: text says max possible rate was about 3000/second
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本说最大可能的速率约为每秒 3000 次
- en: 10% writes, so 300 writes/second
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10% 的写入，因此每秒 300 次写入
- en: 5 SU per region, so 60 writes/SU/second
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个区域 5 个 SU，因此每秒 60 次写入/SU
- en: about right if each write does a random disk I/O
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果每次写入都执行随机磁盘 I/O，则大约合适
- en: but you'll need lots of SUs for millions of active users
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是您将需要大量的 SUs 来支持数百万活跃用户
- en: Stepping back, what were PNUTS key design decisions?
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，PNUTS 的关键设计决策是什么？
- en: replication of all data at multiple regions
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多个区域复制所有数据
- en: fast reads, slow writes
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取速度快，写入速度慢
- en: relaxed consistency -- stale reads
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 松散的一致性 -- 陈旧的读取
- en: b/c writes are slow
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为写入速度慢
- en: only single-row transactions w/ test-and-set-write
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有单行事务带有测试和设置写入
- en: sequence all writes thru master region
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有写入都按照主区域的顺序排序
- en: 'pro: keeps replicas identical, enforces serial order on updates, easy to reason
    about'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：保持副本相同，强制更新的序列顺序，易于理解
- en: 'con: slow, no progress if master region disconnected'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：慢，如果主区域断开连接则没有进展
- en: 'Next: Dynamo, a very different design'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步：Dynamo，一个非常不同的设计
- en: async replication, but no master
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步复制，但没有主服务器
- en: eventual consistency
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终一致性
- en: always allow updates
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是允许更新
- en: tree of versions if network partitions
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网络分区，则版本树
- en: readers must reconcile versions
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读者必须调和版本
