- en: 演算子
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演算子
- en: 原文：[https://jsprimer.net/basic/operator/](https://jsprimer.net/basic/operator/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://jsprimer.net/basic/operator/](https://jsprimer.net/basic/operator/)
- en: 演算子はよく利用する演算処理を記号などで表現したものです。 たとえば、足し算をする `+` も演算子の一種です。これ以外にも演算子には多くの種類があります。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 演算子はよく利用する演算処理を記号などで表現したものです。 たとえば、足し算をする `+` も演算子の一種です。これ以外にも演算子には多くの種類があります。
- en: 演算子は演算する対象を持ちます。この演算子の対象のことを**被演算子（オペランド）**と呼びます。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 演算子は演算する対象を持ちます。この演算子の対象のことを**被演算子（オペランド）**と呼びます。
- en: 次のコードでは、`+`演算子が値同士を足し算する加算演算を行っています。 このとき、`+`演算子の対象となっている`1`と`2`という2つの値がオペランドです。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`+`演算子が値同士を足し算する加算演算を行っています。 このとき、`+`演算子の対象となっている`1`と`2`という2つの値がオペランドです。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: このコードでは`+`演算子に対して、前後に合計2つのオペランドがあります。 このように、2つのオペランドを取る演算子を**二項演算子**と呼びます。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: このコードでは`+`演算子に対して、前後に合計2つのオペランドがあります。 このように、2つのオペランドを取る演算子を**二項演算子**と呼びます。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: また、1つの演算子に対して1つのオペランドだけを取るものもあります。 たとえば、数値をインクリメントする`++`演算子は、次のように前後どちらか一方にオペランドを置きます。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: また、1つの演算子に対して1つのオペランドだけを取るものもあります。 たとえば、数値をインクリメントする`++`演算子は、次のように前後どちらか一方にオペランドを置きます。
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: このように、1つのオペランドを取る演算子を**単項演算子**と呼びます。 単項演算子と二項演算子で同じ記号を使うことがあるため、呼び方を変えています。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: このように、1つのオペランドを取る演算子を**単項演算子**と呼びます。 単項演算子と二項演算子で同じ記号を使うことがあるため、呼び方を変えています。
- en: この章では、演算子ごとにそれぞれの処理について学んでいきます。 また、演算子の中でも比較演算子は、JavaScriptでも特に挙動が理解しにくい**暗黙的な型変換**という問題と密接な関係があります。
    そのため、演算子をひととおり見た後に、暗黙的な型変換と明示的な型変換について学んでいきます。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: この章では、演算子ごとにそれぞれの処理について学んでいきます。 また、演算子の中でも比較演算子は、JavaScriptでも特に挙動が理解しにくい**暗黙的な型変換**という問題と密接な関係があります。
    そのため、演算子をひととおり見た後に、暗黙的な型変換と明示的な型変換について学んでいきます。
- en: 演算子の種類は多いため、すべての演算子の動作をここで覚える必要はありません。 必要となったタイミングで、改めてその演算子の動作を見るのがよいでしょう。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 演算子の種類は多いため、すべての演算子の動作をここで覚える必要はありません。 必要となったタイミングで、改めてその演算子の動作を見るのがよいでしょう。
- en: '[](#binary-operator)*二項演算子*'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#binary-operator)*二項演算子*'
- en: '*四則演算など基本的な二項演算子を見ていきます。'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*四則演算など基本的な二項演算子を見ていきます。'
- en: '[](#plus-operator)*プラス演算子（`+`）*'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#plus-operator)*プラス演算子（`+`）*'
- en: '*2つの数値を加算する演算子です。'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*2つの数値を加算する演算子です。'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: JavaScriptでは、数値は内部的にIEEE 754方式の浮動小数点数として表現されています （ [データ型とリテラル](../data-type/)を参照）。
    そのため、整数と浮動小数点数の加算もプラス演算子で行えます。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScriptでは、数値は内部的にIEEE 754方式の浮動小数点数として表現されています （ [データ型とリテラル](../data-type/)を参照）。
    そのため、整数と浮動小数点数の加算もプラス演算子で行えます。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[](#string-combination-operator)*文字列結合演算子（`+`）*'
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#string-combination-operator)*文字列結合演算子（`+`）*'
- en: '*数値の加算に利用したプラス演算子（`+`）は、文字列の結合に利用できます。'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*数値の加算に利用したプラス演算子（`+`）は、文字列の結合に利用できます。'
- en: 文字列結合演算子（`+`）は、2つの文字列を結合した文字列を返します。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 文字列結合演算子（`+`）は、2つの文字列を結合した文字列を返します。
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: つまり、プラス演算子（`+`）は数値同士と文字列同士の演算をします。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: つまり、プラス演算子（`+`）は数値同士と文字列同士の演算をします。
- en: '[](#minus-operator)*マイナス演算子（`-`）*'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#minus-operator)*マイナス演算子（`-`）*'
- en: '*2つの数値を減算する演算子です。左オペランドから右オペランドを減算した値を返します。'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*2つの数値を減算する演算子です。左オペランドから右オペランドを減算した値を返します。'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[](#multiplication-operator)*乗算演算子（`*`）*'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#multiplication-operator)*乗算演算子（`*`）*'
- en: '*2つの数値を乗算する演算子です。'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*2つの数値を乗算する演算子です。'
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[](#division-operator)*除算演算子（`/`）*'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#division-operator)*除算演算子（`/`）*'
- en: '*2つの数値を除算する演算子です。左オペランドを右オペランドで除算した値を返します。'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*2つの数値を除算する演算子です。左オペランドを右オペランドで除算した値を返します。'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ただし、任意の数値を`0`で除算した結果は、無限大を表す数値である`Infinity`となります。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ただし、任意の数値を`0`で除算した結果は、無限大を表す数値である`Infinity`となります。
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[](#modulus-operator)*剰余演算子（`%`）*'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#modulus-operator)*剰余演算子（`%`）*'
- en: '*2つの数値を除算したあまりを求める演算子です。左オペランドを右オペランドで除算したあまりを返します。'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*2つの数値を除算したあまりを求める演算子です。左オペランドを右オペランドで除算したあまりを返します。'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[](#pow-operator)*[ES2016] べき乗演算子（`**`）*'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#pow-operator)*[ES2016] べき乗演算子（`**`）*'
- en: '*2つの数値のべき乗を求める演算子です。 左オペランドを右オペランドでべき乗した値を返します。'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*2つの数値のべき乗を求める演算子です。 左オペランドを右オペランドでべき乗した値を返します。'
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: べき乗演算子と同じ動作をする`Math.pow`メソッドがあります。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: べき乗演算子と同じ動作をする`Math.pow`メソッドがあります。
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: べき乗演算子はES2016で後から追加された演算子であるため、関数と演算子がそれぞれ存在しています。 一方、他の二項演算子は演算子が先に存在していたため、`Math`には対応するメソッドがありません。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: べき乗演算子はES2016で後から追加された演算子であるため、関数と演算子がそれぞれ存在しています。 一方、他の二項演算子は演算子が先に存在していたため、`Math`には対応するメソッドがありません。
- en: '[](#unary-operator)*単項演算子（算術）*'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#unary-operator)*単項演算子（算術）*'
- en: '*単項演算子は、1つのオペランドを受け取り処理する演算子です。'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*単項演算子は、1つのオペランドを受け取り処理する演算子です。'
- en: '[](#unary-plus-operator)*単項プラス演算子（`+`）*'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#unary-plus-operator)*単項プラス演算子（`+`）*'
- en: '*単項演算子の`+`はオペランドを数値に変換します。'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*単項演算子の`+`はオペランドを数値に変換します。'
- en: 次のコードでは、数値の`1`を数値へ変換するため、結果は変わらず数値の`1`です。 `+数値`のように数値に対して、単項プラス演算子をつけるケースはほぼ無いでしょう。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、数値の`1`を数値へ変換するため、結果は変わらず数値の`1`です。 `+数値`のように数値に対して、単項プラス演算子をつけるケースはほぼ無いでしょう。
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: また、単項プラス演算子は、数値以外も数値へと変換します。 次のコードでは、数字（文字列）を数値へ変換しています。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: また、単項プラス演算子は、数値以外も数値へと変換します。 次のコードでは、数字（文字列）を数値へ変換しています。
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 一方、数値に変換できない文字列などは`NaN`という特殊な値へと変換されます。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一方、数値に変換できない文字列などは`NaN`という特殊な値へと変換されます。
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`NaN`は"Not-a-Number"の略称で、数値ではないがNumber型の値を表現しています。 `NaN`はどの値とも（NaN自身に対しても）一致しない特性があり、`Number.isNaN`メソッドを使うことで`NaN`の判定を行えます。'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`は"Not-a-Number"の略称で、数値ではないがNumber型の値を表現しています。 `NaN`はどの値とも（NaN自身に対しても）一致しない特性があり、`Number.isNaN`メソッドを使うことで`NaN`の判定を行えます。'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: しかし、単項プラス演算子は文字列から数値への変換に使うべきではありません。 なぜなら、`Number`コンストラクタ関数や`parseInt`関数などの明示的な変換方法が存在するためです。
    詳しくは「[暗黙的な型変換](../implicit-coercion/ "暗黙的な型変換について解説する章")」の章で解説します。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: しかし、単項プラス演算子は文字列から数値への変換に使うべきではありません。 なぜなら、`Number`コンストラクタ関数や`parseInt`関数などの明示的な変換方法が存在するためです。
    詳しくは「[暗黙的な型変換](../implicit-coercion/ "暗黙的な型変換について解説する章")」の章で解説します。
- en: '[](#unary-minus-operator)*単項マイナス演算子（`-`）*'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#unary-minus-operator)*単項マイナス演算子（`-`）*'
- en: '*単項マイナス演算子はマイナスの数値を記述する場合に利用します。'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*単項マイナス演算子はマイナスの数値を記述する場合に利用します。'
- en: たとえば、マイナスの1という数値を `-1` と書くことができるのは、単項マイナス演算子を利用しているからです。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: たとえば、マイナスの1という数値を `-1` と書くことができるのは、単項マイナス演算子を利用しているからです。
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: また、単項マイナス演算子はマイナスの数値を反転できます。 そのため、"マイナスのマイナスの数値"はプラスの数値となります。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: また、単項マイナス演算子はマイナスの数値を反転できます。 そのため、"マイナスのマイナスの数値"はプラスの数値となります。
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 単項マイナス演算子も文字列などを数値へ変換します。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 単項マイナス演算子も文字列などを数値へ変換します。
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: また、数値へ変換できない文字列などをオペランドに指定した場合は、`NaN`という特殊な値になります。 そのため、単項プラス演算子と同じく、文字列から数値への変換に単項マイナス演算子を使うべきではありません。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: また、数値へ変換できない文字列などをオペランドに指定した場合は、`NaN`という特殊な値になります。 そのため、単項プラス演算子と同じく、文字列から数値への変換に単項マイナス演算子を使うべきではありません。
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[](#increment-operator)*インクリメント演算子（`++`）*'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#increment-operator)*インクリメント演算子（`++`）*'
- en: '*インクリメント演算子（`++`）は、オペランドの数値を`+1`する演算子です。 オペランドの前後どちらかにインクリメント演算子を置くことで、オペランドに対して値を`+1`した値を返します。'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*インクリメント演算子（`++`）は、オペランドの数値を`+1`する演算子です。 オペランドの前後どちらかにインクリメント演算子を置くことで、オペランドに対して値を`+1`した値を返します。'
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: インクリメント演算子（`++`）は、オペランドの前後どちらに置くかによって評価の順番が異なります。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: インクリメント演算子（`++`）は、オペランドの前後どちらに置くかによって評価の順番が異なります。
- en: 後置インクリメント演算子（`num++`）は、次のような順で処理が行われます。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 後置インクリメント演算子（`num++`）は、次のような順で処理が行われます。
- en: '`num`の評価結果を返す'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`num`の評価結果を返す'
- en: '`num`に対して`+1`する'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`num`に対して`+1`する'
- en: そのため、`num++`が返す値は`+1`する前の値となります。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: そのため、`num++`が返す値は`+1`する前の値となります。
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 一方、前置インクリメント演算子（`++num`）は、次のような順で処理が行われます。
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一方、前置インクリメント演算子（`++num`）は、次のような順で処理が行われます。
- en: '`num`に対して`+1`する'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`num`に対して`+1`する'
- en: '`num`の評価結果を返す'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`num`の評価結果を返す'
- en: そのため、`++num`が返す値は`+1`した後の値となります。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: そのため、`++num`が返す値は`+1`した後の値となります。
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: この2つの使い分けが必要となる場面は多くありません。 そのため、評価の順番が異なることだけを覚えておけば問題ないと言えます。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: この2つの使い分けが必要となる場面は多くありません。 そのため、評価の順番が異なることだけを覚えておけば問題ないと言えます。
- en: '[](#decrement-operator)*デクリメント演算子（`--`）*'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#decrement-operator)*デクリメント演算子（`--`）*'
- en: '*デクリメント演算子（`--`）は、オペランドの数値を`-1`する演算子です。'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*デクリメント演算子（`--`）は、オペランドの数値を`-1`する演算子です。'
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: デクリメント演算子は、インクリメント演算子と同様に、オペランドの前後のどちらかに置くことができます。 デクリメント演算子も、前後どちらに置くかで評価の順番が変わります。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: デクリメント演算子は、インクリメント演算子と同様に、オペランドの前後のどちらかに置くことができます。 デクリメント演算子も、前後どちらに置くかで評価の順番が変わります。
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[](#comparison-operator)*比較演算子*'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#comparison-operator)*比較演算子*'
- en: '*比較演算子はオペランド同士の値を比較し、真偽値を返す演算子です。'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*比較演算子はオペランド同士の値を比較し、真偽値を返す演算子です。'
- en: '[](#strict-equal-operator)*厳密等価演算子（`===`）*'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#strict-equal-operator)*厳密等価演算子（`===`）*'
- en: '*厳密等価演算子は、左右の2つのオペランドを比較します。 同じ型で同じ値である場合に、`true`を返します。'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*厳密等価演算子は、左右の2つのオペランドを比較します。 同じ型で同じ値である場合に、`true`を返します。'
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: また、オペランドがどちらもオブジェクトであるときは、 オブジェクトの参照が同じである場合に、`true`を返します。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: また、オペランドがどちらもオブジェクトであるときは、 オブジェクトの参照が同じである場合に、`true`を返します。
- en: 次のコードでは、空のオブジェクトリテラル(`{}`)同士を比較しています。 オブジェクトリテラルは、新しいオブジェクトを作成します。 そのため、異なるオブジェクトを参照する変数を`===`で比較すると`false`を返します。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、空のオブジェクトリテラル(`{}`)同士を比較しています。 オブジェクトリテラルは、新しいオブジェクトを作成します。 そのため、異なるオブジェクトを参照する変数を`===`で比較すると`false`を返します。
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[](#strict-not-equal-operator)*厳密不等価演算子（`!==`）*'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#strict-not-equal-operator)*厳密不等価演算子（`!==`）*'
- en: '*厳密不等価演算子は、左右の2つのオペランドを比較します。 異なる型または異なる値である場合に、`true`を返します。'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*厳密不等価演算子は、左右の2つのオペランドを比較します。 異なる型または異なる値である場合に、`true`を返します。'
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`===`を反転した結果を返す演算子となります。'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`===`を反転した結果を返す演算子となります。'
- en: '[](#equal-operator)*等価演算子（`==`）*'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#equal-operator)*等価演算子（`==`）*'
- en: '*等価演算子（`==`）は、2つのオペランドを比較します。 同じデータ型のオペランドを比較する場合は、厳密等価演算子（`===`）と同じ結果になります。'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*等価演算子（`==`）は、2つのオペランドを比較します。 同じデータ型のオペランドを比較する場合は、厳密等価演算子（`===`）と同じ結果になります。'
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: しかし、等価演算子（`==`）はオペランド同士が異なる型の値であった場合に、 同じ型となるように**暗黙的な型変換**をしてから比較します。
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: しかし、等価演算子（`==`）はオペランド同士が異なる型の値であった場合に、 同じ型となるように**暗黙的な型変換**をしてから比較します。
- en: そのため、次のような、見た目からは結果を予測できない挙動が多く存在します。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: そのため、次のような、見た目からは結果を予測できない挙動が多く存在します。
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 意図しない挙動となることがあるため、暗黙的な型変換が行われる等価演算子（`==`）を使うべきではありません。 代わりに、厳密等価演算子（`===`）を使い、異なる型を比較したい場合は明示的に型を合わせるべきです。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 意図しない挙動となることがあるため、暗黙的な型変換が行われる等価演算子（`==`）を使うべきではありません。 代わりに、厳密等価演算子（`===`）を使い、異なる型を比較したい場合は明示的に型を合わせるべきです。
- en: 例外的に、等価演算子（`==`）が使われるケースとして、`null`と`undefined`の比較があります。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例外的に、等価演算子（`==`）が使われるケースとして、`null`と`undefined`の比較があります。
- en: 次のように、比較したいオペランドが `null` または `undefined` であることを判定したい場合に、 厳密等価演算子（`===`）では二度比較する必要があります。
    等価演算子（`==`）では`null`と`undefined`の比較結果は`true`となるため、一度の比較でよくなります。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 次のように、比較したいオペランドが `null` または `undefined` であることを判定したい場合に、 厳密等価演算子（`===`）では二度比較する必要があります。
    等価演算子（`==`）では`null`と`undefined`の比較結果は`true`となるため、一度の比較でよくなります。
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: このように等価演算子（`==`）を使う例外的なケースはありますが、 等価演算子（`==`）は[暗黙的な型変換](../implicit-coercion/
    "暗黙的な型変換について解説する章")をするため、バグを引き起こしやすいです。 そのため、仕組みを理解するまでは常に厳密等価演算子（`===`）を利用することを推奨します。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: このように等価演算子（`==`）を使う例外的なケースはありますが、 等価演算子（`==`）は[暗黙的な型変換](../implicit-coercion/
    "暗黙的な型変換について解説する章")をするため、バグを引き起こしやすいです。 そのため、仕組みを理解するまでは常に厳密等価演算子（`===`）を利用することを推奨します。
- en: '[](#not-equal-operator)*不等価演算子（`!=`）*'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#not-equal-operator)*不等価演算子（`!=`）*'
- en: '*不等価演算子（`!=`）は、2つのオペランドを比較し、等しくないなら`true`を返します。'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*不等価演算子（`!=`）は、2つのオペランドを比較し、等しくないなら`true`を返します。'
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 不等価演算子も、等価演算子（`==`）と同様に異なる型のオペランドを比較する際に、暗黙的な型変換をしてから比較します。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不等価演算子も、等価演算子（`==`）と同様に異なる型のオペランドを比較する際に、暗黙的な型変換をしてから比較します。
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: そのため、不等価演算子（`!=`）は、利用するべきではありません。 代わりに暗黙的な型変換をしない厳密不等価演算子（`!==`）を利用します。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: そのため、不等価演算子（`!=`）は、利用するべきではありません。 代わりに暗黙的な型変換をしない厳密不等価演算子（`!==`）を利用します。
- en: '[](#more-than)*大なり演算子/より大きい（`>`）*'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#more-than)*大なり演算子/より大きい（`>`）*'
- en: '*大なり演算子は、左オペランドが右オペランドより大きいならば、`true`を返します。'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*大なり演算子は、左オペランドが右オペランドより大きいならば、`true`を返します。'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[](#more-than-equal)*大なりイコール演算子/以上（`>=`）*'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#more-than-equal)*大なりイコール演算子/以上（`>=`）*'
- en: '*大なりイコール演算子は、左オペランドが右オペランドより大きいまたは等しいならば、`true`を返します。'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*大なりイコール演算子は、左オペランドが右オペランドより大きいまたは等しいならば、`true`を返します。'
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[](#less-than)*小なり演算子/より小さい（`<`）*'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#less-than)*小なり演算子/より小さい（`<`）*'
- en: '*小なり演算子は、左オペランドが右オペランドより小さいならば、`true`を返します。'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*小なり演算子は、左オペランドが右オペランドより小さいならば、`true`を返します。'
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[](#less-than-equal)*小なりイコール演算子/以下（`<=`）*'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#less-than-equal)*小なりイコール演算子/以下（`<=`）*'
- en: '*小なりイコール演算子は、左オペランドが右オペランドより小さいまたは等しいならば、`true`を返します。'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*小なりイコール演算子は、左オペランドが右オペランドより小さいまたは等しいならば、`true`を返します。'
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[](#bit-operator)*ビット演算子*'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#bit-operator)*ビット演算子*'
- en: '*ビット演算子では、オペランドである数値を符号付き32ビット整数（`0`と`1`からなる32個のビットの集合）として扱います。'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*ビット演���子では、オペランドである数値を符号付き32ビット整数（`0`と`1`からなる32個のビットの集合）として扱います。'
- en: たとえば、`1`という数値は符号付き32ビット整数のビットでは、`00000000000000000000000000000001` として表現されます。
    わかりやすく4ビットごとに区切ると `0000_0000_0000_0000_0000_0000_0000_0001` のような32ビットの集合となります。
    符号付き32ビット整数では、先頭の最上位ビット（一番左のビット）は符号を表し、`0`の場合は正の値、`1`の場合は負の値であることを示しています。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: たとえば、`1`という数値は符号付き32ビット整数のビットでは、`00000000000000000000000000000001` として表現されます。
    わかりやすく4ビットごとに区切ると `0000_0000_0000_0000_0000_0000_0000_0001` のような32ビットの集合となります。
    符号付き32ビット整数では、先頭の最上位ビット（一番左のビット）は符号を表し、`0`の場合は正の値、`1`の場合は負の値であることを示しています。
- en: '![1の符号付き32bit整数での表現](../Images/298ae64ae40417ba6ef446a8fec80f2b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![1の符号付き32bit整数での表現](../Images/298ae64ae40417ba6ef446a8fec80f2b.png)'
- en: 符号付き32ビット整数では負の数値は、2の補数形式という形式で表現されます。 2の補数とは、それぞれのビットを反転して1ビットを足した値となります。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 符号付き32ビット整数では負の数値は、2の補数形式という形式で表現されます。 2の補数とは、それぞれのビットを反転して1ビットを足した値となります。
- en: たとえば、`-1` という数値の符号付き32ビット整数は、次のように2の補数で求められます。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: たとえば、`-1` という数値の符号付き32ビット整数は、次のように2の補数で求められます。
- en: 10進数の`1`は、符号付き32ビット整数では`0000_0000_0000_0000_0000_0000_0000_0001`となる
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10進数の`1`は、符号付き32ビット整数では`0000_0000_0000_0000_0000_0000_0000_0001`となる
- en: '`0000_0000_0000_0000_0000_0000_0000_0001` の各ビットを反転すると `1111_1111_1111_1111_1111_1111_1111_1110`
    となる'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0000_0000_0000_0000_0000_0000_0000_0001` の各ビットを反転すると `1111_1111_1111_1111_1111_1111_1111_1110`
    となる'
- en: これに1ビットを足すと `1111_1111_1111_1111_1111_1111_1111_1111` となる
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: これに1ビットを足すと `1111_1111_1111_1111_1111_1111_1111_1111` となる
- en: これによって、`-1`の符号付き32ビット整数は `1111_1111_1111_1111_1111_1111_1111_1111` となります。
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: これによって、`-1`の符号付き32ビット整数は `1111_1111_1111_1111_1111_1111_1111_1111` となります。
- en: '![-1の符号付き32ビット整数での表現](../Images/68ca86456c854787fdff42f3f3afef06.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![-1の符号付き32ビット整数での表現](../Images/68ca86456c854787fdff42f3f3afef06.png)'
- en: 符号付き32ビット整数で表現できる数値の範囲は、`1000_0000_0000_0000_0000_0000_0000_0000`から`0111_1111_1111_1111_1111_1111_1111_1111`までとなります。
    10進数に直すと`-(2^31)`（2の31乗の負の数）から `(2^31) - 1`（2の31乗から1引いた数）までとなります。 32ビットを超える数値については、32ビットをはみ出るビットが最上位（一番左）から順番に捨てられます。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 符号付き32ビット整数で表現できる数値の範囲は、`1000_0000_0000_0000_0000_0000_0000_0000`から`0111_1111_1111_1111_1111_1111_1111_1111`までとなります。
    10進数に直すと`-(2^31)`（2の31乗の負の数）から `(2^31) - 1`（2の31乗から1引いた数）までとなります。 32ビットを超える数値については、32ビットをはみ出るビットが最上位（一番左）から順番に捨てられます。
- en: これから見ていくビット演算子はオペランドを符号付き32ビット整数として扱い、その演算結果を10進数の数値として返します。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: これから見ていくビット演算子はオペランドを符号付き32ビット整数として扱い、その演算結果を10進数の数値として返します。
- en: '[](#bit-and)*ビット論理積（`&`）*'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#bit-and)*ビット論理積（`&`）*'
- en: '*ビット論理積演算子（`&`）はビットごとの**AND**演算した結果を返します。 AND演算では、オペランドの各ビットがどちらも`1`の場合は`1`となり、それ以外の場合は`0`となります。'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*ビット論理積演算子（`&`）はビットごとの**AND**演算した結果を返します。 AND演算では、オペランドの各ビットがどちらも`1`の場合は`1`となり、それ以外の場合は`0`となります。'
- en: 次のコードでは、10進数の`15`と`9`をAND演算しています。 `15`は、符号付き32ビット整数では`0000_0000_0000_0000_0000_0000_0000_1111`となります。
    `9`は、符号付き32ビット整数では`0000_0000_0000_0000_0000_0000_0000_1001`となります。 これらをAND演算した結果は`0000_0000_0000_0000_0000_0000_0000_1001`となり、10進数の値である`9`を返します。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、10進数の`15`と`9`をAND演算しています。 `15`は、符号付き32ビット整数では`0000_0000_0000_0000_0000_0000_0000_1111`となります。
    `9`は、符号付き32ビット整数では`0000_0000_0000_0000_0000_0000_0000_1001`となります。 これらをAND演算した結果は`0000_0000_0000_0000_0000_0000_0000_1001`となり、10進数の値である`9`を返します。
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[](#bit-or)*ビット論理和（`|`）*'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#bit-or)*ビット論理和（`|`）*'
- en: '*ビット論理和演算子（`|`）はビットごとの**OR**演算した結果を返します。 OR演算では、オペランドの各ビットがどちらか片方でも`1`の場合は`1`となり、両方とも`0`の場合は`0`となります。'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*ビット論理和演算子（`|`）はビットごとの**OR**演算した結果を返します。 OR演算では、オペランドの各ビットがどちらか片方でも`1`の場合は`1`となり、両方とも`0`の場合は`0`となります。'
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[](#bit-xor)*ビット排他的論理和（`^`）*'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#bit-xor)*ビット排他的論理和（`^`）*'
- en: '*ビット排他的論理和演算子（`^`）はビットごとの**XOR**演算した結果を返します。 XOR演算では、オペランドのビットが異なるなら`1`、両方とも同じなら`0`となります。'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*ビット排他的論理和演算子（`^`）はビットごとの**XOR**演算した結果を返します。 XOR演算では、オペランドのビットが異なるなら`1`、両方とも同じなら`0`となります。'
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[](#bit-not)*ビット否定（`~`）*'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#bit-not)*ビット否定（`~`）*'
- en: '*単項演算子の否定演算子（`~`）はオペランドの各ビットを反転した値を返します。 これは1の補数として知られている値と同じものです。'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*単項演算子の否定演算子（`~`）はオペランドの各ビットを反転した値を返します。 これは1の補数として知られている値と同じものです。'
- en: 次のコードでは、10進数で`15`を否定演算子（`~`）で各ビットを反転させた値を得ています。 `15` は `0000_0000_0000_0000_0000_0000_0000_1111`です。
    各ビットを反転させると`1111_1111_1111_1111_1111_1111_1111_0000`になり、10進数では`-16` となります。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、10進数で`15`を否定演算子（`~`）で各ビットを反転させた値を得ています。 `15` は `0000_0000_0000_0000_0000_0000_0000_1111`です。
    各ビットを反転させると`1111_1111_1111_1111_1111_1111_1111_0000`になり、10進数では`-16` となります。
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`~x`のように`x`をビット否定演算子で演算した結果は、`-(x + 1)`となります。 この性質を利用する形で、ビット否定演算子（`~`）はビット演算以外でも使われていることがあります。'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`~x`のように`x`をビット否定演算子で演算した結果は、`-(x + 1)`となります。 この性質を利用する形で、ビット否定演算子（`~`）はビット演算以外でも使われていることがあります。'
- en: 文字列（Stringオブジェクト）が持つ`indexOf`メソッドは、マッチする文字列を見つけて、そのインデックス（位置）を返すメソッドです。 この`indexOf`メソッドは、検索対象が見つからない場合には`-1`を返します。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 文字列（Stringオブジェクト）が持つ`indexOf`メソッドは、マッチする文字列を見つけて、そのインデックス（位置）を返すメソッドです。 この`indexOf`メソッドは、検索対象が見つからない場合には`-1`を返します。
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 否定演算子（`~`）は1の補数を返すため、`~(-1)`は`0`となります。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 否定演算子（`~`）は1の補数を返すため、`~(-1)`は`0`となります。
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: JavaScriptでは`0`も、if文では`false`として扱われます。 そのため、`~indexOfの結果`が`0`となるのは、その文字列が見つからなかった場合だけとなります。
    次のコードのように否定演算子（`~`）と`indexOf`メソッドを使ったイディオムが一部では使われていました。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScriptでは`0`も、if文では`false`として扱われます。 そのため、`~indexOfの結果`が`0`となるのは、その文字列が見つからなかった場合だけとなります。
    次のコードのように否定演算子（`~`）と`indexOf`メソッドを使ったイディオムが一部では使われていました。
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ES2015では、文字列（Stringオブジェクト）に`includes`メソッドが実装されました。 `includes`メソッドは指定した文字列が含まれているかを真偽値で返します。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015では、文字列（Stringオブジェクト）に`includes`メソッドが実装されました。 `includes`メソッドは指定した文字列が含まれているかを真偽値で返します。
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: そのため、否定演算子（`~`）と`indexOf`メソッドを使ったイディオムは、`includes`メソッドに置き換えられます。
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: そのため、否定演算子（`~`）と`indexOf`メソッドを使ったイディオムは、`includes`メソッドに置き換えられます。
- en: '[](#left-shift)*左シフト演算子（`<<`）*'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#left-shift)*左シフト演算子（`<<`）*'
- en: '*左シフト演算子は、数値である`num`を`bit`の数だけ左へシフトします。 左にあふれたビットは破棄され、`0`のビットを右から詰めます。'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*左シフト演算子は、数値である`num`を`bit`の数だけ左へシフトします。 左にあふれたビットは破棄され、`0`のビットを右から詰めます。'
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 次のコードでは、`9`を2ビット分だけ左へシフトしています。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`9`を2ビット分だけ左へシフトしています。
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[](#right-shift)*右シフト演算子（`>>`）*'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#right-shift)*右シフト演算子（`>>`）*'
- en: '*右シフト演算子は、数値である`num`を`bit`の数だけ右へシフトします。 右にあふれたビットは破棄され、左端のビットのコピーを左から詰めます。'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*右シフト演算子は、数値である`num`を`bit`の数だけ右へシフトします。 右にあふれたビットは破棄され、左端のビットのコピーを左から詰めます。'
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 次のコードでは、`-9`を2ビット分だけ右へシフトしています。 左端のビットのコピーを使うため、常に符号は維持されます。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`-9`を2ビット分だけ右へシフトしています。 左端のビットのコピーを使うため、常に符号は維持されます。
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[](#fill-zero-right-shift)*ゼロ埋め右シフト演算子（`>>>`）*'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#fill-zero-right-shift)*ゼロ埋め右シフト演算子（`>>>`）*'
- en: '*ゼロ埋め右シフト演算子は、数値である`num`を`bit`の数だけ右へシフトするのは右シフト演算子（`>>`）と同じです。 異なる点としては右にあふれたビットは破棄され、`0`のビットを左から詰めます。'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*ゼロ埋め右シフト演算子は、数値である`num`を`bit`の数だけ右へシフトするのは右シフト演算子（`>>`）と同じです。 異なる点としては右にあふれたビットは破棄され、`0`のビットを左から詰めます。'
- en: 次のコードでは、`-9`を2ビット分だけゼロ埋め右シフトしています。 左端のビットは`0`となるため、常に正の値となります。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、`-9`を2ビット分だけゼロ埋め右シフトしています。 左端のビットは`0`となるため、常に正の値となります。
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[](#assignment-operator)*代入演算子（`=`）*'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#assignment-operator)*代入演算子（`=`）*'
- en: '*代入演算子（`=`）は変数に対して値を代入します。 代入演算子については「[変数と宣言](../variables/)」の章も参照してください。'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*代入演算子（`=`）は変数に対して値を代入します。 代入演算子については「[変数と宣言](../variables/)」の章も参照してください。'
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: また、代入演算子は二項演算子と組み合わせて利用できます。 `+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`>>>=`、`&=`、`^=`、`|=`、`**=`のように、演算した結果を代入できます。
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: また、代入演算子は二項演算子と組み合わせて利用できます。 `+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`>>>=`、`&=`、`^=`、`|=`、`**=`のように、演算した結果を代入できます。
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[](#destructuring-assignment)*[ES2015] 分割代入（Destructuring assignment）*'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#destructuring-assignment)*[ES2015] 分割代入（Destructuring assignment）*'
- en: '*今まで見てきた代入演算子は1つの変数に値を代入するものでした。 分割代入を使うことで、配列やオブジェクトの値を複数の変数へ同時に代入できます。 分割代入は短縮記法のひとつでES2015から導入された構文です。'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*今まで見てきた代入演算子は1つの変数に値を代入するものでした。 分割代入を使うことで、配列やオブジェクトの値を複数の変数へ同時に代入できます。 分割代入は短縮記法のひとつでES2015から導入された構文です。'
- en: 分割代入は、代入演算子（`=`）を使うのは同じですが、左辺のオペランドが配列リテラルやオブジェクトリテラルとなります。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 分割代入は、代入演算子（`=`）を使うのは同じですが、左辺のオペランドが配列リテラルやオブジェクトリテラルとなります。
- en: 次のコードでは、右辺の配列の値を、左辺の配列リテラルの対応するインデックスに書かれた変数名へ代入します。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、右辺の配列の値を、左辺の配列リテラルの対応するインデックスに書かれた変数名へ代入します。
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: これは、次のように書いたのと同じ結果になります。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: これは、次のように書いたのと同じ結果になります。
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 同様にオブジェクトも分割代入に対応しています。 オブジェクトの場合は、右辺のオブジェクトのプロパティ値を、左辺に対応するプロパティ名へ代入します。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 同様にオブジェクトも分割代入に対応しています。 オブジェクトの場合は、右辺のオブジェクトのプロパティ値を、左辺に対忈するプロパティ名へ代入します。
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: これは、次のように書いたのと同じ結果になります。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: これは、次のように書いたのと同��結果になります。
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[](#logical-operator)*論理演算子*'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#logical-operator)*論理演算子*'
- en: '*論理演算子は基本的に真偽値を扱う演算子でAND（かつ）、OR（または）、NOT（否定）を表現できます。'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*論理演算子は基本的に真偽値を扱う演算子でAND（かつ）、OR（または）、NOT（否定）を表現できます。'
- en: '[](#and-operator)*AND演算子（`&&`）*'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#and-operator)*AND演算子（`&&`）*'
- en: '*AND演算子（`&&`）は、左辺の値の評価結果が`true`ならば、右辺の評価結果を返します。 一方で、左辺の値の評価結果が`false`ならば、そのまま左辺の値を返します。'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*AND演算子（`&&`）は、左辺の値の評価結果が`true`ならば、右辺の評価結果を返します。 一方で、左辺の値の評価結果が`false`ならば、そのまま左辺の値を返します。'
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: AND演算子（`&&`）は、左辺の評価が`false`の場合、オペランドの右辺は評価されません。 次のように、左辺が`false`の場合は、右辺に書いた`console.log`関数自体が実行されません。
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: AND演算子（`&&`）は、左辺の評価が`false`の場合、オペランドの右辺は評価されません。 次のように、左辺が`false`の場合は、右辺に書いた`console.log`関数自体が実行されません。
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: このような値が決まった時点でそれ以上評価しないことを**短絡評価**と呼びます。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: このような値が決まった時点でそれ以上評価しないことを**短絡評価**と呼びます。
- en: また、AND演算子は左辺を評価する際に、左辺を真偽値へと[暗黙的な型変換](../implicit-coercion/ "暗黙的な型変換について解説する章")をしてから判定します。
    真偽値への暗黙的な型変換では、次に挙げる値は`false`へ変換されます。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: また、AND演算子は左辺を評価する際に、左辺を真偽値へと[暗黙的な型変換](../implicit-coercion/ "暗黙的な型変換について解説する章")をしてから判定します。
    真偽値への暗黙的な型変換では、次に挙げる値は`false`へ変換されます。
- en: '`false`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`undefined`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`null`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`0`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`'
- en: '`0n`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0n`'
- en: '`NaN`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: '`""`（空文字列）'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`（空文字列）'
- en: 暗黙的な型変換によって`false`に変換されるこれらの値をまとめて**falsy**な値と呼びます。 falsyではない値は、`true`へと変換されます。
    `true`へと変換される値の種類は多いため、`false`へと変換されない値は`true`となることは覚えておくとよいです。 このオペランドを真偽値に変換してから評価するのはAND、OR、NOT演算子で共通の動作です。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 暗黙的な型変換によって`false`に変換されるこれらの値をまとめて**falsy**な値と呼びます。 falsyではない値は、`true`へと変換されます。
    `true`へと変換される値の種類は多いため、`false`へと変換されない値は`true`となることは覚えておくとよいです。 このオペランドを真偽値に変換してから評価するのはAND、OR、NOT演算子で共通の動作です。
- en: 次のように、AND演算子（`&&`）は左辺を真偽値へと変換した結果が`true`の場合に、右辺の評価結果を返します。 つまり、左辺がfalsyの場合は、右辺は評価されません。
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 次のように、AND演算子（`&&`）は左辺を真偽値へと変換した結果が`true`の場合に、右辺の評価結果を返します。 つまり、左辺がfalsyの場合は、右辺は評価されません。
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: AND演算子は、if文と組み合わせて利用することが多い演算子です。
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: AND演算子は、if文と組み合わせて利用することが多い演算子です。
- en: 次のように、`value`がString型で **かつ** 値が`"str"`である場合という条件をひとつの式として書くことができます。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 次のように、`value`がString型で **かつ** 値が`"str"`である場合という条件をひとつの式として書くことができます。
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: このときに、`value`がString型でない場合は、その時点でif文の条件式は`false`となります。 そのため、`value`がString型ではない場合は、AND演算子（`&&`）の右辺は評価されずに、if文の中身も実行されません。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: このときに、`value`がString型でない場合は、その時点でif文の条件式は`false`となります。 そのため、`value`がString型ではない場合は、AND漮算子（`&&`）の右辺は評価されずに、if文の中身も実行されません。
- en: AND演算子（`&&`）を使うと、if文のネストに比べて短く書くことができます。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: AND演算子（`&&`）を使うと、if文のネストに比べて短く書くことができます。
- en: しかし、if文が3重4重にネストしているのは複雑なのと同様に、 AND演算子やOR演算子が3つ4つ連続すると複雑で読みにくいコードとなります。 その場合は抽象化ができないかを検討するべきサインとなります。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: しかし、if文が3重4重にネストしているのは複雑なのと同様に、 AND演算子やOR演算子が3つ4つ連続すると複雑で読みにくいコードとなります。 その場合は抽象化ができないかを検討するべきサインとなります。
- en: '[](#or-operator)*OR演算子（`||`）*'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#or-operator)*OR演算子（`||`）*'
- en: '*OR演算子（`||`）は、左辺の値の評価結果が`true`ならば、そのまま左辺の値を返します。 一方で、左辺の値の評価結果が`false`であるならば、右辺の評価結果を返します。'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*OR演算子（`||`）は、左辺の値の評価結果が`true`ならば、そのまま左辺の値を返します。 一方で、左辺の値の評価結果が`false`であるならば、右辺の評価結果を返します。'
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: OR演算子（`||`）は、左辺の評価が`true`の場合、オペランドの右辺を評価しません。 これは、AND演算子（`&&`）と同様の短絡評価となるためです。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: OR演算子（`||`）は、左辺の評価が`true`の場合、オペランドの右辺を評価しません。 これは、AND演算子（`&&`）と同様の短絡評価となるためです。
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: また、OR演算子は左辺を評価する際に、左辺を真偽値へと暗黙的な型変換をします。 次のように、OR演算子は左辺がfalsyの場合には右辺の値を返します。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: また、OR演算子は左辺を評価する際に、左辺を真偽値へと暗黙的な型変換をします。 次のように、OR演算子は左辺がfalsyの場合には右辺の値を返します。
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: OR演算子は、if文と組み合わせて利用することが多い演算子です。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: OR演算子は、if文と組み合わせて利用することが多い演算子です。
- en: 次のように、`value`が`0`**または**`1`の場合にif文の中身が実行されます。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 次のように、`value`が`0`**または**`1`の場合にif文の中身が実行されます。
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[](#not-operator)*NOT演算子（`!`）*'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#not-operator)*NOT演算子（`!`）*'
- en: '*NOT演算子（`!`）は、`オペランド`の評価結果が`true`ならば、`false`を返します。 一方で、`オペランド`の評価結果が`false`ならば、`true`を返します。
    つまり、オペランドの評価結果を反転した真偽値を返します。'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*NOT演算子（`!`）は、`オペランド`の評価結果が`true`ならば、`false`を返します。 一方で、`オペランド`の評価結果が`false`ならば、`true`を返します。
    つまり、オペランドの評価結果を反転した真偽値を返します。'
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: NOT演算子（`!`）もAND演算子（`&&`）とOR演算子（`||`）と同様に真偽値へと[暗黙的な型変換](../implicit-coercion/
    "暗黙的な型変換について解説する章")します。 falsyである値は`true`へ変換され、falsyではない値は`false`へと変換されます。
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: NOT演算子（`!`）もAND演算子（`&&`）とOR演算子（`||`）と同様に真偽値へと[暗黙的な型変換](../implicit-coercion/
    "暗黙的な型変換について解説する章")します。 falsyである値は`true`へ変換され、falsyではない値は`false`へと変換されます。
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: NOT演算子は必ず真偽値を返すため、次のように2つNOT演算子を重ねて真偽値へ変換するという使い方も見かけます。 たとえば、`!!falsyな値`のように2度反転すれば`false`になります。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: NOT演算子は必ず真偽値を返すため、次のように2つNOT演算子を重ねて真偽値へ変換するという使い方も見かけます。 たとえば、`!!falsyな値`のように2度反転すれば`false`になります。
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: このようなケースの多くは、比較演算子を使うなどより明示的な方法で、真偽値を得ることができます。 安易に`!!`による変換に頼るよりは別の方法を探してみるのがいいでしょう。
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: このようなケースの多くは、比較演算子���使うなどより明示的な方法で、真偽値を得ることができます。 安易に`!!`による変換に頼るよりは別の方法を探してみるのがいいでしょう。
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[](#nullish-coalescing-operator)*[ES2020] Nullish coalescing演算子(`??`)*'
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#nullish-coalescing-operator)*[ES2020] Nullish coalescing演算子(`??`)*'
- en: '*Nullish coalescing演算子(`??`)は、左辺の値が**nullish**であるならば、右辺の評価結果を返します。 **nullish**とは、評価結果が`null`または`undefined`となる値のことです。'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*Nullish coalescing演算子(`??`)は、左辺の値が**nullish**であるならば、右辺の評価結果を返します。 **nullish**とは、評価結果が`null`または`undefined`となる値のことです。'
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Nullish coalescing演算子(`??`)とOR演算子（`||`）は、値のデフォルト値を指定する場合によく利用されています。 OR演算子（`||`）は左辺がfalsyの場合に右辺を評価するため、意図しない結果となる場合があります。
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Nullish coalescing演算子(`??`)とOR演算子（`||`）は、値のデフォルト値を指定する場合によく利用されています。 OR演算子（`||`）は左辺がfalsyの場合に右辺を評価するため、意図しない結果となる場合があります。
- en: 次のコードは、`inputValue`が未定義だった場合に、`value`に対するデフォルト値をOR演算子（`||`）で指定しています。 `inputValue`が未定義(`undefined`)の場合は、意図したようにOR演算子（`||`）の右辺で指定した`42`が入ります。
    しかし、`inputValue`が`0`という値であった場合は、`0`はfalsyであるため`value`には右辺の`42`が入ります。 これでは`0`という値が扱えないため、意図しない動作となっています。
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードは、`inputValue`が未定義だった場合に、`value`に対するデフォルト値をOR演算子（`||`）で指定しています。 `inputValue`が未定義(`undefined`)の場合は、意図したようにOR演算子（`||`）の右辺で指定した`42`が入ります。
    しかし、`inputValue`が`0`という値であった場合は、`0`はfalsyであるため`value`には右辺の`42`が入ります。 これでは`0`という値が扱えないため、意図しない動作となっています。
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: この問題を解決するためにES2020でNullish coalescing演算子(`??`)が導入されています。
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: この問題を解決するためにES2020でNullish coalescing演算子(`??`)が導入されています。
- en: Nullish coalescing演算子(`??`)では、左辺がnullishの場合のみ、`value`に右辺で指定した`42`が入ります。 そのため、`inputValue`が`0`という値が入った場合は、`value`にはそのまま`inputValue`の値である`0`が入ります。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Nullish coalescing演算子(`??`)では、左辺がnullishの場合のみ、`value`に右辺で指定した`42`が入ります。 そのため、`inputValue`が`0`という値が入った場合は、`value`にはそのまま`inputValue`の値である`0`が入ります。
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[](#ternary-operator)*条件（三項）演算子（`?`と`:`）*'
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#ternary-operator)*条件（三項）演算子（`?`と`:`）*'
- en: '*条件演算子（`?`と`:`）は三項をとる演算子であるため、三項演算子とも呼ばれます。'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件演算子（`?`と`:`）は三項をとる演算子であるため、三項演算子とも呼ばれます。'
- en: 条件演算子は`条件式`を評価した結果が`true`ならば、`Trueのとき処理する式`の評価結果を返します。 `条件式`が`false`である場合は、`Falseのとき処理する式`の評価結果を返します。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 条件演算子は`条件式`を評価した結果が`true`ならば、`Trueのとき処理する式`の評価結果を返します。 `条件式`が`false`である場合は、`Falseのとき処理する式`の評価結果を返します。
- en: '[PRE72]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: if文との違いは、条件演算子は式として書くことができるため値を返すという点です。 たとえば、次のように`条件式`の評価結果により`"A"` または `"B"`
    どちらかを返します。
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: if文との違いは、条件演算子は式として書くことができるため値を返すという点です。 たとえば、次のよう��`条件式`の評価結果により`"A"` または `"B"`
    どちらかを返します。
- en: '[PRE73]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 条件分岐による値を返せるため、条件によって変数の初期値が違う場合などに使われます。
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 条件分岐による値を返せるため、条件によって変数の初期値が違う場合などに使われます。
- en: 次の例では、`text`文字列に`prefix`となる文字列を先頭につける関数を書いています。 第二引数の`prefix`を省略したり文字列ではないものが指定された場合に、デフォルトの`prefix`を使います。
    第二引数が省略された場合には、`prefix`に`undefined`が入ります。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们编写了一个函数，该函数将一个前缀字符串添加到`text`字符串的开头。如果第二个参数`prefix`被省略或者不是一个字符串，则会使用默认的`prefix`。如果省略了第二个参数，则`prefix`将被设为`undefined`。
- en: 条件演算子の評価結果は値を返すので、`const`を使って宣言と同時に代入できます。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符的评估结果会返回一个值，因此可以使用`const`进行声明和赋值。
- en: '[PRE74]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: if文を使った場合は、宣言と代入を分ける必要があるため、`const`を使うことができません。
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用if语句，需要分开声明和赋值，因此无法使用`const`。
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[](#group-operator)*グループ化演算子（`(`と`)`）*'
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#group-operator)*分组运算符（`(`和`)`）*'
- en: '*グループ化演算子は複数の二項演算子が組み合わさった場合に、演算子の優先順位を明示できる演算子です。'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*分组运算符是一种可以明确表示多个二元运算符组合的运算符的优先级的运算符。'
- en: たとえば、次のようにグループ化演算子で囲んだ部分が最初に処理されるため、結果も変化します。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于首先处理了由分组运算符括起来的部分，因此结果也会发生变化。
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[演算子の優先順位](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table
    "演算子の優先順位 - JavaScript | MDN")はECMAScript仕様で定義されていますが、演算子の優先度をすべて覚えるのは難しいです。 演算子の優先順位の中でもグループ化演算子は優先順位が高く、グループ化演算子を使うことによって優先順位を明示できます。'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[运算符优先级](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table
    "运算符优先级 - JavaScript | MDN")由ECMAScript规范定义，但记住所有运算符的优先级是困难的。 在运算符优先级中，分组运算符的优先级较高，使用分组运算符可以明确优先级。'
- en: 次のようなグループ化演算子を使わずに書いたコードを見てみましょう。 `x`が`true`または、`y`かつ`z`が`true`であるときに処理されます。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看不使用分组运算符编写的代码。 当`x`为`true`或`y`和`z`均为`true`时进行处理。
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ひとつの式に複数の種類の演算子が出てくると読みにくくなる傾向があります。 このような場合にはグループ化演算子を使い、結合順を明示して書くようにしましょう。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式中出现多种类型的运算符，往往会变得难以阅读。 在这种情况下，可以使用分组运算符并明确结合顺序进行编写。
- en: '[PRE78]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: しかし、ひとつの式で多数の演算をするよりも、式自体を分けたほうが読みやすい場合もあります。
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与其在一个表达式中进行多个运算，不如将表达式本身分开可能更易读。
- en: 次のように`a`と`b`が文字列型 または `x`と`y`が数値型の場合に処理するif文を考えてみます。 グループ化演算子を使い、そのまま1つの条件式で書くことも可能ですが、読みにくくなってしまいます。
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下当`a`和`b`是字符串类型或者`x`和`y`是数值类型时的if语句。 虽然可以使用分组运算符直接编写为一个条件表达式，但这会使代码难以阅读。
- en: '[PRE79]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: このように無理して1つの式（1行）で書くよりも、条件式を分解してそれぞれの結果を変数として定義したほうが読みやすくなる場合もあります。
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与其勉强写成一个表达式（一行），不如将条件表达式分解并将每个结果定义为变量更易于阅读。
- en: '[PRE80]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: そのため、グループ化演算子ですべての条件をまとめるのではなく、 それぞれの条件を分解して名前をつける（変数として定義する）ことも重要です。
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其使用分组运算符将所有条件组合在一起，不如将每个条件分解并赋予名称（作为变量定义）同样重要。
- en: '[](#comma-operator)*カンマ演算子（`,`）*'
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#comma-operator)*逗号运算符（`,`）*'
- en: '*カンマ演算子（`,`）は、カンマ（`,`）で区切った式を左から順に評価し、 最後の式の評価結果を返します。'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*逗号运算符（`,`）会依次评估用逗号（`,`）分隔的表达式， 并返回最后一个表达式的评估结果。'
- en: 次の例では、`式1`、`式2`、`式3`の順に評価され、`式3`の評価結果を返します。
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，将依次评估`expression1`、`expression2`和`expression3`，并返回`expression3`的评估结果。
- en: '[PRE81]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: これまでに、カンマで区切るという表現は、`const`による変数宣言などでも出てきました。 左から順に実行する点ではカンマ演算子の挙動は同じものですが、構文としては似て非なるものです。
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到，逗号分隔的概念也出现在使用`const`声明变量等地方。 在从左到右执行方面，逗号运算符的行为与其相同，但语法不同。
- en: '[PRE82]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 一般にカンマ演算子を利用する機会はほとんどないため、「カンマで区切った式は左から順に評価される」ということだけを知っていれば問題ありません。^([1](#fn_1))
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，很少会使用逗号运算符，因此只需知道“逗号分隔的表达式会从左到右进行评估”就可以了。^([1](#fn_1))
- en: '[](#conclusion)*まとめ*'
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#conclusion)*总结*'
- en: '*この章では演算子について学びました。'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章介绍了运算符。'
- en: 演算子はよく利用する演算処理を記号などで表現したもの
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符是用符号等表示常用运算操作的符号
- en: 四則演算や論理演算などさまざまな種類の演算子がある
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有各种类型的运算符，如四则运算和逻辑运算
- en: 演算子には優先順位が定義されており、グループ化演算子で明示できる
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符有优先级，可以通过分组运算符来明确
- en: ¹. カンマ演算子を活用したテクニックとしてindirect callというものがあります。[https://2ality.com/2014/01/eval.html](https://2ality.com/2014/01/eval.html)
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")*****************************************
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹. 使用逗号运算符的技巧之一是间接调用。[https://2ality.com/2014/01/eval.html](https://2ality.com/2014/01/eval.html)
    [↩](#reffn_1 "返回注释[1]的文本。")
