- en: 'Recitation 7: Examples of evaluation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We started off this course using the **substitution model** to understand how
    OCaml programs evaluate. The basic idea is simple: evaluate subexpressions to
    values, and when you have a function call, *substitute* the argument value for
    the formal parameter within the body of the function, and then evaluate the resulting
    expression.'
  prefs: []
  type: TYPE_NORMAL
- en: But the substitution model is not without its shortcomings.Â  It's not a very
    efficient or realistic model of OCaml programs are really evaluated. It's also
    difficult to extend the substitution model to support side effects, which we will
    soon be covering. So last week we introduced a more realistic semantics called
    the **environment model** that is much closer to how OCaml is really implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The environment model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s review the environment model. We start with a core sublanguage of OCaml:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where `*e*` represents an expression, `*c*` a constant, `(*op*)` a built-in
    operator, `*x*` and `*f*` an identifier, `*C*` a constructor, and `*p*` a pattern.
    Expressions are evaluated with respect to an *environment*, which is a mapping
    from identifiers to values. We can think of an environment as a set of substitutions
    that we have delayed making.
  prefs: []
  type: TYPE_NORMAL
- en: '*Values* are, except for *closures*, a syntactic subset of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where `*env*` is an environment and `<< f, **fun** *x* -> *e*, *env* >>` is
    a recursive closure. The closure records the name `*f*` of a recursive function,
    its implementation `**fun** *x* -> *e*`, and the dynamic environment `*env*` that
    was current at the time the function was defined. If the function is anonymous,
    rather then recursive, then we just leave the name out of the closure, so that
    it looks like `<< **fun** *x* -> *e*, *env* >>`
  prefs: []
  type: TYPE_NORMAL
- en: 'We write `*env* :: *e* --> *v*` to mean that `*e*` evaluates to `*v*` in environment
    `*env*`. We write `*env*(*x*)` to look up the value of `*x*` in `*env*`. We write
    `{}` to mean the empty environment (which is never truly empty, because OCaml
    opens `Pervasives` automatically). We write `*env*+{*x*=*v*}` to mean the same
    environment as `*env*`, except that `*x*` is now bound to `*v*` instead of whatever
    value (if any) it had before.'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation rules in the environment model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constants and operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let rec expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Match expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Function expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Anonymous function application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursive function application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Primitive operator application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The evaluation rules above use *lexical scope*, in which the meaning of a variable
    name is determined by *where* the name appears *lexically* in the source code,
    rather than *when* the variable name is dynamically evaluated. The latter would
    be *dynamic scope*. We saw rules for dynamic scope in lecture. OCaml (and nearly
    all modern languages) use lexical scope.
  prefs: []
  type: TYPE_NORMAL
- en: You should practice evaluating some expressions using the environment model
    to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: because
  prefs: []
  type: TYPE_NORMAL
- en: The first `let` binds `d` to `2`, creating environment `{d=2}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `let` binds `f` to `<< fun x->x+d, {d=2} >>`, creating environment
    `{d=2, f=<< fun x->x+d, {d=2} >>}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third `let` binds `d` to `1`, shadowing the previous binding, and creating
    environment `{d=1, f=<< fun x->x+d, {d=2} >>}`. *Note how the original binding
    of `x` persists in the closure. That's the key insight to take away from this
    example.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name `f` evaluates to the closure `<< fun x->x+d, {d=2} >>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying that closure to `2` creates an environment `{d=2,x=2}`. The function
    body `x+d` is then evaluated in that environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name `d` evaluates to `2`. So does `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're left with `2+2`, which is really syntactic sugar for `(+) 2 2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the primitive addition operator to `2` and `2` yields `4`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So the entire expression evaluates to `4`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 2.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: because
  prefs: []
  type: TYPE_NORMAL
- en: The `let rec` binds `fact` to a closure `cl = << fact, fun n -> if n = 0 then
    1 else n * (fact (n-1)) , {} >>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name `fact` evaluates to that closure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying that closure to argument `1` creates an environment `env={n=1, fact=<<
    fact, fun n -> if n = 0 then 1 else n * (fact (n-1)) , {} >>}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code part of the closure `if n = 0 then 1 else n * (fact (n-1))` is evaluated
    in that environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The guard evaluates to `false` (here we're skipping a couple steps, including
    looking up `n` in the environment, and applying the primitive equality operator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if` expression therefore proceeds by evaluating the `else` branch, which
    is `n * (fact (n-1))`, in the environment `env`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right-hand side `fact (n-1)` is evaluated first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expression `n-1` evaluates to `0`. (Again we're skipping a couple steps.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name `fact` evaluates to the closure `cl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying that closure to argument `0` creates an environment `{n=0, fact=<<
    fact, fun n -> if n = 0 then 1 else n * (fact (n-1)) , {} >>}`. *Note how `fact`
    stays around in the environment for recursive calls. That's the key insight to
    take away from this example.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code part of the closure `if n = 0 then 1 else n * (fact (n-1))` is evaluated
    in that environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The guard evaluates to `true` (here we're skipping a couple steps, including
    looking up `n` in the environment, and applying the primitive equality operator).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `if` expression therefore proceeds by evaluating the `then` branch, which
    is `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The left-hand side `n` is evaluated second. It evaluates to `1` in `env`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now have `1*1`, which is a primitive operation and evaluates to `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 3.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: because
  prefs: []
  type: TYPE_NORMAL
- en: The `let rec` binds `filter` to a closure `<< filter, fun f -> *F*, {} >>`,
    where `*F*` is the body of `filter` as given above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `let` binds `all_gt` to a closure `<< fun n -> *A*, {filter=<< filter, fun
    f -> *F*, {} >>} >>`, where `*A*` is the body of `all_gt` as given above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable name `all_gt` evaluates to the closure just created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application of that closure to `1` creates an environment `{filter=<< filter,
    fun f -> *F*, {} >>, n=1}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function body `fun xs -> filter (fun x -> x > n) xs` is evaluated in that
    environment. It evaluates to a new closure `<< fun xs -> filter (fun x -> x >
    n) xs, {filter=<< filter, fun f -> *F*, {} >>, n=1} >>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new closure is applied to `[1;2]`. That creates an environment `{filter=<<
    filter, fun f -> *F*, {} >>, n=1, xs=[1;2]}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function body `filter (fun x -> x > n) xs` is evaluated in that latest environment.
    If we fully parenthesize, that body is `(filter (fun x -> x > n)) xs`. So the
    next step is to evaluate the function application `filter (fun x -> x > n)`. That
    requires first evaluating the argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The argument `(fun x -> x > n)` is evaluated. It produces a closure `<< fun
    x -> x > n, {filter=<< filter, fun f -> *F*, {} >>, n=1, xs=[1;2]} >>`. *Note
    how the closure saves the value of `n`. That's the key insight to take away from
    this example.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After many more evaluation steps, we reach `[2]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those examples get tedious. It's no wonder we have computers to compute them
    for us!
  prefs: []
  type: TYPE_NORMAL
