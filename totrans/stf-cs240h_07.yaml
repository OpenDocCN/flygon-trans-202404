- en: Functors, monads, and whatnot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our lecture on testing, we visited with the humble functor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But how good is our intuition for what a functor is?
  prefs: []
  type: TYPE_NORMAL
- en: Functors over lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please tell me what the following computes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Functors over lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please tell me what the following computes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Functors over Maybe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s avoid name clash with the standard `Functor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Please write a `MyFunctor` instance for `Maybe`.
  prefs: []
  type: TYPE_NORMAL
- en: You have 2 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Functors over Maybe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s avoid name clash with the standard `Functor` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here is a `MyFunctor` instance for `Maybe`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Functors over Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please dictate to me a `MyFunctor` instance for `Identity`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: (You can find this type in `Data.Functor.Identity`.)
  prefs: []
  type: TYPE_NORMAL
- en: One view of functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we think of a functor as a container.
  prefs: []
  type: TYPE_NORMAL
- en: What do we know about what a functor does to the things inside the container?
  prefs: []
  type: TYPE_NORMAL
- en: How about the structure of the container itself?
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may not have come across the "tupling" operator yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Given two arguments, it returns a pair consisting of those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application of a pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `(,)` is a operator, we can surround it in parentheses to use it as a
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In typical Haskell fashion, we can partially apply the function to yield another
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Type signatures and tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK, we can use `(,)` in prefix position as a function.
  prefs: []
  type: TYPE_NORMAL
- en: We can also write `(,)` as a *type constructor*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This means *exactly the same thing* as the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Functors over tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What should a `MyFunctor` instance for pairs look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, for a type to be an instance of `MyFunctor`, we need one free type
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By convention, we choose the second element of the pair to be free in our `MyFunctor`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: What should `myfmap` look like?
  prefs: []
  type: TYPE_NORMAL
- en: Getting weirder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How useful is our functors-as-containers metaphor?
  prefs: []
  type: TYPE_NORMAL
- en: Recall the enigmatic `Identity` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a `newtype`, it has no runtime representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'So strictly speaking, it''s not really a container:'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from type system machinery, there's no "outside" for something to be "inside"
    of.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why talk about prefix operators?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I had a purpose in talking about `(,)` as a prefix operator.
  prefs: []
  type: TYPE_NORMAL
- en: We can do the same with the `(->)` operator for describing functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we were able to write a `MyFunctor` instance for pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Can we do the same for functions?
  prefs: []
  type: TYPE_NORMAL
- en: Functors for functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Anyone want to take a crack at this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Functors for functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A definition wasn''t too hard to come up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: But what does this *mean*?
  prefs: []
  type: TYPE_NORMAL
- en: It is clearly *not* a container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors for IO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already touched on functors in the context of `IO`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This executes a real-world action, and gives us back a `String`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This executes the same real-world action, and gives us back...*what?*
  prefs: []
  type: TYPE_NORMAL
- en: Functor laws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mapping the identity function has no effect on the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Mapping the composition of two functions is the same as composing the mapping
    of the same functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Lifting, revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard way of writing the type of `fmap` can be a bit obscure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Lifting, revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions in Haskell are always *curried*, so `fmap` "is really" a function
    of one argument that returns another function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add parentheses to make this clear.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It *lifts* its first argument from being a normal function to one that operates
    in this universe where everything is shrouded in `f`.
  prefs: []
  type: TYPE_NORMAL
- en: Why focus on functors?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll come across the damn things everywhere in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Next to `Monoid`, `Functor` is one of the simplest abstractions in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that `(->) a` is a `Functor` (but *not* a container) is *invaluable*:'
  prefs: []
  type: TYPE_NORMAL
- en: It dislodges us from using limiting container-focused metaphors to think about
    these abstractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving `f` a name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So containers are only a training-wheels metaphor.
  prefs: []
  type: TYPE_NORMAL
- en: It'll still be helpful to generically refer to this `f` thing by a name.
  prefs: []
  type: TYPE_NORMAL
- en: We'll call it a *context*.
  prefs: []
  type: TYPE_NORMAL
- en: Contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `[]` functor:'
  prefs: []
  type: TYPE_NORMAL
- en: The context is a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `(->) a` functor:'
  prefs: []
  type: TYPE_NORMAL
- en: Our context is a function that has a first argument of type `a` (a "read-only
    environment").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `IO` functor:'
  prefs: []
  type: TYPE_NORMAL
- en: Our context is computations that may have real-world effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's our next step up the expressive ladder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `pure` function takes a value and lifts it into our new context.
  prefs: []
  type: TYPE_NORMAL
- en: Where "applicative" comes from
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about `(<*>)`?
  prefs: []
  type: TYPE_NORMAL
- en: Consider its similarity to both `fmap` and `($)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*They''re clearly all related!*'
  prefs: []
  type: TYPE_NORMAL
- en: '`($)` is function application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmap` is function application lifted to functors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(<*>)` is function application lifted to functors, but where the initial function
    is wrapped in our context `f` too'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the origin of the name "applicative".
  prefs: []
  type: TYPE_NORMAL
- en: Applicative laws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as with monoids and functors, instances of `Applicative` must follow some
    laws.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there are 4 laws.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to them [at the Typeclassopedia](http://www.haskell.org/haskellwiki/Typeclassopedia#Laws_2)
    if you're interested.
  prefs: []
  type: TYPE_NORMAL
- en: Just one Applicative instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will give us the flavour of the `Applicative` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What should the implementation of `(<*>)` look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Take 2 minutes to write your own.
  prefs: []
  type: TYPE_NORMAL
- en: Just one Applicative instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will give us the flavour of the `Applicative` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What should the implementation of `(<*>)` look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Further study
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to gain some good understanding of `Applicative`:'
  prefs: []
  type: TYPE_NORMAL
- en: Write instances for lists, `Identity`, and `(->) a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bonus material:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Write `Functor` and `Applicative` instances for the `MyConst` type above.
  prefs: []
  type: TYPE_NORMAL
- en: Why all the fuss?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's a tiny `Applicative`-powered parser for URL-encoded bytes such as `%27`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This depends on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Going deeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's parse an entire `application/x-www-form-urlencoded` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'They look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Top-level parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We'll revisit `sepBy` in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First, we must grok `Alternative`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Alternative` class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class combines monoids with applicative functors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`empty` corresponds to `mempty`.'
  prefs: []
  type: TYPE_NORMAL
- en: When parsing, think of this as "the parse failed".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(<|>)` corresponds to `mappend`/`(<>)`.'
  prefs: []
  type: TYPE_NORMAL
- en: When parsing, think of this as "try the first parse; if it fails, try the second".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some handy combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: More parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'New combinators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our complete parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code is amazingly compact and readable!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And finally, on to `Monad`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every `Applicative` is a `Functor`.
  prefs: []
  type: TYPE_NORMAL
- en: And every `Monad` is an `Applicative`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`return` is the same as `pure`.'
  prefs: []
  type: TYPE_NORMAL
- en: What about `(>>=)` ("bind")?
  prefs: []
  type: TYPE_NORMAL
- en: Where does it fit into our mental universe?
  prefs: []
  type: TYPE_NORMAL
- en: A convenient variation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a standard function named `(=<<)` which is exactly `(>>=)`, but with
    its arguments flipped.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Why should we care?
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit an earlier slide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: These are all different ways of applying a function to a value.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit an earlier slide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A small change: add `(=<<)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: So really, the `(>>=)` operator is "just" another application operator, but
    its flipped argument order obscures this.
  prefs: []
  type: TYPE_NORMAL
- en: What `Functor` and `Applicative` cannot do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider application with functors and applicative functors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How do we ensure that they can only operate on the *elements* of a container?
  prefs: []
  type: TYPE_NORMAL
- en: Their function argument *cannot see or influence* `f` at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, they *must* be oblivious to the enclosing structure of the container
    (or computational context, or whatever).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From `Applicative` to `Monad`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to `Monad` is that the `a -> m b` function can take a normal Haskell
    value *and use it to decide* what `m b` to give back:'
  prefs: []
  type: TYPE_NORMAL
- en: It is able to influence the container's structure, change the context, launch
    the nukes, or what have you.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Compared to `Applicative`, `Monad` is both more powerful *and* harder to reason
    about.
  prefs: []
  type: TYPE_NORMAL
- en: The present and future of these classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Applicative` and `Functor` are related. `Monad` is independent of the other
    two due to accidents of history.'
  prefs: []
  type: TYPE_NORMAL
- en: This will change with GHC 7.10.
  prefs: []
  type: TYPE_NORMAL
- en: A useful rule of thumb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Always try to use the *least powerful* abstraction you can.
  prefs: []
  type: TYPE_NORMAL
- en: Use `Applicative` in preference to `Monad`.
  prefs: []
  type: TYPE_NORMAL
- en: Use `Functor` in preference to `Applicative`.
  prefs: []
  type: TYPE_NORMAL
- en: (Unless you can't, of course.)
  prefs: []
  type: TYPE_NORMAL
- en: Why?
  prefs: []
  type: TYPE_NORMAL
- en: The less powerful the abstraction, the easier its behaviour is to reason about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It becomes harder for you and your users to perform foot-shooting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
