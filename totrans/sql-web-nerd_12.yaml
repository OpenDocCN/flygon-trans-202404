- en: '| [![Out for the evening in San Diege, California.](../Images/b87ecea6de3f3d6f8363e2db5ce4a003.jpg)](/http://philip.greenspun.com/images/pcd1647/out-for-the-evening-18.tcl)
    |'
  id: totrans-0
  prefs: []
  type: TYPE_TB
- en: Dates
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: part of [SQL for Web Nerds](index.html) by [Philip Greenspun](http://philip.greenspun.com/),
    updated June 13, 2003 |
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[![Harry and Katerina''s wedding.  Lake Placid.  September 4, 1999.](../Images/3598f2e8670917b09f206c747027750b.jpg)](/http://philip.greenspun.com/images/pcd2898/harry-and-katerina-wedding-81.tcl)
    When representing date-time information in Oracle it becomes absolutely critical
    to know with which version of the Oracle server you are working. From version
    9 onwards it is possible to represent points in time and time intervals using
    ANSI SQL data types such as `timestamp` and `interval`. Earlier versions of Oracle
    represented points in time with the `date` datatype, which is precise to within
    one second, and time intervals as numbers (where 1 = one day).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We strongly recommend that you use the newly available ANSI data types when
    building new applications. These are cleaner and more powerful than the older
    Oracle-specific way of doing things and further will make it easier to port your
    application to another RDBMS if necessary.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: If you are stuck using an older version of Oracle or are writing queries and
    transactions to an older data model, please visit [http://philip.greenspun.com/sql/dates-pre-9](/sql/dates-pre-9).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Querying by Date
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that we have the following table to record user registrations:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s query for people who registered during the last day:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note how the registration date comes out in a non-standard format that won''t
    sort lexicographically and that does not have a full four digits for the year.
    You should curse your database administrator at this point for not configuring
    Oracle with a more sensible default. You can fix the problem for yourself right
    now, however:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can query for shorter time intervals:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can be explicit about how you''d like the timestamps formatted:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Oops. Oracle pads some of these fields by default so that reports will be lined
    up and neat. We''ll have to trim the strings ourselves:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Some Very Weird Things
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One reason that Oracle may have resisted ANSI date-time datatypes and arithmetic
    is that they can make life very strange for the programmer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Some Profoundly Painful Things
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calculating time intervals between rows in a table can be very painful because
    there is no way in standard SQL to refer to "the value of this column from the
    previous row in the report". You can do this easily enough in an imperative computer
    language, e.g., C#, Java, or Visual Basic, that is reading rows from an SQL database
    but doing it purely in SQL is tough.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a few more rows to our users table to see how this works.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose that we''re interested in the average length of time between registrations.
    With so few rows we could just query all the data out and eyeball it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we have a lot of data, however, we'll need to do a self-join.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that to find the "next row" for the pairing we are using the `user_id`
    column, which we know to be sequential and unique, rather than the registration_date
    column, which may not be unique because two users could register at exactly the
    same time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have information from adjacent rows paired up in the same report
    we can begin to calculate intervals:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The interval for each row of the report has come back as days, hours, minutes,
    and seconds. At this point you''d expect to be able to average the intervals:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Oops. Oracle isn't smart enough to aggregate time intervals. And sadly there
    doesn't seem to be an easy way to turn a time interval into a number of seconds,
    for example, that would be amenable to averaging. If you figure how out to do
    it, please let me know!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Should we give up? If you have a strong stomach you can convert the timestamps
    to old-style Oracle dates through character strings before creating the intervals.
    This will give us a result as a fraction of a day:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we''re going to continue using this ugly query we ought to create a view:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can calculate the average time interval in minutes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Reporting
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of using the `to_char` function an GROUP BY to generate
    a report of sales by calendar quarter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a hint that Oracle has all kinds of fancy date formats (covered in their
    online documentation). We're using the "Q" mask to get the calendar quarter. We
    can see that this product started shipping in Q2 1998 and that revenues trailed
    off in Q4 1998.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: More
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '["New Datatypes, New Possibilities"](http://www.oreillynet.com/lpt/a/2992)
    by Steven Feuerstein'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next: [limits](limits.html)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[philg@mit.edu](http://philip.greenspun.com/)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Reader's Comments
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You state: >> no way in standard SQL to refer to "the value of this column
    from the previous row in the report".'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At least in Oracle 8i SQL, there is a way in to refer to this, I'm sure it isn't
    standard, but useful nonetheless, and so I present it here.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is called an Analytic Function. There are several, but the one demonstrated
    in this example is LAST_VALUE.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SELECT r1, r2, r2 - r1 reg_gap FROM (SELECT u1.update_date AS r1, LAST_VALUE
    (update_date) OVER (ORDER BY update_date ASC ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
    AS r2 FROM users u1 WHERE u1.user_id > 100000) WHERE r1 <> r2 ORDER BY r1
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From the inside out, I take the update_date from the users table, and using
    the LAST_VALUE function, I ask for the last update_date value, including in the
    window the current row and the next chronologically ordered row.
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I used a higher level query to do the difference simply to avoid repeating the
    long function, but I could have done it in one.
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The results are the same:'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"R1" "R2" "REG_GAP" 11/10/2003 5:19:00 PM 11/10/2003 8:23:24 PM 0.128055555555556
    11/10/2003 8:23:24 PM 11/12/2003 7:53:10 AM 1.47900462962963 11/12/2003 7:53:10
    AM 2/13/2004 3:44:47 PM 93.3275115740741'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although, as I said, I'm using 8i so I don't have the interval type.
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To find out more about Analytic Functions, check out the Oracle Documentation
    SQL Reference.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要了解更多关于分析函数的信息，请查看 Oracle 文档 SQL 参考。
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: KSF
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: KSF
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [K SF](/shared/community-member?user_id=261669), September 1, 2004
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [K SF](/shared/community-member?user_id=261669)，2004年9月1日
- en: '"Some Profoundly Painful Things -- Calculating time intervals between rows
    in a table" is very useful, thank you. Some people may need the following technique
    to establish a sequential numeric identifier. (In the example you assume "user_id
    column, which we know to be sequential and unique")'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"一些深刻痛苦的事情--计算表中行之间的时间间隔"非常有用，谢谢。有些人可能需要以下技术来建立一个顺序数字标识符。（在示例中，你假设了“user_id”列，我们知道它是顺序且唯一的）'
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: declare @tmp (registration_date datetime)
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 声明 @tmp (registration_date datetime)
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: insert @tmp
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 插入 @tmp
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'select identity(int,1,1) as Sequence, registration_date into #x from users
    order by registration_date'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '从用户中选择 identity(int,1,1) as Sequence, registration_date into #x order by registration_date'
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '... (now use #x instead of users in the example)'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '...（现在在示例中使用 #x 而不是 users）'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'drop table #x'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '删除表 #x'
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Steve Davis](/shared/community-member?user_id=268429), January 29, 2006
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [Steve Davis](/shared/community-member?user_id=268429)，2006年1月29日
- en: 'You say: "Oops. Oracle pads some of these fields by default so that reports
    will be lined up and neat. We''ll have to trim the strings ourselves." Not quite:
    one can use FM modifier in format string to instruct Oracle to trim whitespace
    from resulting string automatically, like this:'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你说：“糟糕。Oracle 默认填充一些字段，以便报告整齐排列。我们必须自己修剪字符串。” 不完全正确：可以在格式字符串中使用 FM 修饰符指示 Oracle
    自动修剪结果字符串中的空格，就像这样：
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ''
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that FM is a switch - second FM in format string negates the effect of
    the first.
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，FM 是一个开关 - 格式字符串中的第二个 FM 取消了第一个的效果。
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Vladimir Zakharychev](/shared/community-member?user_id=271169), May 22,
    2006
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [Vladimir Zakharychev](/shared/community-member?user_id=271169)，2006年5月22日
- en: Not pretty at all but it works...
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一点也不漂亮，但它起作用...
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Andre Mostert](/shared/community-member?user_id=271769), June 20, 2006
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [Andre Mostert](/shared/community-member?user_id=271769)，2006年6月20日
- en: 1.Find the first monday on every quater based on date ? **Select Next_day(trunc(to_date(sysdate,'DD-MON-YYYY'),
    'Q')-1,'Monday') from dual**
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1.根据日期找到每个季度的第一个星期一？**选择 Next_day(trunc(to_date(sysdate,'DD-MON-YYYY'), 'Q')-1,'Monday')
    from dual**
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Mohamed Kaleel](/shared/community-member?user_id=281113), April 13, 2007
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [Mohamed Kaleel](/shared/community-member?user_id=281113)，2007年4月13日
- en: 'Computing number of seconds in an interval:'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算间隔中的秒数：
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FUNCTION seconds_from_interval(invInterval IN INTERVAL DAY TO SECOND) RETURN
    NUMBER IS BEGIN
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数 seconds_from_interval(invInterval IN INTERVAL DAY TO SECOND) 返回 NUMBER IS
    BEGIN
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RETURN EXTRACT (DAY FROM invInterval) * 86400 +
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回 EXTRACT (DAY FROM invInterval) * 86400 +
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EXTRACT (HOUR FROM invInterval) * 3600 +
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从 invInterval 中提取（HOUR）* 3600 +
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EXTRACT (MINUTE FROM invInterval) * 60 +
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从 invInterval 中提取（MINUTE）* 60 +
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EXTRACT (SECOND FROM invInterval);
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从 invInterval 中提取（SECOND）;
- en: ''
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: END seconds_from_interval;
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: END seconds_from_interval;
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Bob Jarvis](/shared/community-member?user_id=288915), March 4, 2008
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [Bob Jarvis](/shared/community-member?user_id=288915)，2008年3月4日
- en: '[Add a comment](/comments/add?page_id=3513)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[添加评论](/comments/add?page_id=3513)'
