- en: '| [![Out for the evening in San Diege, California.](../Images/b87ecea6de3f3d6f8363e2db5ce4a003.jpg)](/http://philip.greenspun.com/images/pcd1647/out-for-the-evening-18.tcl)
    |'
  prefs: []
  type: TYPE_TB
- en: Dates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: part of [SQL for Web Nerds](index.html) by [Philip Greenspun](http://philip.greenspun.com/),
    updated June 13, 2003 |
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[![Harry and Katerina''s wedding.  Lake Placid.  September 4, 1999.](../Images/3598f2e8670917b09f206c747027750b.jpg)](/http://philip.greenspun.com/images/pcd2898/harry-and-katerina-wedding-81.tcl)
    When representing date-time information in Oracle it becomes absolutely critical
    to know with which version of the Oracle server you are working. From version
    9 onwards it is possible to represent points in time and time intervals using
    ANSI SQL data types such as `timestamp` and `interval`. Earlier versions of Oracle
    represented points in time with the `date` datatype, which is precise to within
    one second, and time intervals as numbers (where 1 = one day).'
  prefs: []
  type: TYPE_NORMAL
- en: We strongly recommend that you use the newly available ANSI data types when
    building new applications. These are cleaner and more powerful than the older
    Oracle-specific way of doing things and further will make it easier to port your
    application to another RDBMS if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: If you are stuck using an older version of Oracle or are writing queries and
    transactions to an older data model, please visit [http://philip.greenspun.com/sql/dates-pre-9](/sql/dates-pre-9).
  prefs: []
  type: TYPE_NORMAL
- en: Querying by Date
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose that we have the following table to record user registrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Let''s query for people who registered during the last day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Note how the registration date comes out in a non-standard format that won''t
    sort lexicographically and that does not have a full four digits for the year.
    You should curse your database administrator at this point for not configuring
    Oracle with a more sensible default. You can fix the problem for yourself right
    now, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'You can query for shorter time intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'You can be explicit about how you''d like the timestamps formatted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Oops. Oracle pads some of these fields by default so that reports will be lined
    up and neat. We''ll have to trim the strings ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Some Very Weird Things
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One reason that Oracle may have resisted ANSI date-time datatypes and arithmetic
    is that they can make life very strange for the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Some Profoundly Painful Things
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Calculating time intervals between rows in a table can be very painful because
    there is no way in standard SQL to refer to "the value of this column from the
    previous row in the report". You can do this easily enough in an imperative computer
    language, e.g., C#, Java, or Visual Basic, that is reading rows from an SQL database
    but doing it purely in SQL is tough.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a few more rows to our users table to see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Suppose that we''re interested in the average length of time between registrations.
    With so few rows we could just query all the data out and eyeball it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: If we have a lot of data, however, we'll need to do a self-join.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Notice that to find the "next row" for the pairing we are using the `user_id`
    column, which we know to be sequential and unique, rather than the registration_date
    column, which may not be unique because two users could register at exactly the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have information from adjacent rows paired up in the same report
    we can begin to calculate intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The interval for each row of the report has come back as days, hours, minutes,
    and seconds. At this point you''d expect to be able to average the intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Oops. Oracle isn't smart enough to aggregate time intervals. And sadly there
    doesn't seem to be an easy way to turn a time interval into a number of seconds,
    for example, that would be amenable to averaging. If you figure how out to do
    it, please let me know!
  prefs: []
  type: TYPE_NORMAL
- en: 'Should we give up? If you have a strong stomach you can convert the timestamps
    to old-style Oracle dates through character strings before creating the intervals.
    This will give us a result as a fraction of a day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'If we''re going to continue using this ugly query we ought to create a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Now we can calculate the average time interval in minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Reporting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an example of using the `to_char` function an GROUP BY to generate
    a report of sales by calendar quarter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: This is a hint that Oracle has all kinds of fancy date formats (covered in their
    online documentation). We're using the "Q" mask to get the calendar quarter. We
    can see that this product started shipping in Q2 1998 and that revenues trailed
    off in Q4 1998.
  prefs: []
  type: TYPE_NORMAL
- en: More
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '["New Datatypes, New Possibilities"](http://www.oreillynet.com/lpt/a/2992)
    by Steven Feuerstein'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next: [limits](limits.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[philg@mit.edu](http://philip.greenspun.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Reader's Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You state: >> no way in standard SQL to refer to "the value of this column
    from the previous row in the report".'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At least in Oracle 8i SQL, there is a way in to refer to this, I'm sure it isn't
    standard, but useful nonetheless, and so I present it here.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is called an Analytic Function. There are several, but the one demonstrated
    in this example is LAST_VALUE.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SELECT r1, r2, r2 - r1 reg_gap FROM (SELECT u1.update_date AS r1, LAST_VALUE
    (update_date) OVER (ORDER BY update_date ASC ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)
    AS r2 FROM users u1 WHERE u1.user_id > 100000) WHERE r1 <> r2 ORDER BY r1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From the inside out, I take the update_date from the users table, and using
    the LAST_VALUE function, I ask for the last update_date value, including in the
    window the current row and the next chronologically ordered row.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I used a higher level query to do the difference simply to avoid repeating the
    long function, but I could have done it in one.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The results are the same:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"R1" "R2" "REG_GAP" 11/10/2003 5:19:00 PM 11/10/2003 8:23:24 PM 0.128055555555556
    11/10/2003 8:23:24 PM 11/12/2003 7:53:10 AM 1.47900462962963 11/12/2003 7:53:10
    AM 2/13/2004 3:44:47 PM 93.3275115740741'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although, as I said, I'm using 8i so I don't have the interval type.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To find out more about Analytic Functions, check out the Oracle Documentation
    SQL Reference.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: KSF
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [K SF](/shared/community-member?user_id=261669), September 1, 2004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"Some Profoundly Painful Things -- Calculating time intervals between rows
    in a table" is very useful, thank you. Some people may need the following technique
    to establish a sequential numeric identifier. (In the example you assume "user_id
    column, which we know to be sequential and unique")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: declare @tmp (registration_date datetime)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: insert @tmp
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'select identity(int,1,1) as Sequence, registration_date into #x from users
    order by registration_date'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '... (now use #x instead of users in the example)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'drop table #x'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Steve Davis](/shared/community-member?user_id=268429), January 29, 2006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You say: "Oops. Oracle pads some of these fields by default so that reports
    will be lined up and neat. We''ll have to trim the strings ourselves." Not quite:
    one can use FM modifier in format string to instruct Oracle to trim whitespace
    from resulting string automatically, like this:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that FM is a switch - second FM in format string negates the effect of
    the first.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Vladimir Zakharychev](/shared/community-member?user_id=271169), May 22,
    2006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Not pretty at all but it works...
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Andre Mostert](/shared/community-member?user_id=271769), June 20, 2006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1.Find the first monday on every quater based on date ? **Select Next_day(trunc(to_date(sysdate,'DD-MON-YYYY'),
    'Q')-1,'Monday') from dual**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Mohamed Kaleel](/shared/community-member?user_id=281113), April 13, 2007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Computing number of seconds in an interval:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FUNCTION seconds_from_interval(invInterval IN INTERVAL DAY TO SECOND) RETURN
    NUMBER IS BEGIN
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RETURN EXTRACT (DAY FROM invInterval) * 86400 +
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EXTRACT (HOUR FROM invInterval) * 3600 +
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EXTRACT (MINUTE FROM invInterval) * 60 +
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EXTRACT (SECOND FROM invInterval);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: END seconds_from_interval;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Bob Jarvis](/shared/community-member?user_id=288915), March 4, 2008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Add a comment](/comments/add?page_id=3513)'
  prefs: []
  type: TYPE_NORMAL
