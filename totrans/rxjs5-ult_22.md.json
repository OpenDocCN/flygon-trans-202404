["```\nspyOn(service,'method').and.callFake(() => {\n    return {\n        then : function(resolve, reject){\n            resolve('some data')\n        }\n    }\n}) \n```", "```\nspyOn(service,'method').and.callFake(q.when('some data')) \n```", "```\nlet testScheduler = new TestScheduler();\n\n// my algorithm\nlet stream$ = Rx.Observable\n.interval(1000, testScheduler)\n.take(5);\n\n// setting up the test\nlet result;\n\nstream$.subscribe(data => result = data);\n\ntestScheduler.advanceBy(1000);\nassert( result === 1 )\n\ntestScheduler.advanceBy(1000);\n... assert again, etc.. \n```", "```\n// setup the thing that outputs data\nvar input = scheduler.createHotObservable(\n    onNext(100, 'abc'),\n    onNext(200, 'def'),\n    onNext(250, 'ghi'),\n    onNext(300, 'pqr'),\n    onNext(450, 'xyz'),\n    onCompleted(500)\n  );\n\n// apply operators to it\nvar results = scheduler.startScheduler(\n    function () {\n      return input.buffer(function () {\n        return input.debounce(100, scheduler);\n      })\n      .map(function (b) {\n        return b.join(',');\n      });\n    },\n    {\n      created: 50,\n      subscribed: 150,\n      disposed: 600\n    }\n  );\n\n//assert\ncollectionAssert.assertEqual(results.messages, [\n    onNext(400, 'def,ghi,pqr'),\n    onNext(500, 'xyz'),\n    onCompleted(500)\n  ]); \n```", "```\n// setup\nconst lhsMarble = '-x-y-z';\nconst expected = '-x-y-z';\nconst expectedMap = {\n    x: 1,\n    y: 2,\n    z : 3\n};\n\nconst lhs$ = testScheduler.createHotObservable(lhsMarble, { x: 1, y: 2, z :3 });\n\nconst myAlgorithm = ( lhs ) => \n    Rx.Observable\n    .from( lhs );\n\nconst actual$ = myAlgorithm( lhs$ );\n\n//assert\ntestScheduler.expectObservable(actual$).toBe(expected, expectedMap);\ntestScheduler.flush(); \n```", "```\nconst lhsMarble = '-x-y-z';\nconst expected = '-x-y-z';\nconst expectedMap = {\n    x: 1,\n    y: 2,\n    z : 3\n};\n\nconst lhs$ = testScheduler.createHotObservable(lhsMarble, { x: 1, y: 2, z :3 }); \n```", "```\nlet stream$ = Rx.Observable.create(observer => {\n   observer.next(1);\n   observer.next(2);\n   observer.next(3);\n}) \n```", "```\nconst expected = '-x-y-z';\n\nconst expectedMap = {\n    x: 1,\n    y: 2,\n    z : 3\n} \n```", "```\n// excerpt from createHotObservable\n var messages = TestScheduler.parseMarbles(marbles, values, error);\nvar subject = new HotObservable_1.HotObservable(messages, this);\nthis.hotObservables.push(subject);\nreturn subject; \n```", "```\n// excerpt from expectObservable()\nthis.schedule(function () {\n    subscription = observable.subscribe(function (x) {\n        var value = x;\n        // Support Observable-of-Observables\n        if (x instanceof Observable_1.Observable) {\n            value = _this.materializeInnerObservable(value, _this.frame);\n        }\n        actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });\n    }, function (err) {\n        actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });\n    }, function () {\n        actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });\n    });\n}, 0); \n```", "```\n// excerpt from flush()\n while (readyFlushTests.length > 0) {\n    var test = readyFlushTests.shift();\n    this.assertDeepEqual(test.actual, test.expected);\n} \n```", "```\n{ \n  frame : [some number],\n  notification : { value : [your value] }\n} \n```", "```\n-a-b-c \n```", "```\nconst lhsMarble = '-x-y-z';\nconst expected = '---y-';\nconst expectedMap = {\n    x: 1,\n    y: 2,\n    z : 3\n};\n\nconst lhs$ = testScheduler.createHotObservable(lhsMarble, { x: 1, y: 2, z :3 });\n\nconst myAlgorithm = ( lhs ) => \n    Rx.Observable\n    .from( lhs )\n    .filter(x => x % 2 === 0 );\n\nconst actual$ = myAlgorithm( lhs$ );\n\n//assert\ntestScheduler.expectObservable(actual$).toBe(expected, expectedMap);\ntestScheduler.flush(); \n```", "```\n'-x-y-z' \n```", "```\n`---y-` \n```", "```\n-x-y \n```", "```\n---y \n```", "```\nconst lhsMarble = '-#';\nconst expected = '#';\nconst expectedMap = {\n};\n\n//const lhs$ = testScheduler.createHotObservable(lhsMarble, { x: 1, y: 2, z :3 });\n\nconst myAlgorithm = ( lhs ) => \n    Rx.Observable\n    .from( lhs );\n\nconst actual$ = myAlgorithm( Rx.Observable.throw('error') );\n\n//assert\ntestScheduler.expectObservable(actual$).toBe(expected, expectedMap);\ntestScheduler.flush(); \n```", "```\nconst lhsMarble = '-a-b-c-|';\nconst expected = '-a-b-c-|';\nconst expectedMap = {\n    a : 1,\n    b : 2,\n    c : 3\n};\n\nconst myAlgorithm = ( lhs ) => \n    Rx.Observable\n    .from( lhs );\n\nconst lhs$ = testScheduler.createHotObservable(lhsMarble, { a: 1, b: 2, c :3 });    \nconst actual$ = lhs$;\n\ntestScheduler.expectObservable(actual$).toBe(expected, expectedMap);\ntestScheduler.flush(); \n```"]