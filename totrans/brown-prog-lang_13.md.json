["```\nfun square(x :: Number) -> Number: x * x end\nfun double(x :: Number) -> Number: 2 * x end\n```", "```\nd-dx :: ((Number -> Number) -> (Number -> Number))\n```", "```\nepsilon = 0.001\n```", "```\nfun d-dx(f :: (Number -> Number)) -> (Number -> Number):\n  (f(x + epsilon) - f(x)) / epsilon\nend\n```", "```\nfun d-dx(f :: (Number -> Number)) -> (Number -> Number):\n  lam(x :: Number) -> Number:\n    (f(x + epsilon) - f(x)) / epsilon\n  end\nend\n```", "```\nd-dx-square = d-dx(square)\n\ncheck:\n  ins = [list: 0, 1, 10, 100]\n  for map(n from ins):\n    num-floor(d-dx-square(n))\n  end\n  is\n  for map(n from ins):\n    num-floor(double(n))\n  end\nend\n```", "```\nd-dx(lam(x): x * x end) = lam(x): 2 * x end\n```", "```\n{(a): b}\n```", "```\n{(x): x * x}\n```", "```\nfun d-dx-short(f):\n  {(x): (f(x + epsilon) - f(x)) / epsilon}\nend\n```", "```\nfun nats-from(n):\n  link(n, nats-from(n + 1))\nend\n```", "```\nones = lz-link(1, lam(): ones end)\n```", "```\nones = link(1, ones)\n```", "```\nrec ones = lz-link(1, lam(): ones end)\n```", "```\n> > ones = link(1, ones)\n> > ```", "```\n> > rec ones = link(1, ones)\n> > ```", "```\nrec ones = lz-link(1, {(): ones})\n```", "```\nfun nats-from(n :: Number):\n  lz-link(n, {(): nats-from(n + 1)})\nend\n```", "```\nnats = nats-from(0)\n```", "```\nfun lz-first<T>(s :: Stream<T>) -> T: s.h end\n```", "```\nfun lz-rest<T>(s :: Stream<T>) -> Stream<T>: s.t() end\n```", "```\nfun take<T>(n :: Number, s :: Stream<T>) -> List<T>:\n  if n == 0:\n    empty\n  else:\n    link(lz-first(s), take(n - 1, lz-rest(s)))\n  end\nend\n```", "```\ncheck:\n  take(10, ones) is map(lam(_): 1 end, range(0, 10))\n  take(10, nats) is range(0, 10)\n  take(10, nats-from(1)) is map((_ + 1), range(0, 10))\nend\n```", "```\nrec fibs =\n  lz-link(0,\n    {(): lz-link(1,\n          {(): lz-map2({(a :: Number, b :: Number): a + b},\n                fibs,\n            lz-rest(fibs))})})\n```", "```\ncheck:\n  take(10, fibs) is [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nend\n```", "```\nfun d-dx(f :: (Number -> Number)) ->\n    (Number -> (Number -> Number)):\n  lam(x :: Number) -> (Number -> Number):\n    lam(epsilon :: Number) -> Number:\n      (f(x + epsilon) - f(x)) / epsilon\n    end\n  end\nend\n```", "```\nd-dx-square = d-dx(square)\n```", "```\ntenths = block:\n  fun by-ten(d):\n    new-denom = d / 10\n    lz-link(new-denom, lam(): by-ten(new-denom) end)\n  end\n  by-ten(1)\nend\n```", "```\ncheck:\n  take(3, tenths) is [list: 1/10, 1/100, 1/1000]\nend\n```", "```\nd-dx-square-at-10 = d-dx-square(10)\n```", "```\nlz-map(d-dx-square-at-10, tenths)\n```"]