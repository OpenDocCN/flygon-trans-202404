- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interface is a reference type which contains some method definitions. Any type
    which implements all the methods defined by a reference type will satisfy this
    interface type automatically. Through interface, you can approach object-oriented
    programming. Check the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The running result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the code detailedly:'
  prefs: []
  type: TYPE_NORMAL
- en: (1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The above code defines a interface `Foo` which has only one method: `foo()`.'
  prefs: []
  type: TYPE_NORMAL
- en: (2)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'struct `A` has `2` methods: `foo()` and `bar()`. Since it already implements
    `foo()` method, it satisfies `Foo` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: (3)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`callFoo` requires a variable whose type is `Foo` interface, and passing `A`
    is OK. The `callFoo` will use `A`''s `foo()` method, and "`A foo`" is printed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the argument of `callFoo()` is `&a`, whose type is `*A`. Compile
    and run the program, you may find it also outputs: "`A foo`". So `*A` type has
    all the methods which `A` has. But the reverse is not true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see also `*A` type has implemented `foo()` and `bar()` methods, it doesn't
    mean `A` type has both methods by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'BTW, every type satisfies the empty interface: `interface{}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface type is actually a tuple which contains `2` elements: `<type,
    value>`, `type` identifies the type of the variable which stores in the interface
    while `value` points to the actual value. The default value of an interface type
    is `nil`, which means both `type` and `value` are `nil`: `<nil, nil>`. When you
    check whether an interface is empty or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You must remember only if both `type` and `value` are `nil` means the interface
    value is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Go Programming Language](http://www.gopl.io/).'
  prefs: []
  type: TYPE_NORMAL
