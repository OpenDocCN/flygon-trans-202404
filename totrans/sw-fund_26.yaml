- en: MoreStlcMore on the Simply Typed Lambda-Calculus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Types.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: t ::=                Terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...               (other terms same as before)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| let x=t in t      let-binding'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'λx : Nat*Nat.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let sum = x.fst + x.snd in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let diff = x.fst - x.snd in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (sum,diff)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: t ::=                Terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| (t,t)             pair'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| t.fst             first projection'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| t.snd             second projection'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: v ::=                Values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| (v,v)             pair value'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: T ::=                Types
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| T * T             product type'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: t ::=                Terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| unit              unit value'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: v ::=                Values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| unit              unit'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: T ::=                Types
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Unit              Unit type'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Nat + Bool
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'inl : Nat -> Nat + Bool'
  prefs: []
  type: TYPE_NORMAL
- en: 'inr : Bool -> Nat + Bool'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'div : Nat -> Nat -> (Nat + Unit) ='
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: div =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: λx:Nat. λy:Nat.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if iszero y then
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: inr unit
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: inl ...
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: getNat =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: λx:Nat+Bool.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: case x of
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: inl n => n
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| inr b => if b then 1 else 0'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: t ::=                Terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| inl T t           tagging (left)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| inr T t           tagging (right)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| case t of         case'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: inl x => t
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| inr x => t'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: v ::=                Values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| inl T v           tagged value (left)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| inr T v           tagged value (right)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: T ::=                Types
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| T + T             sum type'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: λx:List Nat.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lcase x of nil -> 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| a::x'' -> lcase x'' of nil -> a'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| b::x'''' -> a+b'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: t ::=                Terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| nil T'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| cons t t'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| lcase t of nil -> t | x::x -> t'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: v ::=                Values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| nil T             nil value'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| cons v v          cons value'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: T ::=                Types
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| List T            list of Ts'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: fact = λx:Nat.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if x=0 then 1 else x * (fact (pred x)))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: fact = λx:Nat.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if x=0 then 1 else x * (fact (pred x)))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: fact =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fix
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (λf:Nat->Nat.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: λx:Nat.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if x=0 then 1 else x * (f (pred x)))
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: t ::=                Terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| fix t             fixed-point operator'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: F = (λf. λx. if x=0 then 1 else x * (f (pred x)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: fix F 3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: (λx. if x=0 then 1 else x * (fix F (pred x))) 3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: if 3=0 then 1 else 3 * (fix F (pred 3))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (fix F (pred 3))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 3 * ((λx. if x=0 then 1 else x * (fix F (pred x))) (pred 3))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 3 * ((λx. if x=0 then 1 else x * (fix F (pred x))) 2)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (if 2=0 then 1 else 2 * (fix F (pred 2)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * (fix F (pred 2)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * ((λx. if x=0 then 1 else x * (fix F (pred x))) (pred 2)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * ((λx. if x=0 then 1 else x * (fix F (pred x))) 1))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * (if 1=0 then 1 else 1 * (fix F (pred 1))))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * (1 * (fix F (pred 1))))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * (1 * ((λx. if x=0 then 1 else x * (fix F (pred x))) (pred 1))))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * (1 * ((λx. if x=0 then 1 else x * (fix F (pred x))) 0)))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * (1 * (if 0=0 then 1 else 0 * (fix F (pred 0)))))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * (1 * 1))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 3 * (2 * 1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 3 * 2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '6'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: halve =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: λx:Nat.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if x=0 then 0
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else if (pred x)=0 then 0
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else 1 + (halve (pred (pred x))))
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: fix (λx:T.x)
  prefs: []
  type: TYPE_NORMAL
- en: By T_Fix  and T_Abs, this term has type T.  By ST_FixAbs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it reduces to itself, over and over again.  Thus it is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*diverging element* of T.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More usefully, here's an example using fix to define a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'two-argument recursive function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: And finally, here is an example where fix is used to define a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*pair* of recursive functions (illustrating the fact that the type'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'T[1] in the rule T_Fix need not be a function type):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: t ::=                          Terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| {i1=t1, ..., in=tn}         record'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| t.i                         projection'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: v ::=                          Values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| {i1=v1, ..., in=vn}         record value'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: T ::=                          Types
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| {i1:T1, ..., in:Tn}         record type'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| ...'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Encoding Records (Optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see how records can be encoded using just pairs and unit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, observe that we can encode arbitrary-size *tuples* using
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nested pairs and the unit value.  To avoid overloading the pair
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: notation (t[1],t[2]), we'll use curly braces without labels to write
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: down tuples, so {} is the empty tuple, {5} is a singleton
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tuple, {5,6} is a 2-tuple (morally the same as a pair),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{5,6,7} is a triple, etc.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can encode tuple types using nested product types:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The operation of projecting a field from a tuple can be encoded
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'using a sequence of second projections followed by a first projection:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Next, suppose that there is some total ordering on record labels,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so that we can associate each label with a unique natural number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This number is called the *position* of the label.  For example,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'we might assign positions like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We use these positions to encode record values as tuples (i.e., as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nested pairs) by sorting the fields according to their positions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note that each field appears in the position associated with its
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: label, that the size of the tuple is determined by the label with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the highest position, and that we fill in unused positions with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We do exactly the same thing with record types:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Finally, record projection is encoded as a tuple projection from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the appropriate position:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It is not hard to check that all the typing rules for the original
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"direct" presentation of records are validated by this'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: encoding.  (The reduction rules are "almost validated" — not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: quite, because the encoding reorders fields.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Of course, this encoding will not be very efficient if we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: happen to use a record with label foo!  But things are not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'actually as bad as they might seem: for example, if we assume that'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: our compiler can see the whole program at the same time, we can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*choose* the numbering of labels so that we assign small positions'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to the most frequently used labels.  Indeed, there are industrial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: compilers that essentially do this!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Variants (Optional)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as products can be generalized to records, sums can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: generalized to n-ary labeled types called *variants*.  Instead of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: T[1]+T[2], we can write something like <l[1]:T[1],l[2]:T[2],...ln:Tn>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where l[1],l[2],... are field labels which are used both to build
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: instances and as case arm labels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These n-ary variants give us almost enough mechanism to build
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arbitrary inductive data types like lists and trees from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: scratch — the only thing missing is a way to allow *recursion* in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type definitions.  We won't cover this here, but detailed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: treatments can be found in many textbooks — e.g., Types and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Programming Languages [[Pierce 2002]](Bib.html#Pierce 2002).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Module STLCExtended.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive ty : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| TArrow : ty → ty → ty'
  prefs: []
  type: TYPE_NORMAL
- en: '| TNat   : ty'
  prefs: []
  type: TYPE_NORMAL
- en: '| TUnit  : ty'
  prefs: []
  type: TYPE_NORMAL
- en: '| TProd  : ty → ty → ty'
  prefs: []
  type: TYPE_NORMAL
- en: '| TSum   : ty → ty → ty'
  prefs: []
  type: TYPE_NORMAL
- en: '| TList  : ty → ty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive tm : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: (* pure STLC *)
  prefs: []
  type: TYPE_NORMAL
- en: '| tvar : id → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tapp : tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tabs : id → ty → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: (* numbers *)
  prefs: []
  type: TYPE_NORMAL
- en: '| tnat : nat → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tsucc : tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tpred : tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tmult : tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tif0  : tm → tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: (* pairs *)
  prefs: []
  type: TYPE_NORMAL
- en: '| tpair : tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tfst : tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tsnd : tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: (* units *)
  prefs: []
  type: TYPE_NORMAL
- en: '| tunit : tm'
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  prefs: []
  type: TYPE_NORMAL
- en: '| tlet : id → tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: (* i.e., let x = t[1] in t[2] *)
  prefs: []
  type: TYPE_NORMAL
- en: (* sums *)
  prefs: []
  type: TYPE_NORMAL
- en: '| tinl : ty → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tinr : ty → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tcase : tm → id → tm → id → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: (* i.e., case t[0] of inl x[1] ⇒ t[1] | inr x[2] ⇒ t[2] *)
  prefs: []
  type: TYPE_NORMAL
- en: (* lists *)
  prefs: []
  type: TYPE_NORMAL
- en: '| tnil : ty → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tcons : tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tlcase : tm → tm → id → id → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: (* i.e., lcase t[1] of | nil → t[2] | x::y → t[3] *)
  prefs: []
  type: TYPE_NORMAL
- en: (* fix *)
  prefs: []
  type: TYPE_NORMAL
- en: '| tfix  : tm → tm.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: if x = 0 then ... else ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: if0 x then ... else ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Substitution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Reduction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we define the values of our language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Next we define the typing rules.  These are nearly direct
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: transcriptions of the inference rules shown above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section presents formalized versions of the examples from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: above (plus several more).  The ones at the beginning focus on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: specific features; you can use these to make sure your definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of a given feature is reasonable before moving on to extending the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proofs later in the file with the cases relating to this feature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The later examples require all the features together, so you'll
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need to come back to these when you've got all the definitions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: filled in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Preliminaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s define a few variable names:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Next, a bit of Coq hackery to automate searching for typing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: derivations.  You don't need to understand this bit in detail —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: just have a look over it so that you'll know what to look for if
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: you ever find yourself needing to make custom extensions to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The following Hint declarations say that, whenever auto
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arrives at a goal of the form (Γ ⊢ (tapp e[1] e[1]) ∈ T), it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: should consider eapply T_App, leaving an existential variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for the middle type T[1], and similar for lcase. That variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: will then be filled in during the search for type derivations for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e[1] and e[2].  We also include a hint to "try harder" when
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: solving equality goals; this is useful to automate uses of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: T_Var (which includes an equality as a precondition).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Remove the comment braces once you've implemented enough of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions that you think this should work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: let
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Sums
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: fix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '(Warning: you may be able to typecheck fact but still have some'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rules wrong!)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Properties of Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proofs of progress and preservation for this enriched system
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are essentially the same (though of course longer) as for the pure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: STLC.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem progress : ∀t T,'
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: value t ∨ ∃t', t ⇒ t'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* Theorem: Suppose empty |- t : T.  Then either        1. t is a value, or
           2. t ==> t' for some t'.      Proof: By induction on the given typing derivation. *)
  prefs: []
  type: TYPE_NORMAL
- en: intros t T Ht.
  prefs: []
  type: TYPE_NORMAL
- en: remember [empty](Maps.html#empty) as Γ.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent HeqGamma.
  prefs: []
  type: TYPE_NORMAL
- en: induction Ht; intros HeqGamma; subst.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Var *)'
  prefs: []
  type: TYPE_NORMAL
- en: '(* The final rule in the given typing derivation cannot be         T_Var, since it can never be the case that 
           empty ⊢ x : T (since the context is empty). *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If the T_Abs rule was the last used, then         t = tabs x T[11] t[12], which is a value. *)
  prefs: []
  type: TYPE_NORMAL
- en: left...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: '(* If the last rule applied was T_App, then t = t[1] t[2],         and we know from the form of the rule that
             empty ⊢ t[1] : T[1] → T[2]          empty ⊢ t[2] : T[1]        By the induction hypothesis, each of t[1] and t[2] either is 
           a value or can take a step. *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1; subst...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] is a value *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If both t[1] and t[2] are values, then we know that            t[1] = tabs
    x T[11] t[12], since abstractions are the             only values that can have an arrow type.  But
               (tabs x T[11] t[12]) t[2] ⇒ [x:=t[2]]t[12] by ST_AppAbs. *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: ∃([subst](MoreStlc.html#STLCExtended.subst) x t[2] t[12])...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If t[1] is a value and t[2] ⇒ t[2]',             then t[1] t[2] ⇒ t[1] t[2]' by ST_App2. *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0] as [t[2]' Hstp]. ∃([tapp](MoreStlc.html#STLCExtended.tapp) t[1]
    t[2]')...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: (* Finally, If t[1] ⇒ t[1]', then t[1] t[2] ⇒ t[1]' t[2]           by ST_App1. *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' Hstp]. ∃([tapp](MoreStlc.html#STLCExtended.tapp) t[1]'
    t[2])...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Nat *)'
  prefs: []
  type: TYPE_NORMAL
- en: left...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Succ *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S)
    n[1]))...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tsucc](MoreStlc.html#STLCExtended.tsucc) t[1]')...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Pred *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([pred](http://coq.inria.fr/library/Coq.Init.Peano.html#pred)
    n[1]))...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tpred](MoreStlc.html#STLCExtended.tpred) t[1]')...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Mult *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] is a value *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0]; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([mult](http://coq.inria.fr/library/Coq.Init.Peano.html#mult)
    n[1] n[0]))...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[2] steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[0] as [t[2]' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tmult](MoreStlc.html#STLCExtended.tmult) t[1] t[2]')...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tmult](MoreStlc.html#STLCExtended.tmult) t[1]' t[2])...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_If[0] *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: destruct n[1] as [|n[1]'].
  prefs: []
  type: TYPE_NORMAL
- en: '* (* n[1]=0 *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃t[2]...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* n[1]<>0 *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃t[3]...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' H[0]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tif0](MoreStlc.html#STLCExtended.tif0) t[1]' t[2] t[3])...
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Unit *)'
  prefs: []
  type: TYPE_NORMAL
- en: left...
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Inl *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion H as [t[1]' Hstp]...
  prefs: []
  type: TYPE_NORMAL
- en: (* exists (tinl _ t[1]')... *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Inr *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion H as [t[1]' Hstp]...
  prefs: []
  type: TYPE_NORMAL
- en: (* exists (tinr _ t[1]')... *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Case *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[0] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[0] is inl *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃([x[1]:=v]t[1])...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[0] is inr *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃([x[2]:=v]t[2])...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[0] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[0]' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tcase](MoreStlc.html#STLCExtended.tcase) t[0]' x[1] t[1] x[2] t[2])...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Nil *)'
  prefs: []
  type: TYPE_NORMAL
- en: left...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Cons *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  prefs: []
  type: TYPE_NORMAL
- en: + (* head is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* tail steps *)'
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion H[0] as [t[2]' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tcons](MoreStlc.html#STLCExtended.tcons) t[1] t[2]')...
  prefs: []
  type: TYPE_NORMAL
- en: + (* head steps *)
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion H as [t[1]' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tcons](MoreStlc.html#STLCExtended.tcons) t[1]' t[2])...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Lcase *)'
  prefs: []
  type: TYPE_NORMAL
- en: right.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[1]=tnil *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃t[2]...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[1]=tcons v[1] vl *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃([x[2]:=vl]([x[1]:=v[1]]t[3]))...
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' Hstp].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tlcase](MoreStlc.html#STLCExtended.tlcase) t[1]' t[2] x[1] x[2] t[3])...
  prefs: []
  type: TYPE_NORMAL
- en: (* fix *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive appears_free_in : id → tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_var : ∀x,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tvar x)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_app1 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] → appears_free_in x (tapp t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_app2 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] → appears_free_in x (tapp t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_abs : ∀x y T[11] t[12],'
  prefs: []
  type: TYPE_NORMAL
- en: y ≠ x  →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[12] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tabs y T[11] t[12])
  prefs: []
  type: TYPE_NORMAL
- en: (* nats *)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_succ : ∀x t,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tsucc t)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_pred : ∀x t,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tpred t)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_mult1 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tmult t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_mult2 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tmult t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_if[01] : ∀x t[1] t[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tif0 t[1] t[2] t[3])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_if[02] : ∀x t[1] t[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tif0 t[1] t[2] t[3])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_if[03] : ∀x t[1] t[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[3] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tif0 t[1] t[2] t[3])
  prefs: []
  type: TYPE_NORMAL
- en: (* pairs *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: (* sums *)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_inl : ∀x t T,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tinl T t)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_inr : ∀x t T,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tinr T t)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_case0 : ∀x t[0] x[1] t[1] x[2] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[0] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tcase t[0] x[1] t[1] x[2] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_case1 : ∀x t[0] x[1] t[1] x[2] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: x[1] ≠ x →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tcase t[0] x[1] t[1] x[2] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_case2 : ∀x t[0] x[1] t[1] x[2] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: x[2] ≠ x →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tcase t[0] x[1] t[1] x[2] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: (* lists *)
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_cons1 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tcons t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_cons2 : ∀x t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tcons t[1] t[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_lcase1 : ∀x t[1] t[2] y[1] y[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_lcase2 : ∀x t[1] t[2] y[1] y[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_lcase3 : ∀x t[1] t[2] y[1] y[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: y[1] ≠ x →
  prefs: []
  type: TYPE_NORMAL
- en: y[2] ≠ x →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[3] →
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
  prefs: []
  type: TYPE_NORMAL
- en: (* fix *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: Hint Constructors appears_free_in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma context_invariance : ∀Γ Γ'' t S,'
  prefs: []
  type: TYPE_NORMAL
- en: Γ ⊢ t ∈ S  →
  prefs: []
  type: TYPE_NORMAL
- en: (∀x, appears_free_in x t → Γ x = Γ' x)  →
  prefs: []
  type: TYPE_NORMAL
- en: Γ' ⊢ t ∈ S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros. generalize dependent Γ'.
  prefs: []
  type: TYPE_NORMAL
- en: induction H;
  prefs: []
  type: TYPE_NORMAL
- en: intros Γ' Heqv...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Var *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Var](MoreStlc.html#STLCExtended.T_Var)... rewrite ← Heqv...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Abs](MoreStlc.html#STLCExtended.T_Abs)... apply IHhas_type. intros
    y Hafi.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Mult *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Mult](MoreStlc.html#STLCExtended.T_Mult)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_If[0] *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_If[0]](MoreStlc.html#STLCExtended.T_If<sub>0</sub>)...
  prefs: []
  type: TYPE_NORMAL
- en: (* pair *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Case *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Case](MoreStlc.html#STLCExtended.T_Case)...
  prefs: []
  type: TYPE_NORMAL
- en: + apply IHhas_type2. intros y Hafi.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x[1] y)...
  prefs: []
  type: TYPE_NORMAL
- en: + apply IHhas_type3. intros y Hafi.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x[2] y)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Cons *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Cons](MoreStlc.html#STLCExtended.T_Cons)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Lcase *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Lcase](MoreStlc.html#STLCExtended.T_Lcase)... apply IHhas_type3. intros
    y Hafi.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x[1] y)...
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x[2] y)...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma free_in_context : ∀x t T Γ,'
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  prefs: []
  type: TYPE_NORMAL
- en: Γ ⊢ t ∈ T →
  prefs: []
  type: TYPE_NORMAL
- en: ∃T', Γ x = Some T'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros x t T Γ Hafi Htyp.
  prefs: []
  type: TYPE_NORMAL
- en: induction Htyp; inversion Hafi; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Abs *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHtyp as [T' Hctx]... ∃T'.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: (* T_Case *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* left *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHtyp2 as [T' Hctx]... ∃T'.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* right *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHtyp3 as [T' Hctx]... ∃T'.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Lcase *)'
  prefs: []
  type: TYPE_NORMAL
- en: clear Htyp1 IHHtyp1 Htyp2 IHHtyp2.
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHtyp3 as [T' Hctx]... ∃T'.
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  prefs: []
  type: TYPE_NORMAL
- en: (update Γ x U) ⊢ t ∈ S  →
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ v ∈ U   →
  prefs: []
  type: TYPE_NORMAL
- en: Γ ⊢ ([x:=v]t) ∈ S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* Theorem: If Gamma,x:U |- t : S and empty |- v : U, then      Gamma |- x:=vt : S. *)
  prefs: []
  type: TYPE_NORMAL
- en: intros Γ x U v t S Htypt Htypv.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent Γ. generalize dependent S.
  prefs: []
  type: TYPE_NORMAL
- en: (* Proof: By induction on the term t.  Most cases follow       directly from the IH, with the exception of tvar
         and tabs. These aren't automatic because we must      reason about how the variables interact. *)
  prefs: []
  type: TYPE_NORMAL
- en: induction t;
  prefs: []
  type: TYPE_NORMAL
- en: intros S Γ Htypt; simpl; inversion Htypt; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tvar *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rename i into y.
  prefs: []
  type: TYPE_NORMAL
- en: '(* If t = y, we know that          empty ⊢ v : U and          Γ,x:U ⊢ y : S
           and, by inversion, update Γ x U y = Some S.  We want to        show that Γ
    ⊢ [x:=v]y : S.        There are two cases to consider: either x=y or x≠y. *)'
  prefs: []
  type: TYPE_NORMAL
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in H[1].
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y).
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x = y, then we know that U = S, and that           [x:=v]y = v.  So what we really must show is 
             that if empty ⊢ v : U then Γ ⊢ v : U.            We have already proven a more general version
             of this theorem, called context invariance. *)'
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[1]; subst. clear H[1].
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hcontra.
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([free_in_context](MoreStlc.html#STLCExtended.free_in_context) _ _
    S [empty](Maps.html#empty) Hcontra)
  prefs: []
  type: TYPE_NORMAL
- en: as [T' HT']...
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT'.
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x ≠ y, then Γ y = Some S and the substitution has no        effect.  We can show that Γ
    ⊢ y : S by T_Var. *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Var](MoreStlc.html#STLCExtended.T_Var)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tabs *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i into y. rename t into T[11].
  prefs: []
  type: TYPE_NORMAL
- en: '(* If t = tabs y T[11] t[0], then we know that          Γ,x:U ⊢ tabs y T[11]
    t[0] : T[11]→T[12]          Γ,x:U,y:T[11] ⊢ t[0] : T[12]          empty ⊢ v :
    U        As our IH, we know that forall S Gamma,          Γ,x:U ⊢ t[0] : S → Γ
    ⊢ [x:=v]t[0] : S.        We can calculate that          x:=vt = tabs y T[11] (if beq_id x y then t[0] else x:=vt[0])
           And we must show that Γ ⊢ [x:=v]t : T[11]→T[12].  We know        we will do so using T_Abs, so it remains to be shown that:
             Γ,y:T[11] ⊢ if beq_id x y then t[0] else [x:=v]t[0] : T[12]        We consider two cases: x
    = y and x ≠ y.     *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [T_Abs](MoreStlc.html#STLCExtended.T_Abs)...
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y) as [Hxy|Hxy].
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x = y, then the substitution has no effect.  Context        invariance shows that Γ,y:U,y:T[11] and Γ,y:T[11] are
           equivalent.  Since the former context shows that         t[0] : T[12], so does the latter. *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) y x)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x ≠ y, then the IH and context invariance allow           us to show that
               Γ,x:U,y:T[11] ⊢ t[0] : T[12]       =>            Γ,y:T[11],x:U ⊢ t[0]
    : T[12]       =>            Γ,y:T[11] ⊢ [x:=v]t[0] : T[12] *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt. eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y z) as [Hyz|Hyz]...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id)...
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tcase *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i into x[1]. rename i[0] into x[2].
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Case](MoreStlc.html#STLCExtended.T_Case)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* left arm *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x x[1]) as [Hxx1|Hxx1].
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x = x[1] *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) x[1] z)...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x <> x[1] *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt2. eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x[1] z) as [Hx1z|Hx1z]...
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* right arm *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x x[2]) as [Hxx2|Hxx2].
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x = x[2] *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) x[2] z)...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x <> x[2] *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt3. eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x[2] z)...
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tlcase *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i into y[1]. rename i[0] into y[2].
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Lcase](MoreStlc.html#STLCExtended.T_Lcase)...
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y[1]).
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y[1] *)
  prefs: []
  type: TYPE_NORMAL
- en: simpl.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y[1] z)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y[1] *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y[2]).
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x=y[2] *)'
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y[2] z)...
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x<>y[2] *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt3. eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y[1] z)...
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y[2] z)...
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem preservation : ∀t t'' T,'
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ t ∈ T  →
  prefs: []
  type: TYPE_NORMAL
- en: t ⇒ t'  →
  prefs: []
  type: TYPE_NORMAL
- en: empty ⊢ t' ∈ T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t t' T HT.
  prefs: []
  type: TYPE_NORMAL
- en: '(* Theorem: If empty ⊢ t : T and t ⇒ t'', then       empty ⊢ t'' : T. *)'
  prefs: []
  type: TYPE_NORMAL
- en: remember [empty](Maps.html#empty) as Γ. generalize dependent HeqGamma.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent t'.
  prefs: []
  type: TYPE_NORMAL
- en: (* Proof: By induction on the given typing derivation.  Many       cases are contradictory (T_Var, T_Abs).  We show just 
         the interesting ones. *)
  prefs: []
  type: TYPE_NORMAL
- en: induction HT;
  prefs: []
  type: TYPE_NORMAL
- en: intros t' HeqGamma HE; subst; inversion HE; subst...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_App *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* If the last rule used was T_App, then t = t[1] t[2], and         three rules could have been used to show t
    ⇒ t':         ST_App1, ST_App2, and ST_AppAbs. In the first two         cases, the result follows directly from the IH. *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion HE; subst...
  prefs: []
  type: TYPE_NORMAL
- en: + (* ST_AppAbs *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* For the third case, suppose            t[1] = tabs x T[11] t[12]          and
               t[2] = v[2].          We must show that empty ⊢ [x:=v[2]]t[12] : T[2].
             We know by assumption that              empty ⊢ tabs x T[11] t[12] :
    T[1]→T[2]          and by inversion              x:T[1] ⊢ t[12] : T[2]          We have already proven that substitution preserves 
             typing, and              empty ⊢ v[2] : T[1]          by assumption, so we are done. *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    with T[1]...
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT[1]...
  prefs: []
  type: TYPE_NORMAL
- en: (* fst and snd *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: (* T_Case *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* ST_CaseInl *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT[1]; subst.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* ST_CaseInr *)'
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT[1]; subst.
  prefs: []
  type: TYPE_NORMAL
- en: eapply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Lcase *)'
  prefs: []
  type: TYPE_NORMAL
- en: + (* ST_LcaseCons *)
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT[1]; subst.
  prefs: []
  type: TYPE_NORMAL
- en: apply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    with ([TList](MoreStlc.html#STLCExtended.TList) T[1])...
  prefs: []
  type: TYPE_NORMAL
- en: apply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    with T[1]...
  prefs: []
  type: TYPE_NORMAL
- en: (* fix *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Qed.
  prefs: []
  type: TYPE_NORMAL
- en: End STLCExtended.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: (* $Date: 2016-12-17 23:53:20 -0500 (Sat, 17 Dec 2016) $ *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
