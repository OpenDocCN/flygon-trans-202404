- en: MoreStlcMore on the Simply Typed Lambda-Calculus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于简单类型 λ 演算的内容
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Import Maps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Maps。
- en: Require Import Types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Types。
- en: Require Import Smallstep.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Smallstep。
- en: Require Import Stlc.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 Stlc。
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: t ::=                Terms
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t ::=                术语
- en: '| ...               (other terms same as before)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...               (其他术语与之前相同)'
- en: '| let x=t in t      let-binding'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| 让 x=t 在 t 中      让绑定'
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'λx : Nat*Nat.'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'λx : Nat*Nat.'
- en: let sum = x.fst + x.snd in
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让和 = x.fst + x.snd 在
- en: let diff = x.fst - x.snd in
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让差值 = x.fst - x.snd
- en: (sum,diff)
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (和,差)
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: t ::=                Terms
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t ::=                术语
- en: '| (t,t)             pair'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| (t,t)             对'
- en: '| t.fst             first projection'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| t.fst             第一投影'
- en: '| t.snd             second projection'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| t.snd             第二投影'
- en: '| ...'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: v ::=                Values
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: v ::=                值
- en: '| (v,v)             pair value'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| (v,v)             对值'
- en: '| ...'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: T ::=                Types
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T ::=                类型
- en: '| T * T             product type'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| T * T             乘积类型'
- en: '| ...'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: t ::=                Terms
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t ::=                术语
- en: '| unit              unit value'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| unit              单元值'
- en: '| ...'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: v ::=                Values
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: v ::=                值
- en: '| unit              unit'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| unit              单元'
- en: '| ...'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: T ::=                Types
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T ::=                类型
- en: '| Unit              Unit type'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| Unit              单元类型'
- en: '| ...'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nat + Bool
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Nat + Bool
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'inl : Nat -> Nat + Bool'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'inl : Nat -> Nat + Bool'
- en: 'inr : Bool -> Nat + Bool'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 'inr : Bool -> Nat + Bool'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'div : Nat -> Nat -> (Nat + Unit) ='
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'div : Nat -> Nat -> (Nat + Unit) ='
- en: div =
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除法 =
- en: λx:Nat. λy:Nat.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: λx:Nat. λy:Nat.
- en: if iszero y then
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 y 是零则
- en: inr unit
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: inr 单元
- en: else
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则
- en: inl ...
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: inl ...
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: getNat =
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取自然数 =
- en: λx:Nat+Bool.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: λx:Nat+Bool.
- en: case x of
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对 x 进行分析
- en: inl n => n
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: inl n => n
- en: '| inr b => if b then 1 else 0'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| inr b => 如果 b 则 1 否则 0'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: t ::=                Terms
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t ::=                术语
- en: '| inl T t           tagging (left)'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| inl T t           标记（左）'
- en: '| inr T t           tagging (right)'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| inr T t           标记（右）'
- en: '| case t of         case'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| case t of         案例'
- en: inl x => t
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: inl x => t
- en: '| inr x => t'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| inr x => t'
- en: '| ...'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: v ::=                Values
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: v ::=                值
- en: '| inl T v           tagged value (left)'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| inl T v           标记值（左）'
- en: '| inr T v           tagged value (right)'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| inr T v           标记值（右）'
- en: '| ...'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: T ::=                Types
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T ::=                类型
- en: '| T + T             sum type'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| T + T             和类型'
- en: '| ...'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: λx:List Nat.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: λx:List Nat.
- en: lcase x of nil -> 0
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lcase x of nil -> 0
- en: '| a::x'' -> lcase x'' of nil -> a'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| a::x'' -> lcase x'' of nil -> a'
- en: '| b::x'''' -> a+b'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| b::x'''' -> a+b'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: t ::=                Terms
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t ::=                术语
- en: '| nil T'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| nil T'
- en: '| cons t t'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| cons t t'
- en: '| lcase t of nil -> t | x::x -> t'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| lcase t of nil -> t | x::x -> t'
- en: '| ...'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: v ::=                Values
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: v ::=                值
- en: '| nil T             nil value'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| nil T             空值'
- en: '| cons v v          cons value'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| cons v v          cons 值'
- en: '| ...'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: T ::=                Types
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T ::=                类型
- en: '| List T            list of Ts'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| List T            Ts 的列表'
- en: '| ...'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: fact = λx:Nat.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 阶乘 = λx:Nat.
- en: if x=0 then 1 else x * (fact (pred x)))
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 x=0 则 1 否则 x * (阶乘 (前驱 x)))
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: fact = λx:Nat.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 阶乘 = λx:Nat.
- en: if x=0 then 1 else x * (fact (pred x)))
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 x=0 则 1 否则 x * (阶乘 (前驱 x)))
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: fact =
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 阶乘 =
- en: fix
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修复
- en: (λf:Nat->Nat.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (λf:Nat->Nat.
- en: λx:Nat.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: λx:Nat.
- en: if x=0 then 1 else x * (f (pred x)))
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 x=0 则 1 否则 x * (f (前驱 x)))
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: t ::=                Terms
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t ::=                术语
- en: '| fix t             fixed-point operator'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| 修复 t             不动点运算符'
- en: '| ...'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: F = (λf. λx. if x=0 then 1 else x * (f (pred x)))
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: F = (λf. λx. 如果 x=0 则 1 否则 x * (f (前驱 x)))
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: fix F 3
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修复 F 3
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: (λx. if x=0 then 1 else x * (fix F (pred x))) 3
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (λx. 如果 x=0 则 1 否则 x * (修复 F (前驱 x))) 3
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: if 3=0 then 1 else 3 * (fix F (pred 3))
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 3=0 则 1 否则 3 * (修复 F (前驱 3))
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 3 * (fix F (pred 3))
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (修复 F (前驱 3))
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 3 * ((λx. if x=0 then 1 else x * (fix F (pred x))) (pred 3))
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * ((λx. 如果 x=0 则 1 否则 x * (修复 F (前驱 x))) (前驱 3))
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 3 * ((λx. if x=0 then 1 else x * (fix F (pred x))) 2)
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * ((λx. 如果 x=0 则 1 否则 x * (修复 F (前驱 x))) 2)
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 3 * (if 2=0 then 1 else 2 * (fix F (pred 2)))
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (如果 2=0 则 1 否则 2 * (修复 F (前驱 2)))
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 3 * (2 * (fix F (pred 2)))
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * (修复 F (前驱 2)))
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 3 * (2 * ((λx. if x=0 then 1 else x * (fix F (pred x))) (pred 2)))
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * ((λx. 如果 x=0 则 1 否则 x * (修复 F (前驱 x))) (前驱 2)))
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 3 * (2 * ((λx. if x=0 then 1 else x * (fix F (pred x))) 1))
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * ((λx. 如果 x=0 则 1 否则 x * (修复 F (前驱 x))) 1))
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 3 * (2 * (if 1=0 then 1 else 1 * (fix F (pred 1))))
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * (如果 1=0 则 1 否则 1 * (修复 F (前驱 1))))
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 3 * (2 * (1 * (fix F (pred 1))))
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * (1 * (修复 F (前驱 1)))
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 3 * (2 * (1 * ((λx. if x=0 then 1 else x * (fix F (pred x))) (pred 1))))
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * (1 * ((λx. 如果 x=0 则 1 否则 x * (修复 F (前驱 x))) (前驱 1))))
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 3 * (2 * (1 * ((λx. if x=0 then 1 else x * (fix F (pred x))) 0)))
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * (1 * ((λx. 如果 x=0 则 1 否则 x * (修复 F (前驱 x))) 0)))
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 3 * (2 * (1 * (if 0=0 then 1 else 0 * (fix F (pred 0)))))
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * (1 * (如果 0=0 则 1 否则 0 * (修复 F (前驱 0))))
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 3 * (2 * (1 * 1))
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * (1 * 1))
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 3 * (2 * 1)
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * (2 * 1)
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 3 * 2
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 * 2
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '6'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: halve =
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: halve =
- en: λx:Nat.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: λx:Nat.
- en: if x=0 then 0
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 x=0 则 0
- en: else if (pred x)=0 then 0
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则如果 (前驱 x)=0 则 0
- en: else 1 + (halve (pred (pred x))))
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则 1 + (halve (前驱 (前驱 x))))
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: fix (λx:T.x)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 修复 (λx:T.x)
- en: By T_Fix  and T_Abs, this term has type T.  By ST_FixAbs
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过 T_Fix 和 T_Abs，这个术语的类型为 T。通过 ST_FixAbs
- en: it reduces to itself, over and over again.  Thus it is a
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它一遍又一遍地减少自身。因此它是一个
- en: '*diverging element* of T.'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*发散元素* of T.'
- en: More usefully, here's an example using fix to define a
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更有用的是，这里有一个使用fix来定义的示例
- en: 'two-argument recursive function:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 二参数递归函数：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: And finally, here is an example where fix is used to define a
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，这里是一个使用fix来定义的示例
- en: '*pair* of recursive functions (illustrating the fact that the type'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*对*递归函数对（说明类型的事实'
- en: 'T[1] in the rule T_Fix need not be a function type):'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T[1]在规则T_Fix中不必是函数类型）：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: t ::=                          Terms
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: t ::=                          术语
- en: '| {i1=t1, ..., in=tn}         record'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| {i1=t1, ..., in=tn}         记录'
- en: '| t.i                         projection'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| t.i                         投影'
- en: '| ...'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: v ::=                          Values
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: v ::=                          值
- en: '| {i1=v1, ..., in=vn}         record value'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| {i1=v1, ..., in=vn}         记录值'
- en: '| ...'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: T ::=                          Types
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T ::=                          类型
- en: '| {i1:T1, ..., in:Tn}         record type'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| {i1:T1, ..., in:Tn}         记录类型'
- en: '| ...'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '| ...'
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Encoding Records (Optional)
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码记录（可选）
- en: Let's see how records can be encoded using just pairs and unit.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看如何只使用对和单位来编码记录。
- en: First, observe that we can encode arbitrary-size *tuples* using
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，观察到我们可以使用任意大小的*元组*进行编码
- en: nested pairs and the unit value.  To avoid overloading the pair
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嵌套对和单位值。为了避免过载对
- en: notation (t[1],t[2]), we'll use curly braces without labels to write
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 符号（t[1]，t[2]），我们将使用没有标签的花括号来写
- en: down tuples, so {} is the empty tuple, {5} is a singleton
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 减少元组，所以{}是空元组，{5}是单例
- en: tuple, {5,6} is a 2-tuple (morally the same as a pair),
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 元组，{5,6}是一个2元组（道义上与一对相同），
- en: '{5,6,7} is a triple, etc.'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{5,6,7}是三元组，等等。'
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Similarly, we can encode tuple types using nested product types:'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，我们可以使用嵌套乘积类型来编码元组类型：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The operation of projecting a field from a tuple can be encoded
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从元组中投影字段的操作可以被编码
- en: 'using a sequence of second projections followed by a first projection:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用一系列第二个投影，然后是第一个投影：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, suppose that there is some total ordering on record labels,
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，假设记录标签上有一些完全排序，
- en: so that we can associate each label with a unique natural number.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以便我们可以将每个标签与唯一的自然数关联起来。
- en: This number is called the *position* of the label.  For example,
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个数字被称为*标签的位置*。例如，
- en: 'we might assign positions like this:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可能分配位置如下：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We use these positions to encode record values as tuples (i.e., as
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用这些位置将记录值编码为元组（即，作为
- en: nested pairs) by sorting the fields according to their positions.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嵌套对）通过根据其位置对字段进行排序。
- en: 'For example:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that each field appears in the position associated with its
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，每个字段都出现在与其关联的位置上
- en: label, that the size of the tuple is determined by the label with
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标签，元组的大小由带有标签的标签确定
- en: the highest position, and that we fill in unused positions with
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最高位置，并且我们用未使用的位置填充
- en: unit.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单位。
- en: 'We do exactly the same thing with record types:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们对记录类型执行完全相同的操作：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Finally, record projection is encoded as a tuple projection from
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，记录投影被编码为元组投影
- en: 'the appropriate position:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 适当的位置：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It is not hard to check that all the typing rules for the original
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查原始的所有类型规则并不难
- en: '"direct" presentation of records are validated by this'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “直接”呈现记录由此验证
- en: encoding.  (The reduction rules are "almost validated" — not
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编码。（减少规则“几乎验证” — 不
- en: quite, because the encoding reorders fields.)
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相当，因为编码重新排序字段。）
- en: Of course, this encoding will not be very efficient if we
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，如果我们这样做
- en: happen to use a record with label foo!  But things are not
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 碰巧使用具有标签foo的记录！但事情并不是
- en: 'actually as bad as they might seem: for example, if we assume that'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上并不像它们看起来那么糟糕：例如，如果我们假设
- en: our compiler can see the whole program at the same time, we can
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的编译器可以同时看到整个程序，我们可以
- en: '*choose* the numbering of labels so that we assign small positions'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*选择*标签的编号，以便我们分配小位置'
- en: to the most frequently used labels.  Indeed, there are industrial
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到最常用的标签。实际上，有工业
- en: compilers that essentially do this!
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本质上是这样做的编译器！
- en: Variants (Optional)
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变体（可选）
- en: Just as products can be generalized to records, sums can be
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如乘积可以推广到记录，和可以
- en: generalized to n-ary labeled types called *variants*.  Instead of
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 广义到n元标记类型称为*变体*。而不是
- en: T[1]+T[2], we can write something like <l[1]:T[1],l[2]:T[2],...ln:Tn>
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T[1]+T[2]，我们可以写一些类似<l[1]:T[1],l[2]:T[2],...ln:Tn>
- en: where l[1],l[2],... are field labels which are used both to build
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中l[1]，l[2]，...是用于构建的字段标签
- en: instances and as case arm labels.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实例和作为案例臂标签。
- en: These n-ary variants give us almost enough mechanism to build
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些n元变体几乎为我们提供了足够的机制来构建
- en: arbitrary inductive data types like lists and trees from
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任意归纳数据类型，如列表和树
- en: scratch — the only thing missing is a way to allow *recursion* in
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type definitions.  We won't cover this here, but detailed
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: treatments can be found in many textbooks — e.g., Types and
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Programming Languages [[Pierce 2002]](Bib.html#Pierce 2002).
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Module STLCExtended.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Inductive ty : Type :='
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '| TArrow : ty → ty → ty'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '| TNat   : ty'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '| TUnit  : ty'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '| TProd  : ty → ty → ty'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '| TSum   : ty → ty → ty'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '| TList  : ty → ty.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive tm : Type :='
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: (* pure STLC *)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '| tvar : id → tm'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '| tapp : tm → tm → tm'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '| tabs : id → ty → tm → tm'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: (* numbers *)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '| tnat : nat → tm'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '| tsucc : tm → tm'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '| tpred : tm → tm'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '| tmult : tm → tm → tm'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '| tif0  : tm → tm → tm → tm'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: (* pairs *)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '| tpair : tm → tm → tm'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '| tfst : tm → tm'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '| tsnd : tm → tm'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: (* units *)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '| tunit : tm'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '| tlet : id → tm → tm → tm'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: (* i.e., let x = t[1] in t[2] *)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: (* sums *)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '| tinl : ty → tm → tm'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '| tinr : ty → tm → tm'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '| tcase : tm → id → tm → id → tm → tm'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: (* i.e., case t[0] of inl x[1] ⇒ t[1] | inr x[2] ⇒ t[2] *)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: (* lists *)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '| tnil : ty → tm'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '| tcons : tm → tm → tm'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '| tlcase : tm → tm → id → id → tm → tm'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: (* i.e., lcase t[1] of | nil → t[2] | x::y → t[3] *)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: (* fix *)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '| tfix  : tm → tm.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: if x = 0 then ... else ...
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: if0 x then ... else ...
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Substitution
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Reduction
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we define the values of our language.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Typing
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Next we define the typing rules.  These are nearly direct
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: transcriptions of the inference rules shown above.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Examples
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section presents formalized versions of the examples from
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: above (plus several more).  The ones at the beginning focus on
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: specific features; you can use these to make sure your definition
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of a given feature is reasonable before moving on to extending the
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proofs later in the file with the cases relating to this feature.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The later examples require all the features together, so you'll
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need to come back to these when you've got all the definitions
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: filled in.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Preliminaries
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s define a few variable names:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Next, a bit of Coq hackery to automate searching for typing
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: derivations.  You don't need to understand this bit in detail —
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: just have a look over it so that you'll know what to look for if
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: you ever find yourself needing to make custom extensions to
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: auto.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The following Hint declarations say that, whenever auto
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arrives at a goal of the form (Γ ⊢ (tapp e[1] e[1]) ∈ T), it
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: should consider eapply T_App, leaving an existential variable
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for the middle type T[1], and similar for lcase. That variable
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: will then be filled in during the search for type derivations for
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e[1] and e[2].  We also include a hint to "try harder" when
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: solving equality goals; this is useful to automate uses of
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: T_Var (which includes an equality as a precondition).
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Numbers
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Remove the comment braces once you've implemented enough of the
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions that you think this should work.
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Products
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: let
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Sums
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Lists
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: fix
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '(Warning: you may be able to typecheck fact but still have some'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rules wrong!)
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Properties of Typing
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The proofs of progress and preservation for this enriched system
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are essentially the same (though of course longer) as for the pure
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: STLC.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Theorem progress : ∀t T,'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 progress： ∀t T，
- en: empty ⊢ t ∈ T →
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: empty ⊢ t ∈ T →
- en: value t ∨ ∃t', t ⇒ t'.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: value t ∨ ∃t', t ⇒ t'.
- en: Proof with eauto.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: (* Theorem: Suppose empty |- t : T.  Then either        1. t is a value, or
           2. t ==> t' for some t'.      Proof: By induction on the given typing derivation. *)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: (* 定理：假设empty |- t : T。那么要么        1. t 是一个值，或者        2. t ==> t'，对于某个t'。      证明：通过对给定的类型推导进行归纳。*)
- en: intros t T Ht.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: intros t T Ht.
- en: remember [empty](Maps.html#empty) as Γ.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: remember [empty](Maps.html#empty) as Γ.
- en: generalize dependent HeqGamma.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: generalize dependent HeqGamma.
- en: induction Ht; intros HeqGamma; subst.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: induction Ht; intros HeqGamma; subst.
- en: '- (* T_Var *)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Var *)'
- en: '(* The final rule in the given typing derivation cannot be         T_Var, since it can never be the case that 
           empty ⊢ x : T (since the context is empty). *)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 给定的类型推导中的最后一条规则不能是        T_Var，因为        empty ⊢ x : T （因为上下文是空的）永远不可能成立。*)'
- en: inversion H.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H.
- en: '- (* T_Abs *)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: (* If the T_Abs rule was the last used, then         t = tabs x T[11] t[12], which is a value. *)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果最后使用的规则是T_Abs，那么        t = tabs x T[11] t[12]，这是一个值。*)
- en: left...
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: left...
- en: '- (* T_App *)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: '(* If the last rule applied was T_App, then t = t[1] t[2],         and we know from the form of the rule that
             empty ⊢ t[1] : T[1] → T[2]          empty ⊢ t[2] : T[1]        By the induction hypothesis, each of t[1] and t[2] either is 
           a value or can take a step. *)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果最后应用的规则是T_App，那么t = t[1] t[2]，        我们从规则的形式知道          empty ⊢ t[1]
    : T[1] → T[2]          empty ⊢ t[2] : T[1]        根据归纳假设，t[1] 和 t[2] 中的每一个要么是
           一个值，要么可以进行一步推导。*)'
- en: right.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: right.
- en: destruct IHHt1; subst...
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt1; subst...
- en: + (* t[1] is a value *)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是一个值 *)
- en: destruct IHHt2; subst...
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt2; subst...
- en: '* (* t[2] is a value *)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 是一个值 *)'
- en: (* If both t[1] and t[2] are values, then we know that            t[1] = tabs
    x T[11] t[12], since abstractions are the             only values that can have an arrow type.  But
               (tabs x T[11] t[12]) t[2] ⇒ [x:=t[2]]t[12] by ST_AppAbs. *)
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果t[1]和t[2]都是值，那么我们知道            t[1] = tabs x T[11] t[12]，因为抽象是            唯一可以有箭头类型的值。但是
               (tabs x T[11] t[12]) t[2] ⇒ [x:=t[2]]t[12] 通过ST_AppAbs。*)
- en: inversion H; subst; try solve_by_invert.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H; subst; try solve_by_invert.
- en: ∃([subst](MoreStlc.html#STLCExtended.subst) x t[2] t[12])...
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([subst](MoreStlc.html#STLCExtended.subst) x t[2] t[12])...
- en: '* (* t[2] steps *)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 步骤 *)'
- en: (* If t[1] is a value and t[2] ⇒ t[2]',             then t[1] t[2] ⇒ t[1] t[2]' by ST_App2. *)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果t[1]是一个值，并且t[2] ⇒ t[2]'，            那么t[1] t[2] ⇒ t[1] t[2]' 通过ST_App2。*)
- en: inversion H[0] as [t[2]' Hstp]. ∃([tapp](MoreStlc.html#STLCExtended.tapp) t[1]
    t[2]')...
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H[0] as [t[2]' Hstp]. ∃([tapp](MoreStlc.html#STLCExtended.tapp) t[1]
    t[2]')...
- en: + (* t[1] steps *)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: (* Finally, If t[1] ⇒ t[1]', then t[1] t[2] ⇒ t[1]' t[2]           by ST_App1. *)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: (* 最后，如果t[1] ⇒ t[1]'，那么t[1] t[2] ⇒ t[1]' t[2]           通过ST_App1。*)
- en: inversion H as [t[1]' Hstp]. ∃([tapp](MoreStlc.html#STLCExtended.tapp) t[1]'
    t[2])...
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H as [t[1]' Hstp]. ∃([tapp](MoreStlc.html#STLCExtended.tapp) t[1]'
    t[2])...
- en: '- (* T_Nat *)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Nat *)'
- en: left...
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: left...
- en: '- (* T_Succ *)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Succ *)'
- en: right.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: right.
- en: destruct IHHt...
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt...
- en: + (* t[1] is a value *)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是一个值 *)
- en: inversion H; subst; try solve_by_invert.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H; subst; try solve_by_invert.
- en: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S)
    n[1]))...
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([S](http://coq.inria.fr/library/Coq.Init.Datatypes.html#S)
    n[1]))...
- en: + (* t[1] steps *)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion H as [t[1]' Hstp].
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H as [t[1]' Hstp].
- en: ∃([tsucc](MoreStlc.html#STLCExtended.tsucc) t[1]')...
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tsucc](MoreStlc.html#STLCExtended.tsucc) t[1]')...
- en: '- (* T_Pred *)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Pred *)'
- en: right.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: right.
- en: destruct IHHt...
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt...
- en: + (* t[1] is a value *)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是一个值 *)
- en: inversion H; subst; try solve_by_invert.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H; subst; try solve_by_invert.
- en: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([pred](http://coq.inria.fr/library/Coq.Init.Peano.html#pred)
    n[1]))...
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([pred](http://coq.inria.fr/library/Coq.Init.Peano.html#pred)
    n[1]))...
- en: + (* t[1] steps *)
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion H as [t[1]' Hstp].
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H as [t[1]' Hstp].
- en: ∃([tpred](MoreStlc.html#STLCExtended.tpred) t[1]')...
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tpred](MoreStlc.html#STLCExtended.tpred) t[1]')...
- en: '- (* T_Mult *)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Mult *)'
- en: right.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: right.
- en: destruct IHHt1...
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt1...
- en: + (* t[1] is a value *)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 是一个值 *)
- en: destruct IHHt2...
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHt2...
- en: '* (* t[2] is a value *)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 是一个值 *)'
- en: inversion H; subst; try solve_by_invert.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H; subst; try solve_by_invert.
- en: inversion H[0]; subst; try solve_by_invert.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H[0]; subst; try solve_by_invert.
- en: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([mult](http://coq.inria.fr/library/Coq.Init.Peano.html#mult)
    n[1] n[0]))...
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tnat](MoreStlc.html#STLCExtended.tnat) ([mult](http://coq.inria.fr/library/Coq.Init.Peano.html#mult)
    n[1] n[0]))...
- en: '* (* t[2] steps *)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* t[2] 步骤 *)'
- en: inversion H[0] as [t[2]' Hstp].
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H[0] as [t[2]' Hstp].
- en: ∃([tmult](MoreStlc.html#STLCExtended.tmult) t[1] t[2]')...
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([tmult](MoreStlc.html#STLCExtended.tmult) t[1] t[2]')...
- en: + (* t[1] steps *)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: + (* t[1] 步骤 *)
- en: inversion H as [t[1]' Hstp].
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: inversion H as [t[1]' Hstp].
- en: ∃([tmult](MoreStlc.html#STLCExtended.tmult) t[1]' t[2])...
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_If[0] *)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: right.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: destruct n[1] as [|n[1]'].
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '* (* n[1]=0 *)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: ∃t[2]...
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '* (* n[1]<>0 *)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: ∃t[3]...
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' H[0]].
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tif0](MoreStlc.html#STLCExtended.tif0) t[1]' t[2] t[3])...
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Unit *)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: left...
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Inl *)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt...
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion H as [t[1]' Hstp]...
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: (* exists (tinl _ t[1]')... *)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Inr *)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt...
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion H as [t[1]' Hstp]...
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: (* exists (tinr _ t[1]')... *)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Case *)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: right.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[0] is a value *)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[0] is inl *)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: ∃([x[1]:=v]t[1])...
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[0] is inr *)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: ∃([x[2]:=v]t[2])...
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[0] steps *)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[0]' Hstp].
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tcase](MoreStlc.html#STLCExtended.tcase) t[0]' x[1] t[1] x[2] t[2])...
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Nil *)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: left...
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Cons *)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: + (* head is a value *)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt2...
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '* (* tail steps *)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion H[0] as [t[2]' Hstp].
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tcons](MoreStlc.html#STLCExtended.tcons) t[1] t[2]')...
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: + (* head steps *)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: right. inversion H as [t[1]' Hstp].
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tcons](MoreStlc.html#STLCExtended.tcons) t[1]' t[2])...
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '- (* T_Lcase *)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: right.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHHt1...
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] is a value *)
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: inversion H; subst; try solve_by_invert.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[1]=tnil *)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: ∃t[2]...
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '* (* t[1]=tcons v[1] vl *)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: ∃([x[2]:=vl]([x[1]:=v[1]]t[3]))...
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: + (* t[1] steps *)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: inversion H as [t[1]' Hstp].
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: ∃([tlcase](MoreStlc.html#STLCExtended.tlcase) t[1]' t[2] x[1] x[2] t[3])...
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: (* fix *)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Qed.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Inductive appears_free_in : id → tm → Prop :='
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_var : ∀x,'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tvar x)
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_app1 : ∀x t[1] t[2],'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] → appears_free_in x (tapp t[1] t[2])
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_app2 : ∀x t[1] t[2],'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] → appears_free_in x (tapp t[1] t[2])
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_abs : ∀x y T[11] t[12],'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: y ≠ x  →
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[12] →
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tabs y T[11] t[12])
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: (* nats *)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_succ : ∀x t,'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tsucc t)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_pred : ∀x t,'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tpred t)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_mult1 : ∀x t[1] t[2],'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] →
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tmult t[1] t[2])
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_mult2 : ∀x t[1] t[2],'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] →
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tmult t[1] t[2])
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_if[01] : ∀x t[1] t[2] t[3],'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[1] →
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tif0 t[1] t[2] t[3])
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_if[02] : ∀x t[1] t[2] t[3],'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[2] →
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tif0 t[1] t[2] t[3])
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_if[03] : ∀x t[1] t[2] t[3],'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[3] →
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tif0 t[1] t[2] t[3])
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: (* pairs *)
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: (* sums *)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_inl : ∀x t T,'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tinl T t)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_inr : ∀x t T,'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t →
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tinr T t)
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_case0 : ∀x t[0] x[1] t[1] x[2] t[2],'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x t[0] →
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: appears_free_in x (tcase t[0] x[1] t[1] x[2] t[2])
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '| afi_case1 : ∀x t[0] x[1] t[1] x[2] t[2],'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_case1 : ∀x t[0] x[1] t[1] x[2] t[2],'
- en: x[1] ≠ x →
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: x[1] ≠ x →
- en: appears_free_in x t[1] →
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[1] →
- en: appears_free_in x (tcase t[0] x[1] t[1] x[2] t[2])
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tcase t[0] x[1] t[1] x[2] t[2])
- en: '| afi_case2 : ∀x t[0] x[1] t[1] x[2] t[2],'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_case2 : ∀x t[0] x[1] t[1] x[2] t[2],'
- en: x[2] ≠ x →
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: x[2] ≠ x →
- en: appears_free_in x t[2] →
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[2] →
- en: appears_free_in x (tcase t[0] x[1] t[1] x[2] t[2])
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tcase t[0] x[1] t[1] x[2] t[2])
- en: (* lists *)
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: (* lists *)
- en: '| afi_cons1 : ∀x t[1] t[2],'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_cons1 : ∀x t[1] t[2],'
- en: appears_free_in x t[1] →
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[1] →
- en: appears_free_in x (tcons t[1] t[2])
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tcons t[1] t[2])
- en: '| afi_cons2 : ∀x t[1] t[2],'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_cons2 : ∀x t[1] t[2],'
- en: appears_free_in x t[2] →
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[2] →
- en: appears_free_in x (tcons t[1] t[2])
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tcons t[1] t[2])
- en: '| afi_lcase1 : ∀x t[1] t[2] y[1] y[2] t[3],'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_lcase1 : ∀x t[1] t[2] y[1] y[2] t[3],'
- en: appears_free_in x t[1] →
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[1] →
- en: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
- en: '| afi_lcase2 : ∀x t[1] t[2] y[1] y[2] t[3],'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_lcase2 : ∀x t[1] t[2] y[1] y[2] t[3],'
- en: appears_free_in x t[2] →
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[2] →
- en: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
- en: '| afi_lcase3 : ∀x t[1] t[2] y[1] y[2] t[3],'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '| afi_lcase3 : ∀x t[1] t[2] y[1] y[2] t[3],'
- en: y[1] ≠ x →
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: y[1] ≠ x →
- en: y[2] ≠ x →
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: y[2] ≠ x →
- en: appears_free_in x t[3] →
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t[3] →
- en: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x (tlcase t[1] t[2] y[1] y[2] t[3])
- en: (* fix *)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: (* fix *)
- en: (* FILL IN HERE *)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容*)
- en: .
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: Hint Constructors appears_free_in.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: Hint Constructors appears_free_in.
- en: 'Lemma context_invariance : ∀Γ Γ'' t S,'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma context_invariance : ∀Γ Γ'' t S,'
- en: Γ ⊢ t ∈ S  →
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: Γ ⊢ t ∈ S  →
- en: (∀x, appears_free_in x t → Γ x = Γ' x)  →
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: (∀x, appears_free_in x t → Γ x = Γ' x)  →
- en: Γ' ⊢ t ∈ S.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Γ' ⊢ t ∈ S.
- en: Proof with eauto.
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros. generalize dependent Γ'.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: intros. generalize dependent Γ'.
- en: induction H;
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: induction H;
- en: intros Γ' Heqv...
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: intros Γ' Heqv...
- en: '- (* T_Var *)'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Var *)'
- en: apply [T_Var](MoreStlc.html#STLCExtended.T_Var)... rewrite ← Heqv...
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Var](MoreStlc.html#STLCExtended.T_Var)... rewrite ← Heqv...
- en: '- (* T_Abs *)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: apply [T_Abs](MoreStlc.html#STLCExtended.T_Abs)... apply IHhas_type. intros
    y Hafi.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Abs](MoreStlc.html#STLCExtended.T_Abs)... apply IHhas_type. intros
    y Hafi.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
- en: destruct ([beq_idP](Maps.html#beq_idP) x y)...
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x y)...
- en: '- (* T_Mult *)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Mult *)'
- en: apply [T_Mult](MoreStlc.html#STLCExtended.T_Mult)...
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Mult](MoreStlc.html#STLCExtended.T_Mult)...
- en: '- (* T_If[0] *)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_If[0] *)'
- en: apply [T_If[0]](MoreStlc.html#STLCExtended.T_If<sub>0</sub>)...
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_If[0]](MoreStlc.html#STLCExtended.T_If<sub>0</sub>)...
- en: (* pair *)
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: (* pair *)
- en: (* FILL IN HERE *)
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容*)
- en: (* let *)
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: (* let *)
- en: (* FILL IN HERE *)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容*)
- en: '- (* T_Case *)'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Case *)'
- en: eapply [T_Case](MoreStlc.html#STLCExtended.T_Case)...
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_Case](MoreStlc.html#STLCExtended.T_Case)...
- en: + apply IHhas_type2. intros y Hafi.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: + apply IHhas_type2. intros y Hafi.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
- en: destruct ([beq_idP](Maps.html#beq_idP) x[1] y)...
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x[1] y)...
- en: + apply IHhas_type3. intros y Hafi.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: + apply IHhas_type3. intros y Hafi.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
- en: destruct ([beq_idP](Maps.html#beq_idP) x[2] y)...
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x[2] y)...
- en: '- (* T_Cons *)'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Cons *)'
- en: apply [T_Cons](MoreStlc.html#STLCExtended.T_Cons)...
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: apply [T_Cons](MoreStlc.html#STLCExtended.T_Cons)...
- en: '- (* T_Lcase *)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Lcase *)'
- en: eapply [T_Lcase](MoreStlc.html#STLCExtended.T_Lcase)... apply IHhas_type3. intros
    y Hafi.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: eapply [T_Lcase](MoreStlc.html#STLCExtended.T_Lcase)... apply IHhas_type3. intros
    y Hafi.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
- en: destruct ([beq_idP](Maps.html#beq_idP) x[1] y)...
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x[1] y)...
- en: destruct ([beq_idP](Maps.html#beq_idP) x[2] y)...
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: destruct ([beq_idP](Maps.html#beq_idP) x[2] y)...
- en: Qed.
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed.
- en: 'Lemma free_in_context : ∀x t T Γ,'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 'Lemma free_in_context : ∀x t T Γ,'
- en: appears_free_in x t →
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: appears_free_in x t →
- en: Γ ⊢ t ∈ T →
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: Γ ⊢ t ∈ T →
- en: ∃T', Γ x = Some T'.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ∃T', Γ x = Some T'.
- en: Proof with eauto.
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Proof with eauto.
- en: intros x t T Γ Hafi Htyp.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: intros x t T Γ Hafi Htyp.
- en: induction Htyp; inversion Hafi; subst...
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: induction Htyp; inversion Hafi; subst...
- en: '- (* T_Abs *)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Abs *)'
- en: destruct IHHtyp as [T' Hctx]... ∃T'.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHtyp as [T' Hctx]... ∃T'.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
- en: (* let *)
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: (* let *)
- en: (* FILL IN HERE *)
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写内容*)
- en: (* T_Case *)
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: (* T_Case *)
- en: '- (* left *)'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* left *)'
- en: destruct IHHtyp2 as [T' Hctx]... ∃T'.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHtyp2 as [T' Hctx]... ∃T'.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
- en: '- (* right *)'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* right *)'
- en: destruct IHHtyp3 as [T' Hctx]... ∃T'.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: destruct IHHtyp3 as [T' Hctx]... ∃T'.
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hctx 中展开 [update](Maps.html#update), [t_update](Maps.html#t_update)。
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hctx 中重写 [false_beq_id](Maps.html#false_beq_id)...
- en: '- (* T_Lcase *)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Lcase *)'
- en: clear Htyp1 IHHtyp1 Htyp2 IHHtyp2.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 清除 Htyp1 IHHtyp1 Htyp2 IHHtyp2。
- en: destruct IHHtyp3 as [T' Hctx]... ∃T'.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IHHtyp3 破坏为 [T' Hctx]... ∃T'。
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in Hctx.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hctx 中展开 [update](Maps.html#update), [t_update](Maps.html#t_update)。
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hctx 中重写 [false_beq_id](Maps.html#false_beq_id)...
- en: rewrite [false_beq_id](Maps.html#false_beq_id) in Hctx...
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Hctx 中重写 [false_beq_id](Maps.html#false_beq_id)...
- en: Qed.
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE71]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 替换保持类型不变引理：∀Γ x U v t S，
- en: (update Γ x U) ⊢ t ∈ S  →
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: (update Γ x U) ⊢ t ∈ S  →
- en: empty ⊢ v ∈ U   →
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: empty ⊢ v ∈ U   →
- en: Γ ⊢ ([x:=v]t) ∈ S.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: Γ ⊢ ([x:=v]t) ∈ S。
- en: Proof with eauto.
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明使用 eauto。
- en: (* Theorem: If Gamma,x:U |- t : S and empty |- v : U, then      Gamma |- x:=vt : S. *)
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 定理：如果 Gamma,x:U |- t : S 并且 empty |- v : U，则      Gamma |- x:=vt : S。*)'
- en: intros Γ x U v t S Htypt Htypv.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Γ x U v t S Htypt Htypv 进行介绍。
- en: generalize dependent Γ. generalize dependent S.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 推广到 Γ。推广到 S。
- en: (* Proof: By induction on the term t.  Most cases follow       directly from the IH, with the exception of tvar
         and tabs. These aren't automatic because we must      reason about how the variables interact. *)
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: (* 证明：通过对项 t 进行归纳。大多数情况都可以直接      从 IH 推导出来，除了 tvar      和 tabs。这些不是自动的，因为我们必须
         推理变量之间的交互。*)
- en: induction t;
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t 进行归纳;
- en: intros S Γ Htypt; simpl; inversion Htypt; subst...
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 对 S Γ Htypt 进行介绍；简化；反演 Htypt；替换...
- en: '- (* tvar *)'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tvar *)'
- en: simpl. rename i into y.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。将 i 重命名为 y。
- en: '(* If t = y, we know that          empty ⊢ v : U and          Γ,x:U ⊢ y : S
           and, by inversion, update Γ x U y = Some S.  We want to        show that Γ
    ⊢ [x:=v]y : S.        There are two cases to consider: either x=y or x≠y. *)'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 t = y，我们知道          empty ⊢ v : U 和          Γ,x:U ⊢ y : S        并且，通过反演，update
    Γ x U y = Some S。  我们想要展示        Γ ⊢ [x:=v]y : S。        有两种情况需要考虑：要么 x=y，要么 x≠y。*)'
- en: unfold [update](Maps.html#update), [t_update](Maps.html#t_update) in H[1].
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H[1] 中展开 [update](Maps.html#update), [t_update](Maps.html#t_update)。
- en: destruct ([beq_idP](Maps.html#beq_idP) x y).
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏 ([beq_idP](Maps.html#beq_idP) x y).
- en: + (* x=y *)
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x=y *)
- en: '(* If x = y, then we know that U = S, and that           [x:=v]y = v.  So what we really must show is 
             that if empty ⊢ v : U then Γ ⊢ v : U.            We have already proven a more general version
             of this theorem, called context invariance. *)'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x = y，那么我们知道 U = S，并且          [x:=v]y = v。  所以我们真正需要展示的是          如果
    empty ⊢ v : U，则 Γ ⊢ v : U。          我们已经证明了一个更一般的定理，称为上下文不变性。*)'
- en: subst.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。
- en: inversion H[1]; subst. clear H[1].
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 H[1]；替换。清除 H[1]。
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [上下文不变性](MoreStlc.html#STLCExtended.context_invariance)...
- en: intros x Hcontra.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 对 x Hcontra 进行介绍。
- en: destruct ([free_in_context](MoreStlc.html#STLCExtended.free_in_context) _ _
    S [empty](Maps.html#empty) Hcontra)
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ([free_in_context](MoreStlc.html#STLCExtended.free_in_context) _ _ S [empty](Maps.html#empty)
    Hcontra) 破坏
- en: as [T' HT']...
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [T' HT'] 所示...
- en: inversion HT'.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HT'。
- en: + (* x<>y *)
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x<>y *)
- en: '(* If x ≠ y, then Γ y = Some S and the substitution has no        effect.  We can show that Γ
    ⊢ y : S by T_Var. *)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 x ≠ y，那么 Γ y = Some S，替换没有影响。我们可以通过 T_Var 展示        Γ ⊢ y : S。*)'
- en: apply [T_Var](MoreStlc.html#STLCExtended.T_Var)...
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_Var](MoreStlc.html#STLCExtended.T_Var)...
- en: '- (* tabs *)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tabs *)'
- en: rename i into y. rename t into T[11].
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 将 i 重命名为 y。将 t 重命名为 T[11]。
- en: '(* If t = tabs y T[11] t[0], then we know that          Γ,x:U ⊢ tabs y T[11]
    t[0] : T[11]→T[12]          Γ,x:U,y:T[11] ⊢ t[0] : T[12]          empty ⊢ v :
    U        As our IH, we know that forall S Gamma,          Γ,x:U ⊢ t[0] : S → Γ
    ⊢ [x:=v]t[0] : S.        We can calculate that          x:=vt = tabs y T[11] (if beq_id x y then t[0] else x:=vt[0])
           And we must show that Γ ⊢ [x:=v]t : T[11]→T[12].  We know        we will do so using T_Abs, so it remains to be shown that:
             Γ,y:T[11] ⊢ if beq_id x y then t[0] else [x:=v]t[0] : T[12]        We consider two cases: x
    = y and x ≠ y.     *)'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 如果 t = tabs y T[11] t[0]，那么我们知道          Γ,x:U ⊢ tabs y T[11] t[0] : T[11]→T[12]
             Γ,x:U,y:T[11] ⊢ t[0] : T[12]          empty ⊢ v : U        根据我们的 IH，我们知道对于所有的
    S 和 Gamma，          Γ,x:U ⊢ t[0] : S → Γ ⊢ [x:=v]t[0] : S。        我们可以计算出          x:=vt = tabs y T[11] (if beq_id x y then t[0] else x:=vt[0])
           我们必须展示 Γ ⊢ [x:=v]t : T[11]→T[12]。  我们知道        我们将使用 T_Abs 来完成，所以我们还需要展示：
             Γ,y:T[11] ⊢ if beq_id x y then t[0] else [x:=v]t[0] : T[12]        我们考虑两种情况：x
    = y 和 x ≠ y。     *)'
- en: apply [T_Abs](MoreStlc.html#STLCExtended.T_Abs)...
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [T_Abs](MoreStlc.html#STLCExtended.T_Abs)...
- en: destruct ([beq_idP](Maps.html#beq_idP) x y) as [Hxy|Hxy].
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ([beq_idP](Maps.html#beq_idP) x y) 分解为 [Hxy|Hxy]。
- en: + (* x=y *)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x=y *)
- en: '(* If x = y, then the substitution has no effect.  Context        invariance shows that Γ,y:U,y:T[11] and Γ,y:T[11] are
           equivalent.  Since the former context shows that         t[0] : T[12], so does the latter. *)'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) y x)...
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y *)
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '(* If x ≠ y, then the IH and context invariance allow           us to show that
               Γ,x:U,y:T[11] ⊢ t[0] : T[12]       =>            Γ,y:T[11],x:U ⊢ t[0]
    : T[12]       =>            Γ,y:T[11] ⊢ [x:=v]t[0] : T[12] *)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt. eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y z) as [Hyz|Hyz]...
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [false_beq_id](Maps.html#false_beq_id)...
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: (* let *)
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tcase *)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: rename i into x[1]. rename i[0] into x[2].
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Case](MoreStlc.html#STLCExtended.T_Case)...
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: + (* left arm *)
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x x[1]) as [Hxx1|Hxx1].
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x = x[1] *)'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) x[1] z)...
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x <> x[1] *)'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt2. eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x[1] z) as [Hx1z|Hx1z]...
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: + (* right arm *)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x x[2]) as [Hxx2|Hxx2].
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x = x[2] *)'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_id](Maps.html#beq_id) x[2] z)...
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x <> x[2] *)'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt3. eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x[2] z)...
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tlcase *)'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: rename i into y[1]. rename i[0] into y[2].
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: eapply [T_Lcase](MoreStlc.html#STLCExtended.T_Lcase)...
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y[1]).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y[1] *)
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: simpl.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y[1] z)...
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y[1] *)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) x y[2]).
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '* (* x=y[2] *)'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: destruct ([beq_idP](Maps.html#beq_idP) y[2] z)...
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_idP](Maps.html#beq_idP) y[2] z)...
- en: '* (* x<>y[2] *)'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* x<>y[2] *)'
- en: apply IHt3. eapply [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHt3。使用 [context_invariance](MoreStlc.html#STLCExtended.context_invariance)...
- en: intros z Hafi. unfold [update](Maps.html#update), [t_update](Maps.html#t_update).
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 对 z 和 Hafi 进行介绍。展开 [update](Maps.html#update)，[t_update](Maps.html#t_update)。
- en: destruct ([beq_idP](Maps.html#beq_idP) y[1] z)...
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_idP](Maps.html#beq_idP) y[1] z)...
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。重写 [false_beq_id](Maps.html#false_beq_id)...
- en: destruct ([beq_idP](Maps.html#beq_idP) y[2] z)...
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 ([beq_idP](Maps.html#beq_idP) y[2] z)...
- en: subst. rewrite [false_beq_id](Maps.html#false_beq_id)...
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。重写 [false_beq_id](Maps.html#false_beq_id)...
- en: Qed.
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE72]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Theorem preservation : ∀t t'' T,'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 定理保持性：∀t t' T，
- en: empty ⊢ t ∈ T  →
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: empty ⊢ t ∈ T  →
- en: t ⇒ t'  →
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: t ⇒ t'  →
- en: empty ⊢ t' ∈ T.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: empty ⊢ t' ∈ T。
- en: Proof with eauto.
  id: totrans-720
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明使用 eauto。
- en: intros t t' T HT.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t t' T HT 进行介绍。
- en: '(* Theorem: If empty ⊢ t : T and t ⇒ t'', then       empty ⊢ t'' : T. *)'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 定理：如果 empty ⊢ t : T 并且 t ⇒ t''，那么 empty ⊢ t'' : T。*)'
- en: remember [empty](Maps.html#empty) as Γ. generalize dependent HeqGamma.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 [empty](Maps.html#empty) 作为 Γ。推广依赖于 HeqGamma。
- en: generalize dependent t'.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 推广依赖于 t'。
- en: (* Proof: By induction on the given typing derivation.  Many       cases are contradictory (T_Var, T_Abs).  We show just 
         the interesting ones. *)
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: (* 证明：通过对给定的类型推导进行归纳。许多情况是矛盾的（T_Var，T_Abs）。我们只展示有趣的情况。*)
- en: induction HT;
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HT 进行归纳；
- en: intros t' HeqGamma HE; subst; inversion HE; subst...
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t' 进行介绍 HeqGamma HE；替换；反演 HE；替换...
- en: '- (* T_App *)'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_App *)'
- en: (* If the last rule used was T_App, then t = t[1] t[2], and         three rules could have been used to show t
    ⇒ t':         ST_App1, ST_App2, and ST_AppAbs. In the first two         cases, the result follows directly from the IH. *)
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: (* 如果最后使用的规则是 T_App，则 t = t[1] t[2]，并且有三个规则可以用来展示 t ⇒ t'：ST_App1，ST_App2 和 ST_AppAbs。在前两种情况下，结果直接由
    IH 得出。*)
- en: inversion HE; subst...
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HE；替换...
- en: + (* ST_AppAbs *)
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: + (* ST_AppAbs *)
- en: '(* For the third case, suppose            t[1] = tabs x T[11] t[12]          and
               t[2] = v[2].          We must show that empty ⊢ [x:=v[2]]t[12] : T[2].
             We know by assumption that              empty ⊢ tabs x T[11] t[12] :
    T[1]→T[2]          and by inversion              x:T[1] ⊢ t[12] : T[2]          We have already proven that substitution preserves 
             typing, and              empty ⊢ v[2] : T[1]          by assumption, so we are done. *)'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 对于第三种情况，假设            t[1] = tabs x T[11] t[12]          并且            t[2]
    = v[2]。          我们必须展示 empty ⊢ [x:=v[2]]t[12] : T[2]。          我们知道根据假设              empty
    ⊢ tabs x T[11] t[12] : T[1]→T[2]          并且根据反演              x:T[1] ⊢ t[12] :
    T[2]          我们已经证明了替换保持          类型，并且              empty ⊢ v[2] : T[1]          根据假设，所以我们完成了。*)'
- en: apply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    with T[1]...
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    与 T[1]...
- en: inversion HT[1]...
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HT[1] 进行反演...
- en: (* fst and snd *)
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: (* fst 和 snd *)
- en: (* FILL IN HERE *)
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *)
- en: (* let *)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: (* let *)
- en: (* FILL IN HERE *)
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *)
- en: (* T_Case *)
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: (* T_Case *)
- en: '- (* ST_CaseInl *)'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* ST_CaseInl *)'
- en: inversion HT[1]; subst.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HT[1] 进行反演；替换。
- en: eapply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)...
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)...
- en: '- (* ST_CaseInr *)'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* ST_CaseInr *)'
- en: inversion HT[1]; subst.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HT[1] 进行反演；替换。
- en: eapply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)...
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)...
- en: '- (* T_Lcase *)'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* T_Lcase *)'
- en: + (* ST_LcaseCons *)
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: + (* ST_LcaseCons *)
- en: inversion HT[1]; subst.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HT[1] 进行反演；替换。
- en: apply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    with ([TList](MoreStlc.html#STLCExtended.TList) T[1])...
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    与 ([TList](MoreStlc.html#STLCExtended.TList) T[1])...
- en: apply [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    with T[1]...
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [substitution_preserves_typing](MoreStlc.html#STLCExtended.substitution_preserves_typing)
    与 T[1]...
- en: (* fix *)
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: (* fix *)
- en: (* FILL IN HERE *) Qed.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 完成。
- en: End STLCExtended.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 STLCExtended。
- en: '[PRE73]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: (* $Date: 2016-12-17 23:53:20 -0500 (Sat, 17 Dec 2016) $ *)
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: (* $Date: 2016-12-17 23:53:20 -0500 (Sat, 17 Dec 2016) $ *)
- en: '[PRE74]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
