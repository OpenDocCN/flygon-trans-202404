- en: The "Dependency cycles" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common complaints about F# is that it requires code to be in
    *dependency order*. That is, you cannot use forward references to code that hasn't
    been seen by the compiler yet.
  prefs: []
  type: TYPE_NORMAL
- en: In this series, I discuss dependency cycles, why they are bad, and how to get
    rid of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Cyclic dependencies are evil](cyclic-dependencies.html). Cyclic dependencies:
    Part 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Refactoring to remove cyclic dependencies](removing-cyclic-dependencies.html).
    Cyclic dependencies: Part 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Cycles and modularity in the wild](cycles-and-modularity-in-the-wild.html).
    Comparing some real-world metrics of C# and F# projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyclic dependencies are evil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cyclic dependencies are evil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*One of three related posts on [module organization](recipe-part3.html) and
    [cyclic dependencies](removing-cyclic-dependencies.html).*'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common complaints about F# is that it requires code to be in
    *dependency order*. That is, you cannot use forward references to code that hasn't
    been seen by the compiler yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The order of .fs files makes it hard to compile... My F# application is just
    over 50 lines of code, but it''s already more work than it''s worth to compile
    even the tiniest non-trivial application. Is there a way to make the F# compiler
    more like the C# compiler, so that it''s not so tightly coupled to the order that
    files are passed to the compiler?" [[fpish.net]](http://fpish.net/topic/None/57578)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'and another:'
  prefs: []
  type: TYPE_NORMAL
- en: '"After trying to build a slightly above-toy-size project in F#, I came to the
    conclusion that with current tools it would be quite difficult to maintain a project
    of even moderate complexity." [[www.ikriv.com]](http://www.ikriv.com/blog/?p=28)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'and another:'
  prefs: []
  type: TYPE_NORMAL
- en: '"F# compiler [is] too linear. The F# compiler should handle all type resolution
    matters automatically, independent of declaration order" [[www.sturmnet.org]](http://www.sturmnet.org/blog/2008/05/20/f-compiler-considered-too-linear)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'and one more:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The topic of annoying (and IMHO unnecessary) limitations of the F# project
    system was already discussed on this forum. I am talking about the way compilation
    order is controlled" [[fpish.net]](http://fpish.net/topic/Some/0/59219)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Well, these complaints are unfounded. You most certainly can build and maintain
    large projects using F#. The F# compiler and the core library are two obvious
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, most of these problems boil down to "why can't F# be like C#". If you
    are coming from C#, you are used to having the compiler connect everything automatically.
    Having to deal with dependency relationships explicitly is very annoying -- old-fashioned
    and regressive, even.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this post is to explain (a) why dependency management is important,
    and (b) some techniques that can help you deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are bad things...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We all know that dependencies are the bane of our existence. Assembly dependencies,
    configuration dependencies, database dependencies, network dependencies -- there's
    always something.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we developers, as a profession, tend to put a lot of effort into making
    dependencies more manageable. This goal manifests itself in many disparate ways:
    the [interface segregation principle](http://en.wikipedia.org/wiki/Interface_segregation_principle),
    inversion of control and [dependency injection](http://en.wikipedia.org/wiki/Dependency_inversion_principle);
    package management with NuGet; configuration management with puppet/chef; and
    so on. In some sense all these approaches are trying to reduce the number of things
    we have to be aware of, and the number of things that can break.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not a new problem, of course. A large part of the classic book "[Large-Scale
    C++ Software Design](http://www.amazon.com/Large-Scale-Software-Design-John-Lakos/dp/0201633620)"
    is devoted to dependency management. As John Lakos, the author, put it:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The maintenance cost of a subsystem can be reduced significantly by avoiding
    unnecessary dependencies among components"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key word here is "unnecessary". What is an "unnecessary" dependency? It
    depends, of course. But one particular kind of dependency is almost always unnecessary
    -- a **circular dependency**.
  prefs: []
  type: TYPE_NORMAL
- en: '... and circular dependencies are evil'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand why circular dependencies are evil, let's revisit what we mean
    by a "component".
  prefs: []
  type: TYPE_NORMAL
- en: Components are Good Things. Whether you think of them as packages, assemblies,
    modules, classes or whatever, their primary purpose is to break up large amounts
    of code into smaller and more manageable pieces. In other words, we are applying
    a divide and conquer approach to the problem of software development.
  prefs: []
  type: TYPE_NORMAL
- en: But in order to be useful for maintenance, deployment, or whatever, a component
    shouldn't just be a random collection of stuff. It should (of course) group only
    *related code* together.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, each component would thus be completely independent of any
    others. But generally (of course), some dependencies are always necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, now that we have components with *dependencies*, we need a way to manage
    these dependencies. One standard way to do this is with the "layering" principle.
    We can have "high level" layers and "low level" layers, and the critical rule
    is: *each layer should depend only on layers below it, and never on a layer above
    it*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You are very familiar with this, I''m sure. Here''s a diagram of some simple
    layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Layering1.png)'
  prefs: []
  type: TYPE_IMG
- en: But now what happens when you introduce a dependency from the bottom layer to
    the top layer, like this?
  prefs: []
  type: TYPE_NORMAL
- en: '![](Layering2.png)'
  prefs: []
  type: TYPE_IMG
- en: By having a dependency from the bottom to the top, we have introduced the evil
    "circular dependency".
  prefs: []
  type: TYPE_NORMAL
- en: Why is it evil? Because *any* alternative layering method is now valid!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could put the bottom layer on top instead, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Layering3.png)'
  prefs: []
  type: TYPE_IMG
- en: From a logical point of view, this alternative layering is just the same as
    the original layering.
  prefs: []
  type: TYPE_NORMAL
- en: Or how about we put the middle layer on top?
  prefs: []
  type: TYPE_NORMAL
- en: '![](Layering3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Something has gone badly wrong! It's clear that we've really messed things up.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, as soon as you have any kind of circular dependency between components,
    the *only* thing you can do is to put them *all* into the *same* layer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Layering4.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words, the circular dependency has completely destroyed our "divide
    and conquer" approach, the whole reason for having components in the first place.
    Rather than having three components, we now have just one "super component", which
    is three times bigger and more complicated than it needed to be.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Layering5.png)'
  prefs: []
  type: TYPE_IMG
- en: And that's why circular dependencies are evil.
  prefs: []
  type: TYPE_NORMAL
- en: '*For more on this subject, see this [StackOverflow answer](http://stackoverflow.com/a/1948636/1136133)
    and [this article about layering](http://codebetter.com/patricksmacchia/2008/02/10/layering-the-level-metric-and-the-discourse-of-method/)
    by Patrick Smacchia (of NDepend).*'
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependencies in the real world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by looking at circular dependencies between .NET assemblies. Here
    are some war stories from Brian McNamara (my emphasis):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The .Net Framework 2.0 has this problem in spades; System.dll, System.Configuration.dll,
    and System.Xml.dll are all hopelessly entangled with one another. This manifests
    in a variety of ugly ways. For example, I found a simple [bug] in the VS debugger
    that effectively crashes the debuggee when hitting a breakpoint while trying to
    loads symbols, caused by the circular dependencies among these assemblies. Another
    story: a friend of mine was a developer on the initial versions of Silverlight
    and was tasked with trying to trim down these three assemblies, and the first
    arduous task was trying to untangle the circular dependencies. **"Mutual recursion
    for free" is very convenient on a small scale, but it will destroy you on a large
    scale.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: VS2008 shipped a week later than planned, because VS2008 had a dependency on
    SQL server, and SQL server had a dependency on VS, and whoops! in the end they
    couldn't produce a full product version where everything had the same build number,
    and had to scramble to make it work. [[fpish.net]](http://fpish.net/topic/None/59219#comment-70220)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So there is plenty of evidence that circular dependencies between assemblies
    are bad. In fact, circular dependencies between assemblies are considered bad
    enough that Visual Studio won't even let you create them!
  prefs: []
  type: TYPE_NORMAL
- en: You might say, "Yes, I can understand why circular dependencies are bad for
    assemblies, but why bother for code inside an assembly?"
  prefs: []
  type: TYPE_NORMAL
- en: Well, for exactly the same reasons! Layering allows better partitioning, easier
    testing and cleaner refactoring. You can see what I mean in a [related post on
    dependency cycles "in the wild"](cycles-and-modularity-in-the-wild.html) where
    I compare C# projects and F# projects. The dependencies in the F# projects are
    a lot less spaghetti-like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another quote from Brian''s (excellent) comment:'
  prefs: []
  type: TYPE_NORMAL
- en: I'm evangelizing an unpopular position here, but my experience is that everything
    in the world is better when you're forced to consider and manage "dependency order
    among software components" at every level of the system. The specific UI/tooling
    for F# may not yet be ideal, but I think the principle is right. This is a burden
    you want. It *is* more work. "Unit testing" is also more work, but we've gotten
    to the point where the consensus is that work is "worth it" in that it saves you
    time in the long run. I feel the same way about 'ordering'. There are dependencies
    among the classes and methods in your system. You ignore those dependencies at
    your own peril. A system that forces you to consider this dependency graph (roughly,
    the topological sort of components) is likely to steer you into developing software
    with cleaner architectures, better system layering, and fewer needless dependencies.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Detecting and removing circular dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ok, we're agreed that circular dependencies are bad. So how do we detect them
    and then get rid of them?
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with detection. There are a number of tools to help you detect circular
    dependencies in your code.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using C#, you will need a tool like the invaluable [NDepend](http://www.ndepend.com/features.aspx#DependencyCycle).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And if you are using Java, there are equivalent tools such as [JDepend](http://www.clarkware.com/software/JDepend.html#cycles).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But if you are using F#, you're in luck! You get circular dependency detection
    for free!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Very funny," you might say, "I already know about F#''s circular dependency
    prohibition -- it''s driving me nuts! What can I do to fix the problem and make
    the compiler happy?"'
  prefs: []
  type: TYPE_NORMAL
- en: For that, you'll need to read the [next post](removing-cyclic-dependencies.html)...
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to remove cyclic dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring to remove cyclic dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous post, we looked at the concept of dependency cycles, and why
    they are bad.
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll look at some techniques for eliminating them from your code.
    Having to do this may seem annoying at first, but really, you'll come to appreciate
    that in the long run, "it's not a bug, it's a feature!"
  prefs: []
  type: TYPE_NORMAL
- en: Classifying some common cyclic dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's classify the kinds of dependencies you're likely to run into. I'll look
    at three common situations, and for each one, demonstrate some techniques for
    dealing with them.
  prefs: []
  type: TYPE_NORMAL
- en: First, there is what I will call a *"method dependency"*.
  prefs: []
  type: TYPE_NORMAL
- en: Type A stores a value of type B in a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type B references type A in a method signature, but doesn't store a value of
    type A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, there is what I will call a *"structural dependency"*.
  prefs: []
  type: TYPE_NORMAL
- en: Type A stores a value of type B in a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type B stores a value of type A in a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is what I will call an *"inheritance dependency"*.
  prefs: []
  type: TYPE_NORMAL
- en: Type A stores a value of type B in a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type B inherits from type A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are, of course, other variants. But if you know how to deal with these,
    you can use the same techniques to deal with the others as well.
  prefs: []
  type: TYPE_NORMAL
- en: Three tips on dealing with dependencies in F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started, here are three useful tips which apply generally when
    trying to untangle dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip 1: Treat F# like F#**.'
  prefs: []
  type: TYPE_NORMAL
- en: Recognize that F# is not C#. If you are willing to work with F# using its native
    idioms, then it is normally very straightforward to avoid circular dependencies
    by using a different style of [code organization](recipe-part3.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip 2: Separate types from behavior**.'
  prefs: []
  type: TYPE_NORMAL
- en: Since most types in F# are immutable, it is acceptable for them to be "exposed"
    and ["anemic"](http://www.martinfowler.com/bliki/AnemicDomainModel.html), even.
    So in a functional design it is common to separate the types themselves from the
    functions that act on them. This approach will often help to clean up dependencies,
    as we'll see below.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip 3: Parameterize, parameterize, parameterize**.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies can only happen when a specific type is referenced. If you use
    generic types, you cannot have a dependency!
  prefs: []
  type: TYPE_NORMAL
- en: And rather than hard coding behavior for a type, why not parameterize it by
    passing in functions instead? The `List` module is a great example of this approach,
    and I'll show some examples below as well.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with a "method dependency"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start with the simplest kind of dependency -- what I will call a "method
    dependency".
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Customer` class has a property/field of type `CustomerObserver`, but the
    `CustomerObserver` class has a method which takes a `Customer` as a parameter,
    causing a mutual dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Using the "and" keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One straightforward way to get the types to compile is to use the `and` keyword,
    as I did above.
  prefs: []
  type: TYPE_NORMAL
- en: The `and` keyword is designed for just this situation -- it allows you to have
    two or more types that refer to each other.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, just replace the second `type` keyword with `and`. Note that using
    `and type`, as shown below, is incorrect. Just the single `and` is all you need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But `and` has a number of problems, and using it is generally discouraged except
    as a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: First, it only works for types declared in the same module. You can't use it
    across module boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it should really only be used for tiny types. If you have 500 lines
    of code between the `type` and the `and`, then you are doing something very wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet shown above is an example of how *not* to do it.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, don't treat `and` as a panacea. Overusing it is a symptom that
    you have not refactored your code properly.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing parameterization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, instead of using `and`, let's see what we can do using parameterization,
    as mentioned in the third tip.
  prefs: []
  type: TYPE_NORMAL
- en: If we think about the example code, do we *really* need a special `CustomerObserver`
    class? Why have we restricted it to `Customer` only? Can't we have a more generic
    observer class?
  prefs: []
  type: TYPE_NORMAL
- en: So why don't we create a `INameObserver<'T>` interface instead, with the same
    `OnNameChanged` method, but the method (and interface) parameterized to accept
    any class?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this revised version, the dependency has been broken! No `and` is needed
    at all. In fact, you could even put the types in different projects or assemblies
    now!
  prefs: []
  type: TYPE_NORMAL
- en: The code is almost identical to the first version, except that the `Customer`
    constructor accepts a interface, and `CustomerObserver` now implements the same
    interface. In fact, I would argue that introducing the interface has actually
    made the code better than before.
  prefs: []
  type: TYPE_NORMAL
- en: But we don't have to stop there. Now that we have an interface, do we really
    need to create a whole class just to implement it? F# has a great feature called
    [object expressions](http://msdn.microsoft.com/en-us/library/dd233237.aspx) which
    allows you to instantiate an interface directly.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the same code again, but this time the `CustomerObserver` class has
    been eliminated completely and the `INameObserver` created directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique will obviously work for more complex interfaces as well, such
    as that shown below, where there are two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using functions instead of parameterization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many cases, we can go even further and eliminate the interface class as
    well. Why not just pass in a simple function that is called when the name changes,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I think you''ll agree that this snippet is "lower ceremony" than either of
    the previous versions. The observer is now defined inline as needed, very simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: True, it only works when the interface being replaced is simple, but even so,
    this approach can be used more often than you might think.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more functional approach: separating types from functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I mentioned above, a more "functional design" would be to separate the types
    themselves from the functions that act on those types. Let's see how this might
    be done in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a first pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the example above, we now have *three* modules: one for the types, and one
    each for the functions. Obviously, in a real application, there will be a lot
    more Customer related functions in the `Customer` module than just this one!'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, though, we still have the mutual dependency between `Customer`
    and `CustomerObserver`. The type definitions are more compact, so it is not such
    a problem, but even so, can we eliminate the `and`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, of course. We can use the same trick as in the previous approach, eliminating
    the observer type and embedding a function directly in the `Customer` data structure,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Making types dumber
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Customer` type still has some behavior embedded in it. In many cases, there
    is no need for this. A more functional approach would be to pass a function only
    when you need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s remove the `observer` from the customer type, and pass it as an extra
    parameter to the `changeName` function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You might be thinking that I have made things more complicated now -- I have
    to specify the `observer` function everywhere I call `changeName` in my code.
    Surely this is worse than before? At least in the OO version, the observer was
    part of the customer object and I didn't have to keep passing it in.
  prefs: []
  type: TYPE_NORMAL
- en: Ah, but, you're forgetting the magic of [partial application](partial-application.html)!
    You can set up a function with the observer "baked in", and then use *that* function
    everywhere, without needing to pass in an observer every time you use it. Clever!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But wait... there's more!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s look at the `changeName` function again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: do something to make a result value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: call the observer with the result value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: return the result value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is completely generic logic -- it has nothing to do with customers at all.
    So we can rewrite it as a completely generic library function. Our new function
    will allow *any* observer function to "hook into" into the result of *any* other
    function, so let's call it `hook` for now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, I called it `hook2` because the function `f` being "hooked into"
    has two parameters. I could make another version for functions that have one parameter,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you have read the [railway oriented programming post](recipe-part2.html),
    you might notice that this is quite similar to what I called a "dead-end" function.
    I won't go into more details here, but this is indeed a common pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, back to the code -- how do we use this generic `hook` function?
  prefs: []
  type: TYPE_NORMAL
- en: '`Customer.changeName` is the function being hooked into, and it has two parameters,
    so we use `hook2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer function is just as before
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, again, we create a partially applied `changeName` function, but this time
    we create it by passing the observer and the hooked function to `hook2`, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the resulting `changeName` has *exactly the same signature* as the
    original `Customer.changeName` function, so it can be used interchangably with
    it anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating a `hook` function like this might seem to add extra complication initially,
    but it has eliminated yet more code from the main application, and once you have
    built up a library of functions like this, you will find uses for them everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if it helps you to use OO design terminology, you can think of this
    approach as a "Decorator" or "Proxy" pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with a "structural dependency"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second of our classifications is what I am calling a "structural dependency",
    where each type stores a value of the other type.
  prefs: []
  type: TYPE_NORMAL
- en: Type A stores a value of type B in a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type B stores a value of type A in a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this set of examples, consider an `Employee` who works at a `Location`.
    The `Employee` contains the `Location` they work at, and the `Location` stores
    a list of `Employees` who work there.
  prefs: []
  type: TYPE_NORMAL
- en: Voila -- mutual dependency!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the example in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Before we get on to refactoring, let's consider how awkward this design is.
    How can we initialize an `Employee` value without having a `Location` value, and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s one attempt. We create a location with an empty list of employees,
    and then create other employees using that location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: But this code doesn't work as we want. We have to set the list of employees
    for `location` as empty because we can't forward reference the `alice` and `bob`
    values..
  prefs: []
  type: TYPE_NORMAL
- en: F# will sometimes allow you to use the `and` keyword in these situation too,
    for recursive "lets". Just as with "type", the "and" keyword replaces the "let"
    keyword. Unlike "type", the first "let" has to be marked as recursive with `let
    rec`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it. We will give `location` a list of `alice` and `bob` even though
    they are not declared yet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But no, the compiler is not happy about the infinite recursion that we have
    created. In some cases, `and` does indeed work for `let` definitions, but this
    is not one of them! And anyway, just as for types, having to use `and` for "let"
    definitions is a clue that you might need to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, really, the only sensible solution is to use mutable structures, and to
    fix up the location object *after* the individual employees have been created,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, a lot of trouble just to create some values. This is another reason why
    mutual dependencies are a bad idea!
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing again
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To break the dependency, we can use the parameterization trick again. We can
    just create a parameterized vesion of `Employee`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we create a type alias for `Employee`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: One nice thing about creating an alias like that is that the original code for
    creating employees will continue to work unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Parameterizing with behavior dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code above assumes that the particular class being parameterized over is
    not important. But what if there are dependencies on particular properties of
    the type?
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that the `Employee` class expects a `Name` property,
    and the `Location` class expects an `Age` property, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How can we possibly parameterize this?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, let''s try using the same approach as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `Location` is happy with `ParameterizedEmployee.Age`, but `location.Name`
    fails to compile. obviously, because the type parameter is too generic.
  prefs: []
  type: TYPE_NORMAL
- en: One way would be to fix this by creating interfaces such as `ILocation` and
    `IEmployee`, and that might often be the most sensible approach.
  prefs: []
  type: TYPE_NORMAL
- en: But another way is to let the Location parameter be generic and pass in an *additional
    function* that knows how to handle it. In this case a `getLocationName` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: One way of thinking about this is that we are providing the behavior externally,
    rather than as part of the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this then, we need to pass in a function along with the type parameter.
    This would be annoying to do all the time, so naturally we will wrap it in a function,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, the original test code continues to work, almost unchanged
    (we have to change `new Employee` to just `Employee`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The functional approach: separating types from functions again'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's apply the functional design approach to this problem, just as we did
    before.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we'll separate the types themselves from the functions that act on those
    types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Before we go any further, let's remove some unneeded code. One nice thing about
    using a record type is that you don't need to define "getters", so the only functions
    you need in the modules are functions that manipulate the data, such as `AverageAge`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Parameterizing again
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again, we can remove the dependency by creating a parameterized version
    of the types.
  prefs: []
  type: TYPE_NORMAL
- en: Let's step back and think about the "location" concept. Why does a location
    have to only contain Employees? If we make it a bit more generic, we could consider
    a location as being a "place" plus "a list of things at that place".
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the things are products, then a place full of products might
    be a warehouse. If the things are books, then a place full of books might be a
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are these concepts expressed in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Of course, these locations are not exactly the same, but there might be something
    in common that you can extract into a generic design, especially as there is no
    behavior requirement attached to the things they contain.
  prefs: []
  type: TYPE_NORMAL
- en: So, using the "location of things" design, here is our dependency rewritten
    to use parameterized types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this revised design you will see that the `AverageAge` function has been
    completely removed from the `Location` module. There is really no need for it,
    because we can do these kinds of calculations quite well "inline" without needing
    the overhead of special functions.
  prefs: []
  type: TYPE_NORMAL
- en: And if you think about it, if we *did* need to have such a function pre-defined,
    it would probably be more appropriate to put in the `Employee` module rather than
    the `Location` module. After all, the functionality is much more related to how
    employees work than how locations work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is one advantage of modules over classes; you can mix and match functions
    with different types, as long as they are all related to the underlying use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Moving relationships into distinct types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the examples so far, the "list of things" field in location has had to be
    mutable. How can we work with immutable types and still support relationships?
  prefs: []
  type: TYPE_NORMAL
- en: Well one way *not* to do it is to have the kind of mutual dependency we have
    seen. In that design, synchronization (or lack of) is a terrible problem
  prefs: []
  type: TYPE_NORMAL
- en: For example, I could change Alice's location without telling the location she
    points to, resulting in an inconsistency. But if I tried to change the contents
    of the location as well, then I would also need to update the value of Bob as
    well. And so on, ad infinitum. A nightmare, basically.
  prefs: []
  type: TYPE_NORMAL
- en: The correct way to do this with immutable data is steal a leaf from database
    design, and extract the relationship into a separate "table" or type in our case.
    The current relationships are held in a single master list, and so when changes
    are made, no synchronization is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a very crude example, using a simple list of `Relationship`s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Or course, a more efficient design would use dictionaries/maps, or special in-memory
    structures designed for this kind of thing.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let's look at an "inheritance dependency".
  prefs: []
  type: TYPE_NORMAL
- en: Type A stores a value of type B in a property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type B inherits from type A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll consider a UI control hierarchy, where every control belongs to a top-level
    "Form", and the Form itself is a Control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a first pass at an implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The thing to note here is that the Form passes itself in as the `form` value
    for the Control constructor.
  prefs: []
  type: TYPE_NORMAL
- en: This code will compile, but will cause a `NullReferenceException` error at runtime.
    This kind of technique will work in C#, but not in F#, because the class initialization
    logic is done differently.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, this is a terrible design. The form shouldn't have to pass itself in
    to a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: A better design, which also fixes the constructor error, is to make `Control`
    an abstract class instead, and distinguish between non-form child classes (which
    do take a form in their constructor) and the `Form` class itself, which doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Our old friend parameterization again
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To remove the circular dependency, we can parameterize the classes in the usual
    way, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A functional version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I will leave a functional design as an exercise for you to do yourself.
  prefs: []
  type: TYPE_NORMAL
- en: If we were going for truly functional design, we probably would not be using
    inheritance at all. Instead, we would use composition in conjunction with parameterization.
  prefs: []
  type: TYPE_NORMAL
- en: But that's a big topic, so I'll save it for another day.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I hope that this post has given you some useful tips on removing dependency
    cycles. With these various approaches in hand, any problems with [module organization](recipe-part3.html)
    should be able to be resolved easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the next post in this series, I'll look at dependency cycles "in the wild",
    by comparing some real world C# and F# projects.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, F# is a very opinionated language! It wants us to use modules
    instead of classes and it prohibits dependency cycles. Are these just annoyances,
    or do they really make a difference to the way that code is organized? [Read on
    and find out!](cycles-and-modularity-in-the-wild.html)
  prefs: []
  type: TYPE_NORMAL
- en: Cycles and modularity in the wild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cycles and modularity in the wild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (*Updated 2013-06-15\. See comments at the end of the post*)
  prefs: []
  type: TYPE_NORMAL
- en: (*Updated 2014-04-12\. A [follow up post](roslyn-vs-fsharp-compiler.md) that
    applies the same analysis to Roslyn*)
  prefs: []
  type: TYPE_NORMAL
- en: (*Updated 2015-01-23\. A much clearer version of this analysis [has been done
    by Evelina Gabasova](http://evelinag.com/blog/2014/06-09-comparing-dependency-networks/).
    She knows what she is talking about, so I highly recommend you read her post first!*)
  prefs: []
  type: TYPE_NORMAL
- en: This is a follow up post to two earlier posts on [module organization](recipe-part3.html)
    and [cyclic dependencies](cyclic-dependencies.html).
  prefs: []
  type: TYPE_NORMAL
- en: I thought it would be interesting to look at some real projects written in C#
    and F#, and see how they compare in modularity and number of cyclic dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My plan was to take ten or so projects written in C# and ten or so projects
    written in F#, and somehow compare them.
  prefs: []
  type: TYPE_NORMAL
- en: I didn't want to spend too much time on this, and so rather than trying to analyze
    the source files, I thought I would cheat a little and analyze the compiled assemblies,
    using the [Mono.Cecil](http://www.mono-project.com/Cecil) library.
  prefs: []
  type: TYPE_NORMAL
- en: This also meant that I could get the binaries directly, using NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The projects I picked were:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C# projects*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mono.Cecil](http://nuget.org/packages/Mono.Cecil/), which inspects programs
    and libraries in the ECMA CIL format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NUnit](http://nuget.org/packages/NUnit/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SignalR](http://nuget.org/packages/Microsoft.AspNet.SignalR/) for real-time
    web functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NancyFx](http://nuget.org/packages/Nancy/), a web framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[YamlDotNet](http://nuget.org/packages/YamlDotNet.Core/), for parsing and emitting
    YAML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SpecFlow](http://nuget.org/packages/SpecFlow/), a BDD tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Json.NET](http://nuget.org/packages/Newtonsoft.Json/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Entity Framework](http://nuget.org/packages/EntityFramework/5.0.0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ELMAH](http://nuget.org/packages/elmah/), a logging framework for ASP.NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NuGet](http://nuget.org/packages/Nuget.Core/) itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Moq](http://nuget.org/packages/Moq/), a mocking framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NDepend](http://ndepend.com), a code analysis tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, to show I'm being fair, a business application that I wrote in C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F# projects*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there is not yet a wide variety of F# projects to choose from.
    I picked the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[FSharp.Core](http://nuget.org/packages/FSharp.Core/), the core F# library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FSPowerPack](http://nuget.org/packages/FSPowerPack.Community/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FsUnit](http://nuget.org/packages/FsUnit/), extensions for NUnit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Canopy](http://nuget.org/packages/canopy/), a wrapper around the Selenium
    test automation tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FsSql](http://nuget.org/packages/FsSql/), a nice little ADO.NET wrapper.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[WebSharper](http://nuget.org/packages/WebSharper/2.4.85.235), the web framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TickSpec](http://nuget.org/packages/TickSpec/), a BDD tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FSharpx](http://nuget.org/packages/FSharpx.Core/), an F# library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FParsec](http://nuget.org/packages/FParsec/), a parser library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FsYaml](http://nuget.org/packages/FsYaml/), a YAML library built on FParsec.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Storm](http://storm.codeplex.com/releases/view/18871), a tool for testing
    web services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Foq](http://nuget.org/packages/Foq/), a mocking framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another business application that I wrote, this time in F#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I did choose SpecFlow and TickSpec as being directly comparable, and also Moq
    and and Foq.
  prefs: []
  type: TYPE_NORMAL
- en: But as you can see, most of the F# projects are not directly comparable to the
    C# ones. For example, there is no direct F# equivalent to Nancy, or Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, I was hoping that I might observe some sort of pattern by comparing
    the projects. And I was right. Read on for the results!
  prefs: []
  type: TYPE_NORMAL
- en: What metrics to use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I wanted to examine two things: "modularity" and "cyclic dependencies".'
  prefs: []
  type: TYPE_NORMAL
- en: First, what should be the unit of "modularity"?
  prefs: []
  type: TYPE_NORMAL
- en: From a coding point of view, we generally work with files ([Smalltalk being
    a notable exception](http://stackoverflow.com/questions/3561145/what-is-a-smalltalk-image)),
    and so it makes sense to think of the *file* as the unit of modularity. A file
    is used to group related items together, and if two chunks of code are in different
    files, they are somehow not as "related" as if they were in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, the best practice is to have one class per file. So 20 files means 20
    classes. Sometimes classes have nested classes, but with rare exceptions, the
    nested class is in the same file as the parent class. This means that we can ignore
    them and just use top-level classes as our unit of modularity, as a proxy for
    files.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, the best practice is to have one *module* per file (or sometimes more).
    So 20 files means 20 modules. Behind the scenes, modules are turned into static
    classes, and any classes defined within the module are turned into nested classes.
    So again, this means that we can ignore nested classes and just use top-level
    classes as our unit of modularity.
  prefs: []
  type: TYPE_NORMAL
- en: The C# and F# compilers generate many "hidden" types, for things such as LINQ,
    lambdas, etc. In some cases, I wanted to exclude these, and only include "authored"
    types, which have been coded for explicitly. I also excluded the case classes
    generated by F# discriminated unions from being "authored" classes as well. That
    means that a union type with three cases will be counted as one authored type
    rather than four.
  prefs: []
  type: TYPE_NORMAL
- en: 'So my definition of a *top-level type* is: a type that is not nested and which
    is not compiler generated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The metrics I chose for modularity were:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The number of top-level types** as defined above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of authored types** as defined above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of all types**. This number would include the compiler generated
    types as well. Comparing this number to the top-level types gives us some idea
    of how representative the top-level types are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The size of the project**. Obviously, there will be more types in a larger
    project, so we need to make adjustments based on the size of the project. The
    size metric I picked was the number of instructions, rather than the physical
    size of the file. This eliminates issues with embedded resources, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have our units of modularity, we can look at dependencies between modules.
  prefs: []
  type: TYPE_NORMAL
- en: For this analysis, I only want to include dependencies between types in the
    same assembly. In other words, dependencies on system types such as `String` or
    `List` do not count as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a top-level type `A` and another top-level type `B`. Then
    I say that a *dependency* exists from `A` to `B` if:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `A` or any of its nested types inherits from (or implements) type `B` or
    any of its nested types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type `A` or any of its nested types has a field, property or method that references
    type `B` or any of its nested types as a parameter or return value. This includes
    private members as well -- after all, it is still a dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type `A` or any of its nested types has a method implementation that references
    type `B` or any of its nested types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This might not be a perfect definition. But it is good enough for my purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to all dependencies, I thought it might be useful to look at "public"
    or "published" dependencies. A *public dependency* from `A` to `B` exists if:'
  prefs: []
  type: TYPE_NORMAL
- en: Type `A` or any of its nested types inherits from (or implements) type `B` or
    any of its nested types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type `A` or any of its nested types has a *public* field, property or method
    that references type `B` or any of its nested types as a parameter or return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a public dependency is only counted if the source type itself is public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The metrics I chose for dependencies were:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The total number of dependencies**. This is simply the sum of all dependencies
    of all types. Again, there will be more dependencies in a larger project, but
    we will also take the size of the project into account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The number of types that have more than X dependencies**. This gives us an
    idea of how many types are "too" complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyclic dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given this definition of dependency, then, a *cyclic dependency* occurs when
    two different top-level types depend on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note what *not* included in this definition. If a nested type in a module depends
    on another nested type in the *same* module, then that is not a cyclic dependency.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a cyclic dependency, then there is a set of modules that are all
    linked together. For example, if `A` depends on `B`, `B` depends on `C`, and then
    say, `C` depends on `A`, then `A`, `B` and `C` are linked together. In graph theory,
    this is called a *strongly connected component*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The metrics I chose for cyclic dependencies were:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The number of cycles**. That is, the number of strongly connected components
    which had more than one module in them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The size of the largest component**. This gives us an idea of how complex
    the dependencies are.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I analyzed cyclic dependencies for all dependencies and also for public dependencies
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Doing the experiment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, I downloaded each of the project binaries using NuGet. Then I wrote
    a little F# script that did the following steps for each assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzed the assembly using [Mono.Cecil](http://www.mono-project.com/Cecil)
    and extracted all the types, including the nested types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each type, extracted the public and implementation references to other types,
    divided into internal (same assembly) and external (different assembly).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Created a list of the "top level" types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Created a dependency list from each top level type to other top level types,
    based on the lower level dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This dependency list was then used to extract various statistics, shown below.
    I also rendered the dependency graphs to SVG format (using [graphViz](http://www.graphviz.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: For cycle detection, I used the [QuickGraph library](http://quickgraph.codeplex.com/)
    to extract the strongly connected components, and then did some more processing
    and rendering.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the gory details, here is [a link to the script](https://gist.github.com/swlaschin/5742974)
    that I used, and [here is the raw data](https://gist.github.com/swlaschin/5742994).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to recognize that this is *not* a proper statistical study,
    just a quick analysis. However the results are quite interesting, as we shall
    see.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at the modularity first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the modularity-related results for the C# projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Project | Code size | Top-level types | Authored types | All types | Code/Top
    | Code/Auth | Code/All | Auth/Top | All/Top |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ef | 269521 | 514 | 565 | 876 | 524 | 477 | 308 | 1.1 | 1.7 |'
  prefs: []
  type: TYPE_TB
- en: '| jsonDotNet | 148829 | 215 | 232 | 283 | 692 | 642 | 526 | 1.1 | 1.3 |'
  prefs: []
  type: TYPE_TB
- en: '| nancy | 143445 | 339 | 366 | 560 | 423 | 392 | 256 | 1.1 | 1.7 |'
  prefs: []
  type: TYPE_TB
- en: '| cecil | 101121 | 240 | 245 | 247 | 421 | 413 | 409 | 1.0 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| nuget | 114856 | 216 | 237 | 381 | 532 | 485 | 301 | 1.1 | 1.8 |'
  prefs: []
  type: TYPE_TB
- en: '| signalR | 65513 | 192 | 229 | 311 | 341 | 286 | 211 | 1.2 | 1.6 |'
  prefs: []
  type: TYPE_TB
- en: '| nunit | 45023 | 173 | 195 | 197 | 260 | 231 | 229 | 1.1 | 1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| specFlow | 46065 | 242 | 287 | 331 | 190 | 161 | 139 | 1.2 | 1.4 |'
  prefs: []
  type: TYPE_TB
- en: '| elmah | 43855 | 116 | 140 | 141 | 378 | 313 | 311 | 1.2 | 1.2 |'
  prefs: []
  type: TYPE_TB
- en: '| yamlDotNet | 23499 | 70 | 73 | 73 | 336 | 322 | 322 | 1.0 | 1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fparsecCS | 57474 | 41 | 92 | 93 | 1402 | 625 | 618 | 2.2 | 2.3 |'
  prefs: []
  type: TYPE_TB
- en: '| moq | 133189 | 397 | 420 | 533 | 335 | 317 | 250 | 1.1 | 1.3 |'
  prefs: []
  type: TYPE_TB
- en: '| ndepend | 478508 | 734 | 828 | 843 | 652 | 578 | 568 | 1.1 | 1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| ndependPlat | 151625 | 185 | 205 | 205 | 820 | 740 | 740 | 1.1 | 1.1 |'
  prefs: []
  type: TYPE_TB
- en: '| personalCS | 422147 | 195 | 278 | 346 | 2165 | 1519 | 1220 | 1.4 | 1.8 |'
  prefs: []
  type: TYPE_TB
- en: '| TOTAL | 2244670 | 3869 | 4392 | 5420 | 580 | 511 | 414 | 1.1 | 1.4 |'
  prefs: []
  type: TYPE_TB
- en: 'And here are the results for the F# projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Project | Code size | Top-level types | Authored types | All types | Code/Top
    | Code/Auth | Code/All | Auth/Top | All/Top |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fsxCore | 339596 | 173 | 328 | 2024 | 1963 | 1035 | 168 | 1.9 | 11.7 |'
  prefs: []
  type: TYPE_TB
- en: '| fsCore | 226830 | 154 | 313 | 1186 | 1473 | 725 | 191 | 2.0 | 7.7 |'
  prefs: []
  type: TYPE_TB
- en: '| fsPowerPack | 117581 | 93 | 150 | 410 | 1264 | 784 | 287 | 1.6 | 4.4 |'
  prefs: []
  type: TYPE_TB
- en: '| storm | 73595 | 67 | 70 | 405 | 1098 | 1051 | 182 | 1.0 | 6.0 |'
  prefs: []
  type: TYPE_TB
- en: '| fParsec | 67252 | 8 | 24 | 245 | 8407 | 2802 | 274 | 3.0 | 30.6 |'
  prefs: []
  type: TYPE_TB
- en: '| websharper | 47391 | 52 | 128 | 285 | 911 | 370 | 166 | 2.5 | 5.5 |'
  prefs: []
  type: TYPE_TB
- en: '| tickSpec | 30797 | 34 | 49 | 170 | 906 | 629 | 181 | 1.4 | 5.0 |'
  prefs: []
  type: TYPE_TB
- en: '| websharperHtml | 14787 | 18 | 28 | 72 | 822 | 528 | 205 | 1.6 | 4.0 |'
  prefs: []
  type: TYPE_TB
- en: '| canopy | 15105 | 6 | 16 | 103 | 2518 | 944 | 147 | 2.7 | 17.2 |'
  prefs: []
  type: TYPE_TB
- en: '| fsYaml | 15191 | 7 | 11 | 160 | 2170 | 1381 | 95 | 1.6 | 22.9 |'
  prefs: []
  type: TYPE_TB
- en: '| fsSql | 15434 | 13 | 18 | 162 | 1187 | 857 | 95 | 1.4 | 12.5 |'
  prefs: []
  type: TYPE_TB
- en: '| fsUnit | 1848 | 2 | 3 | 7 | 924 | 616 | 264 | 1.5 | 3.5 |'
  prefs: []
  type: TYPE_TB
- en: '| foq | 26957 | 35 | 48 | 103 | 770 | 562 | 262 | 1.4 | 2.9 |'
  prefs: []
  type: TYPE_TB
- en: '| personalFS | 118893 | 30 | 146 | 655 | 3963 | 814 | 182 | 4.9 | 21.8 |'
  prefs: []
  type: TYPE_TB
- en: '| TOTAL | 1111257 | 692 | 1332 | 5987 | 1606 | 834 | 186 | 1.9 | 8.7 |'
  prefs: []
  type: TYPE_TB
- en: 'The columns are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code size** is the number of CIL instructions from all methods, as reported
    by Cecil.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Top-level types** is the total number of top-level types in the assembly,
    using the definition above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authored types** is the total number of types in the assembly, including
    nested types, enums, and so on, but excluding compiler generated types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All types** is the total number of types in the assembly, including compiler
    generated types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I have extended these core metrics with some extra calculated columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code/Top** is the number of CIL instructions per top level type / module.
    This is a measure of how much code is associated with each unit of modularity.
    Generally, more is better, because you don''t want to have to deal with multiple
    files if you don''t have too. On the other hand, there is a trade off. Too many
    lines of code in a file makes reading the code impossible. In both C# and F#,
    good practice is not to have more than 500-1000 lines of code per file, and with
    a few exceptions, that seems to be the case in the source code that I looked at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code/Auth** is the number of CIL instructions per authored type. This is
    a measure of how "big" each authored type is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code/All** is the number of CIL instructions per type. This is a measure
    of how "big" each type is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auth/Top** is the ratio of all authored types to the top-level-types. It
    is a rough measure of how many authored types are in each unit of modularity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All/Top** is the ratio of all types to the top-level-types. It is a rough
    measure of how many types are in each unit of modularity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing I noticed is that, with a few exceptions, the code size is bigger
    for the C# projects than for the F# projects. Partly that is because I picked
    bigger projects, of course. But even for a somewhat comparable project like SpecFlow
    vs. TickSpec, the SpecFlow code size is bigger. It may well be that SpecFlow does
    a lot more than TickSpec, of course, but it also may be a result of using more
    generic code in F#. There is not enough information to know either way right now
    -- it would be interesting to do a true side by side comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the number of top-level types. I said earlier that this should correspond
    to the number of files in a project. Does it?
  prefs: []
  type: TYPE_NORMAL
- en: I didn't get all the sources for all the projects to do a thorough check, but
    I did a couple of spot checks. For example, for Nancy, there are 339 top level
    classes, which implies that there should be about 339 files. In fact, there are
    actually 322 .cs files, so not a bad estimate.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, for SpecFlow there are 242 top level types, but only 171
    .cs files, so a bit of an overestimate there. And for Cecil, the same thing: 240
    top level classes but only 128 .cs files.'
  prefs: []
  type: TYPE_NORMAL
- en: For the FSharpX project, there are 173 top level classes, which implies there
    should be about 173 files. In fact, there are actually only 78 .fs files, so it
    is a serious over-estimate by a factor of more than 2\. And if we look at Storm,
    there are 67 top level classes. In fact, there are actually only 35 .fs files,
    so again it is an over-estimate by a factor of 2\.
  prefs: []
  type: TYPE_NORMAL
- en: So it looks like the number of top level classes is always an over-estimate
    of the number of files, but much more so for F# than for C#. It would be worth
    doing some more detailed analysis in this area.
  prefs: []
  type: TYPE_NORMAL
- en: Ratio of code size to number of top-level types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The "Code/Top" ratio is consistently bigger for F# code than for C# code. Overall,
    the average top-level type in C# is converted into 580 instructions. But for F#
    that number is 1606 instructions, about three times as many.
  prefs: []
  type: TYPE_NORMAL
- en: I expect that this is because F# code is more concise than C# code. I would
    guess that 500 lines of F# code in a single module would create many more CIL
    instructions than 500 lines of C# code in a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we visually plot "Code size" vs. "Top-level types", we get this chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Metrics_CodeSize_TopLevel.png)'
  prefs: []
  type: TYPE_IMG
- en: What's surprising to me is how distinct the F# and C# projects are in this chart.
    The C# projects seem to have a consistent ratio of about 1-2 top-level types per
    1000 instructions, even across different project sizes. And the F# projects are
    consistent too, having a ratio of about 0.6 top-level types per 1000 instructions.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the number of top level types in F# projects seems to taper off as
    projects get larger, rather than increasing linearly like the C# projects.
  prefs: []
  type: TYPE_NORMAL
- en: The message I get from this chart is that, for a given size of project, an F#
    implementation will have fewer modules, and presumably less complexity as a result.
  prefs: []
  type: TYPE_NORMAL
- en: You probably noticed that there are two anomalies. Two C# projects are out of
    place -- the one at the 50K mark is FParsecCS and the one at the 425K mark is
    my business application.
  prefs: []
  type: TYPE_NORMAL
- en: I am fairly certain that this because both these implementations have some rather
    large C# classes in them, which helps the code ratio. Probably a necessarily evil
    for a parser, but in the case of my business application, I know that it is due
    to cruft accumulating over the years, and there are some massive classes that
    ought to be refactored into smaller ones. So a metric like this is probably a
    *bad* sign for a C# code base.
  prefs: []
  type: TYPE_NORMAL
- en: Ratio of code size to number of all types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the other hand, if we compare the ratio of code to all types, including compiler
    generated ones, we get a very different result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the corresponding chart of "Code size" vs. "All types":'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Metrics_CodeSize_AllTypes.png)'
  prefs: []
  type: TYPE_IMG
- en: This is surprisingly linear for F#. The total number of types (including compiler
    generated ones) seems to depend closely on the size of the project. On the other
    hand, the number of types for C# seems to vary a lot.
  prefs: []
  type: TYPE_NORMAL
- en: The average "size" of a type is somewhat smaller for F# code than for C# code.
    The average type in C# is converted into about 400 instructions. But for F# that
    number is about 180 instructions.
  prefs: []
  type: TYPE_NORMAL
- en: I'm not sure why this is. Is it because the F# types are more fine-grained,
    or could it be because the F# compiler generates many more little types than the
    C# compiler? Without doing a more subtle analysis, I can't tell.
  prefs: []
  type: TYPE_NORMAL
- en: Ratio of top-level types to authored types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having compared the type counts to the code size, let''s now compare them to
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Metrics_TopLevel_AuthTypes.png)'
  prefs: []
  type: TYPE_IMG
- en: Again, there is a significant difference. For each unit of modularity in C#
    there are an average of 1.1 authored types. But in F# the average is 1.9, and
    for some projects a lot more than that.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, creating nested types is trivial in F#, and quite uncommon in C#,
    so you could argue that this is not a fair comparison. But surely the ability
    to create [a dozen types in as many lines](conciseness-type-definitions.html)
    of F# has some effect on the quality of the design? This is harder to do in C#,
    but there is nothing to stop you. So might this not mean that there is a temptation
    in C# to not be as fine-grained as you could potentially be?
  prefs: []
  type: TYPE_NORMAL
- en: The project with the highest ratio (4.9) is my F# business application. I believe
    that this is due to this being only F# project in this list which is designed
    around a specific business domain, I created many "little" types to model the
    domain accurately, using the concepts [described here](designing-with-types.html).
    For other projects created using DDD principles, I would expect to see this same
    high number.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's look at the dependency relationships between the top level classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results for the C# projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Project | Top Level Types | Total Dep. Count | Dep/Top | One or more dep.
    | Three or more dep. | Five or more dep. | Ten or more dep. | Diagram |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ef | 514 | 2354 | 4.6 | 76% | 51% | 32% | 13% | [svg](../assets/svg/ef.all.dot.svg) [dotfile](../assets/svg/ef.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| jsonDotNet | 215 | 913 | 4.2 | 69% | 42% | 30% | 14% | [svg](../assets/svg/jsonDotNet.all.dot.svg) [dotfile](../assets/svg/jsonDotNet.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| nancy | 339 | 1132 | 3.3 | 78% | 41% | 22% | 6% | [svg](../assets/svg/nancy.all.dot.svg) [dotfile](../assets/svg/nancy.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| cecil | 240 | 1145 | 4.8 | 73% | 43% | 23% | 13% | [svg](../assets/svg/cecil.all.dot.svg) [dotfile](../assets/svg/cecil.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| nuget | 216 | 833 | 3.9 | 71% | 43% | 26% | 12% | [svg](../assets/svg/nuget.all.dot.svg) [dotfile](../assets/svg/nuget.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| signalR | 192 | 641 | 3.3 | 66% | 34% | 19% | 10% | [svg](../assets/svg/signalR.all.dot.svg) [dotfile](../assets/svg/signalR.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| nunit | 173 | 499 | 2.9 | 75% | 39% | 13% | 4% | [svg](../assets/svg/nunit.all.dot.svg) [dotfile](../assets/svg/nunit.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| specFlow | 242 | 578 | 2.4 | 64% | 25% | 17% | 5% | [svg](specFlow.all.dot.svg) [dotfile](../assets/svg/specFlow.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| elmah | 116 | 300 | 2.6 | 72% | 28% | 22% | 6% | [svg](../assets/svg/elmah.all.dot.svg) [dotfile](../assets/svg/elmah.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| yamlDotNet | 70 | 228 | 3.3 | 83% | 30% | 11% | 4% | [svg](../assets/svg/yamlDotNet.all.dot.svg) [dotfile](../assets/svg/yamlDotNet.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fparsecCS | 41 | 64 | 1.6 | 59% | 29% | 5% | 0% | [svg](../assets/svg/fparsecCS.all.dot.svg) [dotfile](../assets/svg/fparsecCS.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| moq | 397 | 1100 | 2.8 | 63% | 29% | 17% | 7% | [svg](../assets/svg/moq.all.dot.svg) [dotfile](../assets/svg/moq.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ndepend | 734 | 2426 | 3.3 | 67% | 37% | 25% | 10% | [svg](../assets/svg/ndepend.all.dot.svg) [dotfile](../assets/svg/ndepend.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ndependPlat | 185 | 404 | 2.2 | 67% | 24% | 11% | 4% | [svg](../assets/svg/ndependPlat.all.dot.svg) [dotfile](../assets/svg/ndependPlat.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| personalCS | 195 | 532 | 2.7 | 69% | 29% | 19% | 7% |  |'
  prefs: []
  type: TYPE_TB
- en: '| TOTAL | 3869 | 13149 | 3.4 | 70% | 37% | 22% | 9% |  |'
  prefs: []
  type: TYPE_TB
- en: 'And here are the results for the F# projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Project | Top Level Types | Total Dep. Count | Dep/Top | One or more dep.
    | Three or more dep. | Five or more dep. | Ten or more dep. | Diagram |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fsxCore | 173 | 76 | 0.4 | 30% | 4% | 1% | 0% | [svg](../assets/svg/fsxCore.all.dot.svg) [dotfile](../assets/svg/fsxCore.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fsCore | 154 | 287 | 1.9 | 55% | 26% | 14% | 3% | [svg](../assets/svg/fsCore.all.dot.svg) [dotfile](../assets/svg/fsCore.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fsPowerPack | 93 | 68 | 0.7 | 38% | 13% | 2% | 0% | [svg](../assets/svg/fsPowerPack.all.dot.svg) [dotfile](../assets/svg/fsPowerPack.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| storm | 67 | 195 | 2.9 | 72% | 40% | 18% | 4% | [svg](../assets/svg/storm.all.dot.svg) [dotfile](../assets/svg/storm.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fParsec | 8 | 9 | 1.1 | 63% | 25% | 0% | 0% | [svg](../assets/svg/fParsec.all.dot.svg) [dotfile](../assets/svg/fParsec.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| websharper | 52 | 18 | 0.3 | 31% | 0% | 0% | 0% | [svg](../assets/svg/websharper.all.dot.svg) [dotfile](../assets/svg/websharper.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| tickSpec | 34 | 48 | 1.4 | 50% | 15% | 9% | 3% | [svg](tickSpec.all.dot.svg) [dotfile](../assets/svg/tickSpec.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| websharperHtml | 18 | 37 | 2.1 | 78% | 39% | 6% | 0% | [svg](../assets/svg/websharperHtml.all.dot.svg) [dotfile](../assets/svg/websharperHtml.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| canopy | 6 | 8 | 1.3 | 50% | 33% | 0% | 0% | [svg](../assets/svg/canopy.all.dot.svg) [dotfile](../assets/svg/canopy.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fsYaml | 7 | 10 | 1.4 | 71% | 14% | 0% | 0% | [svg](../assets/svg/fsYaml.all.dot.svg) [dotfile](../assets/svg/fsYaml.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fsSql | 13 | 14 | 1.1 | 54% | 8% | 8% | 0% | [svg](../assets/svg/fsSql.all.dot.svg) [dotfile](../assets/svg/fsSql.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fsUnit | 2 | 0 | 0.0 | 0% | 0% | 0% | 0% | [svg](../assets/svg/fsUnit.all.dot.svg) [dotfile](../assets/svg/fsUnit.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| foq | 35 | 66 | 1.9 | 66% | 29% | 11% | 0% | [svg](../assets/svg/foq.all.dot.svg) [dotfile](../assets/svg/foq.all.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| personalFS | 30 | 111 | 3.7 | 93% | 60% | 27% | 7% |  |'
  prefs: []
  type: TYPE_TB
- en: '| TOTAL | 692 | 947 | 1.4 | 49% | 19% | 8% | 1% |  |'
  prefs: []
  type: TYPE_TB
- en: 'The columns are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-level types** is the total number of top-level types in the assembly,
    as before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total dep. count** is the total number of dependencies between top level
    types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dep/Top** is the number of dependencies per top level type / module only.
    This is a measure of how many dependencies the average top level type/module has.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One or more dep** is the number of top level types that have dependencies
    on one or more other top level types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three or more dep**. Similar to above, but with dependencies on three or
    more other top level types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Five or more dep**. Similar to above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ten or more dep**. Similar to above. Top level types with this many dependencies
    will be harder to understand and maintain. So this is measure of how complex the
    project is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **diagram** column contains a link to a SVG file, generated from the dependencies,
    and also the [DOT file](http://www.graphviz.org/) that was used to generate the
    SVG. See below for a discussion of these diagrams. (Note that I can't expose the
    internals of my applications, so I will just give the metrics)
  prefs: []
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These results are very interesting. For C#, the number of total dependencies
    increases with project size. Each top-level type depends on 3-4 others, on average.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the number of total dependencies in an F# project does not
    seem to vary too much with project size at all. Each F# module depends on no more
    than 1-2 others, on average. And the largest project (FSharpX) has a lower ratio
    than many of the smaller projects. My business app and the Storm project are the
    only exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a chart of the relationship between code size and the number of dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Metrics_CodeSize_Dependencies.png)'
  prefs: []
  type: TYPE_IMG
- en: The disparity between C# and F# projects is very clear. The C# dependencies
    seem to grow linearly with project size, while the F# dependencies seem to be
    flat.
  prefs: []
  type: TYPE_NORMAL
- en: Distribution of dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The average number of dependencies per top level type is interesting, but it
    doesn't help us understand the variability. Are there many modules with lots of
    dependencies? Or does each one just have a few?
  prefs: []
  type: TYPE_NORMAL
- en: This might make a difference in maintainability, perhaps. I would assume that
    a module with only one or two dependencies would be easier to understand in the
    context of the application that one with tens of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than doing a sophisticated statistical analysis, I thought I would keep
    it simple and just count how many top level types had one or more dependencies,
    three or more dependencies, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the same results, displayed visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Metrics_CS_DependencyPercent.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Metrics_FS_DependencyPercent.png)'
  prefs: []
  type: TYPE_IMG
- en: So, what can we deduce from these numbers?
  prefs: []
  type: TYPE_NORMAL
- en: First, in the F# projects, more than half of the modules have no outside dependencies
    *at all*. This is a bit surprising, but I think it is due to the heavy use of
    generics compared with C# projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the modules in the F# projects consistently have fewer dependencies
    than the classes in the C# projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, in the F# projects, modules with a high number of dependencies are
    quite rare -- less than 2% overall. But in the C# projects, 9% of classes have
    more than 10 dependencies on other classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The worst offender in the F# group is my very own F# application, which is even
    worse than my C# application with respect to these metrics. Again, it might be
    due to heavy use of non-generics in the form of domain-specific types, or it might
    just be that the code needs more refactoring!
  prefs: []
  type: TYPE_NORMAL
- en: The dependency diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It might be useful to look at the dependency diagrams now. These are SVG files,
    so you should be able to view them in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note that most of these diagrams are very big -- so after you open them you
    will need to zoom out quite a bit in order to see anything!
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by comparing the diagrams for [SpecFlow](specFlow.all.dot.svg) and
    [TickSpec](tickSpec.all.dot.svg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the one for SpecFlow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](specflow_svg.png)](specFlow.all.dot.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the one for TickSpec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![](tickspec_svg.png)](tickSpec.all.dot.svg)'
  prefs: []
  type: TYPE_NORMAL
- en: Each diagram lists all the top-level types found in the project. If there is
    a dependency from one type to another, it is shown by an arrow. The dependencies
    point from left to right where possible, so any arrows going from right to left
    implies that there is a cyclic dependency.
  prefs: []
  type: TYPE_NORMAL
- en: The layout is done automatically by graphviz, but in general, the types are
    organized into columns or "ranks". For example, the SpecFlow diagram has 12 ranks,
    and the TickSpec diagram has five.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are generally a lot of tangled lines in a typical dependency
    diagram! How tangled the diagram looks is a sort of visual measure of the code
    complexity. For instance, if I was tasked to maintain the SpecFlow project, I
    wouldn't really feel comfortable until I had understood all the relationships
    between the classes. And the more complex the project, the longer it takes to
    come up to speed.
  prefs: []
  type: TYPE_NORMAL
- en: OO vs functional design revealed?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The TickSpec diagram is a lot simpler than the SpecFlow one. Is that because
    TickSpec perhaps doesn't do as much as SpecFlow?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no, I don't think that it has anything to do with the size of
    the feature set at all, but rather because the code is organized differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the SpecFlow classes ([dotfile](../assets/svg/specFlow.all.dot)),
    we can see it follows good OOD and TDD practices by creating interfaces. There''s
    a `TestRunnerManager` and an `ITestRunnerManager`, for example. And there are
    many other patterns that commonly crop up in OOD: "listener" classes and interfaces,
    "provider" classes and interfaces, "comparer" classes and interfaces, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: But if we look at the TickSpec modules ([dotfile](../assets/svg/tickSpec.all.dot))
    there are no interfaces at all. And no "listeners", "providers" or "comparers"
    either. There might well be a need for such things in the code, but either they
    are not exposed outside their module, or more likely, the role they play is fulfilled
    by functions rather than types.
  prefs: []
  type: TYPE_NORMAL
- en: I'm not picking on the SpecFlow code, by the way. It seems well designed, and
    is a very useful library, but I think it does highlight some of the differences
    between OO design and functional design.
  prefs: []
  type: TYPE_NORMAL
- en: Moq compared with Foq
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's also compare the diagrams for [Moq](../assets/svg/moq.all.dot.svg) and
    [Foq](../assets/svg/foq.all.dot.svg). These two projects do roughly the same thing,
    so the code should be comparable.
  prefs: []
  type: TYPE_NORMAL
- en: As before, the project written in F# has a much smaller dependency diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the Moq classes ([dotfile](../assets/svg/moq.all.dot)), we can see
    it includes the "Castle" library, which I didn't eliminate from the analysis.
    Out of the 249 classes with dependencies, only 66 are Moq specific. If we had
    considered only the classes in the Moq namespace, we might have had a cleaner
    diagram.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, looking at the Foq modules ([dotfile](../assets/svg/foq.all.dot))
    there are only 23 modules with dependencies, fewer even than just the Moq classes
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: So something is very different with code organization in F#.
  prefs: []
  type: TYPE_NORMAL
- en: FParsec compared with FParsecCS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FParsec project is an interesting natural experiment. The project has two
    assemblies, roughly the same size, but one is written in C# and the other in F#.
  prefs: []
  type: TYPE_NORMAL
- en: It is a bit unfair to compare them directly, because the C# code is designed
    for parsing fast, while the F# code is more high level. But... I'm going to be
    unfair and compare them anyway!
  prefs: []
  type: TYPE_NORMAL
- en: Here are the diagrams for the F# assembly ["FParsec"](../assets/svg/fParsec.all.dot.svg)
    and C# assembly ["FParsecCS"](../assets/svg/fparsecCS.all.dot.svg).
  prefs: []
  type: TYPE_NORMAL
- en: They are both nice and clear. Lovely code!
  prefs: []
  type: TYPE_NORMAL
- en: What's not clear from the diagram is that my methodology is being unfair to
    the C# assembly.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the C# diagram shows that there are dependencies between `Operator`,
    `OperatorType`, `InfixOperator` and so on. But in fact, looking at the source
    code, these classes are all in the same physical file. In F#, they would all be
    in the same module, and their relationships would not count as public dependencies.
    So the C# code is being penalized in a way.
  prefs: []
  type: TYPE_NORMAL
- en: Even so, looking at the source code, the C# code has 20 source files compared
    to F#'s 8, so there is still some difference in complexity.
  prefs: []
  type: TYPE_NORMAL
- en: What counts as a dependency?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In defence of my method though, the only thing that is keeping these FParsec
    C# classes together in the same file is good coding practice; it is not enforced
    by the C# compiler. Another maintainer could come along and unwittingly separate
    them into different files, which really *would* increase the complexity. In F#
    you could not do that so easily, and certainly not accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: So it depends on what you mean by "module", and "dependency". In my view, a
    module contains things that really are "joined at the hip" and shouldn't easily
    be decoupled. Hence dependencies within a module don't count, while dependencies
    between modules do.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think about it is that F# encourages high coupling in some areas
    (modules) in exchange for low coupling in others. In C#, the only kind of strict
    coupling available is class-based. Anything looser, such as using namespaces,
    has to be enforced using good practices or a tool such as NDepend.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the F# approach is better or worse depends on your preference. It does
    make certain kinds of refactoring harder as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclic dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we can turn our attention to the oh-so-evil cyclic dependencies. (If
    you want to know why they are bad, [read this post](cyclic-dependencies.html)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Here are the cyclic dependency results for the C# projects.
  prefs: []
  type: TYPE_NORMAL
- en: '| Project | Top-level types | Cycle count | Partic. | Partic.% | Max comp.
    size | Cycle count (public) | Partic. (public) | Partic.% (public) | Max comp.
    size (public) | Diagram |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ef | 514 | 14 | 123 | 24% | 79 | 1 | 7 | 1% | 7 | [svg](../assets/svg/ef.all.cycles.dot.svg) [dotfile](../assets/svg/ef.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| jsonDotNet | 215 | 3 | 88 | 41% | 83 | 1 | 11 | 5% | 11 | [svg](../assets/svg/jsonDotNet.all.cycles.dot.svg) [dotfile](../assets/svg/jsonDotNet.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| nancy | 339 | 6 | 35 | 10% | 21 | 2 | 4 | 1% | 2 | [svg](../assets/svg/nancy.all.cycles.dot.svg) [dotfile](../assets/svg/nancy.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| cecil | 240 | 2 | 125 | 52% | 123 | 1 | 50 | 21% | 50 | [svg](../assets/svg/cecil.all.cycles.dot.svg) [dotfile](../assets/svg/cecil.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| nuget | 216 | 4 | 24 | 11% | 10 | 0 | 0 | 0% | 1 | [svg](../assets/svg/nuget.all.cycles.dot.svg) [dotfile](../assets/svg/nuget.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| signalR | 192 | 3 | 14 | 7% | 7 | 1 | 5 | 3% | 5 | [svg](../assets/svg/signalR.all.cycles.dot.svg) [dotfile](../assets/svg/signalR.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| nunit | 173 | 2 | 80 | 46% | 78 | 1 | 48 | 28% | 48 | [svg](../assets/svg/nunit.all.cycles.dot.svg) [dotfile](../assets/svg/nunit.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| specFlow | 242 | 5 | 11 | 5% | 3 | 1 | 2 | 1% | 2 | [svg](../assets/svg/specFlow.all.cycles.dot.svg) [dotfile](../assets/svg/specFlow.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| elmah | 116 | 2 | 9 | 8% | 5 | 1 | 2 | 2% | 2 | [svg](../assets/svg/elmah.all.cycles.dot.svg) [dotfile](../assets/svg/elmah.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| yamlDotNet | 70 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | [svg](../assets/svg/yamlDotNet.all.cycles.dot.svg) [dotfile](../assets/svg/yamlDotNet.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fparsecCS | 41 | 3 | 6 | 15% | 2 | 1 | 2 | 5% | 2 | [svg](../assets/svg/fparsecCS.all.cycles.dot.svg) [dotfile](../assets/svg/fparsecCS.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| moq | 397 | 9 | 50 | 13% | 15 | 0 | 0 | 0% | 1 | [svg](../assets/svg/moq.all.cycles.dot.svg) [dotfile](../assets/svg/moq.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ndepend | 734 | 12 | 79 | 11% | 22 | 8 | 36 | 5% | 7 | [svg](../assets/svg/ndepend.all.cycles.dot.svg) [dotfile](../assets/svg/ndepend.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ndependPlat | 185 | 2 | 5 | 3% | 3 | 0 | 0 | 0% | 1 | [svg](../assets/svg/ndependPlat.all.cycles.dot.svg) [dotfile](../assets/svg/ndependPlat.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| personalCS | 195 | 11 | 34 | 17% | 8 | 5 | 19 | 10% | 7 | [svg](../assets/svg/personalCS.all.cycles.dot.svg) [dotfile](../assets/svg/personalCS.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| TOTAL | 3869 |  | 683 | 18% |  |  | 186 | 5% |  | [svg](../assets/svg/TOTAL.all.cycles.dot.svg) [dotfile](../assets/svg/TOTAL.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: 'And here are the results for the F# projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Project | Top-level types | Cycle count | Partic. | Partic.% | Max comp.
    size | Cycle count (public) | Partic. (public) | Partic.% (public) | Max comp.
    size (public) | Diagram |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| fsxCore | 173 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| fsCore | 154 | 2 | 5 | 3% | 3 | 0 | 0 | 0% | 1 | [svg](../assets/svg/fsCore.all.cycles.dot.svg) [dotfile](../assets/svg/fsCore.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| fsPowerPack | 93 | 1 | 2 | 2% | 2 | 0 | 0 | 0% | 1 | [svg](../assets/svg/fsPowerPack.all.cycles.dot.svg) [dotfile](../assets/svg/fsPowerPack.all.cycles.dot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| storm | 67 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| fParsec | 8 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| websharper | 52 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 0 | . |'
  prefs: []
  type: TYPE_TB
- en: '| tickSpec | 34 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| websharperHtml | 18 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| canopy | 6 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| fsYaml | 7 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| fsSql | 13 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| fsUnit | 2 | 0 | 0 | 0% | 0 | 0 | 0 | 0% | 0 | . |'
  prefs: []
  type: TYPE_TB
- en: '| foq | 35 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| personalFS | 30 | 0 | 0 | 0% | 1 | 0 | 0 | 0% | 1 | . |'
  prefs: []
  type: TYPE_TB
- en: '| TOTAL | 692 |  | 7 | 1% |  |  | 0 | 0% |  | . |'
  prefs: []
  type: TYPE_TB
- en: 'The columns are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-level types** is the total number of top-level types in the assembly,
    as before.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cycle count** is the number of cycles altogether. Ideally it would be zero.
    But larger is not necessarily worse. Better to have 10 small cycles than one giant
    one, I think.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partic.**. The number of top level types that participate in any cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partic.%**. The number of top level types that participate in any cycle,
    as a percent of all types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max comp. size** is the number of top level types in the largest cyclic component.
    This is a measure of how complex the cycle is. If there are only two mutually
    dependent types, then the cycle is a lot less complex than, say, 123 mutually
    dependent types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**... (public)** columns have the same definitions, but using only public dependencies.
    I thought it would be interesting to see what effect it would have to limit the
    analysis to public dependencies only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **diagram** column contains a link to a SVG file, generated from the dependencies
    in the cycles only, and also the [DOT file](http://www.graphviz.org/) that was
    used to generate the SVG. See below for an analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we are looking for cycles in the F# code, we will be sorely disappointed.
    Only two of the F# projects have cycles at all, and those are tiny. For example
    in FSharp.Core there is a mutual dependency between two types right next to each
    other in the same file, [here](https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/quotations.fs#L146).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, almost all the C# projects have one or more cycles. Entity
    Framework has the most cycles, involving 24% of the classes, and Cecil has the
    worst participation rate, with over half of the classes being involved in a cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Even NDepend has cycles, although to be fair, there may be good reasons for
    this. First NDepend focuses on removing cycles between namespaces, not classes
    so much, and second, it's possible that the cycles are between types declared
    in the same source file. As a result, my method may penalize well-organized C#
    code somewhat (as noted in the FParsec vs. FParsecCS discussion above).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Metrics_TopLevel_Participation.png)'
  prefs: []
  type: TYPE_IMG
- en: Why the difference between C# and F#?
  prefs: []
  type: TYPE_NORMAL
- en: In C#, there is nothing stopping you from creating cycles -- a perfect example
    of accidental complexity. In fact, you have to make [a special effort](http://programmers.stackexchange.com/questions/60549/how-strictly-do-you-follow-the-no-dependency-cycle-rule-ndepend)
    to avoid them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In F#, of course, it is the other way around. You can't easily create cycles
    at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My business applications compared
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more comparison. As part of my day job, I have written a number of business
    applications in C#, and more recently, in F#. Unlike the other projects listed
    here, they are very focused on addressing a particular business need, with lots
    of domain specific code, custom business rules, special cases, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Both projects were produced under deadline, with changing requirements and all
    the usual real world constraints that stop you writing ideal code. Like most developers
    in my position, I would love a chance to tidy them up and refactor them, but they
    do work, the business is happy, and I have to move on to new things.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, let's see how they stack up to each other. I can't reveal any details
    of the code other than the metrics, but I think that should be enough to be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the C# project first:'
  prefs: []
  type: TYPE_NORMAL
- en: It has 195 top level types, about 1 for every 2K of code. Comparing this with
    other C# projects, there should be *many more* top level types than this. And
    in fact, I know that this is true. As with many projects (this one is 6 years
    old) it is lower risk to just add a method to an existing class rather than refactoring
    it, especially under deadline. Keeping old code stable is always a higher priority
    than making it beautiful! The result is that classes grow too large over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flip side of having large classes is that there many fewer cross-class dependencies!
    It has some of the better scores among the C# projects. So it goes to show that
    dependencies aren't the only metric. There has to be a balance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of cyclic dependencies, it's pretty typical for a C# project. There
    are a number of them (11) but the largest involves only 8 classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now let''s look at my F# project:'
  prefs: []
  type: TYPE_NORMAL
- en: It has 30 modules, about 1 for every 4K of code. Comparing this with other F#
    projects, it's not excessive, but perhaps a bit of refactoring is in order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an aside, in my experience with maintaining this code, I have noticed that,
    unlike C# code, I don't feel that I *have* to add cruft to existing modules when
    feature requests come in. Instead, I find that in many cases, the faster and lower
    risk way of making changes is simply to create a *new* module and put all the
    code for a new feature in there. Because the modules have no state, a function
    can live anywhere -- it is not forced to live in the same class. Over time this
    approach may create its own problems too (COBOL anyone?) but right now, I find
    it a breath of fresh air.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The metrics show that there are an unusually large number of "authored" types
    per module (4.9). As I noted above, I think this is a result of having fine-grained
    DDD-style design. The code per authored type is in line with the other F# projects,
    so that implies they are not too big or small.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, as I noted earlier, the inter-module dependencies are the worst of any
    F# project. I know that there are some API/service functions that depend on almost
    all the other modules, but this could be a clue that they might need refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, unlike C# code, I know exactly where to find these problem modules.
    I can be fairly certain that all these modules are in the top layer of my application
    and will thus appear at the bottom of the module list in Visual Studio. How can
    I be so sure? Because...
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of cyclic dependencies, it's pretty typical for a F# project. There
    aren't any.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I started this analysis from curiosity -- was there any meaningful difference
    in the organization of C# and F# projects?
  prefs: []
  type: TYPE_NORMAL
- en: I was quite surprised that the distinction was so clear. Given these metrics,
    you could certainly predict which language the assembly was written in.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project complexity**. For a given number of instructions, a C# project is
    likely to have many more top level types (and hence files) than an F# one -- more
    than double, it seems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fine-grained types**. For a given number of modules, a C# project is likely
    to have fewer authored types than an F# one, implying that the types are not as
    fine-grained as they could be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependencies**. In a C# project, the number of dependencies between classes
    increases linearly with the size of the project. In an F# project, the number
    of dependencies is much smaller and stays relatively flat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cycles**. In a C# project, cycles occur easily unless care is taken to avoid
    them. In an F# project, cycles are extremely rare, and if present, are very small.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps this has do with the competency of the programmer, rather than a difference
    between languages? Well, first of all, I think that the quality of the C# projects
    is quite good on the whole -- I certainly wouldn't claim that I could write better
    code! And, in two cases in particular, the C# and F# projects were written by
    the same person, and differences were still apparent, so I don't think this argument
    holds up.
  prefs: []
  type: TYPE_NORMAL
- en: Future work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This approach of using *just* the binaries might have gone as far as it can
    go. For a more accurate analysis, we would need to use metrics from the source
    code as well (or maybe the pdb file).
  prefs: []
  type: TYPE_NORMAL
- en: For example, a high "instructions per type" metric is good if it corresponds
    to small source files (concise code), but not if it corresponds to large ones
    (bloated classes). Similarly, my definition of modularity used top-level types
    rather than source files, which penalized C# somewhat over F#.
  prefs: []
  type: TYPE_NORMAL
- en: So, I don't claim that this analysis is perfect (and I hope haven't made a terrible
    mistake in the analysis code!) but I think that it could be a useful starting
    point for further investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Update 2013-06-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This post caused quite a bit of interest. Based on feedback, I made the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assemblies profiled**'
  prefs: []
  type: TYPE_NORMAL
- en: Added Foq and Moq (at the request of Phil Trelford).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added the C# component of FParsec (at the request of Dave Thomas and others).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added two NDepend assemblies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added two of my own projects, one C# and one F#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, adding seven new data points (five C# and two F# projects) didn't
    change the overall analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algorithm changes**'
  prefs: []
  type: TYPE_NORMAL
- en: Made definition of "authored" type stricter. Excluded types with "GeneratedCodeAttribute"
    and F# types that are subtypes of a sum type. This had an effect on the F# projects
    and reduced the "Auth/Top" ratio somewhat.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Text changes**'
  prefs: []
  type: TYPE_NORMAL
- en: Rewrote some of the analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed the unfair comparison of YamlDotNet with FParsec.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a comparison of the C# component and F# components of FParsec.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a comparison of Moq and Foq.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a comparison of my own two projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The orginal post is still available [here](../archives/cycles-and-modularity-in-the-wild_20130614.html)
  prefs: []
  type: TYPE_NORMAL
