- en: Local State Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Preview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a quick glance at what we will be going over in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3153baea361d35852ff06442458a01c2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What do you think? Do you have any idea about what this function does?
  prefs: []
  type: TYPE_NORMAL
- en: Withdraw
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s withdraw money from the bank account. We will do this using a procedure
    `withdraw`, which takes as argument an amount to be withdrawn. If there is enough
    money in the account to accommodate the withdrawal, then `withdraw` should return
    the balance remaining after the withdrawal. Otherwise, `withdraw` should return
    the message `"Insufficient funds"`. For example, if we begin with $100 in the
    account, we should obtain the following sequence of responses using `withdraw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Observe that the expression `(withdraw 25)`, evaluated twice, yields different
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '*Wait, but I thought that a particular function call with the same argument
    returns the same value!*'
  prefs: []
  type: TYPE_NORMAL
- en: Up to now it has, but this is a new kind of behavior for a procedure. All our
    procedures could be viewed as functions that pass the vertical line test. A call
    to a procedure computes the value of the function applied to the given arguments,
    and two calls to the same procedure with the same arguments always produces the
    same result. But in this situation, the balance needs to be changed after each
    transaction. Otherwise, we all are going to be rich!
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement `withdraw`, we can use a variable `balance` to indicate the balance
    of money in the account and define `withdraw` as a procedure that accesses balance.
    The withdraw procedure checks to see if balance is at least as large as the requested
    amount. If so, `withdraw` decrements balance by amount and returns the new value
    of balance. Otherwise, `withdraw` returns the Insufficient funds message. Here
    are the definitions of `balance` and `withdraw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Decrementing balance is accomplished by the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This uses the `set!` special form, whose syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here `[name]` is a symbol and `[new-value]` is any expression. `Set!` changes
    `[name]` so that its value is the result obtained by evaluating `[new-value]`.
    In the case at hand, we are changing balance so that its new value will be the
    result of subtracting amount from the previous value of balance.
  prefs: []
  type: TYPE_NORMAL
- en: '`Withdraw` also uses the `begin` special form to cause two expressions to be
    evaluated in the case where the if test is true: first decrementing `balance`
    and then returning the value of `balance`. In general, evaluating the expression'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: causes the expressions `[exp1]` through `[expk]` to be evaluated in sequence
    and the value of the final expression `[expk]` to be returned as the value of
    the entire `begin` form.
  prefs: []
  type: TYPE_NORMAL
- en: Play with `withdraw`, `set!` and `begin` on your STk interpreter!
  prefs: []
  type: TYPE_NORMAL
- en: Something's Fishy...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we move on, examine again how `withdraw` and `balance` are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Do you see anything that could cause a trouble?
  prefs: []
  type: TYPE_NORMAL
- en: Trouble Detected
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem is with the variable `balance`. As specified above, `balance` is
    a name defined in the global environment and is freely accessible to be examined
    or modified by any procedure. It would be much better if we could somehow make
    `balance` **internal** to `withdraw`, so that `withdraw` would be the only procedure
    that could access `balance` directly and any other procedure could access `balance`
    only indirectly (through calls to `withdraw`). This would more accurately model
    the notion that `balance` is a **local state variable** used by `withdraw` to
    keep track of the state of the account.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make `balance` internal to `withdraw` by rewriting the definition as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What we have done here is use `let` to establish an environment with a local
    variable `balance`, bound to the initial value 100\. Within this local environment,
    we use `lambda` to create a procedure that takes `amount` as an argument and behaves
    like our previous `withdraw` procedure. This procedure -- returned as the result
    of evaluating the `let` expression -- is `new- withdraw`, which behaves in precisely
    the same way as `withdraw` but whose variable `balance` is not accessible by any
    other procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Play with `new-withdraw` on the STk interpreter and make sure you understand
    how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '`make-account`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a simplified version of the `make-account` procedure in SICP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try to rewrite this using local state variables. Fill in the blank
    in the following code so that the result works exactly the same as the `make-account`
    procedure above. That is, it responds to the same messages and produces the same
    return values. The differences between the two procedures are that the inside
    of `make-account` above is enclosed in the `let` statement below, and the names
    of the parameters to `make-account` are different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, modify either version of make-account so that, given the message balance,
    it returns the current account balance, and given the message init-balance, it
    returns the amount with which the account was initially created. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Make another modification such that, given the message transactions (any deposit
    or withdrawal), it returns a list of all transactions made since the account was
    opened. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Before viewing the entire solution below, try out your definition in the STk
    interpreter and make sure you understand the entire code for `make-account`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Substitution Model of Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given this definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Follow the [substitution model](http://berkeley-cs61as.github.io/textbook/the-substitution-model-for-procedure-application.html)
    to find the result of computing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That is, show the expression that results from substituting `5` for `var` in
    the body of `plus1`, and then compute the value of the resulting expression.
  prefs: []
  type: TYPE_NORMAL
- en: Now, try it in the STk interpreter. Did you get the same answer? Why or why
    not?
  prefs: []
  type: TYPE_NORMAL
- en: Introducing assignments accompanies a pretty big cost. At this point, you may
    realize that we cannot use the substitution model of evaluation anymore because
    it yields the wrong value. The trouble here is that substitution is based ultimately
    on the notion that the symbols in our language are essentially names for values.
    But as soon as we introduce `set!` and the idea that the value of a variable can
    change, a variable can no longer be simply a name. Now a variable somehow refers
    to a place where a value can be stored, and the value stored at this place can
    change.
  prefs: []
  type: TYPE_NORMAL
- en: '*Then how can I evaluate the procedures?*'
  prefs: []
  type: TYPE_NORMAL
- en: The new model of evaluation is waiting for you in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement local state variables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Costs of assignments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to use `set!` and `begin`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go to the next subsection and learn about the new model of evaluation!
  prefs: []
  type: TYPE_NORMAL
