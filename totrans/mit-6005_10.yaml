- en: 'Reading 10: Debugging'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The topic of today’s class is systematic debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you have no choice but to debug – particularly when the bug is found
    only when you plug the whole system together, or reported by a user after the
    system is deployed, in which case it may be hard to localize it to a particular
    module. For those situations, we can suggest a systematic strategy for more effective
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Reproduce the Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_10_debugging,reproduce_the_bug/yQIl6IjMUt0)'
  prefs: []
  type: TYPE_NORMAL
- en: Start by finding a small, repeatable test case that produces the failure. If
    the bug was found by regression testing, then you’re in luck; you already have
    a failing test case in your test suite. If the bug was reported by a user, it
    may take some effort to reproduce the bug. For graphical user interfaces and multithreaded
    programs, a bug may be hard to reproduce consistently if it depends on timing
    of events or thread execution.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, any effort you put into making the test case small and repeatable
    will pay off, because you’ll have to run it over and over while you search for
    the bug and develop a fix for it. Furthermore, after you’ve successfully fixed
    the bug, you’ll want to add the test case to your regression test suite, so that
    the bug never crops up again. Once you have a test case for the bug, making this
    test work becomes your goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example. Suppose you have written this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A user passes the whole text of Shakespeare’s plays into your method, something
    like `mostCommonWord(allShakespearesPlaysConcatenated)`, and discovers that instead
    of returning a predictably common English word like `"the"` or `"a"`, the method
    returns something unexpected, perhaps `"e"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shakespeare’s plays have 100,000 lines containing over 800,000 words, so this
    input would be very painful to debug by normal methods, like print-debugging and
    breakpoint-debugging. Debugging will be easier if you first work on reducing the
    size of the buggy input to something manageable that still exhibits the same (or
    very similar) bug:'
  prefs: []
  type: TYPE_NORMAL
- en: does the first half of Shakespeare show the same bug? (Binary search! Always
    a good technique. More about this below.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: does a single play have the same bug?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: does a single speech have the same bug?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve found a small test case, find and fix the bug using that smaller
    test case, and then go back to the original buggy input and confirm that you fixed
    the same bug.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reducing a bug to a test case
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a user reports that `mostCommonWord("chicken chicken chicken beef")`
    returns `"beef"` instead of `"chicken"`.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Give all answers that make sense, not just the simplest one (because the simplest
    one sometimes no longer exhibits the bug!)
  prefs: []
  type: TYPE_NORMAL
- en: Regression testing
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you reduce the `"chicken chicken chicken beef"` input down to `"c c
    b"`, which also has a problem. You find a bug, fix it, and observe that both `"c
    c b"` and `"chicken chicken chicken beef"` are now returning the right answer.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Understand the Location and Cause of the Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_10_debugging,understand_the_location_and_cause_of_the_bug/guQ0TiPSo-c)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To localize the bug and its cause, you can use the scientific method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Study the data.** Look at the test input that causes the bug, and the incorrect
    results, failed assertions, and stack traces that result from it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hypothesize.** Propose a hypothesis, consistent with all the data, about
    where the bug might be, or where it *cannot* be. It’s good to make this hypothesis
    general at first.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Experiment.** Devise an experiment that tests your hypothesis. It’s good
    to make the experiment an *observation* at first – a probe that collects information
    but disturbs the system as little as possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Repeat.** Add the data you collected from your experiment to what you knew
    before, and make a fresh hypothesis. Hopefully you have ruled out some possibilities
    and narrowed the set of possible locations and reasons for the bug.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at these steps in the context of the `mostCommonWord()` example,
    fleshed out a little more with three helper methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 1\. Study the Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important form of data is the stack trace from an exception. Practice reading
    the stack traces that you get, because they will give you enormous amounts of
    information about where and what the bug might be.
  prefs: []
  type: TYPE_NORMAL
- en: The process of isolating a small test case may also give you data that you didn’t
    have before. You may even have two related test cases that *bracket* the bug in
    the sense that one succeeds and one fails. For example, maybe `mostCommonWords("c
    c, b")` is broken, but `mostCommonWords("c c b")` is fine.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Hypothesize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![data flowing through the modules of the program](../Images/e60a4d6d78c04ad09dfae667a944e163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It helps to think about your program as modules, or steps in an algorithm, and
    try to rule out whole sections of the program at once.
  prefs: []
  type: TYPE_NORMAL
- en: The flow of data in `mostCommonWord()` is shown at right. If the symptom of
    the bug is an exception in `countOccurrences()`, then you can rule out everything
    downstream, specifically `findMostFrequent()`.
  prefs: []
  type: TYPE_NORMAL
- en: Then you would choose a hypothesis that tries to localize the bug even further.
    You might hypothesize that the bug is in `splitIntoWords()`, corrupting its results,
    which then cause the exception in `countOccurrences()`. You would then use an
    experiment to test that hypothesis. If the hypothesis is true, then you would
    have ruled out `countOccurrences()` as the source of the problem. If it’s false,
    then you would rule out `splitIntoWords()`.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Experiment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A good experiment is a gentle observation of the system without disturbing
    it much. It might be:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a **different test case.** The test case reduction process discussed above
    used test cases as experiments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insert a **print statement** or **assertion** in the running program, to check
    something about its internal state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a **breakpoint** using a debugger, then single-step through the code and
    look at variable and object values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s tempting to try to insert *fixes* to the hypothesized bug, instead of mere
    probes. This is almost always the wrong thing to do. First, it leads to a kind
    of ad-hoc guess-and-test programming, which produces awful, complex, hard-to-understand
    code. Second, your fixes may just mask the true bug without actually removing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you’re getting an `ArrayOutOfBoundsException`, try to understand
    what’s going on first. Don’t just add code that avoids or catches the exception,
    without fixing the real problem.
  prefs: []
  type: TYPE_NORMAL
- en: Other tips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Bug localization by binary search**. Debugging is a search process, and you
    can sometimes use binary search to speed up the process. For example, in `mostCommonWords`,
    the data flows through three helper methods. To do a binary search, you would
    divide this workflow in half, perhaps guessing that the bug is found somewhere
    between the first helper method call and the second, and insert probes (like breakpoints,
    print statements, or assertions) there to check the results. From the answer to
    that experiment, you would further divide in half.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prioritize your hypotheses**. When making your hypothesis, you may want to
    keep in mind that different parts of the system have different likelihoods of
    failure. For example, old, well-tested code is probably more trustworthy than
    recently-added code. Java library code is probably more trustworthy than yours.
    The Java compiler and runtime, operating system platform, and hardware are increasingly
    more trustworthy, because they are more tried and tested. You should trust these
    lower levels until you’ve found good reason not to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Swap components**. If you have another implementation of a module that satisfies
    the same interface, and you suspect the module, then one experiment you can do
    is to try swapping in the alternative. For example, if you suspect your binarySearch()
    implementation, then substitute a simpler linearSearch() instead. If you suspect
    java.util.ArrayList, you could swap in java.util.LinkedList instead. If you suspect
    the Java runtime, run with a different version of Java. If you suspect the operating
    system, run your program on a different OS. If you suspect the hardware, run on
    a different machine. You can waste a lot of time swapping unfailing components,
    however, so don’t do this unless you have good reason to suspect a component.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Make sure your source code and object code are up to date.** Pull the latest
    version from the repository, and delete all your binary files and recompile everything
    (in Eclipse, this is done by Project → Clean).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get help.** It often helps to explain your problem to someone else, even
    if the person you’re talking to has no idea what you’re talking about. Lab assistants
    and fellow 6.005 students usually do know what you’re talking about, so they’re
    even better.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sleep on it.** If you’re too tired, you won’t be an effective debugger. Trade
    latency for efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: Fix the Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve found the bug and understand its cause, the third step is to devise
    a fix for it. Avoid the temptation to slap a patch on it and move on. Ask yourself
    whether the bug was a coding error, like a misspelled variable or interchanged
    method parameters, or a design error, like an underspecified or insufficient interface.
    Design errors may suggest that you step back and revisit your design, or at the
    very least consider all the other clients of the failing interface to see if they
    suffer from the bug too.
  prefs: []
  type: TYPE_NORMAL
- en: Think also whether the bug has any relatives. If I just found a divide-by-zero
    error here, did I do that anywhere else in the code? Try to make the code safe
    from future bugs like this. Also consider what effects your fix will have. Will
    it break any other code?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after you have applied your fix, add the bug’s test case to your regression
    test suite, and run all the tests to assure yourself that (a) the bug is fixed,
    and (b) no new bugs have been introduced.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Debugging strategy
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you are debugging the `quadraticRoots` function, which appears to be
    producing wrong answers sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the following items in the order that you should try them: 1, 2, 3, … Say
    “wat” for items that are nonsense statements.'
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>1</option>,<option>2</option>,<option>3</option>,<option>4</option>,<option>5</option>,<option>wat</option></select>(missing
    answer)<select class="form-control"><option>1</option>,<option>2</option>,<option>3</option>,<option>4</option>,<option>5</option>,<option>wat</option></select>(missing
    answer)<select class="form-control"><option>1</option>,<option>2</option>,<option>3</option>,<option>4</option>,<option>5</option>,<option>wat</option></select>(missing
    answer)<select class="form-control"><option>1</option>,<option>2</option>,<option>3</option>,<option>4</option>,<option>5</option>,<option>wat</option></select>(missing
    answer)<select class="form-control"><option>1</option>,<option>2</option>,<option>3</option>,<option>4</option>,<option>5</option>,<option>wat</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this reading, we looked at how to debug systematically:'
  prefs: []
  type: TYPE_NORMAL
- en: reproduce the bug as a test case, and put it in your regression suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: find the bug using the scientific method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fix the bug thoughtfully, not slapdash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thinking about our three main measures of code quality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs.** We’re trying to prevent them and get rid of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand.** Techniques like static typing, final declarations,
    and assertions are additional documentation of the assumptions in your code. Variable
    scope minimization makes it easier for a reader to understand how the variable
    is used, because there’s less code to look at.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change.** Assertions and static typing document the assumptions
    in an automatically-checkable way, so that when a future programmer changes the
    code, accidental violations of those assumptions are detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
