- en: What is Logic Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Logic Programming?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this course, we stressed that computer science deals with
    imperative (how to) knowledge, whereas mathematics deals with declarative (what
    is) knowledge. Indeed, programming languages require that the programmer express
    knowledge in a form that indicates the step-by-step methods for solving particular
    problems. On the other hand, high-level languages provide, as part of the language
    implementation, a substantial amount of methodological knowledge that frees the
    user from concern with numerous details of how a specified computation will progress.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages, including Lisp, are organized around computing the
    values of mathematical functions. Expression-oriented languages (such as Lisp,
    Fortran, and Algol) capitalize on the "pun" that an expression that describes
    the value of a function may also be interpreted as a means of computing that value.
    Because of this, most programming languages are strongly biased toward unidirectional
    computations (computations with well-defined inputs and outputs). There are, however,
    radically different programming languages that relax this bias. Logic programming
    extends this idea by combining a relational vision of programming with a powerful
    kind of symbolic pattern matching called unification.
  prefs: []
  type: TYPE_NORMAL
- en: This approach, when it works, can be a very powerful way to write programs.
    Part of the power comes from the fact that a single "what is" fact can be used
    to solve a number of different problems that would have different "how to" components.
  prefs: []
  type: TYPE_NORMAL
- en: A Sample Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get into the specifics of logic programming, we need a database to
    play with. You can load this database using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The personnel data base for Microshaft contains assertions about company personnel.
    Here is the information about Ben Bitdiddle, the resident computer wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each assertion is a list (in this case a triple) whose elements can themselves
    be lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'As resident wizard, Ben is in charge of the company''s computer division, and
    he supervises two programmers and one technician. Here is the information about
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a programmer trainee, who is supervised by Alyssa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All of these people are in the computer division, as indicated by the word computer
    as the first item in their job descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ben is a high-level employee. His supervisor is the company''s big wheel himself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the computer division supervised by Ben, the company has an accounting
    division, consisting of a chief accountant and his assistant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a secretary for the big wheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The data base also contains assertions about which kinds of jobs can be done
    by people holding other kinds of jobs. For instance, a computer wizard can do
    the jobs of both a computer programmer and a computer technician:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A computer programmer could fill in for a trainee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Also, as is well known,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Simple Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The query language allows users to retrieve information from the data base by
    posing queries in response to the system's prompt. For example, to find all computer
    programmers one can say
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The system will respond with the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The input query specifies that we are looking for entries in the data base that
    match a certain pattern. In this example, the pattern specifies entries consisting
    of three items, of which the first is the literal symbol job, the second can be
    anything, and the third is the literal list (computer programmer). The "anything"
    that can be the second item in the matching list is specified by a pattern variable,
    `?x`. The general form of a pattern variable is a symbol, taken to be the name
    of the variable, preceded by a question mark. We will see below why it is useful
    to specify names for pattern variables rather than just putting ? into patterns
    to represent "anything". The system responds to a simple query by showing all
    entries in the data base that match the specified pattern.
  prefs: []
  type: TYPE_NORMAL
- en: A pattern can have more than one variable. For example, the query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: will list all the employees' addresses.
  prefs: []
  type: TYPE_NORMAL
- en: A pattern can have no variables, in which case the query simply determines whether
    that pattern is an entry in the data base. If so, there will be one match; if
    not, there will be no matches.
  prefs: []
  type: TYPE_NORMAL
- en: The same pattern variable can appear more than once in a query, specifying that
    the same "anything" must appear in each position. This is why variables have names.
    For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: finds all people who supervise themselves (though there are no such assertions
    in our sample data base).
  prefs: []
  type: TYPE_NORMAL
- en: The query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'matches all job entries whose third item is a two-element list whose first
    item is computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This same pattern does not match
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: because the third item in the entry is a list of three elements, and the pattern's
    third item specifies that there should be two elements. If we wanted to change
    the pattern so that the third item could be any list beginning with computer,
    we could specify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: matches the data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: with `?type` as the list `(programmer trainee)`. It also matches the data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: with `?type` as the list `(programmer)`, and matches the data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: with `?type` as the empty list `()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can describe the query language''s processing of simple queries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The system finds all assignments to variables in the query pattern that satisfy
    the pattern -- that is, all sets of values for the variables such that if the
    pattern variables are instantiated with (replaced by) the values, the result is
    in the data base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system responds to the query by listing all instantiations of the query
    pattern with the variable assignments that satisfy it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that if the pattern has no variables, the query reduces to a determination
    of whether that pattern is in the data base. If so, the empty assignment, which
    assigns no values to variables, satisfies that pattern for that data base.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assertions and Queries: Part 1**'
  prefs: []
  type: TYPE_NORMAL
- en: Add a couple assertions into the database about things that you like. This should
    look very similar to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, write a query that returns all of the things you like. It should return
    to you all of the assertions you just added.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assertions and Queries: Part 2**'
  prefs: []
  type: TYPE_NORMAL
- en: Add a few more assertions into the database about things that your project partner
    likes. Write another query that returns all of the things s/he likes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assertions and Queries: Part 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, write a query that will return all of the things that anoyone in the
    database likes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Queries**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Give simple queries that retrieve the following information from the data base:'
  prefs: []
  type: TYPE_NORMAL
- en: all people supervised by Ben Bitdiddle;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the names and jobs of all people in the accounting division;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the names and addresses of all people who live in Slumerville.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember, to load the example database and run the query system, type the following
    commands into an interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Compound Queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Simple queries form the primitive operations of the query language. In order
    to form compound operations, the query language provides means of combination.
    One thing that makes the query language a logic programming language is that the
    means of combination mirror the means of combination used in forming logical expressions:
    and, or, and not. (Here and, or, and not are not the Lisp primitives, but rather
    operations built into the query language.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use and as follows to find the addresses of all the computer programmers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The resulting output is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In general,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: is satisfied by all sets of values for the pattern variables that simultaneously
    satisfy `<query1> <query2> ... <queryn>`
  prefs: []
  type: TYPE_NORMAL
- en: As for simple queries, the system processes a compound query by finding all
    assignments to the pattern variables that satisfy the query, then displaying instantiations
    of the query with those values.
  prefs: []
  type: TYPE_NORMAL
- en: Another means of constructing compound queries is through or. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'will find all employees supervised by Ben Bitdiddle or Alyssa P. Hacker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In general,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: is satisfied by all sets of values for the pattern variables that satisfy at
    least one of `<query1> <query2> ... <queryn>`.
  prefs: []
  type: TYPE_NORMAL
- en: Compound queries can also be formed with `not`. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: finds all people supervised by Ben Bitdiddle who are not computer programmers.
    In general,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: is satisfied by all assignments to the pattern variables that do not satisfy
    `<query1>`.
  prefs: []
  type: TYPE_NORMAL
- en: The final combining form is called `lisp-value`. When `lisp-value` is the first
    element of a pattern, it specifies that the next element is a Lisp predicate to
    be applied to the rest of the (instantiated) elements as arguments. In general,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: will be satisfied by assignments to the pattern variables for which the `<predicate>`
    applied to the instantiated `<arg1> ... <argn>` is true. For example, to find
    all people whose salary is greater than $30,000 we could write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As long as we just tell the system isolated facts, we can’t get extraordinarily
    interesting replies. But we can also tell it *rules* that allow it to infer one
    fact from another. For example, if we have a lot of facts like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'then we can establish a rule about grandmotherhood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The rule says that the ﬁrst part (the conclusion) is true *if* we can ﬁnd values
    for the variables such that the second part (the condition) is true.
  prefs: []
  type: TYPE_NORMAL
- en: Again, resist the temptation to try to do composition of functions!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`Mother` isn’t a function, and you can’t ask for the mother of someone as this
    incorrect example tries to do. Instead, as in the correct version above, you have
    to establish a variable (`?mom`) that has a value that satisﬁes the two motherhood
    relationships we need.'
  prefs: []
  type: TYPE_NORMAL
- en: In this language the words `assert!, rule, and, or`, and `not` have special
    meanings. Everything else is just a word that can be part of assertions or rules.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing the Family Tree**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try writing some rules! The following database (see Genesis 4) traces
    the genealogy of the descendants of Ada back to Adam, by way of Cain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Formulate rules such as "If S is the son of F, and F is the son of G, then S
    is the grandson of G" and "If W is the wife of M, and S is the son of W, then
    S is the son of M" (which was supposedly more true in biblical times than today)
    that will enable the query system to find the grandson of Cain; the sons of Lamech;
    the grandsons of Methushael.
  prefs: []
  type: TYPE_NORMAL
- en: More Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a slightly more complicated rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It specifies that two people live near each other if they live in the same
    town. The final `not` clause prevents the rule from saying that all people live
    near themselves. The `same` relation is defined by the very simple rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Carpooling Time**'
  prefs: []
  type: TYPE_NORMAL
- en: By giving the query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Alyssa P. Hacker is able to find people who live near her, with whom she can
    ride to work. On the other hand, when she tries to find all pairs of people who
    live near each other by querying
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: she notices that each pair of people who live near each other is listed twice;
    for example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Why does this happen? Is there a way to find a list of people who live near
    each other, in which each pair appears only once? Explain. (Don't write the code
    for this!)
  prefs: []
  type: TYPE_NORMAL
- en: Logic as Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can regard a rule as a kind of logical implication: *If* an assignment of
    values to pattern variables satisfies the body, *then* it satisfies the conclusion.
    Consequently, we can regard the query language as having the ability to perform
    *logical deductions* based upon the rules. As an example, consider the `append`
    operation. `Append` can be characterized by the following two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: For any list `y`, the empty list and `y` append to form `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any `u`, `v`, `y`, and `z`, `(cons u v)` and `y` append to form `(cons u
    z)` if `v` and `y` append to form `z`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To express this in our query language, we define two rules for a relation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'which we can interpret to mean "x and y append to form z":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first rule has no body, which means that the conclusion holds for any value
    of `?y`. Note how the second rule makes use of dotted-tail notation to name the
    car and cdr of a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given these two rules, we can formulate queries that compute the append of
    two lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'What is more striking, we can use the same rules to ask the question "Which
    list, when appended to `(a b)`, yields`(a b c d)`?" This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The new thing in logic programming is that we can run a "function" backwards!
    We can tell it the answer and get back the question. But the real magic is...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: we can also ask for all pairs of lists that append to form `(a b c d)`! We can
    use logic programming to compute multiple answers to the same question! Somehow
    it found all the possible combinations of values that would make our query true.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does the append program work? Compare it to the Scheme `append`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the Scheme program, the logic program has two cases: There is a base case
    in which the ﬁrst argument is empty. In that case the combined list is the same
    as the second appended list. And there is a recursive case in which we divide
    the ﬁrst appended list into its car and its cdr. We reduce the given problem into
    a problem about appending `(cdr a)` to `b`. The logic program is diﬀerent in form,
    but it says the same thing.'
  prefs: []
  type: TYPE_NORMAL
- en: (Just as, in the grandmother example, we had to give the mother a name instead
    of using a function call, here we have to give`(car a)` a name--we call it `?u`.)
  prefs: []
  type: TYPE_NORMAL
- en: Word of Caution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The query system may seem to exhibit quite a bit of intelligence in using the
    rules to deduce the answers to the queries above. Actually, as we will see in
    the next section, the system is following a well-determined algorithm in unraveling
    the rules. Unfortunately, although the system works impressively in the append
    case, the general methods may break down in more complex cases.
  prefs: []
  type: TYPE_NORMAL
- en: The "working backward" magic used in the append case doesn't always work. Let's
    look at the following example, which reverses a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This works for `(reverse (a b c) ?what)` but not the other way around; it gets
    into an inﬁnite loop. We can also write a version that works only backwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: But it's much harder to write one that works both ways. Even as we speak, logic
    programming fans are trying to push the limits of the idea, but right now, you
    still have to understand something about the below-the-line algorithm to be conﬁdent
    that your logic program won't loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Last-Pair**'
  prefs: []
  type: TYPE_NORMAL
- en: Define rules to implement the `last-pair` operation of [SICP exercise 2.17](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.17),
    which returns a list containing the last element of a nonempty list. Check your
    rules on queries such as `(last-pair (3) ?x)`, `(last-pair (1 2 3) ?x)`, and `(last-pair
    (2 ?x) (3))`. Do your rules work correctly on queries such as `(last-pair ?x (3))`?
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some takeaways from this subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: In logic programming, we assert facts and ask questions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assertion is represented by a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the query language to retrieve information from the data base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules allow infering one fact from another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write programs such as `append` with logic programming!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to the next subsection and learn how the query system works!
  prefs: []
  type: TYPE_NORMAL
