- en: 'Lecture 12: Imperative features'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we've been working with the purely functional fragment of OCaml. 
    That is, we've been working with the subset of the language that does not include
    computational effects (also known as side effects) other than printing.  In particular,
    whenever we coded a function, we never changed variables or data.  Rather, we
    always computed new data.  For instance, when we wrote code for an abstract data
    type such as a stack, queue, or dictionary, the operations to insert an item into
    the data structure didn't effect the old copy of the data structure.  Instead,
    we always built a new data structure with the item appropriately inserted.  (Note
    that the new data structure might refer to the old data structure, so this isn't
    as inefficient as it first sounds.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, coding in a functional style (i.e., without side effects)
    is a "good thing" because it's easier to reason locally about the behavior of
    the code.  For instance, when we code purely functional queues or stacks, we don't
    have to worry about a non-local change to a queue or stack.  However, in some
    situations, it is more efficient or clearer to destructively modify a data structure
    than to build a new version.  In these situations, we need some form of mutable
    data structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Like most imperative programming languages, OCaml provides support for mutable
    data structures, but unlike languages such as C, C++, or Java, they are not the
    default.  Thus, programmers are encouraged to code purely functionally by default
    and to only resort to mutable data structures when absolutely necessary.  In addition,
    unlike imperative languages, OCaml provides no support for mutable *variables.* 
    In other words, the value of a variable cannot change in OCaml.  Rather, all mutations
    must occur through data structures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Refs
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are only two built-in mutable data structures in OCaml:  refs and arrays.
    OCaml supports imperative programming through the primitive parameterized `ref`
    type. A value of type "int ref" is a pointer to a location in memory, where the
    location in memory contains an integer.  It's analogous to "int*" in C/C++ or
    "Integer" in Java (but not "int" in Java).   Like lists, refs are polymorphic,
    so in fact, we can have a ref (i.e., pointer) to a value of any type.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'A partial signature for refs is below:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A ref is like a box that can store a single value. By using the `:=` operator,
    the value in the box can be changed as a side effect. It is important to distinguish
    between the value that is stored in the box, and the box itself. A ref is the
    simplest **mutable** data structure. A mutable data structure is one that be changed
    imperatively, or **mutated**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example where we use a ref:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code above evaluates to 7.  Let's see why:  The first line "let x:int ref
    = ref 3" creates a new ref cell, initializes the contents to 3, and then returns
    a reference (i.e., pointer) to the cell and binds it to x.  The second line "let
    y:int = !x" reads the contents of the cell referenced by x, returns 3, and then
    binds it to y.  The third line "x := (!x) + 1;" evaluates "!x" to get 3, adds
    one to it to get 4, and then sets the contents of the cell referenced by x to
    this value.  The fourth line "y + (!x)" returns the sum of the values y (i.e.,
    3) and the contents of the cell referenced by x (4).  Thus, the whole expression
    evaluates to 7.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a mutable stack build using refs:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A good exercise for you is to implement mutable versions of queues, priority
    queues, dictionaries, or any other data structure that we've seen in class thus
    far using refs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important kind of mutable data structure that OCaml provides is the
    array.  Arrays generalize refs in that they are a sequence of memory locations,
    where each location contains a different value.  We can think of a ref cell as
    an array of size 1.  The type `t array` is in fact very similar to the Java array
    type `t[]`. Here's a partial signature for the builtin Array structure for OCaml. 
    Note that you either have to "`open Array`" explicitly to use the operations or
    else write `Array.*foo*` when you want to use the operation *`foo`*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See the OCaml documentation for more information on the operations available
    on arrays.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have started using a new kind of clause in the specification,
    the **effects** clause. This clause specifies side effects that the operation
    has beyond the value it returns. When a routine has a side effect, it is useful
    to have the word "Effects:" explicitly in the specification to warn the user of
    the side effect.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Substitution model and refs
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The substitution model that we''ve seen so far explains how computation works
    as long as no imperative features of OCaml are used. This model describes computation
    as a sequence of rewrite steps in which a program subexpression is replaced by
    another until no further rewrites are possible. However, imperative features introduce
    the possibility of **state** : an executing OCaml program is accompanied by a
    current memory state that also changes as computation proceeds.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to get into the details of how memory heaps work yet, so we will
    use a simple abstract model of state. A memory *M* is a collection of memory cells
    each with its own unique name. We will call these names **locations**; a location
    is an abstract version of a memory address at the hardware level. Given a location,
    we can look up in the memory what value is stored at that location. As the program
    executes, the contents of some memory locations may change.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: One way to visualize the execution is the memory consists of a large (actually,
    infinite) number of boxes, each of which can contain a single value. At any given
    point during execution, some boxes are in use and others are empty. Each box has
    a unique name (its location) and this location can be used to find the single
    box with that name. Given a memory, we can always find a box  that is unused.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可视化执行的方式是，内存由大量（实际上是无限的）的盒子组成，每个盒子只能包含一个值。在执行过程中的任何时刻，一些盒子被使用，而其他盒子为空。每个盒子都有一个唯一的名称（它的位置），这个位置可以用来找到具有该名称的单个盒子。给定一个内存，我们总是可以找到一个未使用的盒子。
- en: Ref operations
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用操作
- en: 'There are three principal operations on references: creation using the `ref`
    operator, deferencing using `!`, and update using `:=`. Each of these operations
    has an associated reduction that is used when evaluating it. In order to explain
    what these operations do, a new kind of expression is needed, representing a location.
    We will write the syntactic metavariable *loc* to represent a location. For the
    purposes of explaining how to evaluate OCaml, we assume that there is an infinitely
    large set of locations (called **Loc**) available for use when evaluating programs,
    even though the actual memory is finite. We don''t care what the elements of **Loc**
    actually are. We can think of them as memory addresses, as integers, or even as
    strings. All that matters is that we can tell two different elements of **Loc**
    apart.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 引用上的三个主要操作是：使用 `ref` 运算符创建引用，使用 `!` 进行解引用，使用 `:=` 进行更新。每个操作在评估时都有一个相关的规约。为了解释这些操作的作用，需要一种新的表达式类型，表示一个位置。我们将写出语法元变量
    *loc* 来表示一个位置。为了解释如何评估 OCaml，我们假设在评估程序时有一个无限大的位置集合（称为 **Loc**）可供使用，即使实际内存是有限的。我们不关心
    **Loc** 的元素实际上是什么。我们可以将它们视为内存地址、整数，甚至字符串。重要的是我们能够区分 **Loc** 中的两个不同元素。
- en: ref
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ref
- en: The ref operation creates a new location. It is reduced once its argument is
    a value, creating a new location.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ref 操作创建一个新的位置。一旦其参数是一个值，它就会被规约，创建一个新的位置。
- en: '`ref` *v*`-->` *loc*'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ref` *v*`-->` *loc*'
- en: 'The new location *loc* is one that is unused in the current memory. This evaluation
    step also has a side effect: the memory cell named  *loc* is made to contain the
    value *v*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 新位置 *loc* 是当前内存中未使用的位置。这个评估步骤也具有副作用：名为 *loc* 的内存单元被设置为包含值 *v*。
- en: This rule introduces a *loc* expression into the running program. This is a
    bit different from all the evaluation rules that we have seen till this point,
    because a *loc* expression cannot occur in the original OCaml program. This isn't
    a problem; we have to remember that our models of evaluation are useful fictions.
    As long as the model gives the right answer for what happens when the program
    runs, we are satisfied. In OCaml, if a program evaluates to a location, it is
    printed as a ref expression.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则将一个 *loc* 表达式引入到运行中的程序中。这与我们到目前为止看到的所有评估规则有点不同，因为 *loc* 表达式不能出现在原始的 OCaml
    程序中。这并不是问题；我们必须记住，我们对评估的模型是有用的虚构。只要模型对程序运行时发生的事情给出正确答案，我们就满意。在 OCaml 中，如果一个程序评估为一个位置，它会被打印为一个
    ref 表达式。
- en: Equality on references in OCaml is slightly odd. If we test two expressions
    of the type 'a ref using =, OCaml will actually check if their contents are equal.
    This is generally what you want, but you can also use == to check if the refs
    themselves are equal (i.e., if the two refs point to the same block of memory).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OCaml 中，引用的相等性有点奇怪。如果我们使用 = 测试两个类型为 'a ref 的表达式，OCaml 实际上会检查它们的内容是否相等。这通常是你想要的，但你也可以使用
    == 来检查引用本身是否相等（即，这两个引用是否指向相同的内存块）。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '!'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '!'
- en: 'The dereference (`!`) operation finds the value stored at a given location:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用（`!`）操作找到存储在给定位置的值：
- en: '`!` *loc*`-->` *v*'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`!` *loc*`-->` *v*'
- en: Of course, the value v that replaces the subexpression `!`*loc* is the value
    found in the memory cell named *loc*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，替换 `!`*loc* 子表达式的值 v 是在名为 *loc* 的内存单元中找到的值。
- en: :=
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: :=
- en: 'The update (`:=`) operation updates the value stored at a given location:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更新（`:=`）操作更新存储在给定位置的值：
- en: '*loc* `:=` *v* `-->` `()`'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*loc* `:=` *v* `-->` `()`'
- en: It evaluates to the unit value, but has the side effect of updating the memory
    location named  *loc* to contain *v*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 它求值为单位值，但具有更新名为 *loc* 的内存位置以包含 *v* 的副作用。
- en: Example
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'Consider the following OCaml example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 OCaml 示例：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So we see that the update to `x` is visible when we dereference `y`. This happens
    because `x` and `y` are **aliases**: two different names for the same location
    (`*loc1*`).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当我们对`y`进行解引用时，可以看到对`x`的更新。这是因为`x`和`y`是**别名**：对同一位置(`*loc1*`)的两个不同名称。
