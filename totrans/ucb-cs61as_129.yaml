- en: Python Interpreter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Python
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to learn about Python, the language that CS61A uses. Your friends
    in CS61A are writing a Scheme interpreter in Python. Here in CS61AS, you are going
    to write a Python Interpreter written in Scheme for your last project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Opening Python
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To open Python, go to the terminal and type "python". The ">>>" prompt will
    show up which is the equivalent of Scheme's "->".
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: As you will learn, spaces in Python are really important. Spaces for python
    are Parentheses for Scheme.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Python
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try these commands out in the interpreter. Most of these are taken from the
    project spec added with some more examples. Some of the examples are supposed
    to error. If there is a behavior that you don't expect, please ask!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: print
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How would you ask Python to print "Hello World"? Well,
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'and that''s it! (Yeah, seriously). As you may have noticed from that simple
    example, Python does not need left parentheses to call functions; you do not need
    to precede ''print'' with a left parenthesis. Python is case-sensitive, so "PRINT"
    would not work. Another key difference is that Python only supports infix operators,
    where the operator is present between its operands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You don''t actually need the ''print'' statement; the interpreter automatically
    evaluates whatever is typed at the prompt, using a Read-Eval-Print loop that is
    very similar to that used in the metacircular evaluator (We''ll explore this two
    sections from now.) For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What are the outputs of the following?
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Assignments
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assignments in Python are similar to assignments in other languages. If, for
    example, you would like to provide a value to a variable called ''x'':'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In contrast to Scheme, Python makes no distinction between DEFINE and SET!.
    If a variable 'x' is not already present, the above assignment creates a new variable
    'x' in the global environment; otherwise, any previous value of 'x' is overwritten.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: booleans
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"If we used "=" to assign variables, how do we check for equality?". Python
    (and most other languages) uses "==" instead.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Python has support for the Boolean operators ''and'' and ''or'', which work
    exactly as the corresponding Scheme special forms work:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The Python equivalents for #t and #f are True and False, respectively (capitalization
    is important).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Lists
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python has lists! (Why wouldn't it?)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '"x" is now a variable that stores a list of three numbers. As you can guess,
    the Scheme analog is "(list 1 2 3)". Python lists can also be deep:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Unfortunately, we can''t CAR or CDR down a Python list. To access particular
    elements of a list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The notation "x[1]" returns the second element of the list (Python uses zero-
    based counting). Again, in this case, the "[" character can be considered an infix
    operator.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Blocks
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ifs
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important aspect of Python, born of its dedication to readable code, is its
    usage of INDENTATION. In most other languages, including Scheme, indentation is
    not an issue, since these languages ignore the number of spaces, and instead use
    spaces to delimit symbols, numbers and words. However, in Python, the number of
    spaces at the beginning of a line is important.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '(You will have to press the ENTER key once more at the "..." prompt that will
    show immediately after, to signify that you are done with the ''if''-statement.)
    The ''if''-statement in Python works the same as its equivalent in Scheme: if
    the condition of the ''if''-statement is satisfied, then the body is evaluated.
    Notice that we have used ''=='' instead of ''='': since the ''='' character is
    already used for assignment, we use ''=='' to check for equality. Notice also
    that the body is indented: all statements in the body need to begin with the same
    indentation. As a result, the following would not work:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'because the second statement in the body is indented more than the first statement.
    Similarly, the following would not work:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: because the second statement in the body is indented less than the first statement.
    In general, you would only DEDENT when you are done with a set of related statements,
    or a BLOCK. All statements in a block need to be indented with the same number
    of spaces. As a further example, an 'if'-statement can also have an 'else'-clause,
    which is evaluated if the condition is not satisfied.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that the lines inside the blocks corresponding to the ''if''-statement
    and its ''else''-clause are indented the same amount, but the blocks themselves
    are indented by different amounts (though they don''t have to be!). The ''if''-statement
    and the ''else''-clause, however, need to be indented by the same amount because
    they belong to the same statement. However, *all statements that are not part
    of a block or sub-block of statements should have no indentation*. Try the following
    statement (which has an indentation of two spaces after ">>> ") at the Python
    interpreter prompt:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Indentation enforces clean code, but can take a while to get used to; the key
    thing to remember is that you only need to indent when you are starting a new
    block of statements.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Defining Functions
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python also has FUNCTIONS, its analog to Scheme''s procedures. The following
    defines the ''square'' function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '(Again, you will have to press the ENTER key once more at the "..." prompt
    that will show immediately after, to signify that you are done with the procedure
    body.) This syntax is similar to C-like languages, where the arguments to the
    function are enclosed between parentheses and present immediately after the name
    of the function. To call the function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this sense, the left parenthesis can be considered an infix operator, where
    the operator is between its operands. To see why this is the case, recall that
    in Scheme, the left parenthesis can be considered as a prefix operator, which
    "calls" its first argument on the subsequent arguments. Similarly, in Python,
    the left parenthesis "calls" its first argument (''square'') on the next argument
    (''3''). Also, if Python procedures need to return values, we have to explicitly
    add a ''return''-statement to the body to return the answer; by contrast, in Scheme,
    the very last line of a procedure definition is always returned. This allows us
    to distinguish between Python functions that return values, and Python functions
    that do not return values but are used primarily for their side-effects:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个意义上讲，左括号可以被视为一个中缀运算符，其中运算符位于其操作数之间。要了解为什么会这样，回想一下，在Scheme中，左括号可以被视为一个前缀运算符，它在后续参数上“调用”其第一个参数。同样，在Python中，左括号在下一个参数（'3'）上“调用”其第一个参数（'square'）。此外，如果Python过程需要返回值，我们必须在主体中显式添加一个'return'语句来返回答案；相比之下，在Scheme中，过程定义的最后一行总是返回的。这使我们能够区分返回值的Python函数和主要用于副作用的Python函数：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Try the following:'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 尝试以下内容：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Loops
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: 'Python has constructs for loops. The project spec has a more in depth explanation
    but give the following codes a shot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Python有用于循环的结构。项目规范有更详细的解释，但试试以下代码：
- en: while
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: while
- en: A "while" loop takes in a predicate, and will keep evaluating the body until
    the predicate evaluates to False.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “while”循环接受一个谓词，并将继续评估主体，直到谓词评估为False。
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: for
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for
- en: A "for" loop takes in a list (or any kind of sequence) and runs through the
    body with each element of the sequence. This is similar to the loops you learned
    about in Lesson 9.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: “for”循环接受一个列表（或任何类型的序列）并对序列的每个元素运行主体。这类似于您在第9课中学到的循环。
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
