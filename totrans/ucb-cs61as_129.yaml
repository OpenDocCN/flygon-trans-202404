- en: Python Interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to learn about Python, the language that CS61A uses. Your friends
    in CS61A are writing a Scheme interpreter in Python. Here in CS61AS, you are going
    to write a Python Interpreter written in Scheme for your last project.
  prefs: []
  type: TYPE_NORMAL
- en: Opening Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To open Python, go to the terminal and type "python". The ">>>" prompt will
    show up which is the equivalent of Scheme's "->".
  prefs: []
  type: TYPE_NORMAL
- en: As you will learn, spaces in Python are really important. Spaces for python
    are Parentheses for Scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try these commands out in the interpreter. Most of these are taken from the
    project spec added with some more examples. Some of the examples are supposed
    to error. If there is a behavior that you don't expect, please ask!
  prefs: []
  type: TYPE_NORMAL
- en: print
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How would you ask Python to print "Hello World"? Well,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'and that''s it! (Yeah, seriously). As you may have noticed from that simple
    example, Python does not need left parentheses to call functions; you do not need
    to precede ''print'' with a left parenthesis. Python is case-sensitive, so "PRINT"
    would not work. Another key difference is that Python only supports infix operators,
    where the operator is present between its operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t actually need the ''print'' statement; the interpreter automatically
    evaluates whatever is typed at the prompt, using a Read-Eval-Print loop that is
    very similar to that used in the metacircular evaluator (We''ll explore this two
    sections from now.) For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What are the outputs of the following?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Assignments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assignments in Python are similar to assignments in other languages. If, for
    example, you would like to provide a value to a variable called ''x'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In contrast to Scheme, Python makes no distinction between DEFINE and SET!.
    If a variable 'x' is not already present, the above assignment creates a new variable
    'x' in the global environment; otherwise, any previous value of 'x' is overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"If we used "=" to assign variables, how do we check for equality?". Python
    (and most other languages) uses "==" instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Python has support for the Boolean operators ''and'' and ''or'', which work
    exactly as the corresponding Scheme special forms work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python equivalents for #t and #f are True and False, respectively (capitalization
    is important).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python has lists! (Why wouldn't it?)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '"x" is now a variable that stores a list of three numbers. As you can guess,
    the Scheme analog is "(list 1 2 3)". Python lists can also be deep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, we can''t CAR or CDR down a Python list. To access particular
    elements of a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The notation "x[1]" returns the second element of the list (Python uses zero-
    based counting). Again, in this case, the "[" character can be considered an infix
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ifs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important aspect of Python, born of its dedication to readable code, is its
    usage of INDENTATION. In most other languages, including Scheme, indentation is
    not an issue, since these languages ignore the number of spaces, and instead use
    spaces to delimit symbols, numbers and words. However, in Python, the number of
    spaces at the beginning of a line is important.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '(You will have to press the ENTER key once more at the "..." prompt that will
    show immediately after, to signify that you are done with the ''if''-statement.)
    The ''if''-statement in Python works the same as its equivalent in Scheme: if
    the condition of the ''if''-statement is satisfied, then the body is evaluated.
    Notice that we have used ''=='' instead of ''='': since the ''='' character is
    already used for assignment, we use ''=='' to check for equality. Notice also
    that the body is indented: all statements in the body need to begin with the same
    indentation. As a result, the following would not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'because the second statement in the body is indented more than the first statement.
    Similarly, the following would not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: because the second statement in the body is indented less than the first statement.
    In general, you would only DEDENT when you are done with a set of related statements,
    or a BLOCK. All statements in a block need to be indented with the same number
    of spaces. As a further example, an 'if'-statement can also have an 'else'-clause,
    which is evaluated if the condition is not satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the lines inside the blocks corresponding to the ''if''-statement
    and its ''else''-clause are indented the same amount, but the blocks themselves
    are indented by different amounts (though they don''t have to be!). The ''if''-statement
    and the ''else''-clause, however, need to be indented by the same amount because
    they belong to the same statement. However, *all statements that are not part
    of a block or sub-block of statements should have no indentation*. Try the following
    statement (which has an indentation of two spaces after ">>> ") at the Python
    interpreter prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Indentation enforces clean code, but can take a while to get used to; the key
    thing to remember is that you only need to indent when you are starting a new
    block of statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Defining Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python also has FUNCTIONS, its analog to Scheme''s procedures. The following
    defines the ''square'' function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '(Again, you will have to press the ENTER key once more at the "..." prompt
    that will show immediately after, to signify that you are done with the procedure
    body.) This syntax is similar to C-like languages, where the arguments to the
    function are enclosed between parentheses and present immediately after the name
    of the function. To call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this sense, the left parenthesis can be considered an infix operator, where
    the operator is between its operands. To see why this is the case, recall that
    in Scheme, the left parenthesis can be considered as a prefix operator, which
    "calls" its first argument on the subsequent arguments. Similarly, in Python,
    the left parenthesis "calls" its first argument (''square'') on the next argument
    (''3''). Also, if Python procedures need to return values, we have to explicitly
    add a ''return''-statement to the body to return the answer; by contrast, in Scheme,
    the very last line of a procedure definition is always returned. This allows us
    to distinguish between Python functions that return values, and Python functions
    that do not return values but are used primarily for their side-effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Try the following:'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has constructs for loops. The project spec has a more in depth explanation
    but give the following codes a shot:'
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A "while" loop takes in a predicate, and will keep evaluating the body until
    the predicate evaluates to False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: for
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A "for" loop takes in a list (or any kind of sequence) and runs through the
    body with each element of the sequence. This is similar to the loops you learned
    about in Lesson 9.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
