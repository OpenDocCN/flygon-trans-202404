- en: A Few Words on Amortized Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See Chapter 5.1 of the Okasaki textbook for a summary of two approaches to amortized
    analysis, the banker's method and the physicist's method. Here, we will say just
    a few extra words about the accounting for the [`FastQueue`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/Queues/FastQueue.elm)
    implementation from before.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that when evaluating the running times of functions, we often use symbolic
    constants instead of concrete units (such as seconds) in order to abstract away
    from low-level, incidental, and variable characteristics of an execution environment.
    And because Big-Oh analysis, furthermore, abstracts away the particular constants
    of a function, symbolic constants (such as *k*) are often replaced by particular
    small constants (such as *1*).
  prefs: []
  type: TYPE_NORMAL
- en: Once comfortable with such reasoning, we can often jump directly to saying things
    like "the amortized cost of `enqueue` is *2*" and "the amortized cost of `dequeue`
    is *1*". In the meantime, let us spend the extra effort to explicitly account
    for the actual (symbolic) costs of operations before reducing them to their asymptotic
    characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid confusion with the notation *c* for credits from the textbook, here
    we will use the metavariable *k* to range over constants. Let the following constants
    stand for actual costs of the various operations on a `Queue` that contains *m*
    elements in the `back` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*k[1]* is the cost of `enqueue`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*k[2]* is the cost of `peek`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*k[3]* is the cost of `dequeue` when `List.reverse` is not called (the cheap
    case); and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*k[4]m + k[5] = m + k[6]* is the cost of `dequeue` when `List.reverse` is called
    (the expensive case). Notice that this actual cost is linear in the size of the
    `back` list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We now revisit the amortized analyses from the textbook using these symbolic
    constants rather than concrete costs, such as *1* and *2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the banker''s method (*a[i] = t[i] + c[i] - c[i]*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`enqueue`: *k[1] + 1 - 0 = k[1] + 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek`: *k[2] + 0 - 0 = k[2]*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dequeue` (cheap): *k[3] + 0 - 0 = k[3]*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dequeue` (expensive): *(m + k[6]) + 0 - m = k[6]*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, all of the operations run in *O(1)* amortized time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the physicist''s method (*a[i] = t[i] + Φ(d[i]) - Φ(d[i]-1*)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`enqueue`: *k[1] + (m+1) - m = k[1] + 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek`: *k[2] + m - m = k[2]*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dequeue` (cheap): *k[3] + m - m = k[3]*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dequeue` (expensive): *(m + k[6]) + 0 - m = k[6]*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, all of the operations run in *O(1)* amortized time.
  prefs: []
  type: TYPE_NORMAL
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Required
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Okasaki, Chapter 5.1 and 5.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
