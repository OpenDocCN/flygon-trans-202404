- en: Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing pyramid and different levels of tests are discussed in "Agree the
    language you use for tests".
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in that section it is important to maintain a layered strategy
    with many fast running unit tests and smaller numbers of integration and system
    tests. The precise proportions that work best will vary from project to project
    but the pyramid formation will hold.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is important to write tests at all these levels this section mainly
    concerns itself with unit tests as these are the ones we write most of and run
    most frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Write Specifications Not Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write Specifications Not Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you sit down to write a test it's important to understand *why* you are
    doing it.
  prefs: []
  type: TYPE_NORMAL
- en: What is it that you want to achieve?
  prefs: []
  type: TYPE_NORMAL
- en: There is an unfortunate tendency for developers to look at tests as a thing
    you have to do because it's "best practice". Some extra work to be performed after
    the real work is done. A chore.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for writing them has become lost.
  prefs: []
  type: TYPE_NORMAL
- en: Why Write Tests?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason to write tests is to make our lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: If we are not writing tests that do this we should stop writing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good test should do all of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable refactoring by preventing regression when the implementation changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch bugs during initial coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document how the code behaves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inform the design of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When tests are viewed as a chore to be completed after the code is written only
    this first point is considered.
  prefs: []
  type: TYPE_NORMAL
- en: Often it is not achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests written with this mindset can have a negative value:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of enabling refactoring they can increase its cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of documenting what the code does, the tests are harder to understand
    than the code itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of aiding development they increase the work that must be done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This first problem causes the most pain.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a test that is tied to the code's implementation, to change the
    way the code is implemented you have to spend effort changing the test.
  prefs: []
  type: TYPE_NORMAL
- en: If the test must change whenever the implementation changes then we cannot trust
    that the test will stop regression. How do we know we did not introduce a bug
    into the test when we changed it?
  prefs: []
  type: TYPE_NORMAL
- en: Executable Specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So how do we make sure we do not write negative value tests? How do we make
    sure we write tests that provide the benefits in our list?
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is let go of the idea that we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: We are not testing, we're *specifying*.
  prefs: []
  type: TYPE_NORMAL
- en: To test something you only need to verify that it "does what it does". To specify
    you need to describe the important things that it must do in a way that can be
    clearly understood.
  prefs: []
  type: TYPE_NORMAL
- en: A good specification describes *only* the important things.
  prefs: []
  type: TYPE_NORMAL
- en: It describes what something *must* do without making assumptions about how it
    will do it. It allows for multiple implementations. If a specification is tied
    to one implementation then it is *over-specified* and will have to change when
    the implementation does.
  prefs: []
  type: TYPE_NORMAL
- en: So this is what we must aim for - an executable specification of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately it is very hard to do.
  prefs: []
  type: TYPE_NORMAL
- en: Specification First
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One simple technique that can help is to write the specification before the
    code. i.e. TDD.
  prefs: []
  type: TYPE_NORMAL
- en: A rigorous TDD cycle proceeds in very small steps.
  prefs: []
  type: TYPE_NORMAL
- en: First write a test and run it to ensure that it fails.
  prefs: []
  type: TYPE_NORMAL
- en: Next write just enough code to make that test pass (and no more).
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to see if there is a sensible refactoring that would improve the
    code, then write the next test and continue the cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It guarantees that all the code *can* be tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As there is no implementation when the test is written it is harder to write
    a test that is tied to one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It guarantees that all behavior is covered by tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It discourages writing superfluous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two important aspects to TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the specification first
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving in very small steps
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of these practices are a good idea individually, even if they are not combined.
  prefs: []
  type: TYPE_NORMAL
- en: If we wrote our specification first, but moved in larger steps (possibly because
    we believed we knew what our implementation should look like) we would realize
    our first advantage - a guarantee that the code we wrote could be tested.
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean by this?
  prefs: []
  type: TYPE_NORMAL
- en: If code is not written with testing in mind then it can be difficult to write
    a test for it that fits our definition of a *unit* test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make our code more likely to be testable by following simple rules such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: Always inject dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid global state (singletons, static variables, ThreadLocals, registries etc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But even if we follow these rules we can still find that it is difficult to
    test our code if we have not designed for it. Writing our specification first
    requires our design to consider testing.
  prefs: []
  type: TYPE_NORMAL
- en: Although we ensured our code was testable, because we moved in large steps with
    an implementation in mind we might not achieve the other benefits.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to write our code without first writing a test we might discover
    we were finished that our code was difficult to test. The process of writing that
    code would however have been easier if we had applied the second technique - moving
    in small steps.
  prefs: []
  type: TYPE_NORMAL
- en: If we wrote only a small amount of code before executing it and observing the
    result of each small code change, we would probably spend less time debugging,
    be less likely to write code we did not need and move faster over all.
  prefs: []
  type: TYPE_NORMAL
- en: TDD has many advantages but it is not magic.
  prefs: []
  type: TYPE_NORMAL
- en: Even if it is applied rigorously it is entirely possible to write terrible code
    and specifications. TDD doesn't mean you can stop thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this, if you have a good understanding of the technologies and domain
    in which you are working, TDD is usually the best approach if you wish to optimize
    for quality.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not understand your domain or technology well you may find writing
    a specification first hard.
  prefs: []
  type: TYPE_NORMAL
- en: The classic solution to this problem is to first gain understanding by producing
    a throw away spike.
  prefs: []
  type: TYPE_NORMAL
- en: Spikes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A spike is just some quick and dirty code to explore how you might tackle the
    problem. At the end of the spike you will know if that approach works well or
    if it is worth looking for alternative approaches.
  prefs: []
  type: TYPE_NORMAL
- en: By producing a spike, you gain more understanding of both the domain and the
    technology you are working with. Even if the conclusion at the end of the spike
    is that it was a poor approach, the spike was still useful as it increased your
    understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have learned what you can from the spike, it should be thrown away
    and the final code test driven using the knowledge you have gained.
  prefs: []
  type: TYPE_NORMAL
- en: Spike and Stabilize
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traditionally, spikes are thrown away as they are inherently of low quality.
    Discarding the spike is done to optimize code quality at the expense of a (probably)
    slower delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes this is not the trade-off you want.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to try to stabilize the spike so that it is fit for use. If
    you do this, you will usually end up with something of lower quality than if you
    had started again.
  prefs: []
  type: TYPE_NORMAL
- en: You will also end up spending more effort on this piece of code over the lifetime
    of the project than if you had thrown the spike away.
  prefs: []
  type: TYPE_NORMAL
- en: What you gain for this loss in quality and increase in effort is a faster *first*
    delivery. Sometimes this is a trade-off worth making, sometimes it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Think Units Not Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think Units, Not Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each behavior that a unit test describes should normally relate to the overall
    *unit* rather than the responsibilities of an individual method.
  prefs: []
  type: TYPE_NORMAL
- en: What is a Unit?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To think in terms of units we have to first answer the difficult question of
    what a *unit* actually is.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in terms of methods is effectively the same as saying that a *unit*
    is a method. It is easy to show why this does not always work.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to try and write a unit test for the `push` method of `java.util.Stack`
    we might end up with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now lets test the `pop` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Oh. That looks familiar.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we are hitting is that we have defined too small a *unit*. We are
    trying to describe the behavior of something that is only useful when it collaborates
    with other *units* of the same size.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start thinking of `java.util.Stack` as our *unit* then tests become much
    easier to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have written a test that, instead of trying to describe what a method does,
    describes the behavior of the class as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: The idea that our job is to test methods is common with developers that are
    new to unit testing, and is unfortunately re-enforced by some IDEs and tools that
    provide templates to generate tests for each method of a class.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, for `Stack` it makes far more sense to consider the behavior
    of the class of a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Are Classes Units?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It often does make sense to treat a class as a *unit* so this is a good default
    definition, but it isn't always the right granularity.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to try to test the `java.util.Collections` class we would find that
    it is perfectly reasonable to treat the `sort`, `reverse` , `singleton`, etc.
    methods as separate *units*. Each one represents a self contained logical behavior.
  prefs: []
  type: TYPE_NORMAL
- en: So sometimes *units* are as small as methods.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes they are also larger than a single class.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to inherit the code below without any tests what tests might we write
    for it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We might write tests for the Addition and Subtraction classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the `ThingaMeBob` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At some point we would hopefully question why this code is so over-engineered
    and consider refactoring to something simpler like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What happens to our tests?
  prefs: []
  type: TYPE_NORMAL
- en: Which ones were most valuable?
  prefs: []
  type: TYPE_NORMAL
- en: The answer of course is that the test which exercised all three classes through
    the public interface of `ThingaMeBob` proved the most useful. We did not have
    to change it at all. When it ran green we knew our refactoring was successful
    and everything still works.
  prefs: []
  type: TYPE_NORMAL
- en: We deleted the ones for `Addition` and `Subtraction`. The smaller units we created
    were just implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: Lets re-wind and imagine things happened differently.
  prefs: []
  type: TYPE_NORMAL
- en: What if we were asked to test drive the desired behavior from scratch? What
    would we write?
  prefs: []
  type: TYPE_NORMAL
- en: We would most likely write something that looked like our 2nd simpler version
    of `ThingaMeBob` and a test that looked something like `ThingAMeBobTest`.
  prefs: []
  type: TYPE_NORMAL
- en: If we were then asked to add support for another 10 operations, we might leave
    our design fundamentally the same.
  prefs: []
  type: TYPE_NORMAL
- en: What if a new requirement came for the behavior in `ThingAMeBob` to be more
    dynamic, with different operations being enabled and disabled at runtime?
  prefs: []
  type: TYPE_NORMAL
- en: It would then make sense to refactor to something like our earlier more complex
    version.
  prefs: []
  type: TYPE_NORMAL
- en: What should we do with the tests?
  prefs: []
  type: TYPE_NORMAL
- en: We would already have tests written in terms of `ThingaMeBob` that describe
    all supported behaviors. Should we also fully describe `Addition`, `Subtraction`
    and the other 10 operations with tests as we extract them into classes?
  prefs: []
  type: TYPE_NORMAL
- en: There is no right answer here, but I hope it is clear that the most useful *unit*
    that we have identified is `ThingaMeBob`. The smaller *units* are part of just
    one implementation of the functionality we require.
  prefs: []
  type: TYPE_NORMAL
- en: If we choose to write tests for each extracted class those tests would have
    some value.
  prefs: []
  type: TYPE_NORMAL
- en: The test written in terms of `ThingaMeBob` would do a poor job of describing
    what each of the small extracted units does. If a test was failing it wouldn't
    be instantly obvious which class the bug was in. If we had to change one of the
    extracted classes it wouldn't be instantly obvious which test to run.
  prefs: []
  type: TYPE_NORMAL
- en: So there is definitely value in writing tests for each of the extracted classes.
    At the same time, if we were not to do so, that would also be a reasonable decision
    and it would reduce the cost of the refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThingaMeBob` tests will be fast and repeatable and allow us to work easily
    with the code. If we could only have tests at one level, the level we would choose
    is `ThingaMeBob`.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a starting point, assume that a *unit* will be a class, but recognize
    that this is not a hard rule.
  prefs: []
  type: TYPE_NORMAL
- en: A *unit* is really a "single self contained logical concern" - it may make sense
    to have several classes collaborate in order to capture that concern - as long
    as that collaboration provides a single well defined entry point.
  prefs: []
  type: TYPE_NORMAL
- en: Making units too small may be a form of over-specifying.
  prefs: []
  type: TYPE_NORMAL
- en: Making units too large may result in tests that are difficult to understand
    and expensive to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, if you might reasonably have made one or more classes inner
    classes of a different class, perhaps they should be treated as a single unit.
  prefs: []
  type: TYPE_NORMAL
- en: Name Tests With A Specification Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name Test Cases With a Specification Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the name of each test case to describe one (and **only** one) behavior of
    the unit under test. The name should be a proposition - i.e. a statement that
    could be true or false.
  prefs: []
  type: TYPE_NORMAL
- en: The method name should start with *should*.
  prefs: []
  type: TYPE_NORMAL
- en: This is superfluous once you get good at writing test names, but in a mixed
    team it is useful as it encourages thinking about the test in the right way.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the name should describe a behavior and, optionally, a scenario
    (identified by the word When).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might start to describe `java.util.Stack` with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shouldBeEmptyWhenCreated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldReturnMostRecentlyAddedItemsFirst`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldThrowAnErrorWhenItemsRemovedFromEmptyStack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contrast this with common naming patterns found in some code bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emptyStack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testEmptyStack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testPush`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These names alone tell us nothing about how a `Stack` should behave.
  prefs: []
  type: TYPE_NORMAL
- en: If we omit *should* we can create more concise names
  prefs: []
  type: TYPE_NORMAL
- en: '`isEmptyWhenCreated`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`returnsItemsInOrderTheyAreAdded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`throwsAnErrorWhenItemsRemovedFromEmptyStack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although more verbose the formulaic *should* form has an advantage - it provides
    a clear pattern to follow.
  prefs: []
  type: TYPE_NORMAL
- en: If a developer knows that a test name must start with *should* (often because
    they have seen this pattern within existing tests) it is hard for them to revert
    to a different style and write a test that is not a proposition.
  prefs: []
  type: TYPE_NORMAL
- en: The verbosity of *should* pays for itself by forcing developers to think about
    tests in the right fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Kevlin Henney compares *shoulds* to training wheels on a bike - a device to
    help while we are learning.
  prefs: []
  type: TYPE_NORMAL
- en: So when should we take the training wheels off?
  prefs: []
  type: TYPE_NORMAL
- en: This depends on the makeup of the team and how often the team changes.
  prefs: []
  type: TYPE_NORMAL
- en: If the majority of people who are likely to work on the codebase over its lifetime
    are accustomed to writing tests in this style then the added verbosity is not
    worth it. If a sufficiently large proportion are not then it is probably best
    for the team to stick with the convention.
  prefs: []
  type: TYPE_NORMAL
- en: Use the Example Style When Specification Style Does Not Work
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Occasionally, it is not possible to follow the specification naming style because
    the descriptions become too long and unwieldy. If it feels like your method names
    are becoming overly long ask yourself two questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Am I really testing only one thing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is my unit doing too much?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you're confident the answer is "no" to both then switch to a different style
    - example style.
  prefs: []
  type: TYPE_NORMAL
- en: 'In example style the name describes only the "When" part. It does not describe
    the expected behavior, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emptyStack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oneItemAdded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removalFromEmptyStack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand tests named with the example style, you must read the code within
    the tests. For this reason, this specification style should be preferred when
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Method Names in Test Descriptions Where Possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where possible, avoid including method names in test names.
  prefs: []
  type: TYPE_NORMAL
- en: On a practical level this avoids the extra overhead of updating test names if
    method names are ever refactored.
  prefs: []
  type: TYPE_NORMAL
- en: More subtly, including names can make you think in the wrong fashion - verifying
    method implementation rather than specifying unit behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a hard rule - sometimes it will be difficult or impossible to describe
    a meaningful behavior without referring to the unit's interface.
  prefs: []
  type: TYPE_NORMAL
- en: The domain language may also overlap with the method names, so you may find
    yourself using the same **words** as are also used as a method name.
  prefs: []
  type: TYPE_NORMAL
- en: Pick Examples Carefully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pick Examples Carefully
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditional testing is performed with examples.
  prefs: []
  type: TYPE_NORMAL
- en: The overall behavior of the component or unit is explained by supplying a series
    of example input and output values, or example interactions with other components.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to use examples to
  prefs: []
  type: TYPE_NORMAL
- en: Communicate the general expected behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate the behavior at any edge cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gain confidence that our code is correct and remains correct when we change
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So how should we pick these examples?
  prefs: []
  type: TYPE_NORMAL
- en: One approach is to look at the possible inputs to the component under test.
  prefs: []
  type: TYPE_NORMAL
- en: We could fully specify our code if we provided the expected output for each
    possible input. Usually, this is not practical because the possible range of inputs
    is far too large. Instead, we can look for categories of values within the possible
    range of inputs (e.g *valid* and *invalid*) and pick an example from each one.
  prefs: []
  type: TYPE_NORMAL
- en: However, the best approach is usually not to think in terms of possible inputs
    and examples, but to instead think first of the behaviors we would like our code
    to exhibit.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have identified the behavior we can then pick examples that demonstrate
    it. The actual values used are often unimportant - "Make tests easy to understand"
    discusses some techniques to make unimportant values less prominent in tests and
    highlight the important ones.
  prefs: []
  type: TYPE_NORMAL
- en: Property-based testing takes this a stage further.
  prefs: []
  type: TYPE_NORMAL
- en: Properties are identified that must hold true for all inputs or for a subset
    of possible inputs that meet certain criteria. The tests do not contain any example
    values - just a description of how they must be constrained. The examples used
    to check the properties are generated randomly and only ever seen if the check
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some compelling advantages to property based testing:'
  prefs: []
  type: TYPE_NORMAL
- en: The tests describe what is important about the input values. In example testing
    this must be inferred by the reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests will automatically find edge cases and bad assumptions made by the
    programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is currently little experience with property-based testing in the Java
    community, so questions remain on how best to use it.
  prefs: []
  type: TYPE_NORMAL
- en: One obvious issue is that it introduces randomness, although most frameworks
    provide some mechanism to control it and repeat test runs.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the Zero, One and Many Rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your components deals with numbers or collections of things, make sure you
    use sufficient examples to describe its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule thumb is that test cases covering 0 (or empty), 1 and "many" are
    likely to be necessary. There will also be important edge cases, e.g. algorithmic
    code dealing with integers might need to consider `Integer.MAX` and `Integer.MIN`.
  prefs: []
  type: TYPE_NORMAL
- en: The zero, one many rule defines the minimum number of cases you can hope to
    consider. To properly describe your code's behavior will likely require many more.
  prefs: []
  type: TYPE_NORMAL
- en: When test driving, it is usually easiest to start with the *zero* test case.
  prefs: []
  type: TYPE_NORMAL
- en: Test One Thing at a Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each test case should specify one thing and one thing only.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple assertions within a test may be an indicator that the test is testing
    more than one thing. Multiple assertions should be treated with suspicion, but
    are not necessarily a problem e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This test tests only one concern, but uses multiple asserts to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Test Each Thing Only Once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you've tested a concern, don't let it leak into other tests - if you do
    then those tests are no longer testing only one thing.
  prefs: []
  type: TYPE_NORMAL
- en: This is a particularly easy mistake to make with interaction-based testing.
    If it is vitally important that the method `anImportantSideEffect` is called,
    it is easy to find yourself verifying that method in each test case.
  prefs: []
  type: TYPE_NORMAL
- en: If the contract ever changes so that this side effect is not longer important,
    all tests will need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: This concern should instead by covered by a single test case `shouldPerformImportantSideEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: Although we shouldn't let a property leak into test cases where it does not
    belong this does not necessarily mean that it will be confined to a single test
    case. It may take several examples to fully demonstrate a property.
  prefs: []
  type: TYPE_NORMAL
- en: Make Tests Easy To Understand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make Tests Easy to Understand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of our goals when writing a test is to document what the code under tests
    does.
  prefs: []
  type: TYPE_NORMAL
- en: We achieve this in part by choosing clear specification style names for each
    test case, but we must also ensure that the code implementing each test case is
    easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Some techniques that help achieve this are discussed below.
  prefs: []
  type: TYPE_NORMAL
- en: Make Test Structure Clear
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A test can be viewed as having three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Given - create the values and objects required for the test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When - executes the code under test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then - verifies the output/behavior is as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These stages are also sometimes called *arrange*, *act* and *assert* by people
    particularly attached to the letter 'a'.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is important that these three stages are visible, trying to rigorously
    separate them or label them with comments adds noise to a test.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Follow Standard TEA Naming Convention for Test Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Establishing simple conventions can make some very basic things about a test
    clear to a reader.
  prefs: []
  type: TYPE_NORMAL
- en: If the unit you are testing is a class make this clear by always naming it `testee`
    within a test.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to store an expected value in a variable, call it `expected` (but
    don't store it in a variable just for the sake of it).
  prefs: []
  type: TYPE_NORMAL
- en: If you need to store a result that you will compare against an expected value
    in variable, name it `actual` (but don't store it in a variable just for the sake
    of it).
  prefs: []
  type: TYPE_NORMAL
- en: If you have stubbed a participant consider naming it `stubbedFoo`, if it is
    acting as a mock name it `mockedFoo`. This rule is less hard than the others -
    decide on a case by case basis whether you think it makes your test more or less
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: Highlight What is Important, Hide What is Not
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should be possible to read each test case at a glance - so make things clear
    by highlighting what is important for that test case and hiding what is not.
  prefs: []
  type: TYPE_NORMAL
- en: If an aspect of the input is important to the test case, highlight it by setting
    it **explicitly** in the test case - don't rely on that value being set in a generic
    setup method.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the same value is set by default, it is better to re-supply it in the
    test so it is clearly visible.
  prefs: []
  type: TYPE_NORMAL
- en: If a particular value is not important, indicate this to the reader by using
    well-known neutral values such as `"foo"` for strings, or use clear names such
    as `someInt` or `anInt` for variables and methods that supply values.
  prefs: []
  type: TYPE_NORMAL
- en: Supplying values via a method call makes them less visible.
  prefs: []
  type: TYPE_NORMAL
- en: What is important in the test below?
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How about this version?
  prefs: []
  type: TYPE_NORMAL
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While we need additional context to understand why `3` is an invalid value,
    it should be clear that the first two parameters to the `process` method are not
    important to the behavior we are specifying.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it important that the testee below returns the enum `CONTINUE`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look through the rest of the class we might find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Other tests might not need to care about what the default state is, but this
    test does so we should write:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we start to deal with more complex domain objects, it becomes harder to separate
    the important values from the ones that are required to construct valid objects
    but not of particular interest to our test. Fortunately, we can use the builder
    pattern to ease the pain, reduce duplication, and keep the tests readable.
  prefs: []
  type: TYPE_NORMAL
- en: Name Values Meaningfully
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a value has an important meaning, make that meaning clear e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Write DAMP Test Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen, in order to highlight that a value is important to a test,
    we need to keep it within the test method that uses it. This may introduce duplication
    which we might not accept in normal code - but test code is a little different.
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste coding is bad in tests as well as production code - the more
    code there is, the harder it is to read and a change to a concern will result
    in shotgun surgery if it has been duplicated throughout the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Repetition should therefore generally be avoided in test code.
  prefs: []
  type: TYPE_NORMAL
- en: Test code **is** different from production code however.
  prefs: []
  type: TYPE_NORMAL
- en: Test code must tell more of a story - highlighting what is important and hiding
    what is not. Test code should not be as DRY ( **D**on't **R**epeat **Y**ourself
    ) as production code. It should be DAMP ( contain **D**escriptive **A**nd **M**eaningful
    **P**hrases ).
  prefs: []
  type: TYPE_NORMAL
- en: If refactoring a small amount of code out of a test method into a shared method
    hides what is happening, accept the duplication and leave it in place. If it does
    not affect readability then refactor mercilessly.
  prefs: []
  type: TYPE_NORMAL
- en: Choose the Right Assertion Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a test fails, a good assertion tells you what is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Although JUnit allows you to supply an assertion message this adds noise to
    the test. Like comments, these messages should be saved for those occasions when
    you cannot communicate using code alone.
  prefs: []
  type: TYPE_NORMAL
- en: Bad
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Good
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The built in assertions are fairly limited. Alternative assertion libraries
    such as AssertJ provide richer functionality and result in more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: Understand How To Use Mocks And Stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand How to Use Mocks and Stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two sorts of code and they require two different sorts of test.
  prefs: []
  type: TYPE_NORMAL
- en: '**Worker code** does stuff. We can test worker code with **state based testing**
    - i.e. asserting that expected values are returned from methods, or objects are
    left in expected states.'
  prefs: []
  type: TYPE_NORMAL
- en: State based testing is easily recognized as it will use assert statements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Manager code** does stuff by co-coordinating others.'
  prefs: []
  type: TYPE_NORMAL
- en: Manager code is harder to test than worker code because we need to make a choice
    - do we try to infer its behavior from its outputs using state based testing,
    or do we use **interaction based testing**?
  prefs: []
  type: TYPE_NORMAL
- en: In interaction based testing, we check that objects talk to each other in the
    expected fashion. To do this we need to somehow eavesdrop on the conversation.
    This is achieved by using objects that impersonate real ones.
  prefs: []
  type: TYPE_NORMAL
- en: Usually these are created using a mocking framework.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking Frameworks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is common to refer to all objects created by a mocking framework
    as mocks this is inaccurate.
  prefs: []
  type: TYPE_NORMAL
- en: A more correct generic term for these objects is *test double*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These can be subdivided based on how they behave:'
  prefs: []
  type: TYPE_NORMAL
- en: Dummy object - needs to be present to satisfy a type signature but is never
    actually used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stub - must be present and may supply *indirect inputs*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock - verifies that expected interactions take place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake - like a real thing but less heavy - e.g an in memory database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spy - object that records its interactions with others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these only stubs, mocks and spies might be created by a mocking framework.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about spies in a moment, but most test doubles can be conceptually
    viewed as being either a stub or a mock.
  prefs: []
  type: TYPE_NORMAL
- en: The important difference between them is that a mock has an expectation that
    will cause a test to fail if it is not met. i.e. if an expected method is not
    called on a mock the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: A stub does not care if it is called or not - its role is simply to supply values.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional Mocks present a code readability dilemma. They define an expected
    outcome (a *then*), but are also part of the fixture required for the test to
    execute (a *given*).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example with JMock we would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Spies solve this problem neatly.
  prefs: []
  type: TYPE_NORMAL
- en: Spies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spies record their interactions with other objects.
  prefs: []
  type: TYPE_NORMAL
- en: In practice this means that Spies act as stubs by default, but as mocks when
    we want them to.
  prefs: []
  type: TYPE_NORMAL
- en: The given/when/then flow becomes easy and natural to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using Mockito:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For this reason we recommend using a spy framework.
  prefs: []
  type: TYPE_NORMAL
- en: When spies act as mocks that must also supply indirect inputs, it is best to
    make them as forgiving as possible when supplying values but as specific as possible
    when verifying.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets imagine that, for some reason, the subscribers in our example had to return
    a positive integer in order for the code to execute without error. Perhaps there
    is some sort of assert statement in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We could ensure our test passed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not discuss the Mockito API in any detail here, but this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Ensures that when the `receive` method is called on the spy with a string that
    equals the `message` variable, it will return `1`.
  prefs: []
  type: TYPE_NORMAL
- en: If this line was not present the spy would do what Mockito does by default,
    which is to return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: What would our test do if, due to a bug, `receive` was called with a different
    string?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that, instead of failing due to the verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It would throw an error before it reached this point because the assertion in
    our production code would trigger.
  prefs: []
  type: TYPE_NORMAL
- en: We were too specific.
  prefs: []
  type: TYPE_NORMAL
- en: If we instead setup our spy as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The test would fail cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern of being lenient when supplying values, but specific when verifying
    also tends to result in tests that are less brittle when things change.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs in State-Based Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By definition, state-based testing will never include mocks (in the strict sense
    of the word), but they may use stubs to supply indirect values.
  prefs: []
  type: TYPE_NORMAL
- en: It can be tempting to also use a mocking framework to stub values instead of
    using their constructors and modifier methods. For complex objects using stubs
    can appear easier than constructing real ones.
  prefs: []
  type: TYPE_NORMAL
- en: Don't do this.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking frameworks should be used only to isolate our tests from objects with
    behavior. If you have values that are difficult to construct consider the test
    data builder pattern instead
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Between State and Interaction Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes there is no choice about which to use. For example, it is not possible
    to meaningfully specify how a cache should behave from its inputs and outputs
    alone. Other times we must weigh the pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: A state-based test for manager code is likely to be less easy to read and understand
    as it must rely on the behaviors of the objects the SUT interacts with. The test
    will also be coupled to these behaviors and will require changes if those behaviors
    change - you have effectively increased the size of the "unit" you are testing
    as discussed in "Think units not methods".
  prefs: []
  type: TYPE_NORMAL
- en: Interaction-based testing requires us to peek beyond the unit's external interface
    and into its implementation. This carries the risk that we might over-specify
    and create an implementation-specific test.
  prefs: []
  type: TYPE_NORMAL
- en: On balance, it is preferable to lean towards state based testing and where possible
    enable it in the design of your code. There will, however, be many situations
    in which you will decide that interaction based testing is preferable.
  prefs: []
  type: TYPE_NORMAL
- en: Understand Your Options For Code Reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand Your Options for Code Reuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reusing code is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: When people start programming in an OO language for the first time they tend
    to over-use inheritance for this purpose before discovering that composition is
    generally a better idea.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is not easy to use composition to reuse code in JUnit tests
    and this can lead you to write difficult-to-maintain test class hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: A small amount of duplication may be preferable to introducing a class hierarchy
    when other options do not exist, but some types of test can be reused without
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code related to assertions is straightforward to reuse outside of class hierarchies.
    This can be done trivially, by creating classes containing static assert methods
    that can be statically imported (as the built in JUnit assertions now are), or
    more elegantly by creating custom matchers for hamcrest or AssertJ.
  prefs: []
  type: TYPE_NORMAL
- en: Object Creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For small, simple objects, the mother pattern can be used, but this can quickly
    become a maintenance issue if the objects become more complex over time.
  prefs: []
  type: TYPE_NORMAL
- en: A better pattern is the Builder pattern, this can have the added advantage of
    allowing tests to clearly highlight important and unimportant input.
  prefs: []
  type: TYPE_NORMAL
- en: Repeated Behaviors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using JUnit then repeated section of code within a test can be packaged
    and re-used as [custom rules](https://github.com/junit-team/junit/wiki/Rules).
  prefs: []
  type: TYPE_NORMAL
- en: Write Repeatable Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write Repeatable Unit Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit tests must be repeatable and deterministic - it must be possible to run
    them thousands of times in any order and get the same result. This means that
    they must have no dependency on any external factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice this means unit tests must not:'
  prefs: []
  type: TYPE_NORMAL
- en: Read or write from databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform network IO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write to disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify static state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your test does any of these things then it is not a **unit** test. This is
    not to say that your test is not valuable.
  prefs: []
  type: TYPE_NORMAL
- en: Only Unit Test Code It Makes Sense To Unit Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only Unit Test Code That It Makes Sense to Unit Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, there is little value in unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Auto generated code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code whose **sole** concern is integration with another system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The canonical example of code with a pure integration concern is a DAO.
  prefs: []
  type: TYPE_NORMAL
- en: If a compatible in-memory fake database is available then it can be meaningfully
    unit tested against that. If no fake is available, there is no value in writing
    tests that mock out the JDBC driver - the first level of testing should instead
    be integration testing against a real database.
  prefs: []
  type: TYPE_NORMAL
- en: There is also little value in **explicitly** specifying the behavior of very
    simple boiler plate code such as get/set methods. The expected behavior is clear
    without the presence of a test and their actual behavior ought to be verified
    by other tests that use the code while testing more complex logic. If code coverage
    indicates that these methods have not been executed by other tests perhaps you
    can delete them?
  prefs: []
  type: TYPE_NORMAL
- en: Code that is not unit tested should always be integration tested.
  prefs: []
  type: TYPE_NORMAL
- en: Testing FAQS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing FAQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How Do I Test a Private Method?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't test methods (private or public), you test the behavior of a unit
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot exercise the logic of a private method via the public interface,
    is that logic actually required? If it is required, and is sufficiently complex
    that it is causing you testing pain, then perhaps you should extract that concern
    into a separate unit that can be tested in isolation and injected in via the constructor?
  prefs: []
  type: TYPE_NORMAL
- en: How Do I Test a Void Method?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't test methods (void or not), you test the behavior of a unit as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: If the method is void, it must be performing some sort of side effect that can
    be checked by either state testing or interaction testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you are trying to ''test the add method'' of collection class,
    you should probably instead be writing tests like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How do I Test Code That Reasons About the Current Date/Time?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A bad solution is to use a static method (such as joda time's `setCurrentMillisFixed`)
    to set the current date.
  prefs: []
  type: TYPE_NORMAL
- en: A good solution is to inject a strategy for retrieving the date/time into your
    class as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 provides the `java.time.Clock` class which can be used for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The static factory method `fixed` will create an instance that represents a
    constant time. Other methods provide implementations suitable for production use.
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 does not provide an out of the box class for this purpose so you will
    need to roll your own.
  prefs: []
  type: TYPE_NORMAL
- en: Do I Need to Implement a Teardown Method for my Test?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This used to be a requirement for all JUnit 3 tests. If you didn't nullify all
    members of a test class in a teardown your test suite began to eat memory as it
    grew.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a requirement for vanilla JUnit 4 tests, but it is possible that
    you may need to do so if you are using a custom runner.
  prefs: []
  type: TYPE_NORMAL
- en: What's the Difference Between Errors and Failures?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should try to design your tests to produce **failures** when the code is
    logically wrong. Your tests should only produce errors when something unexpected
    has happened.
  prefs: []
  type: TYPE_NORMAL
- en: How Should I Test for Expected Exceptions?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It depends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Is concise and suffices for simple scenarios, but has a gotcha. If the test
    method exercises more than one method of the testee, the expectation applies to
    the whole test method rather than the specific interaction with the testee that
    is expected to throw it.
  prefs: []
  type: TYPE_NORMAL
- en: If data held within the exception is important, it is also not possible to assert
    on it with this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traditional solution is to use a try catch block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is easy to follow, but a little verbose. It is also easy to forget to include
    the call to `fail()` if you are not test driving your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit now provides an alternate solution in the form of the ''ExpectedException''
    method rule. This allows for more fine grained exception checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is more concise, but breaks the usual given/when/then flow of a test by
    moving the then part to the start of the method.
  prefs: []
  type: TYPE_NORMAL
- en: For Java 8 AssertJ provides some custom assertions that can be used without
    breaking this flow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Although it maintains the flow, the lambda in which the testee is called looks
    a little ugly.
  prefs: []
  type: TYPE_NORMAL
- en: When it can be used we recommend sticking with the concise `expected =` format.
    For more complex situations it is largely a matter of taste.
  prefs: []
  type: TYPE_NORMAL
- en: How Do I Test an Abstract Class?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract class is just a dependency that some other code will use - a dependency
    that you have made harder than usual to isolate due to your choice to make it
    an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: So first off, would your design look better if the functionality was being re-used
    by composition rather than inheritance?
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you can''t improve your design by getting rid of the abstract
    class you can either:'
  prefs: []
  type: TYPE_NORMAL
- en: Treat it as an implementation detail and check that each of its clients behaves
    as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test it in isolation by creating an anonymous concrete class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first approach will result in tests that are less tied to the implementation,
    but there will be repetition between the tests for each subclass.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach will avoid repetition but is tied to the implementation
    and is likely to be brittle.
  prefs: []
  type: TYPE_NORMAL
- en: How Do I test Hashcode and Equals?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing hashcode and equals can be fiddly and time consuming, which raises questions
    about whether it is time well spent given that the code is likely to have been
    auto-generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equals verifier project provides a good (partial) solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.jqno.nl/equalsverifier/](http://www.jqno.nl/equalsverifier/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It checks that a class fulfills the hashcode-equals contract with a single
    line test that is trivial to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It does, however, do a very thorough job of checking the contract - including
    how it interacts with inheritance. It is non-trivial to make a non-final class
    conform to the contract.
  prefs: []
  type: TYPE_NORMAL
- en: Although equals verifier does a good job of checking the hashcode equals contract,
    it has no knowledge of how you expect the methods to actually behave. If you wish
    equality to (for example) be defined by a single ID field only, you must write
    additional tests that verify this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the common scenario of a class that should be considered equal based on
    all of its fields the behavior may be checked in a single test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This may become the default behavior in a future version of EqualsVerifier,
    but must be specifically specified in 1.7.5
  prefs: []
  type: TYPE_NORMAL
