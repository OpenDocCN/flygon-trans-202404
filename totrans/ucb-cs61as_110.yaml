- en: Mutable List Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutating a Pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unit 2, we used pairs as the foundation of the data structures that store
    data. We have seen that we are now walking in a realm where it's possible to mutate
    data. There will also be times when we want to mutate what is stored in our data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define x (cons 1 2))`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](/static/lab9-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '`set-car!`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let the `car` of `x` represent the number of times I fall down the stairs and
    the `cdr` of `x` represent the number of times I went to the wrong bathroom. I
    fell down a flight of stairs just now, so I should update the `car` of `x` to
    `2`. How can we achieve this without creating a new pair? Scheme allows us to
    `set!` the value of some item using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As the name suggests, `set-car!` takes in a pair and a value, and changes its
    `car` to point to the specified value of the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: '![](/static/lab9-2.png)'
  prefs: []
  type: TYPE_IMG
- en: The general form is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`set-cdr!`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might expect, Scheme also provides us with the function `set-cdr!`, which
    takes in a pair and a value, and changes the pointer of the pair's `cdr` to point
    to the value. Going with the previous example, calling
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: will change the pair as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](/static/lab9-3.png)'
  prefs: []
  type: TYPE_IMG
- en: The general syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Changing Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us see how `set-car!` and `set-cdr!` work with more complicated lists.
    We are given the following pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e9eca21e818d614542c7d11dc0a02991.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next few calls on `set-car!` and `set-cdr!` are independent and will be
    based on this original configuration. For the next few questions, drawing the
    box-pointer is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The effect of calling
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'to the original configuration will give the resulting box-and-pointer diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e8df21a04636ad2a014ee759e45a051d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The call changes the car-pointer on `x`, which initially points to `(list a
    b)`, to wherever `y` is pointing: `(list e f)`. What happens to the list with
    `a` and `b`? Nothing actually happens to it, but since it has no pointers that
    reference it, the list is no longer reachable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: In Example 1 above, what does `x` print?.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have the original configuration from Example 1, and now we decided
    to call the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What does `y` print?
  prefs: []
  type: TYPE_NORMAL
- en: Example 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the original configuration, we now call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following box-and-pointer diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/753b11755ec16e689afc20e958891000.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`x` will print `((a b) c d)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y` will print `(e f)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`z` will print `((e f) c d)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: From the configuration shown in Example 2, we now decide to call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What does `x` print now?
  prefs: []
  type: TYPE_NORMAL
- en: From the configuration shown in Example 2, what should we call so that `z` will
    return `((e f) b)`?
  prefs: []
  type: TYPE_NORMAL
- en: Creating New Pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `set-car!` and `set-cdr!` modifies existing pairs. Procedures like `cons`
    and `list` on the other hand, creates a new pair. What about `append`? Does it
    ''merge'' two lists by changing the `cdr` pointer of one of them? Remember the
    definition of `append` we have been using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`append` forms a new list by `cons`-ing elements of `x` and `y`. This tells
    us that `append` returns a new list.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](/static/lab9-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: What will the following piece of code print when entered into STk? Take an educated
    guess, then try it out in the interpreter. > (define a (list 1 2 3 4 5)) a > (set-cdr!
    (cdr a) (cdddr a)) okay > a
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `append!` is similar to `append`, but it is a mutator rather than
    a constructor. It appends the lists by splicing them together, modifying the final
    pair of `x` so that its `cdr` is now `y`. (It is an error to call `append!` with
    an empty `x`.) For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `last-pair` procedure accepts a list and returns the last pair of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What does `(cdr x)` return? Try it out by yourself before putting it into STk.
    Now, take the following call to `append!`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: What does `(cdr x)` return now?
  prefs: []
  type: TYPE_NORMAL
- en: Sharing and Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous exercises raises a big sign that knowing when a pair is shared
    and created is important. In the code above, `x` and `y` refer to the same pairs,
    while `z` makes a different pair with the same elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![](/static/lab9-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remember the `equal?` predicate? It can check if two pairs contain the same
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`(equal? x y)`, `(equal? x z)`, `(equal? y z)` all return `#t`, because they
    all hold the same elements at the same place. Is it possible to differentiate
    that `x` and `z` point to different structures? Yes! Scheme has the `eq?` predicate
    which takes 2 arguments and checks if the 2 arguments refer to the same pair.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`set-car!` and `set-cdr!` change the respective `car` and `cdr` pointers. Procedures
    like `cons`, `list`, and `append` create new pairs. Knowing which pairs are shared
    between different lists is crucial to determining whether mutating one will influence
    the other. Drawing box-and-pointer diagrams will be very helpful.'
  prefs: []
  type: TYPE_NORMAL
