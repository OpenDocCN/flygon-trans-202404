["```\n\n    Before getting started, we need to import all of our\n    definitions from the previous chapter:\n\n```", "```\n\n    For the Require Export to work, you first need to use\n    coqc to compile Basics.v into Basics.vo.  This is like\n    making a .class file from a .java file, or a .o file from a .c\n    file.  There are two ways to do it:\n\n*   In CoqIDE: \n\n     Open Basics.v. In the \"Compile\" menu, click on \"Compile Buffer\". \n\n*   From the command line: \n\n    coqc Basics.v\n\n    If you have trouble (e.g., if you get complaints about missing\n   identifiers later in the file), it may be because the \"load path\"\n   for Coq is not set up correctly.  The Print LoadPath. command may\n   be helpful in sorting out such issues.\n\n```", "```\nTheorem plus_n_O_firsttry : \u2200n:nat,\n\u00a0\u00a0n = n + 0.\n\n```", "```\nProof.\n\u00a0\u00a0intros n.\n\u00a0\u00a0simpl. (*\u00a0Does\u00a0nothing!\u00a0*)\nAbort.\n\n```", "```\nTheorem plus_n_O_secondtry : \u2200n:nat,\n\u00a0\u00a0n = n + 0.\nProof.\n\u00a0\u00a0intros n. destruct n as [| n'].\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a00\u00a0*)\n\u00a0\u00a0\u00a0\u00a0reflexivity. (*\u00a0so\u00a0far\u00a0so\u00a0good...\u00a0*)\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a0S\u00a0n'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. (*\u00a0...but\u00a0here\u00a0we\u00a0are\u00a0stuck\u00a0again\u00a0*)\nAbort.\n\n```", "```\nTheorem plus_n_O : \u2200n:nat, n = n + 0.\nProof.\n\u00a0\u00a0intros n. induction n as [| n' IHn'].\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a00\u00a0*)    reflexivity.\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a0S\u00a0n'\u00a0*) simpl. rewrite \u2190 IHn'. reflexivity. Qed.\n\n```", "```\nTheorem minus_diag : \u2200n,\n\u00a0\u00a0minus n n = 0.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros n. induction n as [| n' IHn'].\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a00\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. reflexivity.\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a0S\u00a0n'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl. rewrite \u2192 IHn'. reflexivity. Qed.\n\n```", "```\nTheorem mult_0_r : \u2200n:nat,\n\u00a0\u00a0n * 0 = 0.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem plus_n_Sm : \u2200n m : nat,\n\u00a0\u00a0S (n + m) = n + (S m).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem plus_comm : \u2200n m : nat,\n\u00a0\u00a0n + m = m + n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem plus_assoc : \u2200n m p : nat,\n\u00a0\u00a0n + (m + p) = (n + m) + p.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nFixpoint double (n:nat) :=\n\u00a0\u00a0match n with\n\u00a0\u00a0| O \u21d2 O\n\u00a0\u00a0| S n' \u21d2 S (S (double n'))\n\u00a0\u00a0end.\n\n```", "```\nLemma double_plus : \u2200n, double n = n + n .\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem evenb_S : \u2200n : nat,\n\u00a0\u00a0evenb (S n) = negb (evenb n).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Proofs Within Proofs\n\n    In Coq, as in informal mathematics, large proofs are often\n    broken into a sequence of theorems, with later proofs referring to\n    earlier theorems.  But sometimes a proof will require some\n    miscellaneous fact that is too trivial and of too little general\n    interest to bother giving it its own top-level name.  In such\n    cases, it is convenient to be able to simply state and prove the\n    needed \"sub-theorem\" right at the point where it is used.  The\n    assert tactic allows us to do this.  For example, our earlier\n    proof of the mult_0_plus theorem referred to a previous theorem\n    named plus_O_n.  We could instead use assert to state and\n    prove plus_O_n in-line:\n\n```", "```\n\n    The assert tactic introduces two sub-goals.  The first is\n    the assertion itself; by prefixing it with H: we name the\n    assertion H.  (We can also name the assertion with as just as\n    we did above with destruct and induction, i.e., assert (0 + n = n) as H.)  Note that we surround the proof of this assertion\n    with curly braces { ... }, both for readability and so that,\n    when using Coq interactively, we can see more easily when we have\n    finished this sub-proof.  The second goal is the same as the one\n    at the point where we invoke assert except that, in the context,\n    we now have the assumption H that 0 + n = n.  That is,\n    assert generates one subgoal where we must prove the asserted\n    fact and a second subgoal where we can use the asserted fact to\n    make progress on whatever we were trying to prove in the first\n    place. \n\n    Another example of assert... \n\n    For example, suppose we want to prove that (n + m) + (p + q) = (m + n) + (p + q). The only difference between the two sides of\n    the = is that the arguments m and n to the first inner +\n    are swapped, so it seems we should be able to use the\n    commutativity of addition (plus_comm) to rewrite one into the\n    other.  However, the rewrite tactic is not very smart about\n    *where* it applies the rewrite.  There are three uses of + here,\n    and it turns out that doing rewrite \u2192 plus_comm will affect\n    only the *outer* one...\n\n```", "```\n\n    To use plus_comm at the point where we need it, we can introduce\n    a local lemma stating that n + m = m + n (for the particular m\n    and n that we are talking about here), prove this lemma using\n    plus_comm, and then use it to do the desired rewrite.\n\n```", "```\n\n# Formal vs. Informal Proof\n\n      \"*Informal proofs are algorithms; formal proofs are code*.\"\n\n    What constitutes a successful proof of a mathematical claim?\n    The question has challenged philosophers for millennia, but a\n    rough and ready definition could be this: A proof of a\n    mathematical proposition P is a written (or spoken) text that\n    instills in the reader or hearer the certainty that P is true \u2014\n    an unassailable argument for the truth of P.  That is, a proof\n    is an act of communication.\n\n    Acts of communication may involve different sorts of readers.  On\n    one hand, the \"reader\" can be a program like Coq, in which case\n    the \"belief\" that is instilled is that P can be mechanically\n    derived from a certain set of formal logical rules, and the proof\n    is a recipe that guides the program in checking this fact.  Such\n    recipes are *formal* proofs.\n\n    Alternatively, the reader can be a human being, in which case the\n    proof will be written in English or some other natural language,\n    and will thus necessarily be *informal*.  Here, the criteria for\n    success are less clearly specified.  A \"valid\" proof is one that\n    makes the reader believe P.  But the same proof may be read by\n    many different readers, some of whom may be convinced by a\n    particular way of phrasing the argument, while others may not be.\n    Some readers may be particularly pedantic, inexperienced, or just\n    plain thick-headed; the only way to convince them will be to make\n    the argument in painstaking detail.  But other readers, more\n    familiar in the area, may find all this detail so overwhelming\n    that they lose the overall thread; all they want is to be told the\n    main ideas, since it is easier for them to fill in the details for\n    themselves than to wade through a written presentation of them.\n    Ultimately, there is no universal standard, because there is no\n    single way of writing an informal proof that is guaranteed to\n    convince every conceivable reader.\n\n    In practice, however, mathematicians have developed a rich set of\n    conventions and idioms for writing about complex mathematical\n    objects that \u2014 at least within a certain community \u2014 make\n    communication fairly reliable.  The conventions of this stylized\n    form of communication give a fairly clear standard for judging\n    proofs good or bad.\n\n    Because we are using Coq in this course, we will be working\n    heavily with formal proofs.  But this doesn't mean we can\n    completely forget about informal ones!  Formal proofs are useful\n    in many ways, but they are *not* very efficient ways of\n    communicating ideas between human beings. \n\n    For example, here is a proof that addition is associative:\n\n```", "```\n\n    Coq is perfectly happy with this.  For a human, however, it\n    is difficult to make much sense of it.  We can use comments and\n    bullets to show the structure a little more clearly...\n\n```", "```\n\n    ... and if you're used to Coq you may be able to step\n    through the tactics one after the other in your mind and imagine\n    the state of the context and goal stack at each point, but if the\n    proof were even a little bit more complicated this would be next\n    to impossible.\n\n    A (pedantic) mathematician might write the proof something like\n    this: \n\n*   *Theorem*: For any n, m and p, \n\n    ```", "```\n        \u00a0\u00a00\u00a0+\u00a0(m\u00a0+\u00a0p)\u00a0=\u00a0(0\u00a0+\u00a0m)\u00a0+\u00a0p.\n\n         This follows directly from the definition of +. \n\n        ```", "```\n        \u00a0\u00a0n'\u00a0+\u00a0(m\u00a0+\u00a0p)\u00a0=\u00a0(n'\u00a0+\u00a0m)\u00a0+\u00a0p.\n\n         We must show \n\n        ```", "```\n        \u00a0\u00a0S\u00a0(n'\u00a0+\u00a0(m\u00a0+\u00a0p))\u00a0=\u00a0S\u00a0((n'\u00a0+\u00a0m)\u00a0+\u00a0p),\n\n         which is immediate from the induction hypothesis. *Qed*.\n        ```", "```\n\n        ```", "```\n\n    The overall form of the proof is basically similar, and of\n    course this is no accident: Coq has been designed so that its\n    induction tactic generates the same sub-goals, in the same\n    order, as the bullet points that a mathematician would write.  But\n    there are significant differences of detail: the formal proof is\n    much more explicit in some ways (e.g., the use of reflexivity)\n    but much less explicit in others (in particular, the \"proof state\"\n    at any given point in the Coq proof is completely implicit,\n    whereas the informal proof reminds the reader several times where\n    things stand). \n\n#### Exercise: 2 stars, advanced, recommendedM (plus_comm_informal)\n\n    Translate your solution for plus_comm into an informal proof:\n\n    Theorem: Addition is commutative.\n\n    Proof: (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610 \n\n#### Exercise: 2 stars, optionalM (beq_nat_refl_informal)\n\n    Write an informal proof of the following theorem, using the\n    informal proof of plus_assoc as a model.  Don't just\n    paraphrase the Coq tactics into English!\n\n    Theorem: true = beq_nat n n for any n.\n\n    Proof: (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610\n\n```", "```\nTheorem plus_swap : \u2200n m p : nat,\n\u00a0\u00a0n + (m + p) = m + (n + p).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem mult_comm : \u2200m n : nat,\n\u00a0\u00a0m * n = n * m.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem leb_refl : \u2200n:nat,\n\u00a0\u00a0true = leb n n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem zero_nbeq_S : \u2200n:nat,\n\u00a0\u00a0beq_nat 0 (S n) = false.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem andb_false_r : \u2200b : bool,\n\u00a0\u00a0andb b false = false.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem plus_ble_compat_l : \u2200n m p : nat,\n\u00a0\u00a0leb n m = true \u2192 leb (p + n) (p + m) = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem S_nbeq_0 : \u2200n:nat,\n\u00a0\u00a0beq_nat (S n) 0 = false.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem mult_1_l : \u2200n:nat, 1 * n = n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem all3_spec : \u2200b c : bool,\n\u00a0\u00a0\u00a0\u00a0orb\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(andb b c)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(orb (negb b)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(negb c))\n\u00a0\u00a0= true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem mult_plus_distr_r : \u2200n m p : nat,\n\u00a0\u00a0(n + m) * p = (n * p) + (m * p).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem mult_assoc : \u2200n m p : nat,\n\u00a0\u00a0n * (m * p) = (n * m) * p.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem beq_nat_refl : \u2200n : nat,\n\u00a0\u00a0true = beq_nat n n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem plus_swap' : \u2200n m p : nat,\n\u00a0\u00a0n + (m + p) = m + (n + p).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0incr\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bin\u00a0---------------------->\u00a0bin\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\n\u00a0\u00a0\u00a0\u00a0bin_to_nat\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0bin_to_nat\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0v\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nat\u00a0---------------------->\u00a0nat\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S\n\n    That is, incrementing a binary number and then converting it to\n    a (unary) natural number yields the same result as first converting\n    it to a natural number and then incrementing.\n    Name your theorem bin_to_nat_pres_incr (\"pres\" for \"preserves\").\n\n    Before you start working on this exercise, copy the definitions\n    from your solution to the binary exercise here so that this file\n    can be graded on its own.  If you want to change your original\n    definitions to make the property easier to prove, feel free to\n    do so!\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 5 stars, advancedM (binary_inverse)\n\n    This exercise is a continuation of the previous exercise about\n    binary numbers.  You will need your definitions and theorems from\n    there to complete this one; please copy them to this file to make\n    it self contained for grading.\n\n    (a) First, write a function to convert natural numbers to binary\n        numbers.  Then prove that starting with any natural number,\n        converting to binary, then converting back yields the same\n        natural number you started with.\n\n    (b) You might naturally think that we should also prove the\n        opposite direction: that starting with a binary number,\n        converting to a natural, and then back to binary yields the\n        same number we started with.  However, this is not true!\n        Explain what the problem is.\n\n    (c) Define a \"direct\" normalization function \u2014 i.e., a function\n        normalize from binary numbers to binary numbers such that,\n        for any binary number b, converting to a natural and then back\n        to binary yields (normalize b).  Prove it.  (Warning: This\n        part is tricky!)\n\n    Again, feel free to change your earlier definitions if this helps\n    here.\n\n```", "```\n\n    \u2610 \n\n```", "```\n\n```", "```\n\n```"]