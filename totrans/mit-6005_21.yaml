- en: 'Reading 21: Sockets & Networking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this reading we examine *client/server communication* over the network using
    the *socket* abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Network communication is inherently concurrent, so building clients and servers
    will require us to reason about their concurrent behavior and to implement them
    with thread safety. We must also design the *wire protocol* that clients and servers
    use to communicate, just as we design the operations that clients of an ADT use
    to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the operations with sockets are *blocking*: they block the progress
    of a thread until they can return a result. Blocking makes writing some code easier,
    but it also foreshadows a new class of concurrency bugs we’ll soon contend with
    in depth: deadlocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Client/server design pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this reading (and in the problem set) we explore the **client/server design
    pattern** for communication with message passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this pattern there are two kinds of processes: clients and servers. A client
    initiates the communication by connecting to a server. The client sends requests
    to the server, and the server sends replies back. Finally, the client disconnects.
    A server might handle connections from many clients concurrently, and clients
    might also connect to multiple servers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many Internet applications work this way: web browsers are clients for web
    servers, an email program like Outlook is a client for a mail server, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: On the Internet, client and server processes are often running on different
    machines, connected only by the network, but it doesn’t have to be that way —
    the server can be a process running on the same machine as the client.
  prefs: []
  type: TYPE_NORMAL
- en: Network sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IP addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A network interface is identified by an [IP address](http://en.wikipedia.org/wiki/IP_address).
    IPv4 addresses are 32-bit numbers written in four 8-bit parts. For example (as
    of this writing):'
  prefs: []
  type: TYPE_NORMAL
- en: '`18.9.22.69` is the IP address of a MIT web server. Every address whose [first
    octet is `18`](http://en.wikipedia.org/wiki/List_of_assigned_/8_IPv4_address_blocks)
    is on the MIT network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`18.9.25.15` is the address of a MIT incoming email handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`173.194.123.40` is the address of a Google web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`127.0.0.1` is the [loopback](http://en.wikipedia.org/wiki/Loopback) or [localhost](http://en.wikipedia.org/wiki/Localhost)
    address: it always refers to the local machine. Technically, any address whose
    first octet is `127` is a loopback address, but `127.0.0.1` is standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can [ask Google for your current IP address](https://www.google.com/search?q=my+ip).
    In general, as you carry around your laptop, every time you connect your machine
    to the network it can be assigned a new IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Hostnames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Hostnames](http://en.wikipedia.org/wiki/Hostname) are names that can be translated
    into IP addresses. A single hostname can map to different IP addresses at different
    times; and multiple hostnames can map to the same IP address. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`web.mit.edu` is the name for MIT’s web server. You can translate this name
    to an IP address yourself using `dig`, `host`, or `nslookup` on the command line,
    e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`dmz-mailsec-scanner-4.mit.edu` is the name for one of MIT’s spam filter machines
    responsible for handling incoming email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google.com` is exactly what you think it is. Try using one of the commands
    above to find `google.com`’s IP address. What do you see?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost` is a name for `127.0.0.1`. When you want to talk to a server running
    on your own machine, talk to `localhost`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translation from hostnames to IP addresses is the job of the [Domain Name System
    (DNS)](http://en.wikipedia.org/wiki/Domain_Name_System). It’s super cool, but
    not part of our discussion today.
  prefs: []
  type: TYPE_NORMAL
- en: Port numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A single machine might have multiple server applications that clients wish to
    connect to, so we need a way to direct traffic on the same network interface to
    different processes.
  prefs: []
  type: TYPE_NORMAL
- en: Network interfaces have multiple [ports](http://en.wikipedia.org/wiki/Port_(computer_networking))
    identified by a 16-bit number from 0 (which is reserved, so we effectively start
    at 1) to 65535.
  prefs: []
  type: TYPE_NORMAL
- en: 'A server process binds to a particular port — it is now **listening** on that
    port. Clients have to know which port number the server is listening on. There
    are some [well-known ports](http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports)
    which are reserved for system-level processes and provide standard ports for certain
    services. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Port 22 is the standard SSH port. When you connect to `athena.dialup.mit.edu`
    using SSH, the software automatically uses port 22.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port 25 is the standard email server port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port 80 is the standard web server port. When you connect to the URL `http://web.mit.edu`
    in your web browser, it connects to `18.9.22.69` on port 80.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the port is not a standard port, it is specified as part of the address.
    For example, the URL `http://128.2.39.10:9000` refers to port 9000 on the machine
    at `128.2.39.10`.
  prefs: []
  type: TYPE_NORMAL
- en: When a client connects to a server, that outgoing connection also uses a port
    number on the client’s network interface, usually chosen at random from the available
    *non*-well-known ports.
  prefs: []
  type: TYPE_NORMAL
- en: Network sockets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A [**socket**](http://en.wikipedia.org/wiki/Network_socket) represents one end
    of the connection between client and server.
  prefs: []
  type: TYPE_NORMAL
- en: A **listening socket** is used by a server process to wait for connections from
    remote clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, use [`ServerSocket`](http://docs.oracle.com/javase/8/docs/api/?java/net/ServerSocket.html)
    to make a listening socket, and use its [`accept`](http://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html#accept--)
    method to listen to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A **connected socket** can send and receive messages to and from the process
    on the other end of the connection. It is identified by both the local IP address
    and port number plus the remote address and port, which allows a server to differentiate
    between concurrent connections from different IPs, or from the same IP on different
    remote ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, clients use a [`Socket`](http://docs.oracle.com/javase/8/docs/api/?java/net/Socket.html)
    constructor to establish a socket connection to a server. Servers obtain a connected
    socket as a `Socket` object returned from `ServerSocket.accept`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data that clients and servers exchange over the network is sent in chunks.
    These are rarely just byte-sized chunks, although they might be. The sending side
    (the client sending a request or the server sending a response) typically writes
    a large chunk (maybe a whole string like “HELLO, WORLD!” or maybe 20 megabytes
    of video data). The network chops that chunk up into packets, and each packet
    is routed separately over the network. At the other end, the receiver reassembles
    the packets together into a stream of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The result is a bursty kind of data transmission — the data may already be there
    when you want to read them, or you may have to wait for them to arrive and be
    reassembled.
  prefs: []
  type: TYPE_NORMAL
- en: When data arrive, they go into a **buffer**, an array in memory that holds the
    data until you read it.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Client server socket buffer*
  prefs: []
  type: TYPE_NORMAL
- en: You’re developing a new web server program on your own laptop. You start the
    server running on port 8080.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the blanks for the URL you should visit in your web browser to talk
    to your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <select class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(missing
    answer)<select class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(missing
    answer)<select class="form-control"><option>80</option>,<option>8080</option>,<option>http</option>,<option>localhost</option>,<option>loopback</option>,<option>web-server</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Address hostname network stuffer*(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: '* see [***What if Dr. Seuss Did Technical Writing?***](http://web.mit.edu/adorai/www/seuss-technical-writing.html),
    although the issue described in the first stanza is no longer relevant with the
    obsolescence of floppy disk drives'
  prefs: []
  type: TYPE_NORMAL
- en: Streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data going into or coming out of a socket is a [**stream**](http://en.wikipedia.org/wiki/Stream_(computing))
    of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, [`InputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/InputStream.html)
    objects represent sources of data flowing into your program. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a file on disk with a [`File­Input­Stream`](http://docs.oracle.com/javase/8/docs/api/?java/io/FileInputStream.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User input from [`System.in`](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#in)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input from a network socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`OutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/OutputStream.html)
    objects represent data sinks, places we can write data to. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`FileOutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/FileOutputStream.html)
    for saving to files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`System.out`](http://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out)
    is a [`PrintStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/PrintStream.html),
    an `OutputStream` that prints readable representations of various types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output to a network socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Java Tutorials, read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[I/O Streams](http://docs.oracle.com/javase/tutorial/essential/io/streams.html)
    up to and including *I/O from the Command Line* (8 pages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With sockets, remember that the *output* of one process is the *input* of another
    process. If Alice and Bob have a socket connection, Alice has an output stream
    that flows to Bob’s input stream, and *vice versa*.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Blocking** means that a thread waits (without doing further work) until an
    event occurs. We can use this term to describe methods and method calls: if a
    method is a **blocking method**, then a call to that method can **block**, waiting
    until some event occurs before it returns to the caller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Socket input/output streams exhibit blocking behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: When an incoming socket’s buffer is empty, calling `read` blocks until data
    are available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the destination socket’s buffer is full, calling `write` blocks until space
    is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking is very convenient from a programmer’s point of view, because the programmer
    can write code as if the `read` (or `write`) call will always work, no matter
    what the timing of data arrival. If data (or for `write`, space) is already available
    in the buffer, the call might return very quickly. But if the read or write can’t
    succeed, the call **blocks**. The operating system takes care of the details of
    delaying that thread until `read` or `write` *can* succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking happens throughout concurrent programming, not just in [I/O](http://en.wikipedia.org/wiki/Input/output)
    (communication into and out of a process, perhaps over a network, or to/from a
    file, or with the user on the command line or a GUI, …). Concurrent modules don’t
    work in lockstep, like sequential programs do, so they typically have to wait
    for each other to catch up when coordinated action is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll see in the next reading that this waiting gives rise to the second major
    kind of bug (the first was race conditions) in concurrent programming: **deadlock**,
    where modules are waiting for each other to do something, so none of them can
    make any progress. But that’s for next time.'
  prefs: []
  type: TYPE_NORMAL
- en: Using network sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure you’ve read about [streams](#streams) at the Java Tutorial link above,
    then read about network sockets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Java Tutorials, read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[All About Sockets](http://docs.oracle.com/javase/tutorial/networking/sockets/index.html)
    (4 pages)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This reading describes everything you need to know about creating server- and
    client-side sockets and writing to and reading from their I/O streams.
  prefs: []
  type: TYPE_NORMAL
- en: On the second page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The example uses a syntax we haven’t seen: the [try-with-resources](http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)
    statement. This statement has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: On the last page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice how both `ServerSocket.accept()` and `in.readLine()` are *blocking*.
    This means that the server will need a *new thread* to handle I/O with each new
    client. While the client-specific thread is working with that client (perhaps
    blocked in a read or a write), another thread (perhaps the main thread) is blocked
    waiting to `accept` a new connection.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, their multithreaded Knock Knock Server implementation creates
    that new thread by *subclassing `Thread`*. That’s *not* the recommended strategy.
    Instead, create a new class that implements `Runnable`, or [use an anonymous `Runnable`](../19-concurrency/anonymous-runnable/)
    that calls a method where that client connection will be handled until it’s closed.
    Don’t use ~~`extends Thread`~~. And while subclassing was popular when the Java
    API was designed, we don’t discuss or recommend it at all because it has many
    downsides.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Network sockets 1
  prefs: []
  type: TYPE_NORMAL
- en: Alice has a connected socket with Bob. How does she send a message to Bob?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Network sockets 2
  prefs: []
  type: TYPE_NORMAL
- en: Which of these is it necessary for a client to know in order to connect to and
    communicate with a server?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Echo echo echo echo
  prefs: []
  type: TYPE_NORMAL
- en: In the [EchoClient](http://docs.oracle.com/javase/tutorial/displayCode.html?code=http://docs.oracle.com/javase/tutorial/networking/sockets/examples/EchoClient.java)
    example, which of these might *block*?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: And in [EchoServer](http://docs.oracle.com/javase/tutorial/displayCode.html?code=http://docs.oracle.com/javase/tutorial/networking/sockets/examples/EchoServer.java),
    which of these might *block*?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Block block block block
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `BufferedReader.readLine()` is a *blocking* method, which of these is
    true:'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Wire protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have our client and server connected up with sockets, what do they
    pass back and forth over those sockets?
  prefs: []
  type: TYPE_NORMAL
- en: A **protocol** is a set of messages that can be exchanged by two communicating
    parties. A **wire protocol** in particular is a set of messages represented as
    byte sequences, like `hello world` and `bye` (assuming we’ve agreed on a way to
    encode those characters into bytes).
  prefs: []
  type: TYPE_NORMAL
- en: Many Internet applications use simple ASCII-based wire protocols. You can use
    a program called Telnet to check them out.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`telnet` is a utility that allows you to make a direct network connection to
    a listening server and communicate with it via a terminal interface. Linux and
    Mac OS X should have `telnet` installed by default.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows users should first check if telnet is installed by running the command
    `telnet` on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have `telnet`, you can install it via Control Panel → Programs
    and Features → Turn Windows features on/off → Telnet client. However, this version
    of `telnet` may be very hard to use. If it does not show you what you’re typing,
    you will need to [turn on the `localecho` option](https://technet.microsoft.com/en-us/library/c.aspx).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A better alternative is PuTTY: [download `putty.exe`](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).
    To connect using PuTTY, enter a hostname and port, select Connection type: Raw,
    and Close window on exit: Never. The last option will prevent the window from
    disappearing as soon as the server closes its end of the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at some examples of wire protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Hypertext Transfer Protocol (HTTP)](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)
    is the language of the World Wide Web. We already know that port 80 is the well-known
    port for speaking HTTP to web servers, so let’s talk to one on the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll be using Telnet on the problem set, so try these out now. User input
    is shown in **green**, and for input to the telnet connection, newlines (pressing
    enter) are shown with **↵**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `GET` command gets a web page. The `/` is the path of the page you want
    on the site. So this command fetches the page at `http://www.eecs.mit.edu:80/`.
    Since 80 is the default port for HTTP, this is equivalent to visiting [http://www.eecs.mit.edu/](http://www.eecs.mit.edu/)
    in your web browser. The result is HTML code that your browser renders to display
    the EECS homepage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internet protocols are defined by [RFC specifications](http://en.wikipedia.org/wiki/Request_for_Comments)
    (RFC stands for “request for comment”, and some RFCs are eventually adopted as
    standards). [RFC 1945](http://tools.ietf.org/html/rfc1945) defined HTTP version
    1.0, and was superseded by HTTP 1.1 in [RFC 2616](http://tools.ietf.org/html/rfc2616).
    So for many web sites, you might need to speak HTTP 1.1 if you want to talk to
    them. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time, your request must end with a blank line. HTTP version 1.1 requires
    the client to specify some extra information (called headers) with the request,
    and the blank line signals the end of the headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also more than likely find that telnet does not exit after making
    this request — this time, the server keeps the connection open so you can make
    another request right away. To quit Telnet manually, type the escape character
    (probably `Ctrl`-`]`) to bring up the `telnet>` prompt, and type `quit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: SMTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Simple Mail Transfer Protocol (SMTP)](http://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol)
    is the protocol for sending email (different protocols are used for client programs
    that retrieve email from your inbox). Because the email system was designed in
    a time before spam, modern email communication is fraught with traps and heuristics
    designed to prevent abuse. But we can still try to speak SMTP. Recall that the
    well-known SMTP port is 25, and `dmz-mailsec-scanner-4.mit.edu` was the name of
    a MIT email handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to fill in *your-IP-address-here* and *your-username-here*, and
    the ↵ indicate newlines for clarity. This will only work if you’re on MITnet,
    and even then your mail might be rejected for looking suspicious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: SMTP is quite chatty in comparison to HTTP, providing some human-readable instructions
    like `continue. finished with "\r\n.\r\n"` to tell us how to terminate our message
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a wire protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When designing a wire protocol, apply the same rules of thumb you use for designing
    the operations of an abstract data type:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the number of different messages **small**. It’s better to have a few commands
    and responses that can be combined rather than many complex messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each message should have a well-defined purpose and **coherent** behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set of messages must be **adequate** for clients to make the requests they
    need to make and for servers to deliver the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as we demand representation independence from our types, we should aim
    for **platform-independence** in our protocols. HTTP can be spoken by any web
    server and any web browser on any operating system. The protocol doesn’t say anything
    about how web pages are stored on disk, how they are prepared or generated by
    the server, what algorithms the client will use to render them, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also apply the three big ideas in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protocol should be easy for clients and servers to generate and parse. Simpler
    code for reading and writing the protocol (whether written with a parser generator
    like ANTLR, with regular expressions, etc.) will have fewer opportunities for
    bugs.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the ways a broken or malicious client or server could stuff garbage
    data into the protocol to break the process on the other end.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Email spam is one example: when we spoke SMTP above, the mail server asked
    *us* to say who was sending the email, and there’s nothing in SMTP to prevent
    us from lying outright. We’ve had to build systems on top of SMTP to try to stop
    spammers who lie about `From:` addresses.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Security vulnerabilities are a more serious example. For example, protocols
    that allow a client to send requests with arbitrary amounts of data require careful
    handling on the server to avoid running out of buffer space, [or worse](http://en.wikipedia.org/wiki/Buffer_overflow).
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Easy to understand**: for example, choosing a text-based protocol means that
    we can debug communication errors by reading the text of the client/server exchange.
    It even allows us to speak the protocol “by hand” as we saw above.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change**: for example, HTTP includes the ability to specify a version
    number, so clients and servers can agree with one another which version of the
    protocol they will use. If we need to make changes to the protocol in the future,
    older clients or servers can continue to work by announcing the version they will
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[**Serialization**](http://en.wikipedia.org/wiki/Serialization) is the process
    of transforming data structures in memory into a format that can be easily stored
    or transmitted (not the same as [serializability from *Thread Safety*](../20-thread-safety/#serializability)).
    Rather than invent a new format for serializing your data between clients and
    servers, use an existing one. For example, [JSON (JavaScript Object Notation)](http://en.wikipedia.org/wiki/JSON)
    is a simple, widely-used format for serializing basic values, arrays, and maps
    with string keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a wire protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to precisely define for clients & servers what messages are allowed
    by a protocol, use a grammar.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a very small part of the HTTP 1.1 request grammar from
    [RFC 2616 section 5](http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the grammar, we can see that in this example request from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`GET` is the `method`: we’re asking the server to get a page for us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/aboutmit/` is the `request-uri`: the description of what we want to get.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP/1.1` is the `http-version`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Host: web.mit.edu` is some kind of header — we would have to examine the rules
    for each of the `...-header` options to discover which one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And we can see why we had to end the request with a blank line: since a single
    `request` can have multiple headers that end in CRLF (newline), we have another
    CRLF at the end to finish the `request`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t have any `message-body` — and since the server didn’t wait to see if
    we would send one, presumably that only applies for other kinds of requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The grammar is not enough: it fills a similar role to method signatures when
    defining an ADT. We still need the specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What are the preconditions of a message?** For example, if a particular field
    in a message is a string of digits, is any number valid? Or must it be the ID
    number of a record known to the server?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under what circumstances can a message be sent? Are certain messages only valid
    when sent in a certain sequence?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**What are the postconditions?** What action will the server take based on
    a message? What server-side data will be mutated? What reply will the server send
    back to the client?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Wire protocols 1
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following tools could you use to speak HTTP with a web server?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Wire protocols 2
  prefs: []
  type: TYPE_NORMAL
- en: Consider this example wire protocol, specified using two grammars…
  prefs: []
  type: TYPE_NORMAL
- en: '**Messages from the client to the server**'
  prefs: []
  type: TYPE_NORMAL
- en: The client can turn lights, identified by numerical IDs, on and off. The client
    can also request help.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Messages from the server to the client**'
  prefs: []
  type: TYPE_NORMAL
- en: The server can report the status of the lights and provides arbitrary help messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use ↵ to represent a newline.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Testing client/server code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that [concurrency is hard to test and debug](../19-concurrency/#concurrency_is_hard_to_test_and_debug).
    We can’t reliably reproduce race conditions, and the network adds a source of
    latency that is entirely beyond our control. You need to design for concurrency
    and argue carefully for the correctness of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Separate network code from data structures and algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the ADTs in your client/server program don’t need to rely on networking.
    Make sure you specify, test, and implement them as separate components that are
    safe from bugs, easy to understand, and ready for change — in part because they
    don’t involve any networking code.
  prefs: []
  type: TYPE_NORMAL
- en: If those ADTs will need to be used concurrently from multiple threads (for example,
    threads handling different client connections), our next reading will discuss
    your options. Otherwise, use the [thread safety strategies of confinement, immutability,
    and existing threadsafe data types](../20-thread-safety/).
  prefs: []
  type: TYPE_NORMAL
- en: Separate socket code from stream code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function or module that needs to read from and write to a socket may only
    need access to the input/output streams, not to the socket itself. This design
    allows you to test the module by connecting it to streams that don’t come from
    a socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two useful Java classes for this are [`ByteArray­InputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/ByteArrayInputStream.html)
    and [`ByteArray­OutputStream`](http://docs.oracle.com/javase/8/docs/api/?java/io/ByteArrayOutputStream.html).
    Suppose we want to test this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The method is normally used with a socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the case conversion is a function we implement, it should already be specified,
    tested, and implemented separately. But now we can also test the read/write behavior
    of `upperCaseLine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, `inBytes` and `outBytes` are [**test stubs**](../03-testing/#unit_testing_and_stubs).
    To isolate and test just `upperCaseLine`, we replace the components it normally
    depends on (input/output streams from a socket) with components that satisfy the
    same spec but have canned behavior: an input stream with fixed input, and an output
    stream that stores the output in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing strategies for more complex modules might use a **mock object** to simulate
    the behavior of a real client or server by producing entire canned sequences of
    interaction and asserting the correctness of each message received from the other
    component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *client/server design pattern*, concurrency is inevitable: multiple
    clients and multiple servers are connected on the network, sending and receiving
    messages simultaneously, and expecting timely replies. A server that *blocks*
    waiting for one slow client when there are other clients waiting to connect to
    it or to receive replies will not make those clients happy. At the same time,
    a server that performs incorrect computations or returns bogus results because
    of concurrent modification to shared mutable data by different clients will not
    make anyone happy.'
  prefs: []
  type: TYPE_NORMAL
- en: All the challenges of making our multi-threaded code **safe from bugs**, **easy
    to understand**, and **ready for change** apply when we design network clients
    and servers. These processes run concurrently with one another (often on different
    machines), and any server that wants to talk to multiple clients concurrently
    (or a client that wants to talk to multiple servers) must manage that multi-threaded
    communication.
  prefs: []
  type: TYPE_NORMAL
