["```\nstring s = read_file();\nfor (int i = 0; i < s.size(); ++i) {\n  //...\n} \n```", "```\nstring s = read_file();\nfor (string::iterator i = s.begin(); i != s.end(); ++i) {\n  string::difference_type idx = std::distance(s.begin(), i);\n  //...\n} \n```", "```\nlet v1 = 1000;\nlet v2 : u32 = 25;\nlet v3 = 126i8; \n```", "```\nlet v1 = 1000u32;\nlet v2: u16 = v1 as u16; \n```", "```\n#include <math.h>\n\nconst double PI = 3.1415927;\ndouble result = cos(45.0 * PI / 180.0);\n//..\ndouble result2 = abs(-124.77);\n//..\nfloat result3 = sqrtf(9.0f);\n//\nlong double result4 = powl(9,10); \n```", "```\n#include <cmath>\nfloat result = std::sqrt(9.0f); \n```", "```\nlet v1 = 10.0;\nlet v2 = 99.99f32;\nlet v3 = -10e4f64; \n```", "```\nlet result = 10.0f32.sqrt();\n//\nlet degrees = 45.0f64;\nlet result2 = angle.to_radians().cos(); \n```", "```\n!false == true\n!true == false \n```", "```\n// A function that doesn't return anything\nvoid delete_directory(const std::string &path);\n\n// Indeterminate pointer use\nstruct file_stat {\n  uint32_t creation_date;\n  uint32_t last_modified;\n  char file_name[MAX_PATH + 1];\n};\n\n// malloc returns a void * which must be cast to the type need\nfile_stat *s = (file_stat *) malloc(sizeof(file_stat));\n// But casting is not required when going back to void *\nfree(s); \n```", "```\nfn do_action() -> Result<(), String> {\n //...\n Result::Ok(())\n}\n\nlet result = do_action();\nif result.is_ok() {\n println!(\"Success!\");\n} \n```", "```\nenum Void {} \n```", "```\nstd::tuple<std::string, int> v1 = std::make_tuple(\"Sally\", 25);\n//\nstd::cout << \"Name = \" << std::get<0>(v1)\n          << \", age = \" << std::get<1>(v1) << std::endl; \n```", "```\nlet v1 = (\"Sally\", 25);\nprintln!(\"Name = {}, age = {}\", v1.0, v1.1); \n```", "```\nlet (x, y, _) = calculate_coords();\nprintln!(\"x = {}, y = {}\", x, y);\n//...\npub fn calculate_coords() -> (i16, i16, i16) {\n  (11, 200, -33)\n} \n```", "```\nlet protected_service: Arc<Mutex<ProtectedService>> = Arc::new(Mutex::new(ProtectedService::new()));\n//...\nlet (host, port, url) = {\n  // Lock and acquire access to ProtectedService\n  let protected_service = protected_service.lock().unwrap();\n  let host = protected_service.host();\n  let port = protected_service.port();\n  let url = protected_service.url();\n  (host, port, url)\n} \n```", "```\n// Stack\ndouble values[100];\n// Heap\ndouble *values = new double[100];\ndelete []values;\n// C99 style brace enclosed lists\ndouble values[100] = {0}; // Set all to 0\ndouble values[100] = {1, 2, 3}; // 1,2,3,0,0,0,0...\n// C99 with designator\ndouble values[100] = {1, 2, 3, [99] 99}; // 1,2,3,0,0,0,...,0,99 \n```", "```\n// Stack\nlet mut values = [0f64; 100]; // 100 elements \nlet mut values = [1f64, 2f64, 3f64]; // 3 elements 1,2,3\n// Heap\nlet mut values = Box::new([0f64; 100]); \n```", "```\nlet array = [\"Mary\", \"Sue\", \"Bob\", \"Michael\"];\nprintln!(\"{:?}\", array);\nlet slice = &array[2..];\nprintln!(\"{:?}\", slice); \n```", "```\n[\"Mary\", \"Sue\", \"Bob\", \"Michael\"]\n[\"Bob\", \"Michael\"] \n```", "```\n// C++11\nstd::array<Element, 100> elements;\nstd::cout << \"Size of array = \" << elements.size() << std::endl; \n```", "```\nconst size_t num_elements = 1024;\nchar buffer[num_elements];\n//...\n// fill_buffer needs to be told how many elements there are\nfill_buffer(buffer, num_elements); \n```", "```\nElement elements[100];\n//...\nint num_elements = sizeof(elements) / sizeof(Element); \n```", "```\nlet buffer: [u8; 1024]\nprintln!(\"Buffer length = {}\", buffer.len());\n\nfill_buffer(&buffer[0..10]);\n//...\nfn fill_buffer(elements: &[Element]) {\n  println!(\"Number of elements = {}\", elements.len());\n} \n```", "```\n// The array that my_string points at ends with a hidden \\0\nchar *my_string = \"This is as close to a string primitive as you can get\"; \n```", "```\n// The traditional way\nchar *my_str = \"Hello\"; // Terminates with \\0\n// or\nchar my_str[] = \"Hello\"; // Terminates with \\0\n// or wide string with L prefix\nwchar_t hello_chinese = L\"\\u4f60\\u597d\";\n// C11 and C++11 add UTF string literal prefixes\nauto hello_8  = u8\"\\u4f60\\u597d\"; // UTF-8 encoded\nauto hello_16 =  u\"\\u4f60\\u597d\"; // UTF-16\nauto hello_32 =  U\"\\u4f60\\u597d\"; // UTF-32 \n```", "```\nlet my_str = \"Hello\";\nlet hello_chinese = \"\u4f60\u597d\"; \n```", "```\nlet my_str = \"Hello\"; // v is a &\u2019static str\nprintln!(\"My string is {} and it is {} bytes long\", v, v.len()); \n```", "```\nlet my_str = \"\u4f60\u597d\";\nprintln!(\"Number of bytes = {}\", my_str.len());\nprintln!(\"Number of chars = {}\", my_str.chars().count()); \n```", "```\nNumber of bytes = 6\nNumber of chars = 2 \n```", "```\nlet (part1, part2) = \"Hello\".split_at(3);\nprintln!(\"Part 1 = {}\", part1);\nprintln!(\"Part 2 = {}\", part2); \n```", "```\nPart 1 = Hel\nPart 2 = lo \n```", "```\nstd::string my_str = \"Hello\";\nmy_str += \" world\";\n\n// C++11 also allows some type inference with autos\nauto s1 =   \"Hello\"s; // std::string\nauto s2 = u8\"Hello\"s; // std::string, forces UTF-8 encoding\nauto s3 = L\"Hello\"s;  // std::wstring\nauto s4 = u\"Hello\"s;  // std::u16string\nauto s5 = U\"Hello\"s;  // std::u32string \n```", "```\nlet v = String::from(\"Hello\");\nv.push_str(\" world\"); \n```", "```\nlet mut v = String::from(\"This is a String\");\nv.push_str(\" that we can modify\"); \n```", "```\nlet b = String::from(\" Bananas\");\nlet mut result = String::new();\nresult.push_str(\"Apples \");\nresult.push('&'); // Push a char\nresult.push_str(b.as_str());\nprintln!(\"result = {}\", result); \n```", "```\nlet mut v = String::with_capacity(100);\n// or\nlet mut v = String::new();\nv.reserve_exact(100); \n```", "```\nlet message = format!(\"The temperature {temp}C is within {percent} of maximum\", temp = 104, percent = 99); \n```", "```\n// std::fmt::Display\npub trait Display {\n    fn fmt(&self, &mut Formatter) -> Result<(), Error>;\n}\n// std::fmt::Debug\npub trait Debug {\n    fn fmt(&self, &mut Formatter) -> Result<(), Error>;\n} \n```", "```\nuse std::fmt::{self, Formatter, Display};\n\nstruct Person {\n  first_name: String,\n  last_name: String,\n}\n\nimpl Display for Person {\n  fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n    write!(f, \"{} {}\", self.first_name, self.last_name)\n  }\n}\n//...\nlet person = Person { first_name: \"Susan\".to_string(), last_name: \"Smith\".to_string() };\nprintln!(\"Person - {}\", person); \n```", "```\nPerson - Susan Smith \n```", "```\n#[derive(Debug)]\nstruct Person {\n  //...\n}\n//...\nprintln!(\"Person - {:?}\", person); \n```", "```\nPerson - Person { first_name: \"Susan\", last_name: \"Smith\" } \n```", "```\nauto x = true; // bool\nauto y = 42;   // int\nauto z = 100.; // double \n```", "```\nauto s = std::string(\"Now is the window of our discontent\"); // char string\nauto s = U\"Battle of Waterloo\"; // char32_t pointer to UTF-32 string literal \n```", "```\ntemplate <typename T, int N> using raw_array = T[N];\nauto a = raw_array<int, 5>{}; \n```", "```\nlet x = true; // x: bool\nlet y = 42; // y: i32\nlet z = 100.0; // z: f64\nlet v = vec![10, 20, 30]; // v: Vec<i32>\nlet s = \"Now is the winter of our discontent\".to_string(); // s: String\nlet s2 = \"Battle of Waterloo\"; // s2: &str\nlet a1: [i32; 5] = [1, 2, 3, 4, 5]; \n```", "```\nlet a2 = [\"Mary\", \"Fred\", \"Sue\"]; \n```", "```\n// Compile error\nlet a3 = [\"Mary\", 32, true]; \n```", "```\nlet result = do_something();\nprintln!(\"Got result {:?}\", result);\nif let Some(result) = result {\n  println!(\"We got a result from do_something\");\n}\nelse {\n  println!(\"We didn't get a result from do_something\");\n}\n\nlet result = do_something_else();\n//... \n```", "```\nchar *name = \"David Jones\";\n\nint position = -1;\nfind_last_index(\"find the letter l\", 'l', &position); \n```", "```\nvoid read(Data *data);\nvoid read(int value);\n// Which function are we calling here?\nread(NULL); \n```", "```\nread(nullptr); \n```", "```\n// This is a reference coerced to a const pointer\nlet age: u16 = 27;\nlet age_ptr: *const u16 = &age;\n\n// This is a mut reference coerced to a mutable pointer\nlet mut total: u32 = 0;\nlet total_ptr: *mut u32 = &mut total; \n```", "```\n#include <tuple>\n\nstd::tuple<int, int> get_last_mouse_click() {\n  return std::make_tuple(100, 20);\n}\n\nstd::tuple<int, int> xy = get_last_mouse_click();\nint x = std::get<0>(xy);\nint y = std::get<1>(xy); \n```", "```\nfn get_last_mouse_click() -> (i32, i32) {\n  (100, 20)\n}\n// Either\nlet (x, y) = get_last_mouse_click();\nprintln!(\"x = {}, y  = {}\", x, y);\n// or\nlet xy = get_last_mouse_click();\nprintln!(\"x = {}, y  = {}\", xy.0, xy.1); \n```", "```\n// Integers\n42\n999U\n43424234UL\n-3456676L\n329478923874927ULL\n-80968098606968LL\n// C++14\n329'478'923'874'927ULL\n// Hex, octal, binary\n0xfffe8899bcde3728 // or 0X\n07583752256\n0b111111110010000 // or 0B \n```", "```\n'a'\nL'a' // wchar_t\nu'\\u20AC' // char16_t\nU'\\U0001D11E' // char32_t \n```", "```\n\"Hello\"\nu8\"Hello\" // char with UTF-8\nL\"Hello\"   // wchar_t\nu\"Hello\"   // char16_t with UTF-16\nU\"Hello\"   // char32_t with UTF-32 \n```", "```\n// Integers\n123i32;\n123u32;\n123_444_474u32;\n0usize;\n// Hex, octal, binary\n0xff_u8;\n0o70_i16;\n0b111_111_11001_0000_i32; \n```", "```\nlet a = 100.0f64;\nlet b = 0.134f64;\nlet c = 2.3f32; // But 2.f32 is not valid (note 1)\nlet d = 12E+99_E64; \n```", "```\ntrue\nfalse \n```", "```\n'x'\n'\\'' # Escaped single quote\nb'&' # byte character is a u8 \n```", "```\n\"This is a string\"\nb\"This is a byte string\" \n```", "```\n\"This is a \\\n  multiline string\"\n\"This string has a newline\\nand an escaped \\\\ backslash\"\n\"This string has a hex char \\x52\" \n```", "```\nr##\"This is a raw string that can contain \\n, \\ and other stuff without escaping\"##\nbr##\"A raw byte string with \"stuff\" like \\n \\, \\u and other things\"## \n```", "```\nstd::vector<char> values;\nfor (const char &c : values) {\n    // do something to process the value in c\n} \n```", "```\nstd::vector<char> values;\n\nfor (std::vector<char>::const_iterator i = values.begin(); i != values.end(); ++i) {\n    const char &c = *i;\n    // do something to process the value in c\n} \n```", "```\nclass Foo {\npublic:\n   // Methods and members here are publicly visible\n   double calculateResult();\nprotected:\n   // Elements here are only visible to ourselves and subclasses\n   virtual double doOperation(double lhs, double rhs);\nprivate:\n   // Elements here are only visible to ourselves\n   bool debug_;\n}; \n```", "```\nstruct Foo { // as a struct\nprivate:\n};\n\nclass Foo { // As a class\n};\n\n// Or the other way around\n\nstruct Bar {\n};\n\nclass Bar {\npublic:\n}; \n```", "```\nclass Size {\npublic:\n  Size(int width, int height);\n\n  int width_;\n  int height_;\n\n  int area() const;\n}; \n```", "```\nSize::Size(int width, int height) : width_(width), height_(height) {}\n\nint Size::area() { return width_ * height_; } \n```", "```\nstruct Size {\n  pub width: i32;\n  pub height: i32;\n} \n```", "```\nimpl Size {\n  pub fn new(width: i32, height: i32) -> Size {\n    Size { width: width, height: height, }\n  }\n\n  pub fn area(&self) -> i32 {\n    self.width * self.height\n  }\n} \n```", "```\nlet size = Size::new(10, 20);\nprintln!(\"Size = {}\", size.area()); \n```", "```\nstruct Person {\n  pub name: String,\n  pub age: i32,\n  pub credentials: Option<Credentials>,\n} \n```", "```\nlet person = Person { name: String::from(\"Bob\"), age: 20, credentials: None } \n```", "```\nimpl Person {\n  pub fn new(name: String, age: String) -> Person {\n    Person { name: name.clone(), age: age, credentials: None }\n  }\n} \n```", "```\n#[derive(Clone)]\nstruct Person {\n  pub name: String,\n  pub age: i32,\n  pub credentials: Option<Credentials>, // Credentials must implement Clone\n}\n\nimpl Person {\n  pub fn new(name: String, age: String) -> Person {\n    Person { name: name.clone(), age: age, credentials: None }\n  }\n}\n\n//...\n\nlet p = Person::new(String::from(\"Michael\"), 20);\nlet p2 = p.clone(); \n```", "```\nclass MyClass {\npublic:\n  MyClass() : someMember_(new Resource()) {}\n  ~MyClass() {\n     delete someMember_;\n  }\n\nprivate:\n  Resource *someMember_;\n} \n```", "```\nimpl Drop for Shape {\n    fn drop(&mut self) {\n        println!(\"Shape dropping!\");\n    }\n} \n```", "```\n{\n  let some_object = SomeObject::new();\n  //...\n  // Ordinarily some_object might get destroyed later,\n  // but this makes it explicitly happen here\n  drop(some_object);\n  //...\n} \n```", "```\npub struct Person { /* ... */ } \n```", "```\npub struct Person {\n  pub age: u16,\n} \n```", "```\nimpl Person {\n  pub fn is_adult(&self) -> bool {\n    self.age >= 18\n  }\n} \n```", "```\nimpl Shape {\n  pub fn new(width: u32, height: u32) -> Shape {\n    Shape { width, height }\n  }\n\n  pub fn area(&self) -> i32 {\n    self.width * self.height\n  }\n\n  pub fn set(&mut self, width: i32, height: i32) {\n    self.width = width;\n    self.height = height;\n  }\n} \n```", "```\nlet shape = Shape::new(100, 100);\nlet area = shape.area(); \n```", "```\nimpl Circle {\n   fn pi() -> f64 { std::f64::consts:PI }\n}\n//...\nlet pi = Circle::pi(); \n```", "```\ntrait HasCircumference {\n  fn circumference(&self) -> f64;\n} \n```", "```\nimpl HasCircumference for Size {\n  fn circumference(&self) -> i32 {\n    2.0 * std::f64::consts::PI * self.radius\n  }\n} \n```", "```\ntrait HasDimensions {\n  fn width(&self) -> u32;\n  fn height(&self) -> u32;\n\n  fn area(&self) -> u32 {\n    self.width() * self.height()\n  }\n} \n```", "```\nclass Incrementor {\npublic:\n    Incrementor(int &value) : value_(value) {}\n    int increment() { return ++value_; }\n\nprivate:\n    int &value_;\n}; \n```", "```\nIncrementor makeIncrementor() {\n  // This is a bad idea\n    int value = 5;\n    return Incrementor(value);\n} \n```", "```\nstruct Incrementor {\n  value: &mut i32\n}\n\nimpl Incrementor {\n  pub fn increment(&mut self) -> i32 {\n    *self.value += 1;\n    *self.value\n  }\n} \n```", "```\n2 |   value: &mut u32\n  |          ^ expected lifetime parameter \n```", "```\nstruct Incrementor<'a> {\n  value: &'a mut i32\n}\n\nimpl <'a> Incrementor<'a> {\n  pub fn increment(&mut self) -> i32 {\n    *self.value += 1;\n    *self.value\n  }\n} \n```", "```\nlet mut value = 20;\nlet mut i = Incrementor { value: &mut value };\nprintln!(\"value = {}\", i.increment()); \n```", "```\nfn find_person(name: &str) -> Option<Person>\n// instead of\nfn find_person<'a>(name: &'a str) -> Option<Person> \n```", "```\n/*\n This is a comment\n*/\n\n// This a comment with Unicode, \u4f60\u597d \n```", "```\n/// This is a comment that becomes documentation for do_thing below\npub fn do_thing() {}\n/// Returned by server if the resource could not be found\npub const NOT_FOUND = 404; \n```", "```\n{\n  let v1 = vec![1, 2, 3, 4]; // Vec is created\n  ...\n} // v1 goes out of scope, Vec is dropped \n```", "```\n{\n  let v1 = vec![1, 2, 3, 4];\n  let v2 = v1;\n  ...\n  println!(\"v1 = {:?}\", v1); // Error!\n} \n```", "```\n{\n  let v1 = vec![1, 2, 3, 4];\n  we_own_it(v1);\n  println!(\"v = {:?}\", v1);\n}\n\nfn we_own_it(v: Vec<i32>) {\n  // ...\n} \n```", "```\nv1 = we_own_and_return_it(v1)\n...\nfn we_own_and_return_it(v: Vec<i32>) -> Vec<i32> {\n  // ...\n  v1\n} \n```", "```\nlet x: i32;\nprintln!(\"The value of x is {}\", x); \n```", "```\nint result;\n{\n   // The scope is to control the lifetime of a lock\n   lock_guard<mutex> guard(data_mutex);\n   result = do_something();\n}\nif (result == 0) {\n  debug(\"result succeeded\");\n} \n```", "```\n{\n  let mut v = Vec::new(); // empty vector\n  fill_vector(&mut v);\n  // ...\n  println!(\"Vector contains {:?}\", v);\n}\n//...\nfn fill_vector(v: &mut Vec<i32>) {\n  v.push(1);\n  v.push(2);\n  v.push(3);\n} \n```", "```\nlet x = 5 + 5; // expression evaluates to 10 \n```", "```\nlet x = {};\nprintln!(\"x = {:?}\", x); \n```", "```\nx = () \n```", "```\nlet x = { println!(\"Hello\"); };\nprintln!(\"x = {:?}\", x); \n```", "```\nlet x = {\n    let pi = 3.141592735;\n    let r = 5.0;\n    2.0 * pi * r\n};\nprintln!(\"x = {}\", x); \n```", "```\npub fn add_values(x: i32, y: i32) -> i32 {\n  x + y\n} \n```", "```\npub fn find(value: &str) -> i32 {\n  if value.len() == 0 {\n    return -1;\n  }\n  database.do_find(value)\n} \n```", "```\nstd::string result;\nswitch (server_state) {\n  case WAITING:\n    result = \"Waiting\";\n    break;\n  case RUNNING:\n    result = \"Running\";\n    break;\n  case STOPPED:\n    result = \"Stopped\";\n    break;\n  }\n} \n```", "```\nlet result = match server_state {\n    ServerState::WAITING => \"Waiting\",\n    ServerState::RUNNING => \"Running\",\n    ServerState::STOPPED => \"Stopped\",\n}; \n```", "```\nbool x = (y / 2) == 4 ? true : false; \n```", "```\nlet x = if y / 2 == 4 { true } else { false }; \n```", "```\nint x = 0;\nwhile (x < 10) {\n  x++;\n}\nint y = 10;\nbool doCompare = true;\nif (doCompare && x == y) {\n  printf(\"They match!\\n\");\n} \n```", "```\nlet mut x = 0;\nwhile x < 10 {\n  x = x + 1;\n}\nlet y = 10;\nlet do_compare = true;\nif do_compare && x == y {\n  println!(\"They match!\");\n} \n```", "```\nint x = (y > 200) ? 10 : 0; \n```", "```\nlet x = if y > 200 { 10 } else { 0 }; \n```", "```\nlet c = get_temperature();\nlet water_is = if (c >= 100) { \"gas\" } else if (c < 0) { \"solid\" } else { \"liquid\" }; \n```", "```\nfn search(name: &str) -> Option<Person> { /* ... */ }\n//...\nif let Some(person) = search(\"fred\") {\n  println!(\"You fould a person {}\", person);\n}\nelse {\n  println!(\"Could not find person\");\n} \n```", "```\nint result = http_get();\nswitch (result) {\ncase 200:\n  success = true;\n  break;\ncase 404:\n  log_error(result);\n  // Drop through\ndefault:\n  success = false;\n  break;\n} \n```", "```\nlet a = 123i32;\nlet b = a as usize; \n```", "```\nenum HttpResponse {\n  okay = 200,\n  not_found = 404,\n  internal_error = 500,\n}; \n```", "```\nenum LibraryCode : char {\n  checked_in = 'I',\n  checked_out = 'O',\n  checked_out_late = 'L'\n}; \n```", "```\nenum HttpResponse {\n  Ok= 200,\n  NotFound= 404,\n  InternalError = 500\n}; \n```", "```\nenum HttpResponse {\n  Ok,\n  NotFound(String),\n  InternalError(String, String, Vec<u8>)\n} \n```", "```\nimpl HttpResponse {\n  pub fn code(&self) => {\n    match *self {\n      HttpResponse::Ok => 200,\n      HttpResponse::NotFound(_) => 404,\n      HttpResponse::InternalError(_, _, _) => 500,\n    }\n  }\n} \n```", "```\nfn do_request(url: &str) -> HttpResponse {\n  if url == \"/invalid\" {\n    HttpResponse::NotFound(url.to_string())\n  }\n  else {\n    HttpResponse::Ok\n  }\n}\n//...\nlet result = do_request(\"/invalid\");\nif let HttpResponse::NotFound(url) = result {\n  println!(\"The url {} could not be found\", url);\n} \n```", "```\n// Infinite\nfor (;;) {\n  //...\n} \n```", "```\nfor (int i = 10, j = 0; (j = i * i) <= 100; i--) {\n  //...\n} \n```", "```\nfor (int i = 0; i < 100; i++ ) {\n  cout << \"Number \" << i << endl;\n} \n```", "```\nfor (std::vector<string>::const_iterator i = my_list.begin(); i != my_list.end(); ++i ) {\n  cout << \"Value = \" << *i << end;\n} \n```", "```\nstd::vector values;\n...\nfor (const auto & v: values) {\n  ...\n}\n\nint x[5] = { 1, 2, 3, 4, 5 };\nfor (int y : x) {\n  ...\n} \n```", "```\nwhile (true) {\n  poll();\n  do_work();\n}\n// Or with a for loop\nfor (;;) {\n  poll();\n  do_work();\n} \n```", "```\nwhile (!end) {\n  std::string next = getLine();\n  end = next == \"END\";\n} \n```", "```\nint i = 0;\ndo {\n  i = rand();\n} while (i < 20); \n```", "```\nbool foundAdministrator = false;\nfor (int i = 0; i < loginCredentials; ++i) {\n   const LoginCredentials credentials = fetchLoginAt(i);\n   if (credentials.disabled) {\n     // This user login is disabled so skip it\n     continue;\n   }\n   if (credentials .isAdmin) {\n     // This user is an administrator so no need to search rest of list\n     foundAdministrator = true;\n     break;\n   }\n   // ... \n} \n```", "```\nIf structure type can be turned `IntoIterator`\n  Loop\n   If let Some(item) = iterator.next() {\n     do_action_to_item(item)\n   Else\n     break;\n  End\nElse \n  Compile Error\nDone \n```", "```\nlet range=0..33;\n// Variables\nlet min = 0;\nlet max = 100;\nlet range2 = min..max; \n```", "```\nfor i in 0..10 {\n  println!(\"Number {}\", i);\n} \n```", "```\nfor (i, x) in (30..50).enumerate() {\n   println!(\"Index {} is value {}\", i, x);\n} \n```", "```\nlet values = [2, 4, 6, 7, 8, 11, 33, 111];\nfor v in &values {\n   println!(\"v = {}\", v);\n} \n```", "```\nlet values = vec![2, 4, 6, 7, 8, 11, 33, 111];\nfor v in values.iter() {\n   println!(\"v = {}\", v);\n} \n```", "```\nuse std::collections::HashMap;\n\nlet mut values = HashMap::new();\nvalues.insert(\"hello\", \"world\");\n//...\nfor (k, v) in &values {\n  println!(\"key = {}, value = {}\", k, v);\n} \n```", "```\nlet values = [2, 4, 6, 7, 8, 11, 33, 111];\nvalues.iter().for_each(|v| println!(\"v = {}\", v)); \n```", "```\nlet values = vec![2, 4, 6, 7, 8, 11, 33, 111];\nfor v in &values {\n  if *v % 2 == 0 {\n    continue;\n  }\n  if *v > 20 {\n    break;\n  }\n  println!(\"v = {}\", v);\n} \n```", "```\n'x: for x in 0..10 {\n  'y: for y in 0..10 {\n     if x == 5 && y == 5 {\n       break 'x;\n     }\n     println!(\"x = {}, y = {}\", x, y);\n  }\n} \n```", "```\nloop {\n  poll();\n  do_work();\n} \n```", "```\nwhile request_count < 1024 {\n  process_request();\n  request_count = request_count + 1;\n} \n```", "```\nlet mut i = 0;\nloop {\n  i = i + 1;\n  if i >= 20 { break; }\n} \n```", "```\nlet mut iterator = vec.into_iter();\nwhile let Some(value) = iterator.next() {\n  process(value);\n} \n```", "```\n// Declaration\nint foo(bool parameter1, const std::string &parameter2);\n\n// Implementation\nint foo(bool parameter1, const std::string &parameter2) {\n  return 1;\n} \n```", "```\nfn foo(parameter1: bool, parameter2: &str) -> i32 {\n  // implementation\n  1\n} \n```", "```\nfn add(x: i32, y: i32) -> i32 {\n  x + y\n} \n```", "```\nfn process_data(number_of_times: ui32) -> ui32 {\n  if number_of_times == 0 {\n    return 0;\n  }\n  let mut result : ui32 = 0;\n  for i in number_of_times {\n    result += i;\n  }\n  result\n} \n```", "```\nvoid printf_like(const char *pattern, ...); \n```", "```\nstd::vector<Record> fetch_database_records(int number_to_fetch = 100); \n```", "```\nstd::string to_string(int x);\nstd::string to_string(float x);\nstd::string to_string(bool x); \n```", "```\nauto function_name(type parameter1, type parameter2, ...) -> return-type; \n```", "```\nclass Variant {\npublic:\n  void set(); // Null variant\n  void set(bool value);\n  void set(int value);\n  void set(float value);\n  void set(Array *value);\n}; \n```", "```\n // Sample code\nVariant v;\n//...\nv.set(NULL); \n```", "```\nfn new(name: &str) -> Foo { /* ... */ }\nfn new_age(name: &str, age: u16) -> Foo { /* ... */ } \n```", "```\nuse std::convert::From;\n\nimpl From<&'static str> for Foo {\n  fn from(v: &'static str) -> Self {\n    Foo { /* ... */ }\n  }\n}\n\nimpl From<(&'static str, u16)> for Foo {\n  fn from(v: (&'static str, u16)) -> Self {\n    Foo { /* ... */ }\n  }\n}\n//...\n\nlet f = Foo::from(\"Bob\");\nlet f = Foo::from((\"Mary\", 16)); \n```", "```\nimpl Foo {\n  pub fn new<T>(v: T) -> Foo where T: Into<Foo> {\n    let result = Foo::foo(v);\n    // we could code here that we do here after making Foo by whatever means\n    result\n  }\n} \n```", "```\nlet f = Foo::new(\"Bob\");\nlet f = Foo::new((\"Mary\", 16)); \n```", "```\n// This Into works on a string slice\nimpl Into<Foo> for &'static str {\n    fn into(self) -> Foo {    \n        //... constructor\n    }    \n}\n\n// This Into works on a tuple consisting of a string slice and a u16\nimpl Into<Foo> for (&'static str, u16) {    \n    fn into(self) -> Foo {    \n        //... constructor\n    }    \n}\n\n//...\nlet f: Foo = \"Bob\".into();\nlet f: Foo = (\"Mary\", 16).into();\n// OR\nlet f = Foo::new(\"Bob\");\nlet f = Foo::new((\"Mary\", 16)); \n```", "```\npub enum FooCtorArgs {\n   String(String),\n   StringU16(String, u16)\n}\n\nimpl Foo {\n  pub fn new(v: FooCtorArgs) {\n    match v {\n      FooCtorArgs::String(s) => { /* ... */ }\n      FooCtorArgs::StringU16(s, i) => { /* ... */ }\n    }\n  }\n}\n//...\nlet f = Foo::new(FooCtorArgs::String(\"Bob\".to_string()));\nlet f = Foo::new(FooCtorArgs::StringU16(\"Mary\".to_string(), 16)); \n```", "```\nvoid do_something() {\n  if (!read_file()) {\n    throw std::runtime_error(\"read_file didn't work!\");\n  }\n}\n...\ntry {\n  do_something();\n}\ncatch (std::exception e) {\n   std::cout << \"Caught exception -- \" << e.what() << std::endl;\n} \n```", "```\nenum Option<T> {\n   None\n   Some(T)\n} \n```", "```\nstruct Person { /* ... */}\n\nfn find_person(name: &str) {\n   let records = run_query(format!(\"select * from persons where name = {}\", sanitize_name(name)));\n   if records.is_empty() {\n      None\n   }\n   else {\n      let person = Person::new(records[0]);\n      Some(person)\n   }\n} \n```", "```\nenum Result<T, E> {\n  Ok(T),\n  Err(E)\n} \n```", "```\nfn set_thermostat(temperature: u16) -> Result<(), String> {\n   if temperature < 10 {\n     err(format!(\"Temperature {} is too low\", temperature))\n   }\n   else if temperature > 30 {\n     err(format!(\"Temperature {} is too high\", temperature))\n   }\n   else {\n     Ok(())\n   }\n}\n// ...\nlet result = set_thermostat();\nif result.is_ok() {\n  // ...\n} \n```", "```\nfn delete_user(name: &str) -> Result<(), ErrorCode> {\n  let result = find_user(name);\n  if let Ok(user) = result {\n     // ... delete the user\n     Ok(())\n  }\n  else {\n    Err(result.unwrap_err())\n  }\n}\n\nfn find_user(name: &str) -> Result<User, ErrorCode> {\n  //... find the user OR\n  Err(ErrorCode::UserDoesNotExist)\n} \n```", "```\nfn delete_user(name: &str) -> Result<(), ErrorCode> {\n  let user = find_user(name)?;\n  // ... delete the user\n  Ok(())\n} \n```", "```\nfn delete_user(name: &str) -> Result<(), ErrorCode> {\n  let user = try!(find_user(name));\n  // ... delete the user\n  Ok(())\n} \n```", "```\nuse std::panic;\n\nlet result = panic::catch_unwind(|| {\n    panic!(\"Bad things\");\n}); \n```", "```\nfloat values[10] = { 9, 3, 2.1, 3, 4, -10, 2, 4, 6, 7 };\nstd::sort(values, values + 10, [](float a, float b) {\n  return a < b;\n}); \n```", "```\nauto v1 = 10.;\nauto v2 = 2.;\n// Capture by value\nauto multiply = [v1, v2]() { return v1 * v2; };\n// Capture by reference\nauto sum = [&v1, &v2]() { return v1 + v2; };\ncout << multiply() << endl;\ncout << sum() << endl;\nv1 = 99; // Now v1 in sum() references 99\ncout << multiply() << endl;\ncout << sum() << endl; \n```", "```\n20\n12\n20\n101 \n```", "```\n// Capture by value\nauto multiply = [=]() { return v1 * v2; };\n// Capture by reference\nauto sum = [&]() { return v1 + v2; }; \n```", "```\nuse std::cmp::Ord;\nlet mut values = [ 9.0, 3.0, 2.1, 3.0, 4.0, -10.0, 2.0, 4.0, 6.0, 7.0 ];\nvalues.sort_by(|a, b| a < b );\nprintln!(\"values = {:?}\", values); \n```", "```\nlet mut x = 100;\n{\n  let square = || x * x;\n  println!(\"square = {}\", square());\n}\nx = 200; \n```", "```\nlet mut x = 100;\nlet square = move || x * x;\nprintln!(\"square = {}\", square()); // 10000\nx = 200;\nprintln!(\"square = {}\", square()); // 10000 \n```", "```\nlet mut v1 = 10.0;\nlet v2 = 2.0;\nlet multiply = move || v1 * v2;\nlet sum = |x: &f64, y: &f64| x + y;\nprintln!(\"multiply {}\", multiply());\nprintln!(\"sum {}\", sum(&v1, &v2));\nv1 = 99.0;\nprintln!(\"multiply {}\", multiply());\nprintln!(\"sum {}\", sum(&v1, &v2)); \n```", "```\ntemplate <typename T>\ninline void debug(const T &v) {\n  cout << \"The value of object is \" << v << endl;\n}\n//...\ndebug(10); \n```", "```\nThe value of object is 10 \n```", "```\ntemplate <class T>\nclass Stack {\nprivate:\n  vector<T> elements;\npublic:\n  void push(const T &v) {\n    // ...\n  }\n  T pop() {\n    // ...\n  }\n}\n//...\nStack<double> doubleStack; \n```", "```\nuse std::fmt;\n\nfn debug<T>(data: T) where T: fmt::Display {\n  println!(\"The value of object is {}\", data);\n}\n//...\ndebug(10); \n```", "```\nstruct Stack<T> {\n  elements: Vec<T>\n}\n\nimpl<T> Stack<T> {\n  fn new() -> Stack<T> { Stack { elements: Vec::new() } }\n\n  fn push(v: T) {\n    //...\n  }\n\n  fn pop() -> Option<T> {\n    //...\n    None\n  }\n}\n//...\nlet double_stack: Stack<f64> = Stack::new(); \n```", "```\nfn compare<T, F>(a: T, b: T, f: F) -> bool \n  where F: FnOnce(T, T) -> bool \n{\n  f(a, b)\n}\n\nlet comparer = |a, b| a < b;\nlet result = compare(10, 20, comparer); \n```", "```\n#[test]\nfn this_is_a_test() {\n  //...\n} \n```", "```\nfn this_is_a_test() {\n  #![test]\n  //...\n} \n```", "```\n#[cfg(windows)]\nfn get_app_data_dir() -> String { /* ... */ }\n\n#[cfg(not(windows))]\nfn get_app_data_dir() -> String { /* ... */ } \n```", "```\nrustc -C lto \n```", "```\n#include <iostream>\n#include <thread>\n\nusing namespace std;\n\nvoid DoWork(int loop_count) {\n    for (int i = 0; i < loop_count; ++i) {\n        cout << \"Hello world \" << i << endl;\n    }\n}\n\nint main() {\n    thread worker(DoWork, 100);\n    worker.join();\n} \n```", "```\n#include <iostream>\n#include <thread>\n#include <mutex>\n\nusing namespace std;\n\nmutex data_guard;\nint result = 0;\n\nvoid DoWork(int loop_count) {\n    for (auto i = 0; i < loop_count; ++i) {\n        lock_guard<mutex> guard(data_guard);\n        result += 1;\n    }\n}\n\nint main() {\n    thread worker1(DoWork, 100);\n    thread worker2(DoWork, 150);\n    worker1.join();\n    worker2.join();\n    cout << \"result = \" << result << endl;\n} \n```", "```\n#include <iostream>\n#include <pthread.h>\n\nusing namespace std;\n\nvoid *DoWork(void *data) {\n    const int loop_count = (int) data;\n    for (int i = 0; i < loop_count; ++i) {\n        cout << \"Hello world \" << i << endl;\n    }\n    pthread_exit(NULL);\n}\n\nint main() {\n    pthread_t worker_thread;\n    int result = pthread_create(&worker_thread, NULL, DoWork, (void *) 100);\n    // Wait for the thread to end\n    result = pthread_join(worker_thread, NULL);\n} \n```", "```\n__thread int private; // gcc / clang\n__declspec(thread) int private; // MSVC \n```", "```\nthread_local int private \n```", "```\nuse std::thread;\n\nthread::spawn(move || {\n  println!(\"Hello\");\n}); \n```", "```\nfn my_thread() {\n  println!(\"Hello\");\n}\n//...\nthread::spawn(my_thread); \n```", "```\nlet h = thread::spawn(move || {\n  println!(\"Hello\");\n});\nh.join(); \n```", "```\nlet h = thread::spawn(move || 100 * 100);\nlet result = h.join().unwrap();\nprintln!(\"Result = {}\", result); \n```", "```\nlet shared_data = Arc::new(Mutex::new(MySharedData::new()));\n\n// Each thread we spawn should have a clone of this Arc\nlet shared_data = shared_data.clone();\nthread::spawn(move || {\n  let mut shared_data = shared_data.lock().unwrap();\n  shared_data.counter += 1;\n}); \n```", "```\nstruct MySharedData {\n  pub counter: u32,\n}\n\nimpl MySharedData {\n  pub fn new() -> MySharedData {\n    MySharedData {\n      counter: 0\n    }\n  }\n}\n\nfn main() {\n  spawn_threads();\n}\n\nfn spawn_threads() {\n  let shared_data = Arc::new(Mutex::new(MySharedData::new()));\n\n  // Spawn a number of threads and collect their join handles\n  let handles: Vec<JoinHandle<_>> = (0..10).map(|_| {\n    let shared_data = shared_data.clone();\n    thread::spawn(move || {\n      let mut shared_data = shared_data.lock().unwrap();\n      shared_data.counter += 1;\n    })\n  }).collect();\n\n  // Wait for each thread to complete\n  for h in handles {\n    h.join();\n  }\n\n  // Print the data\n  let shared_data = shared_data.lock().unwrap();\n  println!(\"Total = {}\", shared_data.counter);\n} \n```", "```\nlet shared_data = Arc::new(RwLock::new(MySharedData::new())); \n```", "```\nlet shared_data = shared_data.read().unwrap();\n// OR\nlet mut shared_data = shared_data.write().unwrap(); \n```", "```\nthread_local! {\n  // TODO\n} \n```", "```\nuse rayon::prelude::*;\nfn sum_of_squares(input: &[i32]) -> i32 {\n    input.par_iter()\n         .map(|&i| i * i)\n         .sum()\n} \n```", "```\n#[allow(rule)]\n#[warn(rule)]\n#[deny(rule)]\n#[forbid(rule)] \n```", "```\n name  default  meaning\n                         ----  -------  -------\n                box-pointers   allow    use of owned (Box type) heap memory\n           fat-ptr-transmutes  allow    detects transmutes of fat pointers\n missing-copy-implementations  allow    detects potentially-forgotten implementations of `Copy`\nmissing-debug-implementations  allow    detects missing implementations of fmt::Debug\n                 missing-docs  allow    detects missing documentation for public members\n                trivial-casts  allow    detects trivial casts which could be removed\n        trivial-numeric-casts  allow    detects trivial casts of numeric types which could be removed\n                  unsafe-code  allow    usage of `unsafe` code\n... \n```", "```\n#define IS_WINDOWS\n#define SHAREWARE_VERSION 1 \n```", "```\n#if SHAREWARE_VERSION == 1\nshowNagwarePopup();\n#endif\n//...\n#ifdef IS_WINDOWS\nwritePrefsToRegistry();\n#else\nwritePrefsToCfg();\n#endif \n```", "```\n// System / external headers tend to use angle style\n#include <string>\n#include <stdio.h>\n\n// Local headers tend to use double quotes\n#include \"MyClass.h\" \n```", "```\n#define MULTIPLY(x, y) x * y\n//\nint x = 10, y = 20;\nint result = MULTIPLY(x + 1, x + y);\n// Value is NOT 330 (11 * 30), it's 41 because macro becomes x + 1 * x + y \n```", "```\n#define SWAP(x, y) int tmp = y; y = x; x = y;\n//\nint tmp = 10;\nint a = 20, b = 30;\nSWAP(a, b); // ERROR \n```", "```\n#define SWAP(x, y) do { int tmp = y; y = x; x = y } while(0); \n```", "```\n#define PRINT(x) \\\n  printf(\"You printed %d\", x); \n```", "```\nmacro_rules! hello_x {\n  ($($name:expr),*) => (\n    $(println!(\"Hello {}\", $name);)*\n  )\n}\n// The code can supply as many arguments it likes to this macro\nhello_x!(\"Bob\", \"Sue\", \"John\", \"Ellen\"); \n```", "```\nHello Bob\nHello Sue\nHello John\nHello Ellen \n```", "```\nhello_x!(\"Bob\", true, 1234.333, -1); \n```", "```\nHello Bob\nHello true\nHello 1234.333\nHello -1 \n```", "```\nhello_x!(Aardvark {}); \n```", "```\nerror[E0422]: `Aardvark` does not name a structure\n  |\n8 | hello_x!(Aardvark {});\n  |          ^^^^^^^^\n<std macros>:2:27: 2:58 note: in this expansion of format_args!\n<std macros>:3:1: 3:54 note: in this expansion of print! (defined in <std macros>)\n<anon>:5:7: 5:35 note: in this expansion of println! (defined in <std macros>)\n<anon>:8:1: 8:23 note: in this expansion of hello_x! (defined in <anon>) \n```", "```\nmacro_rules! vec {\n    ($elem:expr; $n:expr) => (\n        $crate::vec::from_elem($elem, $n)\n    );\n    ($($x:expr),*) => (\n        <[_]>::into_vec(box [$($x),*])\n    );\n    ($($x:expr,)*) => (vec![$($x),*])\n} \n```", "```\n($elem:expr; $n:expr) =>  (\n        $crate::vec::from_elem($elem, $n)\n    ); \n```", "```\nlet v = vec!(1; 100);\n// 1st branch matches and it becomes this\nlet v = std::vec::from_elem(1, 100); \n```", "```\n($($x:expr),*) => (\n        <[_]>::into_vec(box [$($x),*])\n    ); \n```", "```\nlet v = vec!(1, 2, 3, 4, 5);\n// 3nd branch matches and it becomes this\nlet v = <[_]>::into_vec(box [1, 2, 3, 4, 5]); \n```", "```\n($($x:expr,)*) => (vec![$($x),*]) \n```", "```\n// 3rd branch matches this\nlet v = vec!(1, 2, 3, 4, 5,);\n// and it becomes this\nlet v = vec!(1, 2, 3, 4, 5);\n// which matches 2nd branch to become\nlet v = <[_]>::into_vec(box [1, 2, 3, 4, 5]); \n```", "```\n// malloc / free\nchar *buffer = (char *) malloc(1024);\n...\nfree(buffer);\n// new / delete\nStack *stack = new Stack();\n...\ndelete stack;\n// new[] / delete[]\nNode *nodes = new Node[100];\n...\ndelete []nodes; \n```", "```\n{\n  std::auto_ptr<Database> db(new Database());\n  //... object is deleted when db goes out of scope\n}\n\n// C++11\n{\n  std::unique_ptr<Database> db(new Database());\n  //... object is deleted when db goes out of scope\n\n  std::unique_ptr<Node[]> nodes<new Node[100]);\n  //... arrays of objects are supported too\n}\n\n// C++11\n{\n  std::shared_ptr<Database> db(new Database());\n  // Reference count db\n  setDatabase(db);\n  //... object is deleted when last shared_ptr reference to it goes out of scope\n\n  std::shared_ptr<Node[]> nodes<new Node[100]);\n  //... arrays of objects are supported too\n} \n```", "```\nstruct Blob {\n  data: Box<[u8; 16384]>\n}\n\nimpl Blob {\n  pub fn new() {\n    Efficient {\n      data: Box::new([0u8; 16384])\n    }\n  }\n} \n```", "```\n#[link(name = \"foo\")]\nextern {\n  fn foo_command(command: *mut u8)\n} \n```", "```\npub fn run_command(command: &[u8]) {\n  unsafe {\n    foo_command(command.as_ptr());\n  }\n} \n```", "```\nextern crate libc;\n\nuse std::ffi::CString;\nuse std::ptr;\nuse libc::{c_char, c_void, malloc, memset, strcpy, free};\n\n#[no_mangle]\npub extern \"C\" fn make_checksum(filepath: *const c_char) -> *mut c_char {\n    // Your code here\n    if filepath == ptr::null() {\n      return ptr::null_mut::<c_char>()\n    }\n\n    unsafe {\n        // Imagine our checksum code here...\n        let result = malloc(12);\n        memset(result, 0, 12);\n        strcpy(result as *mut c_char, CString::new(\"abcdef\").unwrap().as_ptr());\n        return result as *mut c_char;\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn release_checksum(checksum: *const c_char) {\n    unsafe {\n        free(checksum as *mut c_void);\n    }\n} \n```", "```\nimport ctypes\n\nchecksum = ctypes.CDLL(\"path/to/our/dll\");\ncs = checksum.make_checksum(\"c:/somefile\");\n...\nchecksum.release_checksum(cs) \n```", "```\n[dependencies]\nlibc = \"0.2.17\" \n```", "```\nextern crate libc;\n\nuse libc::{c_char, malloc, free, atoi}; \n```"]