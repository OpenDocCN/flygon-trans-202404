- en: JIT and Optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding JIT and Optimizer Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Welcome to Chapter 4 of the "Implementing a language with LLVM" tutorial. Chapters
    1-3 described the implementation of a simple language and added support for generating
    LLVM IR. This chapter describes two new techniques: adding optimizer support to
    your language, and adding JIT compiler support. These additions will demonstrate
    how to get nice, efficient code for the Kaleidoscope language.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Trivial Constant Folding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our demonstration for Chapter 3 is elegant and easy to extend. Unfortunately,
    it does not produce wonderful code. The IRBuilder, however, does give us obvious
    optimizations when compiling simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is not a literal transcription of the AST built by parsing the input.
    That would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Constant folding, as seen above, in particular, is a very common and very important
    optimization: so much so that many language implementors implement constant folding
    support in their AST representation.'
  prefs: []
  type: TYPE_NORMAL
- en: With LLVM, you don't need this support in the AST. Since all calls to build
    LLVM IR go through the LLVM IR builder, the builder itself checked to see if there
    was a constant folding opportunity when you call it. If so, it just does the constant
    fold and return the constant instead of creating an instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that was easy :). In practice, we recommend always using IRBuilder when
    generating code like this. It has no "syntactic overhead" for its use (you don't
    have to uglify your compiler with constant checks everywhere) and it can dramatically
    reduce the amount of LLVM IR that is generated in some cases (particular for languages
    with a macro preprocessor or that use a lot of constants).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the IRBuilder is limited by the fact that it does all of
    its analysis inline with the code as it is built. If you take a slightly more
    complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the LHS and RHS of the multiplication are the same value. We'd
    really like to see this generate `tmp = x+3; result = tmp*tmp;` instead of computing
    `x+3` twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, no amount of local analysis will be able to detect and correct
    this. This requires two transformations: reassociation of expressions (to make
    the add''s lexically identical) and Common Subexpression Elimination (CSE) to
    delete the redundant add instruction. Fortunately, LLVM provides a broad range
    of optimizations that you can use, in the form of "passes".'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 LLVM Optimization Passes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LLVM provides many optimization passes, which do many different sorts of things
    and have different tradeoffs. Unlike other systems, LLVM doesn't hold to the mistaken
    notion that one set of optimizations is right for all languages and for all situations.
    LLVM allows a compiler implementor to make complete decisions about what optimizations
    to use, in which order, and in what situation.
  prefs: []
  type: TYPE_NORMAL
- en: As a concrete example, LLVM supports both "whole module" passes, which look
    across as large of body of code as they can (often a whole file, but if run at
    link time, this can be a substantial portion of the whole program). It also supports
    and includes "per-function" passes which just operate on a single function at
    a time, without looking at other functions. For more information on passes and
    how they are run, see the How to Write a Pass document and the List of LLVM Passes.
  prefs: []
  type: TYPE_NORMAL
- en: For Kaleidoscope, we are currently generating functions on the fly, one at a
    time, as the user types them in. We aren't shooting for the ultimate optimization
    experience in this setting, but we also want to catch the easy and quick stuff
    where possible. As such, we will choose to run a few per-function optimizations
    as the user types the function in. If we wanted to make a "static Kaleidoscope
    compiler", we would use exactly the code we have now, except that we would defer
    running the optimizer until the entire file has been parsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get per-function optimizations going, we need to set up a FunctionPassManager
    to hold and organize the LLVM optimizations that we want to run. Once we have
    that, we can add a set of optimizations to run. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a FunctionPassManager, `OurFPM`. It requires a pointer to
    the Module to construct itself. Once it is set up, we use a series of `add` calls
    to add a bunch of LLVM passes. The first pass is basically boilerplate, it adds
    a pass so that later optimizations know how the data structures in the program
    are laid out. The `TheExecutionEngine` variable is related to the JIT, which we
    will get to in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we choose to add 4 optimization passes. The passes we chose here
    are a pretty standard set of "cleanup" optimizations that are useful for a wide
    variety of code. I won't delve into what they do but, believe me, they are a good
    starting place :).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the PassManager is set up, we need to make use of it. We do this by running
    it after our newly created function is constructed (in `FunctionAST::Codegen`),
    but before it is returned to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is pretty straightforward. The FunctionPassManager optimizes
    and updates the LLVM `Function*` in place, improving (hopefully) its body. With
    this in place, we can try our test above again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we now get our nicely optimized code, saving a floating point add
    instruction from every execution of this function.
  prefs: []
  type: TYPE_NORMAL
- en: LLVM provides a wide variety of optimizations that can be used in certain circumstances.
    Some documentation about the various passes is available, but it isn't very complete.
    Another good source of ideas can come from looking at the passes that Clang runs
    to get started. The "opt" tool allows you to experiment with passes from the command
    line, so you can see if they do anything.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have reasonable code coming out of our front-end, lets talk about
    executing it!
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Adding a JIT Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code that is available in LLVM IR can have a wide variety of tools applied to
    it. For example, you can run optimizations on it (as we did above), you can dump
    it out in textual or binary forms, you can compile the code to an assembly file
    (.s) for some target, or you can JIT compile it. The nice thing about the LLVM
    IR representation is that it is the "common currency" between many different parts
    of the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll add JIT compiler support to our interpreter. The basic
    idea that we want for Kaleidoscope is to have the user enter function bodies as
    they do now, but immediately evaluate the top-level expressions they type in.
    For example, if they type in `1 + 2;`, we should evaluate and print out 3\. If
    they define a function, they should be able to call it from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we first declare and initialize the JIT. This is done
    by adding a global variable and a call in main:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This creates an abstract `Execution Engine` which can be either a JIT compiler
    or the LLVM interpreter. LLVM will automatically pick a JIT compiler for you if
    one is available for your platform, otherwise it will fall back to the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the ExecutionEngine is created, the JIT is ready to be used. There are
    a variety of APIs that are useful, but the simplest one is the `getPointerToFunction(F)`
    method. This method JIT compiles the specified LLVM Function and returns a function
    pointer to the generated machine code. In our case, this means that we can change
    the code that parses a top-level expression to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Recall that we compile top-level expressions into a self-contained LLVM function
    that takes no arguments and returns the computed double. Because the LLVM JIT
    compiler matches the native platform ABI, this means that you can just cast the
    result pointer to a function pointer of that type and call it directly. This means,
    there is no difference between JIT compiled code and native machine code that
    is statically linked into your application.
  prefs: []
  type: TYPE_NORMAL
- en: With just these two changes, lets see how Kaleidoscope works now!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Well this looks like it is basically working. The dump of the function shows
    the "no argument function that always returns double" that we synthesize for each
    top-level expression that is typed in. This demonstrates very basic functionality,
    but can we do more?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This illustrates that we can now call user code, but there is something a bit
    subtle going on here. Note that we only invoke the JIT on the anonymous functions
    that call testfunc, but we never invoked it on testfunc itself. What actually
    happened here is that the JIT scanned for all non-JIT'd functions transitively
    called from the anonymous function and compiled all of them before returning from
    `getPointerToFunction()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JIT provides a number of other more advanced interfaces for things like
    freeing allocated machine code, rejit''ing functions to update them, etc. However,
    even with this simple code, we get some surprisingly powerful capabilities - check
    this out (I removed the dump of the anonymous functions, you should get the idea
    by now :) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Whoa, how does the JIT know about sin and cos? The answer is surprisingly simple:
    in this example, the JIT started execution of a function and got to a function
    call. It realized that the function was not yet JIT compiled and invoked the standard
    set of routines to resolve the function. In this case, there is no body defined
    for the function, so the JIT ended up calling `dlsym("sin")` on the Kaleidoscope
    process itself. Since `sin` is defined within the JIT''s address space, it simply
    patches up calls in the module to call the libm version of sin directly.'
  prefs: []
  type: TYPE_NORMAL
- en: The LLVM JIT provides a number of interfaces (look in the ExecutionEngine.h
    file) for controlling how unknown functions get resolved. It allows you to establish
    explicit mappings between IR objects and addresses (useful for LLVM global variables
    that you want to map to static tables, for example), allows you to dynamically
    decide on the fly based on the function name, and even allows you to have the
    JIT compile functions lazily the first time they're called.
  prefs: []
  type: TYPE_NORMAL
- en: 'One interesting application of this is that we can now extend the language
    by writing arbitrary C++ code to implement operations. For example, if we add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can produce simple output to the console by using things like: `extern
    putchard(x); putchard(120);`, which prints a lowercase `x` on the console (120
    is the ASCII code for `x`). Similar code could be used to implement file I/O,
    console input, and many other capabilities in Kaleidoscope.'
  prefs: []
  type: TYPE_NORMAL
- en: This completes the JIT and optimizer chapter of the Kaleidoscope tutorial. At
    this point, we can compile a non-Turing-complete programming language, optimize
    and JIT compile it in a user-driven way. Next up we'll look into extending the
    language with control flow constructs, tackling some interesting LLVM IR issues
    along the way.
  prefs: []
  type: TYPE_NORMAL
