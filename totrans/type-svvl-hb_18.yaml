- en: Next.jsで猫画像ジェネレーターを作ろう
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://typescriptbook.jp/tutorials/nextjs](https://typescriptbook.jp/tutorials/nextjs)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next.jsの概要[​](#nextjsの概要 "Next.jsの概要 への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Next.js](https://nextjs.org/)は、オープンソースのUIライブラリReactをベースにしたフロントエンドフレームワークです。'
  prefs: []
  type: TYPE_NORMAL
- en: Reactで開発する場合、webpackのようなバンドラーを用いるのが普通です。webpackの設定ファイルを記述するには、一定の知識が必要です。特に、チャンク分割やCSSモジュールの設定は複雑だったりと、設定ファイルのメンテナンスが大変です。Next.jsは、webpackの設定があらかじめなされた状態で開発が始められるようになっています。
  prefs: []
  type: TYPE_NORMAL
- en: Next.jsはルーティング時のプリフェッチや画像の最適化などのパフォーマンス最適化をフレームワーク内で内包しており、ゼロコンフィグで簡単にパフォーマンスの高いアプリケーションを構築することができます。ページ単位のサーバーサイドレンダリング(SSR)や静的サイト生成(SSG)の機能も提供しており、用途に合わせて柔軟にアーキテクチャを選択できるのも特徴です。
  prefs: []
  type: TYPE_NORMAL
- en: Next.jsはVercel社が開発しています。同社は[Vercel](https://vercel.com/)というホスティングサービスを提供しているので、Next.jsで構築したアプリケーションは簡単に公開できます。
  prefs: []
  type: TYPE_NORMAL
- en: これから作るもの[​](#これから作るもの "これから作るもの への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: このチュートリアルでは、題して「猫画像ジェネレーター」です。どんなものかというと、ボタンを押したら、猫画像のAPIから画像のURLを取得し、ランダムに可愛い猫画像を表示するシンプルなウェブアプリケーションです。
  prefs: []
  type: TYPE_NORMAL
- en: </tutorials/nextjs/demo.mp4>
  prefs: []
  type: TYPE_NORMAL
- en: 最終的な成果物は[デモサイト](https://random-cat.typescriptbook.jp/)で確認できます。チュートリアルを開始する前に事前に触ってみることで、各ステップでどんな実装をしているかのイメージが掴みやすくなります。また、完成形のソースコードは[GitHub](https://github.com/yytypescript/random-cat)で確認することができます。
  prefs: []
  type: TYPE_NORMAL
- en: このチュートリアルに必要なもの[​](#このチュートリアルに必要なもの "このチュートリアルに必要なもの への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: このチュートリアルで必要なものは次のとおりです。
  prefs: []
  type: TYPE_NORMAL
- en: Node.js v16以上
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yarn v1系 (このチュートリアルはv1.22.19で動作確認しています)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ブラウザ (このチュートリアルではGoogle Chromeを想定しています)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.jsの導入については、[開発環境の準備](/tutorials/setup)をご覧ください。
  prefs: []
  type: TYPE_NORMAL
- en: パッケージ管理ツールとしてYarnを利用します。最初にインストールをしておきましょう。すでにインストール済みの方はここのステップはスキップして大丈夫です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next.jsをセットアップする[​](#nextjsをセットアップする "Next.jsをセットアップする への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 最初に`yarn create next-app`コマンドでプロジェクトを作成します。TypeScriptをベースにしたプロジェクトを作成するために `--example
    with-typescript` を指定します。`random-cat` はリポジトリ名となる部分です。この部分は好きな名前でも構いませんが、本チュートリアルでは`random-cat`として話を進めます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: このコマンドを実行すると、`random-cat`ディレクトリが作成されるので、そのディレクトリに移動してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: プロジェクトのファイル構成が次のようになっているか確認してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 開発サーバーを起動する[​](#開発サーバーを起動する "開発サーバーを起動する への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 次のコマンドを実行して、開発サーバーを起動してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 開発サーバーが起動したら、ターミナルに表示されているURLにブラウザでアクセスしてください。
  prefs: []
  type: TYPE_NORMAL
- en: 不要なファイルを消す[​](#不要なファイルを消す "不要なファイルを消す への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: チュートリアルを進める前に、ここでは使わないファイルを削除します。プロジェクトをシンプルな状態にして、作業を進めやすくしましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: ページコンポーネントディレクトリを作る[​](#ページコンポーネントディレクトリを作る "ページコンポーネントディレクトリを作る への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next.jsでは、`pages`ディレクトリ配下のディレクトリ構造がページのルーティングに対応します。たとえば、pages/users.tsxとファイルを作成すると、`/users`へアクセスしたとき、それが実行されます。pages/index.tsxの場合は、`/`
    へアクセスしたときに実行されます。
  prefs: []
  type: TYPE_NORMAL
- en: この`pages`ディレクトリに置かれたコンポーネントのことを、Next.jsの用語でページコンポーネント(page component)と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコマンドを実行してページコンポーネントを置くためのディレクトリを作成してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: トップページのページコンポーネントを作る[​](#トップページのページコンポーネントを作る "トップページのページコンポーネントを作る への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 次のコマンドを実行して、トップページのページコンポーネントを作成してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: ページコンポーネントの内容は、次のようにします。この`IndexPage`関数がページコンポーネントです。これは「猫画像予定地」が表示されるだけの単純なものです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next.jsでは、1ファイルにつき1ページコンポーネントを作成します。Next.jsは`pages`ディレクトリの各`tsx`ファイルを読み込み、デフォルトエクスポートされた関数をページコンポーネントとして認識します。上のコードで`IndexPage`関数を`export
    default`にしているのは、Next.jsにページコンポーネントと認識させるためです。`NextPage`はページコンポーネントを表す型です。この型を注釈しておくと、関数の実装がページコンポーネントの要件を満たしているかがチェックできます。
  prefs: []
  type: TYPE_NORMAL
- en: コンポーネントを実装したら、ブラウザをリロードして画面に「猫画像予定地」と表示されているか確認してください。
  prefs: []
  type: TYPE_NORMAL
- en: Next.jsではアロー関数を使うべきですか？
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptで関数を作るには、大きく分けて[アロー関数と関数宣言を使った方法の2種類](/reference/functions/function-expression-vs-arrow-functions)があります。上で書いた`IndexPage`関数はアロー関数です。これを関数宣言に書き換えると次のようになります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next.jsでは、アロー関数と関数宣言のどちらで書いても構いません。このチュートリアルでアロー関数を採用しているのは、ページコンポーネントに`NextPage`型の型注釈をつけるのが、アロー関数のほうがやりやすいためです。
  prefs: []
  type: TYPE_NORMAL
- en: The Cat API[​](#the-cat-api "The Cat API への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: このチュートリアルでは猫の画像をランダムに表示するにあたり[The Cat API](https://thecatapi.com/)を利用します。このAPIは特定の条件で猫の画像を取得したり、品種ごとの猫の情報を取得することができます。今回のチュートリアルでは[APIドキュメント](https://docs.thecatapi.com/)のQuickstartに記載されている`/v1/images/search`へリクエストを投げてランダムな猫の画像を取得します。
  prefs: []
  type: TYPE_NORMAL
- en: 試しにブラウザで[https://api.thecatapi.com/v1/images/search](https://api.thecatapi.com/v1/images/search)へアクセスしてみてください。ランダムな結果が返ってくるので値は少し違いますが、次のような構造のデータがレスポンスとして取得できます。レスポンスのデータ構造が配列になっている点に注意してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: レスポンスにある`url`が猫画像のURLです。この値を取得して猫の画像をランダムに表示します。
  prefs: []
  type: TYPE_NORMAL
- en: 画像を取得する関数を実装する[​](#画像を取得する関数を実装する "画像を取得する関数を実装する への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: このステップでは、The Cat APIにリクエストし猫画像を取得する関数を実装します。次の実装をした`fetchImage`関数を`export default
    IndexPage`の後ろに追加してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`fetch`はHTTPリクエストでリソースを取得するブラウザ標準のAPIです。戻り値として[Response](https://developer.mozilla.org/ja/docs/Web/API/Response)オブジェクトを返します。Responseオブジェクトの`json()`メソッドを実行することで、レスポンスのボディーをJSONとしてパースし、JavaScriptのオブジェクトとして取得できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchImage`関数についている[`async`キーワード](/reference/asynchronous/async)は、この関数が非同期処理を行うことを示すものです。`fetch`と`res.json`は非同期関数で、これらの処理を待つために、それぞれに[`await`キーワード](/reference/asynchronous/await)がついています。'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchImage`関数がAPIを呼び出せているかテストするために、これを呼び出す処理を`fetchImage`関数の後ろに追加してください。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Chromeの開発者ツールを開いてからページをリロードしてください。「コンソール」タブで次のようなテキストが表示されていたら成功です。
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/55489e605dca6f8087b8a304e59025ce.png)'
  prefs: []
  type: TYPE_IMG
- en: '`fetchImage`関数の動作確認が済んだら、この関数の呼び出しは不要になるので消してください。'
  prefs: []
  type: TYPE_NORMAL
- en: 関数の戻り値に型をつける[​](#関数の戻り値に型をつける "関数の戻り値に型をつける への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 上で作った`fetchImage`関数の戻り値の型は`any`型です。そのため、呼び出し側で存在しないプロパティを参照しても気づけずにバグが発生する危険性があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'ts`const <data-lsp lsp="const fetchImage: () => Promise<any>" style="border-bottom:solid
    2px lightgrey">fetchImage</data-lsp> =  async () => {` `const fetchImage: () =>
    Promise<any>  const  <data-lsp lsp="const res: Response">res</data-lsp>  =  await
    <data-lsp lsp="function fetch(input: RequestInfo | URL, init?: RequestInit | undefined):
    Promise<Response>">fetch</data-lsp>("https://api.thecatapi.com/v1/images/search");  const  <data-lsp
    lsp="const images: any">images</data-lsp>  =  await  <data-lsp lsp="const res:
    Response">res</data-lsp>.<data-lsp lsp="(method) Body.json(): Promise<any>">json</data-lsp>();  <data-lsp
    lsp="namespace console'
  prefs: []
  type: TYPE_NORMAL
- en: 'var console: Console">console</data-lsp>.<data-lsp lsp="(method) Console.log(message?:
    any, ...optionalParams: any[]): void (+1 overload)">log</data-lsp>(<data-lsp lsp="const
    images: any">images</data-lsp>);  return <data-lsp lsp="const images: any">images</data-lsp>[0];};<data-lsp
    lsp="const fetchImage: () => Promise<any>">fetchImage</data-lsp>().<data-lsp lsp="(method)
    Promise<any>.then<void, never>(onfulfilled?: ((value: any) => void | PromiseLike<void>)
    | null | undefined, onrejected?: ((reason: any) => PromiseLike<never>) | null
    | undefined): Promise<...>">then</data-lsp>((<data-lsp lsp="(parameter) image:
    any" style="border-bottom:solid 2px lightgrey">image</data-lsp>) => {` `(parameter)
    image: any  <data-lsp lsp="namespace console'
  prefs: []
  type: TYPE_NORMAL
- en: 'var console: Console">console</data-lsp>.<data-lsp lsp="(method) Console.log(message?:
    any, ...optionalParams: any[]): void (+1 overload)">log</data-lsp>(<data-lsp lsp="(parameter)
    image: any">image</data-lsp>.<data-lsp lsp="any">alt</data-lsp>); // 存在しないプロパティを参照している});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`image`には`alt`プロパティがありませんが、`image`が`any`型なので、上のような誤ったコードを書いても、コンパイル時に誤りに気づけません。'
  prefs: []
  type: TYPE_NORMAL
- en: APIレスポンスの取り扱いはフロントエンドでバグが混在しやすい箇所なので、型を指定することで安全にAPIレスポンスを扱えるようにしていきます。
  prefs: []
  type: TYPE_NORMAL
- en: レスポンスに含まれる画像情報の型を`Image`として定義します。そして、`fetchImage`関数の戻り値を`Promise<Image>`として型注釈します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: APIレスポンスには`url`以外のプロパティも含まれていますが、このアプリケーションで必要な情報は`url`だけなので、他のプロパティの型の定義は省略しています。もし、他のプロパティも必要になった場合でも、`Image`にプロパティの定義を追加していけばよいです。
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchImage`関数の戻り値が正しく型注釈がされていると、万が一APIレスポンスに存在しないプロパティを参照するコードを書いてしまっても、コンパイルエラーが発生することで問題に気がつけるようになります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'ts`<data-lsp lsp="const fetchImage: () => Promise<Image>">fetchImage</data-lsp>().<data-lsp
    lsp="(method) Promise<Image>.then<void, never>(onfulfilled?: ((value: Image) =>
    void | PromiseLike<void>) | null | undefined, onrejected?: ((reason: any) => PromiseLike<never>)
    | null | undefined): Promise<...>">then</data-lsp>((<data-lsp lsp="(parameter)
    image: Image" style="border-bottom:solid 2px lightgrey">image</data-lsp>) => {`
    `(parameter) image: Image  <data-lsp lsp="namespace console'
  prefs: []
  type: TYPE_NORMAL
- en: 'var console: Console">console</data-lsp>.<data-lsp lsp="(method) Console.log(message?:
    any, ...optionalParams: any[]): void (+1 overload)">log</data-lsp>(<data-lsp lsp="(parameter)
    image: Image">image</data-lsp>.<data-err><data-lsp lsp="any">alt</data-lsp></data-err>);
    // 存在しないプロパティを参照しているProperty ''alt'' does not exist on type ''Image''.2339Property
    ''alt'' does not exist on type ''Image''.});`厳密なレスポンスのチェック'
  prefs: []
  type: TYPE_NORMAL
- en: 上のコードは、サーバーサイドを100%信頼するコードになっています。クライアントサイドが期待するデータ構造を、サーバーサイドが必ず返すことを前提としたコードなのです。しかし、サーバーサイドは本当に期待するデータ構造を返してくれているでしょうか？
  prefs: []
  type: TYPE_NORMAL
- en: より防衛的にするなら、クライアントサイドではサーバーのレスポンスをチェックするほうが望ましいでしょう。チェックの一例として次のような実装も考えられます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: このチェック処理では、型が不明な値を安全に型付けする[unknown型](/reference/statements/unknown)や、値の型をチェックしながら型付する[型ガード関数](/reference/functions/type-guard-functions)などのTypeScriptのテクニックも用いています。これらについては、ここでは理解する必要はありませんが、興味のある方はチュートリアルを終えてから解説をご覧ください。
  prefs: []
  type: TYPE_NORMAL
- en: このチュートリアルでは厳密さよりもシンプルさに重心を置くため、上のようなチェック処理はあえて追加せずに話を進めます。
  prefs: []
  type: TYPE_NORMAL
- en: ページを表示したときに画像を表示する[​](#ページを表示したときに画像を表示する "ページを表示したときに画像を表示する への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ページを表示したときに`fetchImage`を呼び出して、猫の画像を表示する処理を書いています。`IndexPage`関数の中身を次のように変更してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 変更内容をひとつひとつ見ていきましょう。
  prefs: []
  type: TYPE_NORMAL
- en: ❶ まず、Reactの`useState`関数を使い、`imageUrl`と`loading`の2つの状態を定義します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`imageUrl`は画像のURLが代入される変数です。初期値は空文字列です。`loading`はAPIを呼び出し中かどうかを管理する変数です。初期値は呼び出し中を意味する`true`です。'
  prefs: []
  type: TYPE_NORMAL
- en: ❷ 次に、コンポーネントがマウントされたときに、APIから猫の画像情報を取得する処理を定義します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Reactの`useEffect`関数を使用します。`useEffect`は2つの引数を指定しています。第1引数は処理内容、第2引数はどのタイミングで処理内容を実行するかの指定です。第2引数は空の配列`[]`になっています。空配列であるため一見すると不要そうに見えますが、これには「コンポーネントがマウントされたときのみ実行する」という重要な役割があるので省略しないでください。
  prefs: []
  type: TYPE_NORMAL
- en: '`useEffect`関数の第1引数となる関数の処理を見てみましょう。`fetchImage`関数は非同期処理です。非同期処理が完了したタイミングで、`imageUrl`に画像URLをセットするために`setImageUrl`関数を呼び出します。同時に、ローディング状態を`false`に更新するために`setLoading`関数も呼び出します。'
  prefs: []
  type: TYPE_NORMAL
- en: <mdxadmonitiontitle>`useEffect`には非同期関数は渡せない</mdxadmonitiontitle>
  prefs: []
  type: TYPE_NORMAL
- en: '`useEffect`に渡している関数は非同期処理をしているのに、`async`キーワードを使わずに`then`を使って記述していることに気がついた方もいるかもしれません。その方の中には、次のように非同期関数を渡す書き方にして、コードが読みやすくしたいと思う方もいるでしょう。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: しかし、`useEffect`には非同期関数を直接渡すことはできません。渡そうとすると、コンパイルエラーになります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: ❸ 最後に画像を表示するロジックです。`||`は論理和演算子で、`loading`が`false`のときに`<img>`要素を表示します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: JSXには文が書けない
  prefs: []
  type: TYPE_NORMAL
- en: 上の条件分岐を見て「なぜ素直にif文を使わないのか？」と疑問の思ったかもしれません。これには理由があります。JSXの`{}`で囲った部分には、JavaScriptの式だけが書けます。ifは文であるため使うことができません。もし使おうとすると次の例のようにコンパイルエラーになります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: したがって、JSXの式で条件分岐するには論理演算子や三項演算子を使う必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 変更内容の詳細は以上です。`IndexPage`の変更が済んだら、猫の画像が表示されているか確認してみてください。画像がちゃんと表示されているでしょうか。
  prefs: []
  type: TYPE_NORMAL
- en: '![猫の画像がuseEffectによって表示されるようになった様子](../Images/d01813c0b259c844ff206882c3d9e569.png)'
  prefs: []
  type: TYPE_IMG
- en: ボタンをクリックしたときに画像が更新されるようにする[​](#ボタンをクリックしたときに画像が更新されるようにする "ボタンをクリックしたときに画像が更新されるようにする
    への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ここではボタンをクリックしたときに、APIから新しい画像情報を取得し、表示中の画像を新しい画像に置き換える機能を作ります。次のように`IndexPage`コンポーネントに、`handleClick`関数とボタンを追加してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: これでクリックしたら画像が更新されるようになります。うまく動いているかブラウザで確認してみてください。
  prefs: []
  type: TYPE_NORMAL
- en: </tutorials/nextjs/cat-image-is-changed-when-click-the-button.mp4>
  prefs: []
  type: TYPE_NORMAL
- en: Next.jsのSSRとデータフェッチAPI[​](#nextjsのssrとデータフェッチapi "Next.jsのSSRとデータフェッチAPI への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reactはクライアントサイドでのレンダリングに特化していますが、Next.jsはサーバーサイドレンダリング(server-side rendering;
    SSR)をサポートしています。これにより、初回読み込みの速度を向上させることができ、SEOやパフォーマンスにもよい影響を与えます。
  prefs: []
  type: TYPE_NORMAL
- en: SSRはウェブアプリケーションのレンダリングをサーバーサイドで行う技術のことです。通常、クライアントサイドレンダリング(client-side rendering;
    CSR)では、ブラウザがHTML、CSS、JavaScriptファイルをダウンロードして、JavaScriptを使用してページをレンダリングします。これに対して、SSRではサーバーがHTMLを生成し、ブラウザに送信します。
  prefs: []
  type: TYPE_NORMAL
- en: Next.jsでSSRを行うには、次のデータフェッチAPIの関数を使います。
  prefs: []
  type: TYPE_NORMAL
- en: '`getServerSideProps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getStaticProps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getInitialProps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: これらの関数を使うことで、Next.jsで簡単にSSRを実装できます。
  prefs: []
  type: TYPE_NORMAL
- en: getServerSideProps[​](#getserversideprops "getServerSideProps への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`getServerSideProps`は、ページがリクエストされるたびにサーバーサイドで実行され、ページのプロパティを返す関数です。この関数を使用すると、リクエストごとにページのデータを取得できます。また、クライアントサイドでルーティングが発生した場合も、この関数がサーバーサイドで実行されます。'
  prefs: []
  type: TYPE_NORMAL
- en: サーバーサイドでのみ実行されるため、`getServerSideProps`内でのみ利用しているモジュールや関数は、クライアントのコードにバンドルされません。これは、配信するファイルサイズを削減することにも繋がります。
  prefs: []
  type: TYPE_NORMAL
- en: サーバーサイドで実行されるため、データベースなどウェブに公開していないミドルウェアから直接データを取得するような処理も記述できます。
  prefs: []
  type: TYPE_NORMAL
- en: getStaticProps[​](#getstaticprops "getStaticProps への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`getStaticProps`は、静的生成するページのデータを取得するための関数で、ビルド時に実行されます。この関数を使用すると、ビルド時にページのデータを取得しておき、クライアントからのリクエスト時にはそのキャッシュからデータを返すようになります。この関数は、リクエスト時や描画時にはデータ取得が実行されないことに注意が必要です。ユーザーログインが不要なランディングページや、内容のリアルタイムさが不要なブログなどの静的なページを構築するときに利用します。'
  prefs: []
  type: TYPE_NORMAL
- en: getInitialProps[​](#getinitialprops "getInitialProps への直接リンク")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`getInitialProps`は、SSR時にサーバーサイドでデータ取得の処理が実行されます。また、クライアントサイドでルーティングが発生した場合は、クライアント側でもデータの取得が実行されます。このAPIはサーバーとクライアントの両方で実行されるため、両方の環境で動作するように実装する必要があります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`getInitialProps`は、Next.js 9までのバージョンで使われていた古い方法です。現在でもサポートされていますが、Next.js 10以降では、代わりに
    `getServerSideProps`や`getStaticProps`の使用を推奨しています。'
  prefs: []
  type: TYPE_NORMAL
- en: データフェッチAPIを使ってリクエスト時に初期画像を取得する[​](#データフェッチapiを使ってリクエスト時に初期画像を取得する "データフェッチAPIを使ってリクエスト時に初期画像を取得する
    への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: これまでに作ってきた`IndexPage`コンポーネントには、クライアントサイドで最初の画像を取得し表示していました。ここでは、データフェッチAPIの`getServerSideProps`を使って、サーバーサイドで初期画像を取得するように変更します。先に完成形のコードを示すと、次のようになります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 上で行った変更をひとつひとつ見ていきましょう。まず、`getServerSideProps`関数を追加しました。この関数は、サーバーサイドで実行する処理を書きます。上のコードは画像情報を取得する処理になっています。`getServerSideProps`関数は、`IndexPage`コンポーネントが引数として受け取る`prop`を戻り値に含めます。`getServerSideProps`関数は、Next.jsに認識させるために`export`しておく必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: 次に、`IndexPage`関数は`getServerSideProps`が返す`props`を受け取れるように引数を追加してあります。`props`の`initialImageUrl`には初期画像のURLが入っていて、この値を`image`の初期値となるように、`useState`の引数に渡します。
  prefs: []
  type: TYPE_NORMAL
- en: 初期画像はサーバーサイドで取得するようにしたので、クライアントサイドで初期画像を取得していた`useEffect`の部分は不要になります。
  prefs: []
  type: TYPE_NORMAL
- en: これで、ページをリクエストするタイミングで、サーバーサイドで画像情報が取得され、ランダムに猫画像が表示されるようになります。
  prefs: []
  type: TYPE_NORMAL
- en: ビジュアルを作り込む[​](#ビジュアルを作り込む "ビジュアルを作り込む への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 機能面が完成したので、最後にビジュアルデザインを作り込んでいきましょう。まず、スタイルシートを作成します。スタイルシートの内容は長くなるので、次のURLからスタイルシートをダウンロードしてください。ダウンロードしたら、`pages`ディレクトリに`index.module.css`として保存してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/yytypescript/random-cat/main/pages/index.module.css](https://raw.githubusercontent.com/yytypescript/random-cat/main/pages/index.module.css)'
  prefs: []
  type: TYPE_NORMAL
- en: このスタイルを`IndexPage`コンポーネントに当てます。まず、`index.module.css`をインポートします。`.module.css`で終わるファイルはCSSモジュール(CSS
    Modules)と言うもので、CSSファイル内で定義したクラス名をTypeScriptからオブジェクトとして参照できるようになります。次に、各要素に`className`属性でクラス名を指定してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 以上でNext.jsを使った猫画像ジェネレーターの開発は完了です。
  prefs: []
  type: TYPE_NORMAL
- en: プロダクションビルドと実行[​](#プロダクションビルドと実行 "プロダクションビルドと実行 への直接リンク")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next.jsでは`next build`を実行することで最適化されたプロダクション用のコードを生成でき、`next start`で生成されたプロダクションコードを実行できます。このチュートリアルではボイラテンプレートを利用しているので、package.jsonにbuildコマンドとstartコマンドがすでに用意されています。`yarn
    build`と`yarn start`を実行して本番用のアプリケーションを実行してみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: アプリケーション起動後に[http://localhost:3000](http://localhost:3000)へブラウザでアクセスをすることで、本番用のアプリケーションの実行を確認できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
