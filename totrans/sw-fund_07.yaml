- en: LogicLogic in Coq
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Coq 中的逻辑
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Export Tactics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要导出的术语。
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Check 3 = 3.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 3 = 3。
- en: (* ===> Prop *)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> Prop *)
- en: 'Check ∀n m : nat, n + m = m + n.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '检查 ∀n m : nat, n + m = m + n。'
- en: (* ===> Prop *)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> Prop *)
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check ∀n : nat, n = 2.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '检查 ∀n : nat, n = 2。'
- en: (* ===> Prop *)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> Prop *)
- en: Check 3 = 4.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 3 = 4。
- en: (* ===> Prop *)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> Prop *)
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Theorem plus_2_2_is_4 :'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 plus_2_2_is_4：
- en: 2 + 2 = 4.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2 + 2 = 4。
- en: Proof. reflexivity. Qed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 反射性。 完成。
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Definition plus_fact : Prop := 2 + 2 = 4.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 plus_fact : Prop := 2 + 2 = 4。'
- en: Check plus_fact.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 plus_fact。
- en: (* ===> plus_fact : Prop *)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '(* ===> plus_fact : Prop *)'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Theorem plus_fact_is_true :'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 plus_fact_is_true：
- en: plus_fact.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: plus_fact。
- en: Proof. reflexivity. Qed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。 反射性。 完成。
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Definition is_three (n : nat) : Prop :='
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 is_three (n : nat) : Prop :='
- en: n = 3.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: n = 3。
- en: Check is_three.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 is_three。
- en: (* ===> nat -> Prop *)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> nat -> Prop *)
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Definition injective {A B} (f : A → B) :='
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 injective {A B} (f : A → B) :='
- en: '∀x y : A, f x = f y → x = y.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ∀x y：A，f x = f y → x = y。
- en: 'Lemma succ_inj : injective S.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 succ_inj：injective S。
- en: Proof.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros n m H. inversion H. reflexivity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: intros n m H。 反演 H。 反射性。
- en: Qed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Check @eq.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 @eq。
- en: (* ===> forall A : Type, A -> A -> Prop *)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '(* ===> forall A : Type, A -> A -> Prop *)'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Logical Connectives
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑连接词
- en: Conjunction
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: The *conjunction* (or *logical and*) of propositions A and B
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命题 A 和 B 的 *合取*（或 *逻辑与*）
- en: is written A ∧ B, representing the claim that both A and B
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是写成 A ∧ B，表示声明 A 和 B 都为真
- en: are true.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是真的。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To prove a conjunction, use the split tactic.  It will generate
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要证明合取，使用 split 策略。 它将生成
- en: 'two subgoals, one for each part of the statement:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个子目标，一个用于语句的每个部分：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For any propositions A and B, if we assume that A is true
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于任何命题 A 和 B，如果我们假设 A 为真
- en: and we assume that B is true, we can conclude that A ∧ B is
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们假设 B 为真，我们可以得出 A ∧ B 为真
- en: also true.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也是真的。
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since applying a theorem with hypotheses to some goal has the
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于将带有假设的定理应用于某个目标具有
- en: effect of generating as many subgoals as there are hypotheses for
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 生成与假设数量相同的子目标的效果
- en: that theorem, we can apply and_intro to achieve the same effect
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那个定理，我们可以应用 and_intro 来实现相同的效果
- en: as split.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如 split。
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Exercise: 2 stars (and_exercise)'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星 (and_exercise)
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ☐
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: So much for proving conjunctive statements.  To go in the other
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如此多地证明合取语句。 要进入另一个
- en: direction — i.e., to *use* a conjunctive hypothesis to help prove
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方向——即，*使用*合取假设来帮助证明
- en: something else — we employ the destruct tactic.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他——我们使用析构策略。
- en: If the proof context contains a hypothesis H of the form
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果证明上下文包含形式为 H 的假设
- en: A ∧ B, writing destruct H as [HA HB] will remove H from the
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A ∧ B，写成 destruct H as [HA HB] 将从中移除 H
- en: 'context and add two new hypotheses: HA, stating that A is'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上下文并添加两个新的假设：HA，声明 A 为真
- en: true, and HB, stating that B is true.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 真，和 HB，声明 B 为真。
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As usual, we can also destruct H right when we introduce it,
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，当我们介绍它时，我们也可以立即析构 H，
- en: 'instead of introducing and then destructing it:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是引入然后析构它：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may wonder why we bothered packing the two hypotheses n = 0
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们费心打包两个假设 n = 0
- en: and m = 0 into a single conjunction, since we could have also
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和 m = 0 合并为单个合取，因为我们也可以
- en: 'stated the theorem with two separate premises:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 陈述了带有两个单独前提的定理：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For this theorem, both formulations are fine.  But it's important
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个定理，两种表述都可以。 但重要的是
- en: to understand how to work with conjunctive hypotheses because
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以了解如何处理合取假设，因为
- en: conjunctions often arise from intermediate steps in proofs,
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 合取经常出现在证明的中间步骤中，
- en: 'especially in bigger developments.  Here''s a simple example:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是在更大的开发中。 以下是一个简单的例子：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another common situation with conjunctions is that we know
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种常见的合取情况是我们知道
- en: A ∧ B but in some context we need just A (or just B).
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A ∧ B 但在某些上下文中我们只需要 A（或只需要 B）。
- en: 'The following lemmas are useful in such cases:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下引理在这种情况下很有用：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Exercise: 1 star, optional (proj2)'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星，可选 (proj2)
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ☐
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: Finally, we sometimes need to rearrange the order of conjunctions
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们有时需要重新排列合取的顺序
- en: and/or the grouping of multi-way conjunctions.  The following
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和/或多向合取的分组。 以下
- en: commutativity and associativity theorems are handy in such
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 交换律和结合律定理在这种情况下很方便
- en: cases.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cases。
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Exercise: 2 stars (and_assoc)'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2 星 (and_assoc)
- en: (In the following proof of associativity, notice how the *nested*
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (在结合的下面证明中，请注意 *嵌套*
- en: 'intro pattern breaks the hypothesis H : P ∧ (Q ∧ R) down into'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '引入模式将假设 H : P ∧ (Q ∧ R) 分解为'
- en: 'HP : P, HQ : Q, and HR : R.  Finish the proof from'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HP：P，HQ：Q 和 HR：R。 完成证明从
- en: there.)
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里。)
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ☐
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: By the way, the infix notation ∧ is actually just syntactic
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顺便说一句，中缀符号 ∧ 实际上只是句法糖
- en: sugar for and A B.  That is, and is a Coq operator that takes
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是 and A B 的 Coq 运算符，它接受
- en: two propositions as arguments and yields a proposition.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Disjunction
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important connective is the *disjunction*, or *logical or*
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'of two propositions: A ∨ B is true when either A or B'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is.  (Alternatively, we can write or A B, where or : Prop → Prop → Prop.)'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To use a disjunctive hypothesis in a proof, we proceed by case
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: analysis, which, as for nat or other data types, can be done
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with destruct or intros.  Here is an example:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Conversely, to show that a disjunction holds, we need to show that
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: one of its sides does. This is done via two tactics, left and
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: right.  As their names imply, the first one requires
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proving the left side of the disjunction, while the second
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: requires proving its right side.  Here is a trivial use...
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '... and a slightly more interesting example requiring both left'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'and right:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Exercise: 1 star (mult_eq_0)'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ☐
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (or_commut)'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ☐
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Falsehood and Negation
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have mostly been concerned with proving that certain
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: things are *true* — addition is commutative, appending lists is
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: associative, etc.  Of course, we may also be interested in
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*negative* results, showing that certain propositions are *not*'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: true. In Coq, such negative statements are expressed with the
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: negation operator ¬.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To see how negation works, recall the discussion of the *principle of explosion*
    from the [Tactics](Tactics.html) chapter; it asserts that, if we
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assume a contradiction, then any other proposition can be derived.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Following this intuition, we could define ¬ P ("not P") as
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ∀ Q, P → Q.  Coq actually makes a slightly different
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: choice, defining ¬ P as P → False, where False is a
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*particular* contradictory proposition defined in the standard'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: library.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since False is a contradictory proposition, the principle of
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: explosion also applies to it. If we get False into the proof
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'context, we can destruct it to complete any goal:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Latin *ex falso quodlibet* means, literally, "from falsehood
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: follows whatever you like"; this is another common name for the
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: principle of explosion.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (not_implies_our_not)'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show that Coq's definition of negation implies the intuitive one
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mentioned above:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ☐
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is how we use not to state that 0 and 1 are different
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elements of nat:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Such inequality statements are frequent enough to warrant a
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'special notation, x ≠ y:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It takes a little practice to get used to working with negation in
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq.  Even though you can see perfectly well why a statement
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involving negation is true, it can be a little tricky at first to
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get things into the right configuration so that Coq can understand
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it!  Here are proofs of a few familiar facts to get you warmed
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: up.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Exercise: 2 stars, advanced, recommendedM (double_neg_inf)'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write an informal proof of double_neg:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Theorem*: P implies ~~P, for any proposition P.'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ☐
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, recommended (contrapositive)'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ☐
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (not_both_true_and_false)'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ☐
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, advancedM (informal_not_PNP)'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write an informal proof (in English) of the proposition ∀ P : Prop, ~(P ∧ ¬P).'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ☐
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, since inequality involves a negation, it requires a
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样���由于不等式涉及否定，它需要一个。
- en: little practice to be able to work with it fluently.  Here is one
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有点练习就能流利地使用它。这里是一个。
- en: useful trick.  If you are trying to prove a goal that is
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有用的技巧。如果你试图证明一个目标。
- en: nonsensical (e.g., the goal state is false = true), apply
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 荒谬的（例如，目标状态是 false = true），应用。
- en: ex_falso_quodlibet to change the goal to False.  This makes it
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ex_falso_quodlibet 将目标改为 False。这使得。
- en: easier to use assumptions of the form ¬P that may be available
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更容易使用形如 ¬P 的假设，可能可用。
- en: in the context — in particular, assumptions of the form
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上下文中 — 特别是形如。
- en: x≠y.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: x≠y。
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since reasoning with ex_falso_quodlibet is quite common, Coq
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于使用 ex_falso_quodlibet 推理是相当常见的，Coq。
- en: provides a built-in tactic, exfalso, for applying it.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供了一个内置策略，exfalso，用于应用它。
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Truth
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真相
- en: Besides False, Coq's standard library also defines True, a
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了 False，Coq 的标准库还定义了 True，一个。
- en: proposition that is trivially true. To prove it, we use the
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然真的命题。为了证明它，我们使用。
- en: 'predefined constant I : True:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预定义常量 I：True。
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Unlike False, which is used extensively, True is used quite
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与 False 不同，True 的使用相当。
- en: rarely, since it is trivial (and therefore uninteresting) to prove
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很少，因为证明这个是微不足道的（因此无趣）。
- en: as a goal, and it carries no useful information as a hypothesis.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一个目标，并且作为一个假设没有带来有用的信息。
- en: But it can be quite useful when defining complex Props using
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是在使用时定义复杂的 Props 时可能会非常有用。
- en: conditionals or as a parameter to higher-order Props.  We will
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 条件或作为高阶 Props 的参数。我们将。
- en: see examples of such uses of True later on.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看到稍后的 True 的使用示例。
- en: Logical Equivalence
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑等价性
- en: The handy "if and only if" connective, which asserts that two
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方便的“当且仅当”连接词，断言两个。
- en: propositions have the same truth value, is just the conjunction of
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命题具有相同的真值，只是与之相连。
- en: two implications.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个蕴含。
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Exercise: 1 star, optional (iff_properties)'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星，可选（iff_properties）
- en: Using the above proof that ↔ is symmetric (iff_sym) as
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用上述证明 ↔ 是对称的（iff_sym）作为。
- en: a guide, prove that it is also reflexive and transitive.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个指南，证明它也是自反的和传递的。
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ☐
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars (or_distributes_over_and)'
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3 星（or_distributes_over_and）
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ☐
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: Some of Coq's tactics treat iff statements specially, avoiding
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 的一些策略特殊处理 iff 语句，避免。
- en: the need for some low-level proof-state manipulation.  In
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些低级别的证明状态操作。在。
- en: particular, rewrite and reflexivity can be used with iff
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是，rewrite 和 reflexivity 可以与 iff 一起使用。
- en: statements, not just equalities.  To enable this behavior, we need
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 陈述，不仅仅是相等。为了启用这种行为，我们需要。
- en: to import a special Coq library that allows rewriting with other
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导入一个特殊的 Coq 库，允许与其他。
- en: 'formulas besides equality:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了相等之外的公式：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here is a simple example demonstrating how these tactics work with
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个简单的示例，演示这些策略如何与。
- en: iff.  First, let's prove a couple of basic iff equivalences...
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然。首先，让我们证明一些基本的当且仅当等价性...
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can now use these facts with rewrite and reflexivity to
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些事实与 rewrite 和 reflexivity 来。
- en: give smooth proofs of statements involving equivalences.  Here is
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给出涉及等价性的陈述的顺利证明。这里是。
- en: 'a ternary version of the previous mult_0 result:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前 mult_0 结果的三元版本：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The apply tactic can also be used with ↔. When given an
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: apply 策略也可以与 ↔ 一起使用。当给出一个。
- en: equivalence as its argument, apply tries to guess which side of
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等价性作为其参数，apply 会尝试猜测是哪一边。
- en: the equivalence to use.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用等价性。
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Existential Quantification
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存在量化
- en: Another important logical connective is *existential quantification*.  To say
    that there is some x of type T such
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个重要的逻辑连接词是*存在量化*。说有一些类型为 T 的 x。
- en: 'that some property P holds of x, we write ∃ x : T, P. As with ∀, the type annotation
    : T can be omitted if'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当某个属性 P 适用于 x 时，我们写成 ∃ x：T，P。与 ∀ 一样，类型注释：T 可以省略。
- en: Coq is able to infer from the context what the type of x should
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 能够从上下文推断出 x 的类型应该是什么。
- en: be.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是。
- en: To prove a statement of the form ∃ x, P, we must show that
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要证明形如 ∃ x，P 的陈述，我们必须展示。
- en: P holds for some specific choice of value for x, known as the
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P 适用于某个特定的 x 值的选择，称为。
- en: '*witness* of the existential.  This is done in two steps: First,'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*见证*存在。这是通过两个步骤完成的：首先，'
- en: we explicitly tell Coq which witness t we have in mind by
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们明确告诉 Coq 我们心目中的见证 t 是什么。
- en: invoking the tactic ∃ t.  Then we prove that P holds after
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用策略 ∃ t。然后我们证明 P 在之后成立。
- en: all occurrences of x are replaced by t.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有 x 的出现都被 t 替换。
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Conversely, if we have an existential hypothesis ∃ x, P in
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，如果我们有一个存在假设 ∃ x，P 在。
- en: the context, we can destruct it to obtain a witness x and a
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上下文中，我们可以解构它以获得一个见证 x 和一个。
- en: hypothesis stating that P holds of x.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设P对x成立的假设。
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Exercise: 1 star (dist_not_exists)'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（dist_not_exists）
- en: Prove that "P holds for all x" implies "there is no x for
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明“对所有x成立的P”意味着“没有x对
- en: which P does not hold."
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P不成立的地方。"
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ☐
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars (dist_exists_or)'
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星（dist_exists_or）
- en: Prove that existential quantification distributes over
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明存在量化在上面分布
- en: disjunction.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分离。
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ☐
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Fixpoint In {A : Type} (x : A) (l : list A) : Prop :='
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数In {A：类型}（x：A）（l：列表A）：命题 =
- en: match l with
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配l与
- en: '| [] ⇒ False'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '| [] ⇒ 假'
- en: '| x'' :: l'' ⇒ x'' = x ∨ In x l'''
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '| x'' :: l'' ⇒ x'' = x ∨ In x l'''
- en: end.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Example In_example_1 : In 4 [1; 2; 3; 4; 5].'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 例子In_example_1：In 4 [1; 2; 3; 4; 5]。
- en: Proof.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* WORKED IN CLASS *)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在课堂上使用过的*)
- en: simpl. right. right. right. left. reflexivity.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。右。右。右。左。一致性。
- en: Qed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: 'Example In_example_2 :'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例子In_example_2：
- en: ∀n, In n [2; 4] →
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ∀n, In n [2; 4] →
- en: ∃n', n = 2 * n'.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ∃n'，n = 2 * n'。
- en: Proof.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* WORKED IN CLASS *)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在课堂上使用过的*)
- en: simpl.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。
- en: intros n [H | [H | []]].
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: intros n [H | [H | []]]。
- en: '- ∃1\. rewrite ← H. reflexivity.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '- ∃1\. 重写 ← H。一致性。'
- en: '- ∃2\. rewrite ← H. reflexivity.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '- ∃2\. 重写 ← H。一致性。'
- en: Qed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Qed.
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Lemma In_map :'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 引理In_map：
- en: '∀(A B : Type) (f : A → B) (l : list A) (x : A),'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(A B : 类型) (f : A → B) (l : 列表 A) (x : A),'
- en: In x l →
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在x l →
- en: In (f x) (map f l).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: In（f x）（map f l）。
- en: Proof.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros A B f l x.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: intros A B f l x。
- en: induction l as [|x' l' IHl'].
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对l进行归纳作为[|x' l' IHl']。
- en: '- (* l = nil, contradiction *)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l = nil, 矛盾 *)'
- en: simpl. intros [].
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。intros []。
- en: '- (* l = x'' :: l'' *)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l = x'' :: l'' *)'
- en: simpl. intros [H | H].
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。intros [H | H]。
- en: + rewrite H. left. reflexivity.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: + 重写H。左。一致性。
- en: + right. apply IHl'. apply H.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: + 右。应用IHl'。应用H。
- en: Qed.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Qed。
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Lemma In_map_iff :'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 引理In_map_iff：
- en: '∀(A B : Type) (f : A → B) (l : list A) (y : B),'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ∀（A B：类型）（f：A → B）（l：列表A）（y：B），
- en: In y (map f l) ↔
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在y (map f l) ↔
- en: ∃x, f x = y ∧ In x l.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ∃x，f x = y ∧ In x l。
- en: Proof.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此处填写*）承认。
- en: '[PRE57]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Lemma in_app_iff : ∀A l l'' (a:A),'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 引理in_app_iff：∀A l l' (a:A),
- en: In a (l++l') ↔ In a l ∨ In a l'.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在（l++l'）中a ↔ 在l中a∨在l'中a。
- en: Proof.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此处填写*）承认。
- en: '[PRE58]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Fixpoint All {T : Type} (P : T → Prop) (l : list T) : Prop'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '递归函数All {T : 类型} (P : T → 命题) (l : 列表 T) : 命题'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ." 替换此行*). 承认。
- en: 'Lemma All_In :'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 引理All_In：
- en: '∀T (P : T → Prop) (l : list T),'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ∀T（P：T → 命题）（l：列表T），
- en: (∀x, In x l → P x) ↔
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: (∀x, In x l → P x) ↔
- en: All P l.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所有P l。
- en: Proof.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此处填写*）承认。
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Definition combine_odd_even (Podd Peven : nat → Prop) : nat → Prop'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 定义combine_odd_even（Podd Peven：自然数 → 命题）：自然数 → 命题
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ." 替换此行*). 承认。
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Theorem combine_odd_even_intro :'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 定理combine_odd_even_intro：
- en: '∀(Podd Peven : nat → Prop) (n : nat),'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(Podd Peven : 自然数 → 命题) (n : 自然数),'
- en: (oddb n = true → Podd n) →
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: (oddb n = true → Podd n) →
- en: (oddb n = false → Peven n) →
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: (oddb n = false → Peven n) →
- en: combine_odd_even Podd Peven n.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: combine_odd_even Podd Peven n。
- en: Proof.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此处填写*）承认。
- en: 'Theorem combine_odd_even_elim_odd :'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 定理combine_odd_even_elim_odd：
- en: '∀(Podd Peven : nat → Prop) (n : nat),'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(Podd Peven : 自然数 → 命题) (n : 自然数),'
- en: combine_odd_even Podd Peven n →
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: combine_odd_even Podd Peven n →
- en: oddb n = true →
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: oddb n = true →
- en: Podd n.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Podd n。
- en: Proof.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此处填写*）承认。
- en: 'Theorem combine_odd_even_elim_even :'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 定理combine_odd_even_elim_even：
- en: '∀(Podd Peven : nat → Prop) (n : nat),'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(Podd Peven : 自然数 → 命题) (n : 自然数),'
- en: combine_odd_even Podd Peven n →
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: combine_odd_even Podd Peven n →
- en: oddb n = false →
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: oddb n = false →
- en: Peven n.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Peven n。
- en: Proof.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此处填写*）承认。
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Applying Theorems to Arguments
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将定理应用于参数
- en: One feature of Coq that distinguishes it from many other proof
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq的一个特点是它与许多其他证明系统不同的地方
- en: assistants is that it treats *proofs* as first-class objects.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 助手是将*证明*视为一等对象的特点。
- en: There is a great deal to be said about this, but it is not
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这方面有很多值得讨论的地方，但不是
- en: necessary to understand it in detail in order to use Coq.  This
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 详细了解它以便使用Coq。 这
- en: section gives just a taste, while a deeper exploration can be
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此节只是一个简单的介绍，深入探讨可以
- en: found in the optional chapters ProofObjects and
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可在可选章节ProofObjects和
- en: IndPrinciples.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IndPrinciples。
- en: We have seen that we can use the Check command to ask Coq to
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以使用Check命令来询问Coq
- en: print the type of an expression.  We can also use Check to ask
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打印表达式的类型。 我们也可以使用Check来询问
- en: what theorem a particular identifier refers to.
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特定标识符指的是哪个定理。
- en: '[PRE62]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Coq prints the *statement* of the plus_comm theorem in the same
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq以相同的方式打印plus_comm定理的*陈述*
- en: way that it prints the *type* of any term that we ask it to
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它以打印我们要求的任何术语的*类型*的方式
- en: Check.  Why?
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查。 为什么？
- en: The reason is that the identifier plus_comm actually refers to a
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原因是标识符plus_comm实际上指的是
- en: '*proof object* — a data structure that represents a logical'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*证明对象* — 代表一个逻辑的数据结构'
- en: 'derivation establishing of the truth of the statement ∀ n m : nat, n + m =
    m + n.  The type of this object *is* the statement'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 建立了∀ n m：nat，n + m = m + n的陈述的推导。这个对象的类型*是*该陈述
- en: of the theorem that it is a proof of.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它所证明的定理的类型。
- en: Intuitively, this makes sense because the statement of a theorem
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直观上，这是有道理的，因为一个定理的陈述
- en: tells us what we can use that theorem for, just as the type of a
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉我们可以使用该定理的内容，就像一个
- en: computational object tells us what we can do with that object —
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算对象告诉我们可以用该对象做什么——
- en: e.g., if we have a term of type nat → nat → nat, we can give
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个类型为nat → nat → nat的术语，我们可以给出
- en: it two nats as arguments and get a nat back.  Similarly, if we
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它两个nats作为参数，然后得到一个nat。同样，如果我们
- en: have an object of type n = m → n + n = m + m and we provide it
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一个类型为n = m → n + n = m + m的对象，我们提供它
- en: an "argument" of type n = m, we can derive n + n = m + m.
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个类型为n = m的“参数”，我们可以推导出n + n = m + m。
- en: 'Operationally, this analogy goes even further: by applying a'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在操作上，这个类比甚至更进一步：通过应用一个
- en: theorem, as if it were a function, to hypotheses with matching
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理，就像它是一个函数，对具有匹配的假设
- en: types, we can specialize its result without having to resort to
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型，我们可以专门化其结果，而无需求助于
- en: intermediate assertions.  For example, suppose we wanted to prove
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 中间断言。例如，假设我们想要证明
- en: 'the following result:'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下结果：
- en: '[PRE63]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It appears at first sight that we ought to be able to prove this
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 乍看之下，我们应该能够证明这一点
- en: by rewriting with plus_comm twice to make the two sides match.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过两次重写加上plus_comm使两边匹配。
- en: The problem, however, is that the second rewrite will undo the
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，问题在于第二次重写将撤消
- en: effect of the first.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个的效果。
- en: '[PRE64]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: One simple way of fixing this problem, using only tools that we
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修复这个问题的一个简单方法是，只使用我们的工具
- en: already know, is to use assert to derive a specialized version
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已知，是使用assert推导出一个专门化版本
- en: of plus_comm that can be used to rewrite exactly where we
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以用于精确重写的plus_comm的版本
- en: want.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想要的。
- en: '[PRE65]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: A more elegant alternative is to apply plus_comm directly to the
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个更优雅的替代方法是直接将plus_comm应用于
- en: arguments we want to instantiate it with, in much the same way as
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想要实例化它的参数，方式与
- en: we apply a polymorphic function to a type argument.
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将一个多态函数应用于一个类型参数时。
- en: '[PRE66]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can "use theorems as functions" in this way with almost all
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以以几乎所有方式“将定理用作函数”使用
- en: tactics that take a theorem name as an argument.  Note also that
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接受定理名称作为参数的策略。还要注意
- en: theorem application uses the same inference mechanisms as function
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理应用使用与函数相同的推理机制
- en: application; thus, it is possible, for example, to supply
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用；因此，例如，可以提供
- en: wildcards as arguments to be inferred, or to declare some
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通配符作为要推断的参数，或者声明一些
- en: hypotheses to a theorem as implicit by default.  These features
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下将一个定理的假设声明为隐式。这些特性
- en: are illustrated in the proof below.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的证明中进行了说明。
- en: '[PRE67]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We will see many more examples of the idioms from this section in
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中看到这一部分的习语的更多示例
- en: later chapters.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 后续章节。
- en: '[PRE68]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Example function_equality_ex[1] : plus 3 = plus (pred 4).'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 function_equality_ex[1]：plus 3 = plus (pred 4)。
- en: Proof. reflexivity. Qed.
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。反射性。Qed。
- en: '[PRE69]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: (∀x, f x = g x) → f = g
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: (∀x，f x = g x) → f = g
- en: This is known as the principle of *functional extensionality*.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这被称为*功能性外延性*原则。
- en: Informally speaking, an "extensional property" is one that
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非正式地说，一个“外延性属性”是
- en: pertains to an object's observable behavior.  Thus, functional
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与对象的可观察行为有关。因此，功能性
- en: extensionality simply means that a function's identity is
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 外延性简单地意味着函数的身份是
- en: completely determined by what we can observe from it — i.e., in
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完全由我们可以从中观察到的东西决定——即，在
- en: Coq terms, the results we obtain after applying it.
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq术语，我们在应用后获得的结果。
- en: Functional extensionality is not part of Coq's basic axioms.  This
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数外延性不是Coq的基本公理的一部分。这
- en: means that some "reasonable" propositions are not provable.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 意味着一些“合理”的命题是无法证明的。
- en: '[PRE70]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: However, we can add functional extensionality to Coq's core logic
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，我们可以将函数外延性添加到Coq的核心逻辑中
- en: using the Axiom command.
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Axiom命令。
- en: '[PRE71]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Using Axiom has the same effect as stating a theorem and
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Axiom与陈述定理具有相同的效果，并且
- en: skipping its proof using Admitted, but it alerts the reader that
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跳过使用Admitted的证明，但它提醒读者
- en: this isn't just something we're going to come back and fill in
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不仅仅是我们要回来填写的东西
- en: later!
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以后！
- en: 'We can now invoke functional extensionality in proofs:'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在可以在证明中调用函数外延性：
- en: '[PRE72]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Naturally, we must be careful when adding new axioms into Coq's
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当向Coq的核心逻辑添加新的公理时，我们必须小心
- en: logic, as they may render it *inconsistent* — that is, they may
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: make it possible to prove every proposition, including False!
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, there is no simple way of telling whether an axiom
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is safe to add: hard work is generally required to establish the'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: consistency of any particular combination of axioms.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, it is known that adding functional extensionality, in
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: particular, *is* consistent.
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To check whether a particular proof relies on any additional
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: axioms, use the Print Assumptions command.
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Exercise: 4 stars (tr_rev)'
  id: totrans-437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One problem with the definition of the list-reversing function
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rev that we have is that it performs a call to app on each
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: step; running app takes time asymptotically linear in the size
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the list, which means that rev has quadratic running time.
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can improve this with the following definition:'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This version is said to be *tail-recursive*, because the recursive
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: call to the function is the last operation that needs to be
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: performed (i.e., we don't have to execute ++ after the recursive
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: call); a decent compiler will generate very efficient code in this
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: case.  Prove that the two definitions are indeed equivalent.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ☐
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Propositions and Booleans
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen two different ways of encoding logical facts in Coq:'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with *booleans* (of type bool), and with *propositions* (of type
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Prop).
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For instance, to claim that a number n is even, we can say
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: either
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (1) that evenb n returns true, or
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (2) that there exists some k such that n = double k. Indeed, these two notions
    of evenness are equivalent, as can easily be shown with a couple of auxiliary
    lemmas.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We often say that the boolean evenb n *reflects* the proposition
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ∃ k, n = double k.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Exercise: 3 stars (evenb_double_conv)'
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ☐
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Similarly, to state that two numbers n and m are equal, we can
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: say either (1) that beq_nat n m returns true or (2) that n = m.  These two notions
    are equivalent.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: However, while the boolean and propositional formulations of a
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: claim are equivalent from a purely logical perspective, they need
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not be equivalent *operationally*.  Equality provides an extreme
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'example: knowing that beq_nat n m = true is generally of little'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: direct help in the middle of a proof involving n and m;
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: however, if we convert the statement to the equivalent form n = m, we can rewrite
    with it.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The case of even numbers is also interesting.  Recall that,
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: when proving the backwards direction of even_bool_prop (i.e.,
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evenb_double, going from the propositional to the boolean
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: claim), we used a simple induction on k.  On the other hand, the
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: converse (the evenb_double_conv exercise) required a clever
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: generalization, since we can't directly prove (∃ k, n = double k) → evenb n
    = true.
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For these examples, the propositional claims are more useful than
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: their boolean counterparts, but this is not always the case.  For
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: instance, we cannot test whether a general proposition is true or
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not in a function definition; as a consequence, the following code
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fragment is rejected:'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Coq complains that n = 2 has type Prop, while it expects an
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq抱怨n = 2具有类型Prop，而它期望一个
- en: elements of bool (or some other inductive type with two
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: bool元素（��其他具有两个的归纳类型
- en: elements).  The reason for this error message has to do with the
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 元素）。这个错误消息的原因与
- en: '*computational* nature of Coq''s core language, which is designed'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq核心语言的*计算*性质，这是设计的
- en: so that every function that it can express is computable and
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以便它能表达的每个函数都是可计算的和
- en: total.  One reason for this is to allow the extraction of
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总共。这样做的一个原因是为了允许提取
- en: executable programs from Coq developments.  As a consequence,
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从Coq开发中执行的可执行程序。因此，
- en: Prop in Coq does *not* have a universal case analysis operation
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq中的Prop没有普遍的案例分析操作
- en: telling whether any given proposition is true or false, since such
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉任何给定命题是真还是假，因为这样的
- en: an operation would allow us to write non-computable functions.
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个操作将允许我们编写不可计算的函数。
- en: Although general non-computable properties cannot be phrased as
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管一般的不可计算属性不能被表述为
- en: boolean computations, it is worth noting that even many
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布尔计算，值得注意的是，即使许多
- en: '*computable* properties are easier to express using Prop than'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*可计算*属性更容易使用Prop表达'
- en: bool, since recursive function definitions are subject to
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: bool，因为递归函数定义受到
- en: significant restrictions in Coq.  For instance, the next chapter
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq中的重要限制。例如，下一章
- en: shows how to define the property that a regular expression matches
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展示如何定义正则表达式匹配的属性
- en: a given string using Prop.  Doing the same with bool would
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Prop来处理给定的字符串。使用bool做同样的事情
- en: amount to writing a regular expression matcher, which would be
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编写一个正则表达式匹配器，这将是
- en: more complicated, harder to understand, and harder to reason
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更复杂，更难理解，更难推理
- en: about.
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于。
- en: Conversely, an important side benefit of stating facts using
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，使用陈述事实的一个重要的附带好处是
- en: booleans is enabling some proof automation through computation
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过计算使一些证明自动化成为可能
- en: 'with Coq terms, a technique known as *proof by reflection*.  Consider the following
    statement:'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与Coq术语一起使用，一种称为*反射证明*的技术。考虑以下陈述：
- en: '[PRE81]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The most direct proof of this fact is to give the value of k
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个事实的最直接证明是给出k的值
- en: explicitly.
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确地简化。
- en: '[PRE82]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: On the other hand, the proof of the corresponding boolean
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，相应布尔值的证明
- en: 'statement is even simpler:'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 陈述甚至更简单：
- en: '[PRE83]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: What is interesting is that, since the two notions are equivalent,
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有趣的是，由于这两个概念是等价的，
- en: we can use the boolean formulation to prove the other one without
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用布尔形式来证明另一个，而不需要
- en: 'mentioning the value 500 explicitly:'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确提到值500：
- en: '[PRE84]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Although we haven't gained much in terms of proof size in this
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管在这方面我们没有取得太多的证明大小
- en: case, larger proofs can often be made considerably simpler by the
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 情况下，更大的证明通常可以通过
- en: use of reflection.  As an extreme example, the Coq proof of the
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用反射。作为一个极端的例子，Coq证明了
- en: famous *4-color theorem* uses reflection to reduce the analysis of
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 著名的*四色定理*使用反射来简化
- en: hundreds of different cases to a boolean computation.  We won't
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数百个不同情况到一个布尔计算。我们不会
- en: cover reflection in great detail, but it serves as a good example
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大量细节中涵盖反射，但它作为一个很好的例子
- en: showing the complementary strengths of booleans and general
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展示布尔值和一般的互补优势
- en: propositions.
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命题。
- en: 'Exercise: 2 stars (logical_connectives)'
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星（逻辑连接词）
- en: The following lemmas relate the propositional connectives studied
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下引理涉及研究的命题连接词
- en: in this chapter to the corresponding boolean operations.
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中对应的布尔运算。
- en: '[PRE85]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ☐
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 1 star (beq_nat_false_iff)'
  id: totrans-534
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（beq_nat_false_iff）
- en: The following theorem is an alternate "negative" formulation of
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下定理是对"负面"表述的替代形式
- en: beq_nat_true_iff that is more convenient in certain
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: beq_nat_true_iff 在某些情况下更方便
- en: situations (we'll see examples in later chapters).
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 情况（我们将在后面的章节中看到例子）。
- en: '[PRE86]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ☐
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars (beq_list)'
  id: totrans-540
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星（beq_list）
- en: Given a boolean operator beq for testing equality of elements of
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定一个用于测试元素相等性的布尔运算符beq
- en: some type A, we can define a function beq_list beq for testing
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些类型A，我们可以定义一个用于测试的函数beq_list beq
- en: equality of lists with elements in A.  Complete the definition
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有元素在A中的列表的相等性。完成定义
- en: of the beq_list function below.  To make sure that your
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的beq_list函数。为了确保您的
- en: definition is correct, prove the lemma beq_list_true_iff.
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义是正确的，证明引理beq_list_true_iff。
- en: '[PRE87]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ☐
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars, recommended (All_forallb)'
  id: totrans-548
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星，推荐（All_forallb）
- en: Recall the function forallb, from the exercise
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回想一下，来自练习中的forallb函数
- en: 'forall_exists_challenge in chapter [Tactics](Tactics.html):'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: forall_exists_challenge 在章节[Tactics](Tactics.html)中：
- en: '[PRE88]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Prove the theorem below, which relates forallb to the All
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明下面的定理，它将 forallb 与 All 关联起来
- en: property of the above exercise.
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述练习的性质。
- en: '[PRE89]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Are there any important properties of the function forallb which
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数 forallb 的重要属性有哪些
- en: are not captured by this specification?
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些规范无法捕捉到吗？
- en: '[PRE90]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: ☐
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: Classical vs. Constructive Logic
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典逻辑与构造性逻辑
- en: We have seen that it is not possible to test whether or not a
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经看到无法测试一个
- en: proposition P holds while defining a Coq function.  You may be
  id: totrans-561
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命题 P 在定义 Coq 函数时成立。你可能会
- en: surprised to learn that a similar restriction applies to *proofs*!
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 惊讶地发现类似的限制也适用于*证明*！
- en: In other words, the following intuitive reasoning principle is not
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，以下直观的推理原则不成立
- en: 'derivable in Coq:'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Coq 中可推导：
- en: '[PRE91]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: To understand operationally why this is the case, recall
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在操作上理解为什么会这样，回想一下
- en: that, to prove a statement of the form P ∨ Q, we use the left
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了证明形式为 P ∨ Q 的陈述，我们使用左
- en: and right tactics, which effectively require knowing which side
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和右策略，实际上需要知道哪一边
- en: of the disjunction holds.  But the universally quantified P in
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 析取的命题成立。但普遍量化的 P 在
- en: excluded_middle is an *arbitrary* proposition, which we know
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: excluded_middle 是一个*任意*命题，我们知道
- en: nothing about.  We don't have enough information to choose which
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 什么都不知道。我们没有足够的信息来选择哪个
- en: of left or right to apply, just as Coq doesn't have enough
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 左边或右边要应用，就像 Coq 没有足够的
- en: information to mechanically decide whether P holds or not inside
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息来机械地决定 P 在内部是成立还是不成立。
- en: a function.
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个函数。
- en: However, if we happen to know that P is reflected in some
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，如果我们碰巧知道 P 在某些地方反映出来
- en: 'boolean term b, then knowing whether it holds or not is trivial:'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布尔术语 b，那么知道它是否成立或不成立是微不足道的：
- en: we just have to check the value of b.
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只需检查 b 的值。
- en: '[PRE92]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In particular, the excluded middle is valid for equations n = m,
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是，排中律对于方程 n = m 是有效的，
- en: between natural numbers n and m.
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两个自然数 n 和 m 之间。
- en: '[PRE93]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: It may seem strange that the general excluded middle is not
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看起来奇怪的是，一般的排中律不是
- en: available by default in Coq; after all, any given claim must be
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 中默认可用；毕竟，任何给定的声明必须是
- en: either true or false.  Nonetheless, there is an advantage in not
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要么是真的，要么是假的。尽管如此，不
- en: 'assuming the excluded middle: statements in Coq can make stronger'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设排中律：Coq 中的陈述可以做出更强的
- en: claims than the analogous statements in standard mathematics.
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声称比标准数学中的类似陈述更强。
- en: Notably, if there is a Coq proof of ∃ x, P x, it is
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值得注意的是，如果存在 Coq 证明 ∃ x, P x，那么
- en: possible to explicitly exhibit a value of x for which we can
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 明确展示一个值 x，我们可以
- en: prove P x — in other words, every proof of existence is
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明 P x — 换句话说，每个存在的证明都是
- en: necessarily *constructive*.
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须是*构造性*的。
- en: Logics like Coq's, which do not assume the excluded middle, are
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似 Coq 的逻辑，不假设排中律，
- en: referred to as *constructive logics*.
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被称为*构造性逻辑*。
- en: More conventional logical systems such as ZFC, in which the
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更传统的逻辑系统，如 ZFC，在其中
- en: excluded middle does hold for arbitrary propositions, are referred
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 排中律是否适用于任意命题，都被称���
- en: to as *classical*.
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 称为*经典*。
- en: The following example illustrates why assuming the excluded middle
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例说明了为什么假设排中律
- en: 'may lead to non-constructive proofs:'
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能导致非构造性证明：
- en: '*Claim*: There exist irrational numbers a and b such that a ^ b is rational.'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*声明*：存在无理数 a 和 b，使得 a ^ b 是有理数。'
- en: '*Proof*: It is not difficult to show that sqrt 2 is irrational.'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*证明*：很容易证明 sqrt 2 是无理数。'
- en: If sqrt 2 ^ sqrt 2 is rational, it suffices to take a = b = sqrt 2 and we are
    done.  Otherwise, sqrt 2 ^ sqrt 2 is
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 sqrt 2 ^ sqrt 2 是有理数，只需取 a = b = sqrt 2 就可以了。否则，sqrt 2 ^ sqrt 2 是
- en: irrational.  In this case, we can take a = sqrt 2 ^ sqrt 2 and
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无理数。在这种情况下，我们可以取 a = sqrt 2 ^ sqrt 2 和
- en: b = sqrt 2, since a ^ b = sqrt 2 ^ (sqrt 2 * sqrt 2) = sqrt 2 ^ 2 = 2.  ☐
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b = sqrt 2，因为 a ^ b = sqrt 2 ^ (sqrt 2 * sqrt 2) = sqrt 2 ^ 2 = 2。 ☐
- en: Do you see what happened here?  We used the excluded middle to
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你看到这里发生了什么吗？我们使用排中律来
- en: consider separately the cases where sqrt 2 ^ sqrt 2 is rational
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分别考虑 sqrt 2 ^ sqrt 2 是有理数的情况
- en: and where it is not, without knowing which one actually holds!
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不知道哪一个实际上成立！
- en: Because of that, we wind up knowing that such a and b exist
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这个原因，我们最终知道这样的 a 和 b 存在
- en: but we cannot determine what their actual values are (at least,
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但我们无法确定它们的实际值是什么（至少
- en: using this line of argument).
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这种论证方式）。
- en: 'As useful as constructive logic is, it does have its limitations:'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管建设性逻辑很有用，但它也有局限性：
- en: There are many statements that can easily be proven in classical
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有许多陈述在古典逻辑中很容易证明。
- en: logic but that have much more complicated constructive proofs, and
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 逻辑，但具有更复杂的建设性证明，并且
- en: there are some that are known to have no constructive proof at
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有一些已知没有建设性证明的
- en: all!  Fortunately, like functional extensionality, the excluded
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 全部！幸运的是，像函数外延性一样，排除
- en: middle is known to be compatible with Coq's logic, allowing us to
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 中间是已知与 Coq 的逻辑兼容的，使我们能够
- en: add it safely as an axiom.  However, we will not need to do so in
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安全地添加它作为公理。但是，在
- en: 'this book: the results that we cover can be developed entirely'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这本书中：我们涵盖的结果可以完全发展
- en: within constructive logic at negligible extra cost.
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在建设性逻辑中几乎没有额外成本。
- en: It takes some practice to understand which proof techniques must
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要一些实践来理解哪些证明技术必须
- en: be avoided in constructive reasoning, but arguments by
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在建设性推理中应避免，但通过论证
- en: contradiction, in particular, are infamous for leading to
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 矛盾，特别是以臭名昭著的方式导致
- en: 'non-constructive proofs.  Here''s a typical example: suppose that'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非建设性证明。这里是一个典型的例子：假设
- en: we want to show that there exists x with some property P,
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想要展示存在具有某种属性 P 的 x，
- en: i.e., such that P x.  We start by assuming that our conclusion
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，使得 P x。我们首先假设我们的结论
- en: is false; that is, ¬ ∃ x, P x. From this premise, it is not
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是错误的；也就是说，¬ ∃ x, P x。从这个前提出发，不
- en: hard to derive ∀ x, ¬ P x.  If we manage to show that this
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 难以推导出 ∀ x, ¬ P x。如果我们设法证明这一点
- en: intermediate fact results in a contradiction, we arrive at an
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 中间事实导致矛盾，我们得到一个
- en: existence proof without ever exhibiting a value of x for which
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存在证明而从未展示出 x 的值
- en: P x holds!
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P x 成立！
- en: The technical flaw here, from a constructive standpoint, is that
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从建设性的角度来看，这里的技术缺陷是
- en: we claimed to prove ∃ x, P x using a proof of
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们声称使用证明 ∃ x, P x 来证明
- en: ¬ ¬ (∃ x, P x).  Allowing ourselves to remove double
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ¬ ¬ (∃ x, P x)。允许我们去除双重
- en: negations from arbitrary statements is equivalent to assuming the
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从任意陈述中推导出否定等同于假设
- en: excluded middle, as shown in one of the exercises below.  Thus,
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 排除中间，如下面的一个练习所示。因此，
- en: this line of reasoning cannot be encoded in Coq without assuming
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种推理不能在不假设的情况下编码到 Coq 中
- en: additional axioms.
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 额外的公理。
- en: 'Exercise: 3 stars (excluded_middle_irrefutable)'
  id: totrans-636
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3 星（excluded_middle_irrefutable）
- en: The consistency of Coq with the general excluded middle axiom
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 与普遍排除中间公理的一致性
- en: requires complicated reasoning that cannot be carried out within
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要复杂的推理，无法在内部执行
- en: Coq itself.  However, the following theorem implies that it is
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 本身。但是，以下定理暗示着它是
- en: always safe to assume a decidability axiom (i.e., an instance of
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 始终可以假设一个可决定性公理（即，一个实例
- en: excluded middle) for any *particular* Prop P.  Why? Because we
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何*特定* Prop P。为什么？因为我们
- en: cannot prove the negation of such an axiom; if we could, we would
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无法证明这种公理的否定；如果我们可以，我们将
- en: have both ¬ (P ∨ ¬P) and ¬ ¬ (P ∨ ¬P), a contradiction.
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时具有¬ (P ∨ ¬P) 和 ¬ ¬ (P ∨ ¬P)，矛盾。
- en: '[PRE94]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: ☐
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, advanced (not_exists_dist)'
  id: totrans-646
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3 星，高级（not_exists_dist）
- en: It is a theorem of classical logic that the following two
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是古典逻辑的一个定理，以下两个
- en: 'assertions are equivalent:'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 断言是等价的：
- en: '[PRE95]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Theorem not_exists_dist :'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 not_exists_dist：
- en: excluded_middle →
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 排除中间 →
- en: '∀(X:Type) (P : X → Prop),'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(X:Type) (P : X → Prop)，'
- en: ¬ (∃x, ¬ P x) → (∀x, P x).
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: ¬ (∃x, ¬ P x) → (∀x, P x)。
- en: Proof.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) Admitted。
- en: '[PRE96]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Definition peirce := ∀P Q: Prop,'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 peirce := ∀P Q: Prop，'
- en: ((P→Q)→P)→P.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: ((P→Q)→P)→P。
- en: Definition double_negation_elimination := ∀P:Prop,
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 double_negation_elimination := ∀P:Prop，
- en: ~~P → P.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: ~~P → P。
- en: Definition de_morgan_not_and_not := ∀P Q:Prop,
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 de_morgan_not_and_not := ∀P Q:Prop，
- en: ~(~P ∧ ¬Q) → P∨Q.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: ~(~P ∧ ¬Q) → P∨Q。
- en: Definition implies_to_or := ∀P Q:Prop,
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 implies_to_or := ∀P Q:Prop，
- en: (P→Q) → (¬P∨Q).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: (P→Q) → (¬P∨Q)。
- en: (* FILL IN HERE *)
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *)
- en: '[PRE97]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
