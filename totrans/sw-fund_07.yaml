- en: LogicLogic in Coq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export Tactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Check 3 = 3.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check ∀n m : nat, n + m = m + n.'
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Check ∀n : nat, n = 2.'
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: Check 3 = 4.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_2_2_is_4 :'
  prefs: []
  type: TYPE_NORMAL
- en: 2 + 2 = 4.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition plus_fact : Prop := 2 + 2 = 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Check plus_fact.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> plus_fact : Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_fact_is_true :'
  prefs: []
  type: TYPE_NORMAL
- en: plus_fact.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition is_three (n : nat) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: n = 3.
  prefs: []
  type: TYPE_NORMAL
- en: Check is_three.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> nat -> Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition injective {A B} (f : A → B) :='
  prefs: []
  type: TYPE_NORMAL
- en: '∀x y : A, f x = f y → x = y.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma succ_inj : injective S.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m H. inversion H. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Check @eq.
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> forall A : Type, A -> A -> Prop *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Logical Connectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conjunction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *conjunction* (or *logical and*) of propositions A and B
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is written A ∧ B, representing the claim that both A and B
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are true.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To prove a conjunction, use the split tactic.  It will generate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'two subgoals, one for each part of the statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For any propositions A and B, if we assume that A is true
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and we assume that B is true, we can conclude that A ∧ B is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: also true.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since applying a theorem with hypotheses to some goal has the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: effect of generating as many subgoals as there are hypotheses for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that theorem, we can apply and_intro to achieve the same effect
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: as split.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars (and_exercise)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So much for proving conjunctive statements.  To go in the other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: direction — i.e., to *use* a conjunctive hypothesis to help prove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: something else — we employ the destruct tactic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the proof context contains a hypothesis H of the form
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A ∧ B, writing destruct H as [HA HB] will remove H from the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'context and add two new hypotheses: HA, stating that A is'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: true, and HB, stating that B is true.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we can also destruct H right when we introduce it,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'instead of introducing and then destructing it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You may wonder why we bothered packing the two hypotheses n = 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and m = 0 into a single conjunction, since we could have also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'stated the theorem with two separate premises:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For this theorem, both formulations are fine.  But it's important
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to understand how to work with conjunctive hypotheses because
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conjunctions often arise from intermediate steps in proofs,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'especially in bigger developments.  Here''s a simple example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Another common situation with conjunctions is that we know
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A ∧ B but in some context we need just A (or just B).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following lemmas are useful in such cases:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optional (proj2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we sometimes need to rearrange the order of conjunctions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and/or the grouping of multi-way conjunctions.  The following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: commutativity and associativity theorems are handy in such
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars (and_assoc)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: (In the following proof of associativity, notice how the *nested*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'intro pattern breaks the hypothesis H : P ∧ (Q ∧ R) down into'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'HP : P, HQ : Q, and HR : R.  Finish the proof from'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: there.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By the way, the infix notation ∧ is actually just syntactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sugar for and A B.  That is, and is a Coq operator that takes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: two propositions as arguments and yields a proposition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Disjunction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important connective is the *disjunction*, or *logical or*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'of two propositions: A ∨ B is true when either A or B'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is.  (Alternatively, we can write or A B, where or : Prop → Prop → Prop.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To use a disjunctive hypothesis in a proof, we proceed by case
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: analysis, which, as for nat or other data types, can be done
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with destruct or intros.  Here is an example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, to show that a disjunction holds, we need to show that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: one of its sides does. This is done via two tactics, left and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: right.  As their names imply, the first one requires
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proving the left side of the disjunction, while the second
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: requires proving its right side.  Here is a trivial use...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '... and a slightly more interesting example requiring both left'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'and right:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (mult_eq_0)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (or_commut)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Falsehood and Negation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have mostly been concerned with proving that certain
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: things are *true* — addition is commutative, appending lists is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: associative, etc.  Of course, we may also be interested in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*negative* results, showing that certain propositions are *not*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: true. In Coq, such negative statements are expressed with the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: negation operator ¬.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To see how negation works, recall the discussion of the *principle of explosion*
    from the [Tactics](Tactics.html) chapter; it asserts that, if we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assume a contradiction, then any other proposition can be derived.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Following this intuition, we could define ¬ P ("not P") as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ∀ Q, P → Q.  Coq actually makes a slightly different
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: choice, defining ¬ P as P → False, where False is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*particular* contradictory proposition defined in the standard'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since False is a contradictory proposition, the principle of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: explosion also applies to it. If we get False into the proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'context, we can destruct it to complete any goal:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The Latin *ex falso quodlibet* means, literally, "from falsehood
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: follows whatever you like"; this is another common name for the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: principle of explosion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (not_implies_our_not)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Show that Coq's definition of negation implies the intuitive one
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mentioned above:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is how we use not to state that 0 and 1 are different
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'elements of nat:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Such inequality statements are frequent enough to warrant a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'special notation, x ≠ y:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: It takes a little practice to get used to working with negation in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq.  Even though you can see perfectly well why a statement
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involving negation is true, it can be a little tricky at first to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get things into the right configuration so that Coq can understand
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it!  Here are proofs of a few familiar facts to get you warmed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, advanced, recommendedM (double_neg_inf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write an informal proof of double_neg:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Theorem*: P implies ~~P, for any proposition P.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, recommended (contrapositive)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (not_both_true_and_false)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, advancedM (informal_not_PNP)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write an informal proof (in English) of the proposition ∀ P : Prop, ~(P ∧ ¬P).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, since inequality involves a negation, it requires a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: little practice to be able to work with it fluently.  Here is one
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: useful trick.  If you are trying to prove a goal that is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nonsensical (e.g., the goal state is false = true), apply
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ex_falso_quodlibet to change the goal to False.  This makes it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: easier to use assumptions of the form ¬P that may be available
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the context — in particular, assumptions of the form
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x≠y.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Since reasoning with ex_falso_quodlibet is quite common, Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: provides a built-in tactic, exfalso, for applying it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Truth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides False, Coq's standard library also defines True, a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proposition that is trivially true. To prove it, we use the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'predefined constant I : True:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Unlike False, which is used extensively, True is used quite
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rarely, since it is trivial (and therefore uninteresting) to prove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: as a goal, and it carries no useful information as a hypothesis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But it can be quite useful when defining complex Props using
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: conditionals or as a parameter to higher-order Props.  We will
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: see examples of such uses of True later on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Logical Equivalence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The handy "if and only if" connective, which asserts that two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: propositions have the same truth value, is just the conjunction of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: two implications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optional (iff_properties)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the above proof that ↔ is symmetric (iff_sym) as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a guide, prove that it is also reflexive and transitive.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (or_distributes_over_and)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Some of Coq's tactics treat iff statements specially, avoiding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the need for some low-level proof-state manipulation.  In
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: particular, rewrite and reflexivity can be used with iff
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: statements, not just equalities.  To enable this behavior, we need
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to import a special Coq library that allows rewriting with other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'formulas besides equality:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here is a simple example demonstrating how these tactics work with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: iff.  First, let's prove a couple of basic iff equivalences...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can now use these facts with rewrite and reflexivity to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: give smooth proofs of statements involving equivalences.  Here is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'a ternary version of the previous mult_0 result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The apply tactic can also be used with ↔. When given an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equivalence as its argument, apply tries to guess which side of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the equivalence to use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Existential Quantification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important logical connective is *existential quantification*.  To say
    that there is some x of type T such
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'that some property P holds of x, we write ∃ x : T, P. As with ∀, the type annotation
    : T can be omitted if'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq is able to infer from the context what the type of x should
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: be.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To prove a statement of the form ∃ x, P, we must show that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P holds for some specific choice of value for x, known as the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*witness* of the existential.  This is done in two steps: First,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we explicitly tell Coq which witness t we have in mind by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: invoking the tactic ∃ t.  Then we prove that P holds after
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all occurrences of x are replaced by t.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, if we have an existential hypothesis ∃ x, P in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the context, we can destruct it to obtain a witness x and a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypothesis stating that P holds of x.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (dist_not_exists)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove that "P holds for all x" implies "there is no x for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which P does not hold."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (dist_exists_or)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove that existential quantification distributes over
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: disjunction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint In {A : Type} (x : A) (l : list A) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| [] ⇒ False'
  prefs: []
  type: TYPE_NORMAL
- en: '| x'' :: l'' ⇒ x'' = x ∨ In x l'''
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Example In_example_1 : In 4 [1; 2; 3; 4; 5].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: simpl. right. right. right. left. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example In_example_2 :'
  prefs: []
  type: TYPE_NORMAL
- en: ∀n, In n [2; 4] →
  prefs: []
  type: TYPE_NORMAL
- en: ∃n', n = 2 * n'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: simpl.
  prefs: []
  type: TYPE_NORMAL
- en: intros n [H | [H | []]].
  prefs: []
  type: TYPE_NORMAL
- en: '- ∃1\. rewrite ← H. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- ∃2\. rewrite ← H. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma In_map :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(A B : Type) (f : A → B) (l : list A) (x : A),'
  prefs: []
  type: TYPE_NORMAL
- en: In x l →
  prefs: []
  type: TYPE_NORMAL
- en: In (f x) (map f l).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros A B f l x.
  prefs: []
  type: TYPE_NORMAL
- en: induction l as [|x' l' IHl'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l = nil, contradiction *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. intros [].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l = x'' :: l'' *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. intros [H | H].
  prefs: []
  type: TYPE_NORMAL
- en: + rewrite H. left. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: + right. apply IHl'. apply H.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma In_map_iff :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(A B : Type) (f : A → B) (l : list A) (y : B),'
  prefs: []
  type: TYPE_NORMAL
- en: In y (map f l) ↔
  prefs: []
  type: TYPE_NORMAL
- en: ∃x, f x = y ∧ In x l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma in_app_iff : ∀A l l'' (a:A),'
  prefs: []
  type: TYPE_NORMAL
- en: In a (l++l') ↔ In a l ∨ In a l'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint All {T : Type} (P : T → Prop) (l : list T) : Prop'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma All_In :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀T (P : T → Prop) (l : list T),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀x, In x l → P x) ↔
  prefs: []
  type: TYPE_NORMAL
- en: All P l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition combine_odd_even (Podd Peven : nat → Prop) : nat → Prop'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem combine_odd_even_intro :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(Podd Peven : nat → Prop) (n : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: (oddb n = true → Podd n) →
  prefs: []
  type: TYPE_NORMAL
- en: (oddb n = false → Peven n) →
  prefs: []
  type: TYPE_NORMAL
- en: combine_odd_even Podd Peven n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem combine_odd_even_elim_odd :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(Podd Peven : nat → Prop) (n : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: combine_odd_even Podd Peven n →
  prefs: []
  type: TYPE_NORMAL
- en: oddb n = true →
  prefs: []
  type: TYPE_NORMAL
- en: Podd n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem combine_odd_even_elim_even :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(Podd Peven : nat → Prop) (n : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: combine_odd_even Podd Peven n →
  prefs: []
  type: TYPE_NORMAL
- en: oddb n = false →
  prefs: []
  type: TYPE_NORMAL
- en: Peven n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Applying Theorems to Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One feature of Coq that distinguishes it from many other proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assistants is that it treats *proofs* as first-class objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is a great deal to be said about this, but it is not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: necessary to understand it in detail in order to use Coq.  This
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: section gives just a taste, while a deeper exploration can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: found in the optional chapters ProofObjects and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IndPrinciples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have seen that we can use the Check command to ask Coq to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print the type of an expression.  We can also use Check to ask
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: what theorem a particular identifier refers to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Coq prints the *statement* of the plus_comm theorem in the same
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: way that it prints the *type* of any term that we ask it to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Check.  Why?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The reason is that the identifier plus_comm actually refers to a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*proof object* — a data structure that represents a logical'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'derivation establishing of the truth of the statement ∀ n m : nat, n + m =
    m + n.  The type of this object *is* the statement'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the theorem that it is a proof of.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Intuitively, this makes sense because the statement of a theorem
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tells us what we can use that theorem for, just as the type of a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: computational object tells us what we can do with that object —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e.g., if we have a term of type nat → nat → nat, we can give
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it two nats as arguments and get a nat back.  Similarly, if we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have an object of type n = m → n + n = m + m and we provide it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: an "argument" of type n = m, we can derive n + n = m + m.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Operationally, this analogy goes even further: by applying a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: theorem, as if it were a function, to hypotheses with matching
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: types, we can specialize its result without having to resort to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intermediate assertions.  For example, suppose we wanted to prove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: It appears at first sight that we ought to be able to prove this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by rewriting with plus_comm twice to make the two sides match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The problem, however, is that the second rewrite will undo the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: effect of the first.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: One simple way of fixing this problem, using only tools that we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: already know, is to use assert to derive a specialized version
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of plus_comm that can be used to rewrite exactly where we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: A more elegant alternative is to apply plus_comm directly to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arguments we want to instantiate it with, in much the same way as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we apply a polymorphic function to a type argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can "use theorems as functions" in this way with almost all
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactics that take a theorem name as an argument.  Note also that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: theorem application uses the same inference mechanisms as function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: application; thus, it is possible, for example, to supply
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: wildcards as arguments to be inferred, or to declare some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypotheses to a theorem as implicit by default.  These features
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are illustrated in the proof below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We will see many more examples of the idioms from this section in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: later chapters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Example function_equality_ex[1] : plus 3 = plus (pred 4).'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: (∀x, f x = g x) → f = g
  prefs: []
  type: TYPE_NORMAL
- en: This is known as the principle of *functional extensionality*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Informally speaking, an "extensional property" is one that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pertains to an object's observable behavior.  Thus, functional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: extensionality simply means that a function's identity is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: completely determined by what we can observe from it — i.e., in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq terms, the results we obtain after applying it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Functional extensionality is not part of Coq's basic axioms.  This
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: means that some "reasonable" propositions are not provable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: However, we can add functional extensionality to Coq's core logic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using the Axiom command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Using Axiom has the same effect as stating a theorem and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: skipping its proof using Admitted, but it alerts the reader that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this isn't just something we're going to come back and fill in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: later!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now invoke functional extensionality in proofs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Naturally, we must be careful when adding new axioms into Coq's
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: logic, as they may render it *inconsistent* — that is, they may
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: make it possible to prove every proposition, including False!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, there is no simple way of telling whether an axiom
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is safe to add: hard work is generally required to establish the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: consistency of any particular combination of axioms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, it is known that adding functional extensionality, in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: particular, *is* consistent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To check whether a particular proof relies on any additional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: axioms, use the Print Assumptions command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 4 stars (tr_rev)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One problem with the definition of the list-reversing function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rev that we have is that it performs a call to app on each
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: step; running app takes time asymptotically linear in the size
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the list, which means that rev has quadratic running time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can improve this with the following definition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This version is said to be *tail-recursive*, because the recursive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: call to the function is the last operation that needs to be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: performed (i.e., we don't have to execute ++ after the recursive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: call); a decent compiler will generate very efficient code in this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: case.  Prove that the two definitions are indeed equivalent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Propositions and Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen two different ways of encoding logical facts in Coq:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with *booleans* (of type bool), and with *propositions* (of type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Prop).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For instance, to claim that a number n is even, we can say
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: either
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (1) that evenb n returns true, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (2) that there exists some k such that n = double k. Indeed, these two notions
    of evenness are equivalent, as can easily be shown with a couple of auxiliary
    lemmas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We often say that the boolean evenb n *reflects* the proposition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ∃ k, n = double k.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars (evenb_double_conv)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, to state that two numbers n and m are equal, we can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: say either (1) that beq_nat n m returns true or (2) that n = m.  These two notions
    are equivalent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: However, while the boolean and propositional formulations of a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: claim are equivalent from a purely logical perspective, they need
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not be equivalent *operationally*.  Equality provides an extreme
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'example: knowing that beq_nat n m = true is generally of little'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: direct help in the middle of a proof involving n and m;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: however, if we convert the statement to the equivalent form n = m, we can rewrite
    with it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The case of even numbers is also interesting.  Recall that,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: when proving the backwards direction of even_bool_prop (i.e.,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evenb_double, going from the propositional to the boolean
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: claim), we used a simple induction on k.  On the other hand, the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: converse (the evenb_double_conv exercise) required a clever
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: generalization, since we can't directly prove (∃ k, n = double k) → evenb n
    = true.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For these examples, the propositional claims are more useful than
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: their boolean counterparts, but this is not always the case.  For
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: instance, we cannot test whether a general proposition is true or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: not in a function definition; as a consequence, the following code
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fragment is rejected:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Coq complains that n = 2 has type Prop, while it expects an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elements of bool (or some other inductive type with two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: elements).  The reason for this error message has to do with the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*computational* nature of Coq''s core language, which is designed'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so that every function that it can express is computable and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: total.  One reason for this is to allow the extraction of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: executable programs from Coq developments.  As a consequence,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Prop in Coq does *not* have a universal case analysis operation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: telling whether any given proposition is true or false, since such
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: an operation would allow us to write non-computable functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although general non-computable properties cannot be phrased as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: boolean computations, it is worth noting that even many
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*computable* properties are easier to express using Prop than'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: bool, since recursive function definitions are subject to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: significant restrictions in Coq.  For instance, the next chapter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: shows how to define the property that a regular expression matches
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a given string using Prop.  Doing the same with bool would
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: amount to writing a regular expression matcher, which would be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: more complicated, harder to understand, and harder to reason
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Conversely, an important side benefit of stating facts using
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: booleans is enabling some proof automation through computation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with Coq terms, a technique known as *proof by reflection*.  Consider the following
    statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The most direct proof of this fact is to give the value of k
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: explicitly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the proof of the corresponding boolean
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'statement is even simpler:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: What is interesting is that, since the two notions are equivalent,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we can use the boolean formulation to prove the other one without
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'mentioning the value 500 explicitly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Although we haven't gained much in terms of proof size in this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: case, larger proofs can often be made considerably simpler by the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use of reflection.  As an extreme example, the Coq proof of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: famous *4-color theorem* uses reflection to reduce the analysis of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hundreds of different cases to a boolean computation.  We won't
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cover reflection in great detail, but it serves as a good example
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: showing the complementary strengths of booleans and general
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: propositions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (logical_connectives)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following lemmas relate the propositional connectives studied
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in this chapter to the corresponding boolean operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (beq_nat_false_iff)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following theorem is an alternate "negative" formulation of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: beq_nat_true_iff that is more convenient in certain
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: situations (we'll see examples in later chapters).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (beq_list)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given a boolean operator beq for testing equality of elements of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: some type A, we can define a function beq_list beq for testing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equality of lists with elements in A.  Complete the definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the beq_list function below.  To make sure that your
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition is correct, prove the lemma beq_list_true_iff.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, recommended (All_forallb)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall the function forallb, from the exercise
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'forall_exists_challenge in chapter [Tactics](Tactics.html):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Prove the theorem below, which relates forallb to the All
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: property of the above exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Are there any important properties of the function forallb which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are not captured by this specification?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Classical vs. Constructive Logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen that it is not possible to test whether or not a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proposition P holds while defining a Coq function.  You may be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: surprised to learn that a similar restriction applies to *proofs*!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In other words, the following intuitive reasoning principle is not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'derivable in Coq:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: To understand operationally why this is the case, recall
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that, to prove a statement of the form P ∨ Q, we use the left
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and right tactics, which effectively require knowing which side
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the disjunction holds.  But the universally quantified P in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: excluded_middle is an *arbitrary* proposition, which we know
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nothing about.  We don't have enough information to choose which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of left or right to apply, just as Coq doesn't have enough
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: information to mechanically decide whether P holds or not inside
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, if we happen to know that P is reflected in some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'boolean term b, then knowing whether it holds or not is trivial:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we just have to check the value of b.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In particular, the excluded middle is valid for equations n = m,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: between natural numbers n and m.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: It may seem strange that the general excluded middle is not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: available by default in Coq; after all, any given claim must be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: either true or false.  Nonetheless, there is an advantage in not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'assuming the excluded middle: statements in Coq can make stronger'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: claims than the analogous statements in standard mathematics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notably, if there is a Coq proof of ∃ x, P x, it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: possible to explicitly exhibit a value of x for which we can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: prove P x — in other words, every proof of existence is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: necessarily *constructive*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Logics like Coq's, which do not assume the excluded middle, are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: referred to as *constructive logics*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More conventional logical systems such as ZFC, in which the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: excluded middle does hold for arbitrary propositions, are referred
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to as *classical*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The following example illustrates why assuming the excluded middle
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'may lead to non-constructive proofs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Claim*: There exist irrational numbers a and b such that a ^ b is rational.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Proof*: It is not difficult to show that sqrt 2 is irrational.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If sqrt 2 ^ sqrt 2 is rational, it suffices to take a = b = sqrt 2 and we are
    done.  Otherwise, sqrt 2 ^ sqrt 2 is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: irrational.  In this case, we can take a = sqrt 2 ^ sqrt 2 and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b = sqrt 2, since a ^ b = sqrt 2 ^ (sqrt 2 * sqrt 2) = sqrt 2 ^ 2 = 2.  ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do you see what happened here?  We used the excluded middle to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: consider separately the cases where sqrt 2 ^ sqrt 2 is rational
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and where it is not, without knowing which one actually holds!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because of that, we wind up knowing that such a and b exist
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: but we cannot determine what their actual values are (at least,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using this line of argument).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As useful as constructive logic is, it does have its limitations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are many statements that can easily be proven in classical
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: logic but that have much more complicated constructive proofs, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: there are some that are known to have no constructive proof at
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all!  Fortunately, like functional extensionality, the excluded
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: middle is known to be compatible with Coq's logic, allowing us to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: add it safely as an axiom.  However, we will not need to do so in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'this book: the results that we cover can be developed entirely'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: within constructive logic at negligible extra cost.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It takes some practice to understand which proof techniques must
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: be avoided in constructive reasoning, but arguments by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: contradiction, in particular, are infamous for leading to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'non-constructive proofs.  Here''s a typical example: suppose that'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we want to show that there exists x with some property P,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: i.e., such that P x.  We start by assuming that our conclusion
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is false; that is, ¬ ∃ x, P x. From this premise, it is not
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hard to derive ∀ x, ¬ P x.  If we manage to show that this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intermediate fact results in a contradiction, we arrive at an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: existence proof without ever exhibiting a value of x for which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P x holds!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The technical flaw here, from a constructive standpoint, is that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we claimed to prove ∃ x, P x using a proof of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ¬ ¬ (∃ x, P x).  Allowing ourselves to remove double
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: negations from arbitrary statements is equivalent to assuming the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: excluded middle, as shown in one of the exercises below.  Thus,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this line of reasoning cannot be encoded in Coq without assuming
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: additional axioms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (excluded_middle_irrefutable)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The consistency of Coq with the general excluded middle axiom
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: requires complicated reasoning that cannot be carried out within
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq itself.  However, the following theorem implies that it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: always safe to assume a decidability axiom (i.e., an instance of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: excluded middle) for any *particular* Prop P.  Why? Because we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cannot prove the negation of such an axiom; if we could, we would
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have both ¬ (P ∨ ¬P) and ¬ ¬ (P ∨ ¬P), a contradiction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced (not_exists_dist)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is a theorem of classical logic that the following two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'assertions are equivalent:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem not_exists_dist :'
  prefs: []
  type: TYPE_NORMAL
- en: excluded_middle →
  prefs: []
  type: TYPE_NORMAL
- en: '∀(X:Type) (P : X → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: ¬ (∃x, ¬ P x) → (∀x, P x).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition peirce := ∀P Q: Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: ((P→Q)→P)→P.
  prefs: []
  type: TYPE_NORMAL
- en: Definition double_negation_elimination := ∀P:Prop,
  prefs: []
  type: TYPE_NORMAL
- en: ~~P → P.
  prefs: []
  type: TYPE_NORMAL
- en: Definition de_morgan_not_and_not := ∀P Q:Prop,
  prefs: []
  type: TYPE_NORMAL
- en: ~(~P ∧ ¬Q) → P∨Q.
  prefs: []
  type: TYPE_NORMAL
- en: Definition implies_to_or := ∀P Q:Prop,
  prefs: []
  type: TYPE_NORMAL
- en: (P→Q) → (¬P∨Q).
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
