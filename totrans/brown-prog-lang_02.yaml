- en: 2Basic Data and Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2基本数据和表达式
- en: '|     [2.1 Numbers](#%28part._.Numbers%29) |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [2.1 数字](#%28part._.数字%29) |'
- en: '|     [2.2 Expressions Versus Values](#%28part._.Expressions_.Versus_.Values%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [2.2 表达式与值](#%28part._.表达式与值%29) |'
- en: '|     [2.3 Variables to Name Values](#%28part._.Variables_to_.Name_.Values%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|     [2.3 变量来命名值](#%28part._.变量来_.命名_.值%29) |'
- en: '|     [2.4 Strings](#%28part._.Strings%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|     [2.4 字符串](#%28part._.字符串%29) |'
- en: '|       [2.4.1 Multi-Line Strings](#%28part._.Multi-.Line_.Strings%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [2.4.1 多行字符串](#%28part._.多行_.字符串%29) |'
- en: '|       [2.4.2 Operations on Strings](#%28part._.Operations_on_.Strings%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [2.4.2 字符串操作](#%28part._.字符串操作%29) |'
- en: '|     [2.5 Booleans](#%28part._booleans%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|     [2.5 布尔值](#%28part._.布尔值%29) |'
- en: '|       [2.5.1 Other Comparisons](#%28part._.Other_.Comparisons%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [2.5.1 其他比较](#%28part._.其他_.比较%29) |'
- en: '|       [2.5.2 Other Boolean-Producing Operations](#%28part._.Other_.Boolean-.Producing_.Operations%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [2.5.2 其他布尔值产生操作](#%28part._.其他_.布尔值产生_.操作%29) |'
- en: '|       [2.5.3 Combining Booleans](#%28part._.Combining_.Booleans%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|       [2.5.3 组合布尔值](#%28part._.组合_.布尔值%29) |'
- en: '|       [2.5.4 Using Booleans](#%28part._.Using_.Booleans%29) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [2.5.4 使用布尔值](#%28part._.使用_.布尔值%29) |'
- en: '|     [2.6 Evaluating by Reducing Expressions](#%28part._.Evaluating_by_.Reducing_.Expressions%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|     [2.6 通过简化表达式来评估](#%28part._.通过简化_.表达式来_.评估%29) |'
- en: '|     [2.7 Images](#%28part._.Images%29) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|     [2.7 图片](#%28part._.图片%29) |'
- en: '|     [2.8 Roughnums](#%28part._.Roughnums%29) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|     [2.8 Roughnums](#%28part._.Roughnums%29) |'
- en: 'Let’s think about some of the programs we use. We might use Google, a search
    engine: it consumes a search query and produces a search results. We may use Facebook,
    a social network: it consumes information about our friendships and produces updates
    from our friends. We could use Amazon, a store: it consumes descriptions of things
    we’re interested in and produces lists of products that match our descriptions.
    We sometimes use Weather.com, a weather site: it consumes our location and produces
    a weather forecast for that location. In fact these systems consume and produce
    even more: they consume our history of past preferences, and produce ads, recommendations
    for related products [REF collaborative filtering], and so on. In short, programs
    consume and produce information.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些我们使用的程序。我们可能会使用谷歌，一个搜索引擎：它消耗一个搜索查询并生成搜索结果。我们可能会使用 Facebook，一个社交网络：它消耗关于我们友谊的信息并生成我们朋友的更新。我们可能会使用亚马逊，一个商店：它消耗我们感兴趣的事物的描述并生成与我们描述相匹配的产品列表。有时我们会使用
    Weather.com，一个天气网站：它消耗我们的位置并为该位置生成天气预报。实际上，这些系统消耗和产生更多信息：它们消耗我们过去的偏好历史，并产生广告，相关产品的推荐
    [REF 协同过滤]，等等。简而言之，程序消耗和产生信息。
- en: 'Information is a fuzzy term; what computers actually consume and produce are
    what we call data. The difference is subtle but important. “Our location” is a
    vague concept, but what a weather site actually consumes is a very concrete representation
    of it, such as the name of a city (like “Providence, RI, USA”) or its GPS coordinate
    (like “41.8236 N, 71.4222 W”). There might even be multiple choices for how to
    represent that information. For instance, some systems might represent Providence’s
    GPS coordinates as we have shown above:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 信息是一个模糊的术语；计算机实际上消耗和产生的是我们称之为数据的东西。区别微妙但重要。“我们的位置”是一个模糊的概念，但一个天气网站实际消耗的是一个非常具体的表示，比如一个城市的名称（如“Providence,
    RI, USA”）或其 GPS 坐标（如“41.8236 N, 71.4222 W”）。甚至可能存在多种选择来表示该信息。例如，一些系统可能会将普罗维登斯的
    GPS 坐标表示为我们上面展示的方式：
- en: '| 41.8236 N, 71.4222 W |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 41.8236 N, 71.4222 W |'
- en: 'Others might choose to use positive and negative numbers to represent the hemisphere:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人可能选择使用正数和负数来表示半球：
- en: '| +41.8236, -71.4222 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| +41.8236, -71.4222 |'
- en: You could even imagine combining the two into a single number through some clever
    numeric trick [REF gödel encoding], and so on. Therefore, these are different
    kinds of data to represent the same information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以想象通过一些巧妙的数值技巧将两者合并成一个数字 [REF 哥德尔编码]，等等。因此，这些是表示相同信息的不同数据类型。
- en: Therefore, to write programs, we have to understand their data. We will begin
    by understand the most basic kinds of data, and writing some simple programs with
    them. As our programs get more sophisticated, we will need to represent more interesting
    kinds of information.Much of our presentation is directly derived from the book
    How to Design Programs, which you can find at [http://htdp.org/](http://htdp.org/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要编写程序，我们必须了解它们的数据。我们将从了解最基本的数据类型开始，并使用它们编写一些简单的程序。随着我们的程序变得更加复杂，我们将需要表示更多有趣的信息。我们的许多演示内容直接来自书籍《如何设计程序》，您可以在[http://htdp.org/](http://htdp.org/)找到。
- en: 2.1Numbers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 数字
- en: 'Some of the most common data in programs are numeric. They might represent
    a GPS coordinate as above, or a person’s age, or the size of a picture on a screen,
    or the number of results to a search query. Numbers are easy to represent in Pyret;
    for instance, here’s the year Brown University was founded:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中最常见的一些数据是数字。它们可以表示像上面那样的 GPS 坐标，或者一个人的年龄，或者屏幕上图片的尺寸，或者搜索查询结果的数量。在 Pyret 中，数字易于表示；例如，这是布朗大学成立的年份：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or a number that excites [number theory fans](https://en.wikipedia.org/wiki/1729_(number)):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一个让[数论爱好者](https://en.wikipedia.org/wiki/1729_(number))兴奋的数字：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Unsurprisingly, if you ask Pyret for their values, Pyret gives you back the
    same value you entered:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，如果您向 Pyret 请求它们的值，Pyret 会将相同的值返回给您：
- en: '| > 1764 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| > 1764 |'
- en: '| 1764 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 1764 |'
- en: '| > 1729 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| > 1729 |'
- en: '| 1729 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 1729 |'
- en: 'What use are programs whose values we already know? You’ll find out later:
    (part "values-for-tests").Of course, you can combine numbers in ways you will
    recognize; we call these expressions, just as in algebra:Yes, you must put spaces
    around operations like +.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 已知值的程序有什么用？稍后你会发现答案：（part "values-for-tests"）。当然，您可以按照您熟悉的方式组合数字；我们称这些表达式为表达式，就像在代数中一样：是的，你必须在
    + 等操作周围加上空格。
- en: '| > 1764 + 1729 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| > 1764 + 1729 |'
- en: '| 3493 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 3493 |'
- en: '| > 1764 - 1729 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| > 1764 - 1729 |'
- en: '| 35 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 35 |'
- en: '| > 1764 * 1729 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| > 1764 * 1729 |'
- en: '| 3049956 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 3049956 |'
- en: 'If you have prior programming experience, you may worry a little about multiplying
    big numbers. Don’t worry, go wild:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有先前的编程经验，您可能会担心大数相乘。别担心，尽情地：
- en: '| > 1764 * 1729 * 1764 * 1729 * 1764 * 1729 * 1764 * 1729 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| > 1764 * 1729 * 1764 * 1729 * 1764 * 1729 * 1764 * 1729 |'
- en: '| 86531512776056800758948096 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 86531512776056800758948096 |'
- en: Do Now!
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在做！
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The examples use only one operator per expression. What happens if we try to
    combine multiple different operators?
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 示例仅使用一个操作符。如果我们尝试组合多个不同的操作符会发生什么？
- en: 'In Pyret, if you combine operators, the language doesn’t want to guess what
    you might have meant (because it might guess wrong): if you write'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pyret 中，如果您组合运算符，语言不会猜测您可能的意思（因为它可能猜错）：如果您写
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'did you mean 3 - (2 + 1) or (3 + 1) - 2? Rather than guess, it asks that you
    write parentheses (as we just did) to make your intent clear.Of course, there
    are many operations we can perform on numbers, and we don’t have special symbols
    for all of them. You can use Pyret’s many more numeric operators using the syntax
    you recognize from math classes: the operator for numeric square root is called
    num-sqrt and you use it as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你是指 3 - (2 + 1) 还是 (3 + 1) - 2？与其猜测，它要求你写括号（就像我们刚才做的那样）以明确你的意图。当然，我们可以对数字执行许多操作，并且我们并没有为所有这些操作都有特殊的符号。您可以使用
    Pyret 的许多其他数字运算符，使用您从数学课程中熟悉的语法：数值平方根的运算符称为 num-sqrt，您可以按如下方式使用它：
- en: '| > num-sqrt(4) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| > num-sqrt(4) |'
- en: '| 2 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 2 |'
- en: 'If you have multiple parameters to the operator, separate them with commas:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对运算符有多个参数，请用逗号分隔它们：
- en: '| > num-expt(2, 4) |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| > num-expt(2, 4) |'
- en: '| 16 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 16 |'
- en: where num-expt computes the exponential.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，num-expt 计算指数。
- en: Exercise
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A natural question you might have is, “Do I need to put spaces after the commas
    between parameters?” Good question! Go ahead and check for yourself.
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会问的一个自然问题是，“我需要在参数之间的逗号后面加空格吗？”好问题！自己检查一下吧。
- en: If you have experience with other programming languages, you might now start
    to wonder about different kinds of numbers. For instance, in many languages, this
    expression
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有其他编程语言的经验，您现在可能会开始思考不同类型的数字。例如，在许多语言中，这个表达式
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'unfortunately results in zero.Don’t ask. Or, well, ask later. Fortunately,
    in Pyret this produces 1. That’s because Pyret represents the result of 1 / 3
    exactly as a ratio, just as you’d expect. In fact, Pyret tries to preserve ratios
    at all times: if you compute'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸地导致零。别问。或者，好吧，以后再问。幸运的是，在 Pyret 中，这会产生 1。这是因为 Pyret 精确地表示 1 / 3 的结果为比例，就像您期望的那样。事实上，Pyret
    会尽量保留比例：如果您计算
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pyret will produce an answer that is equivalent to 1/1729.In fact, if you click
    on the output produced by Pyret, you can switch between different ways of presenting
    the same datum, one of which is 1/1729.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret将产生一个等同于1/1729的答案。实际上，如果你点击Pyret产生的输出，你可以在不同的方式之间切换呈现相同的数据，其中之一就是1/1729。
- en: Exercise
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you try to divide by zero?
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你尝试除以零会发生什么？
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you expect?
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你期待什么？
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What does Pyret do?
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pyret会做什么？
- en: 2.2Expressions Versus Values
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2表达式与值
- en: 'Before we proceed, we have to introduce one piece of terminology. A value is
    the result of an expression: we are done computing with it and can’t do any more.
    Thus, 1764 * 1729 is not a value, because we can still perform the multiplication;
    but 3049956 is a value because it has no more operations waiting to be done.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们必须介绍一个术语。一个值是表达式的结果：我们已经计算完了它，不能再做任何操作。因此，1764 * 1729不是一个值，因为我们仍然可以执行乘法；但是3049956是一个值，因为它没有更多待处理的操作。
- en: Let’s look at another example of expressions. Consider a space traveler visiting
    the Moon. On the Moon, this astronaut weighs only one-sixth their weight on earth.
    Thus, if their Earth weight is 50kg, their Moon weight (in kilograms) is
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个表达式的例子。考虑一个访问月球的太空旅行者。在月球上，这位宇航员的重量只有地球上的六分之一。因此，如果他们的地球重量是50公斤，他们的月球重量（以公斤为单位）是
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If their Earth weight is 150lb, their Moon weight (in pounds) is
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们的地球重量是150磅，他们的月球重量（以磅为单位）是
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In general, given their Earth weight we can write an expression to calculate
    their Moon weight. We’ll return to this example soon [REF].Note that Pyret does
    not care whether 50 represents kilograms or pounds. These are units, and units
    are not part of the programming language. This makes it easy to create unit errors,
    which have an [infamous history](http://spacemath.gsfc.nasa.gov/weekly/6Page53.pdf).
    Later [REF] we will see how we can write some unit processing into our programs
    to reduce such errors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，鉴于它们的地球重量，我们可以写一个表达式来计算它们的月球重量。我们很快会回到这个例子[REF]。请注意，Pyret不关心50代表千克还是磅。这些是单位，单位不是编程语言的一部分。这使得创建单位错误变得容易，这在[臭名昭著的历史](http://spacemath.gsfc.nasa.gov/weekly/6Page53.pdf)中有所体现。稍后[REF]我们将看到如何在我们的程序中编写一些单位处理来减少这种错误。
- en: Do Now!
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see something curious in the fractions we’ve written in the previous
    section and this one?
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你在我们在上一节和这一节写的分数中看到了什么奇怪的地方吗？
- en: 'This is subtle, so don’t worry if you didn’t catch it: we wrote 1/1729 instead
    of 1 / 1729, and 1/6 instead of 1 / 6. Weren’t all arithmetic operations (like
    /) supposed to be surrounded by spaces?'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微妙的，如果你没有注意到，不要担心：我们写的是1/1729而不是1 / 1729，以及1/6而不是1 / 6。难道所有算术运算（如/）不应该被空格包围吗？
- en: 'That’s because 1/1729 is not an expression, it’s a value—<wbr>specifically,
    a number—<wbr>in itself. That is, 1 / 1729 is an expression; there is still work
    that needs to be done (the division) to obtain a value. In contrast, Pyret’s way
    of writing numbers has a special allowance for writing rational numbers directly:
    you can write 1/1729 just as well as you can write 1 and 1729, and it’s just as
    much of a value.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那是因为1/1729不是一个表达式，它是一个值—<wbr>具体来说，是一个数字—<wbr>本身。也就是说，1 / 1729是一个表达式；还有工作需要完成（除法）才能得到一个值。相比之下，Pyret写数字的方式允许直接写有理数：你可以写1/1729，就像你可以写1和1729一样，它同样是一个值。
- en: 2.3Variables to Name Values
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3用变量命名值
- en: 'It’s often more convenient to refer to the name of something than its value.
    For instance, six months from now if you saw 1764 in a program, you might have
    no recollection of what that means; but if you instead saw brown-founding you’d
    have a pretty good sense. Pyret lets us give names to values:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常更方便地引用某物的名称而不是其值。例如，六个月后，如果你在程序中看到1764，你可能不记得那意味着什么；但是如果你看到brown-founding，你可能有一个很好的概念。Pyret让我们给值取名字：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then use the names in expressions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在表达式中使用这些名称：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Indeed, we don’t have to name only values; we can even name expressions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们不仅可以给值取名字；我们甚至可以给表达式取名字：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We call these names variables, just as in algebra. We’ll use the word bound“Bound”
    here means in the sense of “tied down”, because the variable is now tied down
    to that value. to refer to the association of names with values: that is, brown-founding
    is bound to 1764.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这些名称为变量，就像代数中一样。我们将使用“绑定”这个词来指代名称与值的关联：也就是说，brown-founding绑定到1764。
- en: 2.4Strings
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4字符串
- en: 'Of course, computers process much more than just numbers. We might want to
    write down the name of a city, the name of a person, parts of a document, and
    so on. In Pyret, strings are used to represent such text:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，计算机处理的不仅仅是数字。我们可能想要记录城市的名称、人名、文档的部分等等。在 Pyret 中，字符串用于表示这样的文本：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Strings begin and end in double-quotes; note that you have to use the double-quotes
    on your keyboard ("), not opening- and closing-quotes (“ and ”) as generated by
    word processors. You can also use single-quotes ('') instead:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串以双引号开头和结尾；请注意，您必须使用键盘上的双引号（"），而不是文字处理器生成的开引号和闭引号（“和”）。您也可以使用单引号（'）代替：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Naturally, you might wonder how Pyret can tell where a string ends if the string
    itself contains a double-quote:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可能想知道 Pyret 如何知道字符串何时结束，如果字符串本身包含双引号：
- en: '| "The book was called "Structure and Interpretation"" |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| "这本书被称为“结构与解释”" |'
- en: Do Now!
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就试试吧！
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens when you enter this?
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你输入这个时会发生什么？
- en: 'Is that two strings ("The book was called " and "") with some variables (like
    Structure) and other stuff in-between? Needless to say, Pyret gets confused. So
    how do you enter this? There are two easy ways. First, we can use the other quotes
    to avoid confusion:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个字符串（“书名为”和“”）以及一些变量（如 Structure）和其他内容之间的内容吗？不用说，Pyret 感到困惑。那么你怎么输入呢？有两种简单的方法。首先，我们可以使用其他引号来避免混淆：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or (as you may have noticed when Pyret prints the above value), you can tell
    Pyret “this quote is part of the string, not the end of it”:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者（当你注意到 Pyret 打印上面的值时可能会注意到），你可以告诉 Pyret “这个引号是字符串的一部分，不是它的结尾”：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Either will work fine; pick whichever is more readable and less likely to cause
    confusion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都可以正常工作；选择哪一个更易读和不太容易引起混淆。
- en: 2.4.1Multi-Line Strings
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1多行字符串
- en: 'It’s sometimes convenient to have a string that spans multiple lines. Usually,
    strings that go beyond one line represent an error in the program (because the
    programmer forgot to close the string). Therefore, if you try to write a multi-line
    string in your program, Pyret will produce an error:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，拥有一个跨越多行的字符串是很方便的。通常，超过一行的字符串代表程序中的错误（因为程序员忘记关闭字符串）。因此，如果您尝试在程序中编写多行字符串，Pyret
    将产生错误：
- en: '| "Let us go then, you and I, |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| "让我们走吧，你和我， |'
- en: '| When the evening is spread out against the sky" |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 当夜晚铺展在天空之上时" |'
- en: Do Now!
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就试试吧！
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try this out and see the resulting error. Become familiar with it!
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试这个并查看生成的错误。熟悉它！
- en: 'Pyret instead uses a very different syntax for multi-line strings:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret 使用完全不同的语法来表示多行字符串：
- en: '[PRE14]Let us go then, you and I,'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]让我们走吧，你和我，'
- en: When the evening is spread out against the sky[PRE15]
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当夜晚铺展在天空之上时[PRE15]
- en: 'Using the triple-back-tick is your way of signaling to Pyret, “I really do
    want this to span multiple lines”. Notice that when Pyret prints this string,
    it replaces the newline with \n. Indeed, you could have written this multi-line
    string all on line line as:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个反引号是你向 Pyret 发出信号的方式，“我真的希望这个跨越多行”。请注意，当 Pyret 打印此字符串时，它会用 \n 替换换行符。实际上，您可以将此多行字符串全部写在一行上：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, the two are equivalent, and you can choose whichever is more convenient.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这两者是等价的，您可以选择更方便的那个。
- en: 2.4.2Operations on Strings
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2字符串操作
- en: 'Of course, we can not only create strings, we can also perform computations
    with them—<wbr>essentially, “arithmetic with strings”. For instance, we can concatenate
    them:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅可以创建字符串，还可以对它们执行计算 —— 实质上是对字符串进行“算术运算”。例如，我们可以将它们连接起来：
- en: '| > "will." + "i." + "am" |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| > "will." + "i." + "am" |'
- en: '| "will.i.am" |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| "will.i.am" |'
- en: '| > "The Lovesong " + "of J. Alfred Prufrock"Observe the space at the end of
    the first string. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| > "爱的歌曲 " + "of J. Alfred Prufrock"观察第一个字符串末尾的空格。 |'
- en: '| "The Lovesong of J. Alfred Prufrock" |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| "J·阿尔弗雷德·普鲁弗洛克的爱之歌" |'
- en: 'We can also measure the length of strings, or take them apart:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测量字符串的长度，或者拆解它们：
- en: '| > s = "The Lovesong" |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| > s = "爱的歌曲" |'
- en: '| > string-length(s) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| > string-length(s) |'
- en: '| 12 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 12 |'
- en: '| > string-substring(s, 0, 3) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| > string-substring(s, 0, 3) |'
- en: '| "The" |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| "The" |'
- en: 2.5Booleans
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5布尔值
- en: 'We have now multiple times talked about two values being equivalent. Right
    now we’re trusting our eyes to tell that they’re equal, but we can do better:
    we can ask Pyret to check for us.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次谈论了两个值的等价性。现在我们相信我们的眼睛告诉我们它们是相等的，但我们可以做得更好：我们可以要求 Pyret 为我们检查。
- en: Before we do so, we should ask ourselves how Pyret can report back what it finds.
    For instance, if we ask whether two strings are equal, the answer might be yes
    and it might be no. What data should Pyret use to indicate the answer?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，我们应该问自己 Pyret 如何能够报告它发现了什么。例如，如果我们询问两个字符串是否相等，答案可能是是也可能是否。Pyret 应该使用什么数据来指示答案？
- en: Exercise
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain why numbers and strings are not good ways to express the answer.
  id: totrans-135
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释为什么数字和字符串不是表达答案的好方法。
- en: Pyret offers two values, true and false, to represent such answers. For historical
    reasons, these are called Boolean values.Named for [George Boole](https://en.wikipedia.org/wiki/George_Boole).
    We can compare two values for equality with ==:There is much more we can and should
    say about equality, which we will do later [REF equality].
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret 提供了两个值，true 和 false，来表示这样的答案。出于历史原因，这些被称为布尔值。以 [George Boole](https://en.wikipedia.org/wiki/George_Boole)
    命名。我们可以用 == 比较两个值是否相等：关于等式，我们可以说的还有很多，我们以后会详细说明 [REF equality]。
- en: '| > 1 == 1 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| > 1 == 1 |'
- en: '| true |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: '| > 1 == 2 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| > 1 == 2 |'
- en: '| false |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| false |'
- en: Thus, returning to our two earlier examples:Note that we don’t need to create
    variables to perform a comparison, just as we didn’t above. The variables are
    only to make the examples easier to read.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到我们之前的两个例子：请注意，我们不需要创建变量来执行比较，就像我们上面没有做的那样。变量只是为了让示例更容易阅读。
- en: '[PRE17]'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]Let us go then, you and I,'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PRE18]让我们一起去吧，你和我，'
- en: When the evening is spread out against the sky[PRE19]
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当晚霞铺展在天空之上时[PRE19]
- en: 'We expect both to result in true, whereas this does not:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望这两者都会产生 true 结果，但实际上并非如此：
- en: '[PRE20]Let us go then, you and I,'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]让我们一起去吧，你和我，'
- en: When the evening is spread out against the sky[PRE21]
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当晚霞铺展在天空之上时[PRE21]
- en: (because we replaced the \n with a space).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: （因为我们用空格替换了 \n）。
- en: In particular, we are using the language to determine when things are equal,
    rather than using our (perhaps wobbly) eyesight. This is a really important idea,
    which we will return to in much more detail later [REF testing].
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们正在使用语言来确定何时相等，而不是使用我们（可能不太可靠的）视力。这是一个非常重要的观念，我们以后会更详细地讨论 [REF testing]。
- en: 2.5.1Other Comparisons
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1其他比较
- en: Of course, we can do many more kinds of comparisons. For instance,
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以做更多种类的比较。例如，
- en: '| > 1 <= 2 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| > 1 <= 2 |'
- en: '| true |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: '| > 1 > 3 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| > 1 > 3 |'
- en: '| false |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| false |'
- en: 'However, it may not be obvious how to compare strings. Some comparisons are
    unsurprising:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如何比较字符串可能并不明显。有些比较是不足为奇的：
- en: '| > "a" < "b" |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| > "a" < "b" |'
- en: '| true |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: '| > "a" >= "c" |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| > "a" >= "c" |'
- en: '| false |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| false |'
- en: '| > "that" < "this" |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| > "that" < "this" |'
- en: '| true |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: '| > "alpha" < "beta" |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| > "alpha" < "beta" |'
- en: '| true |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: 'which is the alphabetical order we’re used to; but others need some explanining:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们习惯的字母顺序；但其他需要一些解释：
- en: '| > "a" >= "C" |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| > "a" >= "C" |'
- en: '| true |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: '| > "a" >= "A" |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| > "a" >= "A" |'
- en: '| true |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: This is because Pyret strings are compared using an ordering called the [ASCII](https://en.wikipedia.org/wiki/ASCII)
    order.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Pyret 字符串是使用称为 [ASCII](https://en.wikipedia.org/wiki/ASCII) 顺序进行比较的。
- en: Exercise
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you compare true and false? Try comparing them for equality, then for inequality
    (such as <).
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你能比较真和假吗？试着将它们进行相等比较，然后进行不等比较（如<）。
- en: 'In general, you can compare any two values for equality (but read more at [REF
    equality]); for instance:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您可以比较任意两个值是否相等（但请在 [REF equality] 中阅读更多）；例如：
- en: '| > "a" == 1 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| > "a" == 1 |'
- en: '| false |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| false |'
- en: 'If you want to compare values of a specific kind, you can use more specific
    operators:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想比较特定类型的值，可以使用更具体的运算符：
- en: '| > num-equal(1, 1) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| > num-equal(1, 1) |'
- en: '| true |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: '| > num-equal(1, 2) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| > num-equal(1, 2) |'
- en: '| false |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| false |'
- en: '| > string-equal("a", "a") |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| > string-equal("a", "a") |'
- en: '| true |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| true |'
- en: '| > string-equal("a", "b") |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| > string-equal("a", "b") |'
- en: '| false |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| false |'
- en: However, these operators will not let you mix two different kinds of values.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些运算符不会让你混合两种不同类型的值。
- en: Exercise
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try
  id: totrans-189
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 试试看
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| num-equal("a", 1) |'
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '| num-equal("a", 1) |'
- en: '| string-equal("a", 1) |'
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
  zh: '| string-equal("a", 1) |'
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: and understand how these operators relate to ==.
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 并理解这些运算符与 == 的关系。
- en: 2.5.2Other Boolean-Producing Operations
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2其他产生布尔值的操作
- en: 'There are even more Boolean-producing operators, such as:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多产生布尔值的运算符，比如：
- en: '| > wm = "will.i.am" |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| > wm = "will.i.am" |'
- en: '| > string-contains(wm, "will") |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| > string-contains(wm, "will") |'
- en: '| true |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '-   | true |'
- en: '| > string-contains(wm, "Will")Note the capital W. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| > string-contains(wm, "Will")注意大写的 W。 |'
- en: '| false |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| false |'
- en: In fact, just about every kind of data will have some Boolean-valued operators
    to enable comparisons.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，几乎每一种数据都有一些布尔值运算符来进行比较。
- en: 2.5.3Combining Booleans
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3组合布尔值
- en: 'Often, we want to base decisions on more than one Boolean value. For instance,
    you are allowed to vote if you’re a citizen of a country and you are above a certain
    age. You’re allowed to board a bus if you have a ticket or the bus is having a
    free-ride day. We can even combine conditions: you’re allowed to drive if you
    are above a certain age and have good eyesight and—<wbr>either pass a test or
    have a temporary license. Also, you’re allowed to drive if you are not inebriated.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望根据不止一个布尔值做出决定。例如，如果你是某个国家的公民并且年龄超过一定年龄，你就可以投票。如果你有车票或者公交车是免费乘车日，你就可以搭乘公交车。我们甚至可以组合条件：如果你年龄超过一定年龄并且视力良好，且—<wbr>要么通过测试要么有临时许可证，你就可以驾驶。此外，如果你没有醉酒，你也可以驾驶。
- en: 'Corresponding to these forms of combinations, Pyret offers three main operations:
    and, or, and not. Here are some examples of their use:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些组合形式对应，Pyret 提供了三种主要操作：and、or 和 not。以下是它们的一些使用示例：
- en: '| > (1 < 2) and (2 < 3) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| > (1 < 2) and (2 < 3) |'
- en: '| true |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 真 |'
- en: '| > (1 < 2) and (3 < 2) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| > (1 < 2) and (3 < 2) |'
- en: '| false |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 假 |'
- en: '| > (1 < 2) or (2 < 3) |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| > (1 < 2) or (2 < 3) |'
- en: '| true |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 真 |'
- en: '| > (3 < 2) or (1 < 2) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| > (3 < 2) or (1 < 2) |'
- en: '| true |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 真 |'
- en: '| > not(1 < 2) |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| > not(1 < 2) |'
- en: '| false |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 假 |'
- en: 2.5.4Using Booleans
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 使用布尔值
- en: 'One way to use Boolean values is to combine them to produce other Boolean values.
    Ultimately, however, we’d like to produce other kinds of data as well depending
    on a Boolean. There are several ways to do this in Pyret, but for now we’ll focus
    on just one: the conditional expression (because what value it produces is a “condition”
    of other values).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔值的一种方式是将它们组合以产生其他布尔值。然而，最终，我们希望根据布尔值产生其他类型的数据。在 Pyret 中有几种方法可以实现这一点，但现在我们只关注其中一种：条件表达式（因为它产生的值是其他值的“条件”）。
- en: 'The structure of a conditional in Pyret is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret 中条件的结构如下：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For instance,
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Actually, this program contains a small logical error. Suppose Brown and Rice
    were founded in the same year; then, because brown-founding > rice-founding would
    be false, it would declare Rice older despite them being the same age. So a more
    accurate program would check whether they’re equal, and only report one as older
    if it really is. We can do this with an expanded version of the conditional, whose
    syntax is:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个程序包含一个小的逻辑错误。假设布朗大学和莱斯大学是同一年成立的；那么，因为 brown-founding > rice-founding 会是假，它会宣布莱斯大学更老，尽管它们同龄。所以一个更准确的程序会检查它们是否相等，只有在真的更老的情况下才报告一个。我们可以使用条件的扩展版本来实现这一点，其语法是：
- en: '[PRE24]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For instance:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE25]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 2.6Evaluating by Reducing Expressions
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 通过简化表达式进行评估
- en: 'Finally, let us briefly talk about how Pyret produces values, i.e., the process
    of evaluation (reducing to values). Suppose we want to compute the wages of a
    worker. The worker is paid $10 for every hour up to the first 40 hours, and is
    paid $15 for every extra hour. Let’s say hours contains the number of hours they
    work, and suppose it’s 45:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要讨论 Pyret 如何生成值，即评估的过程（简化为值）。假设我们想要计算工人的工资。工人每小时工作 40 小时以内支付 $10，每额外工作一小时支付
    $15。假设 hours 包含他们工作的小时数，假设为 45：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Suppose the formula for computing the wage is
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 假设计算工资的公式为
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s now see how this results in an answer, using a step-by-step process that
    should match what you’ve seen in algebra classes:The first step is to substitute
    the hours with 45.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这是如何产生答案的，使用一个逐步过程，这个过程应该与你在代数课上看到的相匹配：第一步是用 45 替换 hours。
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, the conditional part of the if expression is evaluated, which in this
    case is false.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，评估 if 表达式的条件部分，这种情况下是假。
- en: '[PRE29]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since the condition is false, the next branch is tried.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于条件为假，下一个分支被尝试。
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since the condition is true, the expression reduces to the body of that branch.
    After that, it’s just arithmetic.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于条件为真，表达式简化为该分支的主体。之后，这只是算术。
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This style of reduction is the best way to think about the evaluation of Pyret
    expressions (and later, functions). The whole expression takes steps that simplify
    it, proceeding by simple rules. You can use this style yourself if you want to
    try and work through the evaluation of a Pyret program by hand (or in your head).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化风格是思考评估 Pyret 表达式（以及后来的函数）的最佳方式。整个表达式采取简化步骤，按照简单的规则进行。如果你想尝试手动（或心算）通过 Pyret
    程序的评估，你可以自己使用这种风格。
- en: 2.7Images
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 图像
- en: 'Pyret doesn’t limit you to numbers and strings; you can also treat images as
    data. To use images, we should ask Pyret for the image operations:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret 不限制你只能使用数字和字符串；你还可以将图像视为数据。要使用图像，我们应该向 Pyret 请求图像操作：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can draw a red circle:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以画一个红色的圆：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can also draw a white rectangle:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以画一个白色的矩形：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Just as we can combine numbers, strings, and Booleans, we can also combine
    images (i.e., perform “arithmetic on images”). For instance, overlay will lay
    one image (the first one) atop the second:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以组合数字、字符串和布尔值一样，我们也可以组合图像（即对图像进行“算术运算”）。例如，overlay 会将一个图像（第一个图像）覆盖在第二个图像上：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: to obtain the [Japanese flag](https://en.wikipedia.org/wiki/Flag_of_Japan).
    Similarly, we can place three circles one above the other—<wbr>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得[日本国旗](https://en.wikipedia.org/wiki/Flag_of_Japan)。类似地，我们可以将三个圆放在彼此上方—<wbr>
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '—<wbr>to get the first stage of a snowperson (have fun drawing in the rest!).Revisiting
    the Japanese flag for a moment, there are actually rules about the ratio of the
    different dimensions of the flag: the numbers above were not chosen mindlessly.
    For instance, the width and height must be in a 3:2 ratio (hence 300 and 200),
    and the red circle must have a diameter 3/5 of the overall height. If we now want
    to draw a bigger flag, we would have to carefully change many things to preserve
    these rules! Alternatively, we could use a variable to represent, say, one “unit”
    of size, and calculate everything else from there:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: —<wbr>以获得雪人的第一阶段（享受画剩下部分的乐趣！）。稍后回顾日本国旗，实际上有关于国旗不同尺寸之间比例的规定：上面的数字并不是随意选择的。例如，宽度和高度必须是
    3:2 的比例（因此为 300 和 200），红色圆必须有整体高度的 3/5 的直径。如果我们现在想要绘制一个更大的国旗，我们将不得不小心地改变许多东西以保持这些规则！或者，我们可以使用一个变量来代表，比如说，一个“单位”大小，并从那里计算出其他所有内容：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This now makes it easy to change just one thing and have everything else automatically
    change: each time we run the program the size of the flag depends on the value
    of unit. If we make 200, we obtain a flag twice as large; if we make it 50, we
    obtain one half as big.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这样现在很容易只改变一件事并自动更改其他所有内容：每次运行程序，旗帜的大小取决于 unit 的值。如果我们设为 200，我们得到一个两倍大的旗帜；如果我们设为
    50，我们得到一半大小的旗帜。
- en: Of course, each time we have to keep running the program to compute these values
    afresh, a problem we’d like to avoid; we’ll return to this later [FILL]. Later
    we will also see how we can combine images with other computation to make movies,
    animations, and videogames [REF world].
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每次我们都必须运行程序以重新计算这些值，这是我们想要避免的问题；我们稍后会回到这一点[FILL]。稍后我们还会看到如何将图像与其他计算组合起来制作电影、动画和视频游戏[REF
    world]。
- en: 2.8Roughnums
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8Roughnums
- en: Before we conclude looking at basic data, we have to say a little more about
    numbers. The numeric examples we’ve picked above have been chosen conveniently
    to not reveal a certain ugliness about how computers treat numbers. Though Pyret
    masks this ugliness for the most part, for various reasons (mainly having to do
    with efficiency), it does not mask them entirely.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束基本数据的讨论之前，我们必须再多说一些关于数字的事情。我们上面选择的数字示例之所以方便选择，是为了不暴露计算机对数字处理的某种丑陋性。尽管 Pyret
    大部分时间都掩盖了这种丑陋，但出于各种原因（主要是与效率有关），它并没有完全掩盖它们。
- en: 'The best way to see this problem is to ask for the square root of 2: num-sqrt(2).
    This number does not have a precise rational representation. Pyret still computes
    an answer, but prints it in a curious way:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是寻找这个问题的平方根：num-sqrt(2)。这个数没有精确的有理表示。Pyret 仍然会计算一个答案，但是以一种奇怪的方式打印出来：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What is going on here? Pyret wants to make sure you understand that what it
    has printed—<wbr>1.4142135623730951—<wbr>cannot possibly be the exact answer (because
    \(\sqrt{2}\) has no rational representation). The prefix of ~ means this is a
    roughnum: an approximate answer that you should treat with caution.In practice,
    roughnums are represented using [floating points](https://en.wikipedia.org/wiki/Floating_point),
    which are approximate but implemented efficiently in modern computers. Roughnums
    have a pervasive property: once a computation involves a roughnum, its answer
    will also be a roughnum:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？Pyret 想要确保你明白它所打印的—<wbr>1.4142135623730951—<wbr>绝对不可能是精确的答案（因为 \(\sqrt{2}\)
    没有有理表示）。前缀~表示这是一个 roughnum：一个你应该谨慎对待的近似答案。在实践中，roughnums 使用 [浮点数](https://en.wikipedia.org/wiki/Floating_point)
    来表示，这些数值是近似的但在现代计算机中实现得非常高效。Roughnums 具有普遍的特性：一旦一个计算涉及到 roughnum，其答案也将是 roughnum：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Sometimes, this might be surprising:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这可能会让人感到惊讶：
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You might think “Any number minus itself must be exactly zero”, but Pyret doesn’t
    “know” as much as you do, and hedges its bets.This turns out to be rather wise.
    For instance, consider this calculation:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为“任何数减去自身必须精确地等于零”，但是 Pyret 并不“知道”你所知道的那么多，并且对结果保持谨慎。这事实证明是相当明智的。例如，考虑下面的计算：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Look more closely at the digits after the decimal. You would expect them to
    be exactly the same as those for num-sqrt(2), but the first one seems to have
    an extra digit:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 更仔细地查看小数点后的数字。你预计它们会与num-sqrt(2)完全相同，但第一个似乎多了一个数字：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In fact, subtracting 1 from the second number produces something slightly different
    from the first number:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从第二个数字减去1会产生与第一个数字略有不同的结果：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So is this or isn’t this exactly the same as num-sqrt(2)? Let’s ask Pyret:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这个是或不是确切与num-sqrt(2)相同？让我们问问Pyret：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The notation e means an exponential representation, so this is the same as roughly
    \(2.2 \times 10^{-16}\)—<wbr>i.e., a very small number, but not exactly zero!
    Thus, starting with \(\sqrt{2}\), adding one, subtracting one, and then subtracting
    \(\sqrt{2}\) produces an answer that is not precisely zero.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 符号e表示指数表示法，因此这与大约\(2.2 \times 10^{-16}\)是相同的——<wbr>即，一个非常小的数字，但不是零！因此，从\(\sqrt{2}\)开始，加上一，减去一，然后减去\(\sqrt{2}\)会产生一个不完全是零的答案。
- en: Exercise
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do roughnums obey the axioms of arithmetic operators like (where appropriate)
    distributivity, associativity, and commutativity?
  id: totrans-275
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 粗糙数是否遵循算术运算符的公理，例如（在适当的情况下）分配性、结合性和交换性？
- en: Because roughnums are so brittle, Pyret doesn’t let you get misled by equality
    operations. If you ask
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于粗糙数（roughnums）非常脆弱，Pyret不会让你被相等操作误导。
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Pyret is not sure: the ~1 represents some value that is approximately 1, but
    it could be exactly that or something close to but not exactly it (just like we
    saw a value that was close to but not exactly zero even though in reality we knew
    it was zero). Therefore, Pyret regards this as neither true nor false but rather
    as an error. Later [REF] we will see how to compare roughnums.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Pyret不确定：~1表示大约是1的某个值，但它可能确切是那个值，也可能接近但不完全是它（就像我们看到的一个值接近但不完全是零，尽管在现实中我们知道它是零）。因此，Pyret将其视为既不是真也不是假，而是一个错误。稍后[参考]我们将看到如何比较粗糙数。
- en: A full explanation of floating points is well beyond the scope of this document;
    this section just warns you of what you must beware.The interested reader should
    find a copy of “What Every Computer Scientist Should Know About Floating-Point
    Arithmetic” by David Goldberg, e.g., [see here](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数的完整解释远远超出了本文档的范围；本节只是警告您必须注意的内容。感兴趣的读者应该找到David Goldberg的“每个计算机科学家都应该了解的浮点运算知识”一书的副本，例如，[见此处](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)。
