- en: 2Basic Data and Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [2.1 Numbers](#%28part._.Numbers%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [2.2 Expressions Versus Values](#%28part._.Expressions_.Versus_.Values%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [2.3 Variables to Name Values](#%28part._.Variables_to_.Name_.Values%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [2.4 Strings](#%28part._.Strings%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [2.4.1 Multi-Line Strings](#%28part._.Multi-.Line_.Strings%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [2.4.2 Operations on Strings](#%28part._.Operations_on_.Strings%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [2.5 Booleans](#%28part._booleans%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [2.5.1 Other Comparisons](#%28part._.Other_.Comparisons%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [2.5.2 Other Boolean-Producing Operations](#%28part._.Other_.Boolean-.Producing_.Operations%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [2.5.3 Combining Booleans](#%28part._.Combining_.Booleans%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [2.5.4 Using Booleans](#%28part._.Using_.Booleans%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [2.6 Evaluating by Reducing Expressions](#%28part._.Evaluating_by_.Reducing_.Expressions%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [2.7 Images](#%28part._.Images%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [2.8 Roughnums](#%28part._.Roughnums%29) |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s think about some of the programs we use. We might use Google, a search
    engine: it consumes a search query and produces a search results. We may use Facebook,
    a social network: it consumes information about our friendships and produces updates
    from our friends. We could use Amazon, a store: it consumes descriptions of things
    we’re interested in and produces lists of products that match our descriptions.
    We sometimes use Weather.com, a weather site: it consumes our location and produces
    a weather forecast for that location. In fact these systems consume and produce
    even more: they consume our history of past preferences, and produce ads, recommendations
    for related products [REF collaborative filtering], and so on. In short, programs
    consume and produce information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Information is a fuzzy term; what computers actually consume and produce are
    what we call data. The difference is subtle but important. “Our location” is a
    vague concept, but what a weather site actually consumes is a very concrete representation
    of it, such as the name of a city (like “Providence, RI, USA”) or its GPS coordinate
    (like “41.8236 N, 71.4222 W”). There might even be multiple choices for how to
    represent that information. For instance, some systems might represent Providence’s
    GPS coordinates as we have shown above:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 41.8236 N, 71.4222 W |'
  prefs: []
  type: TYPE_TB
- en: 'Others might choose to use positive and negative numbers to represent the hemisphere:'
  prefs: []
  type: TYPE_NORMAL
- en: '| +41.8236, -71.4222 |'
  prefs: []
  type: TYPE_TB
- en: You could even imagine combining the two into a single number through some clever
    numeric trick [REF gödel encoding], and so on. Therefore, these are different
    kinds of data to represent the same information.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to write programs, we have to understand their data. We will begin
    by understand the most basic kinds of data, and writing some simple programs with
    them. As our programs get more sophisticated, we will need to represent more interesting
    kinds of information.Much of our presentation is directly derived from the book
    How to Design Programs, which you can find at [http://htdp.org/](http://htdp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 2.1Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the most common data in programs are numeric. They might represent
    a GPS coordinate as above, or a person’s age, or the size of a picture on a screen,
    or the number of results to a search query. Numbers are easy to represent in Pyret;
    for instance, here’s the year Brown University was founded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a number that excites [number theory fans](https://en.wikipedia.org/wiki/1729_(number)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Unsurprisingly, if you ask Pyret for their values, Pyret gives you back the
    same value you entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > 1764 |'
  prefs: []
  type: TYPE_TB
- en: '| 1764 |'
  prefs: []
  type: TYPE_TB
- en: '| > 1729 |'
  prefs: []
  type: TYPE_TB
- en: '| 1729 |'
  prefs: []
  type: TYPE_TB
- en: 'What use are programs whose values we already know? You’ll find out later:
    (part "values-for-tests").Of course, you can combine numbers in ways you will
    recognize; we call these expressions, just as in algebra:Yes, you must put spaces
    around operations like +.'
  prefs: []
  type: TYPE_NORMAL
- en: '| > 1764 + 1729 |'
  prefs: []
  type: TYPE_TB
- en: '| 3493 |'
  prefs: []
  type: TYPE_TB
- en: '| > 1764 - 1729 |'
  prefs: []
  type: TYPE_TB
- en: '| 35 |'
  prefs: []
  type: TYPE_TB
- en: '| > 1764 * 1729 |'
  prefs: []
  type: TYPE_TB
- en: '| 3049956 |'
  prefs: []
  type: TYPE_TB
- en: 'If you have prior programming experience, you may worry a little about multiplying
    big numbers. Don’t worry, go wild:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > 1764 * 1729 * 1764 * 1729 * 1764 * 1729 * 1764 * 1729 |'
  prefs: []
  type: TYPE_TB
- en: '| 86531512776056800758948096 |'
  prefs: []
  type: TYPE_TB
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The examples use only one operator per expression. What happens if we try to
    combine multiple different operators?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In Pyret, if you combine operators, the language doesn’t want to guess what
    you might have meant (because it might guess wrong): if you write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'did you mean 3 - (2 + 1) or (3 + 1) - 2? Rather than guess, it asks that you
    write parentheses (as we just did) to make your intent clear.Of course, there
    are many operations we can perform on numbers, and we don’t have special symbols
    for all of them. You can use Pyret’s many more numeric operators using the syntax
    you recognize from math classes: the operator for numeric square root is called
    num-sqrt and you use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > num-sqrt(4) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 |'
  prefs: []
  type: TYPE_TB
- en: 'If you have multiple parameters to the operator, separate them with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > num-expt(2, 4) |'
  prefs: []
  type: TYPE_TB
- en: '| 16 |'
  prefs: []
  type: TYPE_TB
- en: where num-expt computes the exponential.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A natural question you might have is, “Do I need to put spaces after the commas
    between parameters?” Good question! Go ahead and check for yourself.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you have experience with other programming languages, you might now start
    to wonder about different kinds of numbers. For instance, in many languages, this
    expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'unfortunately results in zero.Don’t ask. Or, well, ask later. Fortunately,
    in Pyret this produces 1. That’s because Pyret represents the result of 1 / 3
    exactly as a ratio, just as you’d expect. In fact, Pyret tries to preserve ratios
    at all times: if you compute'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Pyret will produce an answer that is equivalent to 1/1729.In fact, if you click
    on the output produced by Pyret, you can switch between different ways of presenting
    the same datum, one of which is 1/1729.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens if you try to divide by zero?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: What do you expect?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: What does Pyret do?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 2.2Expressions Versus Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we proceed, we have to introduce one piece of terminology. A value is
    the result of an expression: we are done computing with it and can’t do any more.
    Thus, 1764 * 1729 is not a value, because we can still perform the multiplication;
    but 3049956 is a value because it has no more operations waiting to be done.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another example of expressions. Consider a space traveler visiting
    the Moon. On the Moon, this astronaut weighs only one-sixth their weight on earth.
    Thus, if their Earth weight is 50kg, their Moon weight (in kilograms) is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If their Earth weight is 150lb, their Moon weight (in pounds) is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In general, given their Earth weight we can write an expression to calculate
    their Moon weight. We’ll return to this example soon [REF].Note that Pyret does
    not care whether 50 represents kilograms or pounds. These are units, and units
    are not part of the programming language. This makes it easy to create unit errors,
    which have an [infamous history](http://spacemath.gsfc.nasa.gov/weekly/6Page53.pdf).
    Later [REF] we will see how we can write some unit processing into our programs
    to reduce such errors.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see something curious in the fractions we’ve written in the previous
    section and this one?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This is subtle, so don’t worry if you didn’t catch it: we wrote 1/1729 instead
    of 1 / 1729, and 1/6 instead of 1 / 6. Weren’t all arithmetic operations (like
    /) supposed to be surrounded by spaces?'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s because 1/1729 is not an expression, it’s a value—<wbr>specifically,
    a number—<wbr>in itself. That is, 1 / 1729 is an expression; there is still work
    that needs to be done (the division) to obtain a value. In contrast, Pyret’s way
    of writing numbers has a special allowance for writing rational numbers directly:
    you can write 1/1729 just as well as you can write 1 and 1729, and it’s just as
    much of a value.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.3Variables to Name Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s often more convenient to refer to the name of something than its value.
    For instance, six months from now if you saw 1764 in a program, you might have
    no recollection of what that means; but if you instead saw brown-founding you’d
    have a pretty good sense. Pyret lets us give names to values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the names in expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, we don’t have to name only values; we can even name expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We call these names variables, just as in algebra. We’ll use the word bound“Bound”
    here means in the sense of “tied down”, because the variable is now tied down
    to that value. to refer to the association of names with values: that is, brown-founding
    is bound to 1764.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.4Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, computers process much more than just numbers. We might want to
    write down the name of a city, the name of a person, parts of a document, and
    so on. In Pyret, strings are used to represent such text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings begin and end in double-quotes; note that you have to use the double-quotes
    on your keyboard ("), not opening- and closing-quotes (“ and ”) as generated by
    word processors. You can also use single-quotes ('') instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, you might wonder how Pyret can tell where a string ends if the string
    itself contains a double-quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '| "The book was called "Structure and Interpretation"" |'
  prefs: []
  type: TYPE_TB
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens when you enter this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Is that two strings ("The book was called " and "") with some variables (like
    Structure) and other stuff in-between? Needless to say, Pyret gets confused. So
    how do you enter this? There are two easy ways. First, we can use the other quotes
    to avoid confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or (as you may have noticed when Pyret prints the above value), you can tell
    Pyret “this quote is part of the string, not the end of it”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Either will work fine; pick whichever is more readable and less likely to cause
    confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.1Multi-Line Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s sometimes convenient to have a string that spans multiple lines. Usually,
    strings that go beyond one line represent an error in the program (because the
    programmer forgot to close the string). Therefore, if you try to write a multi-line
    string in your program, Pyret will produce an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '| "Let us go then, you and I, |'
  prefs: []
  type: TYPE_TB
- en: '| When the evening is spread out against the sky" |'
  prefs: []
  type: TYPE_TB
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try this out and see the resulting error. Become familiar with it!
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pyret instead uses a very different syntax for multi-line strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]Let us go then, you and I,'
  prefs: []
  type: TYPE_NORMAL
- en: When the evening is spread out against the sky[PRE15]
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the triple-back-tick is your way of signaling to Pyret, “I really do
    want this to span multiple lines”. Notice that when Pyret prints this string,
    it replaces the newline with \n. Indeed, you could have written this multi-line
    string all on line line as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Again, the two are equivalent, and you can choose whichever is more convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2Operations on Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, we can not only create strings, we can also perform computations
    with them—<wbr>essentially, “arithmetic with strings”. For instance, we can concatenate
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > "will." + "i." + "am" |'
  prefs: []
  type: TYPE_TB
- en: '| "will.i.am" |'
  prefs: []
  type: TYPE_TB
- en: '| > "The Lovesong " + "of J. Alfred Prufrock"Observe the space at the end of
    the first string. |'
  prefs: []
  type: TYPE_TB
- en: '| "The Lovesong of J. Alfred Prufrock" |'
  prefs: []
  type: TYPE_TB
- en: 'We can also measure the length of strings, or take them apart:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > s = "The Lovesong" |'
  prefs: []
  type: TYPE_TB
- en: '| > string-length(s) |'
  prefs: []
  type: TYPE_TB
- en: '| 12 |'
  prefs: []
  type: TYPE_TB
- en: '| > string-substring(s, 0, 3) |'
  prefs: []
  type: TYPE_TB
- en: '| "The" |'
  prefs: []
  type: TYPE_TB
- en: 2.5Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have now multiple times talked about two values being equivalent. Right
    now we’re trusting our eyes to tell that they’re equal, but we can do better:
    we can ask Pyret to check for us.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we do so, we should ask ourselves how Pyret can report back what it finds.
    For instance, if we ask whether two strings are equal, the answer might be yes
    and it might be no. What data should Pyret use to indicate the answer?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain why numbers and strings are not good ways to express the answer.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pyret offers two values, true and false, to represent such answers. For historical
    reasons, these are called Boolean values.Named for [George Boole](https://en.wikipedia.org/wiki/George_Boole).
    We can compare two values for equality with ==:There is much more we can and should
    say about equality, which we will do later [REF equality].
  prefs: []
  type: TYPE_NORMAL
- en: '| > 1 == 1 |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > 1 == 2 |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: Thus, returning to our two earlier examples:Note that we don’t need to create
    variables to perform a comparison, just as we didn’t above. The variables are
    only to make the examples easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_UL
  type: TYPE_PRE
- en: '[PRE18]Let us go then, you and I,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the evening is spread out against the sky[PRE19]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We expect both to result in true, whereas this does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]Let us go then, you and I,'
  prefs: []
  type: TYPE_NORMAL
- en: When the evening is spread out against the sky[PRE21]
  prefs: []
  type: TYPE_NORMAL
- en: (because we replaced the \n with a space).
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we are using the language to determine when things are equal,
    rather than using our (perhaps wobbly) eyesight. This is a really important idea,
    which we will return to in much more detail later [REF testing].
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.1Other Comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, we can do many more kinds of comparisons. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '| > 1 <= 2 |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > 1 > 3 |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: 'However, it may not be obvious how to compare strings. Some comparisons are
    unsurprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > "a" < "b" |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > "a" >= "c" |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: '| > "that" < "this" |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > "alpha" < "beta" |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: 'which is the alphabetical order we’re used to; but others need some explanining:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > "a" >= "C" |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > "a" >= "A" |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: This is because Pyret strings are compared using an ordering called the [ASCII](https://en.wikipedia.org/wiki/ASCII)
    order.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can you compare true and false? Try comparing them for equality, then for inequality
    (such as <).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In general, you can compare any two values for equality (but read more at [REF
    equality]); for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > "a" == 1 |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: 'If you want to compare values of a specific kind, you can use more specific
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > num-equal(1, 1) |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > num-equal(1, 2) |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: '| > string-equal("a", "a") |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > string-equal("a", "b") |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: However, these operators will not let you mix two different kinds of values.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| num-equal("a", 1) |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: '| string-equal("a", 1) |'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_TB
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: and understand how these operators relate to ==.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 2.5.2Other Boolean-Producing Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are even more Boolean-producing operators, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > wm = "will.i.am" |'
  prefs: []
  type: TYPE_TB
- en: '| > string-contains(wm, "will") |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > string-contains(wm, "Will")Note the capital W. |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: In fact, just about every kind of data will have some Boolean-valued operators
    to enable comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 2.5.3Combining Booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, we want to base decisions on more than one Boolean value. For instance,
    you are allowed to vote if you’re a citizen of a country and you are above a certain
    age. You’re allowed to board a bus if you have a ticket or the bus is having a
    free-ride day. We can even combine conditions: you’re allowed to drive if you
    are above a certain age and have good eyesight and—<wbr>either pass a test or
    have a temporary license. Also, you’re allowed to drive if you are not inebriated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Corresponding to these forms of combinations, Pyret offers three main operations:
    and, or, and not. Here are some examples of their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| > (1 < 2) and (2 < 3) |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > (1 < 2) and (3 < 2) |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: '| > (1 < 2) or (2 < 3) |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > (3 < 2) or (1 < 2) |'
  prefs: []
  type: TYPE_TB
- en: '| true |'
  prefs: []
  type: TYPE_TB
- en: '| > not(1 < 2) |'
  prefs: []
  type: TYPE_TB
- en: '| false |'
  prefs: []
  type: TYPE_TB
- en: 2.5.4Using Booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One way to use Boolean values is to combine them to produce other Boolean values.
    Ultimately, however, we’d like to produce other kinds of data as well depending
    on a Boolean. There are several ways to do this in Pyret, but for now we’ll focus
    on just one: the conditional expression (because what value it produces is a “condition”
    of other values).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of a conditional in Pyret is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, this program contains a small logical error. Suppose Brown and Rice
    were founded in the same year; then, because brown-founding > rice-founding would
    be false, it would declare Rice older despite them being the same age. So a more
    accurate program would check whether they’re equal, and only report one as older
    if it really is. We can do this with an expanded version of the conditional, whose
    syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 2.6Evaluating by Reducing Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let us briefly talk about how Pyret produces values, i.e., the process
    of evaluation (reducing to values). Suppose we want to compute the wages of a
    worker. The worker is paid $10 for every hour up to the first 40 hours, and is
    paid $15 for every extra hour. Let’s say hours contains the number of hours they
    work, and suppose it’s 45:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the formula for computing the wage is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now see how this results in an answer, using a step-by-step process that
    should match what you’ve seen in algebra classes:The first step is to substitute
    the hours with 45.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, the conditional part of the if expression is evaluated, which in this
    case is false.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since the condition is false, the next branch is tried.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Since the condition is true, the expression reduces to the body of that branch.
    After that, it’s just arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This style of reduction is the best way to think about the evaluation of Pyret
    expressions (and later, functions). The whole expression takes steps that simplify
    it, proceeding by simple rules. You can use this style yourself if you want to
    try and work through the evaluation of a Pyret program by hand (or in your head).
  prefs: []
  type: TYPE_NORMAL
- en: 2.7Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pyret doesn’t limit you to numbers and strings; you can also treat images as
    data. To use images, we should ask Pyret for the image operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can draw a red circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also draw a white rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we can combine numbers, strings, and Booleans, we can also combine
    images (i.e., perform “arithmetic on images”). For instance, overlay will lay
    one image (the first one) atop the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: to obtain the [Japanese flag](https://en.wikipedia.org/wiki/Flag_of_Japan).
    Similarly, we can place three circles one above the other—<wbr>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '—<wbr>to get the first stage of a snowperson (have fun drawing in the rest!).Revisiting
    the Japanese flag for a moment, there are actually rules about the ratio of the
    different dimensions of the flag: the numbers above were not chosen mindlessly.
    For instance, the width and height must be in a 3:2 ratio (hence 300 and 200),
    and the red circle must have a diameter 3/5 of the overall height. If we now want
    to draw a bigger flag, we would have to carefully change many things to preserve
    these rules! Alternatively, we could use a variable to represent, say, one “unit”
    of size, and calculate everything else from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This now makes it easy to change just one thing and have everything else automatically
    change: each time we run the program the size of the flag depends on the value
    of unit. If we make 200, we obtain a flag twice as large; if we make it 50, we
    obtain one half as big.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, each time we have to keep running the program to compute these values
    afresh, a problem we’d like to avoid; we’ll return to this later [FILL]. Later
    we will also see how we can combine images with other computation to make movies,
    animations, and videogames [REF world].
  prefs: []
  type: TYPE_NORMAL
- en: 2.8Roughnums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we conclude looking at basic data, we have to say a little more about
    numbers. The numeric examples we’ve picked above have been chosen conveniently
    to not reveal a certain ugliness about how computers treat numbers. Though Pyret
    masks this ugliness for the most part, for various reasons (mainly having to do
    with efficiency), it does not mask them entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to see this problem is to ask for the square root of 2: num-sqrt(2).
    This number does not have a precise rational representation. Pyret still computes
    an answer, but prints it in a curious way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'What is going on here? Pyret wants to make sure you understand that what it
    has printed—<wbr>1.4142135623730951—<wbr>cannot possibly be the exact answer (because
    \(\sqrt{2}\) has no rational representation). The prefix of ~ means this is a
    roughnum: an approximate answer that you should treat with caution.In practice,
    roughnums are represented using [floating points](https://en.wikipedia.org/wiki/Floating_point),
    which are approximate but implemented efficiently in modern computers. Roughnums
    have a pervasive property: once a computation involves a roughnum, its answer
    will also be a roughnum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, this might be surprising:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You might think “Any number minus itself must be exactly zero”, but Pyret doesn’t
    “know” as much as you do, and hedges its bets.This turns out to be rather wise.
    For instance, consider this calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Look more closely at the digits after the decimal. You would expect them to
    be exactly the same as those for num-sqrt(2), but the first one seems to have
    an extra digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, subtracting 1 from the second number produces something slightly different
    from the first number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So is this or isn’t this exactly the same as num-sqrt(2)? Let’s ask Pyret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The notation e means an exponential representation, so this is the same as roughly
    \(2.2 \times 10^{-16}\)—<wbr>i.e., a very small number, but not exactly zero!
    Thus, starting with \(\sqrt{2}\), adding one, subtracting one, and then subtracting
    \(\sqrt{2}\) produces an answer that is not precisely zero.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do roughnums obey the axioms of arithmetic operators like (where appropriate)
    distributivity, associativity, and commutativity?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because roughnums are so brittle, Pyret doesn’t let you get misled by equality
    operations. If you ask
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Pyret is not sure: the ~1 represents some value that is approximately 1, but
    it could be exactly that or something close to but not exactly it (just like we
    saw a value that was close to but not exactly zero even though in reality we knew
    it was zero). Therefore, Pyret regards this as neither true nor false but rather
    as an error. Later [REF] we will see how to compare roughnums.'
  prefs: []
  type: TYPE_NORMAL
- en: A full explanation of floating points is well beyond the scope of this document;
    this section just warns you of what you must beware.The interested reader should
    find a copy of “What Every Computer Scientist Should Know About Floating-Point
    Arithmetic” by David Goldberg, e.g., [see here](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html).
  prefs: []
  type: TYPE_NORMAL
