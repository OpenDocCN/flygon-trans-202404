- en: 7Functions Anywhere
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 函数随处可见
- en: 'The introduction to the Scheme programming language definition establishes
    this design principle:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme 编程语言定义的介绍建立了这个设计原则：
- en: Programming languages should be designed not by piling feature on top of feature,
    but by removing the weaknesses and restrictions that make additional features
    appear necessary. [REF]
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编程语言的设计不应该是在功能上堆砌功能，而应该是通过消除使额外功能显得必要的弱点和限制来设计。[REF]
- en: As design principles go, this one is hard to argue with. (Some restrictions,
    of course, have good reason to exist, but this principle forces us to argue for
    them, not admit them by default.) Let’s now apply this to functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就设计原则而言，这个原则很难辩驳。（当然，有些限制确实有充分的理由存在，但这个原则迫使我们为它们辩护，而不是默认承认它们。）现在让我们把它应用到函数上。
- en: One of the things we stayed coy about when introducing functions ([Adding Functions
    to the Language](adding-functions.html)) is exactly where functions go. We may
    have suggested we’re following the model of an idealized DrRacket, with definitions
    and their uses kept separate. But, inspired by the Scheme design principle, let’s
    examine how necessary that is.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍函数时，有一件事情我们保持了含糊不清（[将函数添加到语言中](adding-functions.html)），那就是函数应该放在哪里。我们可能暗示我们正在遵循理想化的
    DrRacket 模型，其中定义和使用被分开。但是，受 Scheme 设计原则的启发，让我们看看这是否必要。
- en: Why can’t functions definitions be expressions? In our current arithmetic-centric
    language we face the uncomfortable question “What value does a function definition
    represent?”, to which we don’t really have a good answer. But a real programming
    language obviously computes more than numbers, so we no longer need to confront
    the question in this form; indeed, the answer to the above can just as well be,
    “A function value”. Let’s see how that might work out.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么函数定义不能是表达式？在我们当前以算术为中心的语言中，我们面临一个令人不舒服的问题“函数定义代表什么值？”，对此我们并没有一个好的答案。但是一个真正的编程语言显然计算的不仅仅是数字，所以我们不再需要以这种形式面对这个问题；事实上，上面的答案同样可以是“一个函数值”。让我们看看这可能会怎样。
- en: 'What can we do with functions as values? Clearly, functions are a distinct
    kind of value than a number, so we cannot, for instance, add them. But there is
    one evident thing we can do: apply them to arguments! Thus, we can allow function
    values to appear in the function position of an application. The behavior would,
    naturally, be to apply the function. Thus, we’re proposing a language where the
    following would be a valid program (where I’ve used brackets so we can easily
    identify the function)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为值我们能做什么？显然，函数是一种与数字不同的值，所以我们不能像添加数字那样，将它们相加。但有一件明显的事情我们可以做：将它们应用于参数！因此，我们可以允许函数值出现在应用的函数位置上。行为自然是应用函数。因此，我们提出的语言中以下内容将是一个有效的程序（我使用括号是为了方便我们识别函数）
- en: '| (+ 2 ([define (f x) (* x 3)] 4)) |'
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (+ 2 ([define (f x) (* x 3)] 4)) |'
- en: and would evaluate to (+ 2 (* 4 3)), or 14. (Did you see that I just used substitution?)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 并将计算结果为 (+ 2 (* 4 3))，或 14。 （你看到我刚刚使用了替换吗？）
- en: 7.1Functions as Expressions and Values
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 函数作为表达式和值
- en: 'Let’s first define the core language to include function definitions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义核心语言，包括函数定义：
- en: '[<expr-type>](#(elem._(chunk._~3cexpr-type~3e~3a1))) ::='
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[<expr-type>](#(elem._(chunk._~3cexpr-type~3e~3a1))) ::='
- en: '| (define-type ExprC |'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type ExprC |'
- en: '|   [numC (n : number)] |'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numC (n : number)] |'
- en: '|   [idC (s : symbol)] |'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [idC (s : symbol)] |'
- en: '|   [<app-type>](#(elem._(chunk._~3capp-type~3e~3a1))) |'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<app-type>](#(elem._(chunk._~3capp-type~3e~3a1))) |'
- en: '|   [plusC (l : ExprC) (r : ExprC)] |'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [plusC (l : ExprC) (r : ExprC)] |'
- en: '|   [multC (l : ExprC) (r : ExprC)] |'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [multC (l : ExprC) (r : ExprC)] |'
- en: '|   [<fun-type>](#(elem._(chunk._~3cfun-type~3e~3a1)))) |'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [<fun-type>](#(elem._(chunk._~3cfun-type~3e~3a1)))) |'
- en: For now, we’ll simply copy function definitions into the expression language.
    We’re free to change this if necessary as we go along, but for now it at least
    allows us to reuse our existing test cases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将简单地将函数定义复制到表达式语言中。如果需要的话，我们可以随时更改这个，但现在至少可以让我们重用我们现有的测试用例。
- en: '[<fun-type-take-1>](#(elem._(chunk._~3cfun-type-take-1~3e~3a1))) ::='
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[<fun-type-take-1>](#(elem._(chunk._~3cfun-type-take-1~3e~3a1))) ::='
- en: '[fdC (name : symbol) (arg : symbol) (body : ExprC)]'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[fdC (name : symbol) (arg : symbol) (body : ExprC)]'
- en: 'We also need to determine what an application looks like. What goes in the
    function position of an application? We want to allow an entire function definition,
    not just its name. Because we’ve lumped function definitions in with all other
    expressions, let’s allow an arbitrary expression here, but with the understanding
    that we want only function definition expressions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确定应用是什么样子的。应用的函数位置放什么？我们想允许整个函数定义，而不仅仅是它的名称。因为我们把函数定义与所有其他表达式混合在一起，所以让我们在这里允许任意表达式，但要理解我们只想要函数定义表达式：
- en: We might consider more refined datatypes that split function definitions apart
    from other kinds of expressions. This amounts to trying to classify different
    kinds of expressions, which we will return to when we study types. [REF]
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可能会考虑更精细的数据类型，将函数定义与其他类型的表达式分开。这就相当于试图对不同类型的表达式进行分类，这是我们在研究类型时将返回的内容。[REF]
- en: '[<app-type>](#(elem._(chunk._~3capp-type~3e~3a1))) ::='
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[<app-type>](#(elem._(chunk._~3capp-type~3e~3a1))) ::= '
- en: '[appC (fun : ExprC) (arg : ExprC)]'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[appC (fun : ExprC) (arg : ExprC)]'
- en: 'With this definition of application, we no longer have to look up functions
    by name, so the interpreter can get rid of the list of function definitions. If
    we need it we can restore it later, but for now let’s just explore what happens
    with function definitions are written at the point of application: so-called immediate
    functions.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个应用的定义，我们不再需要通过名称查找函数，所以解释器可以摆脱函数定义的列表。如果需要，我们可以稍后恢复它，但现在让我们来探讨一下在应用点写入函数定义时会发生什么：所谓的即时函数。
- en: 'Now let’s tackle interp. We need to add a case to the interpreter for function
    definitions, and this is a good candidate:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来解决interp。我们需要为解释器添加一个函数定义的情况，这是一个不错的选择：
- en: '| [fdC (n a b) expr] |'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [fdC (n a b) expr] |'
- en: Do Now!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始吧！
- en: What happens when you add this?
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你添加这个时会发生什么？
- en: 'Immediately, we see that we have a problem: the interpreter no longer always
    returns numbers, so we have a type error.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，我们发现了一个问题：解释器不再总是返回数字，所以我们有一个类型错误。
- en: We’ve alluded periodically to the answers computed by the interpreter, but never
    bothered gracing these with their own type. It’s time to do so now.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们周期性地提到解释器计算的答案，但从未打算给这些答案赋予自己的类型。现在是时候这样做了。
- en: '[<answer-type-take-1>](#(elem._(chunk._~3canswer-type-take-1~3e~3a1))) ::='
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[<answer-type-take-1>](#(elem._(chunk._~3canswer-type-take-1~3e~3a1))) ::= '
- en: '| (define-type Value |'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义-type Value |'
- en: '|   [numV (n : number)] |'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numV (n : number)] |'
- en: '|   [funV (name : symbol) (arg : symbol) (body : ExprC)]) |'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [funV (name : symbol) (arg : symbol) (body : ExprC)]) |'
- en: 'We’re using the suffix of V to stand for values, i.e., the result of evaluation.
    The pieces of a funV will be precisely those of a fdC: the latter is input, the
    former is output. By keeping them distinct we allow each one to evolve independently
    as needed.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用V的后缀代表值，即求值的结果。funV的部分将与fdC的部分完全相同：前者是输入，后者是输出。通过保持它们的区别，我们允许每个部分根据需要独立发展。
- en: 'Now we must rewrite the interpreter. Let’s start with its type:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须重写解释器。让我们从它的类型开始：
- en: '[<interp-hof>](#(elem._(chunk._~3cinterp-hof~3e~3a1))) ::='
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[<interp-hof>](#(elem._(chunk._~3cinterp-hof~3e~3a1))) ::= '
- en: '| (define (interp [expr : ExprC] [env : Env]) : Value |'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (interp [expr : ExprC] [env : Env]) : Value |'
- en: '|   (type-case ExprC expr |'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case ExprC expr |'
- en: '|     [<interp-body-hof>](#(elem._(chunk._~3cinterp-body-hof~3e~3a1))))) |'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<interp-body-hof>](#(elem._(chunk._~3cinterp-body-hof~3e~3a1))))) |'
- en: This change naturally forces corresponding type changes to the Binding datatype
    and to lookup.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变自然地导致Binding数据类型和lookup的相应类型更改。
- en: Exercise
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Modify Binding and lookup, appropriately.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 适当地修改Binding和lookup。
- en: '[<interp-body-hof>](#(elem._(chunk._~3cinterp-body-hof~3e~3a1))) ::='
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[<interp-body-hof>](#(elem._(chunk._~3cinterp-body-hof~3e~3a1))) ::= '
- en: '| [numC (n) (numV n)] |'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [numC (n) (numV n)] |'
- en: '| [idC (n) (lookup n env)] |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [idC (n) (lookup n env)] |'
- en: '| [<app-case>](#(elem._(chunk._~3capp-case~3e~3a1))) |'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [<app-case>](#(elem._(chunk._~3capp-case~3e~3a1))) |'
- en: '| [<plus/mult-case>](#(elem._(chunk._~3cplus/mult-case~3e~3a1))) |'
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [<plus/mult-case>](#(elem._(chunk._~3cplus/mult-case~3e~3a1))) |'
- en: '| [<fun-case>](#(elem._(chunk._~3cfun-case~3e~3a1))) |'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [<fun-case>](#(elem._(chunk._~3cfun-case~3e~3a1))) |'
- en: 'Clearly, numeric answers need to be wrapped in the appropriate numeric answer
    constructor. Identifier lookup is unchanged. We have to slightly modify addition
    and multiplication to deal with the fact that the interpreter returns Values,
    not numbers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，数值答案需要用适当的数值答案构造函数包装起来。标识符查找没有变化。我们必须稍微修改加法和乘法以处理解释器返回的是值而不是数字这一事实：
- en: '[<plus/mult-case>](#(elem._(chunk._~3cplus/mult-case~3e~3a1))) ::='
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[<plus/mult-case>](#(elem._(chunk._~3cplus/mult-case~3e~3a1))) ::= '
- en: '| [plusC (l r) (num+ (interp l env) (interp r env))] |'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [plusC (l r) (num+ (interp l env) (interp r env))] |'
- en: '| [multC (l r) (num* (interp l env) (interp r env))] |'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [multC (l r) (num* (interp l env) (interp r env))] |'
- en: 'It’s worth examining the definition of one of these helper functions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 值得检查其中一个辅助函数的定义：
- en: '| (define (num+ [l : Value] [r : Value]) : Value |'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (num+ [l : Value] [r : Value]) : Value |'
- en: '|   (cond |'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (cond |'
- en: '|     [(and (numV? l) (numV? r)) |'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [(and (numV? l) (numV? r)) |'
- en: '|      (numV (+ (numV-n l) (numV-n r)))] |'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (numV (+ (numV-n l) (numV-n r)))] |'
- en: '|     [else |'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [else |'
- en: '|      (error ''num+ "one argument was not a number")])) |'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      (error ''num+ "一个参数不是数字")])) |'
- en: Observe that it checks that both arguments are numbers before performing the
    addition. This is an instance of a safe run-time system. We’ll discuss this topic
    more when we get to types. [REF]
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在执行加法之前，它检查两个参数是否都是数字。这是一个安全的运行时系统的一个例子。当我们讨论类型时，我们将更多地讨论这个主题。[REF]
- en: 'There are two more cases to cover. One is function definitions. We’ve already
    agreed these will be their own kind of value:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两种情况要涵盖。一种是函数定义。我们已经同意这些将是它们自己的一种值：
- en: '[<fun-case-take-1>](#(elem._(chunk._~3cfun-case-take-1~3e~3a1))) ::='
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[<fun-case-take-1>](#(elem._(chunk._~3cfun-case-take-1~3e~3a1))) ::='
- en: '[fdC (n a b) (funV n a b)]'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[fdC (n a b) (funV n a b)]'
- en: 'That leaves one case, application. Though we no longer need to look up the
    function definition, we’ll leave the code structured as similarly as possible:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了一个情况，应用。虽然我们不再需要查找函数定义，但我们将尽可能保持代码结构相似：
- en: '[<app-case-take-1>](#(elem._(chunk._~3capp-case-take-1~3e~3a1))) ::='
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[<app-case-take-1>](#(elem._(chunk._~3capp-case-take-1~3e~3a1))) ::='
- en: '| [appC (f a) (local ([define fd f]) |'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [appC (f a) (local ([define fd f]) |'
- en: '|               (interp (fdC-body fd) |'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (interp (fdC-body fd) |'
- en: '|                       (extend-env (bind (fdC-arg fd) |'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (extend-env (bind (fdC-arg fd) |'
- en: '|                                         (interp a env)) |'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                         (interp a env)) |'
- en: '|                                   mt-env)))] |'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                   mt-env)))] |'
- en: In place of the lookup, we reference f which is the function definition, sitting
    right there. Note that, because any expression can be in the function definition
    position, we really ought to harden the code to check that it is indeed a function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在查找的位置，我们引用了函数定义f，就在那里。请注意，因为任何表达式都可以在函数定义位置，我们确实应该加强代码以检查它确实是一个函数。
- en: Do Now!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在动手！
- en: What does is mean? That is, do we want to check that the function definition
    position is syntactically a function definition (fdC), or only that it evaluates
    to one (funV)? Is there a difference, i.e., can you write a program that satisfies
    one condition but not the other?
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是什么意思？也就是说，我们想要检查函数定义位置在语法上是否是函数定义（fdC），还是仅仅它是否评估为一个（funV）？有区别吗，也就是说，你能写一个满足一个条件但不满足另一个条件的程序吗？
- en: 'We have two choices:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个选择：
- en: We can check that it syntactically is an fdC and, if it isn’t reject it as an
    error.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查它在语法上是否是一个fdC，并且如果不是，则拒绝它作为错误。
- en: We can evaluate it, and check that the resulting value is a function (and signal
    an error otherwise).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以评估它，并检查结果值是否是一个函数（否则会发出错误信号）。
- en: We will take the latter approach, because this gives us a much more flexible
    language. In particular, even if we can’t immediately imagine cases where we,
    as humans, might need this, it might come in handy when a program needs to generate
    code. And we’re writing precisely such a program, namely the desugarer! (See [Sugaring
    Over Anonymity](#(part._let-desugar)).) As a result, we’ll modify the application
    case to evaluate the function position:[<app-case-take-2>](#(elem._(chunk._~3capp-case-take-2~3e~3a1)))
    ::=
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取后一种方法，因为这给了我们一个更加灵活的语言。特别是，即使我们无法立即想象出我们作为人类可能需要这种情况，但当程序需要生成代码时，这可能会派上用场。而我们正在编写正是这样的程序，即解糖器！（参见[Sugaring
    Over Anonymity](#(part._let-desugar)）。）因此，我们将修改应用案例以评估函数位置：[<app-case-take-2>](#(elem._(chunk._~3capp-case-take-2~3e~3a1)))
    ::=
- en: '| [appC (f a) (local ([define fd (interp f env)]) |'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [appC (f a) (local ([define fd (interp f env)]) |'
- en: '|               (interp (funV-body fd) |'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (interp (funV-body fd) |'
- en: '|                       (extend-env (bind (funV-arg fd) |'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (extend-env (bind (funV-arg fd) |'
- en: '|                                         (interp a env)) |'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                         (interp a env)) |'
- en: '|                                   mt-env)))] |'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                   mt-env)))] |'
- en: Exercise
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Modify the code to perform both versions of this check.
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改代码以执行此检查的两个版本。
- en: 'And with that, we’re done. We have a complete interpreter! Here, for instance,
    are some of our old tests again:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们完成了。我们有一个完整的解释器！例如，这里是我们的一些旧测试：
- en: '| (test (interp (plusC (numC 10) (appC (fdC ''const5 ''_ (numC 5)) (numC 10)))
    |'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               mt-env) |'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (numV 15)) |'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   |'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (test/exn (interp (appC (fdC ''f1 ''x (appC (fdC ''f2 ''y (plusC (idC ''x) (idC ''y)))
    |'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                           (numC 4))) |'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (numC 3)) |'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                   mt-env) |'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|           "name not found") |'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 7.2Nested What?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The body of a function definition is an arbitrary expression. A function definition
    is itself an expression. That means a function definition can contain a...function
    definition. For instance:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[<nested-fdC>](#(elem._(chunk._~3cnested-fd.C~3e~3a1))) ::='
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '| (fdC ''f1 ''x |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|      (fdC ''f2 ''x |'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|           (plusC (idC ''x) (idC ''x)))) |'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Evaluating this isn’t very interesting:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| (funV ''f1 ''x (fdC ''f2 ''x (plusC (idC ''x) (idC ''x)))) |'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: But suppose we apply the above function to something:[<applied-nested-fdC>](#(elem._(chunk._~3capplied-nested-fd.C~3e~3a1)))
    ::=
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '| (appC [<nested-fdC>](#(elem._(chunk._~3cnested-fd.C~3e~3a1))) |'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (numC 4)) |'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Now the answer becomes more interesting:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '| (funV ''f2 ''x (plusC (idC ''x) (idC ''x))) |'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'It’s almost as if applying the outer function had no impact on the inner function
    at all. Well, why should it? The outer function introduces an identifier which
    is promptly masked by the inner function introducing one of the same name, thereby
    masking the outer definition if we obey static scope (as we should!). But that
    suggests a different program:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '| (appC (fdC ''f1 ''x |'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|            (fdC ''f2 ''y |'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                 (plusC (idC ''x) (idC ''y)))) |'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (numC 4)) |'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'This evaluates to:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '| (funV ''f2 ''y (plusC (idC ''x) (idC ''y))) |'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Hmm, that’s interesting.Do Now!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: What’s interesting?
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To see what’s interesting, let’s apply this once more:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '| (appC (appC (fdC ''f1 ''x |'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                  (fdC ''f2 ''y |'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       (plusC (idC ''x) (idC ''y)))) |'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|             (numC 4)) |'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (numC 5)) |'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'This produces an error indicating that the identifier representing x isn’t
    bound!But it’s bound by the function named f1, isn’t it? For clarity, let’s switch
    to representing it in our hypothetical Racket syntax:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '| ((define (f1 x) |'
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|    ((define (f2 y) |'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|       (+ x y)) |'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     4)) |'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  5) |'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: On applying the outer function, we would expect x to be substituted with 5,
    resulting in
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '| ((define (f2 y) |'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|    (+ 5 y)) |'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|  4) |'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: which on further application and substitution yields (+ 5 4) or 9, not an error.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we’re again failing to faithfully capture what substitution
    would have done.On the other hand, observe that with substitution, as we’ve defined
    it, we would be replacing x with (numV 4), resulting in a function body of (plusC
    (numV 5) (idC ’y)), which does not type. That is, substitution is predicated on
    the assumption that the type of answers is a form of syntax. It is actually possible
    to carry through a study of even very advanced programming constructs under this
    assumption, but we won’t take that path here. A function value needs to remember
    the substitutions that have already been applied to it. Because we’re representing
    substitutions using an environment, a function value therefore needs to be bundled
    with an environment. This resulting data structure is called a closure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们再次没有忠实地捕捉到替换会做什么。另一方面，请注意，按照我们定义的替换方式，我们将用 (numV 4) 替换 x，导致函数体为 (plusC
    (numV 5) (idC ’y))，这是无法类型化的。也就是说，替换的前提是答案的类型是一种形式的语法。实际上，甚至在这种假设下也可以进行非常高级的编程构造的研究，但我们不会选择这条路。函数值需要记住已应用到它的替换。因为我们正在使用环境来表示替换，所以函数值因此需要与环境一起捆绑。这个结果数据结构称为闭包。
- en: 'While we’re at it, observe that the appC case above uses funV-arg and funV-body,
    but not funV-name. Come to think of it, why did a function need a name? so that
    we could find it. But if we’re using the interpreter to find the function for
    us, then there’s nothing to find and fetch. Thus the name is merely descriptive,
    and might as well be a comment. In other words, a function no more needs a name
    than any other immediate constant: we don’t name every use of 3, for instance,
    so why should we name every use of a function? A function is inherently anonymous,
    and we should separate its definition from its naming.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此时请注意上面的 appC 情况使用了 funV-arg 和 funV-body，但没有使用 funV-name。想想看，为什么函数需要名称？为了我们能找到它。但是如果我们使用解释器来找到函数，那么就没有东西可以找到和获取了。因此，名称仅仅是描述性的，可以理解为注释。换句话说，函数不需要名称，就像其他任何即时常量一样：例如，我们不会给每个
    3 的使用命名，那么为什么我们要给每个函数的使用命名呢？函数本质上是匿名的，我们应该将其定义与命名分开。
- en: (But, you might say, this argument only makes sense if functions are always
    written in-place. What if we want to put them somewhere else? Won’t they need
    names then? They will, and we’ll return to this ([Sugaring Over Anonymity](#(part._let-desugar))).)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: （但是，你可能会说，如果函数总是在原地编写，这个论点才有意义。如果我们想把它们放在其他地方怎么办？那么它们不需要名称吗？它们需要，我们将在此返回（[Sugaring
    Over Anonymity](#(part._let-desugar))）。）
- en: 7.3Implementing Closures
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3Implementing Closures
- en: 'We need to change our representation of values to record closures rather than
    raw function text:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改变我们对值的表示方式，记录闭包而不是原始函数文本：
- en: '[<answer-type>](#(elem._(chunk._~3canswer-type~3e~3a1))) ::='
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[<answer-type>](#(elem._(chunk._~3canswer-type~3e~3a1))) ::='
- en: '| (define-type Value |'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define-type Value |'
- en: '|   [numV (n : number)] |'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numV (n : number)] |'
- en: '|   [closV (arg : symbol) (body : ExprC) (env : Env)]) |'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [closV (arg : symbol) (body : ExprC) (env : Env)]) |'
- en: 'While we’re at it, we might as well alter our syntax for defining functions
    to drop the useless name. This construct is historically called a lambda:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，我们也可以修改我们定义函数的语法，以删除无用的名称。这个结构在历史上被称为 lambda：
- en: '[<fun-type>](#(elem._(chunk._~3cfun-type~3e~3a1))) ::='
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[<fun-type>](#(elem._(chunk._~3cfun-type~3e~3a1))) ::='
- en: '[lamC (arg : symbol) (body : ExprC)]'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[lamC (arg : symbol) (body : ExprC)]'
- en: When encountering a function definition, the interpreter must now remember to
    save the substitutions that have been applied so far:“Save the environment! Create
    a closure today!” —<wbr>Cormac Flanagan
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在遇到函数定义时，解释器现在必须记住保存到目前为止已应用的替换：“保存环境！今天创建一个闭包！” ——<wbr>Cormac Flanagan
- en: '[<fun-case>](#(elem._(chunk._~3cfun-case~3e~3a1))) ::='
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[<fun-case>](#(elem._(chunk._~3cfun-case~3e~3a1))) ::='
- en: '[lamC (a b) (closV a b env)]'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[lamC (a b) (closV a b env)]'
- en: 'This saved set, not the empty environment, must be used when applying a function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用函数时，必须使用这个保存的集合，而不是空环境：
- en: '[<app-case>](#(elem._(chunk._~3capp-case~3e~3a1))) ::='
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[<app-case>](#(elem._(chunk._~3capp-case~3e~3a1))) ::='
- en: '| [appC (f a) (local ([define f-value (interp f env)]) |'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [appC (f a) (local ([define f-value (interp f env)]) |'
- en: '|               (interp (closV-body f-value) |'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (interp (closV-body f-value) |'
- en: '|                       (extend-env (bind (closV-arg f-value) |'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                       (extend-env (bind (closV-arg f-value) |'
- en: '|                                         (interp a env)) |'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                         (interp a env)) |'
- en: '|                                   (closV-env f-value))))] |'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                   (closV-env f-value))))] |'
- en: 'There’s actually another possibility: we could use the environment present
    at the point of application:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '| [appC (f a) (local ([define f-value (interp f env)]) |'
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|               (interp (closV-body f-value) |'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       (extend-env (bind (closV-arg f-value) |'
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                         (interp a env)) |'
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                                   env)))] |'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Exercise
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we extend the dynamic environment instead?
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In retrospect, it becomes even more clear why we interpreted the body of a function
    in the empty environment. When a function is defined at the top-level, it is not
    “closed over” any identifiers. Therefore, our previous function applications have
    been special cases of this form of application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 7.4Substitution, Again
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that substitution is instructive in thinking through how to implement
    lambda functions. However, we have to be careful with substitution itself! Suppose
    we have the following expression (to give lambda functions their proper Racket
    syntax):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (f) |'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (lambda (x) |'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (f 10))) |'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Now suppose we substitute for f the following expression: (lambda (y) (+ x
    y)). Observe that it has a free identifier (x), so if it is ever evaluated, we
    would expect to get an unbound identifier error. Substitution would appear to
    give:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (x) |'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   ((lambda (y) (+ x y)) 10)) |'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'But observe that this latter program has no free identifiers!That’s because
    we have too naive a version of substitution. To prevent unexpected behavior like
    this (which is a form of dynamic binding), we need to define capture-free substitution.
    It works roughly as follows: we first consistently rename all bound identifiers
    to entirely previously unused (known as fresh) names. Imagine that we give each
    identifier a numeric suffix to attain freshness. Then the original expression
    becomes'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (f1) |'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (lambda (x1) |'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     (f1 10))) |'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '(Observe that we renamed f to f1 in both the binding and bound locations.)
    Now let’s do the same with the expression we’re substituting:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (y1) (+ x y1)) |'
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Why didn’t we rename x? Because x may be a reference to a top-level binding,
    which should then also be renamed. This is simply another application of the consistent
    renaming principle. In the current setting, the distinction is irrelevant. Now
    let’s substitute for f1:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '| (lambda (x1) |'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   ((lambda (y1) (+ x y1)) 10)) |'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '...and x is still free! This is a good form of substitution.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: But one moment. What happens if we try the same example in our environment-based
    interpreter?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Try it out.
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Observe that it works correctly: it reports an unbound identifier error. Environments
    automatically implement capture-free substitution!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In what way does using an environment avoid the capture problem of substitution?
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 7.5Sugaring Over Anonymity
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s get back to the idea of naming functions, which has evident value
    for program understanding. Observe that we do have a way of naming things: by
    passing them to functions, where they acquire a local name (that of the formal
    parameter). Anywhere within that function’s body, we can refer to that entity
    using the formal parameter name.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到给函数命名的想法，这对于程序理解具有明显的价值。请注意，我们确实有一种命名事物的方法：通过将它们传递给函数，在那里它们获得一个本地名称（即形式参数的名称）。在该函数的任何地方，我们都可以使用形式参数名称引用该实体。
- en: Therefore, we can take a collection of function definitions and name them using
    other...functions. For instance, the Racket code
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将一组函数定义收集起来，并使用其他...函数来命名它们。例如，Racket 代码
- en: '| (define (double x) (+ x x)) |'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (双倍 x) (+ x x)) |'
- en: '| (double 10) |'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (双倍 10) |'
- en: could first be rewritten as the equivalent
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先可以重写为等价形式
- en: '| (define double (lambda (x) (+ x x))) |'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 双倍 (lambda (x) (+ x x))) |'
- en: '| (double 10) |'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (双倍 10) |'
- en: 'We can of course just inline the definition of double, but to preserve the
    name, we could write this as:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以直接内联双倍的定义，但为了保留名称，我们可以这样写：
- en: '| ((lambda (double) |'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((lambda (双倍) |'
- en: '|    (double 10)) |'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    (双倍 10)) |'
- en: '|  (lambda (x) (+ x x))) |'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (lambda (x) (+ x x))) |'
- en: 'Indeed, this pattern—<wbr>which we will pronounce as “left-left-lambda”—<wbr>is
    a local naming mechanism. It is so useful that in Racket, it has its own special
    syntax:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种模式——我们将其发音为“左-左-λ”——是一种本地命名机制。在 Racket 中，它非常有用，因此有自己的特殊语法：
- en: '| (let ([double (lambda (x) (+ x x))]) |'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (让 ([双倍 (lambda (x) (+ x x))]) |'
- en: '|   (double 10)) |'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (双倍 10)) |'
- en: 'where let can be defined by desugaring as shown above.Here’s a more complex
    example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 let 可以通过上面显示的展开来定义。这里有一个更复杂的例子：
- en: '| (define (double x) (+ x x)) |'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (双倍 x) (+ x x)) |'
- en: '| (define (quadruple x) (double (double x))) |'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (四倍 x) (双倍 (双倍 x))) |'
- en: '| (quadruple 10) |'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (四倍 10) |'
- en: This could be rewritten as
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以重写为
- en: '| (let ([double (lambda (x) (+ x x))]) |'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (让 ([双倍 (lambda (x) (+ x x))]) |'
- en: '|   (let ([quadruple (lambda (x) (double (double x)))]) |'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (让 ([四倍 (lambda (x) (双倍 (双倍 x)))]) |'
- en: '|     (quadruple 10))) |'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (四倍 10))) |'
- en: which works just as we’d expect; but if we change the order, it no longer works—<wbr>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按我们的预期工作；但如果我们改变顺序，它就不再起作用——
- en: '| (let ([quadruple (lambda (x) (double (double x)))]) |'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (让 ([四倍 (lambda (x) (双倍 (双倍 x)))]) |'
- en: '|   (let ([double (lambda (x) (+ x x))]) |'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (让 ([双倍 (lambda (x) (+ x x))]) |'
- en: '|     (quadruple 10))) |'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (四倍 10))) |'
- en: '—<wbr>because quadruple can’t “see” double. so we see that top-level binding
    is different from local binding: essentially, the top-level has an “infinite scope”.
    This is the source of both its power and problems.There is another, subtler, problem:
    it has to do with recursion. Consider the simplest infinite loop:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: —因为四倍无法“看到”双倍。所以我们看到顶层绑定与本地绑定不同：本质上，顶层具有“无限范围”。这是其强大和问题的根源。还有另一个更微妙的问题：与递归有关。考虑最简单的无限循环：
- en: '| (define (loop-forever x) (loop-forever x)) |'
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (永远循环 x) (永远循环 x)) |'
- en: '| (loop-forever 10) |'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (永远循环 10) |'
- en: 'Let’s convert it to let:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其转换为 let：
- en: '| (let ([loop-forever (lambda (x) (loop-forever x))]) |'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (让 ([永远循环 (lambda (x) (永远循环 x))]) |'
- en: '|   (loop-forever 10)) |'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (永远循环 10)) |'
- en: 'Seems fine, right? Rewrite in terms of lambda:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，对吧？用 lambda 重写：
- en: '| ((lambda (loop-forever) |'
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((lambda (永远循环) |'
- en: '|    (loop-forever 10)) |'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    (永远循环 10)) |'
- en: '|  (lambda (x) (loop-forever x))) |'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|  (lambda (x) (永远循环 x))) |'
- en: Clearly, the loop-forever on the last line isn’t bound!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，最后一行的永远循环没有绑定！
- en: This is another feature we get “for free” from the top-level. To eliminate this
    magical force, we need to understand recursion explicitly, which we will do soon
    [REF].
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从顶层“免费”获得的另一个功能。为了消除这种神奇的力量，我们需要明确理解递归，我们很快会做到[REF]。
