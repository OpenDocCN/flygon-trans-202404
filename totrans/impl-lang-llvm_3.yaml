- en: Code Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Generation to LLVM IR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to Chapter 3 of the "Implementing a language with LLVM" tutorial. This
    chapter shows you how to transform the Abstract Syntax Tree, built in Chapter
    2, into LLVM IR. This will teach you a little bit about how LLVM does things,
    as well as demonstrate how easy it is to use. It's much more work to build a lexer
    and parser than it is to generate LLVM IR code. :)
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note: the code in this chapter and later require LLVM 2.2 or later.
    LLVM 2.1 and before will not work with it. Also note that you need to use a version
    of this tutorial that matches your LLVM release: If you are using an official
    LLVM release, use the version of the documentation included with your release
    or on the llvm.org releases page.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Code Generation Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to generate LLVM IR, we want some simple setup to get started. First
    we define virtual code generation (codegen) methods in each AST class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Codegen()` method says to emit IR for that AST node along with all the
    things it depends on, and they all return an LLVM Value object. "Value" is the
    class used to represent a "Static Single Assignment (SSA) register" or "SSA value"
    in LLVM. The most distinct aspect of SSA values is that their value is computed
    as the related instruction executes, and it does not get a new value until (and
    if) the instruction re-executes. In other words, there is no way to "change" an
    SSA value. For more information, please read up on Static Single Assignment -
    the concepts are really quite natural once you grok them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that instead of adding virtual methods to the ExprAST class hierarchy,
    it could also make sense to use a visitor pattern or some other way to model this.
    Again, this tutorial won''t dwell on good software engineering practices: for
    our purposes, adding a virtual method is simplest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing we want is an `Error` method like we used for the parser,
    which will be used to report errors found during code generation (for example,
    use of an undeclared parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The static variables will be used during code generation. TheModule is the LLVM
    construct that contains all of the functions and global variables in a chunk of
    code. In many ways, it is the top-level structure that the LLVM IR uses to contain
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The Builder object is a helper object that makes it easy to generate LLVM instructions.
    Instances of the [IRBuilder](http://llvm.org/doxygen/IRBuilder_8h-source.html)
    class template keep track of the current place to insert instructions and has
    methods to create new instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The NamedValues map keeps track of which values are defined in the current scope
    and what their LLVM representation is. (In other words, it is a symbol table for
    the code). In this form of Kaleidoscope, the only things that can be referenced
    are function parameters. As such, function parameters will be in this map when
    generating code for their function body.
  prefs: []
  type: TYPE_NORMAL
- en: With these basics in place, we can start talking about how to generate code
    for each expression. Note that this assumes that the Builder has been set up to
    generate code into something. For now, we'll assume that this has already been
    done, and we'll just use it to emit code.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Expression Code Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generating LLVM code for expression nodes is very straightforward: less than
    45 lines of commented code for all four of our expression nodes. First we''ll
    do numeric literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the LLVM IR, numeric constants are represented with the ConstantFP class,
    which holds the numeric value in an APFloat internally (APFloat has the capability
    of holding floating point constants of Arbitrary Precision). This code basically
    just creates and returns a ConstantFP. Note that in the LLVM IR that constants
    are all uniqued together and shared. For this reason, the API uses the `foo::get(...)`
    idiom instead of `new foo(..)` or `foo::Create(..)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: References to variables are also quite simple using LLVM. In the simple version
    of Kaleidoscope, we assume that the variable has already been emitted somewhere
    and its value is available. In practice, the only values that can be in the NamedValues
    map are function arguments. This code simply checks to see that the specified
    name is in the map (if not, an unknown variable is being referenced) and returns
    the value for it. In future chapters, we'll add support for loop induction variables
    in the symbol table, and for local variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Binary operators start to get more interesting. The basic idea here is that
    we recursively emit code for the left-hand side of the expression, then the right-hand
    side, then we compute the result of the binary expression. In this code, we do
    a simple switch on the opcode to create the right LLVM instruction.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the LLVM builder class is starting to show its value.
    IRBuilder knows where to insert the newly created instruction, all you have to
    do is specify what instruction to create (e.g. with CreateFAdd), which operands
    to use (L and R here) and optionally provide a name for the generated instruction.
  prefs: []
  type: TYPE_NORMAL
- en: One nice thing about LLVM is that the name is just a hint. For instance, if
    the code above emits multiple `addtmp` variables, LLVM will automatically provide
    each one with an increasing, unique numeric suffix. Local value names for instructions
    are purely optional, but it makes it much easier to read the IR dumps.
  prefs: []
  type: TYPE_NORMAL
- en: 'LLVM instructions are constrained by strict rules: for example, the Left and
    Right operators of an add instruction must have the same type, and the result
    type of the add must match the operand types. Because all values in Kaleidoscope
    are doubles, this makes for very simple code for add, sub and mul.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, LLVM specifies that the fcmp instruction always returns an
    ‘i1' value (a one bit integer). The problem with this is that Kaleidoscope wants
    the value to be a 0.0 or 1.0 value. In order to get these semantics, we combine
    the fcmp instruction with a uitofp instruction. This instruction converts its
    input integer into a floating point value by treating the input as an unsigned
    value. In contrast, if we used the sitofp instruction, the Kaleidoscope ‘<' operator
    would return 0.0 and -1.0, depending on the input value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Code generation for function calls is quite straightforward with LLVM. The code
    above initially does a function name lookup in the LLVM Module's symbol table.
    Recall that the LLVM Module is the container that holds all of the functions we
    are JIT'ing. By giving each function the same name as what the user specifies,
    we can use the LLVM symbol table to resolve function names for us.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the function to call, we recursively codegen each argument that
    is to be passed in, and create an LLVM call instruction. Note that LLVM uses the
    native C calling conventions by default, allowing these calls to also call into
    standard library functions like `sin` and `cos`, with no additional effort.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up our handling of the four basic expressions that we have so far
    in Kaleidoscope. Feel free to go in and add some more. For example, by browsing
    the LLVM language reference you'll find several other interesting instructions
    that are really easy to plug into our basic framework.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Function Code Generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code generation for prototypes and functions must handle a number of details,
    which make their code less beautiful than expression code generation, but allows
    us to illustrate some important points. First, lets talk about code generation
    for prototypes: they are used both for function bodies and external function declarations.
    The code starts with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code packs a lot of power into a few lines. Note first that this function
    returns a `Function*` instead of a `Value*`. Because a "prototype" really talks
    about the external interface for a function (not the value computed by an expression),
    it makes sense for it to return the LLVM Function it corresponds to when codegen'd.
  prefs: []
  type: TYPE_NORMAL
- en: The call to FunctionType::get creates the FunctionType that should be used for
    a given Prototype. Since all function arguments in Kaleidoscope are of type double,
    the first line creates a vector of "N" LLVM double types. It then uses the Functiontype::get
    method to create a function type that takes "N" doubles as arguments, returns
    one double as a result, and that is not vararg (the false parameter indicates
    this). Note that Types in LLVM are uniqued just like Constants are, so you don't
    "new" a type, you "get" it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final line above actually creates the function that the prototype will
    correspond to. This indicates the type, linkage and name to use, as well as which
    module to insert into. "external linkage" means that the function may be defined
    outside the current module and/or that it is callable by functions outside the
    module. The Name passed in is the name the user specified: since "TheModule" is
    specified, this name is registered in "TheModule"s symbol table, which is used
    by the function call code above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The Module symbol table works just like the Function symbol table when it comes
    to name conflicts: if a new function is created with a name that was previously
    added to the symbol table, the new function will get implicitly renamed when added
    to the Module. The code above exploits this fact to determine if there was a previous
    definition of this function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kaleidoscope, I choose to allow redefinitions of functions in two cases:
    first, we want to allow `extern`ing a function more than once, as long as the
    prototypes for the externs match (since all arguments have the same type, we just
    have to check that the number of arguments match). Second, we want to allow `extern`ing
    a function and then defining a body for it. This is useful when defining mutually
    recursive functions.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to implement this, the code above first checks to see if there is a
    collision on the name of the function. If so, it deletes the function we just
    created (by calling eraseFromParent) and then calling getFunction to get the existing
    function with the specified name. Note that many APIs in LLVM have "erase" forms
    and "remove" forms. The "remove" form unlinks the object from its parent (e.g.
    a Function from a Module) and returns it. The "erase" form unlinks the object
    and then deletes it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In order to verify the logic above, we first check to see if the pre-existing
    function is "empty". In this case, empty means that it has no basic blocks in
    it, which means it has no body. If it has no body, it is a forward declaration.
    Since we don't allow anything after a full definition of the function, the code
    rejects this case. If the previous reference to a function was an ‘extern', we
    simply verify that the number of arguments for that definition and this one match
    up. If not, we emit an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The last bit of code for prototypes loops over all of the arguments in the function,
    setting the name of the LLVM Argument objects to match, and registering the arguments
    in the NamedValues map for future use by the VariableExprAST AST node. Once this
    is set up, it returns the Function object to the caller. Note that we don't check
    for conflicting argument names here (e.g. "extern foo(a b a)"). Doing so would
    be very straight-forward with the mechanics we have already used above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Code generation for function definitions starts out simply enough: we just
    codegen the prototype (Proto) and verify that it is ok. We then clear out the
    NamedValues map to make sure that there isn''t anything in it from the last function
    we compiled. Code generation of the prototype ensures that there is an LLVM Function
    object that is ready to go for us.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we get to the point where the Builder is set up. The first line creates
    a new basic block (named "entry"), which is inserted into TheFunction. The second
    line then tells the builder that new instructions should be inserted into the
    end of the new basic block. Basic blocks in LLVM are an important part of functions
    that define the Control Flow Graph. Since we don't have any control flow, our
    functions will only contain one block at this point. We'll fix this in Chapter
    5 :).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the insertion point is set up, we call the CodeGen() method for the root
    expression of the function. If no error happens, this emits code to compute the
    expression into the entry block and returns the value that was computed. Assuming
    no error, we then create an LLVM ret instruction, which completes the function.
    Once the function is built, we call verifyFunction, which is provided by LLVM.
    This function does a variety of consistency checks on the generated code, to determine
    if our compiler is doing everything right. Using this is important: it can catch
    a lot of bugs. Once the function is finished and validated, we return it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The only piece left here is handling of the error case. For simplicity, we
    handle this by merely deleting the function we produced with the eraseFromParent
    method. This allows the user to redefine a function that they incorrectly typed
    in before: if we didn''t delete it, it would live in the symbol table, with a
    body, preventing future redefinition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code does have a bug, though. Since the `PrototypeAST::Codegen` can return
    a previously defined forward declaration, our code can actually delete a forward
    declaration. There are a number of ways to fix this bug, see what you can come
    up with! Here is a testcase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 3.4 Driver Changes and Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For now, code generation to LLVM doesn''t really get us much, except that we
    can look at the pretty IR calls. The sample code inserts calls to Codegen into
    the `HandleDefinition`, `HandleExtern` etc functions, and then dumps out the LLVM
    IR. This gives a nice way to look at the LLVM IR for simple functions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note how the parser turns the top-level expression into anonymous functions
    for us. This will be handy when we add JIT support in the next chapter. Also note
    that the code is very literally transcribed, no optimizations are being performed
    except simple constant folding done by IRBuilder. We will add optimizations explicitly
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This shows some simple arithmetic. Notice the striking similarity to the LLVM
    builder calls that we use to create the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This shows some function calls. Note that this function will take a long time
    to execute if you call it. In the future we'll add conditional control flow to
    actually make recursion useful :).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This shows an extern for the libm "cos" function, and a call to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When you quit the current demo, it dumps out the IR for the entire module generated.
    Here you can see the big picture with all the functions referencing each other.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up the third chapter of the Kaleidoscope tutorial. Up next, we'll
    describe how to add JIT codegen and optimizer support to this so we can actually
    start running code!
  prefs: []
  type: TYPE_NORMAL
