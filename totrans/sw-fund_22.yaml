- en: AutoMore Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Ltac inv H := inversion H; subst; clear H.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1]  →
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[2] →
  prefs: []
  type: TYPE_NORMAL
- en: st[1] = st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros c st st[1] st[2] E[1] E[2];
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent st[2];
  prefs: []
  type: TYPE_NORMAL
- en: induction E[1]; intros st[2] E[2]; inv E[2].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Skip *) reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Ass *) reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Seq *)'
  prefs: []
  type: TYPE_NORMAL
- en: assert (st' = st'0) as EQ[1].
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* Proof of assertion *) apply IHE1_1; assumption. }'
  prefs: []
  type: TYPE_NORMAL
- en: subst st'0.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHE1_2. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: (* E_IfTrue *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b evaluates to true *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHE1. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b evaluates to false (contradiction) *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H in H[5]. inversion H[5].
  prefs: []
  type: TYPE_NORMAL
- en: (* E_IfFalse *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b evaluates to true (contradiction) *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H in H[5]. inversion H[5].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b evaluates to false *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply IHE1. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: (* E_WhileEnd *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b evaluates to false *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b evaluates to true (contradiction) *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H in H[2]. inversion H[2].
  prefs: []
  type: TYPE_NORMAL
- en: (* E_WhileLoop *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b evaluates to false (contradiction) *)'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H in H[4]. inversion H[4].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b evaluates to true *)'
  prefs: []
  type: TYPE_NORMAL
- en: assert (st' = st'0) as EQ[1].
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* Proof of assertion *) apply IHE1_1; assumption. }'
  prefs: []
  type: TYPE_NORMAL
- en: subst st'0.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHE1_2. assumption. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Example auto_example_1 : ∀(P Q R: Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (P → Q) → (Q → R) → P → R.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P Q R H[1] H[2] H[3].
  prefs: []
  type: TYPE_NORMAL
- en: apply H[2]. apply H[1]. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Example auto_example_1'' : ∀(P Q R: Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (P → Q) → (Q → R) → P → R.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros P Q R H[1] H[2] H[3].
  prefs: []
  type: TYPE_NORMAL
- en: auto.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Example auto_example_2 : ∀P Q R S T U : Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: (P → Q) →
  prefs: []
  type: TYPE_NORMAL
- en: (P → R) →
  prefs: []
  type: TYPE_NORMAL
- en: (T → R) →
  prefs: []
  type: TYPE_NORMAL
- en: (S → T → U) →
  prefs: []
  type: TYPE_NORMAL
- en: ((P→Q) → (P→S)) →
  prefs: []
  type: TYPE_NORMAL
- en: T →
  prefs: []
  type: TYPE_NORMAL
- en: P →
  prefs: []
  type: TYPE_NORMAL
- en: U.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Example auto_example_3 : ∀(P Q R S T U: Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (P → Q) →
  prefs: []
  type: TYPE_NORMAL
- en: (Q → R) →
  prefs: []
  type: TYPE_NORMAL
- en: (R → S) →
  prefs: []
  type: TYPE_NORMAL
- en: (S → T) →
  prefs: []
  type: TYPE_NORMAL
- en: (T → U) →
  prefs: []
  type: TYPE_NORMAL
- en: P →
  prefs: []
  type: TYPE_NORMAL
- en: U.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* When it cannot solve the goal, auto does nothing *)
  prefs: []
  type: TYPE_NORMAL
- en: auto.
  prefs: []
  type: TYPE_NORMAL
- en: (* Optional argument says how deep to search (default is 5) *)
  prefs: []
  type: TYPE_NORMAL
- en: auto 6.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Example auto_example_4 : ∀P Q R : Prop,'
  prefs: []
  type: TYPE_NORMAL
- en: Q →
  prefs: []
  type: TYPE_NORMAL
- en: (Q → R) →
  prefs: []
  type: TYPE_NORMAL
- en: P ∨ (Q ∧ R).
  prefs: []
  type: TYPE_NORMAL
- en: Proof. auto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma le_antisym : ∀n m: nat, (n ≤ m ∧ m ≤ n) → n = m.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros. omega. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example auto_example_6 : ∀n m p : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: (n ≤ p → (n ≤ m ∧ m ≤ n)) →
  prefs: []
  type: TYPE_NORMAL
- en: n ≤ p →
  prefs: []
  type: TYPE_NORMAL
- en: n = m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros.
  prefs: []
  type: TYPE_NORMAL
- en: auto. (* does nothing: auto doesn't destruct hypotheses! *)
  prefs: []
  type: TYPE_NORMAL
- en: auto using le_antisym.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Hint Resolve T.
  prefs: []
  type: TYPE_NORMAL
- en: at the top level, where T is a top-level theorem or a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructor of an inductively defined proposition (i.e., anything
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: whose type is an implication).  As a shorthand, we can write
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Hint Unfold d.
  prefs: []
  type: TYPE_NORMAL
- en: where d is a defined symbol, so that auto knows to expand uses
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of d, thus enabling further possibilities for applying lemmas that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it knows about.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now let's take a first pass over ceval_deterministic to simplify
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the proof script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we are using a particular tactic many times in a proof, we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can use a variant of the Proof command to make that tactic into
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a default within the proof.  Saying Proof with t (where t is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: an arbitrary tactic) allows us to use t[1]... as a shorthand for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: t[1];t within the proof.  As an illustration, here is an alternate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: version of the previous proof, using Proof with auto.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Searching For Hypotheses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The proof has become simpler, but there is still an annoying
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: amount of repetition. Let's start by tackling the contradiction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cases. Each of them occurs in a situation where we have both
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: H[2]: beval st b = true
  prefs: []
  type: TYPE_NORMAL
- en: as hypotheses.  The contradiction is evident, but demonstrating it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'is a little complicated: we have to locate the two hypotheses H[1]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and H[2] and do a rewrite following by an inversion.  We'd
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: like to automate this process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (In fact, Coq has a built-in tactic congruence that will do the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: job in this case.  But we'll ignore the existence of this tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for now, in order to demonstrate how to build forward search
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactics by hand.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a first step, we can abstract out the piece of script in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: question by writing a little function in Coq's tactic programming
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language, Ltac.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That was is a bit better, but not much.  We really want Coq to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: discover the relevant hypotheses for us.  We can do this by using
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the match goal facility of Ltac.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The match goal tactic looks for two distinct hypotheses that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have the form of equalities, with the same arbitrary expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E on the left and with conflicting boolean values on the right.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If such hypotheses are found, it binds H[1] and H[2] to their
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: names and applies the rwinv tactic to H[1] and H[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adding this tactic to the ones that we invoke in each case of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction handles all of the contradictory cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's see about the remaining cases. Each of them involves
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: applying a conditional hypothesis to extract an equality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Currently we have phrased these as assertions, so that we have to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: predict what the resulting equality will be (although we can then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use auto to prove it).  An alternative is to pick the relevant
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'hypotheses to use and then rewrite with them, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we can automate the task of finding the relevant hypotheses to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rewrite with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The pattern ∀ x, ?P x → ?L = ?R matches any hypothesis of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the form "for all x, *some property of x* implies *some equality*."  The property
    of x is bound to the pattern variable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P, and the left- and right-hand sides of the equality are bound
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to L and R.  The name of this hypothesis is bound to H[1].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then the pattern ?P ?X matches any hypothesis that provides
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evidence that P holds for some concrete X.  If both patterns
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: succeed, we apply the rewrite tactic (instantiating the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: quantified x with X and providing H[2] as the required
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evidence for P X) in all hypotheses and the goal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'One problem remains: in general, there may be several pairs of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hypotheses that have the right general form, and it seems tricky
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to pick out the ones we actually need.  A key trick is to realize
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'that we can *try them all*!  Here''s how this works:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: each execution of match goal will keep trying to find a valid pair of hypotheses
    until the tactic on the RHS of the match succeeds; if there are no such pairs,
    it fails;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: rewrite will fail given a trivial equation of the form X = X;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we can wrap the whole thing in a repeat, which will keep doing useful rewrites
    until only trivial ones are left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The big payoff in this approach is that our proof script
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: should be robust in the face of modest changes to our language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, we can add a REPEAT command to the language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: REPEAT behaves like WHILE, except that the loop guard is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: checked *after* each execution of the body, with the loop
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: repeating as long as the guard stays *false*.  Because of this,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the body will always execute at least once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first attempt at the proof is disappointing: the E_RepeatEnd'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and E_RepeatLoop cases are not handled by our previous
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: automation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To fix this, we just have to swap the invocations of find_eqn
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and find_rwinv.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These examples just give a flavor of what "hyper-automation" can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: achieve in Coq.  The details of match goal are a bit tricky, and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: debugging scripts using it is, frankly, not very pleasant.  But it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is well worth adding at least simple uses to your proofs, both to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: avoid tedium and to "future proof" them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: eapply and eauto
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To close the chapter, we'll introduce one more convenient feature
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'of Coq: its ability to delay instantiation of quantifiers.  To'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: motivate this feature, recall this example from the [Imp](Imp.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'chapter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the first step of the proof, we had to explicitly provide a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: longish expression to help Coq instantiate a "hidden" argument to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the E_Seq constructor.  This was needed because the definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of E_Seq...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Example ceval''_example1:'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 2;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BLe (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: THEN Y ::= ANum 3
  prefs: []
  type: TYPE_NORMAL
- en: ELSE Z ::= ANum 4
  prefs: []
  type: TYPE_NORMAL
- en: FI)
  prefs: []
  type: TYPE_NORMAL
- en: / empty_state
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (t_update (t_update empty_state X 2) Z 4).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: eapply E_Seq. (* 1 *)
  prefs: []
  type: TYPE_NORMAL
- en: '- apply E_Ass. (* 2 *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. (* 3 *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* 4 *) apply E_IfFalse. reflexivity. apply E_Ass. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Hint Constructors ceval.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Transparent state.
  prefs: []
  type: TYPE_NORMAL
- en: Hint Transparent total_map.
  prefs: []
  type: TYPE_NORMAL
- en: Definition st[12] := t_update (t_update empty_state X 1) Y 2.
  prefs: []
  type: TYPE_NORMAL
- en: Definition st[21] := t_update (t_update empty_state X 2) Y 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example auto_example_8 : ∃s'','
  prefs: []
  type: TYPE_NORMAL
- en: (IFB (BLe (AId X) (AId Y))
  prefs: []
  type: TYPE_NORMAL
- en: THEN (Z ::= AMinus (AId Y) (AId X))
  prefs: []
  type: TYPE_NORMAL
- en: ELSE (Y ::= APlus (AId X) (AId Z))
  prefs: []
  type: TYPE_NORMAL
- en: FI) / st[21] ⇓ s'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. eauto. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
