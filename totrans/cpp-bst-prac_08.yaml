- en: Considering Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forward Declare When Possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This applies to templates as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a proactive approach to reduce compilation time and rebuilding dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Unnecessary Template Instantiations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates are not free to instantiate. Instantiating many templates, or templates
    with more code than necessary increases compiled code size and build time.
  prefs: []
  type: TYPE_NORMAL
- en: For more examples see [this article](http://blog2.emptycrate.com/content/template-code-bloat-revisited-smaller-makeshared).
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Recursive Template Instantiations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursive template instantiations can result in a significant load on the compiler
    and more difficult to understand code.
  prefs: []
  type: TYPE_NORMAL
- en: '[Consider using variadic expansions and folds when possible instead.](http://articles.emptycrate.com/2016/05/14/folds_in_cpp11_ish.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the Build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tool [Templight](https://github.com/mikael-s-persson/templight) can be used
    to analyze the build time of your project. It takes some effort to get built,
    but once you do, it's a drop in replacement for clang++.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you build using Templight, you will need to analyze the results. The
    [templight-tools](https://github.com/mikael-s-persson/templight-tools) project
    provides various methods. (Author''s Note: I suggest using the callgrind converter
    and visualizing the results with kcachegrind).'
  prefs: []
  type: TYPE_NORMAL
- en: Firewall Frequently Changing Header Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't Unnecessarily Include Headers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The compiler has to do something with each include directive it sees. Even if
    it stops as soon as it seems the `#ifndef` include guard, it still had to open
    the file and begin processing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[include-what-you-use](https://github.com/include-what-you-use/include-what-you-use)
    is a tool that can help you identify which headers you need.'
  prefs: []
  type: TYPE_NORMAL
- en: Reduce the load on the preprocessor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a general form of "Firewall Frequently Changing Header Files" and "Don't
    Unnecessarily Include Headers." Tools like BOOST_PP can be very helpful, but they
    also put a huge burden on the preprocessor.
  prefs: []
  type: TYPE_NORMAL
- en: Consider using precompiled headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The usage of precompiled headers can considerably reduce the compile time in
    large projects. Selected headers are compiled to an intermediate form (PCH files)
    that can be faster processed by the compiler. It is recommended to define only
    frequently used header that changes rarely as precompiled header (e.g. system
    and library headers) to achieve the compile time reduction. But you have to keep
    in mind, that using precompiled headers has several disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The usage of precompiled header is not portable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generated PCH files are machine dependent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The generated PCH files can be quite large.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can break your header dependencies. Because of the precompiled headers, every
    file has the possibility to include every header that is marked as a precompiled
    header. In result it can happen, that the build fails if you disable the precompiled
    headers. This can be an issue if you ship something like a library. Because of
    this it is highly recommend to build once with precompiled header enabled and
    a second time without them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precompiled headers is supported by the most common compiler, like [GCC](https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html),
    [Clang](http://clang.llvm.org/docs/PCHInternals.html) and [Visual Studio](https://msdn.microsoft.com/en-us/library/szfdksca.aspx).
    Tools like [cotire](https://github.com/sakra/cotire/) (a plugin for cmake) can
    help you to add precompiled headers to your build system.
  prefs: []
  type: TYPE_NORMAL
- en: Consider Using Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are not meant to supersede good design
  prefs: []
  type: TYPE_NORMAL
- en: '[ccache](https://ccache.samba.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[warp](https://github.com/facebook/warp), Facebook''s preprocessor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put tmp on Ramdisk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [this](https://www.youtube.com/watch?v=t4M3yG1dWho) YouTube video for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Use the gold linker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If on Linux, consider using the gold linker for GCC.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Analyze the Code!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's no real way to know where your bottlenecks are without analyzing the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.amd.com/tools-and-sdks/opencl-zone/codexl/](http://developer.amd.com/tools-and-sdks/opencl-zone/codexl/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.codersnotes.com/sleepy](http://www.codersnotes.com/sleepy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify the Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The cleaner, simpler, and easier to read the code is, the better chance the
    compiler has at implementing it well.
  prefs: []
  type: TYPE_NORMAL
- en: Use Initializer Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Initializer lists are significantly more efficient; reducing object copies and
    resizing of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce Temporary Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This sort of code prevents the compiler from performing a move operation...
  prefs: []
  type: TYPE_NORMAL
- en: Enable move operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Move operations are one of the most touted features of C++11\. They allow the
    compiler to avoid extra copies by moving temporary objects instead of copying
    them in certain cases.
  prefs: []
  type: TYPE_NORMAL
- en: Certain coding choices we make (such as declaring our own destructor or assignment
    operator or copy constructor) prevents the compiler from generating a move constructor.
  prefs: []
  type: TYPE_NORMAL
- en: For most code, a simple
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: would suffice. However, MSVC2013 doesn't seem to like this code yet.
  prefs: []
  type: TYPE_NORMAL
- en: Kill `shared_ptr` Copies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`shared_ptr` objects are much more expensive to copy than you''d think they
    would be. This is because the reference count must be atomic and thread-safe.
    So this comment just re-enforces the note above: avoid temporaries and too many
    copies of objects. Just because we are using a pImpl it does not mean our copies
    are free.'
  prefs: []
  type: TYPE_NORMAL
- en: Reduce Copies and Reassignments as Much as Possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more simple cases, the ternary operator can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: More complex cases can be facilitated with an [immediately-invoked lambda](http://blog2.emptycrate.com/content/complex-object-initialization-optimization-iife-c11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Avoid Excess Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exceptions which are thrown and captured internally during normal processing
    slow down the application execution. They also destroy the user experience from
    within a debugger, as debuggers monitor and report on each exception event. It
    is best to just avoid internal exception processing when possible.
  prefs: []
  type: TYPE_NORMAL
- en: Get rid of “new”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already know that we should not be using raw memory access, so we are using
    `unique_ptr` and `shared_ptr` instead, right? Heap allocations are much more expensive
    than stack allocations, but sometimes we have to use them. To make matters worse,
    creating a `shared_ptr` actually requires 2 heap allocations.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `make_shared` function reduces this down to just one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Prefer `unique_ptr` to `shared_ptr`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If possible use `unique_ptr` instead of `shared_ptr`. The `unique_ptr` does
    not need to keep track of its copies because it is not copyable. Because of this
    it is more efficient than the `shared_ptr`. Equivalent to `shared_ptr` and `make_shared`
    you should use `make_unique` (C++14 or greater) to create the `unique_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Current best practices suggest returning a `unique_ptr` from factory functions
    as well, then converting the `unique_ptr` to a `shared_ptr` if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Get rid of std::endl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::endl` implies a flush operation. It''s equivalent to `"\n" << std::flush`.'
  prefs: []
  type: TYPE_NORMAL
- en: Limit Variable Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables should be declared as late as possible, and ideally only when it's
    possible to initialize the object. Reduced variable scope results in less memory
    being used, more efficient code in general, and helps the compiler optimize the
    code further.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[This topic has an associated discussion thread](https://github.com/lefticus/cppbestpractices/issues/52).'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer `double` to `float`, But Test First
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the situation and the compiler's ability to optimize, one may be
    faster over the other. Choosing `float` will result in lower precision and may
    be slower due to conversions. On vectorizable operations `float` may be faster
    if you are able to sacrifice precision.
  prefs: []
  type: TYPE_NORMAL
- en: '`double` is the recomended default choice as it is the default type for floating
    point values in C++.'
  prefs: []
  type: TYPE_NORMAL
- en: See this [stackoverflow](http://stackoverflow.com/questions/4584637/double-or-float-which-is-faster)
    discussion for some more information.
  prefs: []
  type: TYPE_NORMAL
- en: Prefer `++i` to `i++`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '... when it is semantically correct. Pre-increment is [faster](http://blog2.emptycrate.com/content/why-i-faster-i-c)
    than post-increment because it does not require a copy of the object to be made.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Even if many modern compilers will optimize these two loops to the same assembly
    code, it is still good practice to prefer `++i`. There is absolutely no reason
    not to and you can never be certain that your code will not pass a compiler that
    does not optimize this. You should be also aware that the compiler will not be
    able optimize this only for integer types and not necessarily for all iterator
    or other user defined types.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that it is always easier and recommended to use the pre-increment
    operator if it is semantically identical to the post-increment operator.
  prefs: []
  type: TYPE_NORMAL
- en: Char is a char, string is a string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is very minor, but a `"\n"` has to be parsed by the compiler as a `const
    char *` which has to do a range check for `\0` when writing it to the stream (or
    appending to a string). A '\n' is known to be a single character and avoids many
    CPU instructions.
  prefs: []
  type: TYPE_NORMAL
- en: If used inefficiently very many times it might have an impact on your performance,
    but more importantly thinking about these two usage cases gets you thinking more
    about what the compiler and runtime has to do to execute your code.
  prefs: []
  type: TYPE_NORMAL
- en: Never Use `std::bind`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`std::bind` is almost always way more overhead (both compile time and runtime)
    than you need. Instead simply use a lambda.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
