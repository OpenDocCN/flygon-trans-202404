- en: The "Understanding monoids" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series, we'll look at a very common "pattern" known as a *monoid*.
  prefs: []
  type: TYPE_NORMAL
- en: Monoids are not really a design pattern; more an approach to working with many
    different types of values in a common way. In fact, once you understand monoids,
    you will start seeing them everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: '[Monoids without tears](monoids-without-tears.html). A mostly mathless discussion
    of a common functional pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Monoids in practice](monoids-part2.html). Monoids without tears - Part 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Working with non-monoids](monoids-part3.html). Monoids without tears - Part
    3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoids without tears
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monoids without tears
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are coming from an OO background, one of the more challenging aspects
    of learning functional programming is the lack of obvious design patterns. There
    are plenty of idioms such as [partial application](partial-application.html),
    and [error handling techniques](recipe-part2.html), but no apparent patterns in
    the [GoF sense](http://en.wikipedia.org/wiki/Design_Patterns).
  prefs: []
  type: TYPE_NORMAL
- en: In this post, we'll look at a very common "pattern" known as a *monoid*. Monoids
    are not really a design pattern; more an approach to working with many different
    types of values in a common way. In fact, once you understand monoids, you will
    start seeing them everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately the term "monoid" itself is a bit off-putting. It originally comes
    from [mathematics](http://en.wikipedia.org/wiki/Monoid) but the concept as applied
    to programming is easy to grasp without any math at all, as I hope to demonstrate.
    In fact, if we were to name the concept today in a programming context, we might
    call it something like `ICombinable` instead, which is not nearly as scary.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you might be wondering if a "monoid" has any connection with a "monad".
    Yes, there is a mathematical connection between them, but in programming terms,
    they are very different things, despite having similar names.
  prefs: []
  type: TYPE_NORMAL
- en: Uh-oh... some equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On this site, I generally don't use any math, but in this case I'm going to
    break my self-imposed rule and show you some equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ready? Here''s the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Could you handle that? How about another one?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And finally one more...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Ok! We're done! If you can understand these equations, then you have all the
    math you need to understand monoids.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking like a mathematician
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*"A mathematician, like a painter or poet, is a maker of patterns. If his patterns
    are more permanent than theirs, it is because they are made with ideas" -- G H
    Hardy*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Most people imagine that mathematicians work with numbers, doing complicated
    arithmetic and calculus.
  prefs: []
  type: TYPE_NORMAL
- en: This is a misconception. For example, if you look at [typical high-level](http://terrytao.wordpress.com/2013/07/27/an-improved-type-i-estimate/)
    [math discussions](http://books.google.co.uk/books?id=VOCQUC_uiWgC&pg=PA102),
    you will see lots of strange words, and lots of letter and symbols, but not a
    lot of arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that mathematicians *do* do though, is try to find patterns
    in things. "What do these things have in common?" and "How can we generalize these
    concepts?" are typical mathematical questions.
  prefs: []
  type: TYPE_NORMAL
- en: So let's look at these three equations through a mathematician's eyes.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing the first equation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A mathematician would look at `1 + 2 = 3` and think something like:'
  prefs: []
  type: TYPE_NORMAL
- en: We've got a bunch of things (integers in this case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've got some way of combining two of them (addition in this case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the result is another one of these things (that is, we get another integer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And then a mathematician might try to see if this pattern could be generalized
    to other kinds of things and operations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by staying with integers as the "things". What other ways are there
    of combining integers? And do they fit the pattern?
  prefs: []
  type: TYPE_NORMAL
- en: Let's try multiplication, does that fit this pattern?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes, multiplication does fit this pattern because multiplying
    any two integers results in another integer.
  prefs: []
  type: TYPE_NORMAL
- en: What about division? Does that fit the pattern? The answer is no, because in
    most cases, dividing two integers results in a fraction, which is *not* an integer
    (I'm ignoring integer division).
  prefs: []
  type: TYPE_NORMAL
- en: What about the `max` function? Does that fit the pattern? It combines two integers
    and returns one of them, so the answer is yes.
  prefs: []
  type: TYPE_NORMAL
- en: What about the `equals` function? It combines two integers but returns a boolean,
    not an integer, so the answer is no.
  prefs: []
  type: TYPE_NORMAL
- en: Enough of integers! What other kinds of things can we think of?
  prefs: []
  type: TYPE_NORMAL
- en: Floats are similar to integers, but unlike integers, using division with floats
    does result in another float, so the division operation fits the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How about booleans? They can be combined using operators such as AND, OR and
    so on. Does `aBool AND aBool` result in another bool? Yes! And `OR` too fits the
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Strings next. How can they be combined? One way is string concatenation, which
    returns another string, which is what we want. But something like the equality
    operation doesn't fit, because it returns a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's consider lists. As for strings, the obvious way to combine them
    is with list concatenation, which returns another list and fits the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We can continue on like this for all sorts of objects and combining operations,
    but you should see how it works now.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might ask: why is it so important that the operation return another thing
    of the same type? The answer is that **you can chain together multiple objects
    using the operation**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, because `1 + 2` is another integer, you can add 3 to it. And then
    because `1 + 2 + 3` is an integer as well, you can keep going and add say, 4,
    to the result. In other words, it is only because integer addition fits the pattern
    that you can write a sequence of additions like this: `1 + 2 + 3 + 4`. You couldn''t
    write `1 = 2 = 3 = 4` in the same way, because integer equality doesn''t fit the
    pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: And of course, the chain of combined items can be as long as we like. In other
    words, this pattern allows us to extend a pairwise operation into **an operation
    that works on lists**.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematicians call the requirement that "the result is another one of these
    things" the *closure* requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing the second equation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ok, what about the next equation, `1 + (2 + 3) = (1 + 2) + 3`? Why is that important?
  prefs: []
  type: TYPE_NORMAL
- en: Well, if you think about the first pattern, it says we can build up a chain
    of operations such as `1 + 2 + 3`. But we have only got a pairwise operation.
    So what order should we do the combining in? Should we combine 1 and 2 first,
    then combine the result with 3? Or should we combine 2 and 3 first and then combine
    1 with that result? Does it make a difference?
  prefs: []
  type: TYPE_NORMAL
- en: That's where this second equation is useful. It says that, for addition, the
    order of combination doesn't matter. You get the same result either way.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for a chain of four items like this: `1 + 2 + 3 + 4`, we could start working
    from the left hand side: `((1+2) + 3) + 4` or from the right hand side: `1 + (2
    + (3+4))` or even do it in two parts and then combine them like this: `(1+2) +
    (3+4)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's see if this pattern applies to the examples we've already looked at.
  prefs: []
  type: TYPE_NORMAL
- en: Again, let's start with other ways of combining integers.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with multiplication again. Does `1 * (2 * 3)` give the same result
    as `(1 * 2) * 3`? Yes. Just as with addition, the order doesn't matter.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's try subtraction. Does `1 - (2 - 3)` give the same result as `(1 -
    2) - 3`? No. For subtraction, the order *does* matter.
  prefs: []
  type: TYPE_NORMAL
- en: What about division? Does `12 / (2 / 3)` give the same result as `(12 / 2) /
    3`? No. For division also, the order matters.
  prefs: []
  type: TYPE_NORMAL
- en: But the `max` function does work. `max( max(12,2), 3)` gives the same result
    as `max(12, max(2,3)`.
  prefs: []
  type: TYPE_NORMAL
- en: What about strings and lists? Does concatenation meet the requirement? What
    do you think?
  prefs: []
  type: TYPE_NORMAL
- en: Here's a question... Can we come up with an operation for strings that *is*
    order dependent?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, how about a function like "subtractChars" which removes all characters
    in the right string from the left string. So `subtractChars("abc","ab")` is just
    `"c"`. `subtractChars` is indeed order dependent, as you can see with a simple
    example: `subtractChars("abc", subtractChars("abc","abc"))` is not the same string
    as `subtractChars(subtractChars("abc","abc"),"abc")`.'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematicians call the requirement that "the order doesn't matter" the *associativity*
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Important Note:** When I say the "order of combining", I am talking about
    the order in which you do the pairwise combining steps -- combining one pair,
    and then combining the result with the next item.'
  prefs: []
  type: TYPE_NORMAL
- en: But it is critical that the overall sequence of the items be left unchanged.
    This is because for certain operations, if you change the sequencing of the items,
    then you get a completely different result! `1 - 2` does not mean the same as
    `2 - 1` and `2 / 3` does not mean the same as `3 / 2`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in many common cases, the sequence order doesn't matter. After all,
    `1+2` is the same as `2+1`. In this case, the operation is said to be *commutative*.
  prefs: []
  type: TYPE_NORMAL
- en: The third equation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's look at the third equation, `1 + 0 = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mathematician would say something like: that''s interesting -- there is a
    special kind of thing ("zero") that, when you combine it with something, just
    gives you back the original something, as if nothing had happened.'
  prefs: []
  type: TYPE_NORMAL
- en: So once more, let's revisit our examples and see if we can extend this "zero"
    concept to other operations and other things.
  prefs: []
  type: TYPE_NORMAL
- en: Again, let's start with multiplication. Is there some value, such that when
    you multiply a number with it, you get back the original number?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, of course! The number one. So for multiplication, the number `1` is the
    "zero".
  prefs: []
  type: TYPE_NORMAL
- en: What about `max`? Is there a "zero" for that? For 32 bit ints, yes. Combining
    `System.Int32.MinValue` with any other 32 bit integer using `max` will return
    the other integer. That fits the definition of "zero" perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: What about booleans combined using AND? Is there a zero for that? Yes. It is
    the value `True`. Why? Because `True AND False` is `False`, and `True AND True`
    is `True`. In both cases the other value is returned untouched.
  prefs: []
  type: TYPE_NORMAL
- en: What about booleans combined using OR? Is there a zero for that as well? I'll
    let you decide.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, what about string concatenation? Is there a "zero" for this? Yes,
    indeed -- it is just the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, for list concatenation, the "zero" is just the empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the "zero" value depends very much on the operation, not just
    on the set of things. The zero for integer addition is different from the "zero"
    for integer multiplication, which is different again from the from "zero" for
    `Max`.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematicians call the "zero" the *identity element*.
  prefs: []
  type: TYPE_NORMAL
- en: The equations revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So now let's revisit the equations with our new generalizations in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before, we had:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'But now we have something much more abstract, a set of generalized requirements
    that can apply to all sorts of things:'
  prefs: []
  type: TYPE_NORMAL
- en: You start with a bunch of things, *and* some way of combining them two at a
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 1 (Closure)**: The result of combining two things is always another
    one of the things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2 (Associativity)**: When combining more than two things, which pairwise
    combination you do first doesn''t matter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 3 (Identity element)**: There is a special thing called "zero" such
    that when you combine any thing with "zero" you get the original thing back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these rules in place, we can come back to the definition of a monoid. A
    "monoid" is just a system that obeys all three rules. Simple!
  prefs: []
  type: TYPE_NORMAL
- en: As I said at the beginning, don't let the mathematical background put you off.
    If programmers had named this pattern, it probably would been called something
    like "the combinable pattern" rather than "monoid". But that's life. The terminology
    is already well-established, so we have to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Note there are *two* parts to the definition of a monoid -- the things plus
    the associated operation. A monoid is not just "a bunch of things", but "a bunch
    of things" *and* "some way of combining them". So, for example, "the integers"
    is not a monoid, but "the integers under addition" is a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: Semigroups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In certain cases, you have a system that only follows the first two rules, and
    there is no candidate for a "zero" value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your domain consists only of strictly positive numbers, then
    under addition they are closed and associative, but there is no positive number
    that can be "zero".
  prefs: []
  type: TYPE_NORMAL
- en: Another example might be the intersection of finite lists. It is closed and
    associative, but there is no (finite) list that when intersected with any other
    finite list, leaves it untouched.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of system still quite useful, and is called a "semigroup" by mathematicians,
    rather than a monoid. Luckily, there is a trick that can convert any semigroup
    into a monoid (which I'll describe later).
  prefs: []
  type: TYPE_NORMAL
- en: A table of classifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's put all our examples into a table, so you can see them all together.
  prefs: []
  type: TYPE_NORMAL
- en: '| Things | Operation | Closed? | Associative? | Identity? | Classification
    |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Addition | Yes | Yes | 0 | Monoid |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Multiplication | Yes | Yes | 1 | Monoid |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Subtraction | Yes | No | 0 | Other |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Max | Yes | Yes | Int32.MinValue | Monoid |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Equality | No |  |  | Other |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Less than | No |  |  | Other |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| Float | Multiplication | Yes | No (See note 1) | 1 | Other |'
  prefs: []
  type: TYPE_TB
- en: '| Float | Division | Yes (See note 2) | No | 1 | Other |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| Positive Numbers | Addition | Yes | Yes | No identity | Semigroup |'
  prefs: []
  type: TYPE_TB
- en: '| Positive Numbers | Multiplication | Yes | Yes | 1 | Monoid |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | AND | Yes | Yes | true | Monoid |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | OR | Yes | Yes | false | Monoid |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| String | Concatenation | Yes | Yes | Empty string "" | Monoid |'
  prefs: []
  type: TYPE_TB
- en: '| String | Equality | No |  |  | Other |'
  prefs: []
  type: TYPE_TB
- en: '| String | "subtractChars" | Yes | No | Empty string "" | Other |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '| List | Concatenation | Yes | Yes | Empty list [] | Monoid |'
  prefs: []
  type: TYPE_TB
- en: '| List | Intersection | Yes | Yes | No identity | Semigroup |'
  prefs: []
  type: TYPE_TB
- en: There are many other kinds of things you can add to this list; polynomials,
    matrices, probability distributions, and so on. This post won't discuss them,
    but once you get the idea of monoids, you will see that the concept can be applied
    to all sorts of things.
  prefs: []
  type: TYPE_NORMAL
- en: '*[Note 1]* As Doug points out in the comments, [floats are not associative](http://forums.udacity.com/questions/100055360/why-floating-point-arithematic-non-associative).
    Replace ''float'' with ''real number'' to get associativity.'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Note 2]* Mathematical real numbers are not closed under division, because
    you cannot divide by zero and get another real number. However, with IEEE floating
    point numbers you [*can* divide by zero](http://stackoverflow.com/questions/14682005/why-does-division-by-zero-in-ieee754-standard-results-in-infinite-value)
    and get a valid value. So floats are indeed closed under division! Here''s a demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What use are monoids to a programmer?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have described some abstract concepts, but what good are they for
    real-world programming problems?
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of closure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've seen, the closure rule has the benefit that you can convert pairwise
    operations into operations that work on lists or sequences.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if we can define a pairwise operation, we can extend it to list
    operations "for free".
  prefs: []
  type: TYPE_NORMAL
- en: 'The function that does this is typically called "reduce". Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Explicit | Using reduce |'
  prefs: []
  type: TYPE_TB
- en: '| `1 + 2 + 3 + 4` | `[ 1; 2; 3; 4 ] &#124;> List.reduce (+)` |'
  prefs: []
  type: TYPE_TB
- en: '| `1 * 2 * 3 * 4` | `[ 1; 2; 3; 4 ] &#124;> List.reduce (*)` |'
  prefs: []
  type: TYPE_TB
- en: '| `"a" + "b" + "c" + "d"` | `[ "a"; "b"; "c"; "d" ] &#124;> List.reduce (+)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[1] @ [2] @ [3] @ [4]` | `[ [1]; [2]; [3]; [4] ] &#124;> List.reduce (@)`
    |'
  prefs: []
  type: TYPE_TB
- en: You can see that `reduce` can be thought of as inserting the specified operation
    between each element of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the last example, the input to `reduce` is a list of lists, and
    the output is a single list. Make sure you understand why this is.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of associativity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the pairwise combinations can be done in any order, that opens up some interesting
    implementation techniques, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Divide and conquer algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incrementalism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are deep topics, but let's have a quick look!
  prefs: []
  type: TYPE_NORMAL
- en: '**Divide and conquer algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the task of summing the first 8 integers; how could we implement this?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way would be a crude step-by-step sum, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But because the sums can be done in any order, we could also implement the requirement
    by splitting the sum into two halves, like this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'and then we can recursively split the sums into sub-sums in the same way until
    we get down to the basic pairwise operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This "divide and conquer" approach may seem like overkill for something like
    a simple sum, but we'll see in a future post that, in conjunction with a `map`,
    it is the basis for some well known aggregation algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallelization**'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a divide and conquer strategy, it can be easily converted into
    a parallel algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to sum the first 8 integers on a four-core CPU, we might do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | Core 1 | Core 2 | Core 3 | Core 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Step 1 | `sum12 = 1 + 2` | `sum34 = 3 + 4` | `sum56 = 5 + 6` | `sum78 = 7
    + 8` |'
  prefs: []
  type: TYPE_TB
- en: '| Step 2 | `sum1234 = sum12 + sum34` | `sum5678 = sum56 + sum78` | (idle) |
    (idle) |'
  prefs: []
  type: TYPE_TB
- en: '| Step 3 | `sum1234 + sum5678` | (idle) | (idle) | (idle) |'
  prefs: []
  type: TYPE_TB
- en: There are still seven calculations that need to be done, but because we are
    doing it parallel, we can do them all in three steps.
  prefs: []
  type: TYPE_NORMAL
- en: Again, this might seem like a trivial example, but big data systems such as
    Hadoop are all about aggregating large amounts of data, and if the aggregation
    operation is a monoid, then you can, in theory, easily scale these aggregations
    by using multiple machines*.
  prefs: []
  type: TYPE_NORMAL
- en: '*[In practice, of course, the devil is in the details, and real-world systems
    don''t work exactly this way.]'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incrementalism**'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you do not need parallelism, a nice property of monoids is that they
    support incremental calculations.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say you have asked me to calculate the sum of one to five.
    Then of course I give you back the answer fifteen.
  prefs: []
  type: TYPE_NORMAL
- en: But now you say that you have changed your mind, and you want the sum of one
    to *six* instead. Do I have to add up all the numbers again, starting from scratch?
    No, I can use the previous sum, and just add six to it incrementally. This is
    possible because integer addition is a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, when faced with a sum like `1 + 2 + 3 + 4 + 5 + 6`, I can group the
    numbers any way I like. In particular, I can make an incremental sum like this:
    `(1 + 2 + 3 + 4 + 5) + 6`, which then reduces to `15 + 6`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, recalculating the entire sum from scratch might not be a big deal,
    but consider a real-world example like web analytics, counting the number of visitors
    over the last 30 days, say. A naive implementation might be to calculate the numbers
    by parsing the logs of the last 30 days data. A more efficient approach would
    be to recognize that the previous 29 days have not changed, and to only process
    the incremental changes for one day. As a result, the parsing effort is greatly
    reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you had a word count of a 100 page book, and you added another
    page, you shouldn't need to parse all 101 pages again. You just need to count
    the words on the last page and add that to the previous total.*
  prefs: []
  type: TYPE_NORMAL
- en: '[Technically, these are scary sounding *monoid homomorphisms*. I will explain
    what this is in the next post.]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of identity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having an identity element is not always required. Having a closed, associative
    operation (i.e. a semigroup) is sufficient to do many useful things.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in some cases, it is not enough. For example, here are some cases that
    might crop up:'
  prefs: []
  type: TYPE_NORMAL
- en: How can I use `reduce` on an empty list?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If I am designing a divide and conquer algorithm, what should I do if one of
    the "divide" steps has nothing in it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using an incremental algorithm, what value should I start with when I have
    no data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all cases we need a "zero" value. This allows us to say, for example, that
    the sum of an empty list is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the first point above, if we are concerned that the list might be
    empty, then we must replace `reduce` with `fold`, which allows an initial value
    to be passed in. (Of course, `fold` can be used for more things than just monoid
    operations.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are `reduce` and `fold` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using a "zero" can result in counter-intuitive results sometimes. For example,
    what is the *product* of an empty list of integers?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is `1`, not `0` as you might expect! Here''s the code to prove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary of the benefits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To sum up, a monoid is basically a way to describe an aggregation pattern --
    we have a list of things, we have some way of combining them, and we get a single
    aggregated object back at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or in F# terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So when you are designing code, and you start using terms like "sum", "product",
    "composition", or "concatenation", these are clues that you are dealing with a
    monoid.
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand what a monoid is, let's see how they can be used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next post in this series, we'll look at how you might write real code
    that implements the monoid "pattern".
  prefs: []
  type: TYPE_NORMAL
- en: Monoids in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monoids in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [previous post](monoids-without-tears.html), we looked at the definition
    of a monoid. In this post, we'll see how to implement some monoids.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s revisit the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: You start with a bunch of things, *and* some way of combining them two at a
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 1 (Closure)**: The result of combining two things is always another
    one of the things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2 (Associativity)**: When combining more than two things, which pairwise
    combination you do first doesn''t matter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 3 (Identity element)**: There is a special thing called "zero" such
    that when you combine any thing with "zero" you get the original thing back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if strings are the things, and string concatenation is the operation,
    then we have a monoid. Here''s some code that demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: But now let's try to apply this to a more complicated object.
  prefs: []
  type: TYPE_NORMAL
- en: Say that we have have an `OrderLine`, a little structure that represents a line
    in a sales order, say.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And then perhaps we might want to find the total for an order, that is, we want
    to sum the `Total` field for a list of lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard imperative approach would be to create a local `total` variable,
    and then loop through the lines, summing as we go, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But of course, being an experienced functional programmer, you would sneer
    at this, and use `fold` in `calculateOrderTotal` instead, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. Now let's look at a solution using a monoid approach.
  prefs: []
  type: TYPE_NORMAL
- en: For a monoid, we need to define some sort of addition or combination operation.
    How about something like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But this is no good, because we forgot a key aspect of monoids. The addition
    must return a value of the same type!
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the signature for the `addLine` function...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '...we can see that the return type is `float` not `OrderLine`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is return a whole other `OrderLine`. Here''s a correct implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the signature is correct: `addLine : OrderLine -> OrderLine -> OrderLine`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that because we have to return the entire structure we have to specify
    something for the `ProductCode` and `Qty` as well, not just the total. The `Qty`
    is easy, we can just do a sum. For the `ProductCode`, I decided to use the string
    "TOTAL", because we don't have a real product code we can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give this a little test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*NOTE: For more on the printf formatting options used, see the post on [printf
    here](printf.html).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s apply this to a list using `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At first, this might seem like extra work, and just to add up a total. But note
    that we now have more information than just the total; we also have the sum of
    the qtys as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can easily reuse the `printLine` function to make a simple
    receipt printing function that includes the total, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Which gives an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: More importantly, we can now use the incremental nature of monoids to keep a
    running subtotal that we update every time a new line is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We could even define a custom operator such as `++` so that we can add lines
    together naturally as it they were numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can see that using the monoid pattern opens up a whole new way of thinking.
    You can apply this "add" approach to almost any kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, what would a product "plus" a product look like? Or a customer
    "plus" a customer? Let your imagination run wild!
  prefs: []
  type: TYPE_NORMAL
- en: Are we there yet?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that we not quite done yet. There is a third requirement
    for a monoid that we haven't discussed yet -- the zero or identity element.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the requirement means that we need some kind of `OrderLine` such
    that adding it to another order line would leave the original untouched. Do we
    have such a thing?
  prefs: []
  type: TYPE_NORMAL
- en: Right now, no, because the addition operation always changes the product code
    to "TOTAL". What we have right now is in fact a *semigroup*, not a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a semigroup is perfectly useable. But a problem would arise
    if we had an empty list of lines and we wanted to total them. What should the
    result be?
  prefs: []
  type: TYPE_NORMAL
- en: One workaround would be to change the `addLine` function to ignore empty product
    codes. And then we could use an order line with an empty code as the zero element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then test that identity works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This does seem a bit hacky, so I wouldn't recommend this technique in general.
    There's another way to get an identity that we'll be discussing later.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a special total type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example above, the `OrderLine` type was very simple and it was easy to
    overload the fields for the total.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what would happen if the `OrderLine` type was more complicated? For example,
    if it had a `Price` field as well, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now we have introduced a complication. What should we set the `Price` to when
    we combine two lines? The average price? No price?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Neither seems very satisfactory.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we don't know what to do probably means that our design is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Really, we only need a subset of the data for the total, not all of it. How
    can we represent this?
  prefs: []
  type: TYPE_NORMAL
- en: With a discriminated union of course! One case can be used for product lines,
    and the other case can be used for totals only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This design is much nicer. We now have a special structure just for totals and
    we don't have to use contortions to make the excess data fit. We can even remove
    the dummy "TOTAL" product code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note that I named the "total" field differently in each record. Having unique
    field names like this means that you don''t have to always specify the type explicitly.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the addition logic is more complicated now, as we have to handle
    every combination of cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that we cannot just return the `TotalLine` value. We have to wrap in the
    `Total` case to make a proper `OrderLine`. If we didn't do that, then our `addLine`
    would have the signature `OrderLine -> OrderLine -> TotalLine`, which is not correct.
    We have to have the signature `OrderLine -> OrderLine -> OrderLine` -- nothing
    else will do!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have two cases, we need to handle both of them in the `printLine`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But once we have done this, we can now use addition just as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Identity again
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, we haven't dealt with the identity requirement. We could try using the
    same trick as before, with a blank product code, but that only works with the
    `Product` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a proper identity, we really need to introduce a *third* case, `EmptyOrder`
    say, to the union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With this extra case available, we rewrite the `addLine` function to handle
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using the built in List.sum function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out that the `List.sum` function knows about monoids! If you tell it
    what the addition operation is, and what the zero is, then you can use `List.sum`
    directly rather than `List.fold`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way you do this is by attaching two static members, `+` and `Zero` to your
    type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once this has been done, you can use `List.sum` and it will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that for this to work you mustn't already have a method or case called
    `Zero`. If I had used the name `Zero` instead of `EmptyOrder` for the third case
    it would not have worked.
  prefs: []
  type: TYPE_NORMAL
- en: Although this is a neat trick, in practice I don't think it is a good idea unless
    you are defining a proper math-related type such as `ComplexNumber` or `Vector`.
    It's a bit too clever and non-obvious for my taste.
  prefs: []
  type: TYPE_NORMAL
- en: If you *do* want to use this trick, your `Zero` member cannot be an extension
    method -- it must be defined with the type.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the code below, I'm trying to define the empty string as the
    "zero" for strings.
  prefs: []
  type: TYPE_NORMAL
- en: '`List.fold` works because `String.Zero` is visible as an extension method in
    this code right here, but `List.sum` fails because the extension method is not
    visible to it.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Mapping to a different structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having two different cases in a union might be acceptable in the order line
    case, but in many real world cases, that approach is too complicated or confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a customer record like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How would we "add" two of these customers?
  prefs: []
  type: TYPE_NORMAL
- en: A helpful tip is to realize that aggregation really only works for numeric and
    similar types. Strings can't really be aggregated easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'So rather than trying to aggregate `Customer`, let''s define a separate class
    `CustomerStats` that contains all the aggregatable information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'All the fields in `CustomerStats` are numeric, so it is obvious how we can
    add two stats together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As always, the inputs and output of the `add` function must be the same type.
    We must have `CustomerStats -> CustomerStats -> CustomerStats`, not `Customer
    -> Customer -> CustomerStats` or any other variant.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, so far so good.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's say we have a collection of customers, and we want to get the aggregated
    stats for them, how should we do this?
  prefs: []
  type: TYPE_NORMAL
- en: We can't add the customers directly, so what we need to do is first convert
    each customer to a `CustomerStats`, and then add the stats up using the monoid
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note is that the `toStats` creates statistics for just one
    customer. We set the count to just 1. It might seem a bit strange, but it does
    make sense, because if there was just one customer in the list, that's what the
    aggregate stats would be.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to note is how the final aggregation is done. First we use
    `map` to convert the source type to a type that is a monoid, and then we use `reduce`
    to aggregate all the stats.
  prefs: []
  type: TYPE_NORMAL
- en: Hmmm.... `map` followed by `reduce`. Does that sound familiar to you?
  prefs: []
  type: TYPE_NORMAL
- en: Yes indeed, Google's famous MapReduce algorithm was inspired by this concept
    (although the details are somewhat different).
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, here are some simple exercises for you to check your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: What is the "zero" for `CustomerStats`? Test your code by using `List.fold`
    on an empty list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a simple `OrderStats` class and use it to aggregate the `OrderLine` type
    that we introduced at the beginning of this post.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoid Homomorphisms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've now got all the tools we need to understand something called a *monoid
    homomorphism*.
  prefs: []
  type: TYPE_NORMAL
- en: I know what you're thinking... Ugh! Not just one, but two strange math words
    at once!
  prefs: []
  type: TYPE_NORMAL
- en: But I hope that the word "monoid" is not so intimidating now. And "homomorphism"
    is another math word that is simpler than it sounds. It's just greek for "same
    shape" and it describes a mapping or function that keeps the "shape" the same.
  prefs: []
  type: TYPE_NORMAL
- en: What does that mean in practice?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we have seen that all monoids have a certain common structure. That is,
    even though the underlying objects can be quite different (integers, strings,
    lists, `CustomerStats`, etc.) the "monoidness" of them is the same. As George
    W. Bush once said, once you've seen one monoid, you've seen them all.
  prefs: []
  type: TYPE_NORMAL
- en: So a *monoid* homomorphism is a transformation that preserves an essential "monoidness",
    even if the "before" and "after" objects are quite different.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at a simple monoid homomorphism. It's the "hello
    world", the "fibonacci series", of monoid homomorphisms -- word counting.
  prefs: []
  type: TYPE_NORMAL
- en: Documents as a monoid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s say we have a type which represents text blocks, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course we can add two smaller text blocks to make a larger text block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of how adding works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Since you are now a expert, you will quickly recognize this as a monoid, with
    the zero obviously being `Text ""`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's say we are writing a book (such as [this one](https://leanpub.com/understandingfunctionalprogramming?utm_campaign=understandingfunctionalprogramming))
    and we want a word count to show how much we have written.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a very crude implementation, plus a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So we are writing away, and now we have produced three pages of text. How do
    we calculate the word count for the complete document?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, one way is to add the separate pages together to make a complete text
    block, and then apply the `wordCount` function to that text block. Here''s a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Word count via adding pages](monoid_h1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But everytime we finish a new page, we have to add all the text together and
    do the word count all over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'No doubt you can see that there is a better way of doing this. Instead of adding
    all the text together and then counting, get the word count for each page separately,
    and then add these counts up, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Word count via adding counts](monoid_h2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The second approach relies on the fact that integers (the counts) are themselves
    a monoid, and you can add them up to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: So the `wordCount` function has transformed an aggregation over "pages" into
    an aggregation over "counts".
  prefs: []
  type: TYPE_NORMAL
- en: 'The big question now: is `wordCount` a monoid homomorphism?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, pages (text) and counts (integers) are both monoids, so it certainly transforms
    one monoid into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the more subtle condition is: does it preserve the "shape"? That is, does
    the adding of the counts give the same answer as the adding of the pages?'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the answer is yes. So `wordCount` *is* a monoid homomorphism!
  prefs: []
  type: TYPE_NORMAL
- en: You might think that this is obvious, and that all mappings like this must be
    monoid homomorphisms, but we'll see an example later where this is not true.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of chunkability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of the monoid homomorphism approach is that it is *"chunkable"*.
  prefs: []
  type: TYPE_NORMAL
- en: Each map and word count is independent of the others, so we can do them separately
    and then add up the answers afterwards. For many algorithms, working on small
    chunks of data is much more efficient than working on large chunks, so if we can,
    we should exploit this whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: As a direct consequence of this chunkability, we get some of the benefits that
    we touched on in the previous post.
  prefs: []
  type: TYPE_NORMAL
- en: First, it is *incremental*. That is, as we add text to the last page, we don't
    have to recalculate the word counts for all the previous pages, which might save
    some time.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it is *parallelizable*. The work for each chunk can be done independently,
    on different cores or machines. Note that in practice, parallelism is much overrated.
    The chunkability into small pieces has a much greater effect on performance than
    parallelism itself.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing word count implementations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're now ready to create some code that will demonstrate these two different
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the basic definitions from above, except that I will change
    the word count to use regular expressions instead of `split`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll create a page with 1000 words in it, and a document with 1000 pages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We'll want to time the code to see if there is any difference between the implementations.
    Here's a little helper function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Ok, let's implement the first approach. We'll add all the pages together using
    `addText` and then do a word count on the entire million word document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For the second approach, we'll do `wordCount` on each page first, and then add
    all the results together (using `reduce` of course).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have only changed two lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: 'In `wordCountViaAddText` we had:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And in `wordCountViaMap` we have basically swapped these lines. We now do `wordCount`
    *first* and then `reduce` afterwards, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's see what difference parallelism makes. We'll use the built-in
    `Array.Parallel.map` instead of `List.map`, which means we'll need to convert
    the list into an array first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: I hope that you are following along with the implementations, and that you understand
    what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the results for the different implementations running on my 4 core
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We must recognize that these are crude results, not a proper performance profile.
    But even so, it is very obvious that the map/reduce version is about 10 times
    faster that the `ViaAddText` version.
  prefs: []
  type: TYPE_NORMAL
- en: This is the key to why monoid homomorphisms are important -- they enable a "divide
    and conquer" strategy that is both powerful and easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, you could argue that the algorithms used are very inefficient. String
    concat is a terrible way to accumulate large text blocks, and there are much better
    ways of doing word counts. But even with these caveats, the fundamental point
    is still valid: by swapping two lines of code, we got a huge performance increase.'
  prefs: []
  type: TYPE_NORMAL
- en: And with a little bit of hashing and caching, we would also get the benefits
    of incremental aggregation -- only recalculating the minimum needed as pages change.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the parallel map didn't make that much difference in this case, even
    though it did use all four cores. Yes, we did add some minor expense with `toArray`
    but even in the best case, you might only get a small speed up on a multicore
    machine. To reiterate, what really made the most difference was the divide and
    conquer strategy inherent in the map/reduce approach.
  prefs: []
  type: TYPE_NORMAL
- en: A non-monoid homomorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned earlier that not all mappings are necessarily monoid homomorphisms.
    In this section, we'll look at an example of one that isn't.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, rather than using counting words, we're going to return the
    most frequent word in a text block.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the basic code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `mostFrequentWord` function is bit more complicated than the previous `wordCount`
    function, so I'll take you through it step by step.
  prefs: []
  type: TYPE_NORMAL
- en: First, we use a regex to match all non-whitespace. The result of this is a `MatchCollection`
    not a list of `Match`, so we have to explicitly cast it into a sequence (an `IEnumerable<Match>`
    in C# terms).
  prefs: []
  type: TYPE_NORMAL
- en: Next we convert each `Match` into the matched word, using `ToString()`. Then
    we group by the word itself, which gives us a list of pairs, where each pair is
    a `(word,list of words)`. We then turn those pairs into `(word,list count)` and
    then sort descending (using the negated word count).
  prefs: []
  type: TYPE_NORMAL
- en: Finally we take the first pair, and return the first part of the pair. This
    is the most frequent word.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, let's continue, and create some pages and a document as before. This time
    we're not interested in performance, so we only need a few pages. But we do want
    to create *different* pages. We'll create one containing nothing but "hello world",
    another containing nothing but "goodbye world", and a third containing "foobar".
    (Not a very interesting book IMHO!)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It is obvious that, with respect to the entire document, "world" is the most
    frequent word overall.
  prefs: []
  type: TYPE_NORMAL
- en: So let's compare the two approaches as before. The first approach will combine
    all the pages and then apply `mostFrequentWord`, like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![mostFrequentWord via adding pages](monoid_non_h1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second approach will do `mostFrequentWord` separately on each page and
    then combine the results, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![mostFrequentWord via adding counts](monoid_non_h2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Can you see what happened? The first approach was correct. But the second approach
    gave a completely wrong answer!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The second approach just concatenated the most frequent words from each page.
    The result is a new string that was not on *any* of the pages. A complete fail!
  prefs: []
  type: TYPE_NORMAL
- en: What went wrong?
  prefs: []
  type: TYPE_NORMAL
- en: Well, strings *are* a monoid under concatenation, so the mapping transformed
    a monoid (Text) to another monoid (string).
  prefs: []
  type: TYPE_NORMAL
- en: But the mapping did not preserve the "shape". The most frequent word in a big
    chunk of text cannot be derived from the most frequent words in smaller chunks
    of text. In other words, it is not a proper monoid homomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a monoid homomorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at these two different examples again to understand what the distinction
    is between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the word count example, we got the *same* final result whether we added
    the blocks and then did the word count, or whether we did the word counts and
    then added them together. Here''s a diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![word count both ways](monoid_h1_both.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But for the most frequent word example, we did *not* get the same answer from
    the two different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: '![most frequent word both ways](monoid_non_h1_both.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In other words, for `wordCount`, we had
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'But for `mostFrequentWord`, we had:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'So this brings us to a slightly more precise definition of a monoid homomorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Alas, then, `mostFrequentWord` is not a monoid homomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: That means that if we want to calculate the `mostFrequentWord` on a large number
    of text files, we are sadly forced to add all the text together first, and we
    can't benefit from a divide and conquer strategy.
  prefs: []
  type: TYPE_NORMAL
- en: '... or can we? Is there a way to turn `mostFrequentWord` into a proper monoid
    homomorphism? Stay tuned!'
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only dealt with things that are proper monoids. But what if
    the thing you want to work with is *not* a monoid? What then?
  prefs: []
  type: TYPE_NORMAL
- en: In the next post in this series, I'll give you some tips on converting almost
    anything into a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also fix up the `mostFrequentWord` example so that it is a proper monoid
    homomorphism, and we'll revisit the thorny problem of zeroes, with an elegant
    approach for creating them.
  prefs: []
  type: TYPE_NORMAL
- en: See you then!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are interested in using monoids for data aggregation, there are lots
    of good discussions in the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter's [Algebird library](https://blog.twitter.com/2012/scalding-080-and-algebird)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most [probabilistic data structures](http://highlyscalable.wordpress.com/2012/05/01/probabilistic-structures-web-analytics-data-mining/)
    are monoids.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gaussian distributions form a monoid](http://izbicki.me/blog/gausian-distributions-are-monoids).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google's [MapReduce Programming Model](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.5859&rep=rep1&type=pdf)
    (PDF).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Monoidify! Monoids as a Design Principle for Efficient MapReduce Algorithms](http://arxiv.org/abs/1304.7544)
    (PDF).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinkedIn's [Hourglass libary for Hadoop](http://www.slideshare.net/matthewterencehayes/hourglass-27038297)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From Stack Exchange: [What use are groups, monoids, and rings in database computations?](http://cs.stackexchange.com/questions/9648/what-use-are-groups-monoids-and-rings-in-database-computations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to get a bit more technical, here is a detailed study of monoids
    and semigroups, using graphics diagrams as the domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Monoids: Theme and Variations](http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf)
    (PDF).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with non-monoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with non-monoids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous posts in [this series](understanding-monoids.html), we only
    dealt with things that were proper monoids.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the thing you want to work with is *not* a monoid? What then? Well,
    in this post, I'll give you some tips on converting almost anything into a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we'll be introduced to a number of important and common functional
    design idioms, such as preferring lists rather than singletons, and using the
    option type at every opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you recall, for a proper monoid, we need three things to be true: closure,
    associativity, and identity. Each requirement can present a challenge, so we''ll
    discuss each in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with closure.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases you might want to add values together, but the type of the combined
    value is not the same as the type of the original values. How can you handle this?
  prefs: []
  type: TYPE_NORMAL
- en: One way is to just to map from the original type to a new type that *is* closed.
    We saw this approach used with the `Customer` and `CustomerStats` example in the
    previous post. In many cases, this is the easiest approach, because you don't
    have to mess with the design of the original types.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, sometimes you really don't want to use `map`, but instead
    want to design your type from the beginning so that it meets the closure requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, whether you are designing a new type or redesigning an existing
    type, you can use similar techniques to get closure.
  prefs: []
  type: TYPE_NORMAL
- en: Combining closed types to make new compound types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, we've seen that numeric types are closed under some basic math operations
    like addition and multiplication. We've also seen that some non-numeric types,
    like strings and lists, are closed under concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, it should be obvious that any combination of these types
    will be closed too. We just have to define the "add" function to do the appropriate
    "add" on the component types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `addMyType` function uses integer addition on the `int` field, and list
    concatenation on the `list` field. As a result the `MyType` is closed using the
    function `addMyType` -- in fact, not only is it closed, it is a monoid too. So
    in this case, we're done!
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the approach we took with `CustomerStats` in the [previous post](monoids-part2.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s my first tip:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN TIP: To easily create a monoidal type, make sure that each field of
    the type is also a monoid.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Question to think about: when you do this, what is the "zero" of the new compound
    type?'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with non-numeric types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The approach above works when creating compound types. But what about non-numeric
    types, which have no obvious numeric equivalent?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a very simple case. Say that you have some chars that you want to add
    together, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: But, a char plus a char is not another char. If anything, it is a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: But that is very unhelpful, as it does not meet the closure requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to fix this is to force the chars into strings, which does work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: But that is a specific solution for chars -- is there a more generic solution
    that will work for other types?
  prefs: []
  type: TYPE_NORMAL
- en: Well, think for a minute what the relationship of a `string` to a `char` is.
    A string can be thought of as a list or array of chars.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we could have used lists of chars instead, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This meets the closure requirement as well.
  prefs: []
  type: TYPE_NORMAL
- en: What's more, this is in fact a general solution to *any* problem like this,
    because *anything* can be put into a list, and lists (with concatenation) are
    always monoids.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s my next tip:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN TIP: To enable closure for a non-numeric type, replace single items
    with lists.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, you might need to convert to a list when setting up the monoid
    and then convert to another type when you are done.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `Char` case, you would do all your manipulation on lists
    of chars and then only convert to a string at the end.
  prefs: []
  type: TYPE_NORMAL
- en: So let's have a go at creating a "monoidal char" module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `MChar` is a wrapper around a list of chars, rather than a
    single char.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to get fancy we can use map/reduce to work on a set of chars, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Monoids for errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MonoidalChar` example is trivial, and could perhaps be implemented in other
    ways, but in general this is an extremely useful technique.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is a simple module for doing some validation. There are two
    options, `Success` and `Failure`, and the `Failure` case also has a error string
    associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In practice, we might perform multiple validations on a string, and we would
    like to return all the results at once, added together somehow.
  prefs: []
  type: TYPE_NORMAL
- en: This calls out for being a monoid! If we can add two results pairwise, then
    we can extend the operation to add as many results as we like!
  prefs: []
  type: TYPE_NORMAL
- en: So then the question is, how do we combine *two* validation results?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: A naive approach would be to concatenate the strings, but that wouldn't work
    if we were using format strings, or resource ids with localization, etc.
  prefs: []
  type: TYPE_NORMAL
- en: No, a better way is to convert the `Failure` case to use a *list* of strings
    instead of a single string. That will make combining results simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the same code as above, with the `Failure` case redefined to use a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the individual validations call `fail` with a single string,
    but behind the scenes it is being stored as a list of strings, which can, in turn,
    be concatenated together.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we can now create the `add` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic will be:'
  prefs: []
  type: TYPE_NORMAL
- en: If both results are `Success`, then the combined result is `Success`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one result is `Failure`, then the combined result is that failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both results are `Failure`, then the combined result is a `Failure` with
    both error lists concatenated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some tests to check the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a more realistic example, where we have a list of validation functions
    that we want to apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The output is a `Failure` with three error messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: One more thing is needed to finish up this monoid. We need a "zero" as well.
    What should it be?
  prefs: []
  type: TYPE_NORMAL
- en: By definition, it is something that when combined with another result, leaves
    the other result alone.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you can see that by this definition, "zero" is just `Success`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As you know, we would need to use zero if the list to reduce over is empty.
    So here's an example where we don't apply any validation functions at all, giving
    us an empty list of `ValidationResult`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note that we needed to change `reduce` to `fold` as well, otherwise we would
    get a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: Lists for performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's one more example of the benefit of using lists. Compared with other methods
    of combination, list concatenation is relatively cheap, both in computation and
    in memory use, because the objects being pointed to don't have to change or be
    reallocated.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous post, we defined a `Text` block that wrapped a
    string, and used string concatenation to add their contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: But for large strings this continual concatenation can be expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a different implementation, where the `Text` block contains a *list*
    of strings instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Almost no change in implementation, but performance will probably be greatly
    improved.
  prefs: []
  type: TYPE_NORMAL
- en: You can do all your manipulation on *lists* of strings and you need only convert
    to a normal string at the very end of the processing sequence.
  prefs: []
  type: TYPE_NORMAL
- en: And if lists aren't performant enough for you, you can easily extend this approach
    to use classic data structures like trees, heaps, etc. or mutable types like ResizeArray.
    (See the appendix on performance at the bottom of this post for some more discussion
    on this)
  prefs: []
  type: TYPE_NORMAL
- en: Jargon alert
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of using a list of objects as a monoid is common in mathematics,
    where it is called a ["free monoid"](http://en.wikipedia.org/wiki/Free_monoid).
    In computer science, it also called a ["Kleene star"](http://en.wikipedia.org/wiki/Kleene_star)
    such as `A*`. And if you don't allow empty lists, then you have no zero element.
    This variant is called a "free semigroup" or "Kleene plus" such as `A+`.
  prefs: []
  type: TYPE_NORMAL
- en: This "star" and "plus" notation will surely be familiar to you if you have ever
    used regular expressions.*
  prefs: []
  type: TYPE_NORMAL
- en: '[* You probably weren''t aware that there was a connection between regular
    expressions and monoids! There''s some even [deeper relationships too](http://scienceblogs.com/goodmath/2008/03/06/monoids-and-computation-syntac/).]'
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have dealt with closure, let's take on associativity.
  prefs: []
  type: TYPE_NORMAL
- en: We saw a couple of non-associative operations in the very first post, including
    subtraction and division.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `5 - (3 - 2)` is not equal to `(5 - 3) - 2`. This shows that
    subtraction is not associative, and also `12 / (3 / 2)` is not equal to `(12 /
    3) / 2`, which shows that division is not associative.
  prefs: []
  type: TYPE_NORMAL
- en: There's no single correct answer in these cases, because you might genuinely
    care about different answers depending on whether you work from left to right
    or right to left.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the F# standard libraries have two versions of `fold` and `reduce`
    to cater for each preference. The normal `fold` and `reduce` work left to right,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'But there is also `foldBack` and `reduceBack` that work from right to left,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In a sense, then, the associativity requirement is just a way of saying that
    you should get the *same* answer no matter whether you use `fold` or `foldBack`.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the operation into the element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But assuming that you *do* want a consistent monoidal approach, the trick in
    many cases is to move the operation into a property of each element. **Make the
    operation a noun, rather than a verb.**
  prefs: []
  type: TYPE_NORMAL
- en: For example `3 - 2` can be thought of as `3 + (-2)`. Rather than "subtraction"
    as a verb, we have "negative 2" as a noun.
  prefs: []
  type: TYPE_NORMAL
- en: In that case, the above example becomes `5 + (-3) + (-2)`. And since we are
    now using addition as the operator, we *do* have associativity, and `5 + (-3 +
    -2)` is indeed the same as `(5 + -3) + -2`.
  prefs: []
  type: TYPE_NORMAL
- en: A similar approach works with division. `12 / 3 / 2` can be converted into `12
    * (1/3) * (1/2)`, and now we are back to multiplication as the operator, which
    is associative.
  prefs: []
  type: TYPE_NORMAL
- en: This approach of converting the operator into a property of the element can
    be generalized nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s a tip:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN TIP: To get associativity for an operation, try to move the operation
    into the object.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can revisit an earlier example to understand how this works. If you recall,
    in the first post we tried to come up with a non-associative operation for strings,
    and settled on `subtractChars`.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a simple implementation of `subtractChars`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'With this implementation we can do some interactive tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can see for ourselves that the associativity requirement is violated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: How can we make this associative?
  prefs: []
  type: TYPE_NORMAL
- en: The trick is move the "subtract-ness" from the operator into the object, just
    as we did with the numbers earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'What I mean is that we replace the plain strings with a "subtract" or "chars
    to remove" data structure that captures what we want to remove, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we "apply" the data structure to the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we use this approach, we can rework the non-associative example above
    to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it is not exactly the same as the original code, but you might find that
    this is actually a better fit in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is below. We define a `CharsToRemove` to contain a set of
    chars, and the other function implementations fall out from that in a straightforward
    way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Let's test!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The way to think about this approach is that, in a sense, we are modelling *actions*
    rather than *data*. We have a list of `CharsToRemove` actions, then we combine
    them into a single "big" `CharsToRemove` action, and then we execute that single
    action at the end, after we have finished the intermediate manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see another example of this shortly, but you might be thinking at this
    point: "this sounds a bit like functions, doesn''t it?" To which I will say "yes,
    it does!"'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact rather than creating this `CharsToRemove` data structure, we could
    have just partially applied the original `subtractChars` function, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: (Note that we reverse the parameters to make partial application easier)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: And now we don't even need a special `applyTo` function.
  prefs: []
  type: TYPE_NORMAL
- en: But when we have more than one of these subtraction functions, what do we do?
    Each of these partially applied functions has signature `string -> string`, so
    how can we "add" them together?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The answer is function composition, of course!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This is the functional equivalent of creating the `CharsToRemove` data structure.
  prefs: []
  type: TYPE_NORMAL
- en: The "data structure as action" and function approach are not exactly the same
    -- the `CharsToRemove` approach may be more efficient, for example, because it
    uses a set, and is only applied to strings at the end -- but they both achieve
    the same goal. Which one is better depends on the particular problem you're working
    on.
  prefs: []
  type: TYPE_NORMAL
- en: I'll have more to say on functions and monoids in the next post.
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now to the last requirement for a monoid: identity.'
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, identity is not always needed, but it is nice to have if you
    might be dealing with empty lists.
  prefs: []
  type: TYPE_NORMAL
- en: For numeric values, finding an identity for an operation is generally easy,
    whether it be `0` (addition), `1` (multiplication) or `Int32.MinValue` (max).
  prefs: []
  type: TYPE_NORMAL
- en: And this carries over to structures that contain only numeric values as well
    -- just set all values to their appropriate identity. The `CustomerStats` type
    from the previous post demonstrates that nicely.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you have objects that are not numeric? How can you create a "zero"
    or identity element if there is no natural candidate?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is: *you just make one up*.'
  prefs: []
  type: TYPE_NORMAL
- en: Seriously!
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen an example of this in the previous post, when we added
    an `EmptyOrder` case to the `OrderLine` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at this more closely. We performed two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we created a new case and added it to the list of alternatives for an
    `OrderLine` (as shown above).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we adjusted the `addLine` function to take it into account (as shown
    below).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: The new, augmented type consists of the old order line cases, *plus* the new
    `EmptyOrder` case, and so it can reuse much of the behavior of the old cases.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, can you see that the new augmented type follows all the monoid
    rules?
  prefs: []
  type: TYPE_NORMAL
- en: A pair of values of the new type can be added to get another value of the new
    type (closure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the combination order didn't matter for the old type, then it still doesn't
    matter for the new type (associativity)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally... this extra case now gives us an identity for the new type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning PositiveNumber into a monoid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could do the same thing with the other semigroups we've seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we noted earlier that strictly positive numbers (under addition)
    didn''t have an identity; they are only a semigroup. If we wanted to create a
    zero using the "augmentation with extra case" technique (rather than just using
    `0`!) we would first define a special `Zero` case (not an integer), and then create
    an `addPositive` function that can handle it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Admittedly, `PositiveNumberOrIdentity` is a contrived example, but you can see
    how this same approach would work for any situation where you have "normal" values
    and a special, separate, zero value.
  prefs: []
  type: TYPE_NORMAL
- en: A generic solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few drawbacks to this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to deal with *two* cases now: the normal case and the zero case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to create custom types and custom addition functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, there's nothing you can do about the first issue. If you have
    a system with no natural zero, and you create an artificial one, then you will
    indeed always have to deal with two cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there *is* something you can do about the second issue! Rather than create
    a new custom type over and over, perhaps can we create a *generic* type that has
    two cases: one for all normal values and one for the artificial zero, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Does this type look familiar? It's just the **Option type** in disguise!
  prefs: []
  type: TYPE_NORMAL
- en: In other words, any time we need an identity which is outside the normal set
    of values, we can use `Option.None` to represent it. And then `Option.Some` is
    used for all the other "normal" values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another benefit of using `Option` is that we can also write a completely generic
    "add" function as well. Here''s a first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The logic is straightforward. If either option is `None`, the other option is
    returned. If both are `Some`, then they are unwrapped, added together, and then
    wrapped in a `Some` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the `+` in the last line makes assumptions about the types that we are
    adding. Better to pass in the addition function explicitly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: In practice, this would used with partial application to bake in the addition
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we have another important tip:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN TIP: To get identity for an operation, create a special case in a
    discriminated union, or, even simpler, just use Option.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PositiveNumber revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So here is the Positive Number example again, now using the `Option` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Much simpler!
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we pass in the "real" addition function as a parameter to `optionAdd`
    so that it is baked in. In other situations, you would do the same with the relevant
    aggregation function that is associated with the semigroup.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of this partial application, `addPositive` has the signature: `int
    option -> int option -> int option`, which is exactly what we would expect from
    a monoid addition function.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, `optionAdd` turns any function `'a -> 'a -> 'a` into the *same*
    function, but "lifted" to the option type, that is, having a signature `'a option
    -> 'a option -> 'a option` .
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s test it! Some test code might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: You can see that unfortunately we do have to wrap the normal values in `Some`
    in order to get the `None` as identity.
  prefs: []
  type: TYPE_NORMAL
- en: That sounds tedious but in practice, it is easy enough. The code below shows
    how we might handle the two distinct cases when summing a list. First how to sum
    a non-empty list, and then how to sum an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: ValidationResult revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s also revisit the `ValidationResult` type that we
    described earlier when talking about using lists to get closure. Here it is again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've got some insight into the positive integer case, let's look at
    this type from a different angle as well.
  prefs: []
  type: TYPE_NORMAL
- en: The type has two cases. One case holds data that we care about, and the other
    case holds no data. But the data we really care about are the error messages,
    not the success. As Leo Tolstoy nearly said "All validation successes are alike;
    each validation failure is a failure in its own way."
  prefs: []
  type: TYPE_NORMAL
- en: 'So, rather than thinking of it as a "Result", let''s think of the type as *storing
    failures*, and rewrite it like this instead, with the failure case first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Does this type appear familar now?
  prefs: []
  type: TYPE_NORMAL
- en: Yes! It's the option type again! Can we never get away from the darn thing?
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the option type, we can simplify the design of the `ValidationFailure`
    type to just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper to convert a string into the failure case is now just `Some` with
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'And the "add" function can reuse `optionAdd`, but this time with list concatenation
    as the underlying operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the "zero" that was the `Success` case in the original design now simply
    becomes `None` in the new design.
  prefs: []
  type: TYPE_NORMAL
- en: Here's all the code, plus tests
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Summary of the design tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's pause for a second and see what we have covered so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are all the design tips together:'
  prefs: []
  type: TYPE_NORMAL
- en: To easily create a monoidal type, make sure that each field of the type is also
    a monoid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable closure for a non-numeric type, replace single items with lists (or
    a similar data structure).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get associativity for an operation, try to move the operation into the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get identity for an operation, create a special case in a discriminated union,
    or, even simpler, just use Option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next two sections, we''ll apply these tips to two of the non-monoids
    that we have seen in previous posts: "average" and "most frequent word".'
  prefs: []
  type: TYPE_NORMAL
- en: 'A case study: Average'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now we have the toolkit that will enable us to deal with the thorny case
    of averages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple implementation of a pairwise average function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned briefly in the first post, `avg` fails on all three monoid requirements!
  prefs: []
  type: TYPE_NORMAL
- en: First, it is not closed. Two ints that are combined together using `avg` do
    not result in another int.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, even if it was closed, `avg` is not associative, as we can see by defining
    a similar float function `avgf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Finally, there is no identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'What number, when averaged with any other number, returns the original value?
    Answer: none!'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the design tips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So let's apply the design tips to see if they help us come up with a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '*To easily create a monoidal type, make sure that each field of the type is
    also a monoid.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, "average" is a mathematical operation, so we could expect that a monoidal
    equivalent would also be based on numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '*To enable closure for a non-numeric type, replace single items with lists.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This looks at first glance like it won't be relevant, so we'll skip this for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: '*To get associativity for an operation, try to move the operation into the
    object.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's the crux! How do we convert "average" from a verb (an operation) to a
    noun (a data structure)?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we create a structure that is not actually an average, but
    a "delayed average" -- everything you need to make an average on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we need a data structure with *two* components: a total, and a count.
    With these two numbers we can calculate an average as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The good thing about this, is that structure stores `ints`, not `floats`, so
    we don't need to worry about loss of precision or associativity of floats.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last tip is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*To get identity for an operation, create a special case in a discriminated
    union, or, even simpler, just use Option.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, the tip is not needed, as we can easily create a zero by setting
    the two components to be zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: We could also have used `None` for the zero, but it seems like overkill in this
    case. If the list is empty, the `Avg` result is valid, even though we can't do
    the division.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have had this insight into the data structure, the rest of the implementation
    follows easily. Here is all the code, plus some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, you can see that I created a `calcAvg` function that uses
    the `Avg` structure to calculate a (floating point) average. One nice thing about
    this approach is that we can delay having to make a decision about what to do
    with a zero divisor. We can just return `0`, or alternatively `None`, or we can
    just postpone the calculation indefinitely, and only generate the average at the
    last possible moment, on demand!
  prefs: []
  type: TYPE_NORMAL
- en: And of course, this implementation of "average" has the ability to do incremental
    averages. We get this for free because it is a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: That is, if I have already calculated the average of a million numbers, and
    I want to add one more, I don't have to recalculate everything, I can just add
    the new number to the totals so far.
  prefs: []
  type: TYPE_NORMAL
- en: A slight diversion on metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever been responsible for managing any servers or services, you
    will be aware of the importance of logging and monitoring metrics, such as CPU,
    I/O, etc.
  prefs: []
  type: TYPE_NORMAL
- en: One of the questions you often face then is how to design your metrics. Do you
    want kilobytes per second, or just total kilobytes since the server started. Visitors
    per hour, or total visitors?
  prefs: []
  type: TYPE_NORMAL
- en: If you look at some [guidelines when creating metrics](http://opentsdb.net/metrics.html)
    you will see the frequent recommendation to only track metrics that are *counters*,
    not *rates*.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of counters is that (a) missing data doesn't affect the big picture,
    and (b) they can be aggregated in many ways after the fact -- by minute, by hour,
    as a ratio with something else, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have worked through this series, you can see that the recommendation
    can really be rephrased as **metrics should be monoids**.
  prefs: []
  type: TYPE_NORMAL
- en: The work we did in the code above to transform "average" into two components,
    "total" and "count", is exactly what you want to do to make a good metric.
  prefs: []
  type: TYPE_NORMAL
- en: Averages and other rates are not monoids, but "total" and "count" are, and then
    "average" can be calculated from them at your leisure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case study: Turning "most frequent word" into a monoid homomorphism'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last post, we implemented a "most frequent word" function, but found
    that it wasn't a monoid homomorphism. That is,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'did *not* give the same result as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Again, we can use the design tips to fix this up so that it works.
  prefs: []
  type: TYPE_NORMAL
- en: The insight here is again to delay the calculation until the last minute, just
    as we did in the "average" example.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than calculating the most frequent word upfront then, we create a data
    structure that stores all the information that we need to calculate the most frequent
    word later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: In the code above we have a new function `wordFreq`, that returns a `Map<string,int>`
    rather just a single word. That is, we are now working with dictionaries, where
    each slot has a word and its associated frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a demonstration of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: With this map structure in place, we can create a function `addMap` to add two
    maps. It simply merges the frequency counts of the words from both maps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: And when we have combined all the maps together, we can then calculate the most
    frequent word by looping through the map and finding the word with the largest
    frequency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: So, here are the two scenarios revisited using the new approach.
  prefs: []
  type: TYPE_NORMAL
- en: The first scenario combines all the pages into a single text, then applies `wordFreq`
    to get a frequency map, and applies `mostFrequentWord` to get the most frequent
    word.
  prefs: []
  type: TYPE_NORMAL
- en: The second scenario applies `wordFreq` to each page separately to get a map
    for each page. These maps are then combined with `addMap` to get a single global
    map. Then `mostFrequentWord` is applied as the last step, as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you will see that you now get the *same* answer.
  prefs: []
  type: TYPE_NORMAL
- en: This means that `wordFreq` is indeed a monoid homomorphism, and is suitable
    for running in parallel, or incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: Next time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen a lot of code in this post, but it has all been focused on data structures.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is nothing in the definition of a monoid that says that the things
    to be combined have to be data structures -- they could be *anything at all*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next post we'll look at monoids applied to other objects, such as types,
    functions, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: On Performance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples above, I have made frequent use of `@` to "add" two lists in
    the same way that `+` adds two numbers. I did this to highlight the analogies
    with other monoidal operations such as numeric addition and string concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that it is clear that the code samples above are meant to be teaching
    examples, not necessarily good models for the kind of real-world, battle-hardened,
    and all-too-ugly code you need in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of people have pointed out that using List append (`@`) should be avoided
    in general. This is because the entire first list needs to be copied, which is
    not very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: By far the best way to add something to a list is to add it to the front using
    the so-called "cons" mechanism, which in F# is just `::`. F# lists are implemented
    as linked lists, so adding to the front is very cheap.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with using this approach is that it is not symmetrical -- it doesn't
    add two lists together, just a list and an element. This means that it cannot
    be used as the "add" operation in a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't need the benefits of a monoid, such as divide and conquer, then
    that is a perfectly valid design decision. No need to sacrifice performance for
    a pattern that you are not going to benefit from.
  prefs: []
  type: TYPE_NORMAL
- en: The other alternative to using `@` is to not use lists in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `ValidationResult` design, I used a list to hold the error results so
    that we could get easy accumulation of the results. But I only chose the `list`
    type because it is really the default collection type in F#. I could have equally
    well have chosen sequences, or arrays, or sets. Almost any other collection type
    would have done the job just as well.
  prefs: []
  type: TYPE_NORMAL
- en: But not all types will have the same performance. For example, combining two
    sequences is a lazy operation. You don't have to copy all the data; you just enumerate
    one sequence, then the other. So that might be faster perhaps?
  prefs: []
  type: TYPE_NORMAL
- en: Rather than guessing, I wrote a little test script to measure performance at
    various list sizes, for various collection types.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have chosen a very simple model: we have a list of objects, each of which
    is a collection containing *one* item. We then reduce this list of collections
    into a single giant collection using the appropriate monoid operation. Finally,
    we iterate over the giant collection once.'
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to the `ValidationResult` design, where we would combine
    all the results into a single list of results, and then (presumably) iterate over
    them to show the errors.
  prefs: []
  type: TYPE_NORMAL
- en: It is also similar to the "most frequent word" design, above, where we combine
    all the individual frequency maps into a single frequency map, and then iterate
    over it to find the most frequent word. In that case, of course, we were using
    `map` rather than `list`, but the set of steps is the same.
  prefs: []
  type: TYPE_NORMAL
- en: A performance experiment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ok, here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the code quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: The `time` function times the reduce and iteration steps. It deliberately does
    not test how long it takes to create the collection. I do perform a GC before
    starting, but in reality, the memory pressure that a particular type or algorithm
    causes is an important part of the decision to use it (or not). [Understanding
    how GC works](https://www.simple-talk.com/dotnet/.net-framework/5-tips-and-techniques-for-avoiding-automatic-gc-collections/)
    is an important part of getting performant code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `testListPerformance` function sets up the list of collections (lists in
    this case) and also the `reduce` and `iter` functions. It then runs the timer
    on `reduce` and `iter`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other functions do the same thing, but with sequences, arrays, and ResizeArrays
    (standard .NET Lists). Out of curiosity, I thought I'd test two ways of merging
    sequences, one using the standard library function `Seq.append` and the other
    using two `yield!`s in a row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `testResizeArrayPerformance` uses ResizeArrays and adds the right list to
    the left one. The left one mutates and grows larger as needed, using a [growth
    strategy](http://stackoverflow.com/questions/1665298/listt-and-arraylist-default-capacity/1665325#1665325)
    that keeps inserts efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's write code to check the performance on various sized lists. I chose
    to start with a count of 2000 and move by increments of 4000 up to 50000.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: I won't list all the detailed output -- you can run the code for yourself --
    but here is a chart of the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![monoid performance](monoid_performance.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The two sequence-based examples crashed with stack overflows. The `yield!` was
    about 30% faster than `Seq.append`, but also ran out of stack faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List.append didn't run out of stack, but got much slower as the lists got larger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array.append was fast, and increases more slowly with the size of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ResizeArray was fastest of all, and didn't break a sweat even with large lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the three collection types that didn''t crash, I also timed them for a
    list of 100K items. The results were:'
  prefs: []
  type: TYPE_NORMAL
- en: List = 150,730 ms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array = 26,062 ms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ResizeArray = 33 ms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clear winner there, then.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What conclusion can we draw from this little experiment?
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you might have all sorts of questions, such as: Were you running in
    debug or release mode? Did you have optimization turned on? What about using parallelism
    to increase performance? And no doubt, there will be comments saying "why did
    you use technique X, technique Y is so much better".'
  prefs: []
  type: TYPE_NORMAL
- en: 'But here''s the conclusion I would like to make:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You cannot draw any conclusion from these results!**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every situation is different and requires a different approach:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with small data sets you might not care about performance
    anyway. In this case I would stick with lists -- I'd rather not sacrifice pattern
    matching and immutability unless I have to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance bottleneck might not be in the list addition code. There is
    no point working on optimizing the list addition if you are actually spending
    all your time on disk I/O or network delays. A real-world version of the word
    frequency example might actually spend most of its time doing reading from disk,
    or parsing, rather than adding lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you working at the scale of Google, Twitter, or Facebook, you really need
    to go and hire some algorithm experts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only principles that we can take away from any discussion on optimization
    and performance are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A problem must be dealt with in its own context.** The size of the data being
    processed, the type of hardware, the amount of memory, and so on. All these will
    make a difference to your performance. What works for me may not work for you,
    which is why...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You should always measure, not guess.** Don''t make assumptions about where
    your code is spending its time -- learn to use a profiler! There are some good
    examples of using a profiler [here](http://moiraesoftware.com/blog/2012/07/15/the-lurking-horror/)
    and [here](http://moiraesoftware.com/blog/2011/12/11/fixing-a-hole/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be wary of micro-optimizations**. Even if your profiler shows that your sorting
    routine spends all its time in comparing strings, that doesn''t necessarily mean
    that you need to improve your string comparison function. You might be better
    off improving your algorithm so that you don''t need to do so many comparisons
    in the first place. [Premature optimization](http://programmers.stackexchange.com/a/79954/44643)
    and all that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
