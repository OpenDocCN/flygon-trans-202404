- en: The "Understanding monoids" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '"理解幺半群" 系列'
- en: In this series, we'll look at a very common "pattern" known as a *monoid*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们将看一种非常常见的“模式”，称为*幺半群*。
- en: Monoids are not really a design pattern; more an approach to working with many
    different types of values in a common way. In fact, once you understand monoids,
    you will start seeing them everywhere!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群实际上并不是一种设计模式；更多是一种以共同方式处理许多不同类型值的方法。事实上，一旦你理解了幺半群，你会发现它们无处不在！
- en: '[Monoids without tears](monoids-without-tears.html). A mostly mathless discussion
    of a common functional pattern.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[无泪的幺半群](monoids-without-tears.html)。一个关于常见函数模式的几乎没有数学的讨论。'
- en: '[Monoids in practice](monoids-part2.html). Monoids without tears - Part 2.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实践中的幺半群](monoids-part2.html)。无泪的幺半群 - 第2部分。'
- en: '[Working with non-monoids](monoids-part3.html). Monoids without tears - Part
    3.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[处理非幺半群](monoids-part3.html)。无泪的幺半群 - 第3部分。'
- en: Monoids without tears
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无泪的幺半群
- en: Monoids without tears
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无泪的幺半群
- en: If you are coming from an OO background, one of the more challenging aspects
    of learning functional programming is the lack of obvious design patterns. There
    are plenty of idioms such as [partial application](partial-application.html),
    and [error handling techniques](recipe-part2.html), but no apparent patterns in
    the [GoF sense](http://en.wikipedia.org/wiki/Design_Patterns).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自面向对象的背景，学习函数式编程中更具挑战性的方面之一是缺乏明显的设计模式。有许多习语，如[部分应用](partial-application.html)，和[错误处理技术](recipe-part2.html)，但在[GoF意义上](http://en.wikipedia.org/wiki/Design_Patterns)没有明显的模式。
- en: In this post, we'll look at a very common "pattern" known as a *monoid*. Monoids
    are not really a design pattern; more an approach to working with many different
    types of values in a common way. In fact, once you understand monoids, you will
    start seeing them everywhere!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将看一种非常常见的“模式”，称为*幺半群*。幺半群实际上并不是一种设计模式；更多是一种以共同方式处理许多不同类型值的方法。事实上，一旦你理解了幺半群，你会发现它们无处不在！
- en: Unfortunately the term "monoid" itself is a bit off-putting. It originally comes
    from [mathematics](http://en.wikipedia.org/wiki/Monoid) but the concept as applied
    to programming is easy to grasp without any math at all, as I hope to demonstrate.
    In fact, if we were to name the concept today in a programming context, we might
    call it something like `ICombinable` instead, which is not nearly as scary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，“幺半群”这个术语本身有点令人望而生畏。它最初来自[数学](http://en.wikipedia.org/wiki/Monoid)，但作为编程中的概念，即使没有任何数学，也很容易理解，我希望能够证明。事实上，如果今天在编程上下文中给这个概念命名，我们可能会称其为`ICombinable`，这样就不会那么可怕了。
- en: Finally, you might be wondering if a "monoid" has any connection with a "monad".
    Yes, there is a mathematical connection between them, but in programming terms,
    they are very different things, despite having similar names.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能会想知道“幺半群”与“单子”是否有任何联系。是的，它们之间存在数学联系，但在编程术语中，尽管它们有相似的名称，但它们是非常不同的东西。
- en: Uh-oh... some equations
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哎呀... 一些方程式
- en: On this site, I generally don't use any math, but in this case I'm going to
    break my self-imposed rule and show you some equations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网站上，我通常不使用任何数学，但在这种情况下，我打破了自己设定的规则，向你展示一些方程式。
- en: 'Ready? Here''s the first one:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了吗？这是第一个：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Could you handle that? How about another one?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你能应对吗？再来一个？
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And finally one more...
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后再说一句...
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ok! We're done! If you can understand these equations, then you have all the
    math you need to understand monoids.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们完成了！如果你能理解这些方程式，那么你已经掌握了理解幺半群所需的所有数学知识。
- en: Thinking like a mathematician
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思考如数学家
- en: '*"A mathematician, like a painter or poet, is a maker of patterns. If his patterns
    are more permanent than theirs, it is because they are made with ideas" -- G H
    Hardy*'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"数学家，像画家或诗人一样，是一种模式的创造者。如果他的模式比他们的更持久，那是因为它们是用思想创造的" -- G H Hardy*'
- en: Most people imagine that mathematicians work with numbers, doing complicated
    arithmetic and calculus.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人想象数学家处理数字，进行复杂的算术和微积分。
- en: This is a misconception. For example, if you look at [typical high-level](http://terrytao.wordpress.com/2013/07/27/an-improved-type-i-estimate/)
    [math discussions](http://books.google.co.uk/books?id=VOCQUC_uiWgC&pg=PA102),
    you will see lots of strange words, and lots of letter and symbols, but not a
    lot of arithmetic.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个误解。例如，如果你看一下[典型的高级别](http://terrytao.wordpress.com/2013/07/27/an-improved-type-i-estimate/)
    [数学讨论](http://books.google.co.uk/books?id=VOCQUC_uiWgC&pg=PA102)，你会看到很多奇怪的词语，很多字母和符号，但没有太多算术。
- en: One of the things that mathematicians *do* do though, is try to find patterns
    in things. "What do these things have in common?" and "How can we generalize these
    concepts?" are typical mathematical questions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家们做的事情之一是尝试找出事物中的模式。"这些事物有什么共同点？"和"我们如何概括这些概念？"是典型的数学问题。
- en: So let's look at these three equations through a mathematician's eyes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们通过数学家的眼睛来看这三个方程式。
- en: Generalizing the first equation
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推广第一个方程式
- en: 'A mathematician would look at `1 + 2 = 3` and think something like:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数学家会看到`1 + 2 = 3`并想到：
- en: We've got a bunch of things (integers in this case)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一堆东西（在这种情况下是整数）
- en: We've got some way of combining two of them (addition in this case)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一种方法将其中两个结合在一起（在这种情况下是加法）
- en: And the result is another one of these things (that is, we get another integer)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是这些东西中的另一个（也就是说，我们得到另一个整数）
- en: And then a mathematician might try to see if this pattern could be generalized
    to other kinds of things and operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后数学家可能会尝试看看这个模式是否可以推广到其他类型的事物和操作。
- en: Let's start by staying with integers as the "things". What other ways are there
    of combining integers? And do they fit the pattern?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以整数作为“东西”。还有哪些整数组合的方式？它们是否符合这个模式？
- en: Let's try multiplication, does that fit this pattern?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试乘法，它符合这个模式吗？
- en: The answer is yes, multiplication does fit this pattern because multiplying
    any two integers results in another integer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，乘法确实符合这个模式，因为任意两个整数相乘会得到另一个整数。
- en: What about division? Does that fit the pattern? The answer is no, because in
    most cases, dividing two integers results in a fraction, which is *not* an integer
    (I'm ignoring integer division).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除法呢？它符合这个模式吗？答案是否定的，因为在大多数情况下，两个整数相除会得到一个分数，这*不*是一个整数（我忽略了整数除法）。
- en: What about the `max` function? Does that fit the pattern? It combines two integers
    and returns one of them, so the answer is yes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`max`函数呢？���符合这个模式吗？它结合了两个整数并返回其中一个，所以答案是肯定的。'
- en: What about the `equals` function? It combines two integers but returns a boolean,
    not an integer, so the answer is no.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`函数呢？它结合了两个整数但返回一个布尔值，而不是一个整数，所以答案是否定的。'
- en: Enough of integers! What other kinds of things can we think of?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 足够了解整数！我们还能想到哪些其他类型的事物？
- en: Floats are similar to integers, but unlike integers, using division with floats
    does result in another float, so the division operation fits the pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数类似于整数，但与整数不同，使用浮点数进行除法确实会得到另一个浮点数，因此除法操作符符合这个模式。
- en: How about booleans? They can be combined using operators such as AND, OR and
    so on. Does `aBool AND aBool` result in another bool? Yes! And `OR` too fits the
    pattern.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值呢？它们可以使用AND、OR等运算符进行组合。`aBool AND aBool`会得到另一个布尔值吗？是的！`OR`也符合这个模式。
- en: Strings next. How can they be combined? One way is string concatenation, which
    returns another string, which is what we want. But something like the equality
    operation doesn't fit, because it returns a boolean.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是字符串。它们如何组合？一种方式是字符串连接，它返回另一个字符串，这正是我们想要的。但类似等式操作并不符合，因为它返回一个布尔值。
- en: Finally, let's consider lists. As for strings, the obvious way to combine them
    is with list concatenation, which returns another list and fits the pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑列表。对于字符串，显而易见的组合方式是列表连接，它返回另一个列表并符合这个模式。
- en: We can continue on like this for all sorts of objects and combining operations,
    but you should see how it works now.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这样做，对各种对象和组合操作，但你现在应该明白它是如何工作的。
- en: 'You might ask: why is it so important that the operation return another thing
    of the same type? The answer is that **you can chain together multiple objects
    using the operation**.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：为什么操作返回相同类型的另一个对象如此重要？答案是**你可以使用操作链接多个对象**。
- en: 'For example, because `1 + 2` is another integer, you can add 3 to it. And then
    because `1 + 2 + 3` is an integer as well, you can keep going and add say, 4,
    to the result. In other words, it is only because integer addition fits the pattern
    that you can write a sequence of additions like this: `1 + 2 + 3 + 4`. You couldn''t
    write `1 = 2 = 3 = 4` in the same way, because integer equality doesn''t fit the
    pattern.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，因为`1 + 2`是另一个整数，你可以再加上3。然后因为`1 + 2 + 3`也是一个整数，你可以继续加上比如说4。换句话说，只有因为整数加法符合这个模式，你才能写出这样的加法序列：`1
    + 2 + 3 + 4`。你无法以同样的方式写出`1 = 2 = 3 = 4`，因为整数相等不符合这个模式。
- en: And of course, the chain of combined items can be as long as we like. In other
    words, this pattern allows us to extend a pairwise operation into **an operation
    that works on lists**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，组合项目的链可以无限长。换句话说，这种模式允许我们将成对操作扩展为**适用于列表的操作**。
- en: Mathematicians call the requirement that "the result is another one of these
    things" the *closure* requirement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家将“结果仍是这些事物之一”的要求称为*闭包*要求。
- en: Generalizing the second equation
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推广第二个方程式
- en: Ok, what about the next equation, `1 + (2 + 3) = (1 + 2) + 3`? Why is that important?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，下一个方程式，`1 + (2 + 3) = (1 + 2) + 3`呢？这为什么重要？
- en: Well, if you think about the first pattern, it says we can build up a chain
    of operations such as `1 + 2 + 3`. But we have only got a pairwise operation.
    So what order should we do the combining in? Should we combine 1 and 2 first,
    then combine the result with 3? Or should we combine 2 and 3 first and then combine
    1 with that result? Does it make a difference?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，如果你思考第一个模式，它说我们可以建立一系列操作，比如`1 + 2 + 3`。但我们只有一个成对的操作。那么我们应该以什么顺序进行合并？我们应该先合并1和2，然后再将结果与3合并吗？还是应该先合并2和3，然后再将1与该结果合并？这有区别吗？
- en: That's where this second equation is useful. It says that, for addition, the
    order of combination doesn't matter. You get the same result either way.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这个第二个方程式有用的地方。它说，对于加法，组合的顺序不重要。无论哪种方式，你都会得到相同的结果。
- en: 'So for a chain of four items like this: `1 + 2 + 3 + 4`, we could start working
    from the left hand side: `((1+2) + 3) + 4` or from the right hand side: `1 + (2
    + (3+4))` or even do it in two parts and then combine them like this: `(1+2) +
    (3+4)`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的四项链：`1 + 2 + 3 + 4`，我们可以从左边开始工作：`((1+2) + 3) + 4`，或者从右边开始：`1 + (2 + (3+4))`，甚至可以分成两部分然后组合它们，就像这样：`(1+2)
    + (3+4)`。
- en: Let's see if this pattern applies to the examples we've already looked at.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种模式是否适用于我们已经查看过的例子。
- en: Again, let's start with other ways of combining integers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们从其他整数组合方式开始。
- en: We'll start with multiplication again. Does `1 * (2 * 3)` give the same result
    as `(1 * 2) * 3`? Yes. Just as with addition, the order doesn't matter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从乘法开始。`1 * (2 * 3)`与`(1 * 2) * 3`是否给出相同的结果？是的。就像加法一样，顺序不重要。
- en: Now let's try subtraction. Does `1 - (2 - 3)` give the same result as `(1 -
    2) - 3`? No. For subtraction, the order *does* matter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试减法。`1 - (2 - 3)`与`(1 - 2) - 3`是否给出相同的结果？不。对于减法，顺序很重要。
- en: What about division? Does `12 / (2 / 3)` give the same result as `(12 / 2) /
    3`? No. For division also, the order matters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除法呢？`12 / (2 / 3)`与`(12 / 2) / 3`是否给出相同的结果？不。对于除法，顺序也很重要。
- en: But the `max` function does work. `max( max(12,2), 3)` gives the same result
    as `max(12, max(2,3)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但`max`函数确实有效。`max( max(12,2), 3)`与`max(12, max(2,3))`给出相同的结果。
- en: What about strings and lists? Does concatenation meet the requirement? What
    do you think?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串和列表呢？连接是否满足要求？你觉得呢？
- en: Here's a question... Can we come up with an operation for strings that *is*
    order dependent?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个问题... 我们能想出一个对字符串有序的操作吗？
- en: 'Well, how about a function like "subtractChars" which removes all characters
    in the right string from the left string. So `subtractChars("abc","ab")` is just
    `"c"`. `subtractChars` is indeed order dependent, as you can see with a simple
    example: `subtractChars("abc", subtractChars("abc","abc"))` is not the same string
    as `subtractChars(subtractChars("abc","abc"),"abc")`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，像“subtractChars”这样的函数如何呢？它从左侧字符串中删除右侧字符串中的所有字符。因此`subtractChars("abc","ab")`就是`"c"`。`subtractChars`的确是有序的，你可以通过一个简单的例子看到：`subtractChars("abc",
    subtractChars("abc","abc"))`不是与`subtractChars(subtractChars("abc","abc"),"abc")`相同的字符串。
- en: Mathematicians call the requirement that "the order doesn't matter" the *associativity*
    requirement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家将“顺序不重要”要求称为*结合律*要求。
- en: '**Important Note:** When I say the "order of combining", I am talking about
    the order in which you do the pairwise combining steps -- combining one pair,
    and then combining the result with the next item.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要提示：**当我说“组合顺序”时，我指的是你执行成对组合步骤的顺序 -- 先组合一对，然后将结果与下一项组合。'
- en: But it is critical that the overall sequence of the items be left unchanged.
    This is because for certain operations, if you change the sequencing of the items,
    then you get a completely different result! `1 - 2` does not mean the same as
    `2 - 1` and `2 / 3` does not mean the same as `3 / 2`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但至关重要的是，项目的整体序列保持不变。这是因为对于某些操作，如果你改变项目的顺序，那么你会得到完全不同的结果！`1 - 2`的意思不同于`2 - 1`，`2
    / 3`的意思不同于`3 / 2`。
- en: Of course, in many common cases, the sequence order doesn't matter. After all,
    `1+2` is the same as `2+1`. In this case, the operation is said to be *commutative*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在许多常见情况下，序列顺序并不重要。毕竟，`1+2`和`2+1`是一样的。在这种情况下，操作被称为*可交换的*。
- en: The third equation
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三个方程
- en: Now let's look at the third equation, `1 + 0 = 1`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看第三个方程，`1 + 0 = 1`。
- en: 'A mathematician would say something like: that''s interesting -- there is a
    special kind of thing ("zero") that, when you combine it with something, just
    gives you back the original something, as if nothing had happened.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数学家会说类似于：这很有趣--有一种特殊的东西（“零”），当你将它与某物结合时，只会将原始的东西返回，就好像什么都没有发生过一样。
- en: So once more, let's revisit our examples and see if we can extend this "zero"
    concept to other operations and other things.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所以再次，让我们重新审视我们的例子，看看我们是否可以将这个“零”概念扩展到其他操作和其他事物上。
- en: Again, let's start with multiplication. Is there some value, such that when
    you multiply a number with it, you get back the original number?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们从乘法开始。是否存在某个值，使得当你将一个数字与它相乘时，你会得到原始数字？
- en: Yes, of course! The number one. So for multiplication, the number `1` is the
    "zero".
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，当然！数字一。所以对于乘法，数字`1`就是“零”。
- en: What about `max`? Is there a "zero" for that? For 32 bit ints, yes. Combining
    `System.Int32.MinValue` with any other 32 bit integer using `max` will return
    the other integer. That fits the definition of "zero" perfectly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`max`呢？它有一个“零”吗？对于32位整数，是的。使用`max`将`System.Int32.MinValue`与任何其他32位整数组合将返回另一个整数。这完全符合“零”的定义。'
- en: What about booleans combined using AND? Is there a zero for that? Yes. It is
    the value `True`. Why? Because `True AND False` is `False`, and `True AND True`
    is `True`. In both cases the other value is returned untouched.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 那么使用AND组合的布尔值呢？有一个零吗？有。它是值`True`。为什么？因为`True AND False`是`False`，而`True AND True`是`True`。在这两种情况下，另一个值都会原样返回。
- en: What about booleans combined using OR? Is there a zero for that as well? I'll
    let you decide.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么布尔值使用OR组合呢？那也有一个零吗？我会让你决定。
- en: Moving on, what about string concatenation? Is there a "zero" for this? Yes,
    indeed -- it is just the empty string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，字符串连接呢？这个有“零”吗？是的，确实--它就是空字符串。
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, for list concatenation, the "zero" is just the empty list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于列表连接，这个“零”就是空列表。
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that the "zero" value depends very much on the operation, not just
    on the set of things. The zero for integer addition is different from the "zero"
    for integer multiplication, which is different again from the from "zero" for
    `Max`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，“零”值在很大程度上取决于操作，不仅取决于事物��合。整数加法的零与整数乘法的“零”不同，而与`Max`的“零”又不同。
- en: Mathematicians call the "zero" the *identity element*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家将“零”称为*单位元素*。
- en: The equations revisited
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新审视的方程
- en: So now let's revisit the equations with our new generalizations in mind.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们以新的概括为基础重新审视方程。
- en: 'Before, we had:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们有：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But now we have something much more abstract, a set of generalized requirements
    that can apply to all sorts of things:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们有了一个更抽象的东西，一组可以适用于各种事物的概括要求：
- en: You start with a bunch of things, *and* some way of combining them two at a
    time.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你从一堆东西开始，*以及*一种两两组合它们的方式。
- en: '**Rule 1 (Closure)**: The result of combining two things is always another
    one of the things.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则1（封闭性）**：两个东西组合的结果总是另一个东西。'
- en: '**Rule 2 (Associativity)**: When combining more than two things, which pairwise
    combination you do first doesn''t matter.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则2（结合性）**：当组合超过两个东西时，你首先进行哪两两组合并不重要。'
- en: '**Rule 3 (Identity element)**: There is a special thing called "zero" such
    that when you combine any thing with "zero" you get the original thing back.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则3（单位元素）**：有一种特殊的东西叫做“零”，当你将任何东西与“零”结合时，你会得到原始的东西。'
- en: With these rules in place, we can come back to the definition of a monoid. A
    "monoid" is just a system that obeys all three rules. Simple!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些规则，我们可以回到幺半群的定义。一个“幺半群”只是遵守所有三条规则的系统。简单！
- en: As I said at the beginning, don't let the mathematical background put you off.
    If programmers had named this pattern, it probably would been called something
    like "the combinable pattern" rather than "monoid". But that's life. The terminology
    is already well-established, so we have to use it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我一开始所说的，不要让数学背景吓到你。如果程序员给这种模式命名，它可能会被称为“可组合模式”而不是“幺半群”。但这就是生活。术语已经被广泛接受，所以我们必须使用它。
- en: Note there are *two* parts to the definition of a monoid -- the things plus
    the associated operation. A monoid is not just "a bunch of things", but "a bunch
    of things" *and* "some way of combining them". So, for example, "the integers"
    is not a monoid, but "the integers under addition" is a monoid.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Semigroups
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In certain cases, you have a system that only follows the first two rules, and
    there is no candidate for a "zero" value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your domain consists only of strictly positive numbers, then
    under addition they are closed and associative, but there is no positive number
    that can be "zero".
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Another example might be the intersection of finite lists. It is closed and
    associative, but there is no (finite) list that when intersected with any other
    finite list, leaves it untouched.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This kind of system still quite useful, and is called a "semigroup" by mathematicians,
    rather than a monoid. Luckily, there is a trick that can convert any semigroup
    into a monoid (which I'll describe later).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: A table of classifications
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's put all our examples into a table, so you can see them all together.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '| Things | Operation | Closed? | Associative? | Identity? | Classification
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Addition | Yes | Yes | 0 | Monoid |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Multiplication | Yes | Yes | 1 | Monoid |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Subtraction | Yes | No | 0 | Other |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Max | Yes | Yes | Int32.MinValue | Monoid |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Equality | No |  |  | Other |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| Int32 | Less than | No |  |  | Other |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| Float | Multiplication | Yes | No (See note 1) | 1 | Other |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| Float | Division | Yes (See note 2) | No | 1 | Other |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| Positive Numbers | Addition | Yes | Yes | No identity | Semigroup |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| Positive Numbers | Multiplication | Yes | Yes | 1 | Monoid |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| Boolean | AND | Yes | Yes | true | Monoid |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| Boolean | OR | Yes | Yes | false | Monoid |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| String | Concatenation | Yes | Yes | Empty string "" | Monoid |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| String | Equality | No |  |  | Other |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| String | "subtractChars" | Yes | No | Empty string "" | Other |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| List | Concatenation | Yes | Yes | Empty list [] | Monoid |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| List | Intersection | Yes | Yes | No identity | Semigroup |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: There are many other kinds of things you can add to this list; polynomials,
    matrices, probability distributions, and so on. This post won't discuss them,
    but once you get the idea of monoids, you will see that the concept can be applied
    to all sorts of things.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '*[Note 1]* As Doug points out in the comments, [floats are not associative](http://forums.udacity.com/questions/100055360/why-floating-point-arithematic-non-associative).
    Replace ''float'' with ''real number'' to get associativity.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*[Note 2]* Mathematical real numbers are not closed under division, because
    you cannot divide by zero and get another real number. However, with IEEE floating
    point numbers you [*can* divide by zero](http://stackoverflow.com/questions/14682005/why-does-division-by-zero-in-ieee754-standard-results-in-infinite-value)
    and get a valid value. So floats are indeed closed under division! Here''s a demonstration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*[注2]* 数学上的实数在除法下不是封闭的，因为你不能除以零并得到另一个实数。然而，使用IEEE浮点数，你[*可以*除以零](http://stackoverflow.com/questions/14682005/why-does-division-by-zero-in-ieee754-standard-results-in-infinite-value)并得到一个有效的值。因此，浮点数确实在除法下封闭！以下是一个演示：'
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What use are monoids to a programmer?
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对程序员来说，单子有什么用？
- en: So far, we have described some abstract concepts, but what good are they for
    real-world programming problems?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了一些抽象的概念，但它们对于现实世界的编程问题有什么用呢？
- en: The benefit of closure
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包的好处
- en: As we've seen, the closure rule has the benefit that you can convert pairwise
    operations into operations that work on lists or sequences.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，闭包规则的好处是你可以将成对操作转换为对列表或序列的操作。
- en: In other words, if we can define a pairwise operation, we can extend it to list
    operations "for free".
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们可以定义成对操作，我们可以免费扩展到列表操作。
- en: 'The function that does this is typically called "reduce". Here are some examples:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的函数通常称为“reduce”。以下是一些示例：
- en: '| Explicit | Using reduce |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 明确 | 使用 reduce |'
- en: '| `1 + 2 + 3 + 4` | `[ 1; 2; 3; 4 ] &#124;> List.reduce (+)` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `1 + 2 + 3 + 4` | `[ 1; 2; 3; 4 ] &#124;> List.reduce (+)` |'
- en: '| `1 * 2 * 3 * 4` | `[ 1; 2; 3; 4 ] &#124;> List.reduce (*)` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `1 * 2 * 3 * 4` | `[ 1; 2; 3; 4 ] &#124;> List.reduce (*)` |'
- en: '| `"a" + "b" + "c" + "d"` | `[ "a"; "b"; "c"; "d" ] &#124;> List.reduce (+)`
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `"a" + "b" + "c" + "d"` | `[ "a"; "b"; "c"; "d" ] &#124;> List.reduce (+)`
    |'
- en: '| `[1] @ [2] @ [3] @ [4]` | `[ [1]; [2]; [3]; [4] ] &#124;> List.reduce (@)`
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `[1] @ [2] @ [3] @ [4]` | `[ [1]; [2]; [3]; [4] ] &#124;> List.reduce (@)`
    |'
- en: You can see that `reduce` can be thought of as inserting the specified operation
    between each element of the list.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`reduce`可以被认为是在列表的每个元素之间插入指定操作。
- en: Note that in the last example, the input to `reduce` is a list of lists, and
    the output is a single list. Make sure you understand why this is.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在最后一个示例中，`reduce`的输入是一个列表的列表，输出是一个单一的列表。确保你理解这是为什么。
- en: The benefit of associativity
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合律的好处
- en: 'If the pairwise combinations can be done in any order, that opens up some interesting
    implementation techniques, such as:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成对组合可以以任何顺序进行，那么会打开一些有趣的实现技术，例如：
- en: Divide and conquer algorithms
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分而治之算法
- en: Parallelization
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行化
- en: Incrementalism
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进主义
- en: These are deep topics, but let's have a quick look!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是深层次的话题，但让我们快速看一下！
- en: '**Divide and conquer algorithms**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**分而治之算法**'
- en: Consider the task of summing the first 8 integers; how could we implement this?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对前8个整数求和的任务；我们如何实现这个？
- en: 'One way would be a crude step-by-step sum, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方式是粗略的逐步求和，如下所示：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But because the sums can be done in any order, we could also implement the requirement
    by splitting the sum into two halves, like this
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但是因为求和可以以任何顺序进行，我们也可以通过将求和拆分为两半来实现要求，就像这样
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'and then we can recursively split the sums into sub-sums in the same way until
    we get down to the basic pairwise operation:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以以相同的方式将求和递归地拆分为子求和，直到我们达到基本的成对操作为止：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This "divide and conquer" approach may seem like overkill for something like
    a simple sum, but we'll see in a future post that, in conjunction with a `map`,
    it is the basis for some well known aggregation algorithms.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“分而治之”的方法可能对于像简单求和这样的东西来说似乎有些过度，但我们将在将来的文章中看到，与`map`结合使用，它是一些众所周知的聚合算法的基础。
- en: '**Parallelization**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行化**'
- en: Once we have a divide and conquer strategy, it can be easily converted into
    a parallel algorithm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个分而治之的策略，就可以很容易地将其转换为并行算法。
- en: 'For example, to sum the first 8 integers on a four-core CPU, we might do something
    like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于四核CPU来说，要对前8个整数求和，我们可能会这样做：
- en: '|  | Core 1 | Core 2 | Core 3 | Core 4 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  | 核心 1 | 核心 2 | 核心 3 | 核心 4 |'
- en: '| Step 1 | `sum12 = 1 + 2` | `sum34 = 3 + 4` | `sum56 = 5 + 6` | `sum78 = 7
    + 8` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 1 | `sum12 = 1 + 2` | `sum34 = 3 + 4` | `sum56 = 5 + 6` | `sum78 = 7 +
    8` |'
- en: '| Step 2 | `sum1234 = sum12 + sum34` | `sum5678 = sum56 + sum78` | (idle) |
    (idle) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 2 | `sum1234 = sum12 + sum34` | `sum5678 = sum56 + sum78` | (空闲) | (空闲)
    |'
- en: '| Step 3 | `sum1234 + sum5678` | (idle) | (idle) | (idle) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 3 | `sum1234 + sum5678` | (空闲) | (空闲) | (空闲) |'
- en: There are still seven calculations that need to be done, but because we are
    doing it parallel, we can do them all in three steps.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还有七个计算需要进行，但因为我们是并行进行的，所以我们可以在三步内完成所有计算。
- en: Again, this might seem like a trivial example, but big data systems such as
    Hadoop are all about aggregating large amounts of data, and if the aggregation
    operation is a monoid, then you can, in theory, easily scale these aggregations
    by using multiple machines*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这可能看起来像是一个微不足道的例子，但是像Hadoop这样的大数据系统都是关于聚合大量数据的，如果聚合操作是一个单子，那么你理论上可以通过使用多台机器轻松扩展这些聚合*。
- en: '*[In practice, of course, the devil is in the details, and real-world systems
    don''t work exactly this way.]'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*[实际上，魔鬼在于细节，现实世界的系统并不完全按照这种方式工作。]'
- en: '**Incrementalism**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**增量主义**'
- en: Even if you do not need parallelism, a nice property of monoids is that they
    support incremental calculations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不需要并行性，单子的一个好处是它们支持增量计算。
- en: For example, let's say you have asked me to calculate the sum of one to five.
    Then of course I give you back the answer fifteen.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你要求我计算一到五的总和。然后当然我给你回答是十五。
- en: But now you say that you have changed your mind, and you want the sum of one
    to *six* instead. Do I have to add up all the numbers again, starting from scratch?
    No, I can use the previous sum, and just add six to it incrementally. This is
    possible because integer addition is a monoid.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在你说你改变了主意，你想要一到*六*的总和。我需要重新从头开始加总所有的数字吗？不，我可以使用之前的总和，并且只是增加六。这是可能的，因为整数加法是一个单子。
- en: 'That is, when faced with a sum like `1 + 2 + 3 + 4 + 5 + 6`, I can group the
    numbers any way I like. In particular, I can make an incremental sum like this:
    `(1 + 2 + 3 + 4 + 5) + 6`, which then reduces to `15 + 6`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，当面对像`1 + 2 + 3 + 4 + 5 + 6`这样的总和时，我可以以任何我喜欢的方式分组数字。特别是，我可以做一个增量总和，像这样：`(1
    + 2 + 3 + 4 + 5) + 6`，然后减少到`15 + 6`。
- en: In this case, recalculating the entire sum from scratch might not be a big deal,
    but consider a real-world example like web analytics, counting the number of visitors
    over the last 30 days, say. A naive implementation might be to calculate the numbers
    by parsing the logs of the last 30 days data. A more efficient approach would
    be to recognize that the previous 29 days have not changed, and to only process
    the incremental changes for one day. As a result, the parsing effort is greatly
    reduced.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重新从头开始重新计算整个总和可能不是什么大问题，但考虑一个像网站分析这样的实际例子，例如过去30天的访问者数量。一个天真的实现可能是通过解析过去30天数据的日志来计算数字。一个更有效的方法是认识到前29天没有改变，只处理一天的增量变化。因此，解析工作大大减少了。
- en: Similarly, if you had a word count of a 100 page book, and you added another
    page, you shouldn't need to parse all 101 pages again. You just need to count
    the words on the last page and add that to the previous total.*
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你有一个100页书的字数统计，然后再加一页，你不应该需要再解析所有101页。你只需要计算最后一页的字数并将其添加到以前的总数中。
- en: '[Technically, these are scary sounding *monoid homomorphisms*. I will explain
    what this is in the next post.]'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从技术上讲，这些听起来很可怕的*单子同态*。我将在下一篇文章中解释这是什么。]'
- en: The benefit of identity
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份的好处
- en: Having an identity element is not always required. Having a closed, associative
    operation (i.e. a semigroup) is sufficient to do many useful things.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有身份元素并不总是必要的。具有封闭的、可结合的操作（即半群）就足以做很多有用的事情了。
- en: 'But in some cases, it is not enough. For example, here are some cases that
    might crop up:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，这是不够的。例如，这里有一些可能出现的情况：
- en: How can I use `reduce` on an empty list?
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何在空列表上使用`reduce`？
- en: If I am designing a divide and conquer algorithm, what should I do if one of
    the "divide" steps has nothing in it?
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我正在设计一个分治算法，如果一个“分”步骤里面什么都没有怎么办？
- en: When using an incremental algorithm, what value should I start with when I have
    no data?
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用增量算法时，当我没有数据时应该从哪个值开始？
- en: In all cases we need a "zero" value. This allows us to say, for example, that
    the sum of an empty list is `0`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，我们都需要一个“零”值。这使我们能够说，例如，一个空列表的总和是`0`。
- en: Regarding the first point above, if we are concerned that the list might be
    empty, then we must replace `reduce` with `fold`, which allows an initial value
    to be passed in. (Of course, `fold` can be used for more things than just monoid
    operations.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上面的第一点，如果我们担心列表可能为空，那么我们必须用`fold`替换`reduce`，它允许传入一个初始值。（当然，`fold`不仅仅可以用于单子操作。）
- en: 'Here are `reduce` and `fold` in action:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`reduce`和`fold`的运作方式：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using a "zero" can result in counter-intuitive results sometimes. For example,
    what is the *product* of an empty list of integers?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“零”有时会产生直观上令人困惑的结果。例如，空整数列表的*乘积*是什么？
- en: 'The answer is `1`, not `0` as you might expect! Here''s the code to prove it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`1`，而不是你可能期望的`0`！这里是证明的代码：
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Summary of the benefits
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优势总结
- en: To sum up, a monoid is basically a way to describe an aggregation pattern --
    we have a list of things, we have some way of combining them, and we get a single
    aggregated object back at the end.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，单子基本上是一种描述聚合模式的方式--我们有一系列事物，我们有一些方法将它们组合起来，最后我们得到一个单一的聚合对象。
- en: 'Or in F# terms:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者用 F# 表示：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So when you are designing code, and you start using terms like "sum", "product",
    "composition", or "concatenation", these are clues that you are dealing with a
    monoid.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以当你设计代码时，当你开始使用“求和”，“乘积”，“组合”或“连接”等术语时，这些都是你正在处理一个单子的线索。
- en: Next steps
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: Now that we understand what a monoid is, let's see how they can be used in practice.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了单子是什么，让我们看看它们如何在实践中使用。
- en: In the next post in this series, we'll look at how you might write real code
    that implements the monoid "pattern".
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列的下一篇文章中，我们将看看如何编写实现单子“模式”的真实代码。
- en: Monoids in practice
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的单子
- en: Monoids in practice
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的单子
- en: In the [previous post](monoids-without-tears.html), we looked at the definition
    of a monoid. In this post, we'll see how to implement some monoids.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一篇文章](monoids-without-tears.html)中，我们看过单子的定义。在这篇文章中，我们将看看如何实现一些单子。
- en: 'First, let''s revisit the definition:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们重新审视一下定义：
- en: You start with a bunch of things, *and* some way of combining them two at a
    time.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你从一堆东西开始，*然后*以某种方式两两组合它们。
- en: '**Rule 1 (Closure)**: The result of combining two things is always another
    one of the things.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 1（封闭性）**：两个事物的组合结果总是另一个事物。'
- en: '**Rule 2 (Associativity)**: When combining more than two things, which pairwise
    combination you do first doesn''t matter.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 2（结合性）**：当组合两个以上的事物时，你首先做哪一个两两组合是无关紧要的。'
- en: '**Rule 3 (Identity element)**: There is a special thing called "zero" such
    that when you combine any thing with "zero" you get the original thing back.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则 3（单位元素）**：有一个特殊的东西叫做“零”，这样当你将任何东西与“零”结合时，你就会得到原来的东西。'
- en: 'For example, if strings are the things, and string concatenation is the operation,
    then we have a monoid. Here''s some code that demonstrates this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果字符串是事物，字符串连接是操作，那么我们就有了一个单子。这里有一些演示的代码：
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: But now let's try to apply this to a more complicated object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在让我们试着将这个方法应用到一个更复杂的对象上。
- en: Say that we have have an `OrderLine`, a little structure that represents a line
    in a sales order, say.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`OrderLine`，它是一个小结构，表示销售订单中的一行，比如说。
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And then perhaps we might want to find the total for an order, that is, we want
    to sum the `Total` field for a list of lines.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，也许我们想要找到订单的总计，也就是说，我们想要对行的`Total`字段进行求和。
- en: 'The standard imperative approach would be to create a local `total` variable,
    and then loop through the lines, summing as we go, like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的命令式方法是创建一个局部的`total`变量，然后循环遍历行，逐步求和，就像这样：
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s try it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试：
- en: '[PRE16]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But of course, being an experienced functional programmer, you would sneer
    at this, and use `fold` in `calculateOrderTotal` instead, like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 但当然，作为一名经验丰富的函数式程序员，你会嘲笑这一点，而是在`calculateOrderTotal`中使用`fold`，就像这样：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So far, so good. Now let's look at a solution using a monoid approach.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，一切都很好。现在让我们来看看使用单子方法的解决方案。
- en: For a monoid, we need to define some sort of addition or combination operation.
    How about something like this?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个单子，我们需要定义某种加法或组合操作。像这样的东西怎么样？
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But this is no good, because we forgot a key aspect of monoids. The addition
    must return a value of the same type!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样做不好，因为我们忘记了单子的一个关键方面。加法必须返回相同类型的值！
- en: If we look at the signature for the `addLine` function...
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`addLine`函数的签名...
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '...we can see that the return type is `float` not `OrderLine`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '...我们可以看到返回类型是`float`而不是`OrderLine`。'
- en: 'What we need to do is return a whole other `OrderLine`. Here''s a correct implementation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是返回一个完整的其他`OrderLine`。这里是一个正确的实现：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now the signature is correct: `addLine : OrderLine -> OrderLine -> OrderLine`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在签名是正确的：`addLine：OrderLine -> OrderLine -> OrderLine`。
- en: Note that because we have to return the entire structure we have to specify
    something for the `ProductCode` and `Qty` as well, not just the total. The `Qty`
    is easy, we can just do a sum. For the `ProductCode`, I decided to use the string
    "TOTAL", because we don't have a real product code we can use.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为我们必须返回整个结构，所以我们不仅需要为`ProductCode`和`Qty`指定一些东西，还需要为`Total`指定一些东西。`Qty`很容易，我们可以简单地求和。对于`ProductCode`，我决定使用字符串“TOTAL”，因为我们没有真正的产品代码可以使用。
- en: 'Let''s give this a little test:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We should get this result:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*NOTE: For more on the printf formatting options used, see the post on [printf
    here](printf.html).*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s apply this to a list using `reduce`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the result:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At first, this might seem like extra work, and just to add up a total. But note
    that we now have more information than just the total; we also have the sum of
    the qtys as well.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can easily reuse the `printLine` function to make a simple
    receipt printing function that includes the total, like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Which gives an output like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: More importantly, we can now use the incremental nature of monoids to keep a
    running subtotal that we update every time a new line is added.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We could even define a custom operator such as `++` so that we can add lines
    together naturally as it they were numbers:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can see that using the monoid pattern opens up a whole new way of thinking.
    You can apply this "add" approach to almost any kind of object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: For example, what would a product "plus" a product look like? Or a customer
    "plus" a customer? Let your imagination run wild!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Are we there yet?
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that we not quite done yet. There is a third requirement
    for a monoid that we haven't discussed yet -- the zero or identity element.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the requirement means that we need some kind of `OrderLine` such
    that adding it to another order line would leave the original untouched. Do we
    have such a thing?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Right now, no, because the addition operation always changes the product code
    to "TOTAL". What we have right now is in fact a *semigroup*, not a monoid.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a semigroup is perfectly useable. But a problem would arise
    if we had an empty list of lines and we wanted to total them. What should the
    result be?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: One workaround would be to change the `addLine` function to ignore empty product
    codes. And then we could use an order line with an empty code as the zero element.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what I mean:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can then test that identity works as expected:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This does seem a bit hacky, so I wouldn't recommend this technique in general.
    There's another way to get an identity that we'll be discussing later.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Introducing a special total type
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example above, the `OrderLine` type was very simple and it was easy to
    overload the fields for the total.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'But what would happen if the `OrderLine` type was more complicated? For example,
    if it had a `Price` field as well, like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we have introduced a complication. What should we set the `Price` to when
    we combine two lines? The average price? No price?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Neither seems very satisfactory.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we don't know what to do probably means that our design is wrong.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Really, we only need a subset of the data for the total, not all of it. How
    can we represent this?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: With a discriminated union of course! One case can be used for product lines,
    and the other case can be used for totals only.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what I mean:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This design is much nicer. We now have a special structure just for totals and
    we don't have to use contortions to make the excess data fit. We can even remove
    the dummy "TOTAL" product code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计要好得多。我们现在有一个专门用于总数的结构，不必再费力使多余的数据适应。我们甚至可以删除虚拟的“TOTAL”产品代码。
- en: '*Note that I named the "total" field differently in each record. Having unique
    field names like this means that you don''t have to always specify the type explicitly.*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，我在每个记录中都使用了不同的名称来命名“total”字段。像这样拥有唯一字段名称意味着你不必总是显式指定类型。*'
- en: 'Unfortunately, the addition logic is more complicated now, as we have to handle
    every combination of cases:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，现在添加逻辑更加复杂，因为我们必须处理每一种情况的组合：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we cannot just return the `TotalLine` value. We have to wrap in the
    `Total` case to make a proper `OrderLine`. If we didn't do that, then our `addLine`
    would have the signature `OrderLine -> OrderLine -> TotalLine`, which is not correct.
    We have to have the signature `OrderLine -> OrderLine -> OrderLine` -- nothing
    else will do!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能只返回`TotalLine`值。我们必须将其包装在`Total`情况中，以创建一个适当的`OrderLine`。如果我们不这样做，那么我们的`addLine`将具有`OrderLine
    -> OrderLine -> TotalLine`的签名，这是不正确的。我们必须有`OrderLine -> OrderLine -> OrderLine`的签名
    -- 没有其他选择！
- en: 'Now that we have two cases, we need to handle both of them in the `printLine`
    function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两种情况，我们需要在`printLine`函数中处理它们：
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'But once we have done this, we can now use addition just as before:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但一旦我们完成了这个，我们现在可以像以前一样使用加法：
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Identity again
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 再次考虑一下身份
- en: Again, we haven't dealt with the identity requirement. We could try using the
    same trick as before, with a blank product code, but that only works with the
    `Product` case.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们还没有解决身份要求。我们可以尝试使用与之前相同的技巧，使用一个空的产品代码，但那只适用于`Product`情况。
- en: 'To get a proper identity, we really need to introduce a *third* case, `EmptyOrder`
    say, to the union type:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个正确的身份，我们确实需要引入一个*第三*种情况，比如`EmptyOrder`，来表示联合类型：
- en: '[PRE37]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With this extra case available, we rewrite the `addLine` function to handle
    it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个额外的情况可用后，我们重新编写`addLine`函数来处理它：
- en: '[PRE38]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And now we can test it:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试它了：
- en: '[PRE39]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using the built in List.sum function
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置的List.sum函数
- en: It turns out that the `List.sum` function knows about monoids! If you tell it
    what the addition operation is, and what the zero is, then you can use `List.sum`
    directly rather than `List.fold`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 原来，`List.sum`函数知道单子！如果你告诉它加法操作是什么，零是什么，那么你就可以直接使用`List.sum`而不是`List.fold`。
- en: 'The way you do this is by attaching two static members, `+` and `Zero` to your
    type, like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你这样做的方法是通过为你的类型附加两个静态成员，`+`和`Zero`，就像这样：
- en: '[PRE40]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once this has been done, you can use `List.sum` and it will work as expected.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这样做了，你就可以使用`List.sum`，它将按预期工作。
- en: '[PRE41]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that for this to work you mustn't already have a method or case called
    `Zero`. If I had used the name `Zero` instead of `EmptyOrder` for the third case
    it would not have worked.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使这个工作，你不能已经有一个叫做`Zero`的方法或情况。如果我用名字`Zero`而不是`EmptyOrder`来代替第三种情况，它就不会起作用。
- en: Although this is a neat trick, in practice I don't think it is a good idea unless
    you are defining a proper math-related type such as `ComplexNumber` or `Vector`.
    It's a bit too clever and non-obvious for my taste.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个巧妙的技巧，但在实践中，我认为这不是一个好主意，除非你正在定义一个合适的与数学相关的类型，比如`ComplexNumber`或`Vector`。对我来说，这有点太聪明和不明显了。
- en: If you *do* want to use this trick, your `Zero` member cannot be an extension
    method -- it must be defined with the type.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你**确实**想使用这个技巧，你的`Zero`成员不能是一个扩展方法 -- 它必须与类型一起定义。
- en: For example, in the code below, I'm trying to define the empty string as the
    "zero" for strings.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码中，我试图将空字符串定义为字符串的“零”。
- en: '`List.fold` works because `String.Zero` is visible as an extension method in
    this code right here, but `List.sum` fails because the extension method is not
    visible to it.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`List.fold`之所以有效，是因为`String.Zero`在这段代码中作为扩展方法可见，但`List.sum`失败了，因为扩展方法对它不可见。'
- en: '[PRE42]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Mapping to a different structure
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射到不同的结构
- en: Having two different cases in a union might be acceptable in the order line
    case, but in many real world cases, that approach is too complicated or confusing.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在联合中有两种不同情况可能是可以接受的，但在许多实际情况下，这种方法太复杂或令人困惑。
- en: 'Consider a customer record like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个像这样的客户记录：
- en: '[PRE43]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How would we "add" two of these customers?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何“添加”两个这样的客户？
- en: A helpful tip is to realize that aggregation really only works for numeric and
    similar types. Strings can't really be aggregated easily.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的提示是意识到聚合实际上只适用于数值和类似的类型。字符串不能很容易地进行聚合。
- en: 'So rather than trying to aggregate `Customer`, let''s define a separate class
    `CustomerStats` that contains all the aggregatable information:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，与其尝试聚合 `Customer`，不如定义一个单独的类 `CustomerStats`，其中包含所有可聚合的信息：
- en: '[PRE44]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'All the fields in `CustomerStats` are numeric, so it is obvious how we can
    add two stats together:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerStats` 中的所有字段都是数值型的，因此我们很容易理解如何将两个统计信息相加：'
- en: '[PRE45]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As always, the inputs and output of the `add` function must be the same type.
    We must have `CustomerStats -> CustomerStats -> CustomerStats`, not `Customer
    -> Customer -> CustomerStats` or any other variant.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，`add` 函数的输入��输出必须是相同类型。我们必须有 `CustomerStats -> CustomerStats -> CustomerStats`，而不是
    `Customer -> Customer -> CustomerStats` 或任何其他变体。
- en: Ok, so far so good.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，目前一切顺利。
- en: Now let's say we have a collection of customers, and we want to get the aggregated
    stats for them, how should we do this?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有一组客户，我们想要为他们获取聚合的统计信息，应该如何做？
- en: We can't add the customers directly, so what we need to do is first convert
    each customer to a `CustomerStats`, and then add the stats up using the monoid
    operation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接添加客户，所以我们需要先将每个客户转换为 `CustomerStats`，然后使用单子操作将统计信息相加。
- en: 'Here''s an example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE46]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first thing to note is that the `toStats` creates statistics for just one
    customer. We set the count to just 1. It might seem a bit strange, but it does
    make sense, because if there was just one customer in the list, that's what the
    aggregate stats would be.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的第一件事是 `toStats` 仅为一个客户创建统计信息。我们将计数设置为 1。这可能看起来有点奇怪，但这是有道理的，因为如果列表中只有一个客户，那么聚合统计信息就是这样的。
- en: The second thing to note is how the final aggregation is done. First we use
    `map` to convert the source type to a type that is a monoid, and then we use `reduce`
    to aggregate all the stats.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点需要注意的是最终的聚合方式。首先我们使用 `map` 将源类型转换为一个单子类型，然后我们使用 `reduce` 来聚合所有的统计信息。
- en: Hmmm.... `map` followed by `reduce`. Does that sound familiar to you?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯.... `map` 后跟 `reduce`。这听起来熟悉吗？
- en: Yes indeed, Google's famous MapReduce algorithm was inspired by this concept
    (although the details are somewhat different).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，谷歌著名的 MapReduce 算法就是受到这个概念的启发（尽管细节有些不同）。
- en: Before we move on, here are some simple exercises for you to check your understanding.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，这里有一些简单的练习供你检验自己的理解。
- en: What is the "zero" for `CustomerStats`? Test your code by using `List.fold`
    on an empty list.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomerStats` 的"零"是什么？通过在空列表上使用 `List.fold` 测试你的代码。'
- en: Write a simple `OrderStats` class and use it to aggregate the `OrderLine` type
    that we introduced at the beginning of this post.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的 `OrderStats` 类，并用它来聚合我们在本文开头介绍的 `OrderLine` 类型。
- en: Monoid Homomorphisms
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子同态
- en: We've now got all the tools we need to understand something called a *monoid
    homomorphism*.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了理解所谓的*单子同态*所需的所有工具。
- en: I know what you're thinking... Ugh! Not just one, but two strange math words
    at once!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么... 哎呀！不只是一个，而是两个奇怪的数学词汇！
- en: But I hope that the word "monoid" is not so intimidating now. And "homomorphism"
    is another math word that is simpler than it sounds. It's just greek for "same
    shape" and it describes a mapping or function that keeps the "shape" the same.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但我希望现在"单子"这个词不再那么令人生畏。而"同态"是另一个听起来比实际简单的数学词汇。它只是希腊语中的"相同形状"，描述了保持"形状"相同的映射或函数。
- en: What does that mean in practice?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中这意味着什么？
- en: Well, we have seen that all monoids have a certain common structure. That is,
    even though the underlying objects can be quite different (integers, strings,
    lists, `CustomerStats`, etc.) the "monoidness" of them is the same. As George
    W. Bush once said, once you've seen one monoid, you've seen them all.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们已经看到所有单子都具有某种共同的结构。也就是说，即使底层对象可能完全不同（整数、字符串、列表、`CustomerStats` 等），它们的"单子性"是相同的。正如乔治·W·布什曾经说过的，一旦你见过一个单子，你就见过它们全部。
- en: So a *monoid* homomorphism is a transformation that preserves an essential "monoidness",
    even if the "before" and "after" objects are quite different.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*单子*同态是一种保留基本"单子性"的转换，即使"之前"和"之后"的对象可能完全不同。
- en: In this section, we'll look at a simple monoid homomorphism. It's the "hello
    world", the "fibonacci series", of monoid homomorphisms -- word counting.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一个简单的单子同态。这是单子同态的"hello world"，"斐波那契数列"，单子同态的 -- 单词计数。
- en: Documents as a monoid
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档作为一个单子
- en: 'Let''s say we have a type which represents text blocks, something like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个表示文本块的类型，类似于这样：
- en: '[PRE47]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And of course we can add two smaller text blocks to make a larger text block:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将两个较小的文本块相加以形成一个较大的文本块：
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here''s an example of how adding works:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个加法运算的示例：
- en: '[PRE49]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Since you are now a expert, you will quickly recognize this as a monoid, with
    the zero obviously being `Text ""`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你现在是一个专家，你会很快认识到这是一个幺半群，其中零显然是`Text ""`。
- en: Now let's say we are writing a book (such as [this one](https://leanpub.com/understandingfunctionalprogramming?utm_campaign=understandingfunctionalprogramming))
    and we want a word count to show how much we have written.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们正在写一本书（比如[这本书](https://leanpub.com/understandingfunctionalprogramming?utm_campaign=understandingfunctionalprogramming)），我们想要一个字数统计来显示我们已经写了多少。
- en: 'Here''s a very crude implementation, plus a test:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常粗糙的实现，加上一个测试：
- en: '[PRE50]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: So we are writing away, and now we have produced three pages of text. How do
    we calculate the word count for the complete document?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们一直在写作，现在我们已经写了三页的文本。我们如何计算完整文档的字数？
- en: 'Well, one way is to add the separate pages together to make a complete text
    block, and then apply the `wordCount` function to that text block. Here''s a diagram:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，一��方法是将单独的页面合并在一起形成完整的文本块，然后对该文本块应用`wordCount`函数。这里是一个图示：
- en: '![Word count via adding pages](monoid_h1.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![通过添加页面进行字数统计](monoid_h1.jpg)'
- en: But everytime we finish a new page, we have to add all the text together and
    do the word count all over again.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 但每次我们完成一页新的内容时，我们都必须将所有文本加在一起，然后重新计算字数。
- en: 'No doubt you can see that there is a better way of doing this. Instead of adding
    all the text together and then counting, get the word count for each page separately,
    and then add these counts up, like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，你可以看到有一个更好的方法来做这件事。不要将所有文本加在一起然后计数，而是分别获取每页的字数，然后将这些计数相加，就像这样：
- en: '![Word count via adding counts](monoid_h2.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![通过添加计数进行字数统计](monoid_h2.jpg)'
- en: The second approach relies on the fact that integers (the counts) are themselves
    a monoid, and you can add them up to get the desired result.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法依赖于整数（计数）本身是一个幺半群的事实，你可以将它们相加以获得所需的结果。
- en: So the `wordCount` function has transformed an aggregation over "pages" into
    an aggregation over "counts".
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`wordCount`函数已经将对"页面"的聚合转变为对"计数"的聚合。
- en: 'The big question now: is `wordCount` a monoid homomorphism?'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的重要问题是：`wordCount`是一个幺半群同态吗？
- en: Well, pages (text) and counts (integers) are both monoids, so it certainly transforms
    one monoid into another.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，页面（文本）和计数（整数）都是幺半群，所以它肯定将一个幺半群转换为另一个幺半群。
- en: 'But the more subtle condition is: does it preserve the "shape"? That is, does
    the adding of the counts give the same answer as the adding of the pages?'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 但更微妙的条件是：它是否保留了"形状"？也就是说，计数的相加是否与页面的相加给出相同的答案？
- en: In this case, the answer is yes. So `wordCount` *is* a monoid homomorphism!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，答案是肯定的。所以`wordCount` *是* 一个幺半群同态！
- en: You might think that this is obvious, and that all mappings like this must be
    monoid homomorphisms, but we'll see an example later where this is not true.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这是显而易见的，所有类似的映射都必须是幺半群同态，但我们稍后会看到一个例子，证明这并非如此。
- en: The benefits of chunkability
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可分块性的好处
- en: The advantage of the monoid homomorphism approach is that it is *"chunkable"*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 幺半群同态方法的优势在于它是*"可分块的"*。
- en: Each map and word count is independent of the others, so we can do them separately
    and then add up the answers afterwards. For many algorithms, working on small
    chunks of data is much more efficient than working on large chunks, so if we can,
    we should exploit this whenever possible.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 每个映射和字数统计都是独立的，所以我们可以分别进行它们，然后在之后将答案相加。对于许多算法来说，处理小数据块要比处理大数据块高效得多，因此如果可能的话，我们应该尽可能利用这一点。
- en: As a direct consequence of this chunkability, we get some of the benefits that
    we touched on in the previous post.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种可分块性的直接结果，我们获得了前一篇文章中提到的一些好处。
- en: First, it is *incremental*. That is, as we add text to the last page, we don't
    have to recalculate the word counts for all the previous pages, which might save
    some time.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它是*增量的*。也就是说，当我们向最后一页添加文本时，我们不必重新计算所有先前页面的字数，这可能会节省一些时间。
- en: Second, it is *parallelizable*. The work for each chunk can be done independently,
    on different cores or machines. Note that in practice, parallelism is much overrated.
    The chunkability into small pieces has a much greater effect on performance than
    parallelism itself.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它是*可并行化的*。每个块的工作可以独立完成，在不同的核心或机器上。请注意，在实践中，并行性被高估了。将数据分块对性能的影响远远大于并行性本身。
- en: Comparing word count implementations
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较字数统计的实现
- en: We're now ready to create some code that will demonstrate these two different
    techniques.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the basic definitions from above, except that I will change
    the word count to use regular expressions instead of `split`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, we'll create a page with 1000 words in it, and a document with 1000 pages.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We'll want to time the code to see if there is any difference between the implementations.
    Here's a little helper function.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Ok, let's implement the first approach. We'll add all the pages together using
    `addText` and then do a word count on the entire million word document.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: For the second approach, we'll do `wordCount` on each page first, and then add
    all the results together (using `reduce` of course).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that we have only changed two lines of code!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'In `wordCountViaAddText` we had:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And in `wordCountViaMap` we have basically swapped these lines. We now do `wordCount`
    *first* and then `reduce` afterwards, like this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Finally, let's see what difference parallelism makes. We'll use the built-in
    `Array.Parallel.map` instead of `List.map`, which means we'll need to convert
    the list into an array first.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: I hope that you are following along with the implementations, and that you understand
    what is going on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the results
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the results for the different implementations running on my 4 core
    machine:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We must recognize that these are crude results, not a proper performance profile.
    But even so, it is very obvious that the map/reduce version is about 10 times
    faster that the `ViaAddText` version.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: This is the key to why monoid homomorphisms are important -- they enable a "divide
    and conquer" strategy that is both powerful and easy to implement.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, you could argue that the algorithms used are very inefficient. String
    concat is a terrible way to accumulate large text blocks, and there are much better
    ways of doing word counts. But even with these caveats, the fundamental point
    is still valid: by swapping two lines of code, we got a huge performance increase.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: And with a little bit of hashing and caching, we would also get the benefits
    of incremental aggregation -- only recalculating the minimum needed as pages change.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Note that the parallel map didn't make that much difference in this case, even
    though it did use all four cores. Yes, we did add some minor expense with `toArray`
    but even in the best case, you might only get a small speed up on a multicore
    machine. To reiterate, what really made the most difference was the divide and
    conquer strategy inherent in the map/reduce approach.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: A non-monoid homomorphism
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned earlier that not all mappings are necessarily monoid homomorphisms.
    In this section, we'll look at an example of one that isn't.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: For this example, rather than using counting words, we're going to return the
    most frequent word in a text block.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Here's the basic code.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `mostFrequentWord` function is bit more complicated than the previous `wordCount`
    function, so I'll take you through it step by step.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: First, we use a regex to match all non-whitespace. The result of this is a `MatchCollection`
    not a list of `Match`, so we have to explicitly cast it into a sequence (an `IEnumerable<Match>`
    in C# terms).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Next we convert each `Match` into the matched word, using `ToString()`. Then
    we group by the word itself, which gives us a list of pairs, where each pair is
    a `(word,list of words)`. We then turn those pairs into `(word,list count)` and
    then sort descending (using the negated word count).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Finally we take the first pair, and return the first part of the pair. This
    is the most frequent word.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Ok, let's continue, and create some pages and a document as before. This time
    we're not interested in performance, so we only need a few pages. But we do want
    to create *different* pages. We'll create one containing nothing but "hello world",
    another containing nothing but "goodbye world", and a third containing "foobar".
    (Not a very interesting book IMHO!)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: It is obvious that, with respect to the entire document, "world" is the most
    frequent word overall.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: So let's compare the two approaches as before. The first approach will combine
    all the pages and then apply `mostFrequentWord`, like this.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![mostFrequentWord via adding pages](monoid_non_h1.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: 'The second approach will do `mostFrequentWord` separately on each page and
    then combine the results, like this:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '![mostFrequentWord via adding counts](monoid_non_h2.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Can you see what happened? The first approach was correct. But the second approach
    gave a completely wrong answer!
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The second approach just concatenated the most frequent words from each page.
    The result is a new string that was not on *any* of the pages. A complete fail!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: What went wrong?
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Well, strings *are* a monoid under concatenation, so the mapping transformed
    a monoid (Text) to another monoid (string).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: But the mapping did not preserve the "shape". The most frequent word in a big
    chunk of text cannot be derived from the most frequent words in smaller chunks
    of text. In other words, it is not a proper monoid homomorphism.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a monoid homomorphism
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at these two different examples again to understand what the distinction
    is between them.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'In the word count example, we got the *same* final result whether we added
    the blocks and then did the word count, or whether we did the word counts and
    then added them together. Here''s a diagram:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '![word count both ways](monoid_h1_both.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
- en: But for the most frequent word example, we did *not* get the same answer from
    the two different approaches.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![most frequent word both ways](monoid_non_h1_both.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: In other words, for `wordCount`, we had
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'But for `mostFrequentWord`, we had:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'So this brings us to a slightly more precise definition of a monoid homomorphism:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Alas, then, `mostFrequentWord` is not a monoid homomorphism.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: That means that if we want to calculate the `mostFrequentWord` on a large number
    of text files, we are sadly forced to add all the text together first, and we
    can't benefit from a divide and conquer strategy.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '... or can we? Is there a way to turn `mostFrequentWord` into a proper monoid
    homomorphism? Stay tuned!'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Next steps
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only dealt with things that are proper monoids. But what if
    the thing you want to work with is *not* a monoid? What then?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: In the next post in this series, I'll give you some tips on converting almost
    anything into a monoid.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: We'll also fix up the `mostFrequentWord` example so that it is a proper monoid
    homomorphism, and we'll revisit the thorny problem of zeroes, with an elegant
    approach for creating them.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: See you then!
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are interested in using monoids for data aggregation, there are lots
    of good discussions in the following links:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Twitter's [Algebird library](https://blog.twitter.com/2012/scalding-080-and-algebird)
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most [probabilistic data structures](http://highlyscalable.wordpress.com/2012/05/01/probabilistic-structures-web-analytics-data-mining/)
    are monoids.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Gaussian distributions form a monoid](http://izbicki.me/blog/gausian-distributions-are-monoids).'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google's [MapReduce Programming Model](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.5859&rep=rep1&type=pdf)
    (PDF).
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Monoidify! Monoids as a Design Principle for Efficient MapReduce Algorithms](http://arxiv.org/abs/1304.7544)
    (PDF).'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinkedIn's [Hourglass libary for Hadoop](http://www.slideshare.net/matthewterencehayes/hourglass-27038297)
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From Stack Exchange: [What use are groups, monoids, and rings in database computations?](http://cs.stackexchange.com/questions/9648/what-use-are-groups-monoids-and-rings-in-database-computations)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to get a bit more technical, here is a detailed study of monoids
    and semigroups, using graphics diagrams as the domain:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[Monoids: Theme and Variations](http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf)
    (PDF).'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with non-monoids
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with non-monoids
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous posts in [this series](understanding-monoids.html), we only
    dealt with things that were proper monoids.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: But what if the thing you want to work with is *not* a monoid? What then? Well,
    in this post, I'll give you some tips on converting almost anything into a monoid.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we'll be introduced to a number of important and common functional
    design idioms, such as preferring lists rather than singletons, and using the
    option type at every opportunity.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Getting closure
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you recall, for a proper monoid, we need three things to be true: closure,
    associativity, and identity. Each requirement can present a challenge, so we''ll
    discuss each in turn.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with closure.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: In some cases you might want to add values together, but the type of the combined
    value is not the same as the type of the original values. How can you handle this?
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: One way is to just to map from the original type to a new type that *is* closed.
    We saw this approach used with the `Customer` and `CustomerStats` example in the
    previous post. In many cases, this is the easiest approach, because you don't
    have to mess with the design of the original types.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, sometimes you really don't want to use `map`, but instead
    want to design your type from the beginning so that it meets the closure requirement.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Either way, whether you are designing a new type or redesigning an existing
    type, you can use similar techniques to get closure.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Combining closed types to make new compound types
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, we've seen that numeric types are closed under some basic math operations
    like addition and multiplication. We've also seen that some non-numeric types,
    like strings and lists, are closed under concatenation.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, it should be obvious that any combination of these types
    will be closed too. We just have to define the "add" function to do the appropriate
    "add" on the component types.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `addMyType` function uses integer addition on the `int` field, and list
    concatenation on the `list` field. As a result the `MyType` is closed using the
    function `addMyType` -- in fact, not only is it closed, it is a monoid too. So
    in this case, we're done!
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the approach we took with `CustomerStats` in the [previous post](monoids-part2.html).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s my first tip:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN TIP: To easily create a monoidal type, make sure that each field of
    the type is also a monoid.**'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Question to think about: when you do this, what is the "zero" of the new compound
    type?'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with non-numeric types
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The approach above works when creating compound types. But what about non-numeric
    types, which have no obvious numeric equivalent?
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a very simple case. Say that you have some chars that you want to add
    together, like this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: But, a char plus a char is not another char. If anything, it is a string.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: But that is very unhelpful, as it does not meet the closure requirement.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to fix this is to force the chars into strings, which does work:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: But that is a specific solution for chars -- is there a more generic solution
    that will work for other types?
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Well, think for a minute what the relationship of a `string` to a `char` is.
    A string can be thought of as a list or array of chars.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we could have used lists of chars instead, like this:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This meets the closure requirement as well.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: What's more, this is in fact a general solution to *any* problem like this,
    because *anything* can be put into a list, and lists (with concatenation) are
    always monoids.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s my next tip:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN TIP: To enable closure for a non-numeric type, replace single items
    with lists.**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, you might need to convert to a list when setting up the monoid
    and then convert to another type when you are done.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `Char` case, you would do all your manipulation on lists
    of chars and then only convert to a string at the end.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: So let's have a go at creating a "monoidal char" module.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You can see that `MChar` is a wrapper around a list of chars, rather than a
    single char.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s test it:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If we want to get fancy we can use map/reduce to work on a set of chars, like
    this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Monoids for errors
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MonoidalChar` example is trivial, and could perhaps be implemented in other
    ways, but in general this is an extremely useful technique.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is a simple module for doing some validation. There are two
    options, `Success` and `Failure`, and the `Failure` case also has a error string
    associated with it.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In practice, we might perform multiple validations on a string, and we would
    like to return all the results at once, added together somehow.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: This calls out for being a monoid! If we can add two results pairwise, then
    we can extend the operation to add as many results as we like!
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: So then the question is, how do we combine *two* validation results?
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A naive approach would be to concatenate the strings, but that wouldn't work
    if we were using format strings, or resource ids with localization, etc.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: No, a better way is to convert the `Failure` case to use a *list* of strings
    instead of a single string. That will make combining results simple.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the same code as above, with the `Failure` case redefined to use a
    list:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You can see that the individual validations call `fail` with a single string,
    but behind the scenes it is being stored as a list of strings, which can, in turn,
    be concatenated together.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we can now create the `add` function.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic will be:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: If both results are `Success`, then the combined result is `Success`
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one result is `Failure`, then the combined result is that failure.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both results are `Failure`, then the combined result is a `Failure` with
    both error lists concatenated.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here are some tests to check the logic:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'And here''s a more realistic example, where we have a list of validation functions
    that we want to apply:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The output is a `Failure` with three error messages.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: One more thing is needed to finish up this monoid. We need a "zero" as well.
    What should it be?
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: By definition, it is something that when combined with another result, leaves
    the other result alone.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: I hope you can see that by this definition, "zero" is just `Success`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you know, we would need to use zero if the list to reduce over is empty.
    So here's an example where we don't apply any validation functions at all, giving
    us an empty list of `ValidationResult`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note that we needed to change `reduce` to `fold` as well, otherwise we would
    get a runtime error.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Lists for performance
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here's one more example of the benefit of using lists. Compared with other methods
    of combination, list concatenation is relatively cheap, both in computation and
    in memory use, because the objects being pointed to don't have to change or be
    reallocated.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous post, we defined a `Text` block that wrapped a
    string, and used string concatenation to add their contents.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: But for large strings this continual concatenation can be expensive.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Consider a different implementation, where the `Text` block contains a *list*
    of strings instead.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Almost no change in implementation, but performance will probably be greatly
    improved.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: You can do all your manipulation on *lists* of strings and you need only convert
    to a normal string at the very end of the processing sequence.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: And if lists aren't performant enough for you, you can easily extend this approach
    to use classic data structures like trees, heaps, etc. or mutable types like ResizeArray.
    (See the appendix on performance at the bottom of this post for some more discussion
    on this)
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Jargon alert
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of using a list of objects as a monoid is common in mathematics,
    where it is called a ["free monoid"](http://en.wikipedia.org/wiki/Free_monoid).
    In computer science, it also called a ["Kleene star"](http://en.wikipedia.org/wiki/Kleene_star)
    such as `A*`. And if you don't allow empty lists, then you have no zero element.
    This variant is called a "free semigroup" or "Kleene plus" such as `A+`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: This "star" and "plus" notation will surely be familiar to you if you have ever
    used regular expressions.*
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[* You probably weren''t aware that there was a connection between regular
    expressions and monoids! There''s some even [deeper relationships too](http://scienceblogs.com/goodmath/2008/03/06/monoids-and-computation-syntac/).]'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have dealt with closure, let's take on associativity.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: We saw a couple of non-associative operations in the very first post, including
    subtraction and division.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `5 - (3 - 2)` is not equal to `(5 - 3) - 2`. This shows that
    subtraction is not associative, and also `12 / (3 / 2)` is not equal to `(12 /
    3) / 2`, which shows that division is not associative.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: There's no single correct answer in these cases, because you might genuinely
    care about different answers depending on whether you work from left to right
    or right to left.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the F# standard libraries have two versions of `fold` and `reduce`
    to cater for each preference. The normal `fold` and `reduce` work left to right,
    like this:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'But there is also `foldBack` and `reduceBack` that work from right to left,
    like this:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In a sense, then, the associativity requirement is just a way of saying that
    you should get the *same* answer no matter whether you use `fold` or `foldBack`.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Moving the operation into the element
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But assuming that you *do* want a consistent monoidal approach, the trick in
    many cases is to move the operation into a property of each element. **Make the
    operation a noun, rather than a verb.**
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: For example `3 - 2` can be thought of as `3 + (-2)`. Rather than "subtraction"
    as a verb, we have "negative 2" as a noun.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: In that case, the above example becomes `5 + (-3) + (-2)`. And since we are
    now using addition as the operator, we *do* have associativity, and `5 + (-3 +
    -2)` is indeed the same as `(5 + -3) + -2`.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: A similar approach works with division. `12 / 3 / 2` can be converted into `12
    * (1/3) * (1/2)`, and now we are back to multiplication as the operator, which
    is associative.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: This approach of converting the operator into a property of the element can
    be generalized nicely.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s a tip:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN TIP: To get associativity for an operation, try to move the operation
    into the object.**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can revisit an earlier example to understand how this works. If you recall,
    in the first post we tried to come up with a non-associative operation for strings,
    and settled on `subtractChars`.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Here's a simple implementation of `subtractChars`
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'With this implementation we can do some interactive tests:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'And we can see for ourselves that the associativity requirement is violated:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: How can we make this associative?
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: The trick is move the "subtract-ness" from the operator into the object, just
    as we did with the numbers earlier.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'What I mean is that we replace the plain strings with a "subtract" or "chars
    to remove" data structure that captures what we want to remove, like so:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'And then we "apply" the data structure to the string:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Once we use this approach, we can rework the non-associative example above
    to look something like this:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Yes, it is not exactly the same as the original code, but you might find that
    this is actually a better fit in many situations.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is below. We define a `CharsToRemove` to contain a set of
    chars, and the other function implementations fall out from that in a straightforward
    way.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Let's test!
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The way to think about this approach is that, in a sense, we are modelling *actions*
    rather than *data*. We have a list of `CharsToRemove` actions, then we combine
    them into a single "big" `CharsToRemove` action, and then we execute that single
    action at the end, after we have finished the intermediate manipulations.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see another example of this shortly, but you might be thinking at this
    point: "this sounds a bit like functions, doesn''t it?" To which I will say "yes,
    it does!"'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact rather than creating this `CharsToRemove` data structure, we could
    have just partially applied the original `subtractChars` function, as shown below:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: (Note that we reverse the parameters to make partial application easier)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: And now we don't even need a special `applyTo` function.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: But when we have more than one of these subtraction functions, what do we do?
    Each of these partially applied functions has signature `string -> string`, so
    how can we "add" them together?
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The answer is function composition, of course!
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This is the functional equivalent of creating the `CharsToRemove` data structure.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: The "data structure as action" and function approach are not exactly the same
    -- the `CharsToRemove` approach may be more efficient, for example, because it
    uses a set, and is only applied to strings at the end -- but they both achieve
    the same goal. Which one is better depends on the particular problem you're working
    on.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: I'll have more to say on functions and monoids in the next post.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now to the last requirement for a monoid: identity.'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, identity is not always needed, but it is nice to have if you
    might be dealing with empty lists.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: For numeric values, finding an identity for an operation is generally easy,
    whether it be `0` (addition), `1` (multiplication) or `Int32.MinValue` (max).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: And this carries over to structures that contain only numeric values as well
    -- just set all values to their appropriate identity. The `CustomerStats` type
    from the previous post demonstrates that nicely.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: But what if you have objects that are not numeric? How can you create a "zero"
    or identity element if there is no natural candidate?
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is: *you just make one up*.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Seriously!
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen an example of this in the previous post, when we added
    an `EmptyOrder` case to the `OrderLine` type:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s look at this more closely. We performed two steps:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: First, we created a new case and added it to the list of alternatives for an
    `OrderLine` (as shown above).
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we adjusted the `addLine` function to take it into account (as shown
    below).
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: That's all there is to it.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: The new, augmented type consists of the old order line cases, *plus* the new
    `EmptyOrder` case, and so it can reuse much of the behavior of the old cases.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: In particular, can you see that the new augmented type follows all the monoid
    rules?
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: A pair of values of the new type can be added to get another value of the new
    type (closure)
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the combination order didn't matter for the old type, then it still doesn't
    matter for the new type (associativity)
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally... this extra case now gives us an identity for the new type.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning PositiveNumber into a monoid
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could do the same thing with the other semigroups we've seen.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we noted earlier that strictly positive numbers (under addition)
    didn''t have an identity; they are only a semigroup. If we wanted to create a
    zero using the "augmentation with extra case" technique (rather than just using
    `0`!) we would first define a special `Zero` case (not an integer), and then create
    an `addPositive` function that can handle it, like this:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Admittedly, `PositiveNumberOrIdentity` is a contrived example, but you can see
    how this same approach would work for any situation where you have "normal" values
    and a special, separate, zero value.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: A generic solution
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a few drawbacks to this:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to deal with *two* cases now: the normal case and the zero case.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to create custom types and custom addition functions
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, there's nothing you can do about the first issue. If you have
    a system with no natural zero, and you create an artificial one, then you will
    indeed always have to deal with two cases.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'But there *is* something you can do about the second issue! Rather than create
    a new custom type over and over, perhaps can we create a *generic* type that has
    two cases: one for all normal values and one for the artificial zero, like this:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Does this type look familiar? It's just the **Option type** in disguise!
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: In other words, any time we need an identity which is outside the normal set
    of values, we can use `Option.None` to represent it. And then `Option.Some` is
    used for all the other "normal" values.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'Another benefit of using `Option` is that we can also write a completely generic
    "add" function as well. Here''s a first attempt:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The logic is straightforward. If either option is `None`, the other option is
    returned. If both are `Some`, then they are unwrapped, added together, and then
    wrapped in a `Some` again.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: 'But the `+` in the last line makes assumptions about the types that we are
    adding. Better to pass in the addition function explicitly, like this:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In practice, this would used with partial application to bake in the addition
    function.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we have another important tip:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '**DESIGN TIP: To get identity for an operation, create a special case in a
    discriminated union, or, even simpler, just use Option.**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PositiveNumber revisited
  id: totrans-631
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So here is the Positive Number example again, now using the `Option` type.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Much simpler!
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we pass in the "real" addition function as a parameter to `optionAdd`
    so that it is baked in. In other situations, you would do the same with the relevant
    aggregation function that is associated with the semigroup.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result of this partial application, `addPositive` has the signature: `int
    option -> int option -> int option`, which is exactly what we would expect from
    a monoid addition function.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: In other words, `optionAdd` turns any function `'a -> 'a -> 'a` into the *same*
    function, but "lifted" to the option type, that is, having a signature `'a option
    -> 'a option -> 'a option` .
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s test it! Some test code might look like this:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You can see that unfortunately we do have to wrap the normal values in `Some`
    in order to get the `None` as identity.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: That sounds tedious but in practice, it is easy enough. The code below shows
    how we might handle the two distinct cases when summing a list. First how to sum
    a non-empty list, and then how to sum an empty list.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: ValidationResult revisited
  id: totrans-643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s also revisit the `ValidationResult` type that we
    described earlier when talking about using lists to get closure. Here it is again:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Now that we've got some insight into the positive integer case, let's look at
    this type from a different angle as well.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: The type has two cases. One case holds data that we care about, and the other
    case holds no data. But the data we really care about are the error messages,
    not the success. As Leo Tolstoy nearly said "All validation successes are alike;
    each validation failure is a failure in its own way."
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'So, rather than thinking of it as a "Result", let''s think of the type as *storing
    failures*, and rewrite it like this instead, with the failure case first:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Does this type appear familar now?
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: Yes! It's the option type again! Can we never get away from the darn thing?
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the option type, we can simplify the design of the `ValidationFailure`
    type to just this:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The helper to convert a string into the failure case is now just `Some` with
    a list:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'And the "add" function can reuse `optionAdd`, but this time with list concatenation
    as the underlying operation:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Finally, the "zero" that was the `Success` case in the original design now simply
    becomes `None` in the new design.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Here's all the code, plus tests
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Summary of the design tips
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's pause for a second and see what we have covered so far.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are all the design tips together:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: To easily create a monoidal type, make sure that each field of the type is also
    a monoid.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable closure for a non-numeric type, replace single items with lists (or
    a similar data structure).
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get associativity for an operation, try to move the operation into the object.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get identity for an operation, create a special case in a discriminated union,
    or, even simpler, just use Option.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next two sections, we''ll apply these tips to two of the non-monoids
    that we have seen in previous posts: "average" and "most frequent word".'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: 'A case study: Average'
  id: totrans-669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So now we have the toolkit that will enable us to deal with the thorny case
    of averages.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple implementation of a pairwise average function:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: As we mentioned briefly in the first post, `avg` fails on all three monoid requirements!
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: First, it is not closed. Two ints that are combined together using `avg` do
    not result in another int.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, even if it was closed, `avg` is not associative, as we can see by defining
    a similar float function `avgf`:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Finally, there is no identity.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'What number, when averaged with any other number, returns the original value?
    Answer: none!'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: Applying the design tips
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So let's apply the design tips to see if they help us come up with a solution.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '*To easily create a monoidal type, make sure that each field of the type is
    also a monoid.*'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, "average" is a mathematical operation, so we could expect that a monoidal
    equivalent would also be based on numbers.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '*To enable closure for a non-numeric type, replace single items with lists.*'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This looks at first glance like it won't be relevant, so we'll skip this for
    now.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '*To get associativity for an operation, try to move the operation into the
    object.*'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's the crux! How do we convert "average" from a verb (an operation) to a
    noun (a data structure)?
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we create a structure that is not actually an average, but
    a "delayed average" -- everything you need to make an average on demand.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we need a data structure with *two* components: a total, and a count.
    With these two numbers we can calculate an average as needed.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The good thing about this, is that structure stores `ints`, not `floats`, so
    we don't need to worry about loss of precision or associativity of floats.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'The last tip is:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '*To get identity for an operation, create a special case in a discriminated
    union, or, even simpler, just use Option.*'
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, the tip is not needed, as we can easily create a zero by setting
    the two components to be zero:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We could also have used `None` for the zero, but it seems like overkill in this
    case. If the list is empty, the `Avg` result is valid, even though we can't do
    the division.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have had this insight into the data structure, the rest of the implementation
    follows easily. Here is all the code, plus some tests:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In the code above, you can see that I created a `calcAvg` function that uses
    the `Avg` structure to calculate a (floating point) average. One nice thing about
    this approach is that we can delay having to make a decision about what to do
    with a zero divisor. We can just return `0`, or alternatively `None`, or we can
    just postpone the calculation indefinitely, and only generate the average at the
    last possible moment, on demand!
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: And of course, this implementation of "average" has the ability to do incremental
    averages. We get this for free because it is a monoid.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: That is, if I have already calculated the average of a million numbers, and
    I want to add one more, I don't have to recalculate everything, I can just add
    the new number to the totals so far.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: A slight diversion on metrics
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have ever been responsible for managing any servers or services, you
    will be aware of the importance of logging and monitoring metrics, such as CPU,
    I/O, etc.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: One of the questions you often face then is how to design your metrics. Do you
    want kilobytes per second, or just total kilobytes since the server started. Visitors
    per hour, or total visitors?
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: If you look at some [guidelines when creating metrics](http://opentsdb.net/metrics.html)
    you will see the frequent recommendation to only track metrics that are *counters*,
    not *rates*.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of counters is that (a) missing data doesn't affect the big picture,
    and (b) they can be aggregated in many ways after the fact -- by minute, by hour,
    as a ratio with something else, and so on.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have worked through this series, you can see that the recommendation
    can really be rephrased as **metrics should be monoids**.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: The work we did in the code above to transform "average" into two components,
    "total" and "count", is exactly what you want to do to make a good metric.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: Averages and other rates are not monoids, but "total" and "count" are, and then
    "average" can be calculated from them at your leisure.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: 'Case study: Turning "most frequent word" into a monoid homomorphism'
  id: totrans-709
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last post, we implemented a "most frequent word" function, but found
    that it wasn't a monoid homomorphism. That is,
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'did *not* give the same result as:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Again, we can use the design tips to fix this up so that it works.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: The insight here is again to delay the calculation until the last minute, just
    as we did in the "average" example.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: Rather than calculating the most frequent word upfront then, we create a data
    structure that stores all the information that we need to calculate the most frequent
    word later.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In the code above we have a new function `wordFreq`, that returns a `Map<string,int>`
    rather just a single word. That is, we are now working with dictionaries, where
    each slot has a word and its associated frequency.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a demonstration of how it works:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: With this map structure in place, we can create a function `addMap` to add two
    maps. It simply merges the frequency counts of the words from both maps.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: And when we have combined all the maps together, we can then calculate the most
    frequent word by looping through the map and finding the word with the largest
    frequency.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: So, here are the two scenarios revisited using the new approach.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: The first scenario combines all the pages into a single text, then applies `wordFreq`
    to get a frequency map, and applies `mostFrequentWord` to get the most frequent
    word.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: The second scenario applies `wordFreq` to each page separately to get a map
    for each page. These maps are then combined with `addMap` to get a single global
    map. Then `mostFrequentWord` is applied as the last step, as before.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: If you run this code, you will see that you now get the *same* answer.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: This means that `wordFreq` is indeed a monoid homomorphism, and is suitable
    for running in parallel, or incrementally.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Next time
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen a lot of code in this post, but it has all been focused on data structures.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: However, there is nothing in the definition of a monoid that says that the things
    to be combined have to be data structures -- they could be *anything at all*.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: In the next post we'll look at monoids applied to other objects, such as types,
    functions, and more.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: On Performance'
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the examples above, I have made frequent use of `@` to "add" two lists in
    the same way that `+` adds two numbers. I did this to highlight the analogies
    with other monoidal operations such as numeric addition and string concatenation.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: I hope that it is clear that the code samples above are meant to be teaching
    examples, not necessarily good models for the kind of real-world, battle-hardened,
    and all-too-ugly code you need in a production environment.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: A couple of people have pointed out that using List append (`@`) should be avoided
    in general. This is because the entire first list needs to be copied, which is
    not very efficient.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: By far the best way to add something to a list is to add it to the front using
    the so-called "cons" mechanism, which in F# is just `::`. F# lists are implemented
    as linked lists, so adding to the front is very cheap.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: The problem with using this approach is that it is not symmetrical -- it doesn't
    add two lists together, just a list and an element. This means that it cannot
    be used as the "add" operation in a monoid.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: If you don't need the benefits of a monoid, such as divide and conquer, then
    that is a perfectly valid design decision. No need to sacrifice performance for
    a pattern that you are not going to benefit from.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: The other alternative to using `@` is to not use lists in the first place!
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to lists
  id: totrans-743
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `ValidationResult` design, I used a list to hold the error results so
    that we could get easy accumulation of the results. But I only chose the `list`
    type because it is really the default collection type in F#. I could have equally
    well have chosen sequences, or arrays, or sets. Almost any other collection type
    would have done the job just as well.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: But not all types will have the same performance. For example, combining two
    sequences is a lazy operation. You don't have to copy all the data; you just enumerate
    one sequence, then the other. So that might be faster perhaps?
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: Rather than guessing, I wrote a little test script to measure performance at
    various list sizes, for various collection types.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'I have chosen a very simple model: we have a list of objects, each of which
    is a collection containing *one* item. We then reduce this list of collections
    into a single giant collection using the appropriate monoid operation. Finally,
    we iterate over the giant collection once.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to the `ValidationResult` design, where we would combine
    all the results into a single list of results, and then (presumably) iterate over
    them to show the errors.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: It is also similar to the "most frequent word" design, above, where we combine
    all the individual frequency maps into a single frequency map, and then iterate
    over it to find the most frequent word. In that case, of course, we were using
    `map` rather than `list`, but the set of steps is the same.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: A performance experiment
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ok, here''s the code:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Let''s go through the code quickly:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: The `time` function times the reduce and iteration steps. It deliberately does
    not test how long it takes to create the collection. I do perform a GC before
    starting, but in reality, the memory pressure that a particular type or algorithm
    causes is an important part of the decision to use it (or not). [Understanding
    how GC works](https://www.simple-talk.com/dotnet/.net-framework/5-tips-and-techniques-for-avoiding-automatic-gc-collections/)
    is an important part of getting performant code.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `testListPerformance` function sets up the list of collections (lists in
    this case) and also the `reduce` and `iter` functions. It then runs the timer
    on `reduce` and `iter`.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other functions do the same thing, but with sequences, arrays, and ResizeArrays
    (standard .NET Lists). Out of curiosity, I thought I'd test two ways of merging
    sequences, one using the standard library function `Seq.append` and the other
    using two `yield!`s in a row.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `testResizeArrayPerformance` uses ResizeArrays and adds the right list to
    the left one. The left one mutates and grows larger as needed, using a [growth
    strategy](http://stackoverflow.com/questions/1665298/listt-and-arraylist-default-capacity/1665325#1665325)
    that keeps inserts efficient.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's write code to check the performance on various sized lists. I chose
    to start with a count of 2000 and move by increments of 4000 up to 50000.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: I won't list all the detailed output -- you can run the code for yourself --
    but here is a chart of the results.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '![monoid performance](monoid_performance.jpg)'
  id: totrans-761
  prefs: []
  type: TYPE_IMG
- en: 'There are a few things to note:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: The two sequence-based examples crashed with stack overflows. The `yield!` was
    about 30% faster than `Seq.append`, but also ran out of stack faster.
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List.append didn't run out of stack, but got much slower as the lists got larger.
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array.append was fast, and increases more slowly with the size of the list
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ResizeArray was fastest of all, and didn't break a sweat even with large lists.
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the three collection types that didn''t crash, I also timed them for a
    list of 100K items. The results were:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: List = 150,730 ms
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array = 26,062 ms
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ResizeArray = 33 ms
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clear winner there, then.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the results
  id: totrans-772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What conclusion can we draw from this little experiment?
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you might have all sorts of questions, such as: Were you running in
    debug or release mode? Did you have optimization turned on? What about using parallelism
    to increase performance? And no doubt, there will be comments saying "why did
    you use technique X, technique Y is so much better".'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: 'But here''s the conclusion I would like to make:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '**You cannot draw any conclusion from these results!**'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every situation is different and requires a different approach:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with small data sets you might not care about performance
    anyway. In this case I would stick with lists -- I'd rather not sacrifice pattern
    matching and immutability unless I have to.
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance bottleneck might not be in the list addition code. There is
    no point working on optimizing the list addition if you are actually spending
    all your time on disk I/O or network delays. A real-world version of the word
    frequency example might actually spend most of its time doing reading from disk,
    or parsing, rather than adding lists.
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you working at the scale of Google, Twitter, or Facebook, you really need
    to go and hire some algorithm experts.
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only principles that we can take away from any discussion on optimization
    and performance are:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '**A problem must be dealt with in its own context.** The size of the data being
    processed, the type of hardware, the amount of memory, and so on. All these will
    make a difference to your performance. What works for me may not work for you,
    which is why...'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You should always measure, not guess.** Don''t make assumptions about where
    your code is spending its time -- learn to use a profiler! There are some good
    examples of using a profiler [here](http://moiraesoftware.com/blog/2012/07/15/the-lurking-horror/)
    and [here](http://moiraesoftware.com/blog/2011/12/11/fixing-a-hole/).'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Be wary of micro-optimizations**. Even if your profiler shows that your sorting
    routine spends all its time in comparing strings, that doesn''t necessarily mean
    that you need to improve your string comparison function. You might be better
    off improving your algorithm so that you don''t need to do so many comparisons
    in the first place. [Premature optimization](http://programmers.stackexchange.com/a/79954/44643)
    and all that.'
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
