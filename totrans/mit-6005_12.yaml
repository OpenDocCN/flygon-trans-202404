- en: 'Reading 12: Abstraction Functions & Rep Invariants'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读12：抽象函数和表示不变性
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| 免于错误 | 易于理解 | 准备好变化 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确，未来也正确。 | 与未来的程序员清晰沟通，包括未来的你。 | 设计以适应变化而无需重写。 |'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: 'Today’s reading introduces several ideas:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的阅读介绍了几个想法：
- en: invariants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变性
- en: representation exposure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示曝光
- en: abstraction functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象函数
- en: representation invariants
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示不变性
- en: In this reading, we study a more formal mathematical idea of what it means for
    a class to implement an ADT, via the notions of *abstraction functions* and *rep
    invariants*. These mathematical notions are eminently practical in software design.
    The abstraction function will give us a way to cleanly define the equality operation
    on an abstract data type (which we’ll discuss in more depth in a future class).
    The rep invariant will make it easier to catch bugs caused by a corrupted data
    structure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇阅读中，我们研究了一个更正式的数学概念，即类如何实现ADT，通过*抽象函数*和*表示不变性*的概念。 这些数学概念在软件设计中非常实用。 抽象函数将为我们提供一种清晰地定义抽象数据类型上的相等操作的方式（我们将在未来的课程中更深入地讨论）。
    表示不变性将使我们更容易捕捉由损坏的数据结构引起的错误。
- en: Invariants
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不变性
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,invariants/P_1Tz_FyYn0)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,invariants/P_1Tz_FyYn0)'
- en: 'Resuming our discussion of what makes a good abstract data type, the final,
    and perhaps most important, property of a good abstract data type is that it **preserves
    its own invariants**. An *invariant* is a property of a program that is always
    true, for every possible runtime state of the program. Immutability is one crucial
    invariant that we’ve already encountered: once created, an immutable object should
    always represent the same value, for its entire lifetime. Saying that the ADT
    *preserves its own invariants* means that the ADT is responsible for ensuring
    that its own invariants hold. It doesn’t depend on good behavior from its clients.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们关于什么构成良好的抽象数据类型的讨论，一个良好的抽象数据类型的最终，也许是最重要的特性是它**保持自身的不变性**。 *不变性* 是程序的一个属性，对于程序的每一个可能的运行时状态，它总是成立的。
    不变性是我们已经遇到的一个至关重要的不变性：一旦创建，一个不可变对象应始终表示相同的值，直到其整个生命周期。说ADT *保持自身的不变性* 意味着ADT负责确保其自身的不变性保持不变。
    它不依赖于其客户端的良好行为。
- en: When an ADT preserves its own invariants, reasoning about the code becomes much
    easier. If you can count on the fact that Strings never change, you can rule out
    that possibility when you’re debugging code that uses Strings – or when you’re
    trying to establish an invariant for another ADT that uses Strings. Contrast that
    with a string type that guarantees that it will be immutable only if its clients
    promise not to change it. Then you’d have to check all the places in the code
    where the string might be used.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个ADT保持自身的不变性时，对代码进行推理就变得更容易。 如果你可以确信字符串永远不会改变，那么当你调试使用字符串的代码时，或者当你试图为使用字符串的另一个ADT建立不变性时，你就可以排除这种可能性。
    与一个只在其客户端承诺不更改它时才保证它是不可变的字符串类型相比。 然后你就必须检查代码中可能使用字符串的所有地方。
- en: Immutability
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不变性
- en: 'Later in this reading, we’ll see many interesting invariants. Let’s focus on
    immutability for now. Here’s a specific example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇阅读的后面，我们将看到许多有趣的不变性。 现在让我们专注于不变性。 这里有一个具体的例子：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How do we guarantee that these Tweet objects are immutable – that, once a tweet
    is created, its author, message, and date can never be changed?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保这些Tweet对象是不可变的——即，一旦创建了一条推文，其作者、消息和日期就永远不能更改？
- en: 'The first threat to immutability comes from the fact that clients can — in
    fact must — directly access its fields. So nothing’s stopping us from writing
    code like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性的第一个威胁来自于客户端可以——事实上必须——直接访问其字段的事实。 因此，没有什么能阻止我们编写这样的代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a trivial example of **representation exposure**, meaning that code
    outside the class can modify the representation directly. Rep exposure like this
    threatens not only invariants, but also representation independence. We can’t
    change the implementation of Tweet without affecting all the clients who are directly
    accessing those fields.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是**表示暴露**的一个微不足道的例子，意味着类外部的代码可以直接修改表示。这种rep暴露不仅威胁不变性，还威胁表示独立性。我们无法更改Tweet的实现而不影响直接访问这些字段的所有客户端。
- en: 'Fortunately, Java gives us language mechanisms to deal with this kind of rep
    exposure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Java为我们提供了处理这种rep暴露的语言机制：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `private` and `public` keywords indicate which fields and methods are accessible
    only within the class and which can be accessed from outside the class. The `final`
    keyword also helps by guaranteeing that the fields of this immutable type won’t
    be reassigned after the object is constructed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`和`public`关键字指示哪些字段和方法仅在类内部可访问，哪些可以从类外部访问。`final`关键字还有助于保证这种不可变类型的字段在对象构造后不会被重新分配。'
- en: '![retweetLater breaking Tweet''s immutability](../Images/d411b72d2f11f7d79fbe3b35c30cf4cb.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![retweetLater破坏了Tweet的不可变性](../Images/d411b72d2f11f7d79fbe3b35c30cf4cb.jpg)'
- en: 'But that’s not the end of the story: the rep is still exposed! Consider this
    perfectly reasonable client code that uses `Tweet`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但这还不是故事的结局：rep仍然暴露！考虑这段使用`Tweet`的完全合理的客户端代码：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`retweetLater` takes a tweet and should return another tweet with the same
    message (called a *retweet*) but sent an hour later. The `retweetLater` method
    might be part of a system that automatically echoes funny things that Twitter
    celebrities say.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`retweetLater`接受一个tweet，并应该返回另一个消息相同（称为*转推*）但晚一个小时发送的tweet。`retweetLater`方法可能是一个自动回声Twitter名人说的有趣事情的系统的一部分。'
- en: What’s the problem here? The `getTimestamp` call returns a reference to the
    same `Date` object referenced by tweet `t`. `t.timestamp` and `d` are aliases
    to the same mutable object. So when that date object is mutated by `d.setHours()`,
    this affects the date in `t` as well, as shown in the snapshot diagram.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是什么？`getTimestamp`调用返回了一个对tweet `t`引用的相同`Date`对象的引用。`t.timestamp`和`d`是指向同一可变对象的别名。因此，当该日期对象被`d.setHours()`改变时，这也会影响到`t`中的日期，如快照图中所示。
- en: '`Tweet`’s immutability invariant has been broken. The problem is that `Tweet`
    leaked out a reference to a mutable object that its immutability depended on.
    We exposed the rep, in such a way that `Tweet` can no longer guarantee that its
    objects are immutable. Perfectly reasonable client code created a subtle bug.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tweet`的不可变性不变式已经被破坏。问题在于`Tweet`泄漏了对一个可变对象的引用，其不可变性依赖于此。我们暴露了rep，以至于`Tweet`无法再保证其对象是不可变的。完全合理的客户端代码造成了一个微妙的错误。'
- en: 'We can patch this kind of rep exposure by using defensive copying: making a
    copy of a mutable object to avoid leaking out references to the rep. Here’s the
    code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用防御性复制来修补这种rep暴露：复制可变对象以避免泄漏对rep的引用。以下是代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Mutable types often have a copy constructor that allows you to make a new instance
    that duplicates the value of an existing instance. In this case, `Date`’s copy
    constructor uses the timestamp value, measured in milliseconds since January 1,
    1970\. As another example, `StringBuilder`’s copy constructor takes a `String`.
    Another way to copy a mutable object is `clone()`, which is supported by some
    types but not all. There are unfortunate problems with the way `clone()` works
    in Java. For more, see Josh Bloch, [*Effective Java*](http://library.mit.edu/item/001484188),
    item 11\.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可变类型通常有一个复制构造函数，允许您创建一个新实例，复制现有实例的值。在这种情况下，`Date`的复制构造函数使用自1970年1月1日以来以毫秒为单位测量的时间戳值。另一个例子，`StringBuilder`的复制构造函数接受一个`String`。复制可变对象的另一种方法是`clone()`，它受到一些类型支持，但并非所有类型都支持。在Java中，`clone()`的工作方式存在一些不幸的问题。更多信息，请参见Josh
    Bloch的[*Effective Java*](http://library.mit.edu/item/001484188)，第11项。
- en: '![tweetEveryHourToday breaking Tweet''s immutability](../Images/ab178e007a13b5713eb43bca08ba5d2a.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![tweetEveryHourToday破坏了Tweet的不可变性](../Images/ab178e007a13b5713eb43bca08ba5d2a.jpg)'
- en: 'So we’ve done some defensive copying in the return value of `getTimestamp`.
    But we’re not done yet! There’s still rep exposure. Consider this (again perfectly
    reasonable) client code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`getTimestamp`的返回值中进行了一些防御性复制。但我们还没有完成！仍然存在rep暴露。考虑这段（再次完全合理的）客户端代码：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code intends to advance a single `Date` object through the 24 hours of
    a day, creating a tweet for every hour. But notice that the constructor of Tweet
    saves the reference that was passed in, so all 24 Tweet objects end up with the
    same time, as shown in this snapshot diagram.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码旨在通过一天的24小时推进单个`Date`对象，为每个小时创建一条推文。但请注意，Tweet 的构造函数保存了传入的引用，因此所有 24 个 Tweet
    对象最终都具有相同的时间，如此快照图所示。
- en: 'Again, the immutability of Tweet has been violated. We can fix this problem
    too by using judicious defensive copying, this time in the constructor:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Tweet 的不可变性已经被违反。我们也可以通过谨慎的防御性复制来解决这个问题，这次在构造函数中：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In general, you should carefully inspect the argument types and return types
    of all your ADT operations. If any of the types are mutable, make sure your implementation
    doesn’t return direct references to its representation. Doing that creates rep
    exposure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应该仔细检查所有 ADT 操作的参数类型和返回类型。如果任何类型是可变的，请确保你的实现不返回对其表示的直接引用。这样做会暴露 rep。
- en: You may object that this seems wasteful. Why make all these copies of dates?
    Why can’t we just solve this problem by a carefully written specification, like
    this?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这样做很浪费。为什么要复制所有这些日期？为什么我们不能通过一个精心编写的规范来解决这个问题，比如这样？
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This approach is sometimes taken when there isn’t any other reasonable alternative
    – for example, when the mutable object is too large to copy efficiently. But the
    cost in your ability to reason about the program, and your ability to avoid bugs,
    is enormous. In the absence of compelling arguments to the contrary, it’s almost
    always worth it for an abstract data type to guarantee its own invariants, and
    preventing rep exposure is essential to that.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有其他合理的选择时，有时会采用这种方法——例如，当可变对象太大而无法有效地复制时。但是，这样做的代价是你对程序的推理能力和避免错误的能力是巨大的。在没有令人信服的反对意见的情况下，一个抽象数据类型几乎总是值得保证其自己的不变量，防止
    rep 暴露对此至关重要。
- en: An even better solution is to prefer immutable types. If – as recommended in
    [*Mutability & Immutability*’s Groundhog Day example](../09-immutability/#risky_example_2_returning_mutable_values)
    – we had used an immutable date object, like `java.time.ZonedDateTime`, instead
    of the mutable `java.util.Date`, then we would have ended this section after talking
    about `public` and `private`. No further rep exposure would have been possible.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是更喜欢不可变类型。如果——正如[*可变性与不可变性*中的《土拨鼠日》示例](../09-immutability/#risky_example_2_returning_mutable_values)建议的那样——我们使用了不可变的日期对象，比如`java.time.ZonedDateTime`，而不是可变的`java.util.Date`，那么在讨论完`public`和`private`后，我们会结束这一节。没有进一步的
    rep 暴露会发生。
- en: Immutable Wrappers Around Mutable Data Types
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变包装器围绕可变数据类型
- en: 'The Java collections classes offer an interesting compromise: immutable wrappers.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Java 集合类提供了一个有趣的折衷方案：不可变包装器。
- en: '`Collections.unmodifiableList()` takes a (mutable) `List` and wraps it with
    an object that looks like a `List`, but whose mutators are disabled – `set()`,
    `add()`, `remove()`, etc. throw exceptions. So you can construct a list using
    mutators, then seal it up in an unmodifiable wrapper (and throw away your reference
    to the original mutable list, as discussed in [*Mutability & Immutability*](../09-immutability/#useful_immutable_types)),
    and get an immutable list.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collections.unmodifiableList()`接受一个（可变的）`List`并用看起来像一个`List`的对象包装它，但其 mutator
    被禁用——`set()`、`add()`、`remove()`等会抛出异常。因此，你可以使用 mutator 构造一个列表，然后将其封装在一个不可修改的包装器中（并且丢弃对原始可变列表的引用，如[*可变性与不可变性*](../09-immutability/#useful_immutable_types)中所讨论的），并获得一个不可变的列表。'
- en: The downside here is that you get immutability at runtime, but not at compile
    time. Java won’t warn you at compile time if you try to `sort()` this unmodifiable
    list. You’ll just get an exception at runtime. But that’s still better than nothing,
    so using unmodifiable lists, maps, and sets can be a very good way to reduce the
    risk of bugs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的缺点是你在运行时获得了不可变性，但在编译时却没有。如果你尝试对这个不可修改的列表进行`sort()`，Java 不会在编译时警告你。你只会在运行时得到一个异常。但这仍然比没有好，因此使用不可修改的列表、映射和集合可以是减少错误风险的一种非常好的方式。
- en: reading exercises
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取练习
- en: Rep exposure
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Rep 暴露
- en: 'Consider the following problematic datatype:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题数据类型：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (missing answer)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）
- en: (missing explanation)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Rep Invariant and Abstraction Function
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rep 不变式和抽象函数
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,rep_invariant_and_abstraction_function/59458ynxYPk)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,rep_invariant_and_abstraction_function/59458ynxYPk)'
- en: We now take a deeper look at the theory underlying abstract data types. This
    theory is not only elegant and interesting in its own right; it also has immediate
    practical application to the design and implementation of abstract types. If you
    understand the theory deeply, you’ll be able to build better abstract types, and
    will be less likely to fall into subtle traps.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入研究抽象数据类型的理论基础。这个理论不仅本身优雅而且有趣；它还直接应用于抽象类型的设计和实现。如果你深刻理解了这个理论，你将能够构建更好的抽象类型，并且不太可能陷入微妙的陷阱。
- en: In thinking about an abstract type, it helps to consider the relationship between
    two spaces of values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑抽象类型时，考虑两个值空间之间的关系会有所帮助。
- en: The space of representation values (or rep values for short) consists of the
    values of the actual implementation entities. In simple cases, an abstract type
    will be implemented as a single object, but more commonly a small network of objects
    is needed, so this value is actually often something rather complicated. For now,
    though, it will suffice to view it simply as a mathematical value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表示值空间（或简称为 rep 值）由实际实现实体的值组成。在简单的情况下，抽象类型将被实现为单个对象，但更常见的是需要一个小型对象网络，因此此值实际上通常是相当复杂的。不过，就目前而言，将其简单地视为数学值就足够了。
- en: The space of abstract values consists of the values that the type is designed
    to support. These are a figment of our imaginations. They’re platonic entities
    that don’t exist as described, but they are the way we want to view the elements
    of the abstract type, as clients of the type. For example, an abstract type for
    unbounded integers might have the mathematical integers as its abstract value
    space; the fact that it might be implemented as an array of primitive (bounded)
    integers, say, is not relevant to the user of the type.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象值空间由类型设计支持的值组成。这些是我们想象的东西。它们是不存在的柏拉图实体，但它们是我们想要以抽象类型的客户端的方式来看待抽象类型元素的方式。例如，用于无界整数的抽象类型可能将数学整数作为其抽象值空间；它可能被实现为原始（有界）整数的数组，例如，这一事实与类型的用户无关。
- en: Now of course the implementor of the abstract type must be interested in the
    representation values, since it is the implementor’s job to achieve the illusion
    of the abstract value space using the rep value space.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，抽象类型的实现者必须对表示值感兴趣，因为实现者的工作是使用 rep 值空间实现抽象值空间的错觉。
- en: 'Suppose, for example, that we choose to use a string to represent a set of
    characters:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们选择使用字符串来表示一组字符：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![the abstract space and rep space of CharSet](../Images/abdc98d9c81246803b0c92c04fb57f19.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![CharSet 的抽象空间和表示空间](../Images/abdc98d9c81246803b0c92c04fb57f19.jpg)'
- en: 'Then the rep space R contains Strings, and the abstract space A is mathematical
    sets of characters. We can show the two value spaces graphically, with an arc
    from a rep value to the abstract value it represents. There are several things
    to note about this picture:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后表示空间 R 包含字符串，抽象空间 A 是数学字符集。我们可以用图形方式显示两个值空间，从 rep 值到它表示的抽象值的弧。关于这张图片有几点需要注意：
- en: '**Every abstract value is mapped to by some rep value**. The purpose of implementing
    the abstract type is to support operations on abstract values. Presumably, then,
    we will need to be able to create and manipulate all possible abstract values,
    and they must therefore be representable.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个抽象值都有其对应的表示值**。实现抽象类型的目的是支持对抽象值进行操作。因此，我们可能需要能够创建和操作所有可能的抽象值，因此它们必须是可表示的。'
- en: '**Some abstract values are mapped to by more than one rep value**. This happens
    because the representation isn’t a tight encoding. There’s more than one way to
    represent an unordered set of characters as a string.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有些抽象值被多个表示值映射到**。这是因为表示不是紧密编码的。有多种方法将无序字符集表示为字符串。'
- en: '**Not all rep values are mapped**. In this case, the string “abbc” is not mapped.
    In this case, we have decided that the string should not contain duplicates. This
    will allow us to terminate the remove method when we hit the first instance of
    a particular character, since we know there can be at most one.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并非所有的 rep 值都被映射**。在这种情况下，字符串“abbc”没有被映射。在这种情况下，我们决定字符串不应该包含重复项。这将使我们能够在遇到特定字符的第一个实例时终止删除方法，因为我们知道最多只能有一个。'
- en: 'In practice, we can only illustrate a few elements of the two spaces and their
    relationships; the graph as a whole is infinite. So we describe it by giving two
    things:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们只能说明两个空间及其关系的一些元素；整个图是无限的。因此，我们通过提供两个内容来描述它：
- en: '1\. An *abstraction function* that maps rep values to the abstract values they
    represent:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 将 rep 值映射到它们表示的抽象值的*抽象函数*：
- en: 'AF : R → A'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: AF：R → A
- en: The arcs in the diagram show the abstraction function. In the terminology of
    functions, the properties we discussed above can be expressed by saying that the
    function is surjective (also called *onto*), not necessarily injective (*one-to-one*)
    and therefore not necessarily bijective, and often partial.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的弧线显示了抽象函数。在函数术语中，我们上面讨论的属性可以通过说函数是满射（也称为*到*）、不一定是单射（*一对一*）以及因此不一定是双射，通常是部分的方式来表达。
- en: '2\. A *rep invariant* that maps rep values to booleans:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 将 rep 值映射到布尔值的*rep 不变量*：
- en: 'RI : R → boolean'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RI：R → 布尔值
- en: 'For a rep value *r*, *RI(r)* is true if and only if *r* is mapped by *AF*.
    In other words, *RI* tells us whether a given rep value is well-formed. Alternatively,
    you can think of *RI* as a set: it’s the subset of rep values on which *AF* is
    defined.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 rep 值 *r*，*RI(r)* 当且仅当 *r* 被 *AF* 映射时为真。换句话说，*RI* 告诉我们给定的 rep 值是否合法。或者，你可以将
    *RI* 看作一个集合：它是 *AF* 定义的 rep 值的子集。
- en: '![the abstract space and rep space of CharSet using the NoRepeatsRep](../Images/1f30c7e11f8274498c20616e542ce4d0.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用 NoRepeatsRep 的 CharSet 的抽象空间和 rep 空间](../Images/1f30c7e11f8274498c20616e542ce4d0.jpg)'
- en: 'Both the rep invariant and the abstraction function should be documented in
    the code, right next to the declaration of the rep itself:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，不变量和抽象函数应该与 rep 的声明紧邻：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A common confusion about abstraction functions and rep invariants is that they
    are determined by the choice of rep and abstract value spaces, or even by the
    abstract value space alone. If this were the case, they would be of little use,
    since they would be saying something redundant that’s already available elsewhere.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 关于抽象函数和 rep 不变量的一个常见误解是它们由 rep 和抽象值空间的选择，甚至仅由抽象值空间确定。如果是这样，它们将毫无用处，因为它们将重复地表达一些已经在其他地方可用的内容。
- en: 'The abstract value space alone doesn’t determine AF or RI: there can be several
    representations for the same abstract type. A set of characters could equally
    be represented as a string, as above, or as a bit vector, with one bit for each
    possible character. Clearly we need two different abstraction functions to map
    these two different rep value spaces.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 单靠抽象值空间无法确定 AF 或 RI：相同抽象类型可能有多种表示方法。一组字符可以等同地表示为一个字符串，如上所示，也可以表示为一个位向量，每个可能的字符对应一个位。显然，我们需要两个不同的抽象函数来映射这两个不同的
    rep 值空间。
- en: 'It’s less obvious why the choice of both spaces doesn’t determine AF and RI.
    The key point is that defining a type for the rep, and thus choosing the values
    for the space of rep values, does not determine which of the rep values will be
    deemed to be legal, and of those that are legal, how they will be interpreted.
    Rather than deciding, as we did above, that the strings have no duplicates, we
    could instead allow duplicates, but at the same time require that the characters
    be sorted, appearing in nondecreasing order. This would allow us to perform a
    binary search on the string and thus check membership in logarithmic rather than
    linear time. Same rep value space – different rep invariant:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择两个空间都无法确定 AF 和 RI 不太明显。关键点在于，为 rep 定义类型，从而选择 rep 值空间的值，并不确定哪些 rep 值将被视为合法，以及其中合法的值将如何解释。与我们上面所做的决定字符串没有重复不同，我们可以允许重复，但同时要求字符按非递减顺序排序。这样可以让我们在字符串上执行二分搜索，从而以对数时间而不是线性时间检查成员资格。相同的
    rep 值空间 - 不同的 rep 不变量：
- en: '![the abstract space and rep space of CharSet using the SortedRep](../Images/987941ed6b9a03c7ddcccf94f9b97fec.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SortedRep 的 CharSet 的抽象空间和 rep 空间](../Images/987941ed6b9a03c7ddcccf94f9b97fec.jpg)'
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What rep values map to abstract value {a,b,c} in this representation?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表示法中，哪些 `rep` 值映射到抽象值 `{a,b,c}`？
- en: 'Even with the same type for the rep value space and the same rep invariant
    RI, we might still interpret the rep differently, with different abstraction functions
    AF. Suppose RI admits any string of characters. Then we could define AF, as above,
    to interpret the array’s elements as the elements of the set. But there’s no *a
    priori* reason to let the rep decide the interpretation. Perhaps we’ll interpret
    consecutive pairs of characters as subranges, so that the string rep `"acgg"`
    is interpreted as two range pairs, [a-c] and [g-g], and therefore represents the
    set {a,b,c,g}. Here’s what the AF and RI would look like for that representation:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于表示值空间和相同的表示不变式 RI 使用相同类型，我们仍然可能以不同的方式解释表示，使用不同的抽象函数 AF。假设 RI 允许任意字符串。那么我们可以定义
    AF，如上所述，将数组的元素解释为集合的元素。但是没有 *先验* 理由让表示决定解释。也许我们将连续的字符对解释为子范围，这样字符串表示 `"acgg"`
    就被解释为两个范围对，[a-c] 和 [g-g]，因此表示了集合 {a,b,c,g}。以下是该表示的 AF 和 RI 的样子：
- en: '![the abstract space and rep space of CharSet using the SortedRangeRep](../Images/e3a128337bcd2fd1cf4e1d3dc51d20bc.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SortedRangeRep 的 CharSet 的抽象空间和表示空间](../Images/e3a128337bcd2fd1cf4e1d3dc51d20bc.jpg)'
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What rep value maps to abstract value {a,c} in this representation?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表示法中，`rep` 值映射到抽象值 `{a,c}` 的是什么？
- en: The essential point is that designing an abstract type means **not only choosing
    the two spaces** – the abstract value space for the specification and the rep
    value space for the implementation – **but also deciding what rep values to use
    and how to interpret them**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于，设计抽象类型意味着**不仅选择两个空间** - 用于规范的抽象值空间和用于实现的表示值空间 - **还要决定使用什么表示值以及如何解释它们**。
- en: It’s critically important to write down these assumptions in your code, as we’ve
    done above, so that future programmers (and your future self) are aware of what
    the representation actually means. Why? What happens if different implementers
    disagree about the meaning of the rep?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中写下这些假设是至关重要的，就像我们上面做的那样，这样未来的程序员（以及你未来的自己）就会意识到表示实际上意味着什么。为什么？如果不同的实现者对表示的含义有不同的意见会发生什么？
- en: You can find example code for [three different `CharSet` implementations](https://github.com/mit6005/fa16-ex12-adt-examples/tree/master/src/charset)
    on GitHub.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到 [三种不同的 `CharSet` 实现的示例代码](https://github.com/mit6005/fa16-ex12-adt-examples/tree/master/src/charset)。
- en: reading exercises
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Who knows what?(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 谁知道什么？（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Rep invariant pieces
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不变式的部分
- en: 'Suppose `C` is an abstract data type whose representation has two `String`
    fields:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `C` 是一个抽象数据类型，其表示具有两个 `String` 字段：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Trying to implement without an AF/RI
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在没有 AF/RI 的情况下实现
- en: 'Suppose Louis Reasoner has created `CharSet` with the following rep:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设路易斯·理查德创建了具有以下表示的 `CharSet`：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But Louis unfortunately neglects to write down the abstraction function (AF)
    and rep invariant (RI). Here are four possible AF/RI pairs that *might* have been
    what Louis had in mind. All of them were also mentioned in the reading above.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，路易斯不幸地忘记了写下抽象函数（AF）和表示不变式（RI）。以下是路易斯可能考虑过的四对可能的 AF/RI，这些也都在上面的阅读中提到过。
- en: 'SortedRep:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SortedRep：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'SortedRangeRep:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: SortedRangeRep：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'NoRepeatsRep:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: NoRepeatsRep：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'AnyRep:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: AnyRep：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Louis has three teammates helping him implement `CharSet`, each working on
    a different operation: `add()`, `remove()`, and `contains()`. Their implementations
    are below. Which of the possible AF/RI pairs are consistent with each programmer’s
    implementation?'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯有三名队友帮助他实现 `CharSet`，每人负责不同的操作：`add()`、`remove()` 和 `contains()`。他们的实现如下。哪种可能的
    AF/RI 对与每个程序员的实现一致？
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: 'Trying to implement without an AF/RI #2'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试在没有 AF/RI 的情况下实现 #2'
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: 'Trying to implement without an AF/RI #3'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试在没有AF/RI的情况下实现 #3'
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失回答)(缺失回答)(缺失回答)(缺失回答)
- en: (missing explanation)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: 'Example: Rational Numbers'
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：有理数
- en: Here’s an example of an abstract data type for rational numbers. Look closely
    at its rep invariant and abstraction function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有理数的抽象数据类型的示例。仔细看看它的表示不变性和抽象函数。
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![the abstraction function and rep invariant of RatNum](../Images/71f890c25c7e2183358d5ef443cf98c7.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![RatNum的抽象函数和表示不变性](../Images/71f890c25c7e2183358d5ef443cf98c7.jpg)'
- en: Here is a picture of the abstraction function and rep invariant for this code.
    The RI requires that numerator/denominator pairs be in reduced form (i.e., lowest
    terms), so pairs like (2,4) and (18,12) above should be drawn as outside the RI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这段代码的抽象函数和表示不变性的图片。RI要求分子/分母对必须处于简化形式（即最低项），因此像(2,4)和(18,12)这样的对应关系应该绘制在RI之外。
- en: It would be completely reasonable to design another implementation of this same
    ADT with a more permissive RI. With such a change, some operations might become
    more expensive to perform, and others cheaper.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以设计另一个实现这个相同ADT的实现，其RI更为宽松。通过这样的变化，一些操作可能会变得更加昂贵，而另一些则更便宜。
- en: Checking the Rep Invariant
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查表示不变性
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,rep_invariant_and_abstraction_function,checking_the_rep_invariant/Od0Jtnoz6fI)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,rep_invariant_and_abstraction_function,checking_the_rep_invariant/Od0Jtnoz6fI)'
- en: 'The rep invariant isn’t just a neat mathematical idea. If your implementation
    asserts the rep invariant at run time, then you can catch bugs early. Here’s a
    method for `RatNum` that tests its rep invariant:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表示不变性不仅仅是一个巧妙的数学想法。如果你的实现在运行时断言表示不变性，那么你可以及早捕获错误。这里有一个用于`RatNum`的方法，用于测试其表示不变性：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You should certainly call `checkRep()` to assert the rep invariant at the end
    of every operation that creates or mutates the rep – in other words, creators,
    producers, and mutators. Look back at the `RatNum` code above, and you’ll see
    that it calls `checkRep()` at the end of both constructors.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在每个创建或改变表示的操作结束时调用`checkRep()`来断言表示不变性 - 换句话说，创建者，生产者和改变者。回顾上面的`RatNum`代码，你会看到它在两个构造函数的末尾都调用了`checkRep()`。
- en: Observer methods don’t normally need to call `checkRep()`, but it’s good defensive
    practice to do so anyway. Why? Calling `checkRep()` in every method, including
    observers, means you’ll be more likely to catch rep invariant violations caused
    by rep exposure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者方法通常不需要调用`checkRep()`，但无论如何这样做都是良好的防御性做法。为什么？在每个方法中调用`checkRep()`，包括观察者，意味着你更有可能捕获由于表示曝光导致的表示不变性违规。
- en: Why is `checkRep` private? Who should be responsible for checking and enforcing
    a rep invariant – clients, or the implementation itself?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`checkRep`是私有的？谁应该负责检查和强制表示不变性 - 客户端，还是实现本身？
- en: No Null Values in the Rep
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示中没有空值
- en: Recall from the [*Specifications* reading](../06-specifications/specs) that
    null values are troublesome and unsafe, so much so that we try to remove them
    from our programming entirely. In 6.005, the preconditions and postconditions
    of our methods implicitly require that objects and arrays be non-null.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*规格*阅读](../06-specifications/specs)中回想起，空值是麻烦的和不安全的，以至于我们尽量完全将其从我们的编程中移除。在6.005中，我们方法的前提条件和后置条件隐含地要求对象和数组是非空的。
- en: 'We extend that prohibition to the reps of abstract data types. By default,
    in 6.005, the rep invariant implicitly includes `x != null` for every reference
    `x` in the rep that has object type (including references inside arrays or lists).
    So if your rep is:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这种禁止扩展到抽象数据类型的表示。默认情况下，在6.005中，RI隐含地包括对于表示中的每个具有对象类型的引用`x != null`。因此，如果你的表示是：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: then its rep invariant automatically includes `s != null`, and you don’t need
    to state it in a rep invariant comment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 那么它的表示不变性自动包含`s != null`，你不需要在表示不变性注释中说明它。
- en: 'When it’s time to implement that rep invariant in a `checkRep()` method, however,
    you still must *implement* the `s != null` check, and make sure that your `checkRep()`
    correctly fails when `s` is `null`. Often that check comes for free from Java,
    because checking other parts of your rep invariant will throw an exception if
    `s` is null. For example, if your `checkRep()` looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当到了在`checkRep()`方法中实现rep invariant的时候，你仍然必须*实现*`s != null`的检查，并确保当`s`为`null`时，你的`checkRep()`能够正确地失败。通常这个检查在Java中是免费的，因为检查rep
    invariant的其他部分会在`s`为null时抛出异常。例如，如果你的`checkRep()`看起来像这样：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: then you don’t need `assert s!= null`, because the call to `s.length()` will
    fail just as effectively on a null reference. But if `s` is not otherwise checked
    by your rep invariant, then assert `s != null` explicitly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你就不需要`assert s!= null`，因为对`null`引用调用`s.length()`将同样有效地失败。但是如果`s`没有被你的表示不变量（rep
    invariant）检查，那么就要明确地断言`assert s != null`。
- en: reading exercises
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Checking the rep invariant(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 检查rep invariant（缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Documenting the AF, RI, and Safety from Rep Exposure
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档化AF、RI和免于Rep暴露的安全性
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,documenting_the_af_ri_and_safety_from_rep_exposure/O0y4ZJdOr5I)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,documenting_the_af_ri_and_safety_from_rep_exposure/O0y4ZJdOr5I)'
- en: It’s good practice to document the abstraction function and rep invariant in
    the class, using comments right where the private fields of the rep are declared.
    We’ve been doing that above.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中使用注释记录抽象函数和rep invariant是一个好的做法，就在rep的私有字段声明的地方。我们之前一直在做这个。
- en: 'When you describe the rep invariant and abstraction function, you must be precise:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你描述rep invariant和抽象函数时，你必须要准确：
- en: It is not enough for the RI to be a generic statement like “all fields are valid.”
    The job of the rep invariant is to explain precisely what makes the field values
    valid or not.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RI不能仅仅是一个类似“所有字段都有效”的通用陈述。rep invariant的工作是准确解释字段值是什么使其有效或无效。
- en: It is not enough for the AF to offer a generic explanation like “represents
    a set of characters.” The job of the abstraction function is to define precisely
    how the concrete field values are interpreted. As a *function*, if we take the
    documented AF and substitute in actual (legal) field values, we should obtain
    out a complete description of the single abstract value they represent.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AF不能仅仅提供一个类似“表示一组字符”的通用解释是不够的。抽象函数的工作是精确定义具体字段值如何被解释。作为一个*函数*，如果我们采用文档化的AF并替换实际（合法）的字段值，我们应该得到一个完整描述它们所代表的单个抽象值。
- en: Another piece of documentation that 6.005 asks you to write is a **rep exposure
    safety argument**. This is a comment that examines each part of the rep, looks
    at the code that handles that part of the rep (particularly with respect to parameters
    and return values from clients, because that is where rep exposure occurs), and
    presents a reason why the code doesn’t expose the rep.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 6.005要求你写的另一部分文档是**rep暴露安全性参数**。这是一个注释，检查rep的每个部分，查看处理该rep部分的代码（特别是关于客户端参数和返回值的代码，因为这是rep暴露发生的地方），并说明为什么代码不会暴露rep。
- en: 'Here’s an example of `Tweet` with its rep invariant, abstraction function,
    and safety from rep exposure fully documented:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`Tweet`的例子，其rep invariant、抽象函数和免于rep暴露的安全性完全被记录：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that we don’t have any explicit rep invariant conditions on `timestamp`
    (aside from the conventional assumption that `timestamp!=null`, which we have
    for all object references). But we still need to include `timestamp` in the rep
    exposure safety argument, because the immutability property of the whole type
    depends on all the fields remaining unchanged.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们对`timestamp`没有任何明确的rep invariant条件（除了传统的假设`timestamp!=null`，对所有对象引用都适用）。但是我们仍然需要在rep暴露安全性参数中包括`timestamp`，因为整个类型的不可变性属性取决于所有字段保持不变。
- en: Compare the argument above with [an example of a broken argument involving mutable
    `Date` objects](https://github.com/mit6005/fa16-ex12-adt-examples/blob/master/src/Timespan.java).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述参数与[涉及可变`Date`对象的破碎参数的示例](https://github.com/mit6005/fa16-ex12-adt-examples/blob/master/src/Timespan.java)进行比较。
- en: Here are the arguments for `RatNum`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`RatNum`的参数。
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that an immutable rep is particularly easy to argue for safety from rep
    exposure.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不可变的rep特别容易证明免于rep暴露的安全性。
- en: You can find [the full code for `RatNum`](https://github.com/mit6005/fa16-ex12-adt-examples/blob/master/src/RatNum.java)
    on GitHub.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到[`RatNum`的完整代码](https://github.com/mit6005/fa16-ex12-adt-examples/blob/master/src/RatNum.java)。
- en: reading exercises
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Arguing against rep exposure
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 反对表示暴露的论点
- en: 'Consider the following ADT:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下ADT：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For each statement below: assuming the omitted method bodies are consistent
    with the statement, can we use the statement in place of `..???..` to make a persuasive
    safety-from-rep-exposure comment?'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的每个语句：假设省略的方法体与语句一致，我们能否使用语句来替换`..???..`以进行有说服力的安全性防范暴露评论？
- en: '**1.** “Strings are immutable.”'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.** “字符串是不可变的。”'
- en: (missing answer)(missing answer)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '**2.** “`followersOf` is a mutable `Map` containing mutable `Set` objects,
    but `getFollowers()` makes a defensive copy of the `Set` it returns, and all other
    parameters and return values are immutable `String` or `void`.”'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.** “`followersOf` 是一个包含可变`Set`对象的可变`Map`，但 `getFollowers()` 对其返回的`Set`进行了防御性复制，而所有其他参数和返回值均为不可变的`String`或`void`。”'
- en: (missing answer)(missing answer)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '**3.** “This class is mutable, so rep exposure isn’t an issue.”'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.** “这个类是可变的，所以表示暴露不是问题。”'
- en: (missing answer)(missing answer)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '**4.** “`followersOf` is a mutable Map, but it is never passed or returned
    from an operation.”'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.** “`followersOf` 是可变的 Map，但从未从操作中传递或返回。”'
- en: (missing answer)(missing answer)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '**5.** “`FollowGraph()` does not expose the rep; `addFollower()` does not expose
    the rep; `removeFollower()` does not expose the rep; `getFollowers()` does not
    expose the rep.”'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**5.** “`FollowGraph()`不暴露表示；`addFollower()`不暴露表示；`removeFollower()`不暴露表示；`getFollowers()`不暴露表示。”'
- en: (missing answer)(missing answer)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: '**6.** “`String` is immutable, and the `Set` objects in the rep are made immutable
    by unmodifiable wrappers. The `Map` type is mutable, but that type is never passed
    or returned from an operation.”'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**6.** “`String` 是不可变的，而 `Set` 对象在表示中通过不可修改的包装器变为不可变。`Map` 类型是可变的，但从未从操作中传递或返回该类型。”'
- en: (missing answer)(missing answer)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: How to Establish Invariants
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何建立不变式
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,documenting_the_af_ri_and_safety_from_rep_exposure,how_to_establish_invariants/53io8ah2eFI)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,documenting_the_af_ri_and_safety_from_rep_exposure,how_to_establish_invariants/53io8ah2eFI)'
- en: An invariant is a property that is true for the entire program – which in the
    case of an invariant about an object, reduces to the entire lifetime of the object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不变式是程序整体都成立的属性——对于关于对象的不变式来说，这归结为对象的整个生命周期。
- en: 'To make an invariant hold, we need to:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要使不变式成立，我们需要：
- en: make the invariant true in the initial state of the object; and
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使对象的初始状态中的不变式为真；和
- en: ensure that all changes to the object keep the invariant true.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保对对象的所有更改保持不变式为真。
- en: 'Translating this in terms of the types of ADT operations, this means:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将其翻译为ADT操作的类型，则意味着：
- en: creators and producers must establish the invariant for new object instances;
    and
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建者和制作者必须为新对象实例建立不变式；和
- en: mutators and observers must preserve the invariant.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更器和观察者必须保持不变式。
- en: 'The risk of rep exposure makes the situation more complicated. If the rep is
    exposed, then the object might be changed anywhere in the program, not just in
    the ADT’s operations, and we can’t guarantee that the invariant still holds after
    those arbitrary changes. So the full rule for proving invariants is:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表示暴露的风险使情况变得更加复杂。如果表示被暴露，那么对象可能在程序中的任何位置被更改，而不仅仅在ADT的操作中，我们无法保证在这些任意更改之后不变式仍然成立。因此，证明不变式的完整规则是：
- en: '**Structural induction**. If an invariant of an abstract data type is'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构归纳**。如果抽象数据类型的不变式为真'
- en: established by creators and producers;
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由创建者和制作者建立；
- en: preserved by mutators, and observers; and
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被变更器和观察者保留；和
- en: no representation exposure occurs,
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有表示暴露发生，
- en: then the invariant is true of all instances of the abstract data type.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 那么不变式就对抽象数据类型的所有实例都成立。
- en: reading exercises
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Structural induction
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 结构归纳
- en: 'Recall this data type from the first exercise in this reading:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在本次阅读中的第一个练习中的此数据类型：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This datatype has an important invariant: the relationship between the legs
    and hypotenuse, as stated in the Pythagorean theorem.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据类型有一个重要的不变量：根据毕达哥拉斯定理所述的腿和斜边之间的关系。
- en: (missing answer)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: (missing answer)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: (missing answer)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: (missing answer)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: (missing answer)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: ADT invariants replace preconditions
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADT 不变量取代前置条件
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,adt_invariants_replace_preconditions/gsGzuN9JMCA)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_12_abstraction_functions_rep_invariants,adt_invariants_replace_preconditions/gsGzuN9JMCA)'
- en: 'Now let’s bring a lot of pieces together. An enormous advantage of a well-designed
    abstract data type is that it encapsulates and enforces properties that we would
    otherwise have to stipulate in a precondition. For example, instead of a spec
    like this, with an elaborate precondition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把许多片段组合在一起。 设计良好的抽象数据类型的一个巨大优势是它封装并强制执行我们否则必须在前置条件中规定的属性。 例如，与其具有复杂的前置条件的规范，如下所示：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can instead use an ADT that captures the desired property:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以使用捕捉所需属性的 ADT：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is easier to understand, because the name of the ADT conveys all the programmer
    needs to know. It’s also safer from bugs, because Java static checking comes into
    play, and the required condition (sorted with no repeats) can be enforced in exactly
    one place, the [`SortedSet`](http://docs.oracle.com/javase/8/docs/api/?java/util/SortedSet.html)
    type.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这更容易理解，因为 ADT 的名称传达了程序员需要了解的所有信息。 它也更安全免受错误的影响，因为 Java 静态检查会发挥作用，并且所需的条件（排序且无重复）可以在一个地方——[`SortedSet`](http://docs.oracle.com/javase/8/docs/api/?java/util/SortedSet.html)
    类型中强制执行。
- en: Many of the places where we used preconditions on the problem sets would have
    benefited from a custom ADT instead.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在问题集中我们使用前置条件的许多地方本可以受益于使用自定义 ADT。
- en: reading exercises
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Encapsulating preconditions in ADTs
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将前置条件封装在 ADT 中
- en: 'Consider this method:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种方法：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An invariant is a property that is always true of an ADT object instance, for
    the lifetime of the object.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不变量是一个在 ADT 对象实例的生命周期内始终为真的属性。
- en: A good ADT preserves its own invariants. Invariants must be established by creators
    and producers, and preserved by observers and mutators.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个良好的 ADT 保留了自己的不变量。 不变量必须由创建者和生产者建立，并由观察者和变异器保持。
- en: The rep invariant specifies legal values of the representation, and should be
    checked at runtime with `checkRep()`.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rep 不变量指定了表示的合法值，并且应该使用 `checkRep()` 在运行时进行检查。
- en: The abstraction function maps a concrete representation to the abstract value
    it represents.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象函数将具体表示映射到它表示的抽象值。
- en: Representation exposure threatens both representation independence and invariant
    preservation.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示暴露威胁表示独立性和不变性的保留。
- en: 'The topics of today’s reading connect to our three properties of good software
    as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 今天阅读的主题与我们的三个好软件属性相关如下：
- en: '**Safe from bugs.** A good ADT preserves its own invariants, so that those
    invariants are less vulnerable to bugs in the ADT’s clients, and violations of
    the invariants can be more easily isolated within the implementation of the ADT
    itself. Stating the rep invariant explicitly, and checking it at runtime with
    checkRep(), catches misunderstandings and bugs earlier, rather than continuing
    on with a corrupt data structure.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误的影响。** 一个良好的 ADT 保留了自己的不变量，因此这些不变量在 ADT 的客户端中更不容易受到错误的影响，并且在 ADT 自身的实现中更容易地隔离违反不变量。
    明确陈述 rep 不变量，并使用 checkRep() 在运行时进行检查，可以更早地捕获误解和错误，而不是继续使用已损坏的数据结构。'
- en: '**Easy to understand.** Rep invariants and abstraction functions explicate
    the meaning of a data type’s representation, and how it relates to its abstraction.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解。** rep 不变量和抽象函数阐明了数据类型表示的含义，以及它与抽象的关系。'
- en: '**Ready for change.** Abstract data types separate the abstraction from the
    concrete representation, which makes it possible to change the representation
    without having to change client code.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于变更。** 抽象数据类型将抽象与具体表示分离，这使得可以在不必更改客户端代码的情况下更改表示。'
