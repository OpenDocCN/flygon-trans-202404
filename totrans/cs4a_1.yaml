- en: 'Chapter 1: Introduction'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：介绍
- en: '*Computer science is to the information revolution what mechanical engineering
    was to the industrial revolution.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*计算机科学对信息革命的意义，就像机械工程对工业革命的意义一样。*'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Robert Keller
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —罗伯特·凯勒
- en: 1.1 What is Computer Science?
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 什么是计算机科学？
- en: You might be uncertain about what computer science (CS) is, but you use it every
    day. When you use Google or your smartphone, or watch a movie with special effects,
    there’s lots of CS in there. When you order a product over the Internet, there
    is CS in the web site, in the cryptography used to keep your credit card number
    secure, and in the way that FedEx routes their delivery vehicle to get your order
    to you as quickly as possible. Nonetheless, even computer scientists can struggle
    to answer the question “What *exactly* is CS?”
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你不确定计算机科学（CS）到底是什么，但你每天都在使用它。当你使用 Google 或智能手机，或者观看带有特效的电影时，其中有很多 CS。当你通过互联网订购产品时，在网站中有
    CS，在用于保护你的信用卡号安全的加密技术中有 CS，以及 FedEx 如何安排他们的交付车辆以尽快将您的订单送到您手中中也有 CS。尽管如此，即使是计算机科学家也可能难以回答“CS究竟是什么？”这个问题。
- en: 'Many other sciences try to understand how things work: physics tries to understand
    the physical world, chemistry tries to understand the composition of matter, and
    biology tries to understand life. So what is computer science trying to understand?
    Computers? Probably not: computers are designed and built by humans, so their
    inner workings are known (at least to some people!).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他科学试图理解事物的工作原理：物理学试图理解物理世界，化学试图理解物质的组成，生物学试图理解生命。那么计算机科学试图理解什么呢？计算机？可能不是：计算机是由人类设计和构建的，因此它们的内部运作是已知的（至少对某些人来说是！）。
- en: Perhaps it’s all about programming. Programming is indeed important to a computer
    scientist, just as grammar is important to a writer or a telescope is important
    to an astronomer. But nobody would argue that writing is about grammar or that
    astronomy is about telescopes. Similarly, programming is an important piece of
    computer science but it’s not what CS is all about.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 或许这一切都与编程有关。编程对于计算机科学家确实很重要，就像语法对于作家或者望远镜对于天文学家一样重要。但没有人会争辩写作是关于语法的，或者天文学是关于望远镜的。同样，编程是计算机科学的一个重要组成部分，但它并不是
    CS 的全部。
- en: If we turn to origins, computer science has roots in disparate fields that include
    engineering, mathematics, and cognitive science, among others. Some computer scientists
    design things, much like engineers. Others seek new ways to solve computational
    problems, analyze their solutions, and prove that they are correct, much like
    mathematicians. Still others think about how humans interact with computers and
    software, which is closely related to cognitive science and psychology. All of
    these pieces are a part of computer science.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾起源，计算机科学根源于包括工程学、数学和认知科学在内的各种不同领域。一些计算机科学家设计东西，就像工程师一样。其他人寻求解决计算问题的新方法，分析它们的解决方案，并证明它们是正确的，就像数学家一样。还有一些人思考人类如何与计算机和软件交互，这与认知科学和心理学密切相关。所有这些都是计算机科学的一部分。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Zoogenesis refers to the origin of a particular animals species. Computational
    biology is a field that uses CS to help solve zoogenetic questions, among many
    others.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*动物发生是指特定动物物种的起源。计算生物学是一门利用 CS 帮助解决动物起源问题的领域，其中包括许多其他问题。*'
- en: One theme that unifies (nearly) all computer scientists is that they are interested
    in the *automation of tasks* ranging from **a**rtificial intelligence to **z**oogenesis.
    Put another way, computer scientists are interested in finding solutions for a
    wide variety of computational problems. They analyze those solutions to determine
    their “goodness,” and they implement the good solutions to create useful software
    for people to work with. This diversity of endeavors is, in part, what makes CS
    so much fun.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个几乎统一的主题是，几乎所有的计算机科学家都对从**人工智能**到**动物发生**等各种任务的*自动化*感兴趣。换句话说，计算机科学家感兴趣的是找到各种计算问题的解决方案。他们分析这些解决方案以确定其“好坏”，并实施良好的解决方案来创建人们可以使用的有用软件。这种多样化的努力在一定程度上是使
    CS 如此有趣的原因之一。
- en: 'There are several important concepts at the heart of computer science; we have
    chosen to emphasize six of them: data, problem solving, algorithms, programming,
    abstraction, and creativity.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学的核心有几个重要概念；我们选择强调其中的六个：数据、问题解决、算法、编程、抽象和创造力。
- en: 1.1.1 Data
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 数据
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*That’s Astronomical!*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*那是天文数字！*'
- en: 'When you Google the words “pie recipe,” Google reports that it finds approximately
    38 million pages, ranked in order of estimated relevance and usefulness. Facebook
    has approximately 1 billion active users who generate over 3 billion comments
    and “Likes” each day. GenBank, a national database of DNA sequences used by biologists
    and medical researchers studying genetic diseases, has over 100 million genetic
    sequences with over 100 billion DNA base pairs. According to the International
    Data Corporation, in 2010 the size of our “Digital Universe” reached 1.2 zettabytes.
    How much is that? Jeffrey Heer, a computer scientist who specializes in managing
    and visualizing large amounts of data, puts it this way: A stack of DVDs that
    reached to the moon and back would store approximately 1.2 zettabytes of data.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你谷歌搜索“派食谱”时，谷歌报告说它找到了大约3800万页，按照估计的相关性和有用性排序。Facebook有大约10亿活跃用户，每天产生超过30亿的评论和“喜欢”。GenBank是一个国家级的DNA序列数据库，由生物学家和医学研究人员用来研究遗传疾病，拥有超过1亿条基因序列，拥有超过1000亿个DNA碱基对。根据国际数据公司的数据，在2010年，我们的“数字宇宙”的大小达到了1.2泽字节。这是多少？专门从事管理和可视化大量数据的计算机科学家杰弗里·希尔这样说：一堆光盘如果达到月球并返回，将存储约1.2泽字节的数据。
- en: Without computer science, all of this data would be junk. Searching for a recipe
    on Google, a friend on Facebook, or genes in GenBank would all be impossible without
    ideas and tools from computer science.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 没有计算机科学，所有这些数据都将是垃圾。在谷歌上搜索食谱，在Facebook上找朋友，或在GenBank中找基因，所有这些都将不可能没有计算机科学的思想和工具。
- en: Doing meaningful things with data is challenging, even if we’re not dealing
    with millions or billions of things. In this book, we’ll do interesting things
    with smaller sets of data. But much of what we’ll do will be applicable to very
    large amounts of data too.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有处理数百万或数十亿个事物，利用数据做有意义的事情也是具有挑战性的。在这本书中，我们将使用较小的数据集做有趣的事情。但我们所做的许多事情也适用于非常大量的数据。
- en: 1.1.2 Algorithms
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 算法
- en: '**Making Pie and Making** \(\pi\)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**制作派和制作** \(\pi\)'
- en: When presented with a computational problem, our first objective is to find
    a computational solution, or “algorithm,” to solve it. An *algorithm* is a precise
    sequence of steps for carrying out a task, such as ranking web pages in Google,
    searching for a friend on Facebook, or finding closely related genes in Genbank.
    In some cases, a single good algorithm is enough to launch a successful company
    (e.g., Google’s initial success was due to its Page Rank algorithm).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当面临计算问题时，我们的第一个目标是找到一个计算解决方案，或者“算法”，来解决它。一个*算法*是一系列精确的步骤，用于执行任务，例如在谷歌中对网页进行排名，在Facebook上搜索朋友，或者在Genbank中查找紧密相关的基因。在某些情况下，一个好的算法就足以推出一家成功的公司（例如，谷歌的初始成功归功于其Page
    Rank算法）。
- en: 'Algorithms are commonly compared to recipes that act on their ingredients (the
    data). For example, imagine that an alien has come to Earth from a distant planet
    and has a hankering for some pumpkin pie. The alien does a Google search for pumpkin
    pie and finds the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 算法通常被比作对它们的成分（数据）进行操作的食谱。例如，想象一下，一个外星人从遥远的星球来到地球，并渴望吃一些南瓜派。外星人在谷歌上搜索南瓜派，找到了以下内容：
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*I’ve come to Earth for pumpkin pie!*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*我来地球是为了南瓜派！*'
- en: Mix 3/4 cup sugar, 1 tsp cinnamon, 1/2 tsp salt, 1/2 tsp ginger and 1/4 tsp
    cloves in a small bowl.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个小碗中混合3/4杯糖，1茶匙肉桂粉，1/2茶匙盐，1/2茶匙姜和1/4茶匙丁香。
- en: Beat two eggs in a large bowl.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个大碗中打两个鸡蛋。
- en: Stir 1 15-oz. can pumpkin and the mixture from step 1 into the eggs.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搅拌1 15盎司的罐装南瓜和步骤1中的混合物到鸡蛋中。
- en: Gradually stir in 1 12 fl. oz. can evaporated milk into the mixture.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐渐将1 12 fl. oz.的罐装蒸发奶倒入混合物中。
- en: Pour mixture into unbaked, pre-prepared 9-inch pie shell.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将混合物倒入未烤的、预先准备好的9英寸派皮中。
- en: Bake at 425°F for 15 minutes.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以425°F烤15分钟。
- en: Reduce oven temperature to 350°F.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将烤箱温度降至350°F。
- en: Bake for 30-40 minutes more, or until set.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再烤30-40分钟，或直到凝固。
- en: Cool for 2 hours on wire rack.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在铁架上冷却2小时。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*No! Don’t lick the spoon - there are raw eggs in there!*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*不！不要舔勺子 - 里面有生鸡蛋！*'
- en: Assuming we know how to perform basic cooking steps (measuring ingredients,
    cracking eggs, stirring, licking the spoon, etc.), we could make a tasty pie by
    following these steps precisely.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道如何执行基本的烹饪步骤（称量配料，打蛋，搅拌，舔勺子等），我们可以通过精确遵循这些步骤来制作出一块美味的馅饼。
- en: 'Out of respect for our gastronomical well-being, computer scientists rarely
    write recipes (algorithms) that have anything to do with food. As a computer scientist,
    we would be more likely to write an algorithm to calculate \(\pi\) very precisely
    than we would be to write an algorithm to make a pie. Let’s consider just such
    an algorithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 出于对我们的胃口健康的尊重，计算机科学家很少编写与食物有关的食谱（算法）。作为一名计算机科学家，我们更可能编写一个非常精确地计算\(\pi\)的算法，而不是编写一个制作馅饼的算法。让我们考虑一个这样的算法：
- en: Draw a square that is 2 by 2 feet.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 画一个边长为2英尺的正方形。
- en: Inscribe a circle of radius 1 foot (diameter 2 feet) inside this square.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在正方形内划一条半径为1英尺（直径为2英尺）的圆。
- en: Grab a bucket of n darts, move away from the dartboard, and put on a blindfold.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拿起一个有n个飞镖的桶，远离飞镖靶，并戴上眼罩。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Please don’t try this at home!*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*请不要在家里尝试这个！*'
- en: 'Take each dart one at a time and for each dart:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个取出每个飞镖，对于每个飞镖：
- en: With your eyes still covered, throw the dart randomly (but assume that your
    throwing skills ensure that it will land somewhere on the square dartboard).
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依然闭着眼睛，随机投掷飞镖（但假设你的投掷技巧能确保它会落在飞镖板上的某个地方）。
- en: Record whether or not the dart landed inside the circle.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录飞镖是否落在圆内。
- en: When you have thrown all the darts, divide the number that landed inside the
    circle by the total number, n, of darts you threw and multiply by 4\. This will
    give you your estimate for \(\pi\).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你投掷完所有的飞镖后，将落在圆内的数量除以你投掷的飞镖总数n，并乘以4。这将给出你对\(\pi\)的估计。
- en: Figure 1.1 shows the scenario.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1展示了这种情景。
- en: '![../Images/dart.PNG](../Images/dart.PNG)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/dart.PNG](../Images/dart.PNG)'
- en: 'Figure 1.1: Using a dartboard to approximate \(\pi\)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：使用飞镖靶近似计算\(\pi\)
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*Hey, watch it! That dart almost hit me!*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*嘿，小心！那个飞镖差点打到我了！*'
- en: 'That’s the description of the algorithm, but why does it work? Here’s why:
    The area of the circle is \(\pi r^2\) which is π in this case because we made
    the radius of the board to be 1\. The area of the square is 4\. Since we’re assuming
    that darts are equally likely to end up anywhere in the square, we expect the
    proportion of them that land in the circle to be the ratio of the area of the
    circle to the area of the square: \(\frac{\pi}{4}\). Therefore, if we throw n
    darts and determine that some number k land inside the circle, then \(\frac{k}{n}\)
    should be approximately \(\frac{\pi}{4}\). So multiplying the ratio by 4 gives
    us an approximation of \(\pi\).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那是算法的描述，但它为什么有效呢？原因在于：圆的面积是\(\pi r^2\)，在这种情况下是π，因为我们将板的半径设为1。正方形的面积是4。因为我们假设飞镖以等概率落在正方形的任何地方，我们预计落在圆内的飞镖比例将是圆的面积与正方形面积的比值：\(\frac{\pi}{4}\)。因此，如果我们投掷了n个飞镖，并确定有一些数目k落在圆内，则\(\frac{k}{n}\)应该近似于\(\frac{\pi}{4}\)的比值。因此，将比值乘以4会给我们一个\(\pi\)的近似值。
- en: Happily, the computer does not have to robotically throw physical darts; instead
    we can simulate this dart throwing process on a computer by generating random
    coordinates that describe where the darts land. The computer can throw millions
    of virtual darts in a fraction of a second and will never miss the square–making
    things considerably safer for your roommate!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，计算机不必机械地投掷实体飞镖；相反，我们可以在计算机上模拟这个飞镖投掷过程，方法是生成描述飞镖落点的随机坐标。计算机可以在几秒钟内抛出数百万个虚拟飞镖，并且永远不会错过正方形——这对你的室友来说要安全得多！
- en: 1.1.3 Programming
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 编程
- en: Although we noted earlier that computer science is not exclusively about programming,
    ultimately we usually want to have a program–that is, software–that implements
    the algorithm that will operate on our data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们早些时候提到计算机科学不仅仅是关于编程的，但最终我们通常希望有一个程序——即软件——来实现操作我们的数据的算法。
- en: Learning to program is a bit like learning to speak or write in a new language.
    The good news is that the *syntax* of a programming language–the vocabulary and
    grammar–is not nearly as complicated as for a spoken language. In this book, we’ll
    program in a language called Python, whose syntax is particularly easy to learn.
    But don’t be fooled into thinking it’s not a real programming language–Python
    is a very real language used by real programmers to write real software. Moreover,
    the ideas that you’ll learn here will be transferable to learning other languages
    later.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 学习编程有点像学习一种新语言说话或写作。好消息是，编程语言的*语法*——词汇和语法——远不及口语语言那么复杂。在这本书中，我们将使用一种称为 Python
    的语言进行编程，其语法特别容易学习。但不要被误导以为它不是一种真正的编程语言——Python 是一种非常真实的语言，由真正的程序员用来编写真正的软件。此外，你在这里学到的思想将能够转化为以后学习其他语言的基础。
- en: 1.1.4 Abstraction
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.4 抽象
- en: While data, algorithms, and programming might seem like the whole story, the
    truth is that there are other important ideas behind the scenes. Software is often
    immensely complex and it can be difficult or even impossible for any single person
    to keep all of the interacting pieces in mind. To deal with such complex systems,
    computer scientists use the the notion of *abstraction*–the idea that when designing
    one part of a program, we can ignore the inessential details of other parts of
    the program as long as we have a high level understanding of what they do.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据、算法和编程看起来像是全部内容，但事实是幕后还有其他重要的思想。软件通常非常复杂，对于任何一个人来说，要记住所有交互部分可能是困难的，甚至是不可能的。为了处理这样复杂的系统，计算机科学家使用*抽象*的概念——即在设计程序的一部分时，我们可以忽略程序的其他部分的非本质细节，只要我们对它们的高层次理解是正确的。
- en: For example, a car has an engine, a drivetrain, an electrical system, and other
    components. These components can be designed individually and then assembled to
    work together. The designer of the drivetrain doesn’t need to understand every
    aspect of how the engine works, but just enough to know how the drivetrain and
    the engine will be connected. To the drivetrain designer, the engine is an “abstraction.”
    In fact, the engine itself is divided into components such as the engine block,
    distributor, and others. These parts too can be viewed as abstract entities that
    interact with one another. When designing the engine block, we don’t need to think
    about every detail of how the distributor works.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，汽车有发动机、传动系统、电气系统和其他组件。这些组件可以单独设计，然后组装在一起工作。传动系统设计者不需要了解发动机的每个方面，而只需要了解传动系统和发动机如何连接。对于传动系统设计者来说，发动机是一种“抽象”。实际上，发动机本身被划分为发动机块、分配器等组件。这些部件也可以被视为相互作用的抽象实体。在设计发动机块时，我们不需要考虑分配器的每一个细节。
- en: Software systems can be even more complicated than a car. Designing software
    requires that we think about abstractions in order to ensure that many people
    can contribute to the project without everyone needing to understand everything,
    in order to test the software methodically, and in order to be able to update
    it in the future by simply replacing one “component” by a new and improved component.
    Abstraction, therefore, is a key idea in the design of any large system, and software
    in particular.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 软件系统甚至可能比汽车还要复杂。设计软件要求我们考虑抽象，以确保许多人可以为项目做出贡献，而不需要每个人都需要了解一切，以有条不紊地测试软件，并且能够通过简单地用新的和改进的组件替换一个“组件”来更新它。因此，抽象是任何大型系统设计的关键思想，特别是软件设计。
- en: 1.1.5 Problem Solving and Creativity
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.5 问题解决与创造力
- en: This book strives to prepare you to write well-designed programs that do interesting
    things with data. In the process, we hope to convey to you that computer science
    is an enormously creative endeavor that requires innovative problem-solving, exploration,
    and even experimentation. Often times, there’s more than one way to solve a problem.
    In some cases there’s not even a clear “best” way to solve a problem. Different
    solutions will have different merits. While Google, Facebook, GenBank are wonderfully
    easy to use, many challenges arose–and continue to arise–in the design and continual
    updating of such systems. These challenges often lead to groups of computer scientists
    working together to find different solutions and evaluate their relative merits.
    While the challenges that we’ll confront in this book are of a more modest scope,
    we hope to share with you the sense of problem solving and creativity that are
    at the heart of computer science.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书致力于让你能够编写设计良好、能够处理数据的有趣程序。在这个过程中，我们希望向你传达计算机科学是一项需要创新性问题解决、探索甚至实验的极具创造性的事业。通常情况下，解决问题的方法不止一种。在某些情况下，甚至没有明确的“最佳”解决方案。不同的解决方案会有不同的优点。虽然
    Google、Facebook、GenBank 等等极易使用，但在设计和持续更新这些系统时会遇到许多挑战。这些挑战通常会导致计算机科学家组成团队，寻找不同的解决方案并评估它们的相对优点。虽然我们在这本书中将面对的挑战范围较为有限，但我们希望与你分享计算机科学核心的问题解决和创造力。
- en: '**Takeaway message:** *In a nutshell, the objective of this book is to demonstrate
    the breadth of activities that comprise computer science, show you some fundamental
    and beautiful ideas, and provide you with the skills to design, implement, and
    analyze your own programs.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点：** *简而言之，这本书的目标是展示构成计算机科学的各种活动的广度，向你展示一些基本且美妙的想法，并为你提供设计、实现和分析自己程序的技能。*'
- en: 1.2 PicoBot
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 PicoBot
- en: '*Leap before you look.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*先入为主。*'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —W.H. Auden
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —W.H. Auden
- en: 'The best way for you to get a feel for computer science is to jump right in
    and start solving a computer science problem. So let’s do just that. In this section,
    we’ll examine solutions to an important problem: How to make sure you’ll never
    have to clean–or at least vacuum–your room again. To solve this problem we’ll
    use a simple programming language named Picobot that controls a robot loosely
    based on the Roomba vacuum cleaner robot.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让你对计算机科学有感觉的最佳方法是立即投入并开始解决计算机科学问题。所以我们就这么做吧。在这一节中，我们将研究一个重要问题的解决方案：如何确保你永远不必清洁——或至少不必真空——你的房间。为了解决这个问题，我们将使用一个简单的编程语言，名为
    Picobot，它控制一个松散基于 Roomba 真空吸尘器机器人的机器人。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*This web site offers a simulation environment for exploring Picobot’s capabilities*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*这个网站提供了一个模拟环境，用于探索 Picobot 的功能*'
- en: You’re probably wondering what happened to Python, the programming language
    we said we would be using throughout this book. Why are we sweeping Python under
    the carpet and brushing aside the language that we plan to use for the remainder
    of the book? The answer is that although Python is a simple (but powerful!) programming
    language that’s easy to learn, Picobot is an *even simpler* language that’s *even
    easier* to learn. The entire language takes only a few minutes to learn and yet
    it allows you to do some very powerful and interesting computation. So, we’ll
    be able to start some serious computer science before we get sucked into a discussion
    of a full-blown programming language. This will be new and fun–and whether you
    have programmed before, it should offer a “Eureka!” experience. So, dust off your
    browser and join us at [http://www.cs.hmc.edu/picobot](http://www.cs.hmc.edu/picobot).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能想知道我们之前说过会在整本书中使用的编程语言 Python 怎么了。为什么我们把 Python 不谈了，将我们计划在书中其余部分使用的语言搁置一边？答案是，尽管
    Python 是一种简单（但功能强大！）的编程语言，易于学习，但 Picobot 是一种*更简单*的语言，*更容易*学习。整个语言只需几分钟就能学会，但却可以进行一些非常强大和有趣的计算。因此，在我们被卷入讨论完整的编程语言之前，我们将能够开始一些严肃的计算机科学。这将是新的、有趣的体验——无论你之前是否编程过，它都应该给你带来“顿悟”的体验。所以，拂去你浏览器上的尘埃，加入我们在
    [http://www.cs.hmc.edu/picobot](http://www.cs.hmc.edu/picobot)。  '
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Or, at least, the “breakout” app that enable the industry’s first large-scale
    profits.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*或者，至少是促成了行业首次大规模利润的“突围”应用程序。*'
- en: '![../Images/roomba.jpg](../Images/roomba.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/roomba.jpg](../Images/roomba.jpg)'
- en: '*An iRobot Roomba. You’ll notice that we use the word “Picobot” to refer to
    both the Roomba robot and the language that we will use to program it.* *Actually,
    Picobot might not be able to actually “see” at all. Instead, it might sense its
    environment though one of many possible sensors including bump sensors, infrared,
    camera, lasers, etc.*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*iRobot Roomba。您会注意到我们用“Picobot”一词来指代Roomba机器人和我们将用来编程它的语言。* 实际上，Picobot可能根本就不能“看到”。相反，它可能通过众多可能的传感器之一感知其环境，包括碰撞传感器、红外线、摄像头、激光等。'
- en: 1.2.1 The Roomba Problem
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 Roomba问题
- en: 'It is the humblest of tasks–cleaning up–that has turned out to be the “killer
    app” for household robots. Imagine yourself as a Roomba vacuum named Picobot:
    your goal is to suck up the debris from the free space around you- ideally without
    missing any nooks or crannies. The robotics community calls this *the coverage
    problem*: it is the task of ensuring that all the grass is mown, all the surface
    receives paint, or all the Martian soil is surveyed.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就是最卑微的任务——清理——成为了家用机器人的“杀手级应用”。想象一下自己是一台名为Picobot的Roomba吸尘器：您的目标是清除您周围的空地上的碎片——最好是不错过任何角落或缝隙。机器人社区将这称为*覆盖问题*：确保所有的草坪都被修剪，所有的表面都被涂漆，或者所有的火星土壤都被勘测。
- en: At first this problem might seem pretty easy. After all, if your parents gave
    you a vacuum cleaner and told you to vacuum your room without missing a spot,
    you’d probably do a pretty great job without even thinking too much about it.
    Shouldn’t it be straightforward to convey your strategy to a robot?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这个问题可能看起来很容易。毕竟，如果您的父母给了您一台吸尘器，并告诉您要吸尘您的房间，而不错过任何地方，您可能会做得非常出色，甚至不用太费脑子去考虑。应该很容易将您的策略传达给一个机器人，对吧？
- en: Unfortunately, there are a couple of obstacles that make the Picobot’s job considerably
    more difficult than yours. First, Picobot has very limited “sight”; it can only
    sense what’s directly around it. Second, Picobot is totally unfamiliar with the
    environment it is supposed to clean. While you could probably walk around your
    room blindfolded without crashing into things, Picobot is not so lucky. Third,
    Picobot has a very limited memory. In fact, it can’t even remember which part
    of the room it has seen and which part it has not.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有一些障碍使得Picobot的工作比您的工作要困难得多。首先，Picobot的“视野”非常有限；它只能感知周围直接的事物。其次，Picobot完全不熟悉它应该清洁的环境。虽然您可能会戴着眼罩在房间里走来走去而不会撞到东西，但Picobot就没有这么幸运了。第三，Picobot的记忆非常有限。事实上，它甚至无法记住它看到了房间的哪一部分，哪一部分还没有看到。
- en: While these challenges make Picobot’s job (and our job of programming Picobot)
    more difficult, they also make the coverage problem an interesting and non-trivial
    computer science problem worth serious study.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些挑战使得Picobot的工作（以及我们编程Picobot的工作）更加困难，但这也使得覆盖问题成为一个有趣且非平凡的计算机科学问题，值得认真研究。
- en: 1.2.2 The Environment
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 环境
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*“Discretize” is CS-speak for “break up into individual pieces”.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*“离散化”是计算机术语，意思是“分解成单个部分”。'
- en: Our first task in solving this problem is to represent it in a way that the
    computer can handle. In other words, we need to define the data we will be working
    with to solve this problem. For example, how will we represent where the obstacles
    in the room are? Where Picobot is? We could represent the room as a plane, and
    then list the coordinates of the object’s corners and the coordinates of Picobot’s
    location. While this representation is reasonable, we will actually use a slightly
    simpler approach.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决这个问题的第一个任务是以计算机可以处理的方式来表示它。换句话说，我们需要定义我们将用来解决这个问题的数据。例如，我们将如何表示房间中的障碍物？Picobot在哪里？我们可以将房间表示为一个平面，然后列出物体角落的坐标以及Picobot位置的坐标。虽然这种表示是合理的，但实际上我们将使用稍微简单的方法。
- en: 'Whether lawn or sand, an environment is simpler to cover if it is discretized
    into cells as shown in Figure 1.2\. This is our first example of an abstraction:
    we are ignoring the details of the environment and simplifying it into something
    we can easily work with. You, as Picobot, are similarly simplified: you occupy
    one grid square (the green one), and you can travel one step at a time in one
    of the four compass directions: north, east, west, or south.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是草坪还是沙滩，将环境离散化为单元格会更容易覆盖，如图1.2所示。这是我们首次使用抽象的例子：我们忽略环境的细节，并将其简化为我们可以轻松处理的东西。您作为Picobot，同样被简化了：您占据一个网格方格（绿色方格），可以沿着四个罗盘方向之一进行一步一步的移动：北、东、西或南。
- en: 'Picobot cannot travel onto obstacles (the blue cells–which we will also call–”walls”);
    as we mentioned above, it does not know the positions of those obstacles ahead
    of time. What Picobot can sense is its immediate surroundings: the four cells
    directly to its north, east, west, or south. The surroundings are always reported
    as a string of four letters in **“NEWS”** order, meaning that we first see what
    is in our neighboring cell to the **N**orth, next what’s to the **E**ast, then
    **W**est, and finally **S**outh. If the cell to the north is empty, the letter
    in the first position is an `x`. If the cell to the north is occupied, the letter
    in that first position is an N. The second letter, an `x` or an `E`, indicates
    whether the eastern neighbor is empty or occupied; the third, `x` or `W`, is the
    west; the fourth, `x` or `S`, is the south. At its position in the lower-left-hand
    corner of Figure 1.2, for example, Picobot’s sensors would report its four-letter
    surroundings as `xxWS`. There are sixteen possible surroundings for Picobot, shown
    in Figure 1.3 with their textual representations.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Picobot不能移动到障碍物上（蓝色单元格——我们也将其称为“墙”）；正如我们之前提到的，它不知道障碍物的位置。 Picobot能感知的是它的即时环境：它的北、东、西、南四个方向的单元格。环境总是按照“NEWS”顺序报告的，意思是我们首先看到的是我们北面的邻居单元格中的内容，接下来是东边的，然后是西边的，最后是南边的。如果北边的单元格是空的，第一个位置上的字母是一个`x`。如果北边的单元格被占用，那么第一个位置上的字母就是一个N。第二个字母，`x`或`E`，表示东边的邻居是空的还是被占用的；第三个字母，`x`或`W`，是西边的；第四个字母，`x`或`S`，是南边的。例如，在图1.2的左下角位置，Picobot的传感器会报告其四个字母的环境为`xxWS`。Picobot有十六种可能的环境，如图1.3所示，带有它们的文本表示。
- en: '[![../Images/picoRules.jpg](../Images/picoRules.jpg)](../Images/picoRules.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/picoRules.jpg](../Images/picoRules.jpg)](../Images/picoRules.jpg)'
- en: 'Figure 1.2: There are four types of cells in a Picobot environment, or map:
    green is Picobot itself, blue cells are walls, and gray cells are free space.
    Picobot can’t sense whether a empty cell has been visited or not (dark or light
    gray), but it can sense whether each of its four immediate neighbors is free space
    or an obstacle.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：Picobot环境或地图中有四种类型的单元格：绿色是Picobot本身，蓝色单元格是墙，灰色单元格是自由空间。Picobot无法感知一个空单元格是否已被访问过（深灰色或浅灰色），但它可以感知它的四个直接邻居单元格是自由空间还是障碍物。
- en: '[![../Images/picoPossibilities.jpg](../Images/picoPossibilities.jpg)](../Images/picoPossibilities.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/picoPossibilities.jpg](../Images/picoPossibilities.jpg)](../Images/picoPossibilities.jpg)'
- en: 'Figure 1.3: There are sixteen possible surroundings strings for Picobot. The
    one in which Picobot is completely enclosed will not occur in our simulator!'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：Picobot有十六种可能的环境字符串。在我们的模拟器中不会发生完全封闭的情况！
- en: 1.2.3 State
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 状态
- en: As we’ve seen, Picobot can sense its immediate surroundings. This will be important
    in its decision-making process. For example, if Picobot is in the process of moving
    north and it senses that the cell to its north is a wall, it should not try to
    continue moving north! In fact, the simulator will not allow it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Picobot可以感知其周围的环境。这在它的决策过程中非常重要。例如，如果Picobot正在向北移动，并且它感觉到北面的单元格是一堵墙，那么它就不应该试图继续向北移动！事实上，模拟器也不会允许这样做。
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*I’m currently in an inquisitive state.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*我目前处于一个好奇的状态。*'
- en: 'But how does Picobot “know” whether it is moving north or some other direction?
    Picobot doesn’t have an innate sense of direction. Instead, we make use of a powerful
    concept called *state*. The state of a computer (or a person or almost any other
    thing) is simply its current condition: on or off, happy or sad, underwater or
    in outer space, etc. In computer science, we often use “state” to refer to the
    internal information that describes what a computer is doing.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Picobot如何“知道”自己是在向北移动还是其他方向呢？Picobot没有固有的方向感。相反，我们利用了一个强大的概念，叫做*状态*。计算机（或人或几乎任何其他东西）的状态就是它的当前条件：打开或关闭、快乐或悲伤、在水下或在外太空等等。在计算机科学中，我们经常使用“状态”来指代描述计算机正在做什么的内部信息。
- en: 'Picobot’s state is extremely simple: it is a single number in the range 0-99\.
    Somewhat surprisingly, that’s enough to give Picobot some pretty complex behaviors.
    **Picobot always starts in state 0.**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Picobot的状态非常简单：它是一个在0-99范围内的单个数字。令人惊讶的是，这足以给Picobot带来一些相当复杂的行为。**Picobot总是从状态0开始。**
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*The state of anything can be described with a set of numbers.. but describing
    human states would take at least trillions of values*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何事物的状态都可以用一组数字来描述...但描述人类的状态至少需要数万亿个值*'
- en: Although Picobot’s state is numeric, it’s helpful to think of it in English
    terms. For example, we might think of state 0 as meaning “I’m heading north until
    I can’t go any further.” However, it’s important to note that none of the state
    numbers has any special built-in meaning; it is up to us to make those decisions.
    Moreover, Picobot doesn’t actually have a sense of which directions it is pointing.
    But we can define our own conception of which direction Picobot is “pointing”
    by defining an appropriate set of states.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Picobot 的状态是数字，但用英语术语来考虑会更有帮助。例如，我们可能认为状态0表示“我一直向北走，直到不能再往前为止”。然而，重要的是要注意，这些状态数字没有任何特殊的内置含义；我们需要自己做出这些决定。此外，Picobot
    实际上没有意识到它所指的方向。但我们可以通过定义适当的状态集来确定 Picobot “指向” 的方向。
- en: For example, imagine that Picobot wants to perform the task of continually moving
    north until it gets to a wall. We might decide that state 3 means “I’m heading
    north until I can’t go any further (and when I get to a wall to my north, then
    I’ll consider what to do next!).” When Picobot gets to a wall, it might want to
    enter a new state such as “I’m heading west until I can’t go any further (and
    when I get to a wall to my west, I’ll have to think about what to do then!).”
    We might choose to call that state 42 (or state 4; it’s entirely up to us).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，Picobot 想执行一个任务，持续向北移动直到碰到墙为止。我们可能决定状态3表示“我一直向北走直到不能再往前为止（当我到达北边的墙时，我会考虑下一步该怎么做！）”。当
    Picobot 到达墙时，它可能想进入一个新的状态，比如“我一直向西走直到不能再往前为止（当我到达西边的墙时，我将考虑下一步该怎么做！）”。我们可能选择称之为状态42（或状态4；完全取决于我们）。
- en: '![../Images/states.PNG](../Images/states.PNG)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/states.PNG](../Images/states.PNG)'
- en: 'Figure 1.4: The five parts of two Picobot rules. One useful way to interpret
    the idea of state is to attribute a distinct intention to each state. With these
    two rules, Picobot’s initial state (state 0) represents “go west as far as possible.”'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：两个 Picobot 规则的五个部分。解释状态概念的一种有用方法是为每个状态赋予不同的意图。通过这两条规则，Picobot 的初始状态（状态0）表示“尽可能向西移动”。
- en: As we’ll see next, your job as the Picobot programmer is to define the states
    and their meanings; this is what controls Picobot and makes it do interesting
    things!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们会看到，作为 Picobot 程序员，你的工作是定义状态及其含义；这控制着 Picobot 并使其做出有趣的事情！
- en: '**Takeaway message:** *The state is simply a number representing a task that
    you would like Picobot to undertake.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**要点：** *状态只是一个代表你希望 Picobot 执行的任务的数字。*'
- en: 1.2.4 Think locally, act globally
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 本地思考，全局行动
- en: Now we know how to represent Picobot’s surroundings, and how to represent its
    state. But how do we make Picobot *do* anything?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何表示 Picobot 的周围环境，以及如何表示其状态。但是我们如何使 Picobot *做* 任何事情呢？
- en: 'Picobot moves by following a set of rules that specify actions and possibly
    state changes. Which rule Picobot chooses to follow depends on its current state
    and its current surroundings. Thus, Picobot’s complete “thought process” is as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Picobot 通过遵循一组规则来移动，这些规则指定了行动和可能的状态更改。Picobot 选择遵循哪条规则取决于其当前状态和当前环境。因此，Picobot
    的完整的“思考过程”如下：
- en: I take stock of my current state and immediate surroundings.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我评估我当前的状态和周围环境。
- en: Based on that information, I find a rule that tells me (1) a direction to move
    and (2) the state I want to be in next.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于这些信息，我找到一条规则告诉我（1）要移动的方向和（2）下一个我想要处于的状态。
- en: Picobot uses a five-part rule to express this thought process. Figure 1.4 shows
    two examples of such rules.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Picobot 使用一个五部分规则来表达这个思维过程。图1.4展示了这种规则的两个例子。
- en: The first rule,
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则，
- en: '`0 xxWx -> E 1`'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 xxWx -> E 1`'
- en: re-expressed in English, says “If I’m in state 0 and only my western neighbor
    contains an obstacle, take one step east and change into state 1.” The second
    rule,
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 重新用英语表达，说“如果我处于状态0且只有我的西邻居有障碍物，那么向东移动一步并切换到状态1。”第二条规则，
- en: '`0 xxxx -> W 0`'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 xxxx -> W 0`'
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Go west, young Picobot!*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*向西走，年轻的 Picobot！*'
- en: says “If I’m in state 0 with no obstacles around me, move one step west and
    stay in state 0.” Taken together, these two rules use local information to direct
    Picobot across an open area westward to a boundary.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: says “如果我处于状态0且周围没有障碍物，向西移动一步并保持在状态0。”综合考虑，这两条规则利用局部信息引导 Picobot 横穿开放区域向西移动至边界。
- en: '[![../Images/movingPico.jpg](../Images/movingPico.jpg)](../Images/movingPico.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/movingPico.jpg](../Images/movingPico.jpg)](../Images/movingPico.jpg)'
- en: 'Figure 1.5: The result of running Picobot with this section’s four rules.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：使用本节的四条规则运行 Picobot 的结果。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Remember that Picobot always begins its mission in state 0*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住，Picobot 总是从状态 0 开始它的任务*'
- en: 'At each step, Picobot examines the list of rules that you’ve written looking
    for the *one* rule that applies. A rule applies if the state part of the rule
    matches Picobot’s current state and the surroundings part of the rule matches
    the current surroundings. What happens if there are NO rules that match Picobot’s
    current state and surroundings? The Picobot simulator will let you know about
    this in its *Messages* box and the robot will stop running. Similarly, if more
    than one rule applies, Picobot will also complain. Figure 1.5 shows how Picobot
    follows the first rule that matches its current state and surroundings at each
    time step. But what about state 1? No rules specify Picobot’s actions in state
    1-yet! Just as state 0 represents the “go west” task, we can specify two rules
    that will make state 1 be the “go east” task:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每一步，Picobot 都会检查你编写的规则列表，寻找适用的*一条*规则。如果规则适用，则状态部分与 Picobot 的当前状态匹配，并且环境部分与当前环境匹配。如果没有规则与
    Picobot 的当前状态和环境匹配，会发生什么？Picobot 模拟器将在其*消息*框中告诉你，机器人将停止运行。同样，如果有多条规则适用，Picobot
    也会抱怨。图 1.5 显示了 Picobot 如何按照每个时间步骤当前状态和环境匹配的第一条规则。但是状态 1 呢？目前还没有规则指定 Picobot 在状态
    1 时的动作！就像状态 0 代表“向西行”任务一样，我们可以指定两条规则，使状态 1 成为“向东行”任务：
- en: '`1 xxxx -> E 1`'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 xxxx -> E 1`'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`1 xExx -> W 0`'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 xExx -> W 0`'
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Picobot cannot sense whether or not a cell has been visited. This limitation
    is quite realistic: the Roomba, for example, does not know whether a region has
    already been cleaned.*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*Picobot 无法感知一个单元格是否被访问过。这个限制非常现实：比如，Roomba 就不知道一个区域是否已经被清洁过。*'
- en: These rules transition back to state 0, creating an infinite loop back and forth
    across an open row. Try it out! Note that the Picobot website starts Picobot at
    a randomly selected empty cell. Note also that if Picobot starts along a top or
    bottom wall, no rules match and it does not move! We will remedy this defect in
    the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则回到状态 0，形成了一个无限循环，来回穿越一个开放的行。试试看吧！请注意，Picobot 网站会在随机选择的空单元格中启动 Picobot。同时请注意，如果
    Picobot 从顶部或底部墙壁开始，没有规则匹配，它就不会移动！我们将在下一节解决这个缺陷。
- en: '![../Images/picoTable.PNG](../Images/picoTable.PNG)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/picoTable.PNG](../Images/picoTable.PNG)'
- en: 'Table 1.1: Two equivalent formulations of a more general “go-west-go-east”
    behavior for Picobot. Both sets of rules use only two states, but the wildcard
    character * allows for a much more succinct representation on the left than on
    the right!'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1.1：Picobot 更通用的“东行西行”行为的两种等效表述。两组规则只使用两个状态，但是通配符 * 允许左侧比右侧更简洁地表示！
- en: By the way, sometimes you might not want Picobot to move as the result of applying
    a rule. Rather than specifying a move direction (“E”, ‘W”, “N”, or “S”), you may
    use the upper-case letter “X” to indicate “stay where you are”. For example, the
    rule
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，有时候你可能不希望 Picobot 根据规则移动。而不是指定一个移动方向（“E”、“W”、“N”或“S”），你可以使用大写字母“X”表示“原地不动”。例如，规则
- en: '`0 Nxxx -> X 1`'
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 Nxxx -> X 1`'
- en: is saying “if I’m in state 0 and there is a wall to the north, don’t move but
    enter state 1.”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 是在说“如果我处于状态 0 并且北面有墙壁，则不移动但进入状态 1。”
- en: 1.2.5 Whatever
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.5 任意
- en: The problem with the previous “go-west-go-east” example is that the rules are
    too specific. When going west, we really don’t care whether or not walls are present
    to the north, south, or east. Similarly, when going east, we don’t care about
    neighboring cells to the north, south, or west. The wildcard character * indicates
    that we don’t care about the surroundings in the given position (N, E, W, or S).
    Table 1.1’s rules use the wildcard to direct Picobot to forever visit (vacuum)
    the east-west row in which it starts.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前述“东行西行”示例的问题在于规则过于具体。在向西行进时，我们真的不关心北面、南面或东面是否存在墙壁。同样，在向东行进时，我们不关心北面、南面或西面的相邻单元格。通配符
    * 表示我们不关心给定位置（N、E、W 或 S）的周围环境。表格 1.1 中的规则使用通配符指导 Picobot 永远访问（清洁）它开始的东西向行。
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*Picobot needs to get over its “don’t care” attitude!*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Picobot 需要摆脱它的“不在乎”态度！*'
- en: 1.2.6 Algorithms and Rules
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.6 算法和规则
- en: 'So far we’ve looked at how to write rules that make Picobot move. But in trying
    to solve problems with Picobot, it’s usually helpful to take a more global view
    of how Picobot is accomplishing its task, and then to translate that approach
    into rules. In other words, we want to develop an algorithm that allows Picobot
    to accomplish the desired task, where that task is usually to cover the entire
    room. In the previous section, Picobot had the more modest goal of simply moving
    back and forth in an empty room. The algorithm for accomplishing this task was
    the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何编写让 Picobot 移动的规则。但是在尝试用 Picobot 解决问题时，通常更有帮助的是以更全局的视角来看待 Picobot
    是如何完成任务的，然后将这种方法转化为规则。换句话说，我们想要开发一种算法，允许 Picobot 完成所需的任务，这个任务通常是覆盖整个房间。在前一节中，Picobot
    的目标更为谦逊，只是在一个空房间里来回移动。完成这个任务的算法如下：
- en: Move west until Picobot hits a wall to the west
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向西移动，直到 Picobot 撞到西边的墙
- en: Then move east until Picobot hits a wall to the east
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后向东移动，直到 Picobot 撞到东边的墙
- en: Then go back to step 1
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后回到步骤 1
- en: 'Now the question becomes: how do we translate this algorithm into the rules
    from the previous section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题变成了：如何将这个算法转化为前一节的规则：
- en: '`0 **x* -> W 0`'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 **x* -> W 0`'
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`0 **W* -> E 1`'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0 **W* -> E 1`'
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`1 *x** -> E 1`'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 *x** -> E 1`'
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`1 *E** -> W 0`'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1 *E** -> W 0`'
- en: 'As written, it is difficult to see the connection between the steps of the
    algorithm and the Picobot rules. We can see that Picobot will need two states
    to keep track of which direction it is moving (i.e., is it in step 1 or step 2),
    but it’s still not exactly clear how the algorithm translates into precise rules.
    Essentially, each of Picobot’s rules applies in an “if-then” fashion. In other
    words, if Picobot is in a particular state and sees a particular environment,
    then it takes a certain action and potentially enters a new state. With some minor
    modifications, we can rewrite the algorithm above to follow Picobot’s “if-then”
    rule structure more directly:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就算是按照目前的写法，也很难看出算法步骤和 Picobot 规则之间的联系。我们可以看到 Picobot 需要两个状态来跟踪它的移动方向（即它是在步骤
    1 还是步骤 2），但仍然不太清楚算法如何精确地转化为规则。基本上，Picobot 的每条规则都是以“如果-那么”的方式应用的。换句话说，如果 Picobot
    处于特定状态并且看到特定环境，那么它会采取某种行动，并可能进入新状态。通过一些小的修改，我们可以将上述算法重写为更直接遵循 Picobot“如果-那么”规则结构的方式：
- en: 'Repeat the following steps forever:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复以下步骤直到永远：
- en: If Picobot is moving west and there is no wall to the west, then keep moving
    west.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Picobot 正在向西移动并且西边没有墙，那么继续向西移动。
- en: If Picobot is moving west and there is a wall to the west, then start moving
    east.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Picobot 正在向西移动并且西边有墙，那么开始向东移动。
- en: If Picobot is moving east and there is no wall to the east, then keep moving
    east.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Picobot 正在向东移动并且东边没有墙，那么继续向东移动。
- en: If Picobot is moving east and there is a wall to the east, then start moving
    west.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 Picobot 正在向东移动并且东边有墙，那么开始向西移动。
- en: 'Now we can see more clearly the direct translation between the steps of this
    algorithm and the Picobot rules: each step in the algorithm translates directly
    into a rule in Picobot, where state 0 represents “Picobot is movingWest” and state
    1 represents “Picobot is moving East”. Formulating algorithms in this way is the
    key to writing successful programs in Picobot.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更清楚地看到这个算法步骤与 Picobot 规则之间的直接转化：算法中的每一步直接转化为 Picobot 中的一条规则，其中状态 0 代表“Picobot
    正在向西移动”，状态 1 代表“Picobot 正在向东移动”。以这种方式构思算法是编写 Picobot 成功程序的关键。
- en: 1.2.7 The Picobot challenge
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.7 Picobot 挑战
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*This back-and-forth nwonk saw euqinhcet to ancient Greek ox- ti dellac ohw
    srevird “boustrophedon.” Text in some classical nwonk si stpircsunam to show the
    same .nrettap*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*这种来回曲折的行为看起来似乎与古希腊人“来回曲折”的行为相似。一些古典文本中的文本以此方式显示相同的模式。*'
- en: Table 1.1’s rules direct Picobot to visit the entirety of its starting row.
    This section’s challenge is to develop a set of rules that direct Picobot to cover
    the entirety of an empty rectangular room, such as the rooms in Figure 1.2 and
    1.5\. The set of rules–that is, your program–should work regardless of how big
    the room is and regardless of where Picobot initially begins.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 的规则指导 Picobot 访问其起始行的全部内容。本节的挑战是开发一组规则，指导 Picobot 覆盖一个空的矩形房间的全部内容，比如图
    1.2 和 1.5 中的房间。这组规则——也就是你的程序——应该能够处理房间的大小和 Picobot 初始位置的任意变化。
- en: Because Picobot does not distinguish already-visited from unvisited cells, it
    may not know when it has visited every cell. The online simulator, however, will
    detect and report a successful, complete traversal of an environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Picobot 无法区分已访问的单元与未访问的单元，所以它可能不知道它是否已经访问了每个单元。然而，在线模拟器会检测并报告对环境的成功完全遍历。
- en: Try it out. You might find it helpful to simply play around with modifying the
    rules we’ve given you here. For example, you might start by altering the rules
    in Figure 1.1 so that they side-step into a neighboring row after clearing the
    current one. However, once you have an idea for how you might solve the problem,
    we encourage you to plan your algorithm, and then express that algorithm in a
    way that is easily translatable into Picobot rules.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。你可能会发现简单地玩弄我们在这里给你的规则可能会有所帮助。例如，你可以从修改图1.1中的规则开始，使它们在清除当前行后侧向进入相邻行。然而，一旦你对如何解决问题有了主意，我们鼓励你计划你的算法，然后以一种容易转化为
    Picobot 规则的方式表达出来。
- en: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/Alien7.PNG](../Images/Alien7.PNG)'
- en: '*Thank you for sparing us from any corny maize jokes.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*感谢您没有说任何俏皮的玉米笑话。*'
- en: 1.2.8 A-Maze Your Friends!
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.8 使你的朋友迷失在迷宫中！
- en: Once you’ve developed a Picobot program that completely traverses the empty
    room, try to write other programs for more complex environments. You’ll see a
    “MAP” option on the Picobot Web page where you can scroll forward or backward
    through a collection of maps that we’ve created. You can also edit these maps
    by clicking on a cell with your mouse; clicking on an empty cell turns it into
    a wall and clicking on a wall turns it into an empty cell. *Remember that your
    program should work no matter where Picobot begins.*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开发出一个完全遍历空房间的 Picobot 程序，试着为更复杂的环境编写其他程序。你会在 Picobot 网页上看到一个“MAP”选项，你可以通过我们创建的一系列地图向前或向后滚动。你也可以通过用鼠标点击单元格来编辑这些地图；点击一个空单元格会将其转换为墙壁，点击一个墙壁会将其转换为空单元格。*请记住，你的程序应该在
    Picobot 开始的任何地方都能正常工作。*
- en: '![../Images/maze.jpg](../Images/maze.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/maze.jpg](../Images/maze.jpg)'
- en: 'Figure 1.6: Picobot’s maze.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：Picobot 的迷宫。
- en: One environment that is particularly interesting is the maze shown in Figure
    1.6\. Notice that in this maze, all the walls are connected to the outer boundary
    and all empty cells are adjacent to a wall. A smaller maze with this property
    is shown in Figure 1.7(a). Any maze with this property can be completely explored
    with a simple algorithm called the *right-hand rule* (or the *left-hand rule*
    if you prefer).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有趣的环境是图1.6中显示的迷宫。注意，在这个迷宫中，所有的墙壁都与外边界相连，所有的空单元都与墙壁相邻。一个具有这种特性的较小的迷宫如图1.7（a）所示。任何具有这种特性的迷宫都可以用一个简单的算法来完全探索，这个算法叫做*右手规则*（或者如果你喜欢的话，*左手规则*）。
- en: Imagine for a moment that you are in the maze rather than Picobot. In contrast
    to Picobot, you have a clear sense of the direction you’re pointing and you have
    two hands. You start facing north with your right hand touching the wall. Now,
    you can visit every empty cell by simply walking through the maze, making sure
    that your right hand is always touching the wall. Pause here for a moment to convince
    yourself that this is true. Notice also that this algorithm will not visit every
    cell if some walls are not connected to the outer boundary, as shown in the maze
    in Figure 1.7(b) or if some empty cells are not adjacent to a wall, as shown in
    Figure 1.7(c).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你在迷宫里而不是 Picobot。与 Picobot 相比，你清楚地知道自己指向的方向，并且有两只手。你从北方开始，右手碰到墙壁。现在，你可以通过简单地沿着迷宫行走，确保你的右手始终触碰到墙壁来访问每个空单元。在这里暂停片刻，让自己相信这是真的。还要注意，如果一些墙壁没有与外边界相连，如图1.7（b）中所示的迷宫，或者如果一些空单元不与墙壁相邻，如图1.7（c）所示，则此算法不会访问每个单元。
- en: '![../Images/threemazes.jpg](../Images/threemazes.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![../Images/threemazes.jpg](../Images/threemazes.jpg)'
- en: 'Figure 1.7: (a) A maze in which all walls are connected to the outer boundary
    and all empty cells are adjacent to a wall. (b) A maze in which some walls are
    not connected to the outer boundary. (c) A maze in which some empty cells are
    not adjacent to walls.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：（a）一个迷宫，其中所有墙壁都与外边界相连，所有空单元都与墙壁相邻。（b）一个迷宫，其中一些墙壁没有与外边界相连。（c）一个迷宫，其中一些空单元不与墙壁相邻。
- en: Converting the right-hand rule into a set of Picobot rules is an interesting
    computational challenge. After all, you have a sense of direction and you have
    a right hand that was guiding you around the walls, whereas Picobot has neither
    hands nor a sense of orientation. To “teach” Picobot the right-hand rule, we’ll
    again need to use states to represent the direction that Picobot is pointing.
    It may seem that an impossibly large number of situations must be considered,
    but in fact, the number of situations is finite and actually quite small, which
    makes it possible to program Picobot for this task.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将右手规则转换为一组 Picobot 规则是一个有趣的计算挑战。毕竟，你有方向感，有一只右手在墙壁周围引导你，而 Picobot 既没有手也没有方向感。要“教”
    Picobot 右手规则，我们将再次使用状态来表示 Picobot 指向的方向。可能会觉得需要考虑不可能的大量情况，但实际上，情况的数量是有限的，而且实际上相当小，这使得可以为
    Picobot 编写此任务的程序。
- en: To get started, it seems pretty natural to use the four states 0, 1, 2, and
    3 to represent Picobot pointing north, south, east, or west. Now, we’ll need to
    introduce rules that allow Picobot to behave as if it had a right hand to touch
    against the wall.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，使用四个状态 0、1、2 和 3 来表示 Picobot 指向北、南、东或西是相当自然的。现在，我们需要引入规则，让 Picobot 表现得好像它有一只右手可以触碰墙壁。
- en: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![../Images/Alien7.PNG](../Images/Alien7.PNG)](../Images/Alien7.PNG)'
- en: '*Of course, all empty cells must be reachable. If some cells are isolated from
    others, the problem is just physically impossible.*'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*当然，所有空单元格必须是可达的。如果一些单元格与其他单元格隔离开来，那么问题就根本不可能解决。*'
- en: Assume we are in state 0, which we (arbitrarily) choose to correspond to representing
    Picobot pointing north. Picobot’s imaginary right hand is then pointing east.
    If there is a wall to the east and none to the north, the right-hand rule would
    tell us to take a step to the north and keep pointing north. Taking a step to
    the north is no problem. “Keep pointing north” means “stay in state 0.” On the
    other hand, if we are in state 0 and there is no wall to the east, Picobot should
    take a step to the east and think of itself as pointing to the east. “Pointing
    east” will mean changing to another state that is intended to encode that information.
    This is a fun challenge and we encourage you to stop here and try it. (Remember,
    your program should work regardless of where Picobot starts and for any maze with
    the property that all walls are connected to the outer boundary and all empty
    cells are adjacent to a wall.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们处于状态 0，我们（任意地）选择将其对应于表示 Picobot 指向北。那么 Picobot 的想象中的右手指向东。如果东边有墙而北边没有墙，右手规则告诉我们向北走一步并继续指向北。向北走一步没有问题。“继续指向北”意味着“保持在状态
    0”。另一方面，如果我们处于状态 0 而东边没有墙，Picobot 应该向东走一步，并认为自己指向东。 “指向东” 将意味着更改为另一个打算编码该信息的状态。这是一个有趣的挑战，我们鼓励你停下来尝试一下。（请记住，你的程序应该可以在
    Picobot 启动的任何位置工作，并且对于任何迷宫，其特性是所有墙壁都连接到外边界，所有空单元格都相邻于墙壁。）
- en: 1.2.9 Uncomputable environments
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.9 不可计算的环境
- en: Is it possible to write a Picobot program that will fully explore any room that
    we give it? Surprisingly, the answer is “no,” and it’s possible to prove that
    fact mathematically. Picobot’s computational capabilities aren’t enough to guarantee
    coverage of all environments. However, by adding one simple feature to Picobot,
    it can be programmed to fully explore any room. That feature is the ability to
    drop, sense, and pick up “markers” along the way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 是否可能编写一个 Picobot 程序，使其完全探索我们给定的任何房间？令人惊讶的是，答案是“不”，并且可以数学上证明这个事实。Picobot 的计算能力不足以保证覆盖所有环境。但是，通过为
    Picobot 添加一个简单的功能，它可以被编程为完全探索任何房间。这个功能就是能够在路上放下、感知和拾起“标记”。
- en: The fact that computational challenges as elementary as Picobot lead us to *provably
    unsolvable problems* suggests that computation and computers are far from omnipotent.
    And by the time you’re done reading this book, you’ll have learned how to prove
    that certain problems are beyond the limits of what computers can solve.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 计算挑战，如 Picobot 这样基本的问题导致我们能够*证明无法解决的问题*，这表明计算和计算机远非无所不能。当你读完这本书时，你将学会如何证明某些问题超出了计算机能够解决的范围。
