- en: ListsWorking with Structured Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理结构化数据列表
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Export Induction.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 需要导出 Induction。
- en: Module NatList.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 NatList。
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inductive natprod : Type :='
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳 natprod : 类型 :='
- en: '| pair : nat → nat → natprod.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '| pair : nat → nat → natprod.'
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Check (pair 3 5).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 (pair 3 5).
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Definition fst (p : natprod) : nat :='
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 fst (p : natprod) : nat :='
- en: match p with
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 p 与
- en: '| pair x y ⇒ x'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '| pair x y ⇒ x'
- en: end.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Definition snd (p : natprod) : nat :='
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 snd (p : natprod) : nat :='
- en: match p with
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 p 与
- en: '| pair x y ⇒ y'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '| pair x y ⇒ y'
- en: end.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: Compute (fst (pair 3 5)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 (fst (pair 3 5)).
- en: (* ===> 3 *)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: (* ===> 3 *)
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notation "( x , y )" := (pair x y).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 "( x , y )" := (pair x y).
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Compute (fst (3,5)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 (fst (3,5)).
- en: 'Definition fst'' (p : natprod) : nat :='
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 fst'' (p : natprod) : nat :='
- en: match p with
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 p 与
- en: '| (x,y) ⇒ x'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '| (x,y) ⇒ x'
- en: end.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Definition snd'' (p : natprod) : nat :='
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 snd'' (p : natprod) : nat :='
- en: match p with
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 p 与
- en: '| (x,y) ⇒ y'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '| (x,y) ⇒ y'
- en: end.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Definition swap_pair (p : natprod) : natprod :='
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 swap_pair (p : natprod) : natprod :='
- en: match p with
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 p 与
- en: '| (x,y) ⇒ (y,x)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '| (x,y) ⇒ (y,x)'
- en: end.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Theorem surjective_pairing'' : ∀(n m : nat),'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 surjective_pairing'' : ∀(n m : nat),'
- en: (n,m) = (fst (n,m), snd (n,m)).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (n,m) = (fst (n,m), snd (n,m)).
- en: Proof.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: reflexivity. Qed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 反射性。结束。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Theorem surjective_pairing_stuck : ∀(p : natprod),'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 surjective_pairing_stuck : ∀(p : natprod),'
- en: p = (fst p, snd p).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: p = (fst p, snd p).
- en: Proof.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: simpl. (* Doesn't reduce anything! *)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。(* 不会减少任何东西！*)
- en: Abort.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Theorem surjective_pairing : ∀(p : natprod),'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 surjective_pairing : ∀(p : natprod),'
- en: p = (fst p, snd p).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: p = (fst p, snd p).
- en: Proof.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros p. destruct p as [n m]. simpl. reflexivity. Qed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: intros p. destruct p as [n m]. 简化。反射性。结束。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Theorem snd_fst_is_swap : ∀(p : natprod),'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 snd_fst_is_swap : ∀(p : natprod),'
- en: (snd p, fst p) = swap_pair p.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: (snd p, fst p) = swap_pair p.
- en: Proof.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 放弃。
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Theorem fst_swap_is_snd : ∀(p : natprod),'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 fst_swap_is_snd : ∀(p : natprod),'
- en: fst (swap_pair p) = snd p.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: fst (swap_pair p) = snd p.
- en: Proof.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 放弃。
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Lists of Numbers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字列表
- en: Generalizing the definition of pairs, we can describe the
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 推广对的定义，我们可以描述
- en: 'type of *lists* of numbers like this: "A list is either the empty'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型为*数字*列表的形式： "列表要么为空
- en: list or else a pair of a number and another list."
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表或者一个数字和另一个列表的对。"
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For example, here is a three-element list:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，这是一个三元素列表：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As with pairs, it is more convenient to write lists in
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与对偶一样，更方便地写列表
- en: familiar programming notation.  The following declarations
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 熟悉的编程符号。以下声明
- en: 'allow us to use :: as an infix cons operator and square'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '允许我们使用 :: 作为中缀 cons 运算符和方括号'
- en: brackets as an "outfix" notation for constructing lists.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方括号作为构造列表的“外部”符号。
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is not necessary to understand the details of these
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不需要理解这些细节
- en: declarations, but in case you are interested, here is roughly
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明，但如果您感兴趣，这是大致
- en: what's going on.  The right associativity annotation tells Coq
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发生了什么。右结合性注释告诉 Coq
- en: 'how to parenthesize expressions involving several uses of :: so'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '如何括号化涉及多次使用 :: 的表达式'
- en: that, for example, the next three declarations mean exactly the
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，接下来的三个声明确切地意味着
- en: 'same thing:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样的事情：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The at level 60 part tells Coq how to parenthesize
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: at level 60 部分告诉 Coq 如何括号化
- en: 'expressions that involve both :: and some other infix operator.'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '涉及 :: 和其他中缀运算符的表达式。'
- en: For example, since we defined + as infix notation for the plus
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，由于我们将 + 定义为加法的中缀符号
- en: function at level 50,
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数级别为 50，
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Fixpoint repeat (n count : nat) : natlist :='
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '递归重复 (n count : nat) : natlist :='
- en: match count with
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 count 与
- en: '| O ⇒ nil'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '| O ⇒ nil'
- en: '| S count'' ⇒ n :: (repeat n count'')'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '| S count'' ⇒ n :: (repeat n count'')'
- en: end.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Fixpoint length (l:natlist) : nat :='
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '递归长度 (l:natlist) : nat :='
- en: match l with
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l 与
- en: '| nil ⇒ O'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil ⇒ O'
- en: '| h :: t ⇒ S (length t)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒ S (length t)'
- en: end.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Fixpoint app (l[1] l[2] : natlist) : natlist :='
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '递归 app (l[1] l[2] : natlist) : natlist :='
- en: match l[1] with
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l[1] 与
- en: '| nil    ⇒ l[2]'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil    ⇒ l[2]'
- en: '| h :: t ⇒ h :: (app t l[2])'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒ h :: (app t l[2])'
- en: end.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notation "x ++ y" := (app x y)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 "x ++ y" := (app x y)
- en: (right associativity, at level 60).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: (右结合性，级别为 60)。
- en: 'Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '例如测试_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].'
- en: Proof. reflexivity. Qed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。结束。
- en: 'Example test_app2:             nil ++ [4;5] = [4;5].'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '例如测试_app2:             nil ++ [4;5] = [4;5].'
- en: Proof. reflexivity. Qed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。结束。
- en: 'Example test_app3:             [1;2;3] ++ nil = [1;2;3].'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '例如测试_app3:             [1;2;3] ++ nil = [1;2;3].'
- en: Proof. reflexivity. Qed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。结束。
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Definition hd (default:nat) (l:natlist) : nat :='
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 hd (default:nat) (l:natlist) : nat :='
- en: match l with
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l 与
- en: '| nil ⇒ default'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil ⇒ default'
- en: '| h :: t ⇒ h'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒ h'
- en: end.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Definition tl (l:natlist) : natlist :='
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 tl (l:natlist) : natlist :='
- en: match l with
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l 与
- en: '| nil ⇒ nil'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil ⇒ nil'
- en: '| h :: t ⇒ t'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒ t'
- en: end.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: 'Example test_hd[1]:             hd 0 [1;2;3] = 1.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_hd[1]:             hd 0 [1;2;3] = 1。'
- en: Proof. reflexivity. Qed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。完成。
- en: 'Example test_hd[2]:             hd 0 [] = 0.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_hd[2]:             hd 0 [] = 0。'
- en: Proof. reflexivity. Qed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。完成。
- en: 'Example test_tl:              tl [1;2;3] = [2;3].'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_tl:              tl [1;2;3] = [2;3]。'
- en: Proof. reflexivity. Qed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。反射性。完成。
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Fixpoint nonzeros (l:natlist) : natlist'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint nonzeros (l:natlist) : natlist'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用你的定义替换这一行 *). 已承认。
- en: 'Example test_nonzeros:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_nonzeros:'
- en: nonzeros [0;1;0;2;3;0;0] = [1;2;3].
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: nonzeros [0;1;0;2;3;0;0] = [1;2;3]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: 'Fixpoint oddmembers (l:natlist) : natlist'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint oddmembers (l:natlist) : natlist'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用你的定义替换这一行 *). 已承认。
- en: 'Example test_oddmembers:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_oddmembers:'
- en: oddmembers [0;1;0;2;3;0;0] = [1;3].
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: oddmembers [0;1;0;2;3;0;0] = [1;3].
- en: (* FILL IN HERE *) Admitted.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: 'Definition countoddmembers (l:natlist) : nat'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 countoddmembers (l:natlist) : nat'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用你的定义替换这一行 *). 已承认。
- en: 'Example test_countoddmembers1:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_countoddmembers1:'
- en: countoddmembers [1;0;3;1;4;5] = 4.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: countoddmembers [1;0;3;1;4;5] = 4。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: 'Example test_countoddmembers2:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_countoddmembers2:'
- en: countoddmembers [0;2;4] = 0.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: countoddmembers [0;2;4] = 0。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: 'Example test_countoddmembers3:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_countoddmembers3:'
- en: countoddmembers nil = 0.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: countoddmembers nil = 0。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Fixpoint alternate (l[1] l[2] : natlist) : natlist'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'Fixpoint alternate (l[1] l[2] : natlist) : natlist'
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用你的定义替换这一行 *). 已承认。
- en: 'Example test_alternate1:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_alternate1:'
- en: alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: 'Example test_alternate2:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_alternate2:'
- en: alternate [1] [4;5;6] = [1;4;5;6].
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: alternate [1] [4;5;6] = [1;4;5;6]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: 'Example test_alternate3:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_alternate3:'
- en: alternate [1;2;3] [4] = [1;4;2;3].
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: alternate [1;2;3] [4] = [1;4;2;3]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: 'Example test_alternate4:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_alternate4:'
- en: alternate [] [20;30] = [20;30].
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: alternate [] [20;30] = [20;30]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写 *) 已承认。
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Bags via Lists
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过列表实现袋子
- en: A bag (or multiset) is like a set, except that each element
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个袋子（或多重集）类似于一个集合，只是每个元素
- en: can appear multiple times rather than just once.  One possible
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以出现多次而不仅仅一次。一个可能的
- en: implementation is to represent a bag of numbers as a list.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现是将一个数字袋表示为一个列表。
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Exercise: 3 stars, recommended (bag_functions)'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，推荐（bag_functions）
- en: Complete the following definitions for the functions
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完成以下函数的定义
- en: count, sum, add, and member for bags.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计数，求和，添加和成员对于袋子。
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All these proofs can be done just by reflexivity.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有这些证明都可以通过反射性完成。
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Multiset sum is similar to set union: sum a b contains'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多重集和类似于集合并：sum a b 包含
- en: all the elements of a and of b.  (Mathematicians usually
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a和b的所有元素。（数学家通常
- en: define union on multisets a little bit differently, which
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在多重集上定义联合有点不同，这
- en: is why we don't use that name for this operation.)
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是为什么我们不使用该名称来表示此操作的原因。）
- en: For sum we're giving you a header that does not give explicit
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于sum，我们给出了一个不提供明确的标题
- en: names to the arguments.  Moreover, it uses the keyword
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数的名称。此外，它使用了关键字
- en: Definition instead of Fixpoint, so even if you had names for
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义而不是Fixpoint，所以即使你有名字
- en: the arguments, you wouldn't be able to process them recursively.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数，你将无法递归处理它们。
- en: The point of stating the question this way is to encourage you to
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以这种方式陈述问题的重点是鼓励你
- en: think about whether sum can be implemented in another way —
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 思考一下是否可以用另一种方式实现sum —
- en: perhaps by using functions that have already been defined.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也许通过使用已经定义的函数。
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ☐
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, optional (bag_more_functions)'
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，可选（bag_more_functions）
- en: Here are some more bag functions for you to practice with.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有一些更多的袋子函数让你练习。
- en: When remove_one is applied to a bag without the number to remove,
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当remove_one应用于一个没有��移除的数字的袋子时，
- en: it should return the same bag unchanged.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回相同的袋子不变。
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ☐
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, recommendedM (bag_theorem)'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，推荐M（bag_theorem）
- en: Write down an interesting theorem bag_theorem about bags
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写下一个关于袋子的有趣定理
- en: involving the functions count and add, and prove it.  Note
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 涉及计数和添加函数，并加以证明。注意
- en: that, since this problem is somewhat open-ended, it's possible
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这个问题有点开放，所以可能
- en: that you may come up with a theorem which is true, but whose proof
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会得出一个真实的定理，但其证明
- en: requires techniques you haven't learned yet.  Feel free to ask for
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要你尚未学会的技巧。随时可以寻求帮助！
- en: help if you get stuck!
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你卡住了，寻求帮助！
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ☐
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Theorem nil_app : ∀l:natlist,'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 nil_app : ∀l:natlist,'
- en: '[] ++ l = l.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[] ++ l = l.'
- en: Proof. reflexivity. Qed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Proof. reflexivity. Qed.
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Theorem tl_length_pred : ∀l:natlist,'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 tl_length_pred : ∀l:natlist,'
- en: pred (length l) = length (tl l).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: pred (length l) = length (tl l).
- en: Proof.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Proof.
- en: intros l. destruct l as [| n l'].
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对 l 进行析取 as [| n l']。
- en: '- (* l = nil *)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l = nil *)'
- en: reflexivity.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity.
- en: '- (* l = cons n l'' *)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l = cons n l'' *)'
- en: reflexivity. Qed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity. Qed.
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Micro-Sermon
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微讲道
- en: Simply reading example proof scripts will not get you very far!
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅仅阅读例子证明脚本是不会让你走得太远的！
- en: It is important to work through the details of each one, using Coq
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要详细处理每一个细节，使用 Coq
- en: and thinking about what each step achieves.  Otherwise it is more
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并思考每个步骤达到的目的。否则，它更
- en: or less guaranteed that the exercises will make no sense when you
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或许可以肯定的是，当你
- en: get to them.  'Nuff said.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获得它们。就这样。
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Theorem app_assoc : ∀l[1] l[2] l[3] : natlist,'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 app_assoc : ∀l[1] l[2] l[3] : natlist,'
- en: (l[1] ++ l[2]) ++ l[3] = l[1] ++ (l[2] ++ l[3]).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (l[1] ++ l[2]) ++ l[3] = l[1] ++ (l[2] ++ l[3]).
- en: Proof.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Proof.
- en: intros l[1] l[2] l[3]. induction l[1] as [| n l[1]' IHl1'].
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对 l[1] l[2] l[3] 进行析取。对 l[1] 进行归纳 as [| n l[1]' IHl1']。
- en: '- (* l[1] = nil *)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l[1] = nil *)'
- en: reflexivity.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity.
- en: '- (* l[1] = cons n l[1]'' *)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l[1] = cons n l[1]'' *)'
- en: simpl. rewrite → IHl1'. reflexivity. Qed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。rewrite → IHl1'。reflexivity. Qed.
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ([] ++ l[2]) ++ l[3] = [] ++ (l[2] ++ l[3]),
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ([] ++ l[2]) ++ l[3] = [] ++ (l[2] ++ l[3]),
- en: which follows directly from the definition of ++.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这直接来源于++的定义。
- en: '[PRE35]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: (l[1]' ++ l[2]) ++ l[3] = l[1]' ++ (l[2] ++ l[3])
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (l[1]' ++ l[2]) ++ l[3] = l[1]' ++ (l[2] ++ l[3])
- en: (the induction hypothesis). We must show
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （归纳假设）。我们必须证明
- en: '[PRE36]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: n :: ((l[1]' ++ l[2]) ++ l[3]) = n :: (l[1]' ++ (l[2] ++ l[3])),
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: n :: ((l[1]' ++ l[2]) ++ l[3]) = n :: (l[1]' ++ (l[2] ++ l[3])),
- en: which is immediate from the induction hypothesis. ☐
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是立即从归纳假设得到的。 ☐
- en: '[PRE37]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Fixpoint rev (l:natlist) : natlist :='
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 rev (l:natlist) : natlist :='
- en: match l with
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 l，有
- en: '| nil    ⇒ nil'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '| nil    ⇒ nil'
- en: '| h :: t ⇒ rev t ++ [h]'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '| h :: t ⇒ rev t ++ [h]'
- en: end.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: end.
- en: 'Example test_rev1:            rev [1;2;3] = [3;2;1].'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_rev1:            rev [1;2;3] = [3;2;1].'
- en: Proof. reflexivity. Qed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Proof. reflexivity. Qed.
- en: 'Example test_rev2:            rev nil = nil.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 test_rev2:            rev nil = nil.'
- en: Proof. reflexivity. Qed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Proof. reflexivity. Qed.
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Theorem rev_length_firsttry : ∀l : natlist,'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rev_length_firsttry : ∀l : natlist,'
- en: length (rev l) = length l.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: length (rev l) = length l.
- en: Proof.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Proof.
- en: intros l. induction l as [| n l' IHl'].
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对 l 进行归纳 as [| n l' IHl']。
- en: '- (* l =  *)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l =  *)'
- en: reflexivity.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity.
- en: '- (* l = n :: l'' *)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l = n :: l'' *)'
- en: (* This is the tricky case.  Let's begin as usual        by simplifying. *)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: (* 这是棘手的情况。 让我们像往常一样开始简化。*)
- en: simpl.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。
- en: (* Now we seem to be stuck: the goal is an equality        involving ++, but we don't have any useful equations
           in either the immediate context or in the global        environment!  We can make a little progress by using
           the IH to rewrite the goal... *)
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: (* 现在我们似乎卡住了：目标是一个涉及 ++ 的等式，但是我们在当前上下文或全局环境中没有任何有用的等式！我们可以通过使用归纳假设来重写目标，稍微取得一点进展...*)
- en: rewrite ← IHl'.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: rewrite ← IHl'.
- en: (* ... but now we can't go any further. *)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: (* ... 但是我们无法再继续下去了。 *)
- en: Abort.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Theorem app_length : ∀l[1] l[2] : natlist,'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 app_length : ∀l[1] l[2] : natlist,'
- en: length (l[1] ++ l[2]) = (length l[1]) + (length l[2]).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: length (l[1] ++ l[2]) = (length l[1]) + (length l[2]).
- en: Proof.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Proof.
- en: (* WORKED IN CLASS *)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: (* 课上的工作 *)
- en: intros l[1] l[2]. induction l[1] as [| n l[1]' IHl1'].
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对 l[1] l[2] 进行归纳。对 l[1] 进行归纳 as [| n l[1]' IHl1']。
- en: '- (* l[1] = nil *)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l[1] = nil *)'
- en: reflexivity.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity.
- en: '- (* l[1] = cons *)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l[1] = cons *)'
- en: simpl. rewrite → IHl1'. reflexivity. Qed.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。rewrite → IHl1'。reflexivity. Qed.
- en: '[PRE41]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Theorem rev_length : ∀l : natlist,'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 rev_length : ∀l : natlist,'
- en: length (rev l) = length l.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: length (rev l) = length l.
- en: Proof.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Proof.
- en: intros l. induction l as [| n l' IHl'].
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对 l 进行归纳 as [| n l' IHl']。
- en: '- (* l = nil *)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l = nil *)'
- en: reflexivity.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: reflexivity.
- en: '- (* l = cons *)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* l = cons *)'
- en: simpl. rewrite → app_length, plus_comm.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。rewrite → app_length, plus_comm。
- en: simpl. rewrite → IHl'. reflexivity. Qed.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 简化。rewrite → IHl'。reflexivity. Qed.
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: length ([] ++ l[2]) = length [] + length l[2],
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: length ([] ++ l[2]) = length [] + length l[2],
- en: which follows directly from the definitions of length and ++.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这直接来源于 length 和 ++ 的定义。
- en: '[PRE43]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: length (l[1]' ++ l[2]) = length l[1]' + length l[2].
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: length (l[1]' ++ l[2]) = length l[1]' + length l[2].
- en: We must show
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们必须证明
- en: '[PRE44]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: length (rev []) = length [],
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: length (rev []) = length [],
- en: which follows directly from the definitions of length and rev.
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这直接来源于 length 和 rev 的定义。
- en: '[PRE46]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: length (rev l') = length l'.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: length (rev l') = length l'.
- en: We must show
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们必须证明
- en: '[PRE47]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: length ((rev l') ++ [n]) = S (length l')
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: length ((rev l') ++ [n]) = S (length l')
- en: which, by the previous lemma, is the same as
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，根据前面的引理，是一样的
- en: '[PRE48]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Search
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: We've seen that proofs can make use of other theorems we've
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经看到证明可以利用我们已经
- en: already proved, e.g., using rewrite.  But in order to refer to a
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 已经证明，例如，使用rewrite。但是为了引用
- en: theorem, we need to know its name!  Indeed, it is often hard even
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定理，我们需要知道它的名称！实际上，甚至很难
- en: to remember what theorems have been proven, much less what they
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要记住已经证明了哪些定理，更不用说它们
- en: are called.
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被称为。
- en: Coq's Search command is quite helpful with this.  Typing
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq的Search命令在这方面非常有帮助。输入
- en: Search foo will cause Coq to display a list of all theorems
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 搜索foo将导致Coq显示所有定理的列表
- en: involving foo.  For example, try uncommenting the following line
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 涉及foo。例如，尝试取消注释以下行
- en: 'to see a list of theorems that we have proved about rev:'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看我们已经证明的关于rev的定理列表：
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Keep Search in mind as you do the following exercises and
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在做以下练习时请记住搜索
- en: throughout the rest of the book; it can save you a lot of time!
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本书的其余部分中；它可以节省您很多时间！
- en: If you are using ProofGeneral, you can run Search with C-c C-a C-a. Pasting
    its response into your buffer can be
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在使用ProofGeneral，你可以用C-c C-a C-a运行搜索。将其响应粘贴到您的缓冲区中可能会
- en: accomplished with C-c C-;.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用C-c C-;完成。
- en: '[PRE52]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Theorem app_nil_r : ∀l : natlist,'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 定理app_nil_r：∀l：natlist，
- en: l ++ [] = l.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: l ++ [] = l。
- en: Proof.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: 'Theorem rev_app_distr: ∀l[1] l[2] : natlist,'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 定理rev_app_distr：∀l[1] l[2]：natlist，
- en: rev (l[1] ++ l[2]) = rev l[2] ++ rev l[1].
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: rev（l[1] ++ l[2]）= rev l[2] ++ rev l[1]。
- en: Proof.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: 'Theorem rev_involutive : ∀l : natlist,'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 定理rev_involutive：∀l：natlist，
- en: rev (rev l) = l.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: rev（rev l）= l。
- en: Proof.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: '[PRE53]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Theorem app_assoc4 : ∀l[1] l[2] l[3] l[4] : natlist,'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 定理app_assoc4：∀l[1] l[2] l[3] l[4]：natlist，
- en: l[1] ++ (l[2] ++ (l[3] ++ l[4])) = ((l[1] ++ l[2]) ++ l[3]) ++ l[4].
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: l[1] ++（l[2] ++（l[3] ++ l[4]））=（（l[1] ++ l[2]）++ l[3]）++ l[4]。
- en: Proof.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: '[PRE54]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Lemma nonzeros_app : ∀l[1] l[2] : natlist,'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 引理nonzeros_app：∀l[1] l[2]：natlist，
- en: nonzeros (l[1] ++ l[2]) = (nonzeros l[1]) ++ (nonzeros l[2]).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 非零（l[1] ++ l[2]）=（nonzeros l[1]）++（nonzeros l[2]）。
- en: Proof.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: '[PRE55]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Fixpoint beq_natlist (l[1] l[2] : natlist) : bool'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Fixpoint beq_natlist（l[1] l[2]：natlist）：bool
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ." 替换此行*）。已承认。
- en: 'Example test_beq_natlist1 :'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 示例test_beq_natlist1：
- en: (beq_natlist nil nil = true).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: （beq_natlist nil nil = true）。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: 'Example test_beq_natlist2 :'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 示例test_beq_natlist2：
- en: beq_natlist [1;2;3] [1;2;3] = true.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: beq_natlist [1;2;3] [1;2;3] = true。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: 'Example test_beq_natlist3 :'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 示例test_beq_natlist3：
- en: beq_natlist [1;2;3] [1;2;4] = false.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: beq_natlist [1;2;3] [1;2;4] = false。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: 'Theorem beq_natlist_refl : ∀l:natlist,'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 定理beq_natlist_refl：∀l：natlist，
- en: true = beq_natlist l l.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: true = beq_natlist l l。
- en: Proof.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) 已承认。
- en: '[PRE56]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: List Exercises, Part 2
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表练习，第2部分
- en: 'Exercise: 3 stars, advanced (bag_proofs)'
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，高级（bag_proofs）
- en: Here are a couple of little theorems to prove about your
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有几个关于你的小定理要证明
- en: definitions about bags above.
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面关于bags的定义。
- en: '[PRE57]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The following lemma about leb might help you in the next proof.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面关于leb的引理可能会在下一个证明中帮助你。
- en: '[PRE58]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ☐
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, optionalM (bag_count_sum)'
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，可选M（bag_count_sum）
- en: Write down an interesting theorem bag_count_sum about bags
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写下一个有趣的关于bags的定理bag_count_sum
- en: involving the functions count and sum, and prove it.  (You may
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 涉及函数count和sum，并证明它。（您可以
- en: find that the difficulty of the proof depends on how you defined
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发现证明的难度取决于你如何定义
- en: count!)
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计数！
- en: '[PRE59]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ☐
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 4 stars, advancedM (rev_injective)'
  id: totrans-379
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：4星，高级M（rev_injective）
- en: Prove that the rev function is injective — that is,
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明rev函数是单射的-也就是说，
- en: '[PRE60]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: (* FILL IN HERE *)
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*)
- en: '[PRE61]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Options
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项
- en: Suppose we want to write a function that returns the nth
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们想要编写��个返回第n个的函数
- en: element of some list.  If we give it type nat → natlist → nat,
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些列表的元素。如果我们给它类型nat → natlist → nat，
- en: then we'll have to choose some number to return when the list is
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们将不得不选择一个数字返回，当列表是
- en: too short...
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 太短了...
- en: '[PRE62]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This solution is not so good: If nth_bad returns 42, we'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个解决方案不太好：如果nth_bad返回42，我们
- en: can't tell whether that value actually appears on the input
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无法确定该值是否实际出现在输入中
- en: without further processing. A better alternative is to change the
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无需进一步处理。更好的选择是更改
- en: return type of nth_bad to include an error value as a possible
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回nth_bad的类型包括一个错误值作为可能的
- en: outcome. We call this type natoption.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果。我们称这种类型为natoption。
- en: '[PRE63]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We can then change the above definition of nth_bad to
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们可以改变 nth_bad 的上述定义为
- en: return None when the list is too short and Some a when the
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当列表太短时返回 None，并在
- en: list has enough members and a appears at position n. We call
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表有足够的成员，并且 a 出现在位置 n。我们叫
- en: this new function nth_error to indicate that it may result in an
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新函数 nth_error 来指示它可能会导致一个
- en: error.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误。
- en: '[PRE64]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: (In the HTML version, the boilerplate proofs of these
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （在 HTML 版本中，这些的样板证明
- en: examples are elided.  Click on a box if you want to see one.)
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 示例已省略。如果要查看，请单击框。）
- en: This example is also an opportunity to introduce one more small
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个例子也是介绍另一个小的机会
- en: 'feature of Coq''s programming language: conditional'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 的编程语言的特征：条件
- en: expressions...
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达式…
- en: '[PRE65]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Coq's conditionals are exactly like those found in any other
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 的条件语句与其他任何地方找到的条件语句完全相同
- en: language, with one small generalization.  Since the boolean type
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语言，具有一个小的概括。由于布尔类型
- en: is not built in, Coq actually supports conditional expressions over
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不是内置的，Coq 实际上支持条件表达式
- en: '*any* inductively defined type with exactly two constructors.  The'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*任何*归纳定义类型，有两个构造函数。这个'
- en: guard is considered true if it evaluates to the first constructor
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 guard 求值为第一个构造函数，则被视为 true。
- en: in the Inductive definition and false if it evaluates to the
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在归纳定义中，如果求值为 false，则返回
- en: second.
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二。
- en: The function below pulls the nat out of a natoption, returning
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的函数从 natoption 中提取 nat，返回
- en: a supplied default in the None case.
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 None 情况下提供默认值。
- en: '[PRE66]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Exercise: 2 stars (hd_error)'
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星（hd_error）
- en: Using the same idea, fix the hd function from earlier so we don't
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用相同的思想，修复早期的 hd 函数，以便我们不会
- en: have to pass a default element for the nil case.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须为 nil 情况传递一个默认元素。
- en: '[PRE67]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ☐
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 1 star, optional (option_elim_hd)'
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星，可选（option_elim_hd）
- en: This exercise relates your new hd_error to the old hd.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个练习将您的新 hd_error 与旧 hd 相关联。
- en: '[PRE68]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ☐
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE69]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Partial Maps
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分映射
- en: As a final illustration of how data structures can be defined in
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为数据结构可以在最后一个示例中如何定义的最后一个示例
- en: Coq, here is a simple *partial map* data type, analogous to the
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq，这是一个简单的 *部分映射* 数据类型，类似于
- en: map or dictionary data structures found in most programming
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数编程中找到的映射或字典数据结构
- en: languages.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语言。
- en: First, we define a new inductive datatype id to serve as the
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们定义一个新的归纳数据类型 id 来充当
- en: '"keys" of our partial maps.'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的部分映射的“键”。
- en: '[PRE70]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Internally, an id is just a number.  Introducing a separate type
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 内部，id 只是一个数字。引入一个单独的类型
- en: by wrapping each nat with the tag Id makes definitions more
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过用标签 Id 包装每个 nat 来使定义更加
- en: readable and gives us the flexibility to change representations
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可读性，并为我们提供更改表示的灵活性
- en: later if we wish.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以后如果我们希望的话。
- en: 'We''ll also need an equality test for ids:'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要一个 id 的相等性测试：
- en: '[PRE71]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Exercise: 1 star (beq_id_refl)'
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（beq_id_refl）
- en: '[PRE72]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ☐
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Now we define the type of partial maps:'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们定义部分映射的类型：
- en: '[PRE73]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This declaration can be read: "There are two ways to construct a'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个声明可以这样读：“构造
- en: 'partial_map: either using the constructor empty to represent an'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: partial_map：使用构造函数 empty 表示一个
- en: empty partial map, or by applying the constructor record to
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 空部分映射，或通过将构造函数记录应用于
- en: a key, a value, and an existing partial_map to construct a
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个键，一个值和一个现有的 partial_map 来构造一个
- en: partial_map with an additional key-to-value mapping."
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 带有附加键值映射的 partial_map。”
- en: The update function overrides the entry for a given key in a
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新函数覆盖了给定键的条目
- en: partial map (or adds a new entry if the given key is not already
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 部分映射（如果给定键尚未存在，则添加新条目
- en: present).
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存在）。
- en: '[PRE74]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Last, the find function searches a partial_map for a given
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，find 函数在 partial_map 中搜索给定的
- en: key.  It returns None if the key was not found and Some val if
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键。如果找不到键，则返回 None，如果找到则返回 Some val
- en: the key was associated with val. If the same key is mapped to
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键与 val 关联。如果同一个键映射到
- en: multiple values, find will return the first one it
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多个值，find 将返回第一个找到的值
- en: encounters.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遇到。
- en: '[PRE75]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Exercise: 1 star (update_eq)'
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（update_eq）
- en: '[PRE76]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ☐
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 1 star (update_neq)'
  id: totrans-465
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星（update_neq）
- en: '[PRE77]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ☐
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE78]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Exercise: 2 starsM (baz_num_elts)'
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星M（baz_num_elts）
- en: 'Consider the following inductive definition:'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下归纳定义：
- en: '[PRE79]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How *many* elements does the type baz have?  (Answer in English
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型 baz 有多少个元素？（英文回答
- en: or the natural language of your choice.)
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或您选择的自然语言。）
- en: (* FILL IN HERE *)
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （在这里填充）
- en: ☐
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE80]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
