- en: ListsWorking with Structured Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export Induction.
  prefs: []
  type: TYPE_NORMAL
- en: Module NatList.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive natprod : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| pair : nat → nat → natprod.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Check (pair 3 5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition fst (p : natprod) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  prefs: []
  type: TYPE_NORMAL
- en: '| pair x y ⇒ x'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition snd (p : natprod) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  prefs: []
  type: TYPE_NORMAL
- en: '| pair x y ⇒ y'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: Compute (fst (pair 3 5)).
  prefs: []
  type: TYPE_NORMAL
- en: (* ===> 3 *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notation "( x , y )" := (pair x y).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Compute (fst (3,5)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition fst'' (p : natprod) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  prefs: []
  type: TYPE_NORMAL
- en: '| (x,y) ⇒ x'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition snd'' (p : natprod) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  prefs: []
  type: TYPE_NORMAL
- en: '| (x,y) ⇒ y'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition swap_pair (p : natprod) : natprod :='
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  prefs: []
  type: TYPE_NORMAL
- en: '| (x,y) ⇒ (y,x)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem surjective_pairing'' : ∀(n m : nat),'
  prefs: []
  type: TYPE_NORMAL
- en: (n,m) = (fst (n,m), snd (n,m)).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem surjective_pairing_stuck : ∀(p : natprod),'
  prefs: []
  type: TYPE_NORMAL
- en: p = (fst p, snd p).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. (* Doesn't reduce anything! *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem surjective_pairing : ∀(p : natprod),'
  prefs: []
  type: TYPE_NORMAL
- en: p = (fst p, snd p).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros p. destruct p as [n m]. simpl. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem snd_fst_is_swap : ∀(p : natprod),'
  prefs: []
  type: TYPE_NORMAL
- en: (snd p, fst p) = swap_pair p.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem fst_swap_is_snd : ∀(p : natprod),'
  prefs: []
  type: TYPE_NORMAL
- en: fst (swap_pair p) = snd p.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Lists of Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generalizing the definition of pairs, we can describe the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'type of *lists* of numbers like this: "A list is either the empty'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: list or else a pair of a number and another list."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, here is a three-element list:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As with pairs, it is more convenient to write lists in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: familiar programming notation.  The following declarations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'allow us to use :: as an infix cons operator and square'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: brackets as an "outfix" notation for constructing lists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is not necessary to understand the details of these
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: declarations, but in case you are interested, here is roughly
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: what's going on.  The right associativity annotation tells Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'how to parenthesize expressions involving several uses of :: so'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that, for example, the next three declarations mean exactly the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'same thing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The at level 60 part tells Coq how to parenthesize
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'expressions that involve both :: and some other infix operator.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, since we defined + as infix notation for the plus
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function at level 50,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint repeat (n count : nat) : natlist :='
  prefs: []
  type: TYPE_NORMAL
- en: match count with
  prefs: []
  type: TYPE_NORMAL
- en: '| O ⇒ nil'
  prefs: []
  type: TYPE_NORMAL
- en: '| S count'' ⇒ n :: (repeat n count'')'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint length (l:natlist) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil ⇒ O'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒ S (length t)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint app (l[1] l[2] : natlist) : natlist :='
  prefs: []
  type: TYPE_NORMAL
- en: match l[1] with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil    ⇒ l[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒ h :: (app t l[2])'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notation "x ++ y" := (app x y)
  prefs: []
  type: TYPE_NORMAL
- en: (right associativity, at level 60).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_app1:             [1;2;3] ++ [4;5] = [1;2;3;4;5].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_app2:             nil ++ [4;5] = [4;5].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_app3:             [1;2;3] ++ nil = [1;2;3].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition hd (default:nat) (l:natlist) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil ⇒ default'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒ h'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition tl (l:natlist) : natlist :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil ⇒ nil'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒ t'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_hd[1]:             hd 0 [1;2;3] = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_hd[2]:             hd 0 [] = 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_tl:              tl [1;2;3] = [2;3].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint nonzeros (l:natlist) : natlist'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_nonzeros:'
  prefs: []
  type: TYPE_NORMAL
- en: nonzeros [0;1;0;2;3;0;0] = [1;2;3].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint oddmembers (l:natlist) : natlist'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_oddmembers:'
  prefs: []
  type: TYPE_NORMAL
- en: oddmembers [0;1;0;2;3;0;0] = [1;3].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition countoddmembers (l:natlist) : nat'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_countoddmembers1:'
  prefs: []
  type: TYPE_NORMAL
- en: countoddmembers [1;0;3;1;4;5] = 4.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_countoddmembers2:'
  prefs: []
  type: TYPE_NORMAL
- en: countoddmembers [0;2;4] = 0.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_countoddmembers3:'
  prefs: []
  type: TYPE_NORMAL
- en: countoddmembers nil = 0.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint alternate (l[1] l[2] : natlist) : natlist'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_alternate1:'
  prefs: []
  type: TYPE_NORMAL
- en: alternate [1;2;3] [4;5;6] = [1;4;2;5;3;6].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_alternate2:'
  prefs: []
  type: TYPE_NORMAL
- en: alternate [1] [4;5;6] = [1;4;5;6].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_alternate3:'
  prefs: []
  type: TYPE_NORMAL
- en: alternate [1;2;3] [4] = [1;4;2;3].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_alternate4:'
  prefs: []
  type: TYPE_NORMAL
- en: alternate [] [20;30] = [20;30].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Bags via Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A bag (or multiset) is like a set, except that each element
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can appear multiple times rather than just once.  One possible
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: implementation is to represent a bag of numbers as a list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, recommended (bag_functions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Complete the following definitions for the functions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: count, sum, add, and member for bags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All these proofs can be done just by reflexivity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiset sum is similar to set union: sum a b contains'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all the elements of a and of b.  (Mathematicians usually
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: define union on multisets a little bit differently, which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is why we don't use that name for this operation.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For sum we're giving you a header that does not give explicit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: names to the arguments.  Moreover, it uses the keyword
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Definition instead of Fixpoint, so even if you had names for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the arguments, you wouldn't be able to process them recursively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The point of stating the question this way is to encourage you to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: think about whether sum can be implemented in another way —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: perhaps by using functions that have already been defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (bag_more_functions)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here are some more bag functions for you to practice with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When remove_one is applied to a bag without the number to remove,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it should return the same bag unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, recommendedM (bag_theorem)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write down an interesting theorem bag_theorem about bags
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involving the functions count and add, and prove it.  Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that, since this problem is somewhat open-ended, it's possible
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that you may come up with a theorem which is true, but whose proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: requires techniques you haven't learned yet.  Feel free to ask for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: help if you get stuck!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem nil_app : ∀l:natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: '[] ++ l = l.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem tl_length_pred : ∀l:natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: pred (length l) = length (tl l).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros l. destruct l as [| n l'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l = nil *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l = cons n l'' *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Micro-Sermon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply reading example proof scripts will not get you very far!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is important to work through the details of each one, using Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and thinking about what each step achieves.  Otherwise it is more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or less guaranteed that the exercises will make no sense when you
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get to them.  'Nuff said.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem app_assoc : ∀l[1] l[2] l[3] : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: (l[1] ++ l[2]) ++ l[3] = l[1] ++ (l[2] ++ l[3]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros l[1] l[2] l[3]. induction l[1] as [| n l[1]' IHl1'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l[1] = nil *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l[1] = cons n l[1]'' *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite → IHl1'. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: ([] ++ l[2]) ++ l[3] = [] ++ (l[2] ++ l[3]),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which follows directly from the definition of ++.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: (l[1]' ++ l[2]) ++ l[3] = l[1]' ++ (l[2] ++ l[3])
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (the induction hypothesis). We must show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: n :: ((l[1]' ++ l[2]) ++ l[3]) = n :: (l[1]' ++ (l[2] ++ l[3])),
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which is immediate from the induction hypothesis. ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Fixpoint rev (l:natlist) : natlist :='
  prefs: []
  type: TYPE_NORMAL
- en: match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| nil    ⇒ nil'
  prefs: []
  type: TYPE_NORMAL
- en: '| h :: t ⇒ rev t ++ [h]'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_rev1:            rev [1;2;3] = [3;2;1].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_rev2:            rev nil = nil.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem rev_length_firsttry : ∀l : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: length (rev l) = length l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros l. induction l as [| n l' IHl'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l =  *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l = n :: l'' *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* This is the tricky case.  Let's begin as usual        by simplifying. *)
  prefs: []
  type: TYPE_NORMAL
- en: simpl.
  prefs: []
  type: TYPE_NORMAL
- en: (* Now we seem to be stuck: the goal is an equality        involving ++, but we don't have any useful equations
           in either the immediate context or in the global        environment!  We can make a little progress by using
           the IH to rewrite the goal... *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← IHl'.
  prefs: []
  type: TYPE_NORMAL
- en: (* ... but now we can't go any further. *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem app_length : ∀l[1] l[2] : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: length (l[1] ++ l[2]) = (length l[1]) + (length l[2]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* WORKED IN CLASS *)
  prefs: []
  type: TYPE_NORMAL
- en: intros l[1] l[2]. induction l[1] as [| n l[1]' IHl1'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l[1] = nil *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l[1] = cons *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite → IHl1'. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem rev_length : ∀l : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: length (rev l) = length l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros l. induction l as [| n l' IHl'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l = nil *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* l = cons *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite → app_length, plus_comm.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite → IHl'. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: length ([] ++ l[2]) = length [] + length l[2],
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which follows directly from the definitions of length and ++.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: length (l[1]' ++ l[2]) = length l[1]' + length l[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We must show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: length (rev []) = length [],
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which follows directly from the definitions of length and rev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: length (rev l') = length l'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We must show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: length ((rev l') ++ [n]) = S (length l')
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which, by the previous lemma, is the same as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that proofs can make use of other theorems we've
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: already proved, e.g., using rewrite.  But in order to refer to a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: theorem, we need to know its name!  Indeed, it is often hard even
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to remember what theorems have been proven, much less what they
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq's Search command is quite helpful with this.  Typing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Search foo will cause Coq to display a list of all theorems
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involving foo.  For example, try uncommenting the following line
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'to see a list of theorems that we have proved about rev:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Keep Search in mind as you do the following exercises and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: throughout the rest of the book; it can save you a lot of time!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you are using ProofGeneral, you can run Search with C-c C-a C-a. Pasting
    its response into your buffer can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: accomplished with C-c C-;.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem app_nil_r : ∀l : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: l ++ [] = l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rev_app_distr: ∀l[1] l[2] : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: rev (l[1] ++ l[2]) = rev l[2] ++ rev l[1].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem rev_involutive : ∀l : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: rev (rev l) = l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem app_assoc4 : ∀l[1] l[2] l[3] l[4] : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: l[1] ++ (l[2] ++ (l[3] ++ l[4])) = ((l[1] ++ l[2]) ++ l[3]) ++ l[4].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma nonzeros_app : ∀l[1] l[2] : natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: nonzeros (l[1] ++ l[2]) = (nonzeros l[1]) ++ (nonzeros l[2]).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint beq_natlist (l[1] l[2] : natlist) : bool'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_beq_natlist1 :'
  prefs: []
  type: TYPE_NORMAL
- en: (beq_natlist nil nil = true).
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_beq_natlist2 :'
  prefs: []
  type: TYPE_NORMAL
- en: beq_natlist [1;2;3] [1;2;3] = true.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example test_beq_natlist3 :'
  prefs: []
  type: TYPE_NORMAL
- en: beq_natlist [1;2;3] [1;2;4] = false.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem beq_natlist_refl : ∀l:natlist,'
  prefs: []
  type: TYPE_NORMAL
- en: true = beq_natlist l l.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: List Exercises, Part 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced (bag_proofs)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here are a couple of little theorems to prove about your
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions about bags above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The following lemma about leb might help you in the next proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optionalM (bag_count_sum)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write down an interesting theorem bag_count_sum about bags
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: involving the functions count and sum, and prove it.  (You may
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: find that the difficulty of the proof depends on how you defined
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: count!)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 stars, advancedM (rev_injective)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove that the rev function is injective — that is,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we want to write a function that returns the nth
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: element of some list.  If we give it type nat → natlist → nat,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then we'll have to choose some number to return when the list is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: too short...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution is not so good: If nth_bad returns 42, we'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can't tell whether that value actually appears on the input
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: without further processing. A better alternative is to change the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return type of nth_bad to include an error value as a possible
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: outcome. We call this type natoption.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We can then change the above definition of nth_bad to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return None when the list is too short and Some a when the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: list has enough members and a appears at position n. We call
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this new function nth_error to indicate that it may result in an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: (In the HTML version, the boilerplate proofs of these
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: examples are elided.  Click on a box if you want to see one.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This example is also an opportunity to introduce one more small
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'feature of Coq''s programming language: conditional'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Coq's conditionals are exactly like those found in any other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language, with one small generalization.  Since the boolean type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is not built in, Coq actually supports conditional expressions over
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*any* inductively defined type with exactly two constructors.  The'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: guard is considered true if it evaluates to the first constructor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the Inductive definition and false if it evaluates to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The function below pulls the nat out of a natoption, returning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a supplied default in the None case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars (hd_error)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the same idea, fix the hd function from earlier so we don't
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: have to pass a default element for the nil case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, optional (option_elim_hd)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This exercise relates your new hd_error to the old hd.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Partial Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a final illustration of how data structures can be defined in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq, here is a simple *partial map* data type, analogous to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: map or dictionary data structures found in most programming
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: languages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we define a new inductive datatype id to serve as the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"keys" of our partial maps.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Internally, an id is just a number.  Introducing a separate type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by wrapping each nat with the tag Id makes definitions more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: readable and gives us the flexibility to change representations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: later if we wish.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll also need an equality test for ids:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (beq_id_refl)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we define the type of partial maps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This declaration can be read: "There are two ways to construct a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'partial_map: either using the constructor empty to represent an'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: empty partial map, or by applying the constructor record to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a key, a value, and an existing partial_map to construct a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: partial_map with an additional key-to-value mapping."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The update function overrides the entry for a given key in a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: partial map (or adds a new entry if the given key is not already
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: present).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Last, the find function searches a partial_map for a given
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: key.  It returns None if the key was not found and Some val if
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the key was associated with val. If the same key is mapped to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multiple values, find will return the first one it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: encounters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (update_eq)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (update_neq)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 starsM (baz_num_elts)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following inductive definition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How *many* elements does the type baz have?  (Answer in English
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: or the natural language of your choice.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
