["```\n\n```", "```\n\n    In previous chapters, we have seen many examples of factual\n    claims (*propositions*) and ways of presenting evidence of their\n    truth (*proofs*).  In particular, we have worked extensively with\n    *equality propositions* of the form e[1] = e[2], with\n    implications (P \u2192 Q), and with quantified propositions (\u2200 x, P).  In this chapter, we will see how Coq can be used to carry\n    out other familiar forms of logical reasoning.\n\n    Before diving into details, let's talk a bit about the status of\n    mathematical statements in Coq.  Recall that Coq is a *typed*\n    language, which means that every sensible expression in its world\n    has an associated type.  Logical claims are no exception: any\n    statement we might try to prove in Coq has a type, namely Prop,\n    the type of *propositions*.  We can see this with the Check\n    command:\n\n```", "```\n\n    Note that *all* syntactically well-formed propositions have type\n    Prop in Coq, regardless of whether they are true or not.\n\n    Simply *being* a proposition is one thing; being *provable* is\n    something else!\n\n```", "```\n\n    Indeed, propositions don't just have types: they are *first-class objects* that can be manipulated in the same ways as the other\n    entities in Coq's world.  So far, we've seen one primary place\n    that propositions can appear: in Theorem (and Lemma and\n    Example) declarations.\n\n```", "```\n\n    But propositions can be used in many other ways.  For example, we\n    can give a name to a proposition using a Definition, just as we\n    have given names to expressions of other sorts.\n\n```", "```\n\n    We can later use this name in any situation where a proposition is\n    expected \u2014 for example, as the claim in a Theorem declaration.\n\n```", "```\n\n    We can also write *parameterized* propositions \u2014 that is,\n    functions that take arguments of some type and return a\n    proposition. \n\n    For instance, the following function takes a number\n    and returns a proposition asserting that this number is equal to\n    three:\n\n```", "```\n\n    In Coq, functions that return propositions are said to define\n    *properties* of their arguments.\n\n    For instance, here's a (polymorphic) property defining the\n    familiar notion of an *injective function*.\n\n```", "```\n\n    The equality operator = is also a function that returns a\n    Prop.\n\n    The expression n = m is syntactic sugar for eq n m, defined\n    using Coq's Notation mechanism. Because eq can be used with\n    elements of any type, it is also polymorphic:\n\n```", "```\n\n    (Notice that we wrote @eq instead of eq: The type\n    argument A to eq is declared as implicit, so we need to turn\n    off implicit arguments to see the full type of eq.)\n\n```", "```\nExample and_example : 3 + 4 = 7 \u2227 2 * 2 = 4.\n\n```", "```\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0split.\n\u00a0\u00a0- (*\u00a03\u00a0+\u00a04\u00a0=\u00a07\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a02\u00a0+\u00a02\u00a0=\u00a04\u00a0*) reflexivity.\nQed.\n\n```", "```\nLemma and_intro : \u2200A B : Prop, A \u2192 B \u2192 A \u2227 B.\nProof.\n\u00a0\u00a0intros A B HA HB. split.\n\u00a0\u00a0- apply HA.\n\u00a0\u00a0- apply HB.\nQed.\n\n```", "```\nExample and_example' : 3 + 4 = 7 \u2227 2 * 2 = 4.\nProof.\n\u00a0\u00a0apply and_intro.\n\u00a0\u00a0- (*\u00a03\u00a0+\u00a04\u00a0=\u00a07\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a02\u00a0+\u00a02\u00a0=\u00a04\u00a0*) reflexivity.\nQed.\n\n```", "```\nExample and_exercise :\n\u00a0\u00a0\u2200n m : nat, n + m = 0 \u2192 n = 0 \u2227 m = 0.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma and_example2 :\n\u00a0\u00a0\u2200n m : nat, n = 0 \u2227 m = 0 \u2192 n + m = 0.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros n m H.\n\u00a0\u00a0destruct H as [Hn Hm].\n\u00a0\u00a0rewrite Hn. rewrite Hm.\n\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nLemma and_example2' :\n\u00a0\u00a0\u2200n m : nat, n = 0 \u2227 m = 0 \u2192 n + m = 0.\nProof.\n\u00a0\u00a0intros n m [Hn Hm].\n\u00a0\u00a0rewrite Hn. rewrite Hm.\n\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nLemma and_example2'' :\n\u00a0\u00a0\u2200n m : nat, n = 0 \u2192 m = 0 \u2192 n + m = 0.\nProof.\n\u00a0\u00a0intros n m Hn Hm.\n\u00a0\u00a0rewrite Hn. rewrite Hm.\n\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nLemma and_example3 :\n\u00a0\u00a0\u2200n m : nat, n + m = 0 \u2192 n * m = 0.\nProof.\n\u00a0\u00a0intros n m H.\n\u00a0\u00a0assert (H' : n = 0 \u2227 m = 0).\n\u00a0\u00a0{ apply and_exercise. apply H. }\n\u00a0\u00a0destruct H' as [Hn Hm].\n\u00a0\u00a0rewrite Hn. reflexivity.\nQed.\n\n```", "```\nLemma proj1 : \u2200P Q : Prop,\n\u00a0\u00a0P \u2227 Q \u2192 P.\nProof.\n\u00a0\u00a0intros P Q [HP HQ].\n\u00a0\u00a0apply HP. Qed.\n\n```", "```\nLemma proj2 : \u2200P Q : Prop,\n\u00a0\u00a0P \u2227 Q \u2192 Q.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem and_commut : \u2200P Q : Prop,\n\u00a0\u00a0P \u2227 Q \u2192 Q \u2227 P.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros P Q [HP HQ].\n\u00a0\u00a0split.\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0left\u00a0*) apply HQ.\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0right\u00a0*) apply HP. Qed.\n\n```", "```\nTheorem and_assoc : \u2200P Q R : Prop,\n\u00a0\u00a0P \u2227 (Q \u2227 R) \u2192 (P \u2227 Q) \u2227 R.\nProof.\n\u00a0\u00a0intros P Q R [HP [HQ HR]].\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nCheck and.\n(*\u00a0===>\u00a0and\u00a0:\u00a0Prop\u00a0->\u00a0Prop\u00a0->\u00a0Prop\u00a0*)\n\n```", "```\nLemma or_example :\n\u00a0\u00a0\u2200n m : nat, n = 0 \u2228 m = 0 \u2192 n * m = 0.\nProof.\n\u00a0\u00a0(*\u00a0This\u00a0pattern\u00a0implicitly\u00a0does\u00a0case\u00a0analysis\u00a0on \u00a0\u00a0\u00a0\u00a0\u00a0n = 0 \u2228 m = 0\u00a0*)\n\u00a0\u00a0intros n m [Hn | Hm].\n\u00a0\u00a0- (*\u00a0Here,\u00a0n = 0\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite Hn. reflexivity.\n\u00a0\u00a0- (*\u00a0Here,\u00a0m = 0\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite Hm. rewrite \u2190 mult_n_O.\n\u00a0\u00a0\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nLemma or_intro : \u2200A B : Prop, A \u2192 A \u2228 B.\nProof.\n\u00a0\u00a0intros A B HA.\n\u00a0\u00a0left.\n\u00a0\u00a0apply HA.\nQed.\n\n```", "```\nLemma zero_or_succ :\n\u00a0\u00a0\u2200n : nat, n = 0 \u2228 n = S (pred n).\nProof.\n\u00a0\u00a0intros [|n].\n\u00a0\u00a0- left. reflexivity.\n\u00a0\u00a0- right. reflexivity.\nQed.\n\n```", "```\nLemma mult_eq_0 :\n\u00a0\u00a0\u2200n m, n * m = 0 \u2192 n = 0 \u2228 m = 0.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem or_commut : \u2200P Q : Prop,\n\u00a0\u00a0P \u2228 Q  \u2192 Q \u2228 P.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nModule MyNot.\n\nDefinition not (P:Prop) := P \u2192 False.\n\nNotation \"\u00ac x\" := (not x) : type_scope.\n\nCheck not.\n(*\u00a0===>\u00a0Prop\u00a0->\u00a0Prop\u00a0*)\n\nEnd MyNot.\n\n```", "```\nTheorem ex_falso_quodlibet : \u2200(P:Prop),\n\u00a0\u00a0False \u2192 P.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros P contra.\n\u00a0\u00a0destruct contra. Qed.\n\n```", "```\nFact not_implies_our_not : \u2200(P:Prop),\n\u00a0\u00a0\u00ac P \u2192 (\u2200(Q:Prop), P \u2192 Q).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem zero_not_one : ~(0 = 1).\nProof.\n\u00a0\u00a0intros contra. inversion contra.\nQed.\n\n```", "```\nCheck (0 \u2260 1).\n(*\u00a0===>\u00a0Prop\u00a0*)\n\nTheorem zero_not_one' : 0 \u2260 1.\nProof.\n\u00a0\u00a0intros H. inversion H.\nQed.\n\n```", "```\nTheorem not_False :\n\u00a0\u00a0\u00ac False.\nProof.\n\u00a0\u00a0unfold not. intros H. destruct H. Qed.\n\nTheorem contradiction_implies_anything : \u2200P Q : Prop,\n\u00a0\u00a0(P \u2227 \u00acP) \u2192 Q.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros P Q [HP HNA]. unfold not in HNA.\n\u00a0\u00a0apply HNA in HP. destruct HP. Qed.\n\nTheorem double_neg : \u2200P : Prop,\n\u00a0\u00a0P \u2192 ~~P.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros P H. unfold not. intros G. apply G. apply H. Qed.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nTheorem contrapositive : \u2200(P Q : Prop),\n\u00a0\u00a0(P \u2192 Q) \u2192 (\u00acQ \u2192 \u00acP).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem not_both_true_and_false : \u2200P : Prop,\n\u00a0\u00a0\u00ac (P \u2227 \u00acP).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nTheorem not_true_is_false : \u2200b : bool,\n\u00a0\u00a0b \u2260 true \u2192 b = false.\nProof.\n\u00a0\u00a0intros [] H.\n\u00a0\u00a0- (*\u00a0b\u00a0=\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0unfold not in H.\n\u00a0\u00a0\u00a0\u00a0apply ex_falso_quodlibet.\n\u00a0\u00a0\u00a0\u00a0apply H. reflexivity.\n\u00a0\u00a0- (*\u00a0b\u00a0=\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nTheorem not_true_is_false' : \u2200b : bool,\n\u00a0\u00a0b \u2260 true \u2192 b = false.\nProof.\n\u00a0\u00a0intros [] H.\n\u00a0\u00a0- (*\u00a0b\u00a0=\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0unfold not in H.\n\u00a0\u00a0\u00a0\u00a0exfalso. (*\u00a0<===\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply H. reflexivity.\n\u00a0\u00a0- (*\u00a0b\u00a0=\u00a0true\u00a0*) reflexivity.\nQed.\n\n```", "```\nLemma True_is_true : True.\nProof. apply I. Qed.\n\n```", "```\nModule MyIff.\n\nDefinition iff (P Q : Prop) := (P \u2192 Q) \u2227 (Q \u2192 P).\n\nNotation \"P \u2194 Q\" := (iff P Q)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 95, no associativity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: type_scope.\n\nEnd MyIff.\n\nTheorem iff_sym : \u2200P Q : Prop,\n\u00a0\u00a0(P \u2194 Q) \u2192 (Q \u2194 P).\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros P Q [HAB HBA].\n\u00a0\u00a0split.\n\u00a0\u00a0- (*\u00a0->\u00a0*) apply HBA.\n\u00a0\u00a0- (*\u00a0<-\u00a0*) apply HAB. Qed.\n\nLemma not_true_iff_false : \u2200b,\n\u00a0\u00a0b \u2260 true \u2194 b = false.\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros b. split.\n\u00a0\u00a0- (*\u00a0->\u00a0*) apply not_true_is_false.\n\u00a0\u00a0- (*\u00a0<-\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros H. rewrite H. intros H'. inversion H'.\nQed.\n\n```", "```\nTheorem iff_refl : \u2200P : Prop,\n\u00a0\u00a0P \u2194 P.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nTheorem iff_trans : \u2200P Q R : Prop,\n\u00a0\u00a0(P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem or_distributes_over_and : \u2200P Q R : Prop,\n\u00a0\u00a0P \u2228 (Q \u2227 R) \u2194 (P \u2228 Q) \u2227 (P \u2228 R).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nRequire Import Coq.Setoids.Setoid.\n\n```", "```\nLemma mult_0 : \u2200n m, n * m = 0 \u2194 n = 0 \u2228 m = 0.\nProof.\n\u00a0\u00a0split.\n\u00a0\u00a0- apply mult_eq_0.\n\u00a0\u00a0- apply or_example.\nQed.\n\nLemma or_assoc :\n\u00a0\u00a0\u2200P Q R : Prop, P \u2228 (Q \u2228 R) \u2194 (P \u2228 Q) \u2228 R.\nProof.\n\u00a0\u00a0intros P Q R. split.\n\u00a0\u00a0- intros [H | [H | H]].\n\u00a0\u00a0\u00a0\u00a0+ left. left. apply H.\n\u00a0\u00a0\u00a0\u00a0+ left. right. apply H.\n\u00a0\u00a0\u00a0\u00a0+ right. apply H.\n\u00a0\u00a0- intros [[H | H] | H].\n\u00a0\u00a0\u00a0\u00a0+ left. apply H.\n\u00a0\u00a0\u00a0\u00a0+ right. left. apply H.\n\u00a0\u00a0\u00a0\u00a0+ right. right. apply H.\nQed.\n\n```", "```\nLemma mult_0_3 :\n\u00a0\u00a0\u2200n m p, n * m * p = 0 \u2194 n = 0 \u2228 m = 0 \u2228 p = 0.\nProof.\n\u00a0\u00a0intros n m p.\n\u00a0\u00a0rewrite mult_0. rewrite mult_0. rewrite or_assoc.\n\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nLemma apply_iff_example :\n\u00a0\u00a0\u2200n m : nat, n * m = 0 \u2192 n = 0 \u2228 m = 0.\nProof.\n\u00a0\u00a0intros n m H. apply mult_0. apply H.\nQed.\n\n```", "```\nLemma four_is_even : \u2203n : nat, 4 = n + n.\nProof.\n\u00a0\u00a0\u22032\\. reflexivity.\nQed.\n\n```", "```\nTheorem exists_example_2 : \u2200n,\n\u00a0\u00a0(\u2203m, n = 4 + m) \u2192\n\u00a0\u00a0(\u2203o, n = 2 + o).\nProof.\n\u00a0\u00a0(*\u00a0WORKED\u00a0IN\u00a0CLASS\u00a0*)\n\u00a0\u00a0intros n [m Hm]. (*\u00a0note\u00a0implicit\u00a0destruct\u00a0here\u00a0*)\n\u00a0\u00a0\u2203(2 + m).\n\u00a0\u00a0apply Hm. Qed.\n\n```", "```\nTheorem dist_not_exists : \u2200(X:Type) (P : X \u2192 Prop),\n\u00a0\u00a0(\u2200x, P x) \u2192 \u00ac (\u2203x, \u00ac P x).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem dist_exists_or : \u2200(X:Type) (P Q : X \u2192 Prop),\n\u00a0\u00a0(\u2203x, P x \u2228 Q x) \u2194 (\u2203x, P x) \u2228 (\u2203x, Q x).\nProof.\n\u00a0\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Programming with Propositions\n\n    The logical connectives that we have seen provide a rich\n    vocabulary for defining complex propositions from simpler ones.\n    To illustrate, let's look at how to express the claim that an\n    element x occurs in a list l.  Notice that this property has a\n    simple recursive structure: \n\n*   If l is the empty list, then x cannot occur on it, so the property \"x appears in l\" is simply false. \n\n    *   Otherwise, l has the form x' :: l'. In this case, x occurs in l if either it is equal to x' or it occurs in l'. \n\n     We can translate this directly into a straightforward recursive function from taking an element and a list and returning a proposition:\n\n```", "```\n\n    When In is applied to a concrete list, it expands into a\n    concrete sequence of nested disjunctions.\n\n```", "```\n\n    (Notice the use of the empty pattern to discharge the last case\n    *en passant*.) \n\n    We can also prove more generic, higher-level lemmas about In.\n\n    Note, in the next, how In starts out applied to a variable and\n    only gets expanded when we do case analysis on this variable:\n\n```", "```\n\n    This way of defining propositions recursively, though convenient\n    in some cases, also has some drawbacks.  In particular, it is\n    subject to Coq's usual restrictions regarding the definition of\n    recursive functions, e.g., the requirement that they be \"obviously\n    terminating.\"  In the next chapter, we will see how to define\n    propositions *inductively*, a different technique with its own set\n    of strengths and limitations. \n\n#### Exercise: 2 stars (In_map_iff)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars (in_app_iff)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars (All)\n\n    Recall that functions returning propositions can be seen as\n    *properties* of their arguments. For instance, if P has type\n    nat \u2192 Prop, then P n states that property P holds of n.\n\n    Drawing inspiration from In, write a recursive function All\n    stating that some property P holds of all elements of a list\n    l. To make sure your definition is correct, prove the All_In\n    lemma below.  (Of course, your definition should *not* just\n    restate the left-hand side of All_In.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars (combine_odd_even)\n\n    Complete the definition of the combine_odd_even function below.\n    It takes as arguments two properties of numbers, Podd and\n    Peven, and it should return a property P such that P n is\n    equivalent to Podd n when n is odd and equivalent to Peven n\n    otherwise.\n\n```", "```\n\n    To test your definition, prove the following facts:\n\n```", "```\n\n    \u2610\n\n```", "```\nCheck plus_comm.\n(*\u00a0===>\u00a0forall\u00a0n\u00a0m\u00a0:\u00a0nat,\u00a0n\u00a0+\u00a0m\u00a0=\u00a0m\u00a0+\u00a0n\u00a0*)\n\n```", "```\nLemma plus_comm3 :\n\u00a0\u00a0\u2200n m p, n + (m + p) = (p + m) + n.\n\n```", "```\nProof.\n\u00a0\u00a0intros n m p.\n\u00a0\u00a0rewrite plus_comm.\n\u00a0\u00a0rewrite plus_comm.\n\u00a0\u00a0(*\u00a0We\u00a0are\u00a0back\u00a0where\u00a0we\u00a0started...\u00a0*)\nAbort.\n\n```", "```\nLemma plus_comm3_take2 :\n\u00a0\u00a0\u2200n m p, n + (m + p) = (p + m) + n.\nProof.\n\u00a0\u00a0intros n m p.\n\u00a0\u00a0rewrite plus_comm.\n\u00a0\u00a0assert (H : m + p = p + m).\n\u00a0\u00a0{ rewrite plus_comm. reflexivity. }\n\u00a0\u00a0rewrite H.\n\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nLemma plus_comm3_take3 :\n\u00a0\u00a0\u2200n m p, n + (m + p) = (p + m) + n.\nProof.\n\u00a0\u00a0intros n m p.\n\u00a0\u00a0rewrite plus_comm.\n\u00a0\u00a0rewrite (plus_comm m).\n\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nExample lemma_application_ex :\n\u00a0\u00a0\u2200{n : nat} {ns : list nat},\n\u00a0\u00a0\u00a0\u00a0In n (map (fun m \u21d2 m * 0) ns) \u2192\n\u00a0\u00a0\u00a0\u00a0n = 0.\nProof.\n\u00a0\u00a0intros n ns H.\n\u00a0\u00a0destruct (proj1 _ _ (In_map_iff _ _ _ _ _) H)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0as [m [Hm _]].\n\u00a0\u00a0rewrite mult_0_r in Hm. rewrite \u2190 Hm. reflexivity.\nQed.\n\n```", "```\n\n# Coq vs. Set Theory\n\n    Coq's logical core, the *Calculus of Inductive Constructions*,\n    differs in some important ways from other formal systems that are\n    used by mathematicians for writing down precise and rigorous\n    proofs.  For example, in the most popular foundation for\n    mainstream paper-and-pencil mathematics, Zermelo-Fraenkel Set\n    Theory (ZFC), a mathematical object can potentially be a member of\n    many different sets; a term in Coq's logic, on the other hand, is\n    a member of at most one type.  This difference often leads to\n    slightly different ways of capturing informal mathematical\n    concepts, but these are, by and large, quite natural and easy to\n    work with.  For example, instead of saying that a natural number\n    n belongs to the set of even numbers, we would say in Coq that\n    ev n holds, where ev : nat \u2192 Prop is a property describing\n    even numbers.\n\n    However, there are some cases where translating standard\n    mathematical reasoning into Coq can be either cumbersome or\n    sometimes even impossible, unless we enrich the core logic with\n    additional axioms.  We conclude this chapter with a brief\n    discussion of some of the most significant differences between the\n    two worlds. \n\n## Functional Extensionality\n\n    The equality assertions that we have seen so far mostly have\n    concerned elements of inductive types (nat, bool, etc.).  But\n    since Coq's equality operator is polymorphic, these are not the\n    only possibilities \u2014 in particular, we can write propositions\n    claiming that two *functions* are equal to each other:\n\n```", "```\n\n    In common mathematical practice, two functions f and g are\n    considered equal if they produce the same outputs:\n\n```", "```\nExample function_equality_ex[2] :\n\u00a0\u00a0(fun x \u21d2 plus x 1) = (fun x \u21d2 plus 1 x).\nProof.\n\u00a0\u00a0\u00a0(*\u00a0Stuck\u00a0*)\nAbort.\n\n```", "```\nAxiom functional_extensionality : \u2200{X Y: Type}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{f g : X \u2192 Y},\n\u00a0\u00a0(\u2200(x:X), f x = g x) \u2192 f = g.\n\n```", "```\nExample function_equality_ex[2] :\n\u00a0\u00a0(fun x \u21d2 plus x 1) = (fun x \u21d2 plus 1 x).\nProof.\n\u00a0\u00a0apply functional_extensionality. intros x.\n\u00a0\u00a0apply plus_comm.\nQed.\n\n```", "```\nPrint Assumptions function_equality_ex[2].\n(*\u00a0===> \u00a0\u00a0\u00a0\u00a0\u00a0Axioms: \u00a0\u00a0\u00a0\u00a0\u00a0functional_extensionality\u00a0: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forall\u00a0(X\u00a0Y\u00a0:\u00a0Type)\u00a0(f\u00a0g\u00a0:\u00a0X\u00a0->\u00a0Y), \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(forall\u00a0x\u00a0:\u00a0X,\u00a0f\u00a0x\u00a0=\u00a0g\u00a0x)\u00a0->\u00a0f\u00a0=\u00a0g\u00a0*)\n\n```", "```\nFixpoint rev_append {X} (l[1] l[2] : list X) : list X :=\n\u00a0\u00a0match l[1] with\n\u00a0\u00a0| [] \u21d2 l[2]\n\u00a0\u00a0| x :: l[1]' \u21d2 rev_append l[1]' (x :: l[2])\n\u00a0\u00a0end.\n\nDefinition tr_rev {X} (l : list X) : list X :=\n\u00a0\u00a0rev_append l [].\n\n```", "```\nLemma tr_rev_correct : \u2200X, @tr_rev X = @rev X.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem evenb_double : \u2200k, evenb (double k) = true.\nProof.\n\u00a0\u00a0intros k. induction k as [|k' IHk'].\n\u00a0\u00a0- reflexivity.\n\u00a0\u00a0- simpl. apply IHk'.\nQed.\n\n```", "```\nTheorem evenb_double_conv : \u2200n,\n\u00a0\u00a0\u2203k, n = if evenb n then double k\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else S (double k).\nProof.\n\u00a0\u00a0(*\u00a0Hint:\u00a0Use\u00a0the\u00a0evenb_S\u00a0lemma\u00a0from\u00a0Induction.v.\u00a0*)\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem even_bool_prop : \u2200n,\n\u00a0\u00a0evenb n = true \u2194 \u2203k, n = double k.\nProof.\n\u00a0\u00a0intros n. split.\n\u00a0\u00a0- intros H. destruct (evenb_double_conv n) as [k Hk].\n\u00a0\u00a0\u00a0\u00a0rewrite Hk. rewrite H. \u2203k. reflexivity.\n\u00a0\u00a0- intros [k Hk]. rewrite Hk. apply evenb_double.\nQed.\n\n```", "```\nTheorem beq_nat_true_iff : \u2200n[1] n[2] : nat,\n\u00a0\u00a0beq_nat n[1] n[2] = true \u2194 n[1] = n[2].\nProof.\n\u00a0\u00a0intros n[1] n[2]. split.\n\u00a0\u00a0- apply beq_nat_true.\n\u00a0\u00a0- intros H. rewrite H. rewrite \u2190 beq_nat_refl. reflexivity.\nQed.\n\n```", "```\nFail Definition is_even_prime n :=\n\u00a0\u00a0if n = 2 then true\n\u00a0\u00a0else false.\n\n```", "```\nExample even_1000 : \u2203k, 1000 = double k.\n\n```", "```\nProof. \u2203500\\. reflexivity. Qed.\n\n```", "```\nExample even_1000' : evenb 1000 = true.\nProof. reflexivity. Qed.\n\n```", "```\nExample even_1000'' : \u2203k, 1000 = double k.\nProof. apply even_bool_prop. reflexivity. Qed.\n\n```", "```\nLemma andb_true_iff : \u2200b[1] b[2]:bool,\n\u00a0\u00a0b[1] && b[2] = true \u2194 b[1] = true \u2227 b[2] = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nLemma orb_true_iff : \u2200b[1] b[2],\n\u00a0\u00a0b[1] || b[2] = true \u2194 b[1] = true \u2228 b[2] = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem beq_nat_false_iff : \u2200x y : nat,\n\u00a0\u00a0beq_nat x y = false \u2194 x \u2260 y.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nFixpoint beq_list {A : Type} (beq : A \u2192 A \u2192 bool)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(l[1] l[2] : list A) : bool\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nLemma beq_list_true_iff :\n\u00a0\u00a0\u2200A (beq : A \u2192 A \u2192 bool),\n\u00a0\u00a0\u00a0\u00a0(\u2200a[1] a[2], beq a[1] a[2] = true \u2194 a[1] = a[2]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u2200l[1] l[2], beq_list beq l[1] l[2] = true \u2194 l[1] = l[2].\nProof.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nFixpoint forallb {X : Type} (test : X \u2192 bool) (l : list X) : bool :=\n\u00a0\u00a0match l with\n\u00a0\u00a0| [] \u21d2 true\n\u00a0\u00a0| x :: l' \u21d2 andb (test x) (forallb test l')\n\u00a0\u00a0end.\n\n```", "```\nTheorem forallb_true_iff : \u2200X test (l : list X),\n\u00a0\u00a0\u00a0forallb test l = true \u2194 All (fun x \u21d2 test x = true) l.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nDefinition excluded_middle := \u2200P : Prop,\n\u00a0\u00a0P \u2228 \u00ac P.\n\n```", "```\nTheorem restricted_excluded_middle : \u2200P b,\n\u00a0\u00a0(P \u2194 b = true) \u2192 P \u2228 \u00ac P.\nProof.\n\u00a0\u00a0intros P [] H.\n\u00a0\u00a0- left. rewrite H. reflexivity.\n\u00a0\u00a0- right. rewrite H. intros contra. inversion contra.\nQed.\n\n```", "```\nTheorem restricted_excluded_middle_eq : \u2200(n m : nat),\n\u00a0\u00a0n = m \u2228 n \u2260 m.\nProof.\n\u00a0\u00a0intros n m.\n\u00a0\u00a0apply (restricted_excluded_middle (n = m) (beq_nat n m)).\n\u00a0\u00a0symmetry.\n\u00a0\u00a0apply beq_nat_true_iff.\nQed.\n\n```", "```\nTheorem excluded_middle_irrefutable:  \u2200(P:Prop),\n\u00a0\u00a0\u00ac \u00ac (P \u2228 \u00ac P).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00ac\u00a0(\u2203x,\u00a0\u00ac\u00a0P\u00a0x)\n\u00a0\u00a0\u00a0\u00a0\u2200x,\u00a0P\u00a0x\n\n    The dist_not_exists theorem above proves one side of this\n    equivalence. Interestingly, the other direction cannot be proved\n    in constructive logic. Your job is to show that it is implied by\n    the excluded middle.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 5 stars, optional (classical_axioms)\n\n    For those who like a challenge, here is an exercise taken from the\n    Coq'Art book by Bertot and Casteran (p. 123).  Each of the\n    following four statements, together with excluded_middle, can be\n    considered as characterizing classical logic.  We can't prove any\n    of them in Coq, but we can consistently add any one of them as an\n    axiom if we wish to work in classical logic.\n\n    Prove that all five propositions (these four plus\n    excluded_middle) are equivalent.\n\n```", "```\n\n    \u2610 \n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]