["```\n\n    In this chapter, we combine two significant extensions of the pure\n    STLC \u2014 records (from chapter [Records](Records.html)) and subtyping (from\n    chapter [Sub](Sub.html)) \u2014 and explore their interactions.  Most of the\n    concepts have already been discussed in those chapters, so the\n    presentation here is somewhat terse.  We just comment where things\n    are nonstandard.\n\n```", "```\n\n# Core Definitions\n\n```", "```\nInductive ty : Type :=\n\u00a0\u00a0(*\u00a0proper\u00a0types\u00a0*)\n\u00a0\u00a0| TTop   : ty\n\u00a0\u00a0| TBase  : id \u2192 ty\n\u00a0\u00a0| TArrow : ty \u2192 ty \u2192 ty\n\u00a0\u00a0(*\u00a0record\u00a0types\u00a0*)\n\u00a0\u00a0| TRNil : ty\n\u00a0\u00a0| TRCons : id \u2192 ty \u2192 ty \u2192 ty.\n\nInductive tm : Type :=\n\u00a0\u00a0(*\u00a0proper\u00a0terms\u00a0*)\n\u00a0\u00a0| tvar : id \u2192 tm\n\u00a0\u00a0| tapp : tm \u2192 tm \u2192 tm\n\u00a0\u00a0| tabs : id \u2192 ty \u2192 tm \u2192 tm\n\u00a0\u00a0| tproj : tm \u2192 id \u2192 tm\n\u00a0\u00a0(*\u00a0record\u00a0terms\u00a0*)\n\u00a0\u00a0| trnil :  tm\n\u00a0\u00a0| trcons : id \u2192 tm \u2192 tm \u2192 tm.\n\n```", "```\nInductive record_ty : ty \u2192 Prop :=\n\u00a0\u00a0| RTnil :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_ty TRNil\n\u00a0\u00a0| RTcons : \u2200i T[1] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_ty (TRCons i T[1] T[2]).\n\nInductive record_tm : tm \u2192 Prop :=\n\u00a0\u00a0| rtnil :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_tm trnil\n\u00a0\u00a0| rtcons : \u2200i t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_tm (trcons i t[1] t[2]).\n\nInductive well_formed_ty : ty \u2192 Prop :=\n\u00a0\u00a0| wfTTop :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty TTop\n\u00a0\u00a0| wfTBase : \u2200i,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty (TBase i)\n\u00a0\u00a0| wfTArrow : \u2200T[1] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty (TArrow T[1] T[2])\n\u00a0\u00a0| wfTRNil :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty TRNil\n\u00a0\u00a0| wfTRCons : \u2200i T[1] T[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_ty T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty (TRCons i T[1] T[2]).\n\nHint Constructors record_ty record_tm well_formed_ty.\n\n```", "```\nFixpoint subst (x:id) (s:tm) (t:tm) : tm :=\n\u00a0\u00a0match t with\n\u00a0\u00a0| tvar y \u21d2 if beq_id x y then s else t\n\u00a0\u00a0| tabs y T t[1] \u21d2  tabs y T (if beq_id x y then t[1]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0else (subst x s t[1]))\n\u00a0\u00a0| tapp t[1] t[2] \u21d2 tapp (subst x s t[1]) (subst x s t[2])\n\u00a0\u00a0| tproj t[1] i \u21d2 tproj (subst x s t[1]) i\n\u00a0\u00a0| trnil \u21d2 trnil\n\u00a0\u00a0| trcons i t[1] tr[2] \u21d2 trcons i (subst x s t[1]) (subst x s tr[2])\n\u00a0\u00a0end.\n\nNotation \"'[' x ':=' s ']' t\" := (subst x s t) (at level 20).\n\n```", "```\nInductive value : tm \u2192 Prop :=\n\u00a0\u00a0| v_abs : \u2200x T t,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (tabs x T t)\n\u00a0\u00a0| v_rnil : value trnil\n\u00a0\u00a0| v_rcons : \u2200i v vr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value vr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value (trcons i v vr).\n\nHint Constructors value.\n\nFixpoint Tlookup (i:id) (Tr:ty) : option ty :=\n\u00a0\u00a0match Tr with\n\u00a0\u00a0| TRCons i' T Tr' \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id i i' then Some T else Tlookup i Tr'\n\u00a0\u00a0| _ \u21d2 None\n\u00a0\u00a0end.\n\nFixpoint tlookup (i:id) (tr:tm) : option tm :=\n\u00a0\u00a0match tr with\n\u00a0\u00a0| trcons i' t tr' \u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if beq_id i i' then Some t else tlookup i tr'\n\u00a0\u00a0| _ \u21d2 None\n\u00a0\u00a0end.\n\nReserved Notation \"t1 '\u21d2' t2\" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_AppAbs : \u2200x T t[12] v[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tabs x T t[12]) v[2]) \u21d2 [x:=v[2]]t[12]\n\u00a0\u00a0| ST_App1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp t[1] t[2]) \u21d2 (tapp t[1]' t[2])\n\u00a0\u00a0| ST_App2 : \u2200v[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp v[1] t[2]) \u21d2 (tapp v[1]  t[2]')\n\u00a0\u00a0| ST_Proj1 : \u2200tr tr' i,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tr \u21d2 tr' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tproj tr i) \u21d2 (tproj tr' i)\n\u00a0\u00a0| ST_ProjRcd : \u2200tr i vi,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tlookup i tr = Some vi    \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tproj tr i) \u21d2 vi\n\u00a0\u00a0| ST_Rcd_Head : \u2200i t[1] t[1]' tr[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons i t[1] tr[2]) \u21d2 (trcons i t[1]' tr[2])\n\u00a0\u00a0| ST_Rcd_Tail : \u2200i v[1] tr[2] tr[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tr[2] \u21d2 tr[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons i v[1] tr[2]) \u21d2 (trcons i v[1] tr[2]')\n\nwhere \"t1 '\u21d2' t2\" := (step t[1] t[2]).\n\nHint Constructors step.\n\n```", "```\n\n## Definition\n\n    The definition of subtyping is essentially just what we sketched\n    in the discussion of record subtyping in chapter [Sub](Sub.html), but we\n    need to add well-formedness side conditions to some of the rules.\n    Also, we replace the \"n-ary\" width, depth, and permutation\n    subtyping rules by binary rules that deal with just the first\n    field.\n\n```", "```\n\n## Examples\n\n```", "```\n\n    The following facts are mostly easy to prove in Coq.  To get full\n    benefit, make sure you also understand how to prove them on\n    paper! \n\n#### Exercise: 2 stars (subtyping_example_1)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 1 star (subtyping_example_2)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 1 star (subtyping_example_3)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars (subtyping_example_4)\n\n```", "```\n\n    \u2610\n\n```", "```\n\n## Properties of Subtyping\n\n### Well-Formedness\n\n    To get started proving things about subtyping, we need a couple of\n    technical lemmas that intuitively (1) allow us to extract the\n    well-formedness assumptions embedded in subtyping derivations\n    and (2) record the fact that fields of well-formed record types\n    are themselves well-formed types.\n\n```", "```\n\n### Field Lookup\n\n    The record matching lemmas get a little more complicated in the\n    presence of subtyping, for two reasons.  First, record types no\n    longer necessarily describe the exact structure of the\n    corresponding terms.  And second, reasoning by induction on typing\n    derivations becomes harder in general, because typing is no longer\n    syntax directed.\n\n```", "```\n\n#### Exercise: 3 stars (rcd_types_match_informal)\n\n    Write a careful informal proof of the rcd_types_match\n    lemma.\n\n```", "```\n\n    \u2610 \n\n### Inversion Lemmas\n\n#### Exercise: 3 stars, optional (sub_inversion_arrow)\n\n```", "```\nDefinition context := partial_map ty.\n\nReserved Notation \"Gamma '\u22a2' t '\u2208' T\" (at level 40).\n\nInductive has_type : context \u2192 tm \u2192 ty \u2192 Prop :=\n\u00a0\u00a0| T_Var : \u2200\u0393 x T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 x = Some T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tvar x \u2208 T\n\u00a0\u00a0| T_Abs : \u2200\u0393 x T[11] T[12] t[12],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0well_formed_ty T[11] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0update \u0393 x T[11] \u22a2 t[12] \u2208 T[12] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tabs x T[11] t[12] \u2208 TArrow T[11] T[12]\n\u00a0\u00a0| T_App : \u2200T[1] T[2] \u0393 t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[1] \u2208 TArrow T[1] T[2] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t[2] \u2208 T[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tapp t[1] t[2] \u2208 T[2]\n\u00a0\u00a0| T_Proj : \u2200\u0393 i t T Ti,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Tlookup i T = Some Ti \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tproj t i \u2208 Ti\n\u00a0\u00a0(*\u00a0Subsumption\u00a0*)\n\u00a0\u00a0| T_Sub : \u2200\u0393 t S T,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t \u2208 S \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0subtype S T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t \u2208 T\n\u00a0\u00a0(*\u00a0Rules\u00a0for\u00a0record\u00a0terms\u00a0*)\n\u00a0\u00a0| T_RNil : \u2200\u0393,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 trnil \u2208 TRNil\n\u00a0\u00a0| T_RCons : \u2200\u0393 i t T tr Tr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 t \u2208 T \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 tr \u2208 Tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_ty Tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0record_tm tr \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u0393 \u22a2 trcons i t tr \u2208 TRCons i T Tr\n\nwhere \"Gamma '\u22a2' t '\u2208' T\" := (has_type \u0393 t T).\n\nHint Constructors has_type.\n\n```", "```\nModule Examples2.\nImport Examples.\n\n```", "```\nDefinition trcd_kj :=\n\u00a0\u00a0(trcons k (tabs z A (tvar z))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons j (tabs z B (tvar z))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0trnil)).\n\nExample typing_example_0 :\n\u00a0\u00a0has_type empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons k (tabs z A (tvar z))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(trcons j (tabs z B (tvar z))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0trnil))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TRcd_kj.\n(*\u00a0empty\u00a0|-\u00a0{k=(\u03bbz:A.z),\u00a0j=(\u03bbz:B.z)}\u00a0:\u00a0{k:A->A,j:B->B}\u00a0*)\n\n    Proof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n    \u2610\n\n#### Exercise: 2 stars (typing_example_1)\n\n```", "```\nExample typing_example_2 :\n\u00a0\u00a0has_type empty\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tapp (tabs z (TArrow (TArrow C C) TRcd_j)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tproj (tapp (tvar z)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tabs x C (tvar x)))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0j))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tabs z (TArrow C C) trcd_kj))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(TArrow B B).\n(*\u00a0empty\u00a0|-\u00a0(\u03bbz:(C->C)->{j:B->B}.\u00a0(z\u00a0(\u03bbx:C.x)).j) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(\u03bbz:C->C.\u00a0{k=(\u03bbz:A.z),\u00a0j=(\u03bbz:B.z)}) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0:\u00a0B->B\u00a0*)\n\n    Proof with eauto.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n    \u2610\n\nEnd [Examples2](RecordSub.html#Examples2).\n\n## Properties of Typing\n\n### Well-Formedness\n\n```", "```\n\n### Field Lookup\n\n```", "```\n\n### Progress\n\n#### Exercise: 3 stars (canonical_forms_of_arrow_types)\n\n```", "```\n\n### Inversion Lemmas\n\n```", "```\n\n### Context Invariance\n\n```", "```\n\n### Preservation\n\n```", "```\n\n    *Theorem*: If t, t' are terms and T is a type such that\n     empty \u22a2 t : T and t \u21d2 t', then empty \u22a2 t' : T.\n\n    *Proof*: Let t and T be given such that empty \u22a2 t : T.  We go\n     by induction on the structure of this typing derivation, leaving\n     t' general.  Cases T_Abs and T_RNil are vacuous because\n     abstractions and {} don't step.  Case T_Var is vacuous as well,\n     since the context is empty.\n\n*   If the final step of the derivation is by T_App, then there are terms t[1] t[2] and types T[1] T[2] such that t = t[1] t[2], T = T[2], empty \u22a2 t[1] : T[1] \u2192 T[2] and empty \u22a2 t[2] : T[1]. \n\n     By inspection of the definition of the step relation, there are three ways t[1] t[2] can step. Cases ST_App1 and ST_App2 follow immediately by the induction hypotheses for the typing subderivations and a use of T_App. \n\n     Suppose instead t[1] t[2] steps by ST_AppAbs. Then t[1] = \\x:S.t12 for some type S and term t[12], and t' = [x:=t[2]]t[12]. \n\n     By Lemma abs_arrow, we have T[1] <: S and x:S[1] \u22a2 s[2] : T[2]. It then follows by lemma substitution_preserves_typing that empty \u22a2 [x:=t[2]] t[12] : T[2] as desired. \n\n*   If the final step of the derivation is by T_Proj, then there is a term tr, type Tr and label i such that t = tr.i, empty \u22a2 tr : Tr, and Tlookup i Tr = Some T. \n\n     The IH for the typing derivation gives us that, for any term tr', if tr \u21d2 tr' then empty \u22a2 tr' Tr. Inspection of the definition of the step relation reveals that there are two ways a projection can step. Case ST_Proj1 follows immediately by the IH. \n\n     Instead suppose tr.i steps by ST_ProjRcd. Then tr is a value and there is some term vi such that tlookup i tr = Some vi and t' = vi. But by lemma lookup_field_in_value, empty \u22a2 vi : Ti as desired. \n\n*   If the final step of the derivation is by T_Sub, then there is a type S such that S <: T and empty \u22a2 t : S. The result is immediate by the induction hypothesis for the typing subderivation and an application of T_Sub. \n\n*   If the final step of the derivation is by T_RCons, then there exist some terms t[1] tr, types T[1] Tr and a label t such that t = {i=t[1], tr}, T = {i:T[1], Tr}, record_tm tr, record_tm Tr, empty \u22a2 t[1] : T[1] and empty \u22a2 tr : Tr. \n\n     By the definition of the step relation, t must have stepped by ST_Rcd_Head or ST_Rcd_Tail. In the first case, the result follows by the IH for t[1]'s typing derivation and T_RCons. In the second case, the result follows by the IH for tr's typing derivation, T_RCons, and a use of the step_preserves_record_tm lemma.\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]