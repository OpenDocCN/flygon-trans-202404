["```\n\n```", "```\n\n    The evaluators we have seen so far (for aexps, bexps,\n    commands, ...) have been formulated in a \"big-step\" style: they\n    specify how a given expression can be evaluated to its final\n    value (or a command plus a store to a final store) \"all in one big\n    step.\"\n\n    This style is simple and natural for many purposes \u2014 indeed,\n    Gilles Kahn, who popularized it, called it *natural semantics*.\n    But there are some things it does not do well.  In particular, it\n    does not give us a natural way of talking about *concurrent*\n    programming languages, where the semantics of a program \u2014 i.e.,\n    the essence of how it behaves \u2014 is not just which input states\n    get mapped to which output states, but also includes the\n    intermediate states that it passes through along the way, since\n    these states can also be observed by concurrently executing code.\n\n    Another shortcoming of the big-step style is more technical, but\n    critical in many situations.  Suppose we want to define a variant\n    of Imp where variables could hold *either* numbers *or* lists of\n    numbers.  In the syntax of this extended language, it will be\n    possible to write strange expressions like 2 + nil, and our\n    semantics for arithmetic expressions will then need to say\n    something about how such expressions behave.  One possibility is\n    to maintain the convention that every arithmetic expressions\n    evaluates to some number by choosing some way of viewing a list as\n    a number \u2014 e.g., by specifying that a list should be interpreted\n    as 0 when it occurs in a context expecting a number.  But this\n    is really a bit of a hack.\n\n    A much more natural approach is simply to say that the behavior of\n    an expression like 2+nil is *undefined* \u2014 i.e., it doesn't\n    evaluate to any result at all.  And we can easily do this: we just\n    have to formulate aeval and beval as Inductive propositions\n    rather than Fixpoints, so that we can make them partial functions\n    instead of total ones.\n\n    Now, however, we encounter a serious deficiency.  In this\n    language, a command might fail to map a given starting state to\n    any ending state for *two quite different reasons*: either because\n    the execution gets into an infinite loop or because, at some\n    point, the program tries to do an operation that makes no sense,\n    such as adding a number to a list, so that none of the evaluation\n    rules can be applied.\n\n    These two outcomes \u2014 nontermination vs. getting stuck in an\n    erroneous configuration \u2014 are quite different.  In particular, we\n    want to allow the first (permitting the possibility of infinite\n    loops is the price we pay for the convenience of programming with\n    general looping constructs like while) but prevent the\n    second (which is just wrong), for example by adding some form of\n    *typechecking* to the language.  Indeed, this will be a major\n    topic for the rest of the course.  As a first step, we need a way\n    of presenting the semantics that allows us to distinguish\n    nontermination from erroneous \"stuck states.\"\n\n    So, for lots of reasons, we'd like to have a finer-grained way of\n    defining and reasoning about program behaviors.  This is the topic\n    of the present chapter.  We replace the \"big-step\" eval relation\n    with a \"small-step\" relation that specifies, for a given program,\n    how the \"atomic steps\" of computation are performed.\n\n```", "```\nInductive tm : Type :=\n\u00a0\u00a0| C : nat \u2192 tm         (*\u00a0Constant\u00a0*)\n\u00a0\u00a0| P : tm \u2192 tm \u2192 tm. (*\u00a0Plus\u00a0*)\n\n```", "```\nFixpoint evalF (t : tm) : nat :=\n\u00a0\u00a0match t with\n\u00a0\u00a0| C n \u21d2 n\n\u00a0\u00a0| P a[1] a[2] \u21d2 evalF a[1] + evalF a[2]\n\u00a0\u00a0end.\n\n```", "```\nReserved Notation \" t '\u21d3' n \" (at level 50, left associativity).\n\nInductive eval : tm \u2192 nat \u2192 Prop :=\n\n    \u00a0\u00a0| E_Const : \u2200n,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[C](Smallstep.html#C) [n](Smallstep.html#n) \u21d3 [n](Smallstep.html#n)\n\u00a0\u00a0| E_Plus : \u2200t[1] t[2] n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[t[1]](Smallstep.html#t<sub>1</sub>) \u21d3 [n[1]](Smallstep.html#n<sub>1</sub>) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[t[2]](Smallstep.html#t<sub>2</sub>) \u21d3 [n[2]](Smallstep.html#n<sub>2</sub>) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[P](Smallstep.html#P) [t[1]](Smallstep.html#t<sub>1</sub>) [t[2]](Smallstep.html#t<sub>2</sub>) \u21d3 ([n[1]](Smallstep.html#n<sub>1</sub>) + [n[2]](Smallstep.html#n<sub>2</sub>))\n\n\u00a0\u00a0where \" t '\u21d3' n \" := ([eval](Smallstep.html#eval) t n).\n\nModule SimpleArith1.\n\n```", "```\nReserved Notation \" t '\u21d2' t' \" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_PlusConstConst : \u2200n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P (C n[1]) (C n[2]) \u21d2 C (n[1] + n[2])\n\u00a0\u00a0| ST_Plus1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P t[1] t[2] \u21d2 P t[1]' t[2]\n\u00a0\u00a0| ST_Plus2 : \u2200n[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P (C n[1]) t[2] \u21d2 P (C n[1]) t[2]'\n\n\u00a0\u00a0where \" t '\u21d2' t' \" := (step t t').\n\n```", "```\nExample test_step_1 :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 0) (C 3))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 2) (C 4))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C (0 + 3))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 2) (C 4)).\n\n    Proof.\n\u00a0\u00a0apply [ST_Plus1](Smallstep.html#SimpleArith1.ST_Plus1). apply [ST_PlusConstConst](Smallstep.html#SimpleArith1.ST_PlusConstConst). Qed.\n\n```", "```\nExample test_step_2 :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C 2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 0) (C 3)))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C 2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C (0 + 3))).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nEnd SimpleArith1.\n\n```", "```\nDefinition relation (X: Type) := X\u2192X\u2192Prop.\n\n```", "```\nDefinition deterministic {X: Type} (R: relation X) :=\n\u00a0\u00a0\u2200x y[1] y[2] : X, R x y[1] \u2192 R x y[2] \u2192 y[1] = y[2].\n\nModule SimpleArith2.\nImport SimpleArith1.\n\nTheorem step_deterministic:\n\u00a0\u00a0deterministic step.\nProof.\n\u00a0\u00a0unfold deterministic. intros x y[1] y[2] Hy[1] Hy[2].\n\u00a0\u00a0generalize dependent y[2].\n\u00a0\u00a0induction Hy[1]; intros y[2] Hy[2].\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0ST_PlusConstConst\u00a0*) inversion Hy[2].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_PlusConstConst\u00a0*) reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_Plus1\u00a0*) inversion H[2].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_Plus2\u00a0*) inversion H[2].\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0ST_Plus1\u00a0*) inversion Hy[2].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_PlusConstConst\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 H[0] in Hy[1]. inversion Hy[1].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_Plus1\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 (IHHy1 t[1]'0).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reflexivity. assumption.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_Plus2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 H in Hy[1]. inversion Hy[1].\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0ST_Plus2\u00a0*) inversion Hy[2].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_PlusConstConst\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 H[1] in Hy[1]. inversion Hy[1].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_Plus1\u00a0*) inversion H[2].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_Plus2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2190 (IHHy1 t[2]'0).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reflexivity. assumption.\nQed.\n\nEnd SimpleArith2.\n\n```", "```\nLtac solve_by_inverts n :=\n\u00a0\u00a0match goal with | H : ?T \u22a2 _ \u21d2 \n\u00a0\u00a0match type of T with Prop \u21d2\n\u00a0\u00a0\u00a0\u00a0solve [ \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H; \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0match n with S (S (?n')) \u21d2 subst; solve_by_inverts (S n') end ]\n\u00a0\u00a0end end.\n\n```", "```\nLtac solve_by_invert :=\n\u00a0\u00a0solve_by_inverts 1.\n\n```", "```\nModule SimpleArith3.\nImport SimpleArith1.\n\nTheorem step_deterministic_alt: deterministic step.\nProof.\n\u00a0\u00a0intros x y[1] y[2] Hy[1] Hy[2].\n\u00a0\u00a0generalize dependent y[2].\n\u00a0\u00a0induction Hy[1]; intros y[2] Hy[2];\n\u00a0\u00a0\u00a0\u00a0inversion Hy[2]; subst; try solve_by_invert.\n\u00a0\u00a0- (*\u00a0ST_PlusConstConst\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a0ST_Plus1\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply IHHy1 in H[2]. rewrite H[2]. reflexivity.\n\u00a0\u00a0- (*\u00a0ST_Plus2\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply IHHy1 in H[2]. rewrite H[2]. reflexivity.\nQed.\n\nEnd SimpleArith3.\n\n```", "```\nInductive value : tm \u2192 Prop :=\n\u00a0\u00a0| v_const : \u2200n, value (C n).\n\n```", "```\nReserved Notation \" t '\u21d2' t' \" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_PlusConstConst : \u2200n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P (C n[1]) (C n[2])\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2 C (n[1] + n[2])\n\u00a0\u00a0| ST_Plus1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P t[1] t[2] \u21d2 P t[1]' t[2]\n\u00a0\u00a0| ST_Plus2 : \u2200v[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192                     (*\u00a0<-----\u00a0n.b.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P v[1] t[2] \u21d2 P v[1] t[2]'\n\n\u00a0\u00a0where \" t '\u21d2' t' \" := (step t t').\n\n```", "```\nTheorem step_deterministic :\n\u00a0\u00a0deterministic step.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Strong Progress and Normal Forms\n\n    The definition of single-step reduction for our toy language\n    is fairly simple, but for a larger language it would be easy to\n    forget one of the rules and accidentally create a situation where\n    some term cannot take a step even though it has not been\n    completely reduced to a value.  The following theorem shows that\n    we did not, in fact, make such a mistake here. \n\n    *Theorem* (*Strong Progress*): If t is a term, then either t\n    is a value or else there exists a term t' such that t \u21d2 t'. \n\n    *Proof*: By induction on t.\n\n*   Suppose t = C n. Then t is a value. \n\n*   Suppose t = P t[1] t[2], where (by the IH) t[1] either is a value or can step to some t[1]', and where t[2] is either a value or can step to some t[2]'. We must show P t[1] t[2] is either a value or steps to some t'. \n\n    *   If t[1] and t[2] are both values, then t can take a step, by ST_PlusConstConst. \n\n    *   If t[1] is a value and t[2] can take a step, then so can t, by ST_Plus2. \n\n    *   If t[1] can take a step, then so can t, by ST_Plus1. \u2610\n\n    Or, formally:\n\n```", "```\n\n    This important property is called *strong progress*, because\n    every term either is a value or can \"make progress\" by stepping to\n    some other term.  (The qualifier \"strong\" distinguishes it from a\n    more refined version that we'll see in later chapters, called\n    just *progress*.) \n\n    The idea of \"making progress\" can be extended to tell us something\n    interesting about values: in this language, values are exactly the\n    terms that *cannot* make progress in this sense.\n\n    To state this observation formally, let's begin by giving a name\n    to terms that cannot make progress.  We'll call them *normal forms*.\n\n```", "```\n\n    Note that this definition specifies what it is to be a normal form\n    for an *arbitrary* relation R over an arbitrary set X, not\n    just for the particular single-step reduction relation over terms\n    that we are interested in at the moment.  We'll re-use the same\n    terminology for talking about other relations later in the\n    course. \n\n    We can use this terminology to generalize the observation we made\n    in the strong progress theorem: in this language, normal forms and\n    values are actually the same thing.\n\n```", "```\n\n    Why is this interesting?\n\n    Because value is a syntactic concept \u2014 it is defined by looking\n    at the form of a term \u2014 while normal_form is a semantic one \u2014\n    it is defined by looking at how the term steps.  It is not obvious\n    that these concepts should coincide!  Indeed, we could easily have\n    written the definitions so that they would *not* coincide. \n\n#### Exercise: 3 stars, optional (value_not_same_as_normal_form1)\n\n    We might, for example, mistakenly define value so that it\n    includes some terms that are not finished reducing.  (Even if you don't work this exercise and the following ones\n    in Coq, make sure you can think of an example of such a term.)\n\n```", "```\n\n    \u2610\n\n```", "```\nModule Temp2.\n\nInductive value : tm \u2192 Prop :=\n| v_const : \u2200n, value (C n).\n\nReserved Notation \" t '\u21d2' t' \" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_Funny : \u2200n,                         (*\u00a0<----\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C n \u21d2 P (C n) (C 0)\n\u00a0\u00a0| ST_PlusConstConst : \u2200n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P (C n[1]) (C n[2]) \u21d2 C (n[1] + n[2])\n\u00a0\u00a0| ST_Plus1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P t[1] t[2] \u21d2 P t[1]' t[2]\n\u00a0\u00a0| ST_Plus2 : \u2200v[1] t[2] t[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0value v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[2] \u21d2 t[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P v[1] t[2] \u21d2 P v[1] t[2]'\n\n\u00a0\u00a0where \" t '\u21d2' t' \" := (step t t').\n\nLemma value_not_same_as_normal_form :\n\u00a0\u00a0\u2203v, value v \u2227 \u00ac normal_form step v.\n\n    Proof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nEnd Temp2.\n\n```", "```\nModule Temp3.\n\nInductive value : tm \u2192 Prop :=\n\u00a0\u00a0| v_const : \u2200n, value (C n).\n\nReserved Notation \" t '\u21d2' t' \" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_PlusConstConst : \u2200n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P (C n[1]) (C n[2]) \u21d2 C (n[1] + n[2])\n\u00a0\u00a0| ST_Plus1 : \u2200t[1] t[1]' t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P t[1] t[2] \u21d2 P t[1]' t[2]\n\n\u00a0\u00a0where \" t '\u21d2' t' \" := (step t t').\n\n```", "```\nLemma value_not_same_as_normal_form :\n\u00a0\u00a0\u2203t, \u00ac value t \u2227 normal_form step t.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\nEnd Temp3.\n\n```", "```\n\n### Additional Exercises\n\n```", "```\n\n    Here is another very simple language whose terms, instead of being\n    just addition expressions and numbers, are just the booleans true\n    and false and a conditional expression...\n\n```", "```\n\n#### Exercise: 1 starM (smallstep_bools)\n\n    Which of the following propositions are provable?  (This is just a\n    thought exercise, but for an extra challenge feel free to prove\n    your answers in Coq.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 3 stars, optional (progress_bool)\n\n    Just as we proved a progress theorem for plus expressions, we can\n    do so for boolean expressions, as well.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, optional (step_deterministic)\n\n```", "```\n\n    \u2610\n\n```", "```\n\n#### Exercise: 2 stars (smallstep_bool_shortcut)\n\n    Suppose we want to add a \"short circuit\" to the step relation for\n    boolean expressions, so that it can recognize when the then and\n    else branches of a conditional are the same value (either\n    ttrue or tfalse) and reduce the whole conditional to this\n    value in a single step, even if the guard has not yet been reduced\n    to a value. For example, we would like this proposition to be\n    provable:\n\n```", "```\nReserved Notation \" t '\u21d2' t' \" (at level 40).\n\nInductive step : tm \u2192 tm \u2192 Prop :=\n\u00a0\u00a0| ST_IfTrue : \u2200t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tif ttrue t[1] t[2] \u21d2 t[1]\n\u00a0\u00a0| ST_IfFalse : \u2200t[1] t[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tif tfalse t[1] t[2] \u21d2 t[2]\n\u00a0\u00a0| ST_If : \u2200t[1] t[1]' t[2] t[3],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t[1] \u21d2 t[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tif t[1] t[2] t[3] \u21d2 tif t[1]' t[2] t[3]\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n\u00a0\u00a0where \" t '\u21d2' t' \" := (step t t').\n\nDefinition bool_step_prop4 :=\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tif\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(tif ttrue ttrue ttrue)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tfalse\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tfalse\n\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tfalse.\n\nExample bool_step_prop4_holds :\n\u00a0\u00a0bool_step_prop4.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nEnd Temp5.\nEnd Temp4.\n\n```", "```\n\n    Since we'll want to reuse the idea of multi-step reduction many\n    times, let's take a little extra trouble and define it\n    generically.\n\n    Given a relation R, we define a relation multi R, called the\n    *multi-step closure of R* as follows.\n\n```", "```\n\n    (In the [Rel](Rel.html) chapter and the Coq standard library, this relation\n    is called clos_refl_trans_1n.  We give it a shorter name here\n    for the sake of readability.)\n\n    The effect of this definition is that multi R relates two\n    elements x and y if \n\n*   x = y, or\n\n*   R x y, or\n\n*   there is some nonempty sequence z[1], z[2], ..., zn such that \n\n    ```", "```\n\n    Thus, if R describes a single-step of computation, then z[1]...zn \n    is the sequence of intermediate steps of computation between x and \n    y. \n\n    We write \u21d2* for the multi step relation on terms.\n\n```", "```\n\n    The relation multi R has several crucial properties.\n\n    First, it is obviously *reflexive* (that is, \u2200 x, multi R x x).  In the case of the \u21d2* (i.e., multi step) relation, the\n    intuition is that a term can execute to itself by taking zero\n    steps of execution.\n\n    Second, it contains R \u2014 that is, single-step executions are a\n    particular case of multi-step executions.  (It is this fact that\n    justifies the word \"closure\" in the term \"multi-step closure of\n    R.\")\n\n```", "```\n\n    Third, multi R is *transitive*.\n\n```", "```\n\n    In particular, for the multi step relation on terms, if\n    t[1]\u21d2*t[2] and t[2]\u21d2*t[3], then t[1]\u21d2*t[3].\n\n```", "```\nLemma test_multistep_1:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 0) (C 3))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 2) (C 4))\n\u00a0\u00a0\u00a0\u21d2*\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C ((0 + 3) + (2 + 4)).\nProof.\n\u00a0\u00a0apply multi_step with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C (0 + 3))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 2) (C 4))).\n\u00a0\u00a0apply ST_Plus1. apply ST_PlusConstConst.\n\u00a0\u00a0apply multi_step with\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C (0 + 3))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C (2 + 4))).\n\u00a0\u00a0apply ST_Plus2. apply v_const.\n\u00a0\u00a0apply ST_PlusConstConst.\n\u00a0\u00a0apply multi_R.\n\u00a0\u00a0apply ST_PlusConstConst. Qed.\n\n```", "```\nLemma test_multistep_1':\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 0) (C 3))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 2) (C 4))\n\u00a0\u00a0\u21d2*\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C ((0 + 3) + (2 + 4)).\nProof.\n\u00a0\u00a0eapply multi_step. apply ST_Plus1. apply ST_PlusConstConst.\n\u00a0\u00a0eapply multi_step. apply ST_Plus2. apply v_const.\n\u00a0\u00a0apply ST_PlusConstConst.\n\u00a0\u00a0eapply multi_step. apply ST_PlusConstConst.\n\u00a0\u00a0apply multi_refl. Qed.\n\n```", "```\nLemma test_multistep_2:\n\u00a0\u00a0C 3 \u21d2* C 3.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma test_multistep_3:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P (C 0) (C 3)\n\u00a0\u00a0\u00a0\u21d2*\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P (C 0) (C 3).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma test_multistep_4:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C 2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(P (C 0) (C 3)))\n\u00a0\u00a0\u21d2*\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0P\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(C (2 + (0 + 3))).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Normal Forms Again\n\n    If t reduces to t' in zero or more steps and t' is a\n    normal form, we say that \"t' is a normal form of t.\"\n\n```", "```\n\n    We have already seen that, for our language, single-step reduction is\n    deterministic \u2014 i.e., a given term can take a single step in\n    at most one way.  It follows from this that, if t can reach\n    a normal form, then this normal form is unique.  In other words, we\n    can actually pronounce normal_form t t' as \"t' is *the*\n    normal form of t.\" \n\n#### Exercise: 3 stars, optional (normal_forms_unique)\n\n```", "```\n\n    \u2610 \n\n    Indeed, something stronger is true for this language (though not\n    for all languages): the reduction of *any* term t will\n    eventually reach a normal form \u2014 i.e., normal_form_of is a\n    *total* function.  Formally, we say the step relation is\n    *normalizing*.\n\n```", "```\n\n    To prove that step is normalizing, we need a couple of lemmas.\n\n    First, we observe that, if t reduces to t' in many steps, then\n    the same sequence of reduction steps within t is also possible\n    when t appears as the left-hand child of a P node, and\n    similarly when t appears as the right-hand child of a P\n    node whose left-hand child is a value.\n\n```", "```\n\n#### Exercise: 2 stars (multistep_congr_2)\n\n```", "```\n\n    \u2610 \n\n    With these lemmas in hand, the main proof is a straightforward\n    induction.\n\n    *Theorem*: The step function is normalizing \u2014 i.e., for every\n    t there exists some t' such that t steps to t' and t' is\n    a normal form.\n\n    *Proof sketch*: By induction on terms.  There are two cases to\n    consider:\n\n*   t = C n for some n. Here t doesn't take a step, and we have t' = t. We can derive the left-hand side by reflexivity and the right-hand side by observing (a) that values are normal forms (by nf_same_as_value) and (b) that t is a value (by v_const). \n\n*   t = P t[1] t[2] for some t[1] and t[2]. By the IH, t[1] and t[2] have normal forms t[1]' and t[2]'. Recall that normal forms are values (by nf_same_as_value); we know that t[1]' = C n[1] and t[2]' = C n[2], for some n[1] and n[2]. We can combine the \u21d2* derivations for t[1] and t[2] using multi_congr_1 and multi_congr_2 to prove that P t[1] t[2] reduces in many steps to C (n[1] + n[2]). \n\n     It is clear that our choice of t' = C (n[1] + n[2]) is a value, which is in turn a normal form. \u2610\n\n```", "```\n\n## Equivalence of Big-Step and Small-Step\n\n    Having defined the operational semantics of our tiny programming\n    language in two different ways (big-step and small-step), it makes\n    sense to ask whether these definitions actually define the same\n    thing!  They do, though it takes a little work to show it.  The\n    details are left as an exercise. \n\n#### Exercise: 3 stars (eval__multistep)\n\n```", "```\n\n    The key ideas in the proof can be seen in the following picture:\n\n```", "```\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma step__eval : \u2200t t' n,\n\u00a0\u00a0\u00a0\u00a0\u00a0t \u21d2 t' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0t' \u21d3 n \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0t \u21d3 n.\nProof.\n\u00a0\u00a0intros t t' n Hs. generalize dependent n.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem multistep__eval : \u2200t t',\n\u00a0\u00a0normal_form_of t t' \u2192 \u2203n, t' = C n \u2227 t \u21d3 n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Additional Exercises\n\n#### Exercise: 3 stars, optional (interp_tm)\n\n    Remember that we also defined big-step evaluation of terms as a\n    function evalF.  Prove that it is equivalent to the existing\n    semantics.  (Hint: we just proved that eval and multistep are\n    equivalent, so logically it doesn't matter which you choose.\n    One will be easier than the other, though!)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 4 starsM (combined_properties)\n\n    We've considered arithmetic and conditional expressions\n    separately.  This exercise explores how the two interact.\n\n```", "```\n\n    Earlier, we separately proved for both plus- and if-expressions...\n\n*   that the step relation was deterministic, and \n\n*   a strong progress lemma, stating that every term is either a value or can take a step.\n\n    Prove or disprove these two properties for the combined language.\n\n```", "```\n\n    \u2610\n\n```", "```\nInductive aval : aexp \u2192 Prop :=\n\u00a0\u00a0| av_num : \u2200n, aval (ANum n).\n\n```", "```\nReserved Notation \" t '/' st '\u21d2a' t' \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 40, st at level 39).\n\nInductive astep : state \u2192 aexp \u2192 aexp \u2192 Prop :=\n\u00a0\u00a0| AS_Id : \u2200st i,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AId i / st \u21d2[a] ANum (st i)\n\u00a0\u00a0| AS_Plus : \u2200st n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0APlus (ANum n[1]) (ANum n[2]) / st \u21d2[a] ANum (n[1] + n[2])\n\u00a0\u00a0| AS_Plus1 : \u2200st a[1] a[1]' a[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a[1] / st \u21d2[a] a[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(APlus a[1] a[2]) / st \u21d2[a] (APlus a[1]' a[2])\n\u00a0\u00a0| AS_Plus2 : \u2200st v[1] a[2] a[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aval v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a[2] / st \u21d2[a] a[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(APlus v[1] a[2]) / st \u21d2[a] (APlus v[1] a[2]')\n\u00a0\u00a0| AS_Minus : \u2200st n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(AMinus (ANum n[1]) (ANum n[2])) / st \u21d2[a] (ANum (minus n[1] n[2]))\n\u00a0\u00a0| AS_Minus1 : \u2200st a[1] a[1]' a[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a[1] / st \u21d2[a] a[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(AMinus a[1] a[2]) / st \u21d2[a] (AMinus a[1]' a[2])\n\u00a0\u00a0| AS_Minus2 : \u2200st v[1] a[2] a[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aval v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a[2] / st \u21d2[a] a[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(AMinus v[1] a[2]) / st \u21d2[a] (AMinus v[1] a[2]')\n\u00a0\u00a0| AS_Mult : \u2200st n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(AMult (ANum n[1]) (ANum n[2])) / st \u21d2[a] (ANum (mult n[1] n[2]))\n\u00a0\u00a0| AS_Mult1 : \u2200st a[1] a[1]' a[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a[1] / st \u21d2[a] a[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(AMult a[1] a[2]) / st \u21d2[a] (AMult a[1]' a[2])\n\u00a0\u00a0| AS_Mult2 : \u2200st v[1] a[2] a[2]',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0aval v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a[2] / st \u21d2[a] a[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(AMult v[1] a[2]) / st \u21d2[a] (AMult v[1] a[2]')\n\n\u00a0\u00a0\u00a0\u00a0where \" t '/' st '\u21d2a' t' \" := (astep st t t').\n\nReserved Notation \" t '/' st '\u21d2b' t' \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 40, st at level 39).\n\nInductive bstep : state \u2192 bexp \u2192 bexp \u2192 Prop :=\n| BS_Eq : \u2200st n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0(BEq (ANum n[1]) (ANum n[2])) / st \u21d2[b]\n\u00a0\u00a0\u00a0\u00a0(if (beq_nat n[1] n[2]) then BTrue else BFalse)\n| BS_Eq[1] : \u2200st a[1] a[1]' a[2],\n\u00a0\u00a0\u00a0\u00a0a[1] / st \u21d2[a] a[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0(BEq a[1] a[2]) / st \u21d2[b] (BEq a[1]' a[2])\n| BS_Eq[2] : \u2200st v[1] a[2] a[2]',\n\u00a0\u00a0\u00a0\u00a0aval v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0a[2] / st \u21d2[a] a[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0(BEq v[1] a[2]) / st \u21d2[b] (BEq v[1] a[2]')\n| BS_LtEq : \u2200st n[1] n[2],\n\u00a0\u00a0\u00a0\u00a0(BLe (ANum n[1]) (ANum n[2])) / st \u21d2[b]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(if (leb n[1] n[2]) then BTrue else BFalse)\n| BS_LtEq1 : \u2200st a[1] a[1]' a[2],\n\u00a0\u00a0\u00a0\u00a0a[1] / st \u21d2[a] a[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0(BLe a[1] a[2]) / st \u21d2[b] (BLe a[1]' a[2])\n| BS_LtEq2 : \u2200st v[1] a[2] a[2]',\n\u00a0\u00a0\u00a0\u00a0aval v[1] \u2192\n\u00a0\u00a0\u00a0\u00a0a[2] / st \u21d2[a] a[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0(BLe v[1] a[2]) / st \u21d2[b] (BLe v[1] a[2]')\n| BS_NotTrue : \u2200st,\n\u00a0\u00a0\u00a0\u00a0(BNot BTrue) / st \u21d2[b] BFalse\n| BS_NotFalse : \u2200st,\n\u00a0\u00a0\u00a0\u00a0(BNot BFalse) / st \u21d2[b] BTrue\n| BS_NotStep : \u2200st b[1] b[1]',\n\u00a0\u00a0\u00a0\u00a0b[1] / st \u21d2[b] b[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0(BNot b[1]) / st \u21d2[b] (BNot b[1]')\n| BS_AndTrueTrue : \u2200st,\n\u00a0\u00a0\u00a0\u00a0(BAnd BTrue BTrue) / st \u21d2[b] BTrue\n| BS_AndTrueFalse : \u2200st,\n\u00a0\u00a0\u00a0\u00a0(BAnd BTrue BFalse) / st \u21d2[b] BFalse\n| BS_AndFalse : \u2200st b[2],\n\u00a0\u00a0\u00a0\u00a0(BAnd BFalse b[2]) / st \u21d2[b] BFalse\n| BS_AndTrueStep : \u2200st b[2] b[2]',\n\u00a0\u00a0\u00a0\u00a0b[2] / st \u21d2[b] b[2]' \u2192\n\u00a0\u00a0\u00a0\u00a0(BAnd BTrue b[2]) / st \u21d2[b] (BAnd BTrue b[2]')\n| BS_AndStep : \u2200st b[1] b[1]' b[2],\n\u00a0\u00a0\u00a0\u00a0b[1] / st \u21d2[b] b[1]' \u2192\n\u00a0\u00a0\u00a0\u00a0(BAnd b[1] b[2]) / st \u21d2[b] (BAnd b[1]' b[2])\n\nwhere \" t '/' st '\u21d2b' t' \" := (bstep st t t').\n\n```", "```\nReserved Notation \" t '/' st '\u21d2' t' '/' st' \"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 40, st at level 39, t' at level 39).\n\nInductive cstep : (com * state) \u2192 (com * state) \u2192 Prop :=\n\u00a0\u00a0| CS_AssStep : \u2200st i a a',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a / st \u21d2[a] a' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(i ::= a) / st \u21d2 (i ::= a') / st\n\u00a0\u00a0| CS_Ass : \u2200st i n,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(i ::= (ANum n)) / st \u21d2 SKIP / (t_update st i n)\n\u00a0\u00a0| CS_SeqStep : \u2200st c[1] c[1]' st' c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1] / st \u21d2 c[1]' / st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(c[1] ;; c[2]) / st \u21d2 (c[1]' ;; c[2]) / st'\n\u00a0\u00a0| CS_SeqFinish : \u2200st c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(SKIP ;; c[2]) / st \u21d2 c[2] / st\n\u00a0\u00a0| CS_IfTrue : \u2200st c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IFB BTrue THEN c[1] ELSE c[2] FI / st \u21d2 c[1] / st\n\u00a0\u00a0| CS_IfFalse : \u2200st c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IFB BFalse THEN c[1] ELSE c[2] FI / st \u21d2 c[2] / st\n\u00a0\u00a0| CS_IfStep : \u2200st b b' c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b / st \u21d2[b] b' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IFB b THEN c[1] ELSE c[2] FI / st \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2 (IFB b' THEN c[1] ELSE c[2] FI) / st\n\u00a0\u00a0| CS_While : \u2200st b c[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(WHILE b DO c[1] END) / st\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2 (IFB b THEN (c[1];; (WHILE b DO c[1] END)) ELSE SKIP FI) / st\n\n\u00a0\u00a0where \" t '/' st '\u21d2' t' '/' st' \" := (cstep (t,st) (t',st')).\n\n```", "```\nModule CImp.\n\nInductive com : Type :=\n\u00a0\u00a0| CSkip : com\n\u00a0\u00a0| CAss : id \u2192 aexp \u2192 com\n\u00a0\u00a0| CSeq : com \u2192 com \u2192 com\n\u00a0\u00a0| CIf : bexp \u2192 com \u2192 com \u2192 com\n\u00a0\u00a0| CWhile : bexp \u2192 com \u2192 com\n\u00a0\u00a0(*\u00a0New:\u00a0*)\n\u00a0\u00a0| CPar : com \u2192 com \u2192 com.\n\nNotation \"'SKIP'\" :=\n\u00a0\u00a0CSkip.\nNotation \"x '::=' a\" :=\n\u00a0\u00a0(CAss x a) (at level 60).\nNotation \"c1 ;; c2\" :=\n\u00a0\u00a0(CSeq c[1] c[2]) (at level 80, right associativity).\nNotation \"'WHILE' b 'DO' c 'END'\" :=\n\u00a0\u00a0(CWhile b c) (at level 80, right associativity).\nNotation \"'IFB' b 'THEN' c1 'ELSE' c2 'FI'\" :=\n\u00a0\u00a0(CIf b c[1] c[2]) (at level 80, right associativity).\nNotation \"'PAR' c1 'WITH' c2 'END'\" :=\n\u00a0\u00a0(CPar c[1] c[2]) (at level 80, right associativity).\n\nInductive cstep : (com * state)  \u2192 (com * state) \u2192 Prop :=\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Old\u00a0part\u00a0*)\n\u00a0\u00a0| CS_AssStep : \u2200st i a a',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a / st \u21d2[a] a' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(i ::= a) / st \u21d2 (i ::= a') / st\n\u00a0\u00a0| CS_Ass : \u2200st i n,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(i ::= (ANum n)) / st \u21d2 SKIP / (t_update st i n)\n\u00a0\u00a0| CS_SeqStep : \u2200st c[1] c[1]' st' c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1] / st \u21d2 c[1]' / st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(c[1] ;; c[2]) / st \u21d2 (c[1]' ;; c[2]) / st'\n\u00a0\u00a0| CS_SeqFinish : \u2200st c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(SKIP ;; c[2]) / st \u21d2 c[2] / st\n\u00a0\u00a0| CS_IfTrue : \u2200st c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(IFB BTrue THEN c[1] ELSE c[2] FI) / st \u21d2 c[1] / st\n\u00a0\u00a0| CS_IfFalse : \u2200st c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(IFB BFalse THEN c[1] ELSE c[2] FI) / st \u21d2 c[2] / st\n\u00a0\u00a0| CS_IfStep : \u2200st b b' c[1] c[2],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0b /st \u21d2[b] b' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(IFB b THEN c[1] ELSE c[2] FI) / st \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2 (IFB b' THEN c[1] ELSE c[2] FI) / st\n\u00a0\u00a0| CS_While : \u2200st b c[1],\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(WHILE b DO c[1] END) / st \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u21d2 (IFB b THEN (c[1];; (WHILE b DO c[1] END)) ELSE SKIP FI) / st\n\u00a0\u00a0\u00a0\u00a0(*\u00a0New\u00a0part:\u00a0*)\n\u00a0\u00a0| CS_Par1 : \u2200st c[1] c[1]' c[2] st',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[1] / st \u21d2 c[1]' / st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(PAR c[1] WITH c[2] END) / st \u21d2 (PAR c[1]' WITH c[2] END) / st'\n\u00a0\u00a0| CS_Par2 : \u2200st c[1] c[2] c[2]' st',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c[2] / st \u21d2 c[2]' / st' \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(PAR c[1] WITH c[2] END) / st \u21d2 (PAR c[1] WITH c[2]' END) / st'\n\u00a0\u00a0| CS_ParDone : \u2200st,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(PAR SKIP WITH SKIP END) / st \u21d2 SKIP / st\n\u00a0\u00a0where \" t '/' st '\u21d2' t' '/' st' \" := (cstep (t,st) (t',st')).\n\nDefinition cmultistep := multi cstep.\n\nNotation \" t '/' st '\u21d2*' t' '/' st' \" :=\n\u00a0\u00a0\u00a0(multi cstep  (t,st) (t',st'))\n\u00a0\u00a0\u00a0(at level 40, st at level 39, t' at level 39).\n\n```", "```\nDefinition par_loop : com :=\n\u00a0\u00a0PAR\n\u00a0\u00a0\u00a0\u00a0Y ::= ANum 1\n\u00a0\u00a0WITH\n\u00a0\u00a0\u00a0\u00a0WHILE BEq (AId Y) (ANum 0) DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X ::= APlus (AId X) (ANum 1)\n\u00a0\u00a0\u00a0\u00a0END\n\u00a0\u00a0END.\n\n```", "```\nExample par_loop_example_0:\n\u00a0\u00a0\u2203st',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0par_loop / empty_state  \u21d2* SKIP / st'\n\u00a0\u00a0\u00a0\u00a0\u2227 st' X = 0.\n\n    Proof.\n\u00a0\u00a0eapply [ex_intro](http://coq.inria.fr/library/Coq.Init.Logic.html#ex_intro). split.\n\u00a0\u00a0unfold [par_loop](Smallstep.html#CImp.par_loop).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par1](Smallstep.html#CImp.CS_Par1).\n\u00a0\u00a0\u00a0\u00a0apply [CS_Ass](Smallstep.html#CImp.CS_Ass).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_While](Smallstep.html#CImp.CS_While).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq[1]](Smallstep.html#CImp.BS_Eq<sub>1</sub>). apply [AS_Id](Smallstep.html#CImp.AS_Id).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq](Smallstep.html#CImp.BS_Eq). simpl.\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfFalse](Smallstep.html#CImp.CS_IfFalse).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_ParDone](Smallstep.html#CImp.CS_ParDone).\n\u00a0\u00a0eapply [multi_refl](Smallstep.html#CImp.multi_refl).\n\u00a0\u00a0reflexivity. Qed.\n\n```", "```\nExample par_loop_example_2:\n\u00a0\u00a0\u2203st',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0par_loop / empty_state \u21d2* SKIP / st'\n\u00a0\u00a0\u00a0\u00a0\u2227 st' X = 2.\n\n    Proof.\n\u00a0\u00a0eapply [ex_intro](http://coq.inria.fr/library/Coq.Init.Logic.html#ex_intro). split.\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_While](Smallstep.html#CImp.CS_While).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq[1]](Smallstep.html#CImp.BS_Eq<sub>1</sub>). apply [AS_Id](Smallstep.html#CImp.AS_Id).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq](Smallstep.html#CImp.BS_Eq). simpl.\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfTrue](Smallstep.html#CImp.CS_IfTrue).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_SeqStep](Smallstep.html#CImp.CS_SeqStep).\n\u00a0\u00a0\u00a0\u00a0apply [CS_AssStep](Smallstep.html#CImp.CS_AssStep). apply [AS_Plus1](Smallstep.html#CImp.AS_Plus1). apply [AS_Id](Smallstep.html#CImp.AS_Id).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_SeqStep](Smallstep.html#CImp.CS_SeqStep).\n\u00a0\u00a0\u00a0\u00a0apply [CS_AssStep](Smallstep.html#CImp.CS_AssStep). apply [AS_Plus](Smallstep.html#CImp.AS_Plus).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_SeqStep](Smallstep.html#CImp.CS_SeqStep).\n\u00a0\u00a0\u00a0\u00a0apply [CS_Ass](Smallstep.html#CImp.CS_Ass).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_SeqFinish](Smallstep.html#CImp.CS_SeqFinish).\n\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_While](Smallstep.html#CImp.CS_While).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq[1]](Smallstep.html#CImp.BS_Eq<sub>1</sub>). apply [AS_Id](Smallstep.html#CImp.AS_Id).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq](Smallstep.html#CImp.BS_Eq). simpl.\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfTrue](Smallstep.html#CImp.CS_IfTrue).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_SeqStep](Smallstep.html#CImp.CS_SeqStep).\n\u00a0\u00a0\u00a0\u00a0apply [CS_AssStep](Smallstep.html#CImp.CS_AssStep). apply [AS_Plus1](Smallstep.html#CImp.AS_Plus1). apply [AS_Id](Smallstep.html#CImp.AS_Id).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_SeqStep](Smallstep.html#CImp.CS_SeqStep).\n\u00a0\u00a0\u00a0\u00a0apply [CS_AssStep](Smallstep.html#CImp.CS_AssStep). apply [AS_Plus](Smallstep.html#CImp.AS_Plus).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_SeqStep](Smallstep.html#CImp.CS_SeqStep).\n\u00a0\u00a0\u00a0\u00a0apply [CS_Ass](Smallstep.html#CImp.CS_Ass).\n\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par1](Smallstep.html#CImp.CS_Par1). apply [CS_Ass](Smallstep.html#CImp.CS_Ass).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_SeqFinish](Smallstep.html#CImp.CS_SeqFinish).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_While](Smallstep.html#CImp.CS_While).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq[1]](Smallstep.html#CImp.BS_Eq<sub>1</sub>). apply [AS_Id](Smallstep.html#CImp.AS_Id).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq](Smallstep.html#CImp.BS_Eq). simpl.\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfFalse](Smallstep.html#CImp.CS_IfFalse).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_ParDone](Smallstep.html#CImp.CS_ParDone).\n\u00a0\u00a0eapply [multi_refl](Smallstep.html#CImp.multi_refl).\n\u00a0\u00a0reflexivity. Qed.\n\n```", "```\nLemma par_body_n__Sn : \u2200n st,\n\u00a0\u00a0st X = n \u2227 st Y = 0 \u2192\n\u00a0\u00a0par_loop / st \u21d2* par_loop / (t_update st X (S n)).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma par_body_n : \u2200n st,\n\u00a0\u00a0st X = 0 \u2227 st Y = 0 \u2192\n\u00a0\u00a0\u2203st',\n\u00a0\u00a0\u00a0\u00a0par_loop / st \u21d2*  par_loop / st' \u2227 st' X = n \u2227 st' Y = 0.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem par_loop_any_X:\n\u00a0\u00a0\u2200n, \u2203st',\n\u00a0\u00a0\u00a0\u00a0par_loop / empty_state \u21d2*  SKIP / st'\n\u00a0\u00a0\u00a0\u00a0\u2227 st' X = n.\n\n    Proof.\n\u00a0\u00a0intros n.\n\u00a0\u00a0destruct ([par_body_n](Smallstep.html#CImp.par_body_n) n [empty_state](Imp.html#empty_state)).\n\u00a0\u00a0\u00a0\u00a0split; unfold [t_update](Maps.html#t_update); reflexivity.\n\n\u00a0\u00a0rename x into st.\n\u00a0\u00a0inversion H as [H' [HX HY]]; clear H.\n\u00a0\u00a0\u2203([t_update](Maps.html#t_update) st [Y](Imp.html#Y) 1). split.\n\u00a0\u00a0eapply [multi_trans](Smallstep.html#CImp.multi_trans) with ([par_loop](Smallstep.html#CImp.par_loop),st). apply H'.\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par1](Smallstep.html#CImp.CS_Par1). apply [CS_Ass](Smallstep.html#CImp.CS_Ass).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_While](Smallstep.html#CImp.CS_While).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq[1]](Smallstep.html#CImp.BS_Eq<sub>1</sub>). apply [AS_Id](Smallstep.html#CImp.AS_Id). rewrite [t_update_eq](Maps.html#t_update_eq).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfStep](Smallstep.html#CImp.CS_IfStep).\n\u00a0\u00a0\u00a0\u00a0apply [BS_Eq](Smallstep.html#CImp.BS_Eq). simpl.\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_Par2](Smallstep.html#CImp.CS_Par2). apply [CS_IfFalse](Smallstep.html#CImp.CS_IfFalse).\n\u00a0\u00a0eapply [multi_step](Smallstep.html#CImp.multi_step). apply [CS_ParDone](Smallstep.html#CImp.CS_ParDone).\n\u00a0\u00a0apply [multi_refl](Smallstep.html#CImp.multi_refl).\n\n\u00a0\u00a0rewrite [t_update_neq](Maps.html#t_update_neq). assumption. intro X; inversion X.\n    Qed.\n\nEnd CImp.\n\n```", "```\nDefinition stack := list nat.\nDefinition prog  := list sinstr.\n\nInductive stack_step : state \u2192 prog * stack \u2192 prog * stack \u2192 Prop :=\n\u00a0\u00a0| SS_Push : \u2200st stk n p',\n\u00a0\u00a0\u00a0\u00a0stack_step st (SPush n :: p', stk)      (p', n :: stk)\n\u00a0\u00a0| SS_Load : \u2200st stk i p',\n\u00a0\u00a0\u00a0\u00a0stack_step st (SLoad i :: p', stk)      (p', st i :: stk)\n\u00a0\u00a0| SS_Plus : \u2200st stk n m p',\n\u00a0\u00a0\u00a0\u00a0stack_step st (SPlus :: p', n::m::stk)  (p', (m+n)::stk)\n\u00a0\u00a0| SS_Minus : \u2200st stk n m p',\n\u00a0\u00a0\u00a0\u00a0stack_step st (SMinus :: p', n::m::stk) (p', (m-n)::stk)\n\u00a0\u00a0| SS_Mult : \u2200st stk n m p',\n\u00a0\u00a0\u00a0\u00a0stack_step st (SMult :: p', n::m::stk)  (p', (m*n)::stk).\n\nTheorem stack_step_deterministic : \u2200st,\n\u00a0\u00a0deterministic (stack_step st).\n\n    Proof.\n\u00a0\u00a0unfold [deterministic](Smallstep.html#deterministic). intros st x y[1] y[2] H[1] H[2].\n\u00a0\u00a0induction H[1]; inversion H[2]; reflexivity.\n    Qed.\n\nDefinition stack_multistep st := multi (stack_step st).\n\n```", "```\nDefinition compiler_is_correct_statement : Prop \n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nTheorem compiler_is_correct : compiler_is_correct_statement.\nProof.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]