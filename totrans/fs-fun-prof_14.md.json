["```\n{| let! pattern = expr in cexpr |} \n```", "```\nbuilder.Bind(expr, (fun pattern -> {| cexpr |})) \n```", "```\nlet log p = printfn \"expression is %A\" p\n\nlet loggedWorkflow = \n    let x = 42\n    log x\n    let y = 43\n    log y\n    let z = x + y\n    log z\n    //return\n    z \n```", "```\nexpression is 42\nexpression is 43\nexpression is 85 \n```", "```\ntype LoggingBuilder() =\n    let log p = printfn \"expression is %A\" p\n\n    member this.Bind(x, f) = \n        log x\n        f x\n\n    member this.Return(x) = \n        x \n```", "```\nlet logger = new LoggingBuilder() \n```", "```\nlet loggedWorkflow = \n    logger\n        {\n        let! x = 42\n        let! y = 43\n        let! z = x + y\n        return z\n        } \n```", "```\nlet divideBy bottom top =\n    if bottom = 0\n    then None\n    else Some(top/bottom) \n```", "```\nlet divideByWorkflow init x y z = \n    let a = init |> divideBy x\n    match a with\n    | None -> None  // give up\n    | Some a' ->    // keep going\n        let b = a' |> divideBy y\n        match b with\n        | None -> None  // give up\n        | Some b' ->    // keep going\n            let c = b' |> divideBy z\n            match c with\n            | None -> None  // give up\n            | Some c' ->    // keep going\n                //return \n                Some c' \n```", "```\nlet good = divideByWorkflow 12 3 2 1\nlet bad = divideByWorkflow 12 3 0 1 \n```", "```\ntype MaybeBuilder() =\n\n    member this.Bind(x, f) = \n        match x with\n        | None -> None\n        | Some a -> f a\n\n    member this.Return(x) = \n        Some x\n\nlet maybe = new MaybeBuilder() \n```", "```\nlet divideByWorkflow init x y z = \n    maybe \n        {\n        let! a = init |> divideBy x\n        let! b = a |> divideBy y\n        let! c = b |> divideBy z\n        return c\n        } \n```", "```\nlet good = divideByWorkflow 12 3 2 1\nlet bad = divideByWorkflow 12 3 0 1 \n```", "```\nlet map1 = [ (\"1\",\"One\"); (\"2\",\"Two\") ] |> Map.ofList\nlet map2 = [ (\"A\",\"Alice\"); (\"B\",\"Bob\") ] |> Map.ofList\nlet map3 = [ (\"CA\",\"California\"); (\"NY\",\"New York\") ] |> Map.ofList\n\nlet multiLookup key =\n    match map1.TryFind key with\n    | Some result1 -> Some result1   // success\n    | None ->   // failure\n        match map2.TryFind key with\n        | Some result2 -> Some result2 // success\n        | None ->   // failure\n            match map3.TryFind key with\n            | Some result3 -> Some result3  // success\n            | None -> None // failure \n```", "```\nmultiLookup \"A\" |> printfn \"Result for A is %A\" \nmultiLookup \"CA\" |> printfn \"Result for CA is %A\" \nmultiLookup \"X\" |> printfn \"Result for X is %A\" \n```", "```\ntype OrElseBuilder() =\n    member this.ReturnFrom(x) = x\n    member this.Combine (a,b) = \n        match a with\n        | Some _ -> a  // a succeeds -- use it\n        | None -> b    // a fails -- use b instead\n    member this.Delay(f) = f()\n\nlet orElse = new OrElseBuilder() \n```", "```\nlet map1 = [ (\"1\",\"One\"); (\"2\",\"Two\") ] |> Map.ofList\nlet map2 = [ (\"A\",\"Alice\"); (\"B\",\"Bob\") ] |> Map.ofList\nlet map3 = [ (\"CA\",\"California\"); (\"NY\",\"New York\") ] |> Map.ofList\n\nlet multiLookup key = orElse {\n    return! map1.TryFind key\n    return! map2.TryFind key\n    return! map3.TryFind key\n    } \n```", "```\nmultiLookup \"A\" |> printfn \"Result for A is %A\" \nmultiLookup \"CA\" |> printfn \"Result for CA is %A\" \nmultiLookup \"X\" |> printfn \"Result for X is %A\" \n```", "```\nopen System.Net\nlet req1 = HttpWebRequest.Create(\"http://tryfsharp.org\")\nlet req2 = HttpWebRequest.Create(\"http://google.com\")\nlet req3 = HttpWebRequest.Create(\"http://bing.com\")\n\nreq1.BeginGetResponse((fun r1 -> \n    use resp1 = req1.EndGetResponse(r1)\n    printfn \"Downloaded %O\" resp1.ResponseUri\n\n    req2.BeginGetResponse((fun r2 -> \n        use resp2 = req2.EndGetResponse(r2)\n        printfn \"Downloaded %O\" resp2.ResponseUri\n\n        req3.BeginGetResponse((fun r3 -> \n            use resp3 = req3.EndGetResponse(r3)\n            printfn \"Downloaded %O\" resp3.ResponseUri\n\n            ),null) |> ignore\n        ),null) |> ignore\n    ),null) |> ignore \n```", "```\nopen System.Net\nlet req1 = HttpWebRequest.Create(\"http://tryfsharp.org\")\nlet req2 = HttpWebRequest.Create(\"http://google.com\")\nlet req3 = HttpWebRequest.Create(\"http://bing.com\")\n\nasync {\n    use! resp1 = req1.AsyncGetResponse()  \n    printfn \"Downloaded %O\" resp1.ResponseUri\n\n    use! resp2 = req2.AsyncGetResponse()  \n    printfn \"Downloaded %O\" resp2.ResponseUri\n\n    use! resp3 = req3.AsyncGetResponse()  \n    printfn \"Downloaded %O\" resp3.ResponseUri\n\n    } |> Async.RunSynchronously \n```", "```\nmaybe \n    {\n    let! a = x |> divideBy y \n    let! b = a |> divideBy w\n    let! c = b |> divideBy z\n    return c\n    } \n```", "```\n let log p = printfn \"expression is %A\" p\n\nlet loggedWorkflow = \n    let x = 42\n    log x\n    let y = 43\n    log y\n    let z = x + y\n    log z\n    //return\n    z \n```", "```\nlet loggedWorkflow = \n    logger\n        {\n        let! x = 42\n        let! y = 43\n        let! z = x + y\n        return z\n        } \n```", "```\npublic int Divide(int top, int bottom) {\n    if (bottom==0)\n    {\n        throw new InvalidOperationException(\"div by 0\");\n    }\n    else\n    {\n        return top/bottom;\n    }\n}\n\npublic bool IsEven(int aNumber) {\n    var isEven = (aNumber % 2 == 0);\n    return isEven;\n} \n```", "```\npublic T Divide<T>(int top, int bottom, Func<T> ifZero, Func<int,T> ifSuccess)\n{\n    if (bottom==0)\n    {\n        return ifZero();\n    }\n    else\n    {\n        return ifSuccess( top/bottom );\n    }\n}\n\npublic T IsEven<T>(int aNumber, Func<int,T> ifOdd, Func<int,T> ifEven)\n{\n    if (aNumber % 2 == 0)\n    {\n        return ifEven(aNumber);\n    }\n    else\n    {   return ifOdd(aNumber);\n    }\n} \n```", "```\nlet divide top bottom = \n    if (bottom=0) \n    then invalidOp \"div by 0\"\n    else (top/bottom)\n\nlet isEven aNumber = \n    aNumber % 2 = 0 \n```", "```\nlet divide ifZero ifSuccess top bottom = \n    if (bottom=0) \n    then ifZero()\n    else ifSuccess (top/bottom)\n\nlet isEven ifOdd ifEven aNumber = \n    if (aNumber % 2 = 0)\n    then aNumber |> ifEven \n    else aNumber |> ifOdd \n```", "```\n// Scenario 1: pipe the result into a message\n// ----------------------------------------\n// setup the functions to print a message\nlet ifZero1 () = printfn \"bad\"\nlet ifSuccess1 x = printfn \"good %i\" x\n\n// use partial application\nlet divide1  = divide ifZero1 ifSuccess1\n\n//test\nlet good1 = divide1 6 3\nlet bad1 = divide1 6 0\n\n// Scenario 2: convert the result to an option\n// ----------------------------------------\n// setup the functions to return an Option\nlet ifZero2() = None\nlet ifSuccess2 x = Some x\nlet divide2  = divide ifZero2 ifSuccess2\n\n//test\nlet good2 = divide2 6 3\nlet bad2 = divide2 6 0\n\n// Scenario 3: throw an exception in the bad case\n// ----------------------------------------\n// setup the functions to throw exception\nlet ifZero3() = failwith \"div by 0\"\nlet ifSuccess3 x = x\nlet divide3  = divide ifZero3 ifSuccess3\n\n//test\nlet good3 = divide3 6 3\nlet bad3 = divide3 6 0 \n```", "```\n// Scenario 1: pipe the result into a message\n// ----------------------------------------\n// setup the functions to print a message\nlet ifOdd1 x = printfn \"isOdd %i\" x\nlet ifEven1 x = printfn \"isEven %i\" x\n\n// use partial application\nlet isEven1  = isEven ifOdd1 ifEven1\n\n//test\nlet good1 = isEven1 6 \nlet bad1 = isEven1 5\n\n// Scenario 2: convert the result to an option\n// ----------------------------------------\n// setup the functions to return an Option\nlet ifOdd2 _ = None\nlet ifEven2 x = Some x\nlet isEven2  = isEven ifOdd2 ifEven2\n\n//test\nlet good2 = isEven2 6 \nlet bad2 = isEven2 5\n\n// Scenario 3: throw an exception in the bad case\n// ----------------------------------------\n// setup the functions to throw exception\nlet ifOdd3 _ = failwith \"assert failed\"\nlet ifEven3 x = x\nlet isEven3  = isEven ifOdd3 ifEven3\n\n//test\nlet good3 = isEven3 6 \nlet bad3 = isEven3 5 \n```", "```\ntype EmailAddress = EmailAddress of string\n\nlet CreateEmailAddressWithContinuations success failure (s:string) = \n    if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n        then success (EmailAddress s)\n        else failure \"Email address must contain an @ sign\" \n```", "```\n// setup the functions \nlet success (EmailAddress s) = printfn \"success creating email %s\" s        \nlet failure  msg = printfn \"error creating email: %s\" msg\nlet createEmail = CreateEmailAddressWithContinuations success failure\n\n// test\nlet goodEmail = createEmail \"x@example.com\"\nlet badEmail = createEmail \"example.com\" \n```", "```\ncall a function ->\n   <- return from the function\ncall another function ->\n   <- return from the function\ncall yet another function ->\n   <- return from the function \n```", "```\nevaluate something and pass it into ->\n   a function that evaluates something and passes it into ->\n      another function that evaluates something and passes it into ->\n         yet another function that evaluates something and passes it into ->\n            ...etc... \n```", "```\nlet x = someExpression \n```", "```\nlet x = someExpression in [an expression involving x] \n```", "```\nlet x = 42\nlet y = 43\nlet z = x + y \n```", "```\nlet x = 42 in   \n  let y = 43 in \n    let z = x + y in\n       z    // the result \n```", "```\nfun x -> [an expression involving x] \n```", "```\nsomeExpression |> (fun x -> [an expression involving x] ) \n```", "```\n// let\nlet x = someExpression in [an expression involving x]\n\n// pipe a value into a lambda\nsomeExpression |> (fun x -> [an expression involving x] ) \n```", "```\n42 |> (fun x ->\n  43 |> (fun y -> \n     x + y |> (fun z -> \n       z))) \n```", "```\nlet pipeInto (someExpression,lambda) =\n    someExpression |> lambda \n```", "```\npipeInto (42, fun x ->\n  pipeInto (43, fun y -> \n    pipeInto (x + y, fun z -> \n       z))) \n```", "```\npipeInto (42, fun x ->\npipeInto (43, fun y -> \npipeInto (x + y, fun z -> \nz))) \n```", "```\nlet pipeInto (someExpression,lambda) =\n   printfn \"expression is %A\" someExpression \n   someExpression |> lambda \n```", "```\npipeInto (42, fun x ->\npipeInto (43, fun y -> \npipeInto (x + y, fun z -> \nz\n))) \n```", "```\nexpression is 42\nexpression is 43\nexpression is 85 \n```", "```\nlet divideBy bottom top =\n    if bottom = 0\n    then None\n    else Some(top/bottom)\n\nlet divideByWorkflow x y w z = \n    let a = x |> divideBy y \n    match a with\n    | None -> None  // give up\n    | Some a' ->    // keep going\n        let b = a' |> divideBy w\n        match b with\n        | None -> None  // give up\n        | Some b' ->    // keep going\n            let c = b' |> divideBy z\n            match c with\n            | None -> None  // give up\n            | Some c' ->    // keep going\n                //return \n                Some c' \n```", "```\nlet pipeInto (someExpression,lambda) =\n   match someExpression with\n   | None -> \n       None\n   | Some x -> \n       x |> lambda \n```", "```\nlet divideByWorkflow x y w z = \n    let a = x |> divideBy y \n    pipeInto (a, fun a' ->\n        let b = a' |> divideBy w\n        pipeInto (b, fun b' ->\n            let c = b' |> divideBy z\n            pipeInto (c, fun c' ->\n                Some c' //return \n                ))) \n```", "```\nlet a = x |> divideBy y \npipeInto (a, fun a' -> \n```", "```\npipeInto (x |> divideBy y, fun a' -> \n```", "```\nlet divideByResult x y w z = \n    pipeInto (x |> divideBy y, fun a ->\n    pipeInto (a |> divideBy w, fun b ->\n    pipeInto (b |> divideBy z, fun c ->\n    Some c //return \n    ))) \n```", "```\nlet divideBy bottom top =\n    if bottom = 0\n    then None\n    else Some(top/bottom)\n\nlet pipeInto (someExpression,lambda) =\n   match someExpression with\n   | None -> \n       None\n   | Some x -> \n       x |> lambda \n\nlet return' c = Some c\n\nlet divideByWorkflow x y w z = \n    pipeInto (x |> divideBy y, fun a ->\n    pipeInto (a |> divideBy w, fun b ->\n    pipeInto (b |> divideBy z, fun c ->\n    return' c \n    )))\n\nlet good = divideByWorkflow 12 3 2 1\nlet bad = divideByWorkflow 12 3 0 1 \n```", "```\n// documentation\n{| let! pattern = expr in cexpr |}\n\n// real example\nlet! x = 43 in some expression \n```", "```\n// documentation\nbuilder.Bind(expr, (fun pattern -> {| cexpr |}))\n\n// real example\nbuilder.Bind(43, (fun x -> some expression)) \n```", "```\nlet! x = 1\nlet! y = 2\nlet! z = x + y \n```", "```\nBind(1, fun x ->\nBind(2, fun y ->\nBind(x + y, fun z ->\netc \n```", "```\nlet (>>=) m f = pipeInto(m,f) \n```", "```\nlet divideByWorkflow x y w z = \n    x |> divideBy y >>= divideBy w >>= divideBy z \n```", "```\nlet (>>=) m f = \n    printfn \"expression is %A\" m\n    f m\n\nlet loggingWorkflow = \n    1 >>= (+) 2 >>= (*) 42 >>= id \n```", "```\nlet pipeInto (m,f) =\n   match m with\n   | None -> \n       None\n   | Some x -> \n       x |> f \n```", "```\nmodule Option = \n    let bind f m =\n       match m with\n       | None -> \n           None\n       | Some x -> \n           x |> f \n```", "```\ntype MaybeBuilder() =\n    member this.Bind(m, f) = Option.bind f m\n    member this.Return(x) = Some x \n```", "```\nmodule DivideByExplicit = \n\n    let divideBy bottom top =\n        if bottom = 0\n        then None\n        else Some(top/bottom)\n\n    let divideByWorkflow x y w z = \n        let a = x |> divideBy y \n        match a with\n        | None -> None  // give up\n        | Some a' ->    // keep going\n            let b = a' |> divideBy w\n            match b with\n            | None -> None  // give up\n            | Some b' ->    // keep going\n                let c = b' |> divideBy z\n                match c with\n                | None -> None  // give up\n                | Some c' ->    // keep going\n                    //return \n                    Some c'\n    // test\n    let good = divideByWorkflow 12 3 2 1\n    let bad = divideByWorkflow 12 3 0 1 \n```", "```\nmodule DivideByWithBindFunction = \n\n    let divideBy bottom top =\n        if bottom = 0\n        then None\n        else Some(top/bottom)\n\n    let bind (m,f) =\n        Option.bind f m\n\n    let return' x = Some x\n\n    let divideByWorkflow x y w z = \n        bind (x |> divideBy y, fun a ->\n        bind (a |> divideBy w, fun b ->\n        bind (b |> divideBy z, fun c ->\n        return' c \n        )))\n\n    // test\n    let good = divideByWorkflow 12 3 2 1\n    let bad = divideByWorkflow 12 3 0 1 \n```", "```\nmodule DivideByWithCompExpr = \n\n    let divideBy bottom top =\n        if bottom = 0\n        then None\n        else Some(top/bottom)\n\n    type MaybeBuilder() =\n        member this.Bind(m, f) = Option.bind f m\n        member this.Return(x) = Some x\n\n    let maybe = new MaybeBuilder()\n\n    let divideByWorkflow x y w z = \n        maybe \n            {\n            let! a = x |> divideBy y \n            let! b = a |> divideBy w\n            let! c = b |> divideBy z\n            return c\n            }    \n\n    // test\n    let good = divideByWorkflow 12 3 2 1\n    let bad = divideByWorkflow 12 3 0 1 \n```", "```\nmodule DivideByWithBindOperator = \n\n    let divideBy bottom top =\n        if bottom = 0\n        then None\n        else Some(top/bottom)\n\n    let (>>=) m f = Option.bind f m\n\n    let divideByWorkflow x y w z = \n        x |> divideBy y \n        >>= divideBy w \n        >>= divideBy z \n\n    // test\n    let good = divideByWorkflow 12 3 2 1\n    let bad = divideByWorkflow 12 3 0 1 \n```", "```\nlet strToInt str = ??? \n```", "```\nlet stringAddWorkflow x y z = \n    yourWorkflow \n        {\n        let! a = strToInt x\n        let! b = strToInt y\n        let! c = strToInt z\n        return a + b + c\n        }    \n\n// test\nlet good = stringAddWorkflow \"12\" \"3\" \"2\"\nlet bad = stringAddWorkflow \"12\" \"xyz\" \"2\" \n```", "```\nlet strAdd str i = ???\nlet (>>=) m f = ??? \n```", "```\nlet good = strToInt \"1\" >>= strAdd \"2\" >>= strAdd \"3\"\nlet bad = strToInt \"1\" >>= strAdd \"xyz\" >>= strAdd \"3\" \n```", "```\nlet result = \n    maybe \n        {\n        let! anInt = expression of Option<int>\n        let! anInt2 = expression of Option<int>\n        return anInt + anInt2 \n        } \n```", "```\ntype DbResult<'a> = \n    | Success of 'a\n    | Error of string \n```", "```\nlet getCustomerId name =\n    if (name = \"\") \n    then Error \"getCustomerId failed\"\n    else Success \"Cust42\"\n\nlet getLastOrderForCustomer custId =\n    if (custId = \"\") \n    then Error \"getLastOrderForCustomer failed\"\n    else Success \"Order123\"\n\nlet getLastProductForOrder orderId =\n    if (orderId  = \"\") \n    then Error \"getLastProductForOrder failed\"\n    else Success \"Product456\" \n```", "```\nlet product = \n    let r1 = getCustomerId \"Alice\"\n    match r1 with \n    | Error _ -> r1\n    | Success custId ->\n        let r2 = getLastOrderForCustomer custId \n        match r2 with \n        | Error _ -> r2\n        | Success orderId ->\n            let r3 = getLastProductForOrder orderId \n            match r3 with \n            | Error _ -> r3\n            | Success productId ->\n                printfn \"Product is %s\" productId\n                r3 \n```", "```\ntype DbResultBuilder() =\n\n    member this.Bind(m, f) = \n        match m with\n        | Error _ -> m\n        | Success a -> \n            printfn \"\\tSuccessful: %s\" a\n            f a\n\n    member this.Return(x) = \n        Success x\n\nlet dbresult = new DbResultBuilder() \n```", "```\nlet product' = \n    dbresult {\n        let! custId = getCustomerId \"Alice\"\n        let! orderId = getLastOrderForCustomer custId\n        let! productId = getLastProductForOrder orderId \n        printfn \"Product is %s\" productId\n        return productId\n        }\nprintfn \"%A\" product' \n```", "```\nlet product'' = \n    dbresult {\n        let! custId = getCustomerId \"Alice\"\n        let! orderId = getLastOrderForCustomer \"\" // error!\n        let! productId = getLastProductForOrder orderId \n        printfn \"Product is %s\" productId\n        return productId\n        }\nprintfn \"%A\" product'' \n```", "```\nmember Return : 'T -> M<'T> \n```", "```\n// return for the maybe workflow\nmember this.Return(x) = \n    Some x\n\n// return for the dbresult workflow\nmember this.Return(x) = \n    Success x \n```", "```\nmember Bind : M<'T> * ('T -> M<'U>) -> M<'U> \n```", "```\n// return for the maybe workflow\nmember this.Bind(m,f) = \n   match m with\n   | None -> None\n   | Some x -> f x\n\n// return for the dbresult workflow\nmember this.Bind(m, f) = \n    match m with\n    | Error _ -> m\n    | Success x -> \n        printfn \"\\tSuccessful: %s\" x\n        f x \n```", "```\ntype DbResult<'a> = \n    | Success of 'a\n    | Error of string\n\ntype CustomerId =  CustomerId of string\ntype OrderId =  OrderId of int\ntype ProductId =  ProductId of string \n```", "```\nlet getCustomerId name =\n    if (name = \"\") \n    then Error \"getCustomerId failed\"\n    else Success (CustomerId \"Cust42\")\n\nlet getLastOrderForCustomer (CustomerId custId) =\n    if (custId = \"\") \n    then Error \"getLastOrderForCustomer failed\"\n    else Success (OrderId 123)\n\nlet getLastProductForOrder (OrderId orderId) =\n    if (orderId  = 0) \n    then Error \"getLastProductForOrder failed\"\n    else Success (ProductId \"Product456\") \n```", "```\nlet product = \n    let r1 = getCustomerId \"Alice\"\n    match r1 with \n    | Error e -> Error e\n    | Success custId ->\n        let r2 = getLastOrderForCustomer custId \n        match r2 with \n        | Error e -> Error e\n        | Success orderId ->\n            let r3 = getLastProductForOrder orderId \n            match r3 with \n            | Error e -> Error e\n            | Success productId ->\n                printfn \"Product is %A\" productId\n                r3 \n```", "```\ntype DbResultBuilder() =\n\n    member this.Bind(m, f) = \n        match m with\n        | Error e -> Error e\n        | Success a -> \n            printfn \"\\tSuccessful: %A\" a\n            f a\n\n    member this.Return(x) = \n        Success x\n\nlet dbresult = new DbResultBuilder() \n```", "```\nlet product' = \n    dbresult {\n        let! custId = getCustomerId \"Alice\"\n        let! orderId = getLastOrderForCustomer custId\n        let! productId = getLastProductForOrder orderId \n        printfn \"Product is %A\" productId\n        return productId\n        }\nprintfn \"%A\" product' \n```", "```\nlet product'' = \n    dbresult {\n        let! custId = getCustomerId \"Alice\"\n        let! orderId = getLastOrderForCustomer (CustomerId \"\") //error\n        let! productId = getLastProductForOrder orderId \n        printfn \"Product is %A\" productId\n        return productId\n        }\nprintfn \"%A\" product'' \n```", "```\nlet subworkflow1 = myworkflow { return 42 }\nlet subworkflow2 = myworkflow { return 43 }\n\nlet aWrappedValue = \n    myworkflow {\n        let! unwrappedValue1 = subworkflow1\n        let! unwrappedValue2 = subworkflow2\n        return unwrappedValue1 + unwrappedValue2\n        } \n```", "```\nlet aWrappedValue = \n    myworkflow {\n        let! unwrappedValue1 = myworkflow {\n            let! x = myworkflow { return 1 }\n            return x\n            }\n        let! unwrappedValue2 = myworkflow {\n            let! y = myworkflow { return 2 }\n            return y\n            }\n        return unwrappedValue1 + unwrappedValue2\n        } \n```", "```\nlet a = \n    async {\n        let! x = doAsyncThing  // nested workflow\n        let! y = doNextAsyncThing x // nested workflow\n        return x + y\n    } \n```", "```\ntype MaybeBuilder() =\n    member this.Bind(m, f) = Option.bind f m\n    member this.Return(x) = \n        printfn \"Wrapping a raw value into an option\"\n        Some x\n    member this.ReturnFrom(m) = \n        printfn \"Returning an option directly\"\n        m\n\nlet maybe = new MaybeBuilder() \n```", "```\n// return an int\nmaybe { return 1  }\n\n// return an Option\nmaybe { return! (Some 2)  } \n```", "```\n// using return\nmaybe \n    {\n    let! x = 12 |> divideBy 3\n    let! y = x |> divideBy 2\n    return y  // return an int\n    }    \n\n// using return! \nmaybe \n    {\n    let! x = 12 |> divideBy 3\n    return! x |> divideBy 2  // return an Option\n    } \n```", "```\ntype StringIntBuilder() =\n\n    member this.Bind(m, f) = \n        let b,i = System.Int32.TryParse(m)\n        match b,i with\n        | false,_ -> \"error\"\n        | true,i -> f i\n\n    member this.Return(x) = \n        sprintf \"%i\" x\n\nlet stringint = new StringIntBuilder() \n```", "```\nlet good = \n    stringint {\n        let! i = \"42\"\n        let! j = \"43\"\n        return i+j\n        }\nprintfn \"good=%s\" good \n```", "```\nlet bad = \n    stringint {\n        let! i = \"42\"\n        let! j = \"xxx\"\n        return i+j\n        }\nprintfn \"bad=%s\" bad \n```", "```\nlet g1 = \"99\"\nlet g2 = stringint {\n            let! i = g1\n            return i\n            }\nprintfn \"g1=%s g2=%s\" g1 g2 \n```", "```\nlet b1 = \"xxx\"\nlet b2 = stringint {\n            let! i = b1\n            return i\n            }\nprintfn \"b1=%s b2=%s\" b1 b2 \n```", "```\n// fragment before refactoring\nmyworkflow {\n    let wrapped = // some wrapped value\n    let! unwrapped = wrapped\n    return unwrapped \n    } \n\n// refactored fragment \nmyworkflow {\n    let wrapped = // some wrapped value\n    return! wrapped\n    } \n```", "```\nmyworkflow {\n    let originalUnwrapped = something\n\n    // wrap it\n    let wrapped = myworkflow { return originalUnwrapped }\n\n    // unwrap it\n    let! newUnwrapped = wrapped\n\n    // assert they are the same\n    assertEqual newUnwrapped originalUnwrapped \n    } \n```", "```\nmyworkflow {\n    let originalWrapped = something\n\n    let newWrapped = myworkflow { \n\n        // unwrap it\n        let! unwrapped = originalWrapped\n\n        // wrap it\n        return unwrapped\n        }\n\n    // assert they are the same\n    assertEqual newWrapped originalWrapped\n    } \n```", "```\n// inlined\nlet result1 = myworkflow { \n    let! x = originalWrapped\n    let! y = f x  // some function on x\n    return! g y   // some function on y\n    }\n\n// using a child workflow (\"extraction\" refactoring)\nlet result2 = myworkflow { \n    let! y = myworkflow { \n        let! x = originalWrapped\n        return! f x // some function on x\n        }\n    return! g y     // some function on y\n    }\n\n// rule\nassertEqual result1 result2 \n```", "```\nbind( [1;2;3], fun elem -> // expression using a single element ) \n```", "```\nlet add = \n    bind( [1;2;3], fun elem1 -> \n    bind( [10;11;12], fun elem2 -> \n        elem1 + elem2\n    )) \n```", "```\nbind( [1;2;3], fun elem -> // expression using a single element, returning a list ) \n```", "```\nlet add = \n    bind( [1;2;3], fun elem1 -> \n    bind( [10;11;12], fun elem2 -> \n        [elem1 + elem2] // a list!\n    )) \n```", "```\nlet bind(list,f) =\n    // 1) for each element in list, apply f\n    // 2) f will return a list (as required by its signature)\n    // 3) the result is a list of lists \n```", "```\nlet bind(list,f) =\n    list \n    |> List.map f \n    |> List.concat\n\nlet added = \n    bind( [1;2;3], fun elem1 -> \n    bind( [10;11;12], fun elem2 -> \n//       elem1 + elem2    // error. \n        [elem1 + elem2]   // correctly returns a list.\n    )) \n```", "```\ntype ListWorkflowBuilder() =\n\n    member this.Bind(list, f) = \n        list |> List.collect f \n\n    member this.Return(x) = \n        [x]\n\nlet listWorkflow = new ListWorkflowBuilder() \n```", "```\nlet added = \n    listWorkflow {\n        let! i = [1;2;3]\n        let! j = [10;11;12]\n        return i+j\n        }\nprintfn \"added=%A\" added\n\nlet multiplied = \n    listWorkflow {\n        let! i = [1;2;3]\n        let! j = [10;11;12]\n        return i*j\n        }\nprintfn \"multiplied=%A\" multiplied \n```", "```\nval added : int list = [11; 12; 13; 12; 13; 14; 13; 14; 15]\nval multiplied : int list = [10; 11; 12; 20; 22; 24; 30; 33; 36] \n```", "```\n// let version\nlet! i = [1;2;3] in [some expression]\n\n// for..in..do version\nfor i in [1;2;3] do [some expression] \n```", "```\ntype ListWorkflowBuilder() =\n\n    member this.Bind(list, f) = \n        list |> List.collect f \n\n    member this.Return(x) = \n        [x]\n\n    member this.For(list, f) = \n        this.Bind(list, f)\n\nlet listWorkflow = new ListWorkflowBuilder() \n```", "```\nlet multiplied = \n    listWorkflow {\n        for i in [1;2;3] do\n        for j in [10;11;12] do\n        return i*j\n        }\nprintfn \"multiplied=%A\" multiplied \n```", "```\ntype IdentityBuilder() =\n    member this.Bind(m, f) = f m\n    member this.Return(x) = x\n    member this.ReturnFrom(x) = x\n\nlet identity = new IdentityBuilder()\n\nlet result = identity {\n    let! x = 1\n    let! y = 2\n    return x + y\n    } \n```", "```\nlet! x = ...wrapped type value...\n\n```", "```\n// let! pattern = expr in cexpr\nmaybe {\n    let! x,y = Some(1,2) \n    let! head::tail = Some( [1;2;3] )\n    // etc\n    } \n```", "```\nmaybe { for i in [1;2;3] do i } \n```", "```\nThis control construct may only be used if the computation expression builder defines a 'For' method \n```", "```\nmaybe { 1 } \n```", "```\nThis control construct may only be used if the computation expression builder defines a 'Zero' method \n```", "```\nlet x = 1           // 1 is an \"unwrapped\" type\nlet! x = (Some 1)   // Some 1 is a \"wrapped\" type\nreturn 1            // 1 is an \"unwrapped\" type\nreturn! (Some 1)    // Some 1 is a \"wrapped\" type\nyield 1             // 1 is an \"unwrapped\" type\nyield! (Some 1)     // Some 1 is a \"wrapped\" type \n```", "```\nlet! x = maybe {...)       // \"maybe\" returns a \"wrapped\" type\n\n// bind another workflow of the same type using let!\nlet! aMaybe = maybe {...)  // create a \"wrapped\" type\nreturn! aMaybe             // return it\n\n// bind two child asyncs inside a parent async using let!\nlet processUri uri = async {\n    let! html = webClient.AsyncDownloadString(uri)\n    let! links = extractLinks html\n    ... etc ...\n    } \n```", "```\ntype TraceBuilder() =\n    member this.Bind(m, f) = \n        match m with \n        | None -> \n            printfn \"Binding with None. Exiting.\"\n        | Some a -> \n            printfn \"Binding with Some(%A). Continuing\" a\n        Option.bind f m\n\n    member this.Return(x) = \n        printfn \"Returning a unwrapped %A as an option\" x\n        Some x\n\n    member this.ReturnFrom(m) = \n        printfn \"Returning an option (%A) directly\" m\n        m\n\n// make an instance of the workflow \nlet trace = new TraceBuilder() \n```", "```\ntrace { \n    return 1\n    } |> printfn \"Result 1: %A\" \n\ntrace { \n    return! Some 2\n    } |> printfn \"Result 2: %A\" \n\ntrace { \n    let! x = Some 1\n    let! y = Some 2\n    return x + y\n    } |> printfn \"Result 3: %A\" \n\ntrace { \n    let! x = None\n    let! y = Some 1\n    return x + y\n    } |> printfn \"Result 4: %A\" \n```", "```\ntrace { \n    do! Some (printfn \"...expression that returns unit\")\n    do! Some (printfn \"...another expression that returns unit\")\n    let! x = Some (1)\n    return x\n    } |> printfn \"Result from do: %A\" \n```", "```\n...expression that returns unit\nBinding with Some(<null>). Continuing\n...another expression that returns unit\nBinding with Some(<null>). Continuing\nBinding with Some(1). Continuing\nReturning a unwrapped 1 as an option\nResult from do: Some 1\n\n```", "```\ntrace { \n    } |> printfn \"Result for empty: %A\" \n```", "```\nThis value is not a function and cannot be applied \n```", "```\ntrace { \n    printfn \"hello world\"\n    } |> printfn \"Result for simple expression: %A\" \n```", "```\nThis control construct may only be used if the computation expression builder defines a 'Zero' method \n```", "```\ntrace { \n    if false then return 1\n    } |> printfn \"Result for if without else: %A\" \n```", "```\ntype TraceBuilder() =\n    // other members as before\n    member this.Zero() = \n        printfn \"Zero\"\n        None\n\n// make a new instance \nlet trace = new TraceBuilder()\n\n// test\ntrace { \n    printfn \"hello world\"\n    } |> printfn \"Result for simple expression: %A\" \n\ntrace { \n    if false then return 1\n    } |> printfn \"Result for if without else: %A\" \n```", "```\nlet s = seq {printfn \"zero\" }    // Error\nlet a = async {printfn \"zero\" }  // OK \n```", "```\ntrace { \n    yield 1\n    } |> printfn \"Result for yield: %A\" \n```", "```\nThis control construct may only be used if the computation expression builder defines a 'Yield' method \n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.Yield(x) = \n        printfn \"Yield an unwrapped %A as an option\" x\n        Some x\n\n// make a new instance \nlet trace = new TraceBuilder()\n\n// test\ntrace { \n    yield 1\n    } |> printfn \"Result for yield: %A\" \n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.YieldFrom(m) = \n        printfn \"Yield an option (%A) directly\" m\n        m\n\n// make a new instance \nlet trace = new TraceBuilder()\n\n// test\ntrace { \n    yield! Some 1\n    } |> printfn \"Result for yield!: %A\" \n```", "```\nlet s = seq {yield 1}    // OK\nlet s = seq {return 1}   // error\n\nlet a = async {return 1} // OK\nlet a = async {yield 1}  // error \n```", "```\ntype ListBuilder() =\n    member this.Bind(m, f) = \n        m |> List.collect f\n\n    member this.Zero() = \n        printfn \"Zero\"\n        []\n\n    member this.Return(x) = \n        printfn \"Return an unwrapped %A as a list\" x\n        [x]\n\n    member this.Yield(x) = \n        printfn \"Yield an unwrapped %A as a list\" x\n        [x]\n\n    member this.For(m,f) =\n        printfn \"For %A\" m\n        this.Bind(m,f)\n\n// make an instance of the workflow \nlet listbuilder = new ListBuilder() \n```", "```\nlistbuilder { \n    let! x = [1..3]\n    let! y = [10;20;30]\n    return x + y\n    } |> printfn \"Result: %A\" \n```", "```\nlistbuilder { \n    for x in [1..3] do\n    for y in [10;20;30] do\n    return x + y\n    } |> printfn \"Result: %A\" \n```", "```\ntype TraceBuilder() =\n    member this.Bind(m, f) = \n        match m with \n        | None -> \n            printfn \"Binding with None. Exiting.\"\n        | Some a -> \n            printfn \"Binding with Some(%A). Continuing\" a\n        Option.bind f m\n\n    member this.Return(x) = \n        printfn \"Returning a unwrapped %A as an option\" x\n        Some x\n\n    member this.ReturnFrom(m) = \n        printfn \"Returning an option (%A) directly\" m\n        m\n\n    member this.Zero() = \n        printfn \"Zero\"\n        None\n\n    member this.Yield(x) = \n        printfn \"Yield an unwrapped %A as an option\" x\n        Some x\n\n    member this.YieldFrom(m) = \n        printfn \"Yield an option (%A) directly\" m\n        m\n\n// make an instance of the workflow \nlet trace = new TraceBuilder() \n```", "```\ntrace { \n    yield 1\n    yield 2\n    } |> printfn \"Result for yield then yield: %A\" \n```", "```\nThis control construct may only be used if the computation expression builder defines a 'Combine' method. \n```", "```\ntrace { \n    return 1\n    return 2\n    } |> printfn \"Result for return then return: %A\" \n```", "```\ntrace { \n    if true then printfn \"hello\" \n    return 1\n    } |> printfn \"Result for if then return: %A\" \n```", "```\nBind(1,fun x -> \n   Bind(2,fun y -> \n     Bind(x + y,fun z -> \n        Return(z)  // or Yield \n```", "```\nBind(1,fun x -> \n   Bind(2,fun y -> \n     Bind(x + y,fun z -> \n        Yield(z)  \n// start a new expression \nBind(3,fun w -> \n   Bind(4,fun u -> \n     Bind(w + u,fun v -> \n        Yield(v) \n```", "```\nlet value1 = some expression \nlet value2 = some other expression \n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.Combine (a,b) = \n        match a,b with\n        | Some a', Some b' ->\n            printfn \"combining %A and %A\" a' b' \n            Some (a' + b')\n        | Some a', None ->\n            printfn \"combining %A with None\" a' \n            Some a'\n        | None, Some b' ->\n            printfn \"combining None with %A\" b' \n            Some b'\n        | None, None ->\n            printfn \"combining None with None\"\n            None\n\n// make a new instance \nlet trace = new TraceBuilder() \n```", "```\ntrace { \n    yield 1\n    yield 2\n    } |> printfn \"Result for yield then yield: %A\" \n```", "```\nThis control construct may only be used if the computation expression builder defines a 'Delay' method \n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.Delay(f) = \n        printfn \"Delay\"\n        f()\n\n// make a new instance \nlet trace = new TraceBuilder() \n```", "```\ntrace { \n    yield 1\n    yield 2\n    } |> printfn \"Result for yield then yield: %A\" \n```", "```\nDelay\nYield an unwrapped 1 as an option\nDelay\nYield an unwrapped 2 as an option\ncombining 1 and 2\nResult for yield then yield: Some 3 \n```", "```\ntrace { \n    yield 1\n    let! x = None\n    yield 2\n    } |> printfn \"Result for yield then None: %A\" \n```", "```\ntrace { \n    yield 1\n    yield 2\n    yield 3\n    } |> printfn \"Result for yield x 3: %A\" \n```", "```\ntrace { \n    yield 1\n    return 2\n    } |> printfn \"Result for yield then return: %A\" \n\ntrace { \n    return 1\n    return 2\n    } |> printfn \"Result for return then return: %A\" \n```", "```\ntype ListBuilder() =\n    member this.Bind(m, f) = \n        m |> List.collect f\n\n    member this.Zero() = \n        printfn \"Zero\"\n        []\n\n    member this.Yield(x) = \n        printfn \"Yield an unwrapped %A as a list\" x\n        [x]\n\n    member this.YieldFrom(m) = \n        printfn \"Yield a list (%A) directly\" m\n        m\n\n    member this.For(m,f) =\n        printfn \"For %A\" m\n        this.Bind(m,f)\n\n    member this.Combine (a,b) = \n        printfn \"combining %A and %A\" a b \n        List.concat [a;b]\n\n    member this.Delay(f) = \n        printfn \"Delay\"\n        f()\n\n// make an instance of the workflow \nlet listbuilder = new ListBuilder() \n```", "```\nlistbuilder { \n    yield 1\n    yield 2\n    } |> printfn \"Result for yield then yield: %A\" \n\nlistbuilder { \n    yield 1\n    yield! [2;3]\n    } |> printfn \"Result for yield then yield! : %A\" \n```", "```\nlistbuilder { \n    for i in [\"red\";\"blue\"] do\n        yield i\n        for j in [\"hat\";\"tie\"] do\n            yield! [i + \" \" + j;\"-\"]\n    } |> printfn \"Result for for..in..do : %A\" \n```", "```\n[\"red\"; \"red hat\"; \"-\"; \"red tie\"; \"-\"; \"blue\"; \"blue hat\"; \"-\"; \"blue tie\"; \"-\"] \n```", "```\nlistbuilder { \n    yield 1\n    yield 2\n    yield 3\n    yield 4\n    } |> printfn \"Result for yield x 4: %A\" \n```", "```\ncombining [3] and [4]\ncombining [2] and [3; 4]\ncombining [1] and [2; 3; 4]\nResult for yield x 4: [1; 2; 3; 4] \n```", "```\ntrace { \n    if true then printfn \"hello\"  //expression 1\n    return 1                      //expression 2\n    } |> printfn \"Result for combine: %A\" \n```", "```\nif (do first expression)\nor else (do second expression)\nor else (do third expression) \n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.Zero() = \n        printfn \"Zero\"\n        None  // failure\n\n    member this.Combine (a,b) = \n        printfn \"Combining %A with %A\" a b\n        match a with\n        | Some _ -> a  // a succeeds -- use it\n        | None -> b    // a fails -- use b instead\n\n// make a new instance \nlet trace = new TraceBuilder() \n```", "```\ntype IntOrBool = I of int | B of bool\n\nlet parseInt s = \n    match System.Int32.TryParse(s) with\n    | true,i -> Some (I i)\n    | false,_ -> None\n\nlet parseBool s = \n    match System.Boolean.TryParse(s) with\n    | true,i -> Some (B i)\n    | false,_ -> None\n\ntrace { \n    return! parseBool \"42\"  // fails\n    return! parseInt \"42\"\n    } |> printfn \"Result for parsing: %A\" \n```", "```\nSome (I 42) \n```", "```\nlet map1 = [ (\"1\",\"One\"); (\"2\",\"Two\") ] |> Map.ofList\nlet map2 = [ (\"A\",\"Alice\"); (\"B\",\"Bob\") ] |> Map.ofList\n\ntrace { \n    return! map1.TryFind \"A\"\n    return! map2.TryFind \"A\"\n    } |> printfn \"Result for map lookup: %A\" \n```", "```\nResult for map lookup: Some \"Alice\" \n```", "```\ndo some expression\ndo some other expression \nfinal expression \n```", "```\nsome expression; some other expression; final expression \n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.Zero() = \n        printfn \"Zero\"\n        this.Return ()  // unit not None\n\n    member this.Combine (a,b) = \n        printfn \"Combining %A with %A\" a b\n        this.Bind( a, fun ()-> b )\n\n// make a new instance \nlet trace = new TraceBuilder() \n```", "```\ntrace { \n    if true then printfn \"hello.......\"\n    if false then printfn \".......world\"\n    return 1\n    } |> printfn \"Result for sequential combine: %A\" \n```", "```\nhello.......\nZero\nReturning a unwrapped <null> as an option\nZero\nReturning a unwrapped <null> as an option\nReturning a unwrapped 1 as an option\nCombining Some null with Some 1\nCombining Some null with Some 1\nResult for sequential combine: Some 1 \n```", "```\ntype TraceBuilder() =\n\n    member this.ReturnFrom(x) = x\n\n    member this.Zero() = Some ()\n\n    member this.Combine (a,b) = \n        a |> Option.bind (fun ()-> b )\n\n    member this.Delay(f) = f()\n\n// make an instance of the workflow \nlet trace = new TraceBuilder() \n```", "```\ntrace { \n    if true then printfn \"hello.......\"\n    if false then printfn \".......world\"\n    return! Some 1\n    } |> printfn \"Result for minimal combine: %A\" \n```", "```\ntype ListBuilder() =\n\n    member this.Yield(x) = [x]\n\n    member this.For(m,f) =\n        m |> List.collect f\n\n    member this.Combine (a,b) = \n        List.concat [a;b]\n\n    member this.Delay(f) = f()\n\n// make an instance of the workflow \nlet listbuilder = new ListBuilder() \n```", "```\nlistbuilder { \n    yield 1\n    yield 2\n    } |> printfn \"Result: %A\" \n\nlistbuilder { \n    for i in [1..5] do yield i + 2\n    yield 42\n    } |> printfn \"Result: %A\" \n```", "```\nmodule StandaloneCombine = \n\n    let combine a b = \n        match a with\n        | Some _ -> a  // a succeeds -- use it\n        | None -> b    // a fails -- use b instead\n\n    // create an infix version\n    let ( <++ ) = combine\n\n    let map1 = [ (\"1\",\"One\"); (\"2\",\"Two\") ] |> Map.ofList\n    let map2 = [ (\"A\",\"Alice\"); (\"B\",\"Bob\") ] |> Map.ofList\n\n    let result = \n        (map1.TryFind \"A\") \n        <++ (map1.TryFind \"B\")\n        <++ (map2.TryFind \"A\")\n        <++ (map2.TryFind \"B\")\n        |> printfn \"Result of adding options is: %A\" \n```", "```\ntype TraceBuilder() =\n    member this.Bind(m, f) = \n        match m with \n        | None -> \n            printfn \"Binding with None. Exiting.\"\n        | Some a -> \n            printfn \"Binding with Some(%A). Continuing\" a\n        Option.bind f m\n\n    member this.Return(x) = \n        printfn \"Return an unwrapped %A as an option\" x\n        Some x\n\n    member this.Zero() = \n        printfn \"Zero\"\n        None\n\n    member this.Combine (a,b) = \n        printfn \"Returning early with %A. Ignoring second part: %A\" a b \n        a\n\n    member this.Delay(f) = \n        printfn \"Delay\"\n        f()\n\n// make an instance of the workflow \nlet trace = new TraceBuilder() \n```", "```\ntrace { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    printfn \"Part 2: after return has happened\"\n    } |> printfn \"Result for Part1 without Part2: %A\" \n```", "```\n// first expression, up to \"return\"\nDelay\nPart 1: about to return 1\nReturn an unwrapped 1 as an option\n\n// second expression, up to last curly brace.\nDelay\nPart 2: after return has happened\nZero   // zero here because no explicit return was given for this part\n\n// combining the two expressions\nReturning early with Some 1\\. Ignoring second part: <null>\n\n// final result\nResult for Part1 without Part2: Some 1 \n```", "```\nlet part2 = \n    fun () -> \n        printfn \"Part 2: after return has happened\"\n        // do other stuff\n        // return Zero\n\n// only evaluate if needed\nif needed then\n   let result = part2() \n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.Delay(funcToDelay) = \n        let delayed = fun () ->\n            printfn \"%A - Starting Delayed Fn.\" funcToDelay\n            let delayedResult = funcToDelay()\n            printfn \"%A - Finished Delayed Fn. Result is %A\" funcToDelay delayedResult\n            delayedResult  // return the result \n\n        printfn \"%A - Delaying using %A\" funcToDelay delayed\n        delayed // return the new function \n```", "```\n// signature BEFORE the change\nmember Delay : f:(unit -> 'a) -> 'a\n\n// signature AFTER the change\nmember Delay : f:(unit -> 'b) -> (unit -> 'b) \n```", "```\nmember this.Delay(f) = \n    f \n```", "```\ntrace { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    printfn \"Part 2: after return has happened\"\n    } |> printfn \"Result for Part1 without Part2: %A\" \n```", "```\nlet f = trace { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    printfn \"Part 2: after return has happened\"\n    } \nf() |> printfn \"Result for Part1 without Part2: %A\" \n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.Run(funcToRun) = \n        printfn \"%A - Run Start.\" funcToRun\n        let runResult = funcToRun()\n        printfn \"%A - Run End. Result is %A\" funcToRun runResult\n        runResult // return the result of running the delayed function \n```", "```\ntrace { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    printfn \"Part 2: after return has happened\"\n    } |> printfn \"Result for Part1 without Part2: %A\" \n```", "```\n// delaying the overall expression (the output of Combine)\n<fun:clo@160-66> - Delaying using <fun:delayed@141-3>\n\n// running the outermost delayed expression (the output of Combine)\n<fun:delayed@141-3> - Run Start.\n<fun:clo@160-66> - Starting Delayed Fn.\n\n// the first expression results in Some(1)\nPart 1: about to return 1\nReturn an unwrapped 1 as an option\n\n// the second expression is wrapped in a delay\n<fun:clo@162-67> - Delaying using <fun:delayed@141-3>\n\n// the first and second expressions are combined\nCombine. Returning early with Some 1\\. Ignoring <fun:delayed@141-3>\n\n// overall delayed expression (the output of Combine) is complete\n<fun:clo@160-66> - Finished Delayed Fn. Result is Some 1\n<fun:delayed@141-3> - Run End. Result is Some 1\n\n// the result is now an Option not a function\nResult for Part1 without Part2: Some 1 \n```", "```\nmember this.Combine (a: int option,b: int option) = \n    printfn \"Returning early with %A. Ignoring %A\" a b \n    a \n```", "```\ntrace { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    printfn \"Part 2: after return has happened\"\n    } |> printfn \"Result for Part1 without Part2: %A\" \n```", "```\nerror FS0001: This expression was expected to have type\n    int option    \nbut here has type\n    unit -> 'a    \n\n```", "```\ntype TraceBuilder() =\n    // other members as before\n\n    member this.Combine (m,f) = \n        printfn \"Combine. Starting second param %A\" f\n        let y = f()\n        printfn \"Combine. Finished second param %A. Result is %A\" f y\n\n        match m,y with\n        | Some a, Some b ->\n            printfn \"combining %A and %A\" a b \n            Some (a + b)\n        | Some a, None ->\n            printfn \"combining %A with None\" a \n            Some a\n        | None, Some b ->\n            printfn \"combining None with %A\" b \n            Some b\n        | None, None ->\n            printfn \"combining None with None\"\n            None \n```", "```\ntrace { \n    return 1\n    return 2\n    } |> printfn \"Result for return then return: %A\" \n```", "```\n// entire expression is delayed\n<fun:clo@318-69> - Delaying using <fun:delayed@295-6>\n\n// entire expression is run\n<fun:delayed@295-6> - Run Start.\n\n// delayed entire expression is run\n<fun:clo@318-69> - Starting Delayed Fn.\n\n// first return\nReturning a unwrapped 1 as an option\n\n// delaying second return\n<fun:clo@319-70> - Delaying using <fun:delayed@295-6>\n\n// combine starts\nCombine. Starting second param <fun:delayed@295-6>\n\n    // delayed second return is run inside Combine\n    <fun:clo@319-70> - Starting Delayed Fn.\n    Returning a unwrapped 2 as an option\n    <fun:clo@319-70> - Finished Delayed Fn. Result is Some 2\n    // delayed second return is complete\n\nCombine. Finished second param <fun:delayed@295-6>. Result is Some 2\ncombining 1 and 2\n// combine is complete\n\n<fun:clo@318-69> - Finished Delayed Fn. Result is Some 3\n// delayed entire expression is complete\n\n<fun:delayed@295-6> - Run End. Result is Some 3\n// Run is complete\n\n// final result is printed\nResult for return then return: Some 3 \n```", "```\n trace { \n        return 1\n        return 2\n        return 3\n        } |> printfn \"Result for return x 3: %A\" \n```", "```\ntype Internal = Internal of int option\ntype Delayed = Delayed of (unit -> Internal)\n\ntype TraceBuilder() =\n    member this.Bind(m, f) = \n        match m with \n        | None -> \n            printfn \"Binding with None. Exiting.\"\n        | Some a -> \n            printfn \"Binding with Some(%A). Continuing\" a\n        Option.bind f m\n\n    member this.Return(x) = \n        printfn \"Returning a unwrapped %A as an option\" x\n        Internal (Some x) \n\n    member this.ReturnFrom(m) = \n        printfn \"Returning an option (%A) directly\" m\n        Internal m\n\n    member this.Zero() = \n        printfn \"Zero\"\n        Internal None\n\n    member this.Combine (Internal x, Delayed g) : Internal = \n        printfn \"Combine. Starting %A\" g\n        let (Internal y) = g()\n        printfn \"Combine. Finished %A. Result is %A\" g y\n        let o = \n            match x,y with\n            | Some a, Some b ->\n                printfn \"Combining %A and %A\" a b \n                Some (a + b)\n            | Some a, None ->\n                printfn \"combining %A with None\" a \n                Some a\n            | None, Some b ->\n                printfn \"combining None with %A\" b \n                Some b\n            | None, None ->\n                printfn \"combining None with None\"\n                None\n        // return the new value wrapped in a Internal\n        Internal o                \n\n    member this.Delay(funcToDelay) = \n        let delayed = fun () ->\n            printfn \"%A - Starting Delayed Fn.\" funcToDelay\n            let delayedResult = funcToDelay()\n            printfn \"%A - Finished Delayed Fn. Result is %A\" funcToDelay delayedResult\n            delayedResult  // return the result \n\n        printfn \"%A - Delaying using %A\" funcToDelay delayed\n        Delayed delayed // return the new function wrapped in a Delay\n\n    member this.Run(Delayed funcToRun) = \n        printfn \"%A - Run Start.\" funcToRun\n        let (Internal runResult) = funcToRun()\n        printfn \"%A - Run End. Result is %A\" funcToRun runResult\n        runResult // return the result of running the delayed function\n\n// make an instance of the workflow \nlet trace = new TraceBuilder() \n```", "```\ntype Internal = | Internal of int option\ntype Delayed = | Delayed of (unit -> Internal)\n\ntype TraceBuilder =\nclass\n  new : unit -> TraceBuilder\n  member Bind : m:'a option * f:('a -> 'b option) -> 'b option\n  member Combine : Internal * Delayed -> Internal\n  member Delay : funcToDelay:(unit -> Internal) -> Delayed\n  member Return : x:int -> Internal\n  member ReturnFrom : m:int option -> Internal\n  member Run : Delayed -> int option\n  member Zero : unit -> Internal\nend \n```", "```\ntype SuccessOrError = \n| Success of int\n| Error of string\n\ntype SuccessOrErrorBuilder() =\n\n    member this.Bind(m, f) = \n        match m with\n        | Success s -> f s\n        | Error _ -> m\n\n    /// overloaded to accept ints\n    member this.Return(x:int) = \n        printfn \"Return a success %i\" x\n        Success x\n\n    /// overloaded to accept strings\n    member this.Return(x:string) = \n        printfn \"Return an error %s\" x\n        Error x\n\n// make an instance of the workflow \nlet successOrError = new SuccessOrErrorBuilder() \n```", "```\nsuccessOrError { \n    return 42\n    } |> printfn \"Result for success: %A\" \n// Result for success: Success 42\n\nsuccessOrError { \n    return \"error for step 1\"\n    } |> printfn \"Result for error: %A\" \n//Result for error: Error \"error for step 1\" \n```", "```\ntype SuccessOrError<'a,'b> = \n| Success of 'a\n| Error of 'b \n```", "```\ntype SuccessOrError<'a,'b> = \n| Success of 'a\n| Error of 'b\n\ntype SuccessOrErrorBuilder() =\n\n    member this.Bind(m, f) = \n        match m with\n        | Success s -> \n            try\n                f s\n            with\n            | e -> Error e.Message\n        | Error _ -> m\n\n    member this.Return(x) = \n        Success x\n\n// make an instance of the workflow \nlet successOrError = new SuccessOrErrorBuilder() \n```", "```\nsuccessOrError { \n    return 42\n    } |> printfn \"Result for success: %A\" \n\nsuccessOrError { \n    let! x = Success 1\n    return x/0\n    } |> printfn \"Result for error: %A\" \n```", "```\nmember this.Combine (a,b) = \n    match a,b with\n    | Some a', Some b' ->\n        printfn \"combining %A and %A\" a' b' \n        Some [a';b']\n    | Some a', None ->\n        printfn \"combining %A with None\" a' \n        Some [a']\n    | None, Some b' ->\n        printfn \"combining None with %A\" b' \n        Some [b']\n    | None, None ->\n        printfn \"combining None with None\"\n        None \n```", "```\ntrace { \n    yield 1\n    yield 2\n    } |> printfn \"Result for yield then yield: %A\" \n\n// Result for yield then yield: Some [1; 2] \n```", "```\ntrace { \n    yield 1\n    yield! None\n    } |> printfn \"Result for yield then None: %A\" \n\n// Result for yield then None: Some [1] \n```", "```\ntrace { \n    yield 1\n    yield 2\n    yield 3\n    } |> printfn \"Result for yield x 3: %A\" \n```", "```\nerror FS0001: Type mismatch. Expecting a\n    int option    \nbut given a\n    'a list option    \nThe type 'int' does not match the type ''a list' \n```", "```\n/// combine with a list option\nmember this.Combine (a, listOption) = \n    match a,listOption with\n    | Some a', Some list ->\n        printfn \"combining %A and %A\" a' list \n        Some ([a'] @ list)\n    | Some a', None ->\n        printfn \"combining %A with None\" a'\n        Some [a']\n    | None, Some list ->\n        printfn \"combining None with %A\" list\n        Some list\n    | None, None ->\n        printfn \"combining None with None\"\n        None\n\n/// combine with a non-list option\nmember this.Combine (a,b) = \n    match a,b with\n    | Some a', Some b' ->\n        printfn \"combining %A and %A\" a' b' \n        Some [a';b']\n    | Some a', None ->\n        printfn \"combining %A with None\" a' \n        Some [a']\n    | None, Some b' ->\n        printfn \"combining None with %A\" b' \n        Some [b']\n    | None, None ->\n        printfn \"combining None with None\"\n        None \n```", "```\ntrace { \n    yield 1\n    yield 2\n    yield 3\n    } |> printfn \"Result for yield x 3: %A\" \n\n// Result for yield x 3: Some [1; 2; 3] \n```", "```\ntrace { \n    yield 1\n    yield! None\n    } |> printfn \"Result for yield then None: %A\" \n```", "```\nerror FS0041: A unique overload for method 'Combine' could not be determined based on type information prior to this program point. A type annotation may be needed. \n```", "```\ntrace { \n    yield 1\n    let x:int option = None\n    yield! x\n    } |> printfn \"Result for yield then None: %A\" \n```", "```\ntype TraceBuilder() =\n    member this.Bind(m, f) = \n        match m with \n        | None -> \n            printfn \"Binding with None. Exiting.\"\n        | Some a -> \n            printfn \"Binding with Some(%A). Continuing\" a\n        Option.bind f m\n\n    member this.Zero() = \n        printfn \"Zero\"\n        None\n\n    member this.Yield(x) = \n        printfn \"Yield an unwrapped %A as a list option\" x\n        Some [x]\n\n    member this.YieldFrom(m) = \n        printfn \"Yield an option (%A) directly\" m\n        m\n\n    member this.Combine (a, b) = \n        match a,b with\n        | Some a', Some b' ->\n            printfn \"combining %A and %A\" a' b'\n            Some (a' @ b')\n        | Some a', None ->\n            printfn \"combining %A with None\" a'\n            Some a'\n        | None, Some b' ->\n            printfn \"combining None with %A\" b'\n            Some b'\n        | None, None ->\n            printfn \"combining None with None\"\n            None\n\n    member this.Delay(f) = \n        printfn \"Delay\"\n        f()\n\n// make an instance of the workflow \nlet trace = new TraceBuilder() \n```", "```\ntrace { \n    yield 1\n    yield 2\n    } |> printfn \"Result for yield then yield: %A\" \n\n// Result for yield then yield: Some [1; 2]\n\ntrace { \n    yield 1\n    yield 2\n    yield 3\n    } |> printfn \"Result for yield x 3: %A\" \n\n// Result for yield x 3: Some [1; 2; 3]\n\ntrace { \n    yield 1\n    yield! None\n    } |> printfn \"Result for yield then None: %A\" \n\n// Result for yield then None: Some [1] \n```", "```\ntype ListBuilder() =\n    member this.Bind(m, f) = \n        m |> List.collect f\n\n    member this.Yield(x) = \n        printfn \"Yield an unwrapped %A as a list\" x\n        [x]\n\n    member this.For(m,f) =\n        printfn \"For %A\" m\n        this.Bind(m,f)\n\n    member this.For(m:_ seq,f) =\n        printfn \"For %A using seq\" m\n        let m2 = List.ofSeq m\n        this.Bind(m2,f)\n\n// make an instance of the workflow \nlet listbuilder = new ListBuilder() \n```", "```\nlistbuilder { \n    let list = [1..10]\n    for i in list do yield i\n    } |> printfn \"Result for list: %A\" \n\nlistbuilder { \n    let s = seq {1..10}\n    for i in s do yield i\n    } |> printfn \"Result for seq : %A\" \n```", "```\ntype MaybeBuilder() =\n\n    member this.Bind(m, f) = \n        Option.bind f m\n\n    member this.Return(x) = \n        Some x\n\n    member this.ReturnFrom(x) = \n        x\n\n    member this.Zero() = \n        None\n\n    member this.Combine (a,b) = \n        match a with\n        | Some _ -> a  // if a is good, skip b\n        | None -> b()  // if a is bad, run b\n\n    member this.Delay(f) = \n        f\n\n    member this.Run(f) = \n        f()\n\n// make an instance of the workflow \nlet maybe = new MaybeBuilder() \n```", "```\nmaybe { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    printfn \"Part 2: after return has happened\"\n    } |> printfn \"Result for Part1 but not Part2: %A\" \n\n// result - second part is NOT evaluated \n\nmaybe { \n    printfn \"Part 1: about to return None\"\n    return! None\n    printfn \"Part 2: after None, keep going\"\n    } |> printfn \"Result for Part1 and then Part2: %A\" \n\n// result - second part IS evaluated \n```", "```\nlet childWorkflow = \n    maybe {printfn \"Child workflow\"} \n\nmaybe { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    return! childWorkflow \n    } |> printfn \"Result for Part1 but not childWorkflow: %A\" \n```", "```\ntype Maybe<'a> = Maybe of (unit -> 'a option) \n```", "```\n// before\nmember this.Run(f) = \n    f()\n\n// after \nmember this.Run(f) = \n    Maybe f \n```", "```\nlet run (Maybe f) = f() \n```", "```\nlet m1 = maybe { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    printfn \"Part 2: after return has happened\"\n    } \n```", "```\nval m1 : Maybe<int> = Maybe <fun:m1@123-7> \n```", "```\nrun m1 |> printfn \"Result for Part1 but not Part2: %A\" \n```", "```\nPart 1: about to return 1\nResult for Part1 but not Part2: Some 1 \n```", "```\nlet m2 = maybe { \n    printfn \"Part 1: about to return None\"\n    return! None\n    printfn \"Part 2: after None, keep going\"\n    } \n```", "```\nmember this.ReturnFrom(Maybe f) = \n    f() \n```", "```\nlet m2 = maybe { \n    return! maybe {printfn \"Part 1: about to return None\"}\n    printfn \"Part 2: after None, keep going\"\n    } \n```", "```\nValue restriction. The value 'm2' has been inferred to have generic type \n```", "```\nlet m2_int: Maybe<int> = maybe { \n    return! maybe {printfn \"Part 1: about to return None\"}\n    printfn \"Part 2: after None, keep going;\"\n    } \n```", "```\nlet m2 = maybe { \n    return! maybe {printfn \"Part 1: about to return None\"}\n    printfn \"Part 2: after None, keep going;\"\n    return 1\n    } \n```", "```\nrun m2 |> printfn \"Result for Part1 and then Part2: %A\" \n```", "```\nPart 1: about to return None\nPart 2: after None, keep going;\nResult for Part1 and then Part2: Some 1 \n```", "```\nlet childWorkflow = \n    maybe {printfn \"Child workflow\"} \n\nlet m3 = maybe { \n    printfn \"Part 1: about to return 1\"\n    return 1\n    return! childWorkflow \n    } \n\nrun m3 |> printfn \"Result for Part1 but not childWorkflow: %A\" \n```", "```\nlet m4 = maybe { \n    return! maybe {printfn \"Part 1: about to return None\"}\n    return! childWorkflow \n    } \n\nrun m4 |> printfn \"Result for Part1 and then childWorkflow: %A\" \n```", "```\ntype Maybe<'a> = Maybe of (unit -> 'a option)\n\ntype MaybeBuilder() =\n\n    member this.Bind(m, f) = \n        Option.bind f m\n\n    member this.Return(x) = \n        Some x\n\n    member this.ReturnFrom(Maybe f) = \n        f()\n\n    member this.Zero() = \n        None\n\n    member this.Combine (a,b) = \n        match a with\n        | Some _' -> a    // if a is good, skip b\n        | None -> b()     // if a is bad, run b\n\n    member this.Delay(f) = \n        f\n\n    member this.Run(f) = \n        Maybe f\n\n// make an instance of the workflow \nlet maybe = new MaybeBuilder()\n\nlet run (Maybe f) = f() \n```", "```\nlet child_twice: Maybe<unit> = maybe { \n    let workflow = maybe {printfn \"Child workflow\"} \n\n    return! maybe {printfn \"Part 1: about to return None\"}\n    return! workflow \n    return! workflow \n    } \n\nrun child_twice |> printfn \"Result for childWorkflow twice: %A\" \n```", "```\ntype Maybe<'a> = Maybe of Lazy<'a option>\n\ntype MaybeBuilder() =\n\n    member this.Bind(m, f) = \n        Option.bind f m\n\n    member this.Return(x) = \n        Some x\n\n    member this.ReturnFrom(Maybe f) = \n        f.Force()\n\n    member this.Zero() = \n        None\n\n    member this.Combine (a,b) = \n        match a with\n        | Some _' -> a    // if a is good, skip b\n        | None -> b()     // if a is bad, run b\n\n    member this.Delay(f) = \n        f\n\n    member this.Run(f) = \n        Maybe (lazy f())\n\n// make an instance of the workflow \nlet maybe = new MaybeBuilder()\n\nlet run (Maybe f) = f.Force() \n```", "```\nPart 1: about to return None\nChild workflow\nResult for childWorkflow twice: <null> \n```", "```\nBind(1,fun x -> \n   Bind(2,fun y -> \n     Bind(x + y,fun z -> \n        Return(z)  // or Yield \n```", "```\n// evaluate test function\nlet bool = guard()  \nif not bool \nthen\n    // exit loop\n    return what??\nelse\n    // evaluate the body function\n    body()         \n\n    // back to the top of the while loop \n\n    // evaluate test function again\n    let bool' = guard()  \n    if not bool' \n    then\n        // exit loop\n        return what??\n    else \n        // evaluate the body function again\n        body()         \n\n        // back to the top of the while loop\n\n        // evaluate test function a third time\n        let bool'' = guard()  \n        if not bool'' \n        then\n            // exit loop\n            return what??\n        else\n            // evaluate the body function a third time\n            body()         \n\n            // etc \n```", "```\n// evaluate test function\nlet bool = guard()  \nif not bool \nthen\n    // exit loop\n    return Zero\nelse\n    // evaluate the body function\n    Bind( body(), fun () ->  \n\n        // evaluate test function again\n        let bool' = guard()  \n        if not bool' \n        then\n            // exit loop\n            return Zero\n        else \n            // evaluate the body function again\n            Bind( body(), fun () ->  \n\n                // evaluate test function a third time\n                let bool'' = guard()  \n                if not bool'' \n                then\n                    // exit loop\n                    return Zero\n                else\n                    // evaluate the body function again\n                    Bind( body(), fun () ->  \n\n                    // etc \n```", "```\nmember this.While(guard, body) =\n    // evaluate test function\n    if not (guard()) \n    then \n        // exit loop\n        this.Zero() \n    else\n        // evaluate the body function \n        this.Bind( body(), fun () -> \n            // call recursively\n            this.While(guard, body)) \n```", "```\ntype TraceBuilder() =\n    member this.Bind(m, f) = \n        match m with \n        | None -> \n            printfn \"Binding with None. Exiting.\"\n        | Some a -> \n            printfn \"Binding with Some(%A). Continuing\" a\n        Option.bind f m\n\n    member this.Return(x) = \n        Some x\n\n    member this.ReturnFrom(x) = \n        x\n\n    member this.Zero() = \n        printfn \"Zero\"\n        this.Return ()\n\n    member this.Delay(f) = \n        printfn \"Delay\"\n        f\n\n    member this.Run(f) = \n        f()\n\n    member this.While(guard, body) =\n        printfn \"While: test\"\n        if not (guard()) \n        then \n            printfn \"While: zero\"\n            this.Zero() \n        else\n            printfn \"While: body\"\n            this.Bind( body(), fun () -> \n                this.While(guard, body))  \n\n// make an instance of the workflow \nlet trace = new TraceBuilder() \n```", "```\ntype TraceBuilder =\n    // other members\n    member\n      While : guard:(unit -> bool) * body:(unit -> unit option) -> unit option \n```", "```\nlet mutable i = 1\nlet test() = i < 5\nlet inc() = i <- i + 1\n\nlet m = trace { \n    while test() do\n        printfn \"i is %i\" i\n        inc() \n    } \n```", "```\ntry\n    let wrapped = delayedBody()  \n    wrapped  // return a wrapped value\nwith\n| e -> handlerPart e \n```", "```\nmember this.TryWith(body, handler) =\n    try \n        printfn \"TryWith Body\"\n        this.ReturnFrom(body())\n    with \n        e ->\n            printfn \"TryWith Exception handling\"\n            handler e \n```", "```\ntrace { \n    try\n        failwith \"bang\"\n    with\n    | e -> printfn \"Exception! %s\" e.Message\n    } |> printfn \"Result %A\" \n```", "```\nmember this.TryFinally(body, compensation) =\n    try \n        printfn \"TryFinally Body\"\n        this.ReturnFrom(body())\n    finally \n        printfn \"TryFinally compensation\"\n        compensation() \n```", "```\ntrace { \n    try\n        failwith \"bang\"\n    finally\n        printfn \"ok\" \n    } |> printfn \"Result %A\" \n```", "```\n{| use! value = expr in cexpr |} \n```", "```\nbuilder.Bind(expr, (fun value -> builder.Using(value, (fun value -> {| cexpr |} )))) \n```", "```\nmember this.Using(disposable:#System.IDisposable, body) =\n    let body' = fun () -> body disposable\n    this.TryFinally(body', fun () -> \n        match disposable with \n            | null -> () \n            | disp -> disp.Dispose()) \n```", "```\nlet makeResource name =\n    Some { \n    new System.IDisposable with\n    member this.Dispose() = printfn \"Disposing %s\" name\n    }\n\ntrace { \n    use! x = makeResource \"hello\"\n    printfn \"Disposable in use\"\n    return 1\n    } |> printfn \"Result: %A\" \n```", "```\nmember this.For(sequence:seq<_>, body) =\n       this.Using(sequence.GetEnumerator(),fun enum -> \n            this.While(enum.MoveNext, \n                this.Delay(fun () -> body enum.Current)))\n {% endhighlight fsharp %}\n\nAs you can see, it is quite different from the previous implementation, in order to handle a generic `IEnumerable<_>`.\n\n* We explicitly iterate using an `IEnumerator<_>`.\n* `IEnumerator<_>` implements `IDisposable`, so we wrap the enumerator in a `Using`.\n* We use `While .. MoveNext` to iterate.\n* Next, we pass the `enum.Current` into the body function\n* Finally, we delay the call to the body function using `Delay`\n\n## Complete code without tracing \n\nUp to now, all the builder methods have been made more complex than necessary by the adding of tracing and printing expressions. The tracing is helpful to understand what is going on,\nbut it can obscure the simplicity of the methods.\n\nSo as a final step, let's have a look at the complete code for the \"trace\" builder class, but this time without any extraneous code at all.  Even though the code is cryptic, the purpose and implementation of each method should now be familiar to you.\n\n```"]