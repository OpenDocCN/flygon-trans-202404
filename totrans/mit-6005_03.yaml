- en: 'Reading 3: Testing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章阅读：测试
- en: '**Reading exercises are due the night before class.** You must complete the
    reading exercises in this reading by Sunday, September 11 at 10:00 pm.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**阅读练习需在课前一晚完成。**您必须在 9 月 11 日星期日晚上 10:00 前完成本阅读的阅读练习。'
- en: '[***Basic Java* exercises in the Java Tutor**](../../getting-started/java-tutor/#required)
    are also due Sunday, September 11 at 10:00 pm.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[***基础 Java* 在线教程**](../../getting-started/java-tutor/#required)的练习也需在 9 月
    11 日星期日晚上 10:00 前完成。'
- en: '**Optionally,** complete [the first three levels of Java Tutor exercises](../../getting-started/java-tutor/#optional)
    by Monday, September 12 at 10:00 pm to earn a free slack day on [Problem Set 0](../../psets/ps0/).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**可选地**，在 9 月 12 日星期一晚上 10:00 前完成[Java 在线教程的前三个级别的练习](../../getting-started/java-tutor/#optional)，以赢得[问题集
    0](../../psets/ps0/)的一个免费的 Slack 天。'
- en: Software in 6.005
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 免于错误 | 易于理解 | 可变更 |'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 今天正确且在未知的未来也正确。 | 与未来的程序员（包括未来的你）清晰沟通。 | 设计以适应变化而无需重写。 |'
- en: Objectives for Today’s Class
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 今天课程的目标
- en: 'After today’s class, you should:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的课程之后，您应该：
- en: understand the value of testing, and know the process of test-first programming;
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试的价值，并知道测试优先编程的过程；
- en: be able to design a test suite for a method by partitioning its input and output
    space and choosing good test cases;
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过划分输入和输出空间并选择良好的测试用例为方法设计测试套件；
- en: be able to judge a test suite by measuring its code coverage; and
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过测量其代码覆盖率来判断测试套件；和
- en: understand and know when to use blackbox vs. whitebox testing, unit tests vs.
    integration tests, and automated regression testing.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并知道何时使用黑盒测试与白盒测试，单元测试与集成测试，以及自动化回归测试。
- en: Validation
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: Many readings include optional videos from the MITx version of 6.005\.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多阅读包括来自 MITx 版本 6.005 的可选视频。
- en: '[More info about the videos](../../general/#classes_readings_and_nanoquizzes)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[有关视频的更多信息](../../general/#classes_readings_and_nanoquizzes)'
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,validation/1tgKOH6jYIY)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,validation/1tgKOH6jYIY)'
- en: 'Testing is an example of a more general process called *validation*. The purpose
    of validation is to uncover problems in a program and thereby increase your confidence
    in the program’s correctness. Validation includes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是称为*验证*的更一般的过程的一个例子。验证的目的是发现程序中的问题，从而增加对程序正确性的信心。验证包括：
- en: '**Formal reasoning** about a program, usually called *verification*. Verification
    constructs a formal proof that a program is correct. Verification is tedious to
    do by hand, and automated tool support for verification is still an active area
    of research. Nevertheless, small, crucial pieces of a program may be formally
    verified, such as the scheduler in an operating system, or the bytecode interpreter
    in a virtual machine, or [the filesystem in an operating system](http://www.csail.mit.edu/crash_tolerant_data_storage).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对程序进行形式推理**，通常称为*验证*。验证构建一个正式的证明，证明程序是正确的。手工进行验证是很繁琐的，验证的自动化工具支持仍然是一个活跃的研究领域。尽管如此，程序的小而关键的部分可能会被正式验证，例如操作系统中的调度程序，虚拟机中的字节码解释器，或[操作系统中的文件系统](http://www.csail.mit.edu/crash_tolerant_data_storage)。'
- en: '**Code review.** Having somebody else carefully read your code, and reason
    informally about it, can be a good way to uncover bugs. It’s much like having
    somebody else proofread an essay you have written. We’ll talk more about code
    review in the next reading.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码审查**。让其他人仔细阅读您的代码，并对其进行非正式推理，可以发现错误的好方法。这很像让别人校对你写的文章。我们将在下一次阅读中更多地讨论代码审查。'
- en: '**Testing**. Running the program on carefully selected inputs and checking
    the results.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**。在精心选择的输入上运行程序并检查结果。'
- en: 'Even with the best validation, it’s very hard to achieve perfect quality in
    software. Here are some typical *residual defect rates* (bugs left over after
    the software has shipped) per kloc (one thousand lines of source code):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使进行了最佳的验证，要在软件中达到完美的质量也是非常困难的。以下是一些典型的*剩余缺陷率*（软件发货后剩余的错误）每 kloc（一千行源代码）：
- en: '1 - 10 defects/kloc: Typical industry software.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 - 10 缺陷/千行代码：典型的行业软件。
- en: '0.1 - 1 defects/kloc: High-quality validation. The Java libraries might achieve
    this level of correctness.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.1 - 1 缺陷/千行代码：高质量的验证。Java库可能达到这个正确性水平。
- en: '0.01 - 0.1 defects/kloc: The very best, safety-critical validation. NASA and
    companies like Praxis can achieve this level.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.01 - 0.1每千行代码的缺陷：最佳的、安全关键的验证。NASA和像Praxis这样的公司可以达到这个水平。
- en: This can be discouraging for large systems. For example, if you have shipped
    a million lines of typical industry source code (1 defect/kloc), it means you
    missed 1000 bugs!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型系统而言，这可能是令人泄气的。例如，如果你已经交付了100万行典型行业源代码（每千行代码1个缺陷），这意味着你错过了1000个错误！
- en: Why Software Testing is Hard
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件测试为何如此困难
- en: Here are some approaches that unfortunately don’t work well in the world of
    software.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在软件世界中不起作用的方法。
- en: '**Exhaustive testing** is infeasible. The space of possible test cases is generally
    too big to cover exhaustively. Imagine exhaustively testing a 32-bit floating-point
    multiply operation, `a*b`. There are 2^64 test cases!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**穷举测试** 是不可行的。可能的测试用例空间通常太大而无法穷尽。想象一下穷举测试32位浮点乘法操作`a*b`。有2^64个测试用例！'
- en: '**Haphazard testing** (“just try it and see if it works”) is less likely to
    find bugs, unless the program is so buggy that an arbitrarily-chosen input is
    more likely to fail than to succeed. It also doesn’t increase our confidence in
    program correctness.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**随意测试**（“只是试一试，看看是否有效”）不太可能发现错误，除非程序非常有错误，随意选择的输入更有可能失败而不是成功。它也不会增加我们对程序正确性的信心。'
- en: '**Random or statistical testing** doesn’t work well for software. Other engineering
    disciplines can test small random samples (e.g. 1% of hard drives manufactured)
    and infer the defect rate for the whole production lot. Physical systems can use
    many tricks to speed up time, like opening a refrigerator 1000 times in 24 hours
    instead of 10 years. These tricks give known failure rates (e.g. mean lifetime
    of a hard drive), but they assume continuity or uniformity across the space of
    defects. This is true for physical artifacts.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**随机或统计测试** 在软件领域效果不佳。其他工程学科可以测试小的随机样本（例如制造的硬盘的1%），并推断整个生产批次的缺陷率。物理系统可以使用许多技巧来加快时间，例如在24小时内打开冰箱1000次，而不是10年。这些技巧给出了已知的故障率（例如硬盘的平均寿命），但它们假设缺陷空间上的连续性或均匀性。这对物理制品是成立的。'
- en: But it’s not true for software. Software behavior varies discontinuously and
    discretely across the space of possible inputs. The system may seem to work fine
    across a broad range of inputs, and then abruptly fail at a single boundary point.
    The [famous Pentium division bug](http://www.willamette.edu/~mjaneba/pentprob.html)
    affected approximately 1 in 9 billion divisions. Stack overflows, out of memory
    errors, and numeric overflow bugs tend to happen abruptly, and always in the same
    way, not with probabilistic variation. That’s different from physical systems,
    where there is often visible evidence that the system is approaching a failure
    point (cracks in a bridge) or failures are distributed probabilistically near
    the failure point (so that statistical testing will observe some failures even
    before the point is reached).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '但对于软件来说并非如此。软件行为在可能的输入空间中以不连续和离散的方式变化。系统可能在广泛的输入范围内看起来正常工作，然后在单个边界点突然失败。[著名的奔腾除法错误](http://www.willamette.edu/~mjaneba/pentprob.html)
    影响了大约90亿次除法中的1次。栈溢出、内存不足错误和数值溢出错误往往会突然发生，并且总是以相同的方式发生，而不是以概率变化的方式。这与物理系统不同，物理系统中通常有可见的证据表明系统正在接近故障点（桥梁上的裂缝），或者故障在接近故障点附近概率分布（因此统计测试将观察到一些故障甚至在到达点之前）。 '
- en: Instead, test cases must be chosen carefully and systematically, and that’s
    what we’ll look at next.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，测试用例必须被仔细而系统地选择，这就是我们接下来要看的内容。
- en: reading exercises
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Testing basics
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试基础知识
- en: In the 1990s, the Ariane 5 launch vehicle, designed and built for the European
    Space Agency, self-destructed 37 seconds after its first launch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代，为欧洲空间局设计和建造的阿里安5号运载火箭，在首次发射后的37秒内自我销毁。
- en: The reason was a control software bug that went undetected. The Ariane 5’s guidance
    software was reused from the Ariane 4, which was a slower rocket. When the velocity
    calculation converted from a 64-bit floating point number (a `double` in Java
    terminology, though this software wasn’t written in Java) to a 16-bit signed integer
    (a `short`), it overflowed the small integer and caused an exception to be thrown.
    The exception handler had been disabled for efficiency reasons, so the guidance
    software crashed. Without guidance, the rocket crashed too. The cost of the failure
    was $1 billion.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: What ideas does this story demonstrate?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer) (missing answer)(missing answer)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Putting on Your Testing Hat
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,validation,putting_on_your_testing_hat/Eyl2cUMAneQ)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Testing requires having the right attitude. When you’re coding, your goal is
    to make the program work, but as a tester, you want to **make it fail**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: That’s a subtle but important difference. It is all too tempting to treat code
    you’ve just written as a precious thing, a fragile eggshell, and test it very
    lightly just to see it work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you have to be brutal. A good tester wields a sledgehammer and beats
    the program everywhere it might be vulnerable, so that those vulnerabilities can
    be eliminated.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Test-first Programming
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test early and often. Don’t leave testing until the end, when you have a big
    pile of unvalidated code. Leaving testing until the end only makes debugging longer
    and more painful, because bugs may be anywhere in your code. It’s far more pleasant
    to test your code as you develop it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'In test-first-programming, you write tests before you even write any code.
    The development of a single function proceeds in this order:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Write a specification for the function.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests that exercise the specification.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the actual code. Once your code passes the tests you wrote, you’re done.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **specification** describes the input and output behavior of the function.
    It gives the types of the parameters and any additional constraints on them (e.g.
    `sqrt`’s parameter must be nonnegative). It also gives the type of the return
    value and how the return value relates to the inputs. You’ve already seen and
    used specifications on your problem sets in this class. In code, the specification
    consists of the method signature and the comment above it that describes what
    it does. We’ll have much more to say about specifications a few classes from now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests first is a good way to understand the specification. The specification
    can be buggy, too — incorrect, incomplete, ambiguous, missing corner cases. Trying
    to write tests can uncover these problems early, before you’ve wasted time writing
    an implementation of a buggy spec.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Test Cases by Partitioning
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a good test suite is a challenging and interesting design problem.
    We want to pick a set of test cases that is small enough to run quickly, yet large
    enough to validate the program.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个好的测试套件是一个具有挑战性和有趣的设计问题。我们希望选择一组测试用例，它足够小以便快速运行，但又足够大以验证程序。
- en: '![partitioning a function''s input space](../Images/36e3cefd360ba43bf8cbbe4945137ad4.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![partitioning a function''s input space](../Images/36e3cefd360ba43bf8cbbe4945137ad4.jpg)'
- en: To do this, we divide the input space into **subdomains**, each consisting of
    a set of inputs. Taken together the subdomains completely cover the input space,
    so that every input lies in at least one subdomain. Then we choose one test case
    from each subdomain, and that’s our test suite.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将输入空间划分为 **子域**，每个子域由一组输入组成。这些子域一起完全覆盖了输入空间，以便每个输入至少位于一个子域中。然后我们从每个子域中选择一个测试用例，这就是我们的测试套件。
- en: The idea behind subdomains is to partition the input space into sets of similar
    inputs on which the program has similar behavior. Then we use one representative
    of each set. This approach makes the best use of limited testing resources by
    choosing dissimilar test cases, and forcing the testing to explore parts of the
    input space that random testing might not reach.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 子域背后的思想是将输入空间划分为具有相似行为的类似输入的集合。然后我们使用每个集合的一个代表。通过选择不同的测试用例，这种方法可以最大程度地利用有限的测试资源，并迫使测试探索随机测试可能无法达到的输入空间的部分。
- en: We can also partition the output space into subdomains (similar outputs on which
    the program has similar behavior) if we need to ensure our tests will explore
    different parts of the output space. Most of the time, partitioning the input
    space is sufficient.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要确保我们的测试将探索输出空间的不同部分，我们还可以将输出空间划分为子域（程序在其中具有相似行为的相似输出）。大多数情况下，划分输入空间就足够了。
- en: 'Example: `BigInteger.multiply()`'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 例子：`BigInteger.multiply()`
- en: 'Let’s look at an example. [`BigInteger`](http://docs.oracle.com/javase/8/docs/api/?java/math/BigInteger.html)
    is a class built into the Java library that can represent integers of any size,
    unlike the primitive types `int` and `long` that have only limited ranges. BigInteger
    has a method `multiply` that multiplies two BigInteger values together:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。[`BigInteger`](http://docs.oracle.com/javase/8/docs/api/?java/math/BigInteger.html)
    是 Java 库中内置的一个类，可以表示任意大小的整数，不像原始类型 `int` 和 `long` 只有有限的范围。BigInteger 有一个 `multiply`
    方法，用于将两个 BigInteger 值相乘：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example, here’s how it might be used:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是它可能被使用的方式：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example shows that even though only one parameter is explicitly shown
    in the method’s declaration, `multiply` is actually a function of *two* arguments:
    the object you’re calling the method on (`a` in the example above), and the parameter
    that you’re passing in the parentheses (`b` in this example). In Python, the object
    receiving the method call would be explicitly named as a parameter called `self`
    in the method declaration. In Java, you don’t mention the receiving object in
    the parameters, and it’s called `this` instead of `self`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子显示了即使在方法的声明中只显式显示一个参数，`multiply` 实际上是一个 *两个* 参数的函数：你调用方法的对象（上面的例子中的 `a`），以及你在括号中传递的参数（在这个例子中是
    `b`）。在 Python 中，接收方法调用的对象将在方法声明中明确命名为一个名为 `self` 的参数。在 Java 中，你不在参数中提及接收对象，而是称之为
    `this` 而不是 `self`。
- en: 'So we should think of `multiply` as a function taking two inputs, each of type
    `BigInteger`, and producing one output of type `BigInteger`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们应该将 `multiply` 视为一个接受两个输入的函数，每个输入类型为 `BigInteger`，并生成一个类型为 `BigInteger`
    的输出：
- en: '**`multiply : BigInteger × BigInteger → BigInteger`**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**`multiply : BigInteger × BigInteger → BigInteger`**'
- en: 'So we have a two-dimensional input space, consisting of all the pairs of integers
    (a,b). Now let’s partition it. Thinking about how multiplication works, we might
    start with these partitions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们有一个二维输入空间，由所有整数对 (a,b) 组成。现在让我们将其分割。考虑乘法的工作原理，我们可能从这些分区开始：
- en: a and b are both positive
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a 和 b 都是正数
- en: a and b are both negative
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a 和 b 都是负数
- en: a is positive, b is negative
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a 是正数，b 是负数
- en: a is negative, b is positive
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a 是负数，b 是正数
- en: 'There are also some special cases for multiplication that we should check:
    0, 1, and -1.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些乘法的特殊情况需要检查：0、1 和 -1。
- en: a or b is 0, 1, or -1
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a 或 b 是 0、1 或 -1
- en: Finally, as a suspicious tester trying to find bugs, we might suspect that the
    implementor of BigInteger might try to make it faster by using `int` or `long`
    internally when possible, and only fall back to an expensive general representation
    (like a list of digits) when the value is too big. So we should definitely also
    try integers that are very big, bigger than the biggest `long`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为一个怀疑的测试人员试图找到错误，我们可能怀疑BigInteger的实现者可能会尝试通过在可能的情况下内部使用`int`或`long`来加快速度，并且只有在值太大时才会退回到昂贵的一般表示（比如数字列表）。因此，我们还应该尝试非常大的整数，比最大的`long`还要大。
- en: a or b is small
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a或b很小
- en: the absolute value of a or b is bigger than `Long.MAX_VALUE`, the biggest possible
    primitive integer in Java, which is roughly 2^63.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a或b的绝对值大于`Long.MAX_VALUE`，即Java中最大可能的原始整数，大约为2^63。
- en: 'Let’s bring all these observations together into a straightforward partition
    of the whole `(a,b)` space. We’ll choose `a` and `b` independently from:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些观察结果整合到整个`(a,b)`空间的简单划分中。我们将独立选择`a`和`b`，从以下选取：
- en: '![partitioning multiply()](../Images/585394d0bc7d12b5dae64ababce10bcb.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![划分multiply()](../Images/585394d0bc7d12b5dae64ababce10bcb.jpg)'
- en: '0'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1'
- en: '-1'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '-1'
- en: small positive integer
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小正整数
- en: small negative integer
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小负整数
- en: huge positive integer
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极大正整数
- en: huge negative integer
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极大负整数
- en: So this will produce 7 × 7 = 49 partitions that completely cover the space of
    pairs of integers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这将产生7 × 7 = 49 个完全覆盖整数对空间的划分。
- en: 'To produce the test suite, we would pick an arbitrary pair (a,b) from each
    square of the grid, for example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成测试套件，我们将从网格的每个方格中选择任意一对(a,b)，例如：
- en: (a,b) = (-3, 25) to cover (small negative, small positive)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (a,b) = (-3, 25) 以覆盖 (小负数, 小正数)
- en: (a,b) = (0, 30) to cover (0, small positive)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (a,b) = (0, 30) 以覆盖 (0, 小正数)
- en: (a,b) = (2^100, 1) to cover (large positive, 1)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (a,b) = (2^100, 1) 以覆盖 (大正数, 1)
- en: etc.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等。
- en: The figure at the right shows how the two-dimensional (a,b) space is divided
    by this partition, and the points are test cases that we might choose to completely
    cover the partition.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的图表显示了如何通过这种划分将二维的(a,b)空间划分开来，而点是我们可能选择的测试用例，以完全覆盖划分。
- en: 'Example: `max()`'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 例如：`max()`
- en: 'Let’s look at another example from the Java library: the integer `max()` function,
    found in the [`Math`](http://docs.oracle.com/javase/8/docs/api/java/lang/Math.html)
    class.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Java库中的另一个例子：整数`max()`函数，位于[`Math`](http://docs.oracle.com/javase/8/docs/api/java/lang/Math.html)类中。
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Mathematically, this method is a function of the following type:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，这种方法是以下类型的函数：
- en: '**`max : int × int → int`**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**`max : int × int → int`**'
- en: '![partitioning-max](../Images/8e197e8aea463b6e895e0b71783996be.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![划分最大值](../Images/8e197e8aea463b6e895e0b71783996be.jpg)'
- en: 'From the specification, it makes sense to partition this function as:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，将此函数划分为以下部分是有意义的：
- en: a < b
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a < b
- en: a = b
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a = b
- en: a > b
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a > b
- en: 'Our test suite might then be:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试套件可能是：
- en: (a, b) = (1, 2) to cover a < b
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (a, b) = (1, 2) 以覆盖 a < b
- en: (a, b) = (9, 9) to cover a = b
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (a, b) = (9, 9) 以覆盖 a = b
- en: (a, b) = (-5, -6) to cover a > b
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (a, b) = (-5, -6) 以覆盖 a > b
- en: Include Boundaries in the Partition
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在划分中包含边界
- en: 'Bugs often occur at *boundaries* between subdomains. Some examples:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 错误经常发生在子域之间的*边界*。一些例子：
- en: 0 is a boundary between positive numbers and negative numbers
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0是正数和负数之间的边界
- en: the maximum and minimum values of numeric types, like `int` and `double`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值类型的最大值和最小值，比如`int`和`double`
- en: emptiness (the empty string, empty list, empty array) for collection types
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于集合类型的空值（空字符串，空列表，空数组）
- en: the first and last element of a collection
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合的第一个和最后一个元素
- en: Why do bugs often happen at boundaries? One reason is that programmers often
    make **off-by-one mistakes** (like writing `<=` instead of `<`, or initializing
    a counter to 0 instead of 1). Another is that some boundaries may need to be handled
    as special cases in the code. Another is that boundaries may be places of discontinuity
    in the code’s behavior. When an `int` variable grows beyond its maximum positive
    value, for example, it abruptly becomes a negative number.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么错误经常发生在边界？一个原因是程序员经常犯**差一错误**（比如写`<=`而不是`<`，或者将计数器初始化为0而不是1）。另一个原因是一些边界可能需要在代码中作为特殊情况处理。另一个原因是边界可能是代码行为不连续的地方。例如，当一个`int`变量增长超过其最大正值时，它会突然变成一个负数。
- en: It’s important to include boundaries as subdomains in your partition, so that
    you’re choosing an input from the boundary.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在划分中包含边界作为子域是很重要的，这样你就选择了一个边界输入。
- en: 'Let’s redo **`max : int × int → int`**.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们重新做一下**`max : int × int → int`**。'
- en: 'Partition into:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 划分为：
- en: '*relationship between a and b*'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a和b之间的关系*'
- en: a < b
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a < b
- en: a = b
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a = b
- en: a > b
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a > b
- en: '*value of a*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*a的值*'
- en: a = 0
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a = 0
- en: a < 0
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a < 0
- en: a > 0
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a > 0
- en: a = minimum integer
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a = 最小整数
- en: a = maximum integer
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: a = 最大整数
- en: '*value of b*'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*b的值*'
- en: b = 0
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b = 0
- en: b < 0
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b < 0
- en: b > 0
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b > 0
- en: b = minimum integer
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b = 最小整数
- en: b = maximum integer
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: b = 最大整数
- en: 'Now let’s pick test values that cover all these classes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们选择覆盖所有这些类的测试值：
- en: (1, 2) covers a < b, a > 0, b > 0
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （1，2）覆盖了a < b，a > 0，b > 0
- en: (-1, -3) covers a > b, a < 0, b < 0
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （-1，-3）覆盖了a > b，a < 0，b < 0
- en: (0, 0) covers a = b, a = 0, b = 0
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （0，0）覆盖了a = b，a = 0，b = 0
- en: (Integer.MIN_VALUE, Integer.MAX_VALUE) covers a < b, a = minint, b = maxint
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （Integer.MIN_VALUE，Integer.MAX_VALUE）覆盖了a < b，a = minint，b = maxint
- en: (Integer.MAX_VALUE, Integer.MIN_VALUE) covers a > b, a = maxint, b = minint
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （Integer.MAX_VALUE，Integer.MIN_VALUE）覆盖了a > b，a = maxint，b = minint
- en: Two Extremes for Covering the Partition
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖分区的两个极端
- en: 'After partitioning the input space, we can choose how exhaustive we want the
    test suite to be:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在划分输入空间之后，我们可以选择测试套件的详尽程度：
- en: '**Full Cartesian product**.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整笛卡尔积**。'
- en: Every legal combination of the partition dimensions is covered by one test case.
    This is what we did for the `multiply` example, and it gave us 7 × 7 = 49 test
    cases. For the `max` example that included boundaries, which has three dimensions
    with 3 parts, 5 parts, and 5 parts respectively, it would mean up to 3 × 5 × 5
    = 75 test cases. In practice not all of these combinations are possible, however.
    For example, there’s no way to cover the combination a < b, a=0, b=0, because
    `a` can’t be simultaneously less than zero and equal to zero.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个分区维度的每个合法组合都由一个测试用例覆盖。这就是我们为`multiply`示例所做的，它给我们提供了7 × 7 = 49个测试用例。对于包含边界的`max`示例，它有三个维度，分别为3部分，5部分和5部分，这意味着最多有3
    × 5 × 5 = 75个测试用例。然而，在实践中，并非所有这些组合都是可能的。例如，无法覆盖a < b，a = 0，b = 0的组合，因为`a`不能同时小于零且等于零。
- en: '**Cover each part.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖每个部分。**'
- en: Every part of each dimension is covered by at least one test case, but not necessarily
    every combination. With this approach, the test suite for `max` might be as small
    as 5 test cases if carefully chosen. That’s the approach we took above, which
    allowed us to choose 5 test cases.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个维度的每个部分都至少由一个测试用例覆盖，但不一定是每个组合。采用这种方法，如果精心选择，`max`的测试套件可能只有5个测试用例。这就是我们上面采取的方法，它让我们选择了5个测试用例。
- en: Often we strike some compromise between these two extremes, based on human judgement
    and caution, and influenced by whitebox testing and code coverage tools, which
    we look at next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们在这两个极端之间做出一些妥协，基于人类的判断和谨慎，并受到白盒测试和代码覆盖工具的影响，接下来我们将看到。
- en: reading exercises
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Partitioning
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 分区
- en: 'Consider the following specification:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下规范：
- en: '[PRE3]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Which of the following are reasonable partitions for the `start` parameter?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些是`start`参数的合理分区？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Partitioning a String
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串进行分区
- en: Which of the following are reasonable partitions for the `text` parameter?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些是`text`参数的合理分区？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: Blackbox and Whitebox Testing
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑盒测试和白盒测试
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,blackbox_and_whitebox_testing/bMiw7XGsAyY)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,blackbox_and_whitebox_testing/bMiw7XGsAyY)'
- en: Recall from above that the *specification* is the description of the function’s
    behavior — the types of parameters, type of return value, and constraints and
    relationships between them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面回顾，*规范*是函数行为的描述 - 参数类型，返回值类型以及它们之间的约束和关系。
- en: '**Blackbox testing** means choosing test cases only from the specification,
    not the implementation of the function. That’s what we’ve been doing in our examples
    so far. We partitioned and looked for boundaries in `multiply` and `max` without
    looking at the actual code for these functions.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑盒测试**意味着仅从规范中选择测试用例，而不是从函数的实现中选择。这是我们迄今为止在示例中所做的。我们对`multiply`和`max`进行了分区并寻找了边界，而没有查看这些函数的实际代码。'
- en: '**Whitebox testing** (also called glass box testing) means choosing test cases
    with knowledge of how the function is actually implemented. For example, if the
    implementation selects different algorithms depending on the input, then you should
    partition according to those domains. If the implementation keeps an internal
    cache that remembers the answers to previous inputs, then you should test repeated
    inputs.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**白盒测试**（也称为玻璃盒测试）意味着选择测试用例时要了解函数的实际实现方式。例如，如果实现根据输入选择不同的算法，则应根据这些领域进行划分。如果实现保留内部缓存以记住先前输入的答案，则应测试重复输入。'
- en: When doing whitebox testing, you must take care that your test cases don’t *require*
    specific implementation behavior that isn’t specifically called for by the spec.
    For example, if the spec says “throws an exception if the input is poorly formatted,”
    then your test shouldn’t check *specifically* for a `NullPointerException` just
    because that’s what the current implementation does. The specification in this
    case allows *any* exception to be thrown, so your test case should likewise be
    general to preserve the implementor’s freedom. We’ll have much more to say about
    this in the class on specs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行白盒测试时，必须注意你的测试用例不应*要求*特定的实现行为，而这些行为在规范中并没有明确要求。例如，如果规范说“如果输入格式不良，则抛出异常”，那么你的测试不应该*特别*检查`NullPointerException`，只是因为当前实现是这样做的。在这种情况下，规范允许抛出*任何*异常，因此你的测试用例也应该是通用的，以保留实现者的自由。我们在规范课上会有更多讨论。
- en: reading exercises
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Blackbox and whitebox testing
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒和白盒测试
- en: 'Consider the following function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数：
- en: '[PRE4]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Which of the following test cases are likely to be boundary values produced
    by white box testing?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些测试用例可能是白盒测试产生的边界值？
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Documenting Your Testing Strategy
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录您的测试策略
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,documenting_your_testing_strategy/7osZ0SPaEU8)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,documenting_your_testing_strategy/7osZ0SPaEU8)'
- en: For the example function on the left, on the right is how we can document the
    testing strategy we worked on in the [partitioning exercises above](#two_extremes_for_covering_the_partition).
    The strategy also addresses some boundary values we didn’t consider before.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于左侧的示例函数，在右侧是我们如何记录我们在[上面的划分练习](#two_extremes_for_covering_the_partition)中工作的测试策略。该策略还解决了我们之前没有考虑的一些边界值。
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Document the strategy at the top of the test class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '| 在测试类的顶部记录策略：'
- en: '[PRE6]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Document how each test case was chosen, including white box tests:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 记录每个测试用例是如何选择的，包括白盒测试：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Coverage
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,coverage/kSPlAyLLnFs)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,coverage/kSPlAyLLnFs)'
- en: 'One way to judge a test suite is to ask how thoroughly it exercises the program.
    This notion is called *coverage*. Here are three common kinds of coverage:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 评估测试套件的一种方法是询问它对程序进行了多么彻底的测试。这个概念称为*覆盖*。这里有三种常见的覆盖类型：
- en: '**Statement coverage**: is every statement run by some test case?'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句覆盖**：每个语句是否都被某个测试用例执行？'
- en: '**Branch coverage**: for every `if` or `while` statement in the program, are
    both the true and the false direction taken by some test case?'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支覆盖**：程序中每个`if`或`while`语句是否都被某个测试用例执行了真和假两个方向？'
- en: '**Path coverage**: is every possible combination of branches — every path through
    the program — taken by some test case?'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径覆盖**：程序中每个分支的每个可能组合——程序中的每个路径是否都被某个测试用例执行？'
- en: Branch coverage is stronger (requires more tests to achieve) than statement
    coverage, and path coverage is stronger than branch coverage. In industry, 100%
    statement coverage is a common goal, but even that is rarely achieved due to unreachable
    defensive code (like “should never get here” assertions). 100% branch coverage
    is highly desirable, and safety critical industry code has even more arduous criteria
    (e.g., “MCDC,” modified decision/condition coverage). Unfortunately 100% path
    coverage is infeasible, requiring exponential-size test suites to achieve.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 分支覆盖比语句覆盖更强（需要更多的测试来实现），路径覆盖比分支覆盖更强。在工业界，100%语句覆盖是一个常见目标，但由于无法到达的防御性代码（如“不应该到达这里”的断言），即使很少实现。100%分支覆盖是非常理想的，安全关键行业代码甚至有更艰巨的标准（例如，“MCDC”，修改的决策/条件覆盖）。不幸的是，100%路径覆盖是不可行的，需要指数大小的测试套件才能实现。
- en: 'A standard approach to testing is to add tests until the test suite achieves
    adequate statement coverage: i.e., so that every reachable statement in the program
    is executed by at least one test case. In practice, statement coverage is usually
    measured by a code coverage tool, which counts the number of times each statement
    is run by your test suite. With such a tool, white box testing is easy; you just
    measure the coverage of your black box tests, and add more test cases until all
    important statements are logged as executed.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[![EclEmma code coverage tool for Eclipse](../Images/175816548385f82690792f60f2c4ed1e.jpg)](figures/eclemma.png)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: A good code coverage tool for Eclipse is [EclEmma](http://www.eclemma.org/),
    shown on the right.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Lines that have been executed by the test suite are colored green, and lines
    not yet covered are red. If you saw this result from your coverage tool, your
    next step would be to come up with a test case that causes the body of the while
    loop to execute, and add it to your test suite so that the red lines become green.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using a coverage tool
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[Install EclEmma](http://www.eclemma.org/installation.html) in Eclipse on your
    laptop. Use your laptop, because you’ll need it for testing exercises in class,
    too.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Then create a new Java class called `Hailstone.java` (you can make a new project
    for it, or just put it in the project from class 2 exercises) containing this
    code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run this class with EclEmma code coverage highlighting turned on, by choosing
    Run → Coverage As → Java Application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: By changing the initial value of `n`, you can observe how EclEmma highlights
    different lines of code differently.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>green</option>,<option>yellow</option>,<option>red</option>,<option>white</option></select>(missing
    answer)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>green</option>,<option>yellow</option>,<option>red</option>,<option>white</option></select>(missing
    answer)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing and Stubs
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,unit_testing_and_stubs/wBLK4DFKCFM)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: A well-tested program will have tests for every individual module (where a module
    is a method or a class) that it contains. A test that tests an individual module,
    in isolation if possible, is called a **unit test**. Testing modules in isolation
    leads to much easier debugging. When a unit test for a module fails, you can be
    more confident that the bug is found in that module, rather than anywhere in the
    program.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of a unit test is an **integration test**, which tests a combination
    of modules, or even the entire program. If all you have are integration tests,
    then when a test fails, you have to hunt for the bug. It might be anywhere in
    the program. Integration tests are still important, because a program can fail
    at the connections between modules. For example, one module may be expecting different
    inputs than it’s actually getting from another module. But if you have a thorough
    set of unit tests that give you confidence in the correctness of individual modules,
    then you’ll have much less searching to do to find the bug.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you’re building a web search engine. Two of your modules might be `getWebPage()`,
    which downloads web pages, and `extractWords()`, which splits a page into its
    component words:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These methods might be used by another module `makeIndex()` as part of the
    web crawler that makes the search engine’s index:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our test suite, we would want:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: unit tests just for `getWebPage()` that test it on various URLs
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unit tests just for `extractWords()` that test it on various strings
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unit tests for `makeIndex()` that test it on various sets of URLs
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One mistake that programmers sometimes make is writing test cases for `extractWords()`
    in such a way that the test cases depend on `getWebPage()` to be correct. It’s
    better to think about and test `extractWords()` in isolation, and partition it.
    Using test partitions that involve web page content might be reasonable, because
    that’s how `extractWords()` is actually used in the program. But don’t actually
    call `getWebPage()` from the test case, because `getWebPage()` may be buggy! Instead,
    store web page content as a literal string, and pass it directly to `extractWords()`.
    That way you’re writing an isolated unit test, and if it fails, you can be more
    confident that the bug is in the module it’s actually testing, `extractWords()`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Note that the unit tests for `makeIndex()` can’t easily be isolated in this
    way. When a test case calls `makeIndex()`, it is testing the correctness of not
    only the code inside `makeIndex()`, but also all the methods called by `makeIndex()`.
    If the test fails, the bug might be in any of those methods. That’s why we want
    separate tests for `getWebPage()` and `extractWords()`, to increase our confidence
    in those modules individually and localize the problem to the `makeIndex()` code
    that connects them together.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Isolating a higher-level module like `makeIndex()` is possible if we write **stub**
    versions of the modules that it calls. For example, a stub for `getWebPage()`
    wouldn’t access the internet at all, but instead would return mock web page content
    no matter what URL was passed to it. A stub for a class is often called a [**mock
    object**](http://en.wikipedia.org/wiki/Mock_object). Stubs are an important technique
    when building large systems, but we will generally not use them in 6.005.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Automated Testing and Regression Testing
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_3_testing,automated_testing_and_regression_testing/D-EwMsS4_JA)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing makes tests easier to run, and more likely to be run, than complete
    automation. **Automated testing** means running the tests and checking their results
    automatically. A test driver should not be an interactive program that prompts
    you for inputs and prints out results for you to manually check. Instead, a test
    driver should invoke the module itself on fixed test cases and automatically check
    that the results are correct. The result of the test driver should be either “all
    tests OK” or “these tests failed: …” A good testing framework, like JUnit, helps
    you build automated test suites.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Note that automated testing frameworks like JUnit make it easy to run the tests,
    but you still have to come up with good test cases yourself. *Automatic test generation*
    is a hard problem, still a subject of active computer science research.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Once you have test automation, it’s very important to rerun your tests when
    you modify your code. This prevents your program from *regressing* — introducing
    other bugs when you fix new bugs or add new features. Running all your tests after
    every change is called **regression testing**.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you find and fix a bug, take the input that elicited the bug and add
    it to your automated test suite as a test case. This kind of test case is called
    a *regression test*. This helps to populate your test suite with good test cases.
    Remember that a test is good if it elicits a bug — and every regression test did
    in one version of your code! Saving regression tests also protects against reversions
    that reintroduce the bug. The bug may be an easy error to make, since it happened
    once already.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: This idea also leads to *test-first debugging*. When a bug arises, immediately
    write a test case for it that elicits it, and immediately add it to your test
    suite. Once you find and fix the bug, all your test cases will be passing, and
    you’ll be done with debugging and have a regression test for that bug.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In practice, these two ideas, automated testing and regression testing, are
    almost always used in combination.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Regression testing is only practical if the tests can be run often, automatically.
    Conversely, if you already have automated testing in place for your project, then
    you might as well use it to prevent regressions. So **automated regression testing**
    is a best-practice of modern software engineering.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Regression testing
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following best defines regression testing?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer) (missing answer) (missing answer) (missing answer)Running automated
    tests
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following are good times to rerun all your JUnit tests?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Testing techniques
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Which of these techniques are useful for choosing test cases in test-first programming,
    before any code is written?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this reading, we saw these ideas:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Test-first programming. Write tests before you write code.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partitioning and boundaries for choosing test cases systematically.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: White box testing and statement coverage for filling out a test suite.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit-testing each module, in isolation as much as possible.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated regression testing to keep bugs from coming back.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The topics of today’s reading connect to our three key properties of good software
    as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs.** Testing is about finding bugs in your code, and test-first
    programming is about finding them as early as possible, immediately after you
    introduced them.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand.** Testing doesn’t help with this as much as code review
    does.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change.** Readiness for change was considered by writing tests
    that only depend on behavior in the spec. We also talked about automated regression
    testing, which helps keep bugs from coming back when changes are made to code.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: An exercise for the reader
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point you should have completed all the reading exercises above.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Completing the reading exercises prepares you for the *nanoquiz* at the beginning
    of each class meeting, and submitting the exercises is required by 10pm the evening
    before class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
