["```\nloop :: Bool loop = loop wtf :: Bool wtf = undefined crash :: Bool crash = error \"fnord\"\n```", "```\ndata Bool = False | True\n```", "```\ndata Ordering = LT | EQ | GT\n```", "```\ndata Empty\n```", "```\ndata Empty\n```", "```\ndata One = One\n```", "```\ndata Bool = False | True\n```", "```\ndata Ordering = LT | EQ | GT data Bool = False | True\n```", "```\ndata A = A Bool | B Ordering\n```", "```\n(a,b)\n```", "```\ndata Either a b = Left a | Right b\n```", "```\n(a,b,c) data Product a b c = Product a b c\n```", "```\ndata Sum a b c = A a | B b | C c\n```", "```\ndata OutlierEffect = Unaffected -- ^ Less than 1% effect. | Slight -- ^ Between 1% and 10%. | Moderate -- ^ Between 10% and 50%. | Severe -- ^ Above 50% (i.e. measurements -- are useless).\n```", "```\ndata OutlierVariance = OutlierVariance {  ovEffect :: OutlierEffect , ovDescription :: String , ovFraction :: Double }\n```", "```\ndata SampleAnalysis = SampleAnalysis {  anMean :: [Double] , anStdDev :: [Double] , anOutlierVar :: OutlierVariance }\n```", "```\ndata Payload = Payload {  sample :: [Double] , sampleAnalysis :: SampleAnalysis , outliers :: Outliers }\n```", "```\neffect :: Payload -> OutlierEffect effect = ovEffect . anOutlierVar . sampleAnalysis\n```", "```\neditEffect :: (OutlierEffect -> OutlierEffect) -> Payload -> Payload editEffect eff payload = payload { sampleAnalysis = analysis { anOutlierVar = variance { ovEffect = eff effect } } } where analysis = sampleAnalysis payload variance = anOutlierVar analysis effect = ovEffect variance\n```", "```\nsetAddrZip :: Zip -> Address -> Address setAddrZip zip addr = addr { addrZip = zip }\n```", "```\n(a,b)\n```", "```\neditSnd :: (b -> c) -> (a,b) -> (a,c) editSnd f (a,b) = (a, f b)\n```", "```\neditFst :: (a -> c) -> (a,b) -> (c,b) editFst f (a,b) = (f a, b)\n```", "```\neditSnd :: (b -> c) -> (a,b) -> (a,c) editSnd f (a,b) = (a, f b)\n```", "```\neditFst :: (a -> c) -> (a,b) -> (c,b) editFst f (a,b) = (f a, b)\n```", "```\ndata Hole3 a b c = AHole b c | BHole a c | CHole a b\n```", "```\ndata Hole3 a b c = AHole b c | BHole a c | CHole a b\n```", "```\ndata Hole3 x x x = AHole x x | BHole x x | CHole x x\n```", "```\ndata PairHole a b = HoleFst b | HoleSnd a\n```", "```\ndata PairZipper a b c = PZ c (PairHole a b)\n```", "```\ndata PairHole a b = HoleFst b | HoleSnd a data PairZipper a b c = PZ c (PairHole a b) focusFst :: (a,b) -> PairZipper a b a focusFst = undefined focusSnd :: (a,b) -> PairZipper a b b focusSnd = undefined\n```", "```\ndata PairHole a b = HoleFst b | HoleSnd a data PairZipper a b c = PZ c (PairHole a b) focusFst :: (a,b) -> PairZipper a b a focusFst (a,b) = PZ a (HoleFst b) focusSnd :: (a,b) -> PairZipper a b b focusSnd (a,b) = PZ b (HoleSnd a)\n```", "```\nunfocusFst :: PairZipper a b a -> (a,b) unfocusFst (PZ a (HoleFst b)) = (a,b) unfocusSnd :: PairZipper a b b -> (a,b) unfocusSnd (PZ b (HoleSnd a)) = (a,b)\n```", "```\nview :: PairZipper a b c -> c view (PZ c _) = c\n```", "```\n>>> view (focusFst (\"hello\",1)) \"hello\" >>> view (focusSnd (\"hello\",1)) 1\n```", "```\nover :: (c -> c) -> PairZipper a b c -> PairZipper a b c over f (PZ c l) = PZ (f c) l\n```", "```\n>>> unfocusSnd . over succ . focusSnd $ (\"hello\",1::Int) (\"hello\",2)\n```", "```\n>>> unfocusFst . over length . focusFst $ (\"hello\",1::Int)\n```", "```\n>>> unfocusFst . over length . focusFst $ (\"hello\",1::Int)\n```", "```\nover :: (c -> c) -> PairZipper a b c -> PairZipper a b c over f (PZ c l) = PZ (f c) l\n```", "```\nover :: (c -> d) -> PairZipper a b c -> PairZipper a b d over f (PZ c l) = PZ (f c) l\n```", "```\ndata Focused t a b = Focused {  focused :: a , rebuild :: b -> t }\n```", "```\ntype Focuser s t a b = s -> Focused t a b\n```", "```\n>>> unfocusFst . over length . focusFst $ (\"hello\",1::Int)\n```", "```\ndata Focused t a b = Focused {  focused :: a , rebuild :: b -> t }\n```", "```\ntype Focuser s t a b = s -> Focused t a b\n```", "```\nunfocus :: Focused s a a -> s unfocus (Focused focused rebuild) = rebuild focused view :: Focuser s t a b -> s -> a view l s = focused (l s) over :: Focuser s t a b -> (a -> b) -> s -> t over l f s = let Focused focused rebuild = l s in rebuild (f focused)\n```", "```\n_1 :: Focuser (a,b) (c,b) a c _1 (a,b) = Focused a (\\c -> (c,b)) _2 :: Focuser (a,b) (a,c) b c _2 (a,b) = Focused b (\\c -> (a,c))\n```", "```\ndata Focused t a b = Focused {  focused :: a , rebuild :: b -> t } type Focuser s t a b = s -> Focused t a b\n```", "```\nfocusHead :: Focuser [a] [a] a a focusHead = undefined\n```", "```\n>>> over focusHead toUpper \"anita\" \"Anita\"\n```", "```\nover :: Focuser s t a b -> (a -> b) -> s -> t view :: Focuser s t a b -> s -> a\n```", "```\nwat :: Focuser s t a b -> (a -> f b) -> s -> f t\n```", "```\nwat :: Focuser s t a b -> (a -> f b) -> s -> f t\n```", "```\nwat :: Focuser s t a b -> (a -> f b) -> s -> f t over :: Focuser s t a b -> (a -> b) -> s -> t\n```", "```\nwat :: Focuser s t a b -> (a -> f b) -> s -> f t view :: Focuser s t a b {- ignored -} -> s -> a\n```", "```\nnewtype Identity a = Identity { runIdentity :: a } instance Functor Identity where fmap f (Identity a) = Identity (f a)\n```", "```\nnewtype Const a b = Const { getConst :: a } instance Functor (Const a) where fmap _ (Const v) = Const v\n```", "```\n{-# LANGUAGE RankNTypes #-} type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t\n```", "```\n{-# LANGUAGE RankNTypes #-} type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t\n```", "```\n{-# LANGUAGE RankNTypes #-} import Control.Applicative import Data.Functor.Identity type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t over :: Lens s t a b -> (a -> b) -> s -> t over l f s = runIdentity (l (Identity . f) s) view :: Lens s t a b -> s -> a view l s = getConst (l Const s)\n```", "```\n{-# LANGUAGE TupleSections #-}\n```", "```\n(a,)\n```", "```\n\\b -> (a,b)\n```", "```\n{-# LANGUAGE TupleSections #-} _1 :: Lens (a,b) (c,b) a c _1 f (a,b) = (,b) <$> f a _2 :: Lens (a,b) (a,c) b c _2 f (a,b) = (a,) <$> f b _head :: Lens [a] [a] a a _head f (a:as) = (:as) <$> f a\n```", "```\n>>> view (_1 . _head) (\"foo\",True) 'f'\n```", "```\n>>> (head . fst) (\"foo\",True) 'f'\n```", "```\n(\"anita\", True)\n```", "```\n_1 :: Functor f => (a -> f c) -> (a, b) -> f (c, b) _head :: Functor f => (a -> f a) -> [a] -> f [a]\n```", "```\n_1 :: Functor f => (a -> f c) -> ((a, b) -> f (c, b)) _head :: Functor f => (a -> f a) -> ([a] -> f [a]) _1._head :: Functor f => (a -> f a) -> ([a], b) -> f ([a], b)\n```", "```\nfoo & someField %~ ('a':) & otherField .~ 'b'\n```"]