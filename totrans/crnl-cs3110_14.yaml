- en: 'Lecture 10: Functors'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous lecture we considered abstraction and modular design, primarily
    through the use of the `module` mechanism in OCaml. Today we will consider another
    means of abstraction called *functors*, a construct that enables modules to be
    combined by parameterizing a module in terms of other modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `SET` data abstraction that we have looked at during the past
    few classes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this interface uses polymorphism to enable sets with different types of
    elements to be created, any implementation of this signature needs to use the
    built-in `=` function in testing whether an element is a member of such a set.
    Thus we cannot for example have a set of strings where comparison of the elements
    is done in a case-insensitive manner, or a set of integers where elements are
    considered equal when their magnitudes (absolute values) are equal. We could write
    two separate signatures, one for sets with string elements and one for sets with
    integer elements, and then in the implementation of each signature use an appropriate
    comparison function. However this would yield a lot of nearly duplicated code,
    both in the signatures and in the implementation. Such nearly duplicated code
    is more work to write and maintain and more importantly is often a source of bugs
    when things are changed in one place and not another.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'A *functor* is a mapping from modules to modules. It allows the construction
    of a module parameterized by one or more other modules. Functors allow us to create
    a set module that is parameterized by another module that does the equality testing,
    thereby allowing the same code to be used for different equality tests. To make
    this concrete, we will consider an example using the following signatures:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The signature `EQUAL` describes the input type for the functor. To implement
    `EQUAL`, a module need only specify a type `t` and a comparison function `equal
    : t -> t -> bool`, but these can be anything.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The signature `SETFUNCTOR` describes the type of the functor. This differs from
    the `SET` interface in several respects. First, the keyword `functor` indicates
    that it is a functor accepting a parameter, which in this case is any module of
    type `EQUAL`. Note how the syntax is reminiscent of the notation for functions.
    The parameter is referenced by the name `Equal` in the body of `SETFUNCTOR`, but
    that does not have to be its actual name.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The body of `SETFUNCTOR` describes the type of the module that will be produced.
    In the body, instead of the polymorphic `'a` of `SET`, the type of the elements
    is named `elt` and is defined to be the same as the type `t` of the module `Equal`,
    whatever that is. There is also a fixed but unspecified type `set`, along with
    some set operations of the appropriate types, specified in terms of `elt` and
    `set`. (We have omitted a few of the operations for simplicity of the presentation,
    although they could easily be added back in.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to define a functor implementing the `SETFUNCTOR` signature.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, the header
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: indicates that we are defining an implementation named `MakeSet` of the functor
    type `SETFUNCTOR`. The second line
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: indicates that we are defining a functor with parameter `Equal` of type `EQUAL`.
    Again, the module implementing `EQUAL` is referenced by the name `Equal` in the
    body of `MakeSet`, but that does not have to be its actual name. In general there
    can be any number of parameter modules, each of which must be specified with a
    name and signature. Note that these parameters can only be modules, including
    other parameterized modules—they cannot be first-class objects of the language
    such as functions or other types.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the body of `MakeSet` between `struct` and `end` describes the implementation
    of the output module. This module must satisfy the signature described in the
    body of `SETFUNCTOR`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The body of `MakeSet` is like the body of any other module. In this example
    the `open` directive is used so that the names `t` and `equal` can be used without
    qualifying them as `Equal.t` and `Equal.equal`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worth noting the partial evaluation of both `equal` and `List.exists`
    in:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To write it out in full, we might have written
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: but the shorter version is equivalent. In both cases, we are using the fact
    that `fun z -> f z` is equivalent to just `f`. For example, both `fun y -> equal
    x y` and `equal x` are functions that test whether a given element is equal to
    the value of `x`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Now we show how to create modules using the functor `MakeSet`. To do this, we
    need an implementation of the `EQUAL` signature. Say, for example, we want to
    test equality of strings in a case-independent fashion. Here is a module that
    does this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can use `MakeSet` to create a string set module with case-insensitive
    equality by applying it to `StringNoCase`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Evaluating this expression, the interpreter prints out:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That is, the `SSet` module defines the types `set` and `elt` and the function
    `mem`, `add`, and `size`, but the actual implementation is hidden.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use this set abstraction to create and manipulate sets of strings
    with case-insensitive comparison.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After doing this, creating a module for sets of integers using absolute value
    comparison involves almost no additional code. We only need to create another
    module implementing `EQUAL` and use it as the parameter to `MakeSet`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can use this set abstraction to create and manipulate sets of integers
    with absolute value comparison:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Caveats
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few subtleties with functors that are worth mentioning. First, note
    that we did not specify the signature `EQUAL` when we defined `StringNoCase`.
    We might have written
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'but this would have been a bad idea:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The issue here is that the signature `EQUAL` does not expose the type definition
    `type t = string` in the implementation `StringNoCase`, so the functor is not
    free to use that information. It may only deal with the module `StringNoCase`
    through its signature. This is consistent with the principle of information hiding
    through the use of signatures. Thus the module that is produced does not know
    that `StringNoCase.t` is really `string`. But if we omit the `EQUAL`, then the
    signature of `StringNoCase` is inferred from the implementation:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是签名`EQUAL`没有在实现`StringNoCase`中暴露类型定义`type t = string`，因此functor不能自由地使用该信息。它只能通过其签名处理模块`StringNoCase`。这与通过使用签名隐藏信息的原则一致。因此，生成的模块不知道`StringNoCase.t`实际上是`string`。但是如果我们省略了`EQUAL`，则`StringNoCase`的签名将从实现中推断出：
- en: '[PRE16]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (formatting inserted by hand for clarity). You can see that here the type definition
    `type t = string` is exposed, and the functor may now use that information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: （为了清晰起见手动插入格式）。你可以看到这里暴露了类型定义`type t = string`，而functor现在可以使用该信息。
- en: Contravariance
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆变
- en: Another good reason for not specifying the signature is that modules can implement
    lots of different signatures and can be used in different ways. For example, if
    we had defined
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不指定签名的好理由是模块可以实现许多不同的签名，并且可以以不同的方式使用。例如，如果我们定义了
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: then `StringNoCase` implements not only `EQUAL`, but also `Map.OrderedType`
    and `Set.OrderedType` from the OCaml library, so it can also be used as an argument
    to `Map.Make` and `Set.Make`. If we had specified `EQUAL`, then we would have
    precluded those uses.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`StringNoCase`不仅实现了`EQUAL`，还实现了OCaml库中的`Map.OrderedType`和`Set.OrderedType`，因此它也可以作为`Map.Make`和`Set.Make`的参数使用。如果我们指定了`EQUAL`，那么我们将排除这些用途。
- en: 'We can always restrict it if we like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们总是可以加以限制：
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The modules `StringNoCaseEq` and `StringNoCase` have the same implementation,
    but their signatures are different. This is very much like a type upcast in Java.
    It is an *upcast* because it is going from a more specific specification (fewer
    instances) to a more general specification (more instances), which means it can
    be used as the argument to fewer functors. This inverse relationship is known
    as *contravariance*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 模块`StringNoCaseEq`和`StringNoCase`具有相同的实现，但它们的签名不同。这非常类似于Java中的类型上转型。它是一个*上转型*，因为它从更具体的规范（更少的实例）转向更一般的规范（更多的实例），这意味着它可以作为较少functor的参数。这种反向关系称为*逆变*。
- en: '...with type...'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …带有类型…
- en: For clarity, we may wish to define the result signature of a functor independently
    from the signature of the functor itself. So instead of the definition of `SETFUNCTOR`
    as given above, we may wish to write something like
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们可能希望独立于functor本身的签名定义functor的结果签名。因此，与上述`SETFUNCTOR`的定义相反，我们可能希望编写类似于以下内容的内容
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The difficulty here is that we need a way to equate the type `elt` of `SET`
    with `Equal.t`. We could do that in the previous definition of `SETFUNCTOR` by
    writing `type elt = Equal.t` in the body, but here there is no parameter module
    `Equal` around when we define `SET`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的困难在于我们需要一种方法将`SET`的类型`elt`与`Equal.t`相等。我们可以在先前的`SETFUNCTOR`定义中通过在主体中编写`type
    elt = Equal.t`来实现，但是在这里当我们定义`SET`时，周围没有参数模块`Equal`。
- en: To handle this, OCaml allows you to write
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，OCaml允许您写
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now it can link up the two types:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它可以链接起这两种类型：
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
