- en: 暗黙的な型変換
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/implicit-coercion/](https://jsprimer.net/basic/implicit-coercion/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: この章では、明示的な型変換と暗黙的な型変換について学んでいきます。
  prefs: []
  type: TYPE_NORMAL
- en: 「[演算子](../operator/ "演算子について解説した章")」の章にて、 等価演算子（`==`）ではなく厳密等価演算子（`===`）の利用を推奨していました。
    これは厳密等価演算子（`===`）が**暗黙的な型変換**をせずに、値同士を比較できるためです。
  prefs: []
  type: TYPE_NORMAL
- en: 厳密等価演算子（`===`）では異なるデータ型を比較した場合に、その比較結果は必ず`false`となります。 次のコードは、数値の`1`と文字列の`"1"`という異なるデータ型を比較しているので、結果は`false`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: しかし、等価演算子（`==`）では異なるデータ型を比較した場合に、同じ型となるように**暗黙的な型変換**をしてから比較します。 次のコードでは、数値の`1`と文字列の`"1"`の比較結果が`true`となっています。
    これは、等価演算子（`==`）は右辺の文字列`"1"`を数値の`1`へと暗黙的な型変換をしてから、比較するためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: このように、暗黙的な型変換によって意図しない結果となるため、比較には厳密等価演算子（`===`）を使うべきです。
  prefs: []
  type: TYPE_NORMAL
- en: 別の暗黙的な型変換の例として、数値と真偽値の加算を見てみましょう。 多くの言語では、数値と真偽値の加算のような異なるデータ型同士の加算はエラーとなります。
    しかし、JavaScriptでは暗黙的な型変換が行われてから加算されるため、エラーなく処理されます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、真偽値の`true`が数値の`1`へと暗黙的に変換されてから加算処理が行われます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: JavaScriptでは、エラーが発生するのではなく、暗黙的な型変換が行われてしまうケースが多くあります。 暗黙的に変換が行われた場合、プログラムは例外を投げずに処理が進むため、バグの発見が難しくなります。
    このように、暗黙的な型変換はできる限り避けるべき挙動です。
  prefs: []
  type: TYPE_NORMAL
- en: この章では、次のことについて学んでいきます。
  prefs: []
  type: TYPE_NORMAL
- en: 暗黙的な型変換とはどのようなものなのか
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 暗黙的ではない明示的な型変換の方法
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 明示的な変換だけでは解決しないこと
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](#what-is-implicit-coercion)*暗黙的な型変換とは*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*暗黙的な型変換とは次のことを言います。'
  prefs: []
  type: TYPE_NORMAL
- en: ある処理において、その処理過程で行われる明示的ではない型変換のこと
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 暗黙的な型変換は、演算子による演算や関数の処理過程で行われます。 ここでは、演算子における暗黙的な型変換を中心に見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#implicit-coercion-of-equal-operator)*等価演算子の暗黙的な型変換*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*もっとも有名な暗黙的な型変換は、先ほども出てきた等価演算子（`==`）です。 等価演算子は、オペランド同士が同じ型となるように暗黙的な型変換をしてから、比較します。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のように等価演算子（`==`）による比較は、驚くような結果を作り出します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: このほかにも等価演算子による予想できない結果は、比較する値と型の組み合わせの数だけあります。 そのため、等価演算子の比較結果がどうなるかを覚えるのは現実的でありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[![等価演算子による比較結果をまとめた表。緑はtrueとなる組み合わせ](../Images/967e7f39a61e664fa362c1906da0384c.png)](https://dorey.github.io/JavaScript-Equality-Table/)'
  prefs: []
  type: TYPE_NORMAL
- en: しかし、等価演算子の暗黙的な型変換を避ける簡単な方法があります。
  prefs: []
  type: TYPE_NORMAL
- en: それは、常に厳密等価演算子（`===`）を使うことです。 値を比較する際は、常に厳密等価演算子を使うことで、暗黙的な型変換をせずに値を比較できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 厳密等価演算子（`===`）を使うことで、意図しない比較結果を避けることができます。 そのため、比較には等価演算子（`==`）ではなく厳密等価演算子（`===`）を使うことを推奨します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#various-implicit-coercion)*さまざまな暗黙的な型変換*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*他の演算子についても、具体的な例を見てみましょう。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、数値の`1`と文字列の`"2"`をプラス演算子で処理しています。 プラス演算子（`+`）は、数値の加算と文字列の結合を両方実行できるように多重定義されています。
    このケースでは、JavaScriptは文字列の結合を優先する仕様となっています。 そのため、数値の`1`を文字列の`"1"`へ暗黙的に変換してから、文字列結合します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: もうひとつ、数値と文字列での暗黙的な型変換を見てみましょう。 次のコードでは、数値の`1`から文字列の`"2"`を減算しています。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptには、文字列に対するマイナス演算子（`-`）の定義はありません。 そのため、マイナス演算子の対象となる数値への暗黙的な型変換が行われます。
    これにより、文字列の`"2"`を数値の`2`へ暗黙的に変換してから、減算します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 2つの値までは、まだ結果の型を予想できます。 しかし、3つ以上の値を扱う場合に結果を予測するのが難しくなります。
  prefs: []
  type: TYPE_NORMAL
- en: 次のように3つ以上の値を`+`演算子で演算する場合に、値の型が混ざっていると、 演算する順番によっても結果が異なります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: このように、処理の過程でオペランドの型によって、 自動的に変換されることを**暗黙的な型変換**と呼んでいます。
  prefs: []
  type: TYPE_NORMAL
- en: 暗黙的な型変換では、結果の値の型はオペランドの型に依存しています。 それを避けるには、暗黙的ではない変換 ーー つまり明示的な型変換をする必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#explicit-coercion)*明示的な型変換*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*プリミティブ型へ明示的な型変換をする方法を見ていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#any-to-boolean)*任意の値 → 真偽値*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptでは`Boolean`コンストラクタ関数を使うことで、任意の値を`true`または`false`の真偽値に変換できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: JavaScriptでは、次の値は`false`へ変換されます。
  prefs: []
  type: TYPE_NORMAL
- en: '`false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NaN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""`（空文字列）'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 暗黙的な型変換によって`false`に変換されるこれらの値をまとめて**falsy**な値と呼びます。 falsyではない値は、`true`へと変換されます。
  prefs: []
  type: TYPE_NORMAL
- en: この変換ルールはif文の条件式の評価と同様です。 次のようにif文に対して、真偽値以外の値を渡したときに、真偽値へと暗黙的に変換されてから判定されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 真偽値については、暗黙的な型変換のルールが少ないため、明示的に変換せずに扱われることも多いです。 しかし、より正確な判定をして真偽値を得るには、次のように厳密等価演算子（`===`）を使って比較します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[](#number-to-string)*数値 → 文字列*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*数値から文字列へ明示的に変換する場合は、`String`コンストラクタ関数を使います。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`String`コンストラクタ関数は、数値以外にもいろいろな値を文字列へと変換できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 上記の結果からもわかるように`String`コンストラクタ関数での明示的な変換は、万能な方法ではありません。 真偽値、数値、文字列、undefined、null、シンボルのプリミティブ型の値に対して変換は見た目どおりの文字列を得ることができます。
  prefs: []
  type: TYPE_NORMAL
- en: 一方、オブジェクトに対しては、あまり意味のある文字列を返しません。 オブジェクトに対しては`String`コンストラクタ関数より適切な方法があるためです。
    配列には`join`メソッド、オブジェクトには`JSON.stringify`メソッドなど、より適切な方法があります。 そのため、`String`コンストラクタ関数での変換は、あくまでプリミティブ型に対してのみに留めるべきです。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#symbol-to-string)*シンボル → 文字列*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*プラス演算子を文字列に利用した場合、文字列の結合を優先します。 「片方が文字列なら、もう片方のオペランドとは関係なく、結果は文字列となるのでは？」と考えるかもしれません。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: しかし、ES2015で追加されたプリミティブ型であるシンボルは暗黙的に型変換できません。 文字列結合演算子をシンボルに対して利用すると例外を投げるようになっています。
    そのため、片方が文字列であるからといってプラス演算子の結果は必ず文字列になるとは限らないことがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、シンボルを文字列結合演算子（`+`）で文字列に変換できないという`TypeError`が発生しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: この問題も`String`コンストラクタ関数を使うことで、シンボルを明示的に文字列化することで解決できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[](#string-to-number)*文字列 → 数値*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*文字列から数値に変換する典型的なケースとしては、ユーザー入力として数字を受け取ることがあげられます。 ユーザー入力は文字列でしか受け取ることができないため、それを数値に変換してから利用する必要があります。'
  prefs: []
  type: TYPE_NORMAL
- en: 文字列から数値へ明示的に変換するには`Number`コンストラクタ関数が利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: また、文字列から数字を取り出して変換する関数として`Number.parseInt`、`Number.parseFloat`も利用できます。 `Number.parseInt`は文字列から整数を取り出し、`Number.parseFloat`は文字列から浮動小数点数を取り出すことができます。
    `Number.parseInt(文字列, 基数)`の第二引数には基数を指定します。 たとえば、文字列をパースして10進数として数値を取り出したい場合は、第二引数に基数として`10`を指定します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: しかし、ユーザーが数字を入力するとは限りません。 `Number`コンストラクタ関数、`Number.parseInt`、`Number.parseFloat`は、
    数字以外の文字列を渡すと`NaN`（Not a Number）を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: そのため、任意の値から数値へ変換した場合には、`NaN`になってしまった場合の処理を書く必要があります。 変換した結果が`NaN`であるかは`Number.isNaN(x)`メソッドで判定できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[](#nan-is-number-type)*NaNはNot a NumberだけどNumber型*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ここで、数値への型変換でたびたび現れる`NaN`という値について詳しく見ていきます。 `NaN`はNot a Numberの略称で、特殊な性質を持つNumber型のデータです。'
  prefs: []
  type: TYPE_NORMAL
- en: この`NaN`というデータの性質については[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)で規定されており、
    JavaScriptだけの性質ではありません。
  prefs: []
  type: TYPE_NORMAL
- en: '`NaN`という値を作る方法は簡単で、Number型と互換性のない性質のデータをNumber型へ変換した結果は`NaN`となります。 たとえば、オブジェクトは数値とは互換性のないデータです。
    そのため、オブジェクトを明示的に変換したとしても結果は`NaN`になります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: また、`NaN`は何と演算しても結果は`NaN`になる特殊な値です。 次のように、計算の途中で値が`NaN`になると、最終的な結果も`NaN`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN`はNumber型の一種であるという名前と矛盾したデータに見えます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: NaNしか持っていない特殊な性質として、自分自身と一致しないというものがあります。 この特徴を利用することで、ある値が`NaN`であるかを判定できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 同様の処理をする方法として`Number.isNaN(x)`メソッドがあります。 実際に値が`NaN`かを判定する際には、`Number.isNaN(x)`メソッドを利用するとよいでしょう。^([1](#fn_1))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`NaN`は暗黙的な型変換の中でももっとも避けたい値となります。 理由として、先ほど紹介したように`NaN`は何と演算しても結果が`NaN`となってしまうためです。
    これにより、計算していた値がどこで`NaN`となったのかがわかりにくく、デバッグが難しくなります。'
  prefs: []
  type: TYPE_NORMAL
- en: たとえば、次の`sum`関数は可変長引数（任意の個数の引数）を受け取り、その合計値を返します。 しかし、`sum(x, y, z)`と呼び出したときの結果が`NaN`になってしまいました。
    これは、引数の中に`undefined`（未定義の値）が含まれているためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: そのため、`sum(x, y, z);`は次のように呼ばれていたのと同じ結果になります。 `undefined`に数値を加算すると結果は`NaN`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: これは、`sum`関数において引数を明示的にNumber型へ変換したとしても回避できません。 つまり、次のように明示的な型変換をしても解決できないことがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: この意図しない`NaN`への変換を避ける方法として、大きく分けて２つの方法があります。
  prefs: []
  type: TYPE_NORMAL
- en: '`sum`関数側（呼ばれる側）で、Number型の値以外を受けつけなくする'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sum`関数を呼び出す側で、Number型の値のみを渡すようにする'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: つまり、呼び出す側または呼び出される側で対処するということですが、 どちらも行うことがより安全なコードにつながります。
  prefs: []
  type: TYPE_NORMAL
- en: そのためには、`sum`関数が数値のみを受けつけるということを明示する必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: 明示する方法として`sum`関数のドキュメント（コメント）として記述したり、 引数に数値以外の値がある場合は例外を投げるという処理を追加するといった形です。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptではコメントで引数の型を記述する書式として[JSDoc](https://jsdoc.app/)が有名です。 また、実行時に値がNumber型であるかをチェックし`throw`文で例外を投げることで、`sum`関数の利用者に使い方を明示できます
    （`throw`文については「[例外処理](../error-try-catch/)」の章で解説します）。
  prefs: []
  type: TYPE_NORMAL
- en: この２つを利用して`sum`関数の前提条件を詳細に実装したものは次のようになります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: このように、`sum`関数はどのように使うべきかを明示することで、 エラーとなったときに呼ばれる側と呼び出し側でどちらに問題があるのかが明確になります。
    この場合は、`sum`関数へ`undefined`な値を渡している呼び出し側に問題があります。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptは、型エラーに対して暗黙的な型変換をしてしまうなど、驚くほど曖昧さを許容しています。 そのため、大きなアプリケーションを書く場合は、このような検出しにくいバグを見つけられるように書くことが重要です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#unsolved-problem)*明示的な変換でも解決しないこと*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*先ほどの例からもわかるように、あらゆるケースが明示的な変換で解決できるわけではありません。 Number型と互換性がない値を数値にしても、`NaN`となってしまいます。
    一度、`NaN`になってしまうと`Number.isNaN(x)`で判定して処理を終えるしかありません。'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptの型変換は基本的に情報が減る方向へしか変換できません。 そのため、明示的な変換をする前に、まず変換がそもそも必要なのかを考える必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#judge-empty-string)*空文字列かどうかを判定する*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*たとえば、文字列が空文字列なのかを判定したい場合を考えてみましょう。 `""`（空文字列）はfalsyな値であるため、明示的に`Boolean`コンストラクタ関数で真偽値へ変換できます。
    しかし、falsyな値は空文字列以外にもあるため、明示的に変換したからといって空文字列だけを判定できるわけではありません。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、明示的な型変換をしていますが、`0`も**空文字列**となってしまい意図しない挙動になっています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: ほとんどのケースにおいて、真偽値を得るには型変換ではなく別の方法が存在します。
  prefs: []
  type: TYPE_NORMAL
- en: この場合、空文字列とは「String型で文字長が0の値」であると定義することで、`isEmptyString`関数をもっと正確に書くことができます。 次のように実装することで、値が空文字列であるかを正しく判定できるようになりました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`Boolean`を使った型変換は、楽をするための型変換であり、正確に真偽値を得るための方法ではありません。 そのため、型変換をする前にまず別の方法で解決できないかを考えることも大切です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#conclusion)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では暗黙的な型変換と明示的な型変換について学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: 暗黙的な型変換は意図しない結果となりやすいため避ける
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 比較には等価演算子（`==`）ではなく、厳密等価演算子（`===`）を利用する
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 演算子による暗黙的な型変換より、明示的な型変換をする関数を利用する
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 真偽値を得るには、明示的な型変換以外の方法もある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ¹. `isNaN`関数というよく似た関数がありますが、`NaN`を正しく判定できないことがあるため、`Number.isNaN`メソッドを利用することが推奨されます。
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")************
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
