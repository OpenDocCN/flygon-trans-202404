["```\ndatatype 'a t = T of 'a t -> 'aval y = fn f => (fn (T x) => (f (fn a => x (T x) a)))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (T (fn (T x) => (f (fn a => x (T x) a))))\n```", "```\n> ;; `t' is the type name, `T' is the constructor (aka the variant)(define-type (RecType a)\u00a0 ; we don't really have polymorphic types\u00a0 [T ((RecType a) -> a)])\n> ```", "```\n> val y = fn f => (fn (T x) => (f (x (T x))))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (T (fn (T x) => (f (x (T x)))))\n> ```", "```\n> val y = fn f => (fn (Quote x) => (f (x (Quote x))))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Quote (fn (Quote x) => (f (x (Quote x)))))\n> ```", "```\n> (define (Y f)\u00a0 ((lambda (qx)\u00a0 \u00a0  (cases qx\u00a0 \u00a0 \u00a0  [(Quote x) (f (x (Quote x)))]))\u00a0  (Quote\u00a0 \u00a0 (lambda (qx)\u00a0 \u00a0 \u00a0 (cases qx\u00a0 \u00a0 \u00a0 \u00a0 [(Quote x) (f (x (Quote x)))])))))\n> ```", "```\n# type 'a t = T of ('a t -> 'a) ;;type 'a t = T of ('a t -> 'a)# let y f = (fun (T x) -> x (T x))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (T (fun (T x) -> fun z -> f (x (T x)) z)) ;;val y : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun># let fact = y (fun fact n -> if n<1 then 1 else n* fact(n-1)) ;;val fact : int -> int = <fun># fact 5 ;;- : int = 120\n```", "```\n# let y f = (fun x -> x x) (fun x -> fun z -> f (x x) z) ;;val y : (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b = <fun># let fact = y (fun fact n -> if n<1 then 1 else n* fact(n-1)) ;;val fact : int -> int = <fun># fact 5 ;;- : int = 120\n```", "```\n(: make-recursive : (T -> T) -> T)\n```", "```\n(: make-recursive : ((S -> T) -> (S -> T)) -> (S -> T))\n```", "```\n(define-type (Tau S T) = (Rec this (this -> (S -> T))))\n```", "```\n(: make-recursive : (All (S T) ((S -> T) -> (S -> T)) -> (S -> T)))(define-type (Tau S T) = (Rec this (this -> (S -> T))))(define (make-recursive f)\u00a0 ((lambda ([x : (Tau S T)]) (f (lambda (z) ((x x) z))))\u00a0  (lambda ([x : (Tau S T)]) (f (lambda (z) ((x x) z))))))(: fact : Number -> Number)(define fact (make-recursive\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (lambda ([fact : (Number -> Number)])\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (lambda ([n : Number])\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (if (zero? n)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 1\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (* n (fact (- n 1))))))))(fact 5)\n```"]