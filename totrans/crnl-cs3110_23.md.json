["```\n\n  Simple Synchronization\n\n  One simple way to coordinate deferred computations is to wait for them to become determined. The function `both` does this for the case where there are two computations:\n\n```", "```\n\n  Recall that both can be easily implemented\nusing bind and return:\n\n```", "```\n\n  More generally, we can wait for a *list* of deferred values to\nbecome determined using all\n\n```", "```\n\n  One can think of all as a kind of barrier which ensures that\nall of the deferred values in the list have been fully computed before\nproceeding. The resulting values are available in the final list. Here\nis one possible implementation of all:\n\n```", "```\n\n  There is a dual to `all` called any that waits for *some* value in a list of deferreds to become determined:\n\n```", "```\n\n  Note that, if several deferreds from the list \nbecome determined in close proximity,\nthe Async scheduler makes no\nguarantees that the deferred computation selected will be the first that\nbecame determined.\n\n  Timeouts\n\n  One application of `any` is to create functions that execute computations with a fixed time budget. The function `after` produces a deferred computation that becomes determined at a fixed time in the future:\n\n```", "```\n\n  The type Core.Span.t represents a span of time. The\nfunction sec computes a span in seconds:\n\n```", "```\n\n  Hence, the expression\n\n```", "```\n\n  is a deferred computation that becomes determined after approximately\n5.3 seconds.\nAsync does not make real-time guarantees:  the \n  after will become determined after 5.3\nseconds, but not necessarily *immediately* after.\n  Using `after` and `any`, we can write a higher-order function that executes a deferred computation `f` until it becomes determined or reaches a timeout:\n\n```", "```\n\n  The expression timeout thunk n attempts to execute the thunk\nand wraps the result in the Some constructor for the option\ndatatype. However, if the time budget is exceeded, then the unit value\ncomputed by after become determined and the whole computation\nreturns None instead. \n\n  The 3110 autograder uses a similar function to handle the issue of student submissions spinning off into infinite loops.\n\n  Ivars\n\n  Most common patterns of coordination and synchronization can be implemented using simple functions like `both`, `all`, and `any`. But in certain other situations, more intricate behavior is needed. An *ivar* can be used to implement fine-grained coordination and synchronization between deferred computations. Intuitively, an ivar is like a reference that can be assigned to, or *filled*, exactly once. Hence, an ivar is similar to a deferred computation, which is intially undetermined and then becomes determined exactly once.\n\n  The ivars interface is captured by the following code:\n\n```", "```\n\n  Consult\nthe Ivar\ndocumentation for further details.\n\n  The key thing to notice about the `Ivar` module is the `read` function, which constructs a deferred value that becomes determined when the ivar is filled. We will use this functionality in the next example.\n\n  The ivar abstraction was invented by John Reppy (Cornell PhD, 1992) in a language called Concurrent ML.\n\n  Delaying Scheduler\n\n  To illustrate the use of ivars, we will implement a simple scheduler that delays jobs by a fixed amount of time. We will need the function `upon`,\n\n```", "```\n\n  which waits for a value in the first argument to become determined,\nand then executes the code in the (possibly side-effecting) second\nargument.\n\n  The interface for the delaying scheduler is as follows:\n\n```", "```\n\n  The create function initializes a scheduler that delays\nincoming jobs by a fixed amount of time. The schedule\nfunction schedules a job provided by a thunk that produces a deferred\nvalue.  The overall result of schedule is determined when the\njob has been run and its value has become determined.\n\n  The implementation for the delaying scheduler is as follows:\n\n```", "```\n\n  Note that the job is enqueued immediately and dequeued after the delay\nhas elapsed. Also note how ivar is filled and used to\ncommunicate the final result.\n\n  Choice\n\n  The `any` function provides a way to choose just one of several deferred computations. However, if those computations have effects, such as opening files or socket connections, printing to the console, etc., the behavior may not be what is desired. This can lead to problems in general if these side effects are not correctly handled. However, OCaml does not provide general mechanisms to cleanly revert or shutdown a computation that has been discarded.\n\n  To address this problem, Async provides the notion of a *choice*:\n\n```", "```\n\n  To construct a value of type choice, one provides a deferred\ncomputation as well a function:\n\n```", "```\n\n  Intuitively a choice can be thought of as representing a computation\nwhere the function is executed if the deferred computation becomes\ndetermined and the choice is chosen. By placing all side-effecting\npieces of the computation in the function, programmers can obtain\nfiner-grained control if and when computations are discarded.\n\n  The function `choose` selects a list of choices:\n\n```", "```\n\n  Just like any, the implementation provides no guarantees\nabout which element will be chosen, or when it will be\ndetermined. However, importantly it does guarantee that only one of\nthe functions for the choice elements is executed. This can be used to\nwrite clean shutdown code in programs that combine deferred\ncomputation and side\neffects. See Real World OCaml Chapter 18 for a fully worked out example using choice\nto build a web search client.\n\n```"]