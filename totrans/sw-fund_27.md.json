["```\n\n```", "```\n\n# Concepts\n\n We now turn to the study of *subtyping*, a key feature\n    needed to support the object-oriented programming style. \n\n## A Motivating Example\n\n Suppose we are writing a program involving two record types\n    defined as follows:\n\n```", "```\n\n In the simply typed lamdba-calculus with records, the term\n\n```", "```\n\n   is not typable, since it applies a function that wants a one-field\n   record to an argument that actually provides two fields, while the\n   T_App rule demands that the domain type of the function being\n   applied must match the type of the argument precisely.\n\n   But this is silly: we're passing the function a *better* argument\n   than it needs!  The only thing the body of the function can\n   possibly do with its record argument r is project the field age\n   from it: nothing else is allowed by the type, and the presence or\n   absence of an extra gpa field makes no difference at all.  So,\n   intuitively, it seems that this function should be applicable to\n   any record value that has at least an age field.\n\n   More generally, a record with more fields is \"at least as good in\n   any context\" as one with just a subset of these fields, in the\n   sense that any value belonging to the longer record type can be\n   used *safely* in any context expecting the shorter record type.  If\n   the context expects something with the shorter type but we actually\n   give it something with the longer type, nothing bad will\n   happen (formally, the program will not get stuck).\n\n   The principle at work here is called *subtyping*.  We say that \"S\n   is a subtype of T\", written S <: T, if a value of type S can\n   safely be used in any context where a value of type T is\n   expected.  The idea of subtyping applies not only to records, but\n   to all of the type constructors in the language \u2014 functions,\n   pairs, etc. \n\n## Subtyping and Object-Oriented Languages\n\n Subtyping plays a fundamental role in many programming\n    languages \u2014 in particular, it is closely related to the notion of\n    *subclassing* in object-oriented languages.\n\n    An *object* in Java, C#, etc. can be thought of as a record,\n    some of whose fields are functions (\"methods\") and some of whose\n    fields are data values (\"fields\" or \"instance variables\").\n    Invoking a method m of an object o on some arguments a[1]..an\n    roughly consists of projecting out the m field of o and\n    applying it to a[1]..an.\n\n    The type of an object is called a *class* \u2014 or, in some\n    languages, an *interface*.  It describes which methods and which\n    data fields the object offers.  Classes and interfaces are related\n    by the *subclass* and *subinterface* relations.  An object\n    belonging to a subclass (or subinterface) is required to provide\n    all the methods and fields of one belonging to a superclass (or\n    superinterface), plus possibly some more.\n\n    The fact that an object from a subclass can be used in place of\n    one from a superclass provides a degree of flexibility that is is\n    extremely handy for organizing complex libraries.  For example, a\n    GUI toolkit like Java's Swing framework might define an abstract\n    interface Component that collects together the common fields and\n    methods of all objects having a graphical representation that can\n    be displayed on the screen and interact with the user, such as the\n    buttons, checkboxes, and scrollbars of a typical GUI.  A method\n    that relies only on this common interface can now be applied to\n    any of these objects.\n\n    Of course, real object-oriented languages include many other\n    features besides these.  For example, fields can be updated.\n    Fields and methods can be declared private.  Classes can give\n    *initializers* that are used when constructing objects.  Code in\n    subclasses can cooperate with code in superclasses via\n    *inheritance*.  Classes can have static methods and fields.  Etc.,\n    etc.\n\n    To keep things simple here, we won't deal with any of these\n    issues \u2014 in fact, we won't even talk any more about objects or\n    classes.  (There is a lot of discussion in [[Pierce 2002]](Bib.html#Pierce 2002), if\n    you are interested.)  Instead, we'll study the core concepts\n    behind the subclass / subinterface relation in the simplified\n    setting of the STLC. \n\n## The Subsumption Rule\n\n Our goal for this chapter is to add subtyping to the simply typed\n    lambda-calculus (with some of the basic extensions from MoreStlc).\n    This involves two steps:\n\n*   Defining a binary *subtype relation* between types.\n\n*   Enriching the typing relation to take subtyping into account.\n\n    The second step is actually very simple.  We add just a single rule\n    to the typing relation: the so-called *rule of subsumption*:\n\n| \u0393\u00a0\u22a2\u00a0t\u00a0:\u00a0S\u00a0\u00a0\u00a0\u00a0\u00a0S\u00a0<:\u00a0t< td=\"\">\n    | \n     (T_Sub) \u00a0\n   |\n|  \n* * *\n\n |\n| \u0393\u00a0\u22a2\u00a0t\u00a0:\u00a0T | \n \n |\n\n    This rule says, intuitively, that it is OK to \"forget\" some of\n    what we know about a term. \n\n For example, we may know that t is a record with two\n    fields (e.g., S = {x:A\u2192A, y:B\u2192B}), but choose to forget about\n    one of the fields (T = {y:B\u2192B}) so that we can pass t to a\n    function that requires just a single-field record. \n\n## The Subtype Relation\n\n The first step \u2014 the definition of the relation S <: T \u2014 is\n    where all the action is.  Let's look at each of the clauses of its\n    definition.  \n\n### Structural Rules\n\n To start off, we impose two \"structural rules\" that are\n    independent of any particular type constructor: a rule of\n    *transitivity*, which says intuitively that, if S is \n    better (richer, safer) than U and U is better than T, \n    then S is better than T...\n\n| S\u00a0<:\u00a0u\u00a0\u00a0\u00a0\u00a0u\u00a0<:\u00a0t< td=\"\">\n    | \n     (S_Trans) \u00a0\n   |\n|  \n* * *\n\n |\n| S\u00a0<:\u00a0t< td=\"\">\n    | \n \n |\n\n    ... and a rule of *reflexivity*, since certainly any type T is\n    as good as itself:\n\n| \u00a0\u00a0 | \n     (S_Refl) \u00a0\n   |\n|  \n* * *\n\n |\n| T\u00a0<:\u00a0t< td=\"\">\n    | \n \n |\n\n### Products\n\n Now we consider the individual type constructors, one by one,\n    beginning with product types.  We consider one pair to be a subtype \n    of another if each of its components is.\n\n| S[1]\u00a0<:\u00a0t[1\u00a0\u00a0\u00a0\u00a0S[2]\u00a0<:\u00a0t[2]] | \n     (S_Prod) \u00a0\n   |\n|  \n* * *\n\n |\n| S[1]\u00a0*\u00a0S[2]\u00a0<:\u00a0t[1\u00a0*\u00a0T[2]] | \n \n |\n\n### Arrows\n\n The subtyping rule for arrows is a little less intuitive.  \n    Suppose we have functions f and g with these types:\n\n```", "```\n\n    That is, f is a function that yields a record of type Student,\n    and g is a (higher-order) function that expects its argument to be \n    a function yielding a record of type Person.  Also suppose that\n    Student is a subtype of Person.  Then the application g f is\n    safe even though their types do not match up precisely, because\n    the only thing g can do with f is to apply it to some\n    argument (of type C); the result will actually be a Student,\n    while g will be expecting a Person, but this is safe because\n    the only thing g can then do is to project out the two fields\n    that it knows about (name and age), and these will certainly\n    be among the fields that are present.\n\n    This example suggests that the subtyping rule for arrow types\n    should say that two arrow types are in the subtype relation if\n    their results are:\n\n| S[2]\u00a0<:\u00a0t[2] | \n     (S_Arrow_Co) \u00a0\n   |\n|  \n* * *\n\n |\n| S[1]\u00a0\u2192\u00a0S[2]\u00a0<:\u00a0s[1\u00a0\u2192\u00a0T[2]] | \n \n |\n\n    We can generalize this to allow the arguments of the two arrow\n    types to be in the subtype relation as well:\n\n| T[1]\u00a0<:\u00a0s[1\u00a0\u00a0\u00a0\u00a0S[2]\u00a0<:\u00a0t[2]] | \n     (S_Arrow) \u00a0\n   |\n|  \n* * *\n\n |\n| S[1]\u00a0\u2192\u00a0S[2]\u00a0<:\u00a0t[1\u00a0\u2192\u00a0T[2]] | \n \n |\n\n    But notice that the argument types are subtypes \"the other way round\":\n    in order to conclude that S[1]\u2192S[2] to be a subtype of T[1]\u2192T[2], it\n    must be the case that T[1] is a subtype of S[1].  The arrow\n    constructor is said to be *contravariant* in its first argument\n    and *covariant* in its second.\n\n    Here is an example that illustrates this:\n\n```", "```\n\n    The application g f is safe, because the only thing the body of\n    g can do with f is to apply it to some argument of type\n    Student.  Since f requires records having (at least) the\n    fields of a Person, this will always work. So Person \u2192 C is a\n    subtype of Student \u2192 C since Student is a subtype of\n    Person.\n\n    The intuition is that, if we have a function f of type S[1]\u2192S[2],\n    then we know that f accepts elements of type S[1]; clearly, f\n    will also accept elements of any subtype T[1] of S[1]. The type of\n    f also tells us that it returns elements of type S[2]; we can\n    also view these results belonging to any supertype T[2] of\n    S[2]. That is, any function f of type S[1]\u2192S[2] can also be\n    viewed as having type T[1]\u2192T[2]. \n\n### Records\n\n What about subtyping for record types? \n\n The basic intuition is that it is always safe to use a \"bigger\"\n    record in place of a \"smaller\" one.  That is, given a record type,\n    adding extra fields will always result in a subtype.  If some code\n    is expecting a record with fields x and y, it is perfectly safe\n    for it to receive a record with fields x, y, and z; the z\n    field will simply be ignored.  For example,\n\n```", "```\n\n    This is known as \"width subtyping\" for records. \n\n We can also create a subtype of a record type by replacing the type\n    of one of its fields with a subtype.  If some code is expecting a\n    record with a field x of type T, it will be happy with a record\n    having a field x of type S as long as S is a subtype of\n    T. For example,\n\n```", "```\n\n    This is known as \"depth subtyping\". \n\n Finally, although the fields of a record type are written in a\n    particular order, the order does not really matter. For example,\n\n```", "```\n\n    This is known as \"permutation subtyping\". \n\n We *could* formalize these requirements in a single subtyping rule\n    for records as follows:\n\n| \u2200jk\u00a0in\u00a0j[1]..jn, | \n \n |\n| \u2203ip\u00a0in\u00a0i[1]..im,\u00a0such\u00a0that | \n \n |\n| jk=ip\u00a0and\u00a0Sp\u00a0<:\u00a0tk< td=\"\">\n    | \n     (S_Rcd) \u00a0\n   |\n|  \n* * *\n\n |\n| {i[1]:S[1]...im:Sm}\u00a0<:\u00a0{j[1:T[1]...jn:Tn}] | \n \n |\n\n    That is, the record on the left should have all the field labels of\n    the one on the right (and possibly more), while the types of the\n    common fields should be in the subtype relation. \n\n    However, this rule is rather heavy and hard to read, so it is often \n    decomposed into three simpler rules, which can be combined using \n    S_Trans to achieve all the same effects. \n\n First, adding fields to the end of a record type gives a subtype:\n\n| n\u00a0>\u00a0m | \n     (S_RcdWidth) \u00a0\n   |\n|  \n* * *\n\n |\n| {i[1]:T[1]...in:Tn}\u00a0<:\u00a0{i[1:T[1]...im:Tm}] | \n \n |\n\n    We can use S_RcdWidth to drop later fields of a multi-field\n    record while keeping earlier fields, showing for example that\n    {age:Nat,name:String} <: {name:String}. \n\n Second, subtyping can be applied inside the components of a compound\n    record type:\n\n| S[1]\u00a0<:\u00a0t[1\u00a0\u00a0...\u00a0\u00a0Sn\u00a0<:\u00a0tn< td=\"\">]  | \n     (S_RcdDepth) \u00a0\n   |\n|  \n* * *\n\n |\n| {i[1]:S[1]...in:Sn}\u00a0<:\u00a0{i[1:T[1]...in:Tn}] | \n \n |\n\n    For example, we can use S_RcdDepth and S_RcdWidth together to\n    show that {y:Student, x:Nat} <: {y:Person}. \n\n Third, subtyping can reorder fields.  For example, we\n    want {name:String, gpa:Nat, age:Nat} <: Person.  (We\n    haven't quite achieved this yet: using just S_RcdDepth and\n    S_RcdWidth we can only drop fields from the *end* of a record\n    type.)  So we add:\n\n| {i[1]:S[1]...in:Sn}\u00a0is\u00a0a\u00a0permutation\u00a0of\u00a0{j[1]:T[1]...jn:Tn} | \n     (S_RcdPerm) \u00a0\n   |\n|  \n* * *\n\n |\n| {i[1]:S[1]...in:Sn}\u00a0<:\u00a0{j[1:T[1]...jn:Tn}] | \n \n |\n\n It is worth noting that full-blown language designs may choose not\n    to adopt all of these subtyping rules. For example, in Java:\n\n*   A subclass may not change the argument or result types of a\n          method of its superclass (i.e., no depth subtyping or no arrow\n          subtyping, depending how you look at it).\n\n*   Each class member (field or method) can be assigned a single\n          index, adding new indices \"on the right\" as more members are\n          added in subclasses (i.e., no permutation for classes).\n\n*   A class may implement multiple interfaces \u2014 so-called \"multiple\n          inheritance\" of interfaces (i.e., permutation is allowed for\n          interfaces). \n\n#### Exercise: 2 stars, recommendedM (arrow_sub_wrong)\n\n Suppose we had incorrectly defined subtyping as covariant on both\n    the right and the left of arrow types:\n\n| S[1]\u00a0<:\u00a0t[1\u00a0\u00a0\u00a0\u00a0S[2]\u00a0<:\u00a0t[2]] | \n     (S_Arrow_wrong) \u00a0\n   |\n|  \n* * *\n\n |\n| S[1]\u00a0\u2192\u00a0S[2]\u00a0<:\u00a0t[1\u00a0\u2192\u00a0T[2]] | \n \n |\n\n    Give a concrete example of functions f and g with the following\n    types...\n\n```", "```\n\n    ... such that the application g f will get stuck during\n    execution.  (Use informal syntax.  No need to prove formally that \n    the application gets stuck.)\n\n\u2610 \n\n### Top\n\n Finally, it is convenient to give the subtype relation a maximum\n    element \u2014 a type that lies above every other type and is\n    inhabited by all (well-typed) values.  We do this by adding to the\n    language one new type constant, called Top, together with a\n    subtyping rule that places it above every other type in the\n    subtype relation:\n\n| \u00a0\u00a0 | \n     (S_Top) \u00a0\n   |\n|  \n* * *\n\n |\n| S\u00a0<:\u00a0top< td=\"\">\n    | \n \n |\n\n    The Top type is an analog of the Object type in Java and C#. \n\n### Summary\n\n In summary, we form the STLC with subtyping by starting with the\n    pure STLC (over some set of base types) and then...\n\n*   adding a base type Top,\n\n*   adding the rule of subsumption\n\n    | \u0393\u00a0\u22a2\u00a0t\u00a0:\u00a0S\u00a0\u00a0\u00a0\u00a0\u00a0S\u00a0<:\u00a0t< td=\"\">\n    | \n     (T_Sub) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | \u0393\u00a0\u22a2\u00a0t\u00a0:\u00a0T | \n \n     |\n\n          to the typing relation, and\n\n*   defining a subtype relation as follows:\n\n    | S\u00a0<:\u00a0u\u00a0\u00a0\u00a0\u00a0u\u00a0<:\u00a0t< td=\"\">\n    | \n     (S_Trans) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | S\u00a0<:\u00a0t< td=\"\">\n    | \n \n     |\n\n    | \u00a0\u00a0 | \n     (S_Refl) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | T\u00a0<:\u00a0t< td=\"\">\n    | \n \n     |\n\n    | \u00a0\u00a0 | \n     (S_Top) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | S\u00a0<:\u00a0top< td=\"\">\n    | \n \n     |\n\n    | S[1]\u00a0<:\u00a0t[1\u00a0\u00a0\u00a0\u00a0S[2]\u00a0<:\u00a0t[2]] | \n     (S_Prod) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | S[1]\u00a0*\u00a0S[2]\u00a0<:\u00a0t[1\u00a0*\u00a0T[2]] | \n \n     |\n\n    | T[1]\u00a0<:\u00a0s[1\u00a0\u00a0\u00a0\u00a0S[2]\u00a0<:\u00a0t[2]] | \n     (S_Arrow) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | S[1]\u00a0\u2192\u00a0S[2]\u00a0<:\u00a0t[1\u00a0\u2192\u00a0T[2]] | \n \n     |\n\n    | n\u00a0>\u00a0m | \n     (S_RcdWidth) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | {i[1]:T[1]...in:Tn}\u00a0<:\u00a0{i[1:T[1]...im:Tm}] | \n \n     |\n\n    | S[1]\u00a0<:\u00a0t[1\u00a0\u00a0...\u00a0\u00a0Sn\u00a0<:\u00a0tn< td=\"\">]  | \n     (S_RcdDepth) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | {i[1]:S[1]...in:Sn}\u00a0<:\u00a0{i[1:T[1]...in:Tn}] | \n \n     |\n\n    | {i[1]:S[1]...in:Sn}\u00a0is\u00a0a\u00a0permutation\u00a0of\u00a0{j[1]:T[1]...jn:Tn} | \n     (S_RcdPerm) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | {i[1]:S[1]...in:Sn}\u00a0<:\u00a0{j[1:T[1]...jn:Tn}] | \n \n     |\n\n## Exercises\n\n#### Exercise: 1 star, optional (subtype_instances_tf_1)\n\n Suppose we have types S, T, U, and V with S <: T\n    and U <: V.  Which of the following subtyping assertions\n    are then true?  Write *true* or *false* after each one.\n    (A, B, and C here are base types like Bool, Nat, etc.)\n\n*   T\u2192S <: T\u2192S\n\n*   Top\u2192U <: S\u2192Top\n\n*   (C\u2192C) \u2192 (A*B)  <:  (C\u2192C) \u2192 (Top*B)\n\n*   T\u2192T\u2192U <: S\u2192S\u2192V\n\n*   (T\u2192T)\u2192U <: (S\u2192S)\u2192V\n\n*   ((T\u2192S)\u2192T)\u2192U <: ((S\u2192T)\u2192S)\u2192V\n\n*   S*V <: T*U\n\n\u2610 \n\n#### Exercise: 2 starsM (subtype_order)\n\n The following types happen to form a linear order with respect to subtyping:\n\n*   Top\n\n*   Top \u2192 Student\n\n*   Student \u2192 Person\n\n*   Student \u2192 Top\n\n*   Person \u2192 Student\n\nWrite these types in order from the most specific to the most general.\n\nWhere does the type Top\u2192Top\u2192Student fit into this order?\n\n\u2610 \n\n#### Exercise: 1 starM (subtype_instances_tf_2)\n\n Which of the following statements are true?  Write *true* or\n    *false* after each one.\n\n```", "```\n\n\u2610 \n\n#### Exercise: 1 starM (subtype_concepts_tf)\n\n Which of the following statements are true, and which are false?\n\n*   There exists a type that is a supertype of every other type.\n\n*   There exists a type that is a subtype of every other type.\n\n*   There exists a pair type that is a supertype of every other\n          pair type.\n\n*   There exists a pair type that is a subtype of every other\n          pair type.\n\n*   There exists an arrow type that is a supertype of every other\n          arrow type.\n\n*   There exists an arrow type that is a subtype of every other\n          arrow type.\n\n*   There is an infinite descending chain of distinct types in the\n          subtype relation\u2014-that is, an infinite sequence of types\n          S[0], S[1], etc., such that all the Si's are different and\n          each S(i+1) is a subtype of Si.\n\n*   There is an infinite *ascending* chain of distinct types in\n          the subtype relation\u2014-that is, an infinite sequence of types\n          S[0], S[1], etc., such that all the Si's are different and\n          each S(i+1) is a supertype of Si.\n\n\u2610 \n\n#### Exercise: 2 starsM (proper_subtypes)\n\n Is the following statement true or false?  Briefly explain your\n    answer.  (Here TBase n stands for a base type, where n is \n    a string standing for the name of the base type.  See the \n    Syntax section below.)\n\n```", "```\n\n\u2610 \n\n#### Exercise: 2 starsM (small_large_1)\n\n*   What is the *smallest* type T (\"smallest\" in the subtype\n         relation) that makes the following assertion true?  (Assume we\n         have Unit among the base types and unit as a constant of this\n         type.)\n\n    ```", "```\n\n*   What is the *largest* type T that makes the same assertion true?\n\n\u2610 \n\n#### Exercise: 2 starsM (small_large_2)\n\n*   What is the *smallest* type T that makes the following\n         assertion true?\n\n    ```", "```\n\n*   What is the *largest* type T that makes the same assertion true?\n\n\u2610 \n\n#### Exercise: 2 stars, optional (small_large_3)\n\n*   What is the *smallest* type T that makes the following\n         assertion true?\n\n    ```", "```\n\n*   What is the *largest* type T that makes the same assertion true?\n\n\u2610 \n\n#### Exercise: 2 starsM (small_large_4)\n\n*   What is the *smallest* type T that makes the following\n         assertion true?\n\n    ```", "```\n\n*   What is the *largest* type T that makes the same\n         assertion true?\n\n\u2610 \n\n#### Exercise: 2 starsM (smallest_1)\n\n What is the *smallest* type T that makes the following\n    assertion true?\n\n```", "```\n\n\u2610 \n\n#### Exercise: 2 starsM (smallest_2)\n\n What is the *smallest* type T that makes the following\n    assertion true?\n\n```", "```\n\n\u2610 \n\n#### Exercise: 3 stars, optional (count_supertypes)\n\n How many supertypes does the record type {x:A, y:C\u2192C} have?  That is,\n    how many different types T are there such that {x:A, y:C\u2192C} <:\n    T?  (We consider two types to be different if they are written\n    differently, even if each is a subtype of the other.  For example,\n    {x:A,y:B} and {y:B,x:A} are different.)\n\n\u2610 \n\n#### Exercise: 2 starsM (pair_permutation)\n\n The subtyping rule for product types\n\n| S[1]\u00a0<:\u00a0t[1\u00a0\u00a0\u00a0\u00a0S[2]\u00a0<:\u00a0t[2]] | \n     (S_Prod) \u00a0\n   |\n|  \n* * *\n\n |\n| S[1]*S[2]\u00a0<:\u00a0t[1*T[2]] | \n \n |\n\n    intuitively corresponds to the \"depth\" subtyping rule for records. \n    Extending the analogy, we might consider adding a \"permutation\" rule\n\n| \u00a0\u00a0 | \n     \u00a0\n   |\n|  \n* * *\n\n |\n| T[1]*T[2]\u00a0<:\u00a0t[2*T[1]] | \n \n |\n\n    for products.  Is this a good idea? Briefly explain why or why not.\n\n\u2610 \n\n# Formal Definitions\n\n Most of the definitions needed to formalize what we've discussed\n    above \u2014 in particular, the syntax and operational semantics of\n    the language \u2014 are identical to what we saw in the last chapter.\n    We just need to extend the typing relation with the subsumption\n    rule and add a new Inductive definition for the subtyping\n    relation.  Let's first do the identical bits. \n\n## Core Definitions\n\n### Syntax\n\n In the rest of the chapter, we formalize just base types,\n    booleans, arrow types, Unit, and Top, omitting record types\n    and leaving product types as an exercise.  For the sake of more\n    interesting examples, we'll add an arbitrary set of base types\n    like String, Float, etc.  (Since they are just for examples,\n    we won't bother adding any operations over these base types, but\n    we could easily do so.) \n\n```", "```\n\n### Substitution\n\n The definition of substitution remains exactly the same as for the\n    pure STLC. \n\n```", "```\n\n### Reduction\n\n Likewise the definitions of the value property and the step\n    relation. \n\n```", "```\n\n## Subtyping\n\n Now we come to the interesting part.  We begin by defining\n    the subtyping relation and developing some of its important\n    technical properties. \n\n The definition of subtyping is just what we sketched in the\n    motivating discussion. \n\n```", "```\n\nNote that we don't need any special rules for base types (TBool\n    and TBase): they are automatically subtypes of themselves (by\n    S_Refl) and Top (by S_Top), and that's all we want. \n\n```", "```\n\n#### Exercise: 2 stars, optional (subtyping_judgements)\n\n (Wait to do this exercise after you have added product types to the\n    language \u2014 see exercise products \u2014 at least up to this point \n    in the file).\n\n    Recall that, in chapter [MoreStlc](MoreStlc.html), the optional section \"Encoding\n    Records\" describes how records can be encoded as pairs.\n    Using this encoding, define pair types representing the following \n    record types:\n\n```", "```\n\n```", "```\n\nNow use the definition of the subtype relation to prove the following: \n\n```", "```\n\n\u2610 \n\n The following facts are mostly easy to prove in Coq.  To get\n    full benefit from the exercises, make sure you also\n    understand how to prove them on paper! \n\n#### Exercise: 1 star, optional (subtyping_example_1)\n\n```", "```\n\n\u2610 \n\n#### Exercise: 1 star, optional (subtyping_example_2)\n\n```", "```\n\n\u2610 \n\n```", "```\n\n## Typing\n\n The only change to the typing relation is the addition of the rule\n    of subsumption, T_Sub. \n\n```", "```\n\nThe following hints help auto and eauto construct typing\n    derivations.  (See chapter [UseAuto](UseAuto.html) for more on hints.) \n\n```", "```\n\nDo the following exercises after you have added product types to\n    the language.  For each informal typing judgement, write it as a\n    formal statement in Coq and prove it. \n\n#### Exercise: 1 star, optional (typing_example_0)\n\n```", "```\n\n\u2610 \n\n#### Exercise: 2 stars, optional (typing_example_1)\n\n```", "```\n\n\u2610 \n\n#### Exercise: 2 stars, optional (typing_example_2)\n\n```", "```\n\n\u2610 \n\n```", "```\n\n# Properties\n\n The fundamental properties of the system that we want to\n    check are the same as always: progress and preservation.  Unlike\n    the extension of the STLC with references (chapter [References](References.html)),\n    we don't need to change the *statements* of these properties to\n    take subtyping into account.  However, their proofs do become a\n    little bit more involved. \n\n## Inversion Lemmas for Subtyping\n\n Before we look at the properties of the typing relation, we need\n    to establish a couple of critical structural properties of the\n    subtype relation:\n\n*   Bool is the only subtype of Bool, and\n\n*   every subtype of an arrow type is itself an arrow type. \n\n These are called *inversion lemmas* because they play a\n    similar role in proofs as the built-in inversion tactic: given a\n    hypothesis that there exists a derivation of some subtyping\n    statement S <: T and some constraints on the shape of S and/or\n    T, each inversion lemma reasons about what this derivation must\n    look like to tell us something further about the shapes of S and\n    T and the existence of subtype relations between their parts. \n\n#### Exercise: 2 stars, optional (sub_inversion_Bool)\n\n```", "```\n\n#### Exercise: 3 stars, optional (sub_inversion_arrow)\n\n```", "```\n\n\u2610 \n\n## Canonical Forms\n\n The proof of the progress theorem \u2014 that a well-typed\n    non-value can always take a step \u2014 doesn't need to change too\n    much: we just need one small refinement.  When we're considering\n    the case where the term in question is an application t[1] t[2]\n    where both t[1] and t[2] are values, we need to know that t[1] has\n    the *form* of a lambda-abstraction, so that we can apply the\n    ST_AppAbs reduction rule.  In the ordinary STLC, this is\n    obvious: we know that t[1] has a function type T[11]\u2192T[12], and\n    there is only one rule that can be used to give a function type to\n    a value \u2014 rule T_Abs \u2014 and the form of the conclusion of this\n    rule forces t[1] to be an abstraction.\n\n    In the STLC with subtyping, this reasoning doesn't quite work\n    because there's another rule that can be used to show that a value\n    has a function type: subsumption.  Fortunately, this possibility\n    doesn't change things much: if the last rule used to show \u0393\n    \u22a2 t[1] : T[11]\u2192T[12] is subsumption, then there is some\n    *sub*-derivation whose subject is also t[1], and we can reason by\n    induction until we finally bottom out at a use of T_Abs.\n\n    This bit of reasoning is packaged up in the following lemma, which\n    tells us the possible \"canonical forms\" (i.e., values) of function\n    type. \n\n#### Exercise: 3 stars, optional (canonical_forms_of_arrow_types)\n\n```", "```\n\n\u2610 \n\n Similarly, the canonical forms of type Bool are the constants\n    true and false. \n\n```", "```\n\n## Progress\n\n The proof of progress now proceeds just like the one for the\n    pure STLC, except that in several places we invoke canonical forms\n    lemmas... \n\n *Theorem* (Progress): For any term t and type T, if empty \u22a2\n    t : T then t is a value or t \u21d2 t' for some term t'.\n\n    *Proof*: Let t and T be given, with empty \u22a2 t : T.  Proceed\n    by induction on the typing derivation.\n\n    The cases for T_Abs, T_Unit, T_True and T_False are\n    immediate because abstractions, unit, true, and false are\n    already values.  The T_Var case is vacuous because variables\n    cannot be typed in the empty context.  The remaining cases are\n    more interesting:\n\n*   If the last step in the typing derivation uses rule T_App,\n          then there are terms t[1] t[2] and types T[1] and T[2] such that\n          t = t[1] t[2], T = T[2], empty \u22a2 t[1] : T[1] \u2192 T[2], and empty \u22a2\n          t[2] : T[1].  Moreover, by the induction hypothesis, either t[1] is\n          a value or it steps, and either t[2] is a value or it steps.\n          There are three possibilities to consider:\n\n    *   Suppose t[1] \u21d2 t[1]' for some term t[1]'.  Then t[1] t[2] \u21d2 t[1]' t[2]\n                by ST_App1.\n\n    *   Suppose t[1] is a value and t[2] \u21d2 t[2]' for some term t[2]'.\n                Then t[1] t[2] \u21d2 t[1] t[2]' by rule ST_App2 because t[1] is a\n                value.\n\n    *   Finally, suppose t[1] and t[2] are both values.  By the \n                canonical forms lemma for arrow types, we know that t[1] has the\n                form \\x:S[1].s2 for some x, S[1], and s[2].  But then\n                (\u03bbx:S[1].s2) t[2] \u21d2 [x:=t[2]]s[2] by ST_AppAbs, since t[2] is a\n                value.\n\n*   If the final step of the derivation uses rule T_If, then there\n          are terms t[1], t[2], and t[3] such that t = if t[1] then t[2] else\n          t[3], with empty \u22a2 t[1] : Bool and with empty \u22a2 t[2] : T and\n          empty \u22a2 t[3] : T.  Moreover, by the induction hypothesis,\n          either t[1] is a value or it steps.\n\n    *   If t[1] is a value, then by the canonical forms lemma for\n                 booleans, either t[1] = true or t[1] = false.  In either\n                 case, t can step, using rule ST_IfTrue or ST_IfFalse.\n\n    *   If t[1] can step, then so can t, by rule ST_If.\n\n*   If the final step of the derivation is by T_Sub, then there is\n          a type S such that S <: T and empty \u22a2 t : S.  The desired\n          result is exactly the induction hypothesis for the typing\n          subderivation. \n\n```", "```\n\n## Inversion Lemmas for Typing\n\n The proof of the preservation theorem also becomes a little more\n    complex with the addition of subtyping.  The reason is that, as\n    with the \"inversion lemmas for subtyping\" above, there are a\n    number of facts about the typing relation that are immediate from\n    the definition in the pure STLC (formally: that can be obtained\n    directly from the inversion tactic) but that require real proofs\n    in the presence of subtyping because there are multiple ways to\n    derive the same has_type statement.\n\n    The following inversion lemma tells us that, if we have a\n    derivation of some typing statement \u0393 \u22a2 \\x:S[1].t2 : T whose\n    subject is an abstraction, then there must be some subderivation\n    giving a type to the body t[2]. \n\n *Lemma*: If \u0393 \u22a2 \\x:S[1].t2 : T, then there is a type S[2]\n    such that \u0393, x:S[1] \u22a2 t[2] : S[2] and S[1] \u2192 S[2] <: T.\n\n    (Notice that the lemma does *not* say, \"then T itself is an arrow\n    type\" \u2014 this is tempting, but false!)\n\n    *Proof*: Let \u0393, x, S[1], t[2] and T be given as\n     described.  Proceed by induction on the derivation of \u0393 \u22a2\n     \\x:S[1].t2 : T.  Cases T_Var, T_App, are vacuous as those\n     rules cannot be used to give a type to a syntactic abstraction.\n\n*   If the last step of the derivation is a use of T_Abs then\n           there is a type T[12] such that T = S[1] \u2192 T[12] and \u0393,\n           x:S[1] \u22a2 t[2] : T[12].  Picking T[12] for S[2] gives us what we\n           need: S[1] \u2192 T[12] <: S[1] \u2192 T[12] follows from S_Refl.\n\n*   If the last step of the derivation is a use of T_Sub then\n           there is a type S such that S <: T and \u0393 \u22a2 \\x:S[1].t2 :\n           S.  The IH for the typing subderivation tell us that there is\n           some type S[2] with S[1] \u2192 S[2] <: S and \u0393, x:S[1] \u22a2 t[2] :\n           S[2].  Picking type S[2] gives us what we need, since S[1] \u2192 S[2]\n           <: T then follows by S_Trans. \n\n```", "```\n\nSimilarly... \n\n```", "```\n\nThe inversion lemmas for typing and for subtyping between arrow\n    types can be packaged up as a useful \"combination lemma\" telling\n    us exactly what we'll actually require below. \n\n```", "```\n\n## Context Invariance\n\n The context invariance lemma follows the same pattern as in the\n    pure STLC. \n\n```", "```\n\n## Substitution\n\n The *substitution lemma* is proved along the same lines as\n    for the pure STLC.  The only significant change is that there are\n    several places where, instead of the built-in inversion tactic,\n    we need to use the inversion lemmas that we proved above to\n    extract structural information from assumptions about the\n    well-typedness of subterms. \n\n```", "```\n\n## Preservation\n\n The proof of preservation now proceeds pretty much as in earlier\n    chapters, using the substitution lemma at the appropriate point\n    and again using inversion lemmas from above to extract structural\n    information from typing assumptions. \n\n *Theorem* (Preservation): If t, t' are terms and T is a type\n    such that empty \u22a2 t : T and t \u21d2 t', then empty \u22a2 t' :\n    T.\n\n    *Proof*: Let t and T be given such that empty \u22a2 t : T.  We\n    proceed by induction on the structure of this typing derivation,\n    leaving t' general.  The cases T_Abs, T_Unit, T_True, and\n    T_False cases are vacuous because abstractions and constants\n    don't step.  Case T_Var is vacuous as well, since the context is\n    empty.\n\n*   If the final step of the derivation is by T_App, then there\n           are terms t[1] and t[2] and types T[1] and T[2] such that\n           t = t[1] t[2], T = T[2], empty \u22a2 t[1] : T[1] \u2192 T[2], and\n           empty \u22a2 t[2] : T[1].\n\n           By the definition of the step relation, there are three ways\n           t[1] t[2] can step.  Cases ST_App1 and ST_App2 follow\n           immediately by the induction hypotheses for the typing\n           subderivations and a use of T_App.\n\n           Suppose instead t[1] t[2] steps by ST_AppAbs.  Then t[1] =\n           \\x:S.t12 for some type S and term t[12], and t' =\n           [x:=t[2]]t[12].\n\n           By lemma abs_arrow, we have T[1] <: S and x:S[1] \u22a2 s[2] : T[2].\n           It then follows by the substitution lemma\n           (substitution_preserves_typing) that empty \u22a2 [x:=t[2]]\n           t[12] : T[2] as desired.\n\n    *   If the final step of the derivation uses rule T_If, then\n                there are terms t[1], t[2], and t[3] such that t = if t[1] then\n                t[2] else t[3], with empty \u22a2 t[1] : Bool and with empty \u22a2 t[2] :\n                T and empty \u22a2 t[3] : T.  Moreover, by the induction\n                hypothesis, if t[1] steps to t[1]' then empty \u22a2 t[1]' : Bool.\n                There are three cases to consider, depending on which rule was\n                used to show t \u21d2 t'.\n\n        *   If t \u21d2 t' by rule ST_If, then t' = if t[1]' then t[2]\n                         else t[3] with t[1] \u21d2 t[1]'.  By the induction hypothesis,\n                         empty \u22a2 t[1]' : Bool, and so empty \u22a2 t' : T by T_If.\n\n        *   If t \u21d2 t' by rule ST_IfTrue or ST_IfFalse, then\n                         either t' = t[2] or t' = t[3], and empty \u22a2 t' : T\n                         follows by assumption.\n\n*   If the final step of the derivation is by T_Sub, then there\n           is a type S such that S <: T and empty \u22a2 t : S.  The\n           result is immediate by the induction hypothesis for the typing\n           subderivation and an application of T_Sub.  \u2610 \n\n```", "```\n\n## Records, via Products and Top\n\n This formalization of the STLC with subtyping omits record\n    types for brevity.  If we want to deal with them more seriously,\n    we have two choices.\n\n    First, we can treat them as part of the core language, writing\n    down proper syntax, typing, and subtyping rules for them.  Chapter\n    RecordSub shows how this extension works.\n\n    On the other hand, if we are treating them as a derived form that\n    is desugared in the parser, then we shouldn't need any new rules:\n    we should just check that the existing rules for subtyping product\n    and Unit types give rise to reasonable rules for record\n    subtyping via this encoding. To do this, we just need to make one\n    small change to the encoding described earlier: instead of using\n    Unit as the base case in the encoding of tuples and the \"don't\n    care\" placeholder in the encoding of records, we use Top.  So:\n\n```", "```\n\n    The encoding of record values doesn't change at all.  It is\n    easy (and instructive) to check that the subtyping rules above are\n    validated by the encoding. \n\n## Exercises\n\n#### Exercise: 2 starsM (variations)\n\n Each part of this problem suggests a different way of changing the\n    definition of the STLC with Unit and subtyping.  (These changes\n    are not cumulative: each part starts from the original language.)\n    In each part, list which properties (Progress, Preservation, both,\n    or neither) become false.  If a property becomes false, give a\n    counterexample.\n\n*   Suppose we add the following typing rule:\n\n    | \u0393\u00a0\u22a2\u00a0t\u00a0:\u00a0S[1]->S[2] | \n \n     |\n    | S[1]\u00a0<:\u00a0t[1\u00a0\u00a0\u00a0\u00a0\u00a0T[1]\u00a0<:\u00a0s[1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0S[2]\u00a0<:\u00a0t[2]]] | \n     (T_Funny1) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | \u0393\u00a0\u22a2\u00a0t\u00a0:\u00a0T[1]->T[2] | \n \n     |\n\n*   Suppose we add the following reduction rule:\n\n    | \u00a0\u00a0 | \n     (ST_Funny21) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | unit\u00a0\u21d2\u00a0(\u03bbx:Top.\u00a0x) | \n \n     |\n\n*   Suppose we add the following subtyping rule:\n\n    | \u00a0\u00a0 | \n     (S_Funny3) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | Unit\u00a0<:\u00a0top->Top | \n \n     |\n\n*   Suppose we add the following subtyping rule:\n\n    | \u00a0\u00a0 | \n     (S_Funny4) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | Top->Top\u00a0<:\u00a0unit< td=\"\">\n    | \n \n     |\n\n*   Suppose we add the following reduction rule:\n\n    | \u00a0\u00a0 | \n     (ST_Funny5) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | (unit\u00a0t)\u00a0\u21d2\u00a0(t\u00a0unit) | \n \n     |\n\n*   Suppose we add the same reduction rule *and* a new typing rule:\n\n    | \u00a0\u00a0 | \n     (ST_Funny5) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | (unit\u00a0t)\u00a0\u21d2\u00a0(t\u00a0unit) | \n \n     |\n\n    | \u00a0\u00a0 | \n     (T_Funny6) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | empty\u00a0\u22a2\u00a0unit\u00a0:\u00a0Top->Top | \n \n     |\n\n*   Suppose we *change* the arrow subtyping rule to:\n\n    | S[1]\u00a0<:\u00a0t[1\u00a0S[2]\u00a0<:\u00a0t[2]] | \n     (S_Arrow') \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | S[1]->S[2]\u00a0<:\u00a0t[1->T[2]] | \n \n     |\n\n\u2610 \n\n# Exercise: Adding Products\n\n#### Exercise: 4 stars (products)\n\n Adding pairs, projections, and product types to the system we have\n    defined is a relatively straightforward matter.  Carry out this\n    extension:\n\n*   Below, we've added constructors for pairs, first and second\n          projections, and product types to the definitions of ty and\n          tm.\n\n*   Copy the definitions of the substitution function and value\n          relation from above and extend them as in chapter\n          [MoreSTLC](MoreSTLC.html) to include products.\n\n*   Similarly, copy and extend the operational semantics with the\n          same reduction rules as in chapter [MoreSTLC](MoreSTLC.html).\n\n*   (Copy and) extend the subtyping relation with this rule:\n\n    | S[1]\u00a0<:\u00a0t[1\u00a0S[2]\u00a0<:\u00a0t[2]] | \n     (Sub_Prod) \u00a0\n       |\n    |  \n    * * *\n\n     |\n    | S[1]\u00a0*\u00a0S[2]\u00a0<:\u00a0t[1\u00a0*\u00a0T[2]] | \n \n     |\n\n*   Extend the typing relation with the same rules for pairs and\n          projections as in chapter [MoreSTLC](MoreSTLC.html).\n\n*   Extend the proofs of progress, preservation, and all their\n          supporting lemmas to deal with the new constructs.  (You'll also\n          need to add a couple of completely new lemmas.) \n\n```", "```\n\n\u2610 \n\n```"]