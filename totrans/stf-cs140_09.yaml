- en: File Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lecture Notes for CS 140
  prefs: []
  type: TYPE_NORMAL
- en: Spring 2014
  prefs: []
  type: TYPE_NORMAL
- en: John Ousterhout
  prefs: []
  type: TYPE_NORMAL
- en: 'Readings for this topic from *Operating Systems: Principles and Practice*:
    Chapter 11, Section 13.3 (up through page 561).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Problems addressed by modern file systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disk Management:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast access to files (minimize seeks)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing space between users
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient use of disk space
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Naming: how do users select files?'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Protection: isolation between users, controlled sharing.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reliability: information must survive OS crashes and hardware failures.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'File: a named collection of bytes stored on durable storage such as disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'File access patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sequential: information is processed in order, one byte after another.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Random Access: can address any byte in the file directly without passing through
    its predecessors. E.g. the data set for demand paging, also databases.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keyed (or indexed): search for blocks with particular contents, e.g. hash table,
    associative database, dictionary. Usually provided by databases, not operating
    system.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Issues to consider:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most files are small (a few kilobytes or less), so per-file overheads must be
    low.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the disk space is in large files.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the I/O operations are for large files, so performance must be good
    for large files.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Files may grow unpredictably over time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: File Descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operating system data structure with information about a file (called *inode*
    in Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored on disk along with file data.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Kept in memory when file is open.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Info in file descriptor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sectors occupied by file
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: File size
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Access times (last read, last write)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Protection information (owner id, group id, etc.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How should disk sectors be used to represent the bytes of a file?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Contiguous allocation* (also called "extent-based"): allocate files like segmented
    memory (contiguous run of sectors). Keep a free list of unused areas of the disk.
    When creating a file, make the user specify its length, allocate all the space
    at once. Descriptor contains location and size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advantages:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy access, both sequential and random
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Few seeks
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drawbacks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragmentation will make it hard to use disk space efficiently; large files may
    be impossible
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hard to predict needs at file creation timeExample: IBM OS/360.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linked files*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Divide disk into fixed-sized blocks (512 bytes?)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a linked list of all free blocks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In file descriptor, just keep pointer to first block.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each block of file contains pointer to next block.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drawbacks?Examples (more or less): TOPS-10, Xerox Alto.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows FAT:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like linked allocation, except don't keep the links in the blocks themselves.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the links for all files in a single table called the *File Allocation Table*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Table is memory resident during normal operation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each FAT entry is disk sector number of next block in file
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Special values for "last block in file", "free block"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: File descriptor stores number of first block in file, size
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Originally, each FAT entry was 16 bits.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FAT32 supports larger disks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each entry has 28 bits of sector number
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Disk addresses refer to *clusters*: groups of adjacent sectors.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster sizes 2 - 32 KBytes; fixed for any particular disk partition.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Indexed files*: keep an array of block pointers for each file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum length must be declared for file when it is created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocate array to hold pointers to all the blocks, but don't allocate the blocks.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill in the pointers dynamically as file is written.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawbacks?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Multi-level indexes* (4.3 BSD Unix):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks are 4 Kbytes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: File descriptor = 14 block pointers, initially 0 ("no block").
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: First 12 point to data blocks (*direct blocks*).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next entry points to an *indirect block* (contains 1024 4-byte block pointers).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Last entry points to a *doubly-indirect block*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum file length is fixed, but large.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Indirect blocks aren't allocated until needed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Block Cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use part of main memory to retain recently-accessed disk blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LRU replacement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks that are referenced frequently (e.g., indirect blocks for large files)
    are usually in the cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This solves the problem of slow access to large files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Originally, block caches were fixed size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As memories have gotten larger, so have block caches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many systems now unify the block cache and the VM page pool: any page can be
    used for either, based on LRU access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when a block in the cache is modified?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Synchronous writes*: immediately write through to disk.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Safe: data won''t be lost if the machine crashes'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slow: process can''t continue until disk I/O completes'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'May be unnecessary:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Many small writes to the same block
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some files are deleted quickly (e.g., temporary files)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Delayed writes*: don''t immediately write to disk:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait a while (30 seconds?) in case there are more writes to a block or the block
    is deleted
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fast: writes return immediately'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dangerous: may lose data after a system crash'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Free Space Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managing disk free space: many early systems just used a linked list of free
    blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each block holds many pointers to free blocks, plus a pointer to the next block
    of pointers.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At the beginning, free list is sorted, so blocks in a file are allocated contiguously.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Free list quickly becomes scrambled, so files are spread all over disk.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '4.3 BSD approach to free space: *bit map*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep an array of bits, one per block.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 means block is free, 0 means block in use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: During allocation, search bit map for a block that's close to the previous block
    of the file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If disk isn't full, this usually works pretty well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If disk is nearly full this becomes very expensive and doesn't produce much
    locality.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: don''t let the disk fill up!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pretend disk has 10% less capacity than it really has
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If disk is 90% full, tell users it's full and don't allow any more data to be
    written.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Block Sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many early file systems (e.g. Unix) used a block size of 512 bytes (one sector).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inefficient I/O: more distinct transfers, hence more seeks.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bulkier file descriptors: only 128 pointers in an indirect block (pointers
    will occupy 1% of disk space).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase block size (e.g. 2KB clusters in FAT32)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4.3BSD solution: multiple block sizes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large blocks are 4 KBytes; most blocks are large
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fragments* are multiples of 512 bytes, fitting within a single large block'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The last block in a file can be a fragment.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One large block can hold fragments from multiple files.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bit map for free blocks is based on fragments.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk Scheduling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are several disk I/O's waiting to be executed, what is the best order
    in which to execute them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goal is to minimize seek time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*First come first served* (FCFS, FIFO): simple, but does nothing to optimize
    seeks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shortest seek time first* (SSTF):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose next request that is as close as possible to the previous one.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Good for minimizing seeks, but can result in starvation for some requests.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scan* ("elevator algorithm").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same as SSTF except heads keep moving in one direction across disk.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the edge of the disk has been reached, seek to the farthest block away
    and start again.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
