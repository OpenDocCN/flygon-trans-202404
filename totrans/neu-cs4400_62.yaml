- en: Variable MutationTuesday, February 28th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PLAI §12](plai.pdf#chapter.12 "Church and State") and [PLAI §13](plai.pdf#chapter.13
    "Mutable Data Structures") (different: adds boxes to the language)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PLAI §14](plai.pdf#chapter.14 "Variables") (that’s what we do)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The code that we now have implements recursion by *changing* bindings, and
    to make that possible we made environments hold boxes for all bindings, therefore
    bindings are *all* mutable now. We can use this to add more functionality to our
    evaluator, by allowing changing any variable — we can add a `set!` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: to the evaluator that will modify the value of a variable. To implement this
    functionality, all we need to do is to use `lookup` to retrieve some box, then
    evaluate the expression and put the result in that box. The actual implementation
    is left as a homework exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that should be considered here is — all of the expressions in our
    language evaluate to some value, the question is what should be the value of a
    `set!` expression? There are three obvious choices:'
  prefs: []
  type: TYPE_NORMAL
- en: return some bogus value,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: return the value that was assigned,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: return the value that was previously in the box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each one of these has its own advantage — for example, C uses the second option
    to `chain` assignments (eg, `x = y = 0`) and to allow side effects where an expression
    is expected (eg, `while (x = x-1) ...`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The third one is useful in cases where you might use the old value that is
    overwritten — for example, if C had this behavior, you could `pop` a value from
    a linked list using something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'because the argument to `first` will be the old value of `l`, before it changed
    to be its `rest`. You could also swap two variables in a single expression: `x
    = y = x`.'
  prefs: []
  type: TYPE_NORMAL
- en: (Note that the expression `x = x + 1` has the meaning of C’s `++x` when option
    (2) is used, and `x++` when option (3) is used.)
  prefs: []
  type: TYPE_NORMAL
- en: Racket chooses the first option, and we will do the same in our language. The
    advantage here is that you get no discounts, therefore you must be explicit about
    what values you want to return in situations where there is no obvious choice.
    This leads to more robust programs since you do not get other programmers that
    will rely on a feature of your code that you did not plan on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, the modification that introduces mutation is small, but it has
    a tremendous effect on our language: it was true for Racket, and it is true for
    FLANG. We have seen how mutation affects the language subset that we use, and
    in the extension of our FLANG the effect is even stronger: since *any* variable
    can change (there is no need for an explicit `box` value). In other words, a binding
    is not always the same — in can change as a result of a `set!` expression. Of
    course, we could extend our language with boxes (using Racket boxes to implement
    FLANG boxes), but that will be a little more verbose.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that Racket does have a `set!` form, and in addition, fields in structs
    can be made modifiable. However, we do not use any of these. At least not for
    now.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
