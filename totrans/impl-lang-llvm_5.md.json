["```\ndef fib(x)\n  if x < 3 then\n    1\n  else\n    fib(x-1)+fib(x-2); \n```", "```\n// control\ntok_if = -6, tok_then = -7, tok_else = -8,\nOnce we have that, we recognize the new keywords in the lexer. This is pretty simple stuff:\n\n...\nif (IdentifierStr == \"def\") return tok_def;\nif (IdentifierStr == \"extern\") return tok_extern;\nif (IdentifierStr == \"if\") return tok_if;\nif (IdentifierStr == \"then\") return tok_then;\nif (IdentifierStr == \"else\") return tok_else;\nreturn tok_identifier; \n```", "```\n/// IfExprAST - Expression class for if/then/else.\nclass IfExprAST : public ExprAST {\n  ExprAST *Cond, *Then, *Else;\npublic:\n  IfExprAST(ExprAST *cond, ExprAST *then, ExprAST *_else)\n    : Cond(cond), Then(then), Else(_else) {}\n  virtual Value *Codegen();\n}; \n```", "```\n/// ifexpr ::= 'if' expression 'then' expression 'else' expression\nstatic ExprAST *ParseIfExpr() {\n  getNextToken();  // eat the if.\n\n  // condition.\n  ExprAST *Cond = ParseExpression();\n  if (!Cond) return 0;\n\n  if (CurTok != tok_then)\n    return Error(\"expected then\");\n  getNextToken();  // eat the then\n\n  ExprAST *Then = ParseExpression();\n  if (Then == 0) return 0;\n\n  if (CurTok != tok_else)\n    return Error(\"expected else\");\n\n  getNextToken();\n\n  ExprAST *Else = ParseExpression();\n  if (!Else) return 0;\n\n  return new IfExprAST(Cond, Then, Else);\n} \n```", "```\nstatic ExprAST *ParsePrimary() {\n  switch (CurTok) {\n  default: return Error(\"unknown token when expecting an expression\");\n  case tok_identifier: return ParseIdentifierExpr();\n  case tok_number:     return ParseNumberExpr();\n  case '(':            return ParseParenExpr();\n  case tok_if:         return ParseIfExpr();\n  }\n} \n```", "```\nextern foo();\nextern bar();\ndef baz(x) if x then foo() else bar();\nIf you disable optimizations, the code you'll (soon) get from Kaleidoscope looks like this:\n\ndeclare double @foo()\n\ndeclare double @bar()\n\ndefine double @baz(double %x) {\nentry:\n  %ifcond = fcmp one double %x, 0.000000e+00\n  br i1 %ifcond, label %then, label %else\n\nthen:       ; preds = %entry\n  %calltmp = call double @foo()\n  br label %ifcont\n\nelse:       ; preds = %entry\n  %calltmp1 = call double @bar()\n  br label %ifcont\n\nifcont:     ; preds = %else, %then\n  %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ]\n  ret double %iftmp\n} \n```", "```\nValue *IfExprAST::Codegen() {\n  Value *CondV = Cond->Codegen();\n  if (CondV == 0) return 0;\n\n  // Convert condition to a bool by comparing equal to 0.0.\n  CondV = Builder.CreateFCmpONE(CondV,\n                              ConstantFP::get(getGlobalContext(), APFloat(0.0)),\n                                \"ifcond\");\nThis code is straightforward and similar to what we saw before. We emit the expression for the condition, then compare that value to zero to get a truth value as a 1-bit (bool) value.\n\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\n\n// Create blocks for the then and else cases.  Insert the 'then' block at the\n// end of the function.\nBasicBlock *ThenBB = BasicBlock::Create(getGlobalContext(), \"then\", TheFunction);\nBasicBlock *ElseBB = BasicBlock::Create(getGlobalContext(), \"else\");\nBasicBlock *MergeBB = BasicBlock::Create(getGlobalContext(), \"ifcont\");\n\nBuilder.CreateCondBr(CondV, ThenBB, ElseBB); \n```", "```\n// Emit then value.\nBuilder.SetInsertPoint(ThenBB);\n\nValue *ThenV = Then->Codegen();\nif (ThenV == 0) return 0;\n\nBuilder.CreateBr(MergeBB);\n// Codegen of 'Then' can change the current block, update ThenBB for the PHI.\nThenBB = Builder.GetInsertBlock(); \n```", "```\n// Emit else block.\nTheFunction->getBasicBlockList().push_back(ElseBB);\nBuilder.SetInsertPoint(ElseBB);\n\nValue *ElseV = Else->Codegen();\nif (ElseV == 0) return 0;\n\nBuilder.CreateBr(MergeBB);\n// Codegen of 'Else' can change the current block, update ElseBB for the PHI.\nElseBB = Builder.GetInsertBlock();\nCode generation for the 'else' block is basically identical to codegen for the 'then' block. The only significant difference is the first line, which adds the 'else' block to the function. Recall previously that the 'else' block was created, but not added to the function. Now that the 'then' and 'else' blocks are emitted, we can finish up with the merge code:\n\n  // Emit merge block.\n  TheFunction->getBasicBlockList().push_back(MergeBB);\n  Builder.SetInsertPoint(MergeBB);\n  PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(getGlobalContext()), 2,\n                                  \"iftmp\");\n\n  PN->addIncoming(ThenV, ThenBB);\n  PN->addIncoming(ElseV, ElseBB);\n  return PN;\n} \n```", "```\nextern putchard(char)\ndef printstar(n)\n  for i = 1, i < n, 1.0 in\n    putchard(42);  # ascii 42 = '*'\n\n# print 100 '*' characters\nprintstar(100); \n```", "```\n... in enum Token ...\n// control\ntok_if = -6, tok_then = -7, tok_else = -8,\ntok_for = -9, tok_in = -10\n\n... in gettok ...\nif (IdentifierStr == \"def\") return tok_def;\nif (IdentifierStr == \"extern\") return tok_extern;\nif (IdentifierStr == \"if\") return tok_if;\nif (IdentifierStr == \"then\") return tok_then;\nif (IdentifierStr == \"else\") return tok_else;\nif (IdentifierStr == \"for\") return tok_for;\nif (IdentifierStr == \"in\") return tok_in;\nreturn tok_identifier; \n```", "```\n/// ForExprAST - Expression class for for/in.\nclass ForExprAST : public ExprAST {\n  std::string VarName;\n  ExprAST *Start, *End, *Step, *Body;\npublic:\n  ForExprAST(const std::string &varname, ExprAST *start, ExprAST *end,\n             ExprAST *step, ExprAST *body)\n    : VarName(varname), Start(start), End(end), Step(step), Body(body) {}\n  virtual Value *Codegen();\n}; \n```", "```\n/// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression\nstatic ExprAST *ParseForExpr() {\n  getNextToken();  // eat the for.\n\n  if (CurTok != tok_identifier)\n    return Error(\"expected identifier after for\");\n\n  std::string IdName = IdentifierStr;\n  getNextToken();  // eat identifier.\n\n  if (CurTok != '=')\n    return Error(\"expected '=' after for\");\n  getNextToken();  // eat '='.\n\n  ExprAST *Start = ParseExpression();\n  if (Start == 0) return 0;\n  if (CurTok != ',')\n    return Error(\"expected ',' after for start value\");\n  getNextToken();\n\n  ExprAST *End = ParseExpression();\n  if (End == 0) return 0;\n\n  // The step value is optional.\n  ExprAST *Step = 0;\n  if (CurTok == ',') {\n    getNextToken();\n    Step = ParseExpression();\n    if (Step == 0) return 0;\n  }\n\n  if (CurTok != tok_in)\n    return Error(\"expected 'in' after for\");\n  getNextToken();  // eat 'in'.\n\n  ExprAST *Body = ParseExpression();\n  if (Body == 0) return 0;\n\n  return new ForExprAST(IdName, Start, End, Step, Body);\n} \n```", "```\ndeclare double @putchard(double)\n\ndefine double @printstar(double %n) {\nentry:\n  ; initial value = 1.0 (inlined into phi)\n  br label %loop\n\nloop:       ; preds = %loop, %entry\n  %i = phi double [ 1.000000e+00, %entry ], [ %nextvar, %loop ]\n  ; body\n  %calltmp = call double @putchard(double 4.200000e+01)\n  ; increment\n  %nextvar = fadd double %i, 1.000000e+00\n\n  ; termination test\n  %cmptmp = fcmp ult double %i, %n\n  %booltmp = uitofp i1 %cmptmp to double\n  %loopcond = fcmp one double %booltmp, 0.000000e+00\n  br i1 %loopcond, label %loop, label %afterloop\n\nafterloop:      ; preds = %loop\n  ; loop always returns 0.0\n  ret double 0.000000e+00\n} \n```", "```\nValue *ForExprAST::Codegen() {\n  // Emit the start code first, without 'variable' in scope.\n  Value *StartVal = Start->Codegen();\n  if (StartVal == 0) return 0; \n```", "```\n// Make the new basic block for the loop header, inserting after current\n// block.\nFunction *TheFunction = Builder.GetInsertBlock()->getParent();\nBasicBlock *PreheaderBB = Builder.GetInsertBlock();\nBasicBlock *LoopBB = BasicBlock::Create(getGlobalContext(), \"loop\", TheFunction);\n\n// Insert an explicit fall through from the current block to the LoopBB.\nBuilder.CreateBr(LoopBB); \n```", "```\n// Start insertion in LoopBB.\nBuilder.SetInsertPoint(LoopBB);\n\n// Start the PHI node with an entry for Start.\nPHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(getGlobalContext()), 2, VarName.c_str());\nVariable->addIncoming(StartVal, PreheaderBB); \n```", "```\n// Within the loop, the variable is defined equal to the PHI node.  If it\n// shadows an existing variable, we have to restore it, so save it now.\nValue *OldVal = NamedValues[VarName];\nNamedValues[VarName] = Variable;\n\n// Emit the body of the loop.  This, like any other expr, can change the\n// current BB.  Note that we ignore the value computed by the body, but don't\n// allow an error.\nif (Body->Codegen() == 0)\n  return 0; \n```", "```\n// Emit the step value.\nValue *StepVal;\nif (Step) {\n  StepVal = Step->Codegen();\n  if (StepVal == 0) return 0;\n} else {\n  // If not specified, use 1.0.\n  StepVal = ConstantFP::get(getGlobalContext(), APFloat(1.0));\n}\n\nValue *NextVar = Builder.CreateFAdd(Variable, StepVal, \"nextvar\"); \n```", "```\n// Compute the end condition.\nValue *EndCond = End->Codegen();\nif (EndCond == 0) return EndCond;\n\n// Convert condition to a bool by comparing equal to 0.0.\nEndCond = Builder.CreateFCmpONE(EndCond,\n                            ConstantFP::get(getGlobalContext(), APFloat(0.0)),\n                                \"loopcond\"); \n```", "```\n// Create the \"after loop\" block and insert it.\nBasicBlock *LoopEndBB = Builder.GetInsertBlock();\nBasicBlock *AfterBB = BasicBlock::Create(getGlobalContext(), \"afterloop\", TheFunction);\n\n// Insert the conditional branch into the end of LoopEndBB.\nBuilder.CreateCondBr(EndCond, LoopBB, AfterBB);\n\n// Any new code will be inserted in AfterBB.\nBuilder.SetInsertPoint(AfterBB); \n```", "```\n // Add a new entry to the PHI node for the backedge.\n  Variable->addIncoming(NextVar, LoopEndBB);\n\n  // Restore the unshadowed variable.\n  if (OldVal)\n    NamedValues[VarName] = OldVal;\n  else\n    NamedValues.erase(VarName);\n\n  // for expr always returns 0.0.\n  return Constant::getNullValue(Type::getDoubleTy(getGlobalContext()));\n} \n```"]