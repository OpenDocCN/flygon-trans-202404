- en: Introduction to FRP in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Say that we wanted to write some JavaScript (pseudo)code to keep track of whether
    the user is currently pressing the mouse button. We might start by defining a
    mutable variable, and then installing two "callback" functions that get invoked
    by the JavaScript run-time system when the `mousedown` and `mouseup` events are
    triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '(Note: The point of this example is to make plain the structure of managing
    the state, so we will avoid the natural urge to refactor.)'
  prefs: []
  type: TYPE_NORMAL
- en: This is quite a roundabout way of implementing what can be described simply
    as "a boolean that is `true` only when the mouse button is being pressed." Matters
    quickly become more complicated when managing state that depends on multiple events
    and multiple intermediate computations.
  prefs: []
  type: TYPE_NORMAL
- en: '*Functional reactive programming (FRP)* is a paradigm that allows *time-varying*
    values (such as `isDown`) to be implemented directly using the building blocks
    of functional programming, rather than resorting to using mutation and callbacks
    as above.'
  prefs: []
  type: TYPE_NORMAL
- en: '[What is a Signal?](http://elm-lang.org/learn/What-is-FRP.elm)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"A *signal* is a value that changes over time." In Elm, [`Mouse.isDown`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Mouse)
    is a primitive signal provided by the language that has type `Signal Bool`. We
    get to treat `isDown` as if it always refers to the "current" value, without worrying
    about the low-level details of how it gets updated.'
  prefs: []
  type: TYPE_NORMAL
- en: Better still, we can *abstract over* and *compose* signals using the building
    blocks of functional programing. For example, we can use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: to "lift" the pure function `not`, which negates `Bool`s, to operate on the
    current value of `isDown` as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'or, more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result is a signal of boolean values (of type `Signal Bool`) that updates
    whenever the `Mouse.isDown` signal updates. How cool is that?
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, the behavior and type of `Signal.map` is analogous to
    mapping functions that operate on other kinds of data — [`List.map`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/List),
    [`String.map`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/String),
    [`Maybe.map`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Maybe),
    [`Dict.map`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Dict), etc.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering to HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing to an HTML window is the primary *effect* that Elm programs can affect.
    The `main` definition in an Elm module specifies what to render, and this something
    takes the form of an `Element` value, a type defined in the [`Graphics.Element`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Graphics-Element)
    library.
  prefs: []
  type: TYPE_NORMAL
- en: The `elm-repl` comes in handy when testing out programs that do not render anything
    to HTML (notice that we did not have to define `main` in those cases). But now
    you will want to try out these examples in the browser — either by compiling Elm
    source files with `elm-make` (see [HW0](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/assignments/HW0.html)
    for a refresher); using the live editor [online](http://elm-lang.org/try); or
    building the [Elm website](https://github.com/elm-lang/elm-lang.org) locally so
    that you can run your own live editor without an Intnet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In addition to providing many functions for manipulating text, the [`Text`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Text)
    library provides `plainText` to convert a `String` to an `Element`, which is the
    type of value we need to provide `main` in order to render. Notice also that `import`
    statements are used to load names of types (e.g. `Element`) as well as values
    (e.g. `plainText`) into scope.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, because we will often want to change what is rendered over time, a
    `main` definition is actually a *signal* of `Element`s (i.e. of type `Signal Element`).
    When `main` is defined to be an expression `e` of type `Element` rather than `Signal
    Element`, it is interpreted as signal `Signal.constant e`, where the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'turns a pure value into a `Signal`, one that is constant. So we could have
    written the more explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve introduced ourselves to the world, let''s write something slightly
    more interesting to the window, say, whether or not the mouse button is currently
    being pressed. For this, we make use of the `toString` function in [`Basics`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Basics):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Try this out and click around. You can also play with [the official IsDown example](http://elm-lang.org/edit/examples/Reactive/IsDown.elm).
  prefs: []
  type: TYPE_NORMAL
- en: A Word About Imports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notice that most libraries, even pretty common ones, require explicit `import`s.
    I think this will be especially handy when learning the language, because it will
    require carefully understanding the structure and purposes of the libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that, in the example above, I've chosen to mix and match qualified
    and unqualified `imports`. As you develop experience writing Elm code, you will
    find a style of `import`s that works for you. This will depend on factors such
    as how many functions you plan to use from a given module — I don't know about
    you, but I'm planning to go crazy with the [`Mouse`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Mouse)
    library and I don't want to list all of its definitions explictly — as well as
    how unique imported names are — `plainText` is much less likely than, say, `map`
    to be defined by other imported modules, so using `plainText` without qualification
    seems like a good choice to me.
  prefs: []
  type: TYPE_NORMAL
- en: A Word About Function Composition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Depending on your prior experience and tastes, you may prefer to scrap the anonymous
    lambda in the `main` definition above in favor of one that emphasizes function
    composition, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All of these definitions are equivalent, so choose a style that you like best
    and that fits well within the code around it.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that [`Basics`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Basics)
    defines these infix operators. Take a look also at [`Text.asText`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Text),
    which is similar to `(plainText << toString)`.
  prefs: []
  type: TYPE_NORMAL
- en: Folding From the Past
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now consider a slightly more interesting example, to count and display
    the number of times the user has clicked a mouse button. There is no such signal
    built in to Elm, so we will define our own in terms of the signals that are provided.
  prefs: []
  type: TYPE_NORMAL
- en: One option is to build on the mouse click event, which is separate but closely
    related to the mouse-down event we have seen. For this, Elm provides the primitive
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: which produces the dummy "unit" value (written `()`) of the dummy "unit" type
    (also written `()`) for every mouse button click. Releasing a button does not
    trigger an update to this signal.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Model-View-Controller Architecture
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to build a `Signal` of `Element`s to render, it is often convenient
    to factor the work intro three parts.
  prefs: []
  type: TYPE_NORMAL
- en: The *model* keeps track of all the information that is needed to produce the
    desired result. We may be sloppy and sometimes (actually, often) refer to the
    model as the *state*, but let us not be tricked into thinking there is anything
    mutable at the source level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to display the number of clicks, all we need to maintain is an integer
    counter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The use of the `alias` keyword defines `State` to be completely synonymous with
    `Int`; it is simply a shorthand and does not define a new type. Type aliases can
    be used to abbreviate long types as well as to give an indication about the intended
    use of the type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The *view* defines how to render the model to the screen. In this case, it''s
    rather simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, more succinctly:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The *controller* defines the connection between a signal and a function that
    transforms and renders the state when the signal updates. For this, we use the
    function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'to apply a folding function to *all* values (of type `a`) ever produced by
    the signal, starting with some initial state (of type `b`), and turning it into
    a signal of state values (of type `b`). This is, in fact, the same fold pattern
    as provided for other datatypes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For `Signal`, this operation is called "folding from the past" rather than "from
    the left". Folding "from the right" would mean folding "from the future"...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To finish our task, we define a folding function `step` and then put everything
    together in `main` as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Download this program as [`IntroFRP.elm`](https://www.classes.cs.uchicago.edu/archive/2015/winter/22300-1/public-code/IntroFRP.elm)
    and [try](http://elm-lang.org/try) it out. You can also take a look at [the CountClicks
    example](http://elm-lang.org/edit/examples/Reactive/CountClicks.elm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Something to consider: could we have implemented this functionality by using
    the `Mouse.isDown` signal rather than `Mouse.clicks`?'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, say we wanted to track the passage of time rather than the number of
    clicks. By factoring our `main` definition into the generic form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'we can implement this with a minor tweak of the previous definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Check out the [`Time`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Time)
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Wait a minute...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We are factoring our Elm code into models, views, and controllers just like
    in the JavaScript code we started with. So, what have we really gained?
  prefs: []
  type: TYPE_NORMAL
- en: Well, in JavaScript, we would write logic in event handlers to determine which
    parts of the state need to be updated for different events. In Elm, we define
    new signals directly as functions of existing ones, and we leave it to the Elm
    compiler and run-time to figure out how and when to recompute signal values that
    are derived from more primitive ones. So, we have gained a lot!
  prefs: []
  type: TYPE_NORMAL
- en: 'This begs the question: how will the compiler figure this all out?'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling to JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Elm compiler is left with the responsibility to generate target JavaScript
    that manages mutable state and event handlers, similar to the pseudocode we started
    with. A way to understand the structure of an Elm program is to think of a *signal
    graph*, where nodes are units of computation and edges indicate the flow of values.
    The incoming edges to a signal graph are the "primitive" JavaScript signals, or
    events, such as mouse-down, mouse-up, mouse-click, etc. The rest of the graph
    constitutes a pure function defined in terms of these primitive signals.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, a naive approach would be to recompute the *entire* program based
    on changes to *any* signal. This would, of course, be inefficient and is also
    unnecessary, because many parts of the signal graph are likely to be independent
    of changes to many primitive signals.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the compiler tracks dependencies in the signal graph and uses a concurrent
    message-passing system to more efficiently recompute only those parts of a program
    that depend on changes to primitive signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not go into any of the details of the compilation process, but you
    can find more information about it in the Reading links posted below. At a basic
    level, however, our intuitions for how the process might work should resemble
    our intuitions about how optimizing compilers for functional languages (even without
    FRP) work: a source language may be purely functional with immutable data structures
    being copied all over the place, but we know that, below the hood, the compiler
    is working to identify opportunities to reuse and cache previously computed results.
    In fact, we will see much more of this principle in the coming weeks as we study
    how to realize efficient data structures in purely functional languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 2D Graphics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`Graphics.Element`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Graphics-Element)
    library defines an API for laying out text, images, and other `Element`s. In addition,
    the [`Graphics.Collage`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Graphics-Collage)
    library provides tools for defining freeform graphics, comprising shapes, lines,
    colors, etc. Start exploring by going through the 2D Shapes examples on the [Elm
    Examples page](http://elm-lang.org/Examples.elm). Homework 1 will provide a reason
    to really dig in.
  prefs: []
  type: TYPE_NORMAL
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Required
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Libraries: [`Signal`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Signal),
    [`Graphics.Element`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Graphics-Element),
    [`Graphics.Collage`](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/Graphics-Collage).
    As you peruse the `Signal` library, notice how the `isUp` function can be rewritten
    using a handy infix operator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '"Pass the `Mouse.isDown` signal through the `not` function."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recommended
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Look through more of the [Elm Examples](http://elm-lang.org/Examples.elm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look through more of the [Standard Libraries](http://package.elm-lang.org/packages/elm-lang/core/1.0.0/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a more comprehensive background on FRP and introduction to Elm, you may
    want to skim parts of Evan Czaplicki's
  prefs: []
  type: TYPE_NORMAL
- en: '[Senior Thesis](http://elm-lang.org/papers/concurrent-frp.pdf) and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PLDI 2013 paper](http://people.seas.harvard.edu/~chong/pubs/pldi13-elm.pdf)
    with [Stephen Chong](http://people.seas.harvard.edu/~chong/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will find that some terminology and language features have since changed
    (e.g. `Signal.lift` is now called `Signal.map`). You will also find detailed explanation
    of the compilation process that we will not cover in this class.
  prefs: []
  type: TYPE_NORMAL
