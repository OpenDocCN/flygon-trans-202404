["```\n(define (foo x)\n  (define a 5)\n  (+ x a)) \n```", "```\n-> ((lambda (x y z) (+ x y x z)) 1 2 3)\n7 \n```", "```\n-> (let ((x 1) (y 2) (z 3)) (+ x y x z))\n7 \n```", "```\n(define (f x y)\n  (+ (* x (+ 1 (square (* x y)))) (* y (- 1 y)) (* (+ 1 (* x y)) (- 1 y)))) \n```", "```\n(define (f x y)\n    (define (f-helper a b)\n        (+ (* x (square a))\n           (* y b)\n           (* a b)))\n    (f-helper (+ 1 (* x y))\n              (- 1 y))) \n```", "```\n(define (f x y)\n    ((lambda (a b)\n        (+ (* x (square a))\n           (* y b)\n           (* a b)))\n    (+ 1 (* x y))\n    (- 1 y))) \n```", "```\n(define (f x y)\n   (let ((a (+ 1 (* x y)))\n         (b (- 1 y)))\n     (+ (* x (square a)) (* y b) (* a b)))) \n```", "```\n(let ((<var1> <exp1>)\n      (<var2> <exp2>)\n      ...\n      (<varn> <expn>))\n  <body>) \n```", "```\n((lambda (<var1> <var2> ... <varn>) <body>)\n  <exp1> <exp2> ... <expn> ) \n```", "```\n(define y 10)  \n\n(let ((y 0)) y) ;; notice that let overrides global vars  \n\n(let ((x 10)  \n      (z x))   \n    z) ;; this will break, translate to lambda to see why  \n\n(let ((a 1))  \n  (let ((a 2))  \n    (let ((a 3))  \n       a))) ;; nested lets are valid.   \n\n(let ((test 'wait-what?))  \n  5)  \ntest  ;; let only binds variables inside its body  \n\n(let ((a 1))  \n  (+ a (let ((a 2))  \n    (+ a (let ((a 3))  \n            a))))) ;; challenge: figure out what that last one returns, before checking interpreter \n```"]