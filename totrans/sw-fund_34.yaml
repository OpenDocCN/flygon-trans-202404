- en: 'UseTacticsTactic Library for Coq: A Gentle Introduction'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于Coq的UseTacticsTactic库：温和介绍
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: (* Chapter written and maintained by Arthur Chargueraud *)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: (* 由Arthur Chargueraud编写和维护的章节*)
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Require Import Coq.Arith.Arith.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Coq.Arith.Arith。
- en: Require Import Maps.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Maps。
- en: Require Import Imp.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Imp。
- en: Require Import Types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Types。
- en: Require Import Smallstep.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Smallstep。
- en: Require Import LibTactics.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 导入LibTactics。
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tactics for Introduction and Case Analysis
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍和案例分析策略
- en: 'This section presents the following tactics:'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节介绍以下策略：
- en: introv, for naming hypotheses more efficiently,
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: introv，用于更有效地命名假设，
- en: inverts, for improving the inversion tactic,
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: inverts，用于改进反演策略，
- en: cases, for performing a case analysis without losing information,
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cases，用于执行案例分析而不丢失信息，
- en: cases_if, for automating case analysis on the argument of if.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cases_if，用于自动化对if参数进行案例分析。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Module IntrovExamples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模块IntrovExamples。
- en: Require Import Stlc.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Stlc。
- en: Import Imp.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Imp。
- en: Import STLC.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 导入STLC。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 定理ceval_deterministic：∀c st st[1] st[2]，
- en: c / st ⇓ st[1] →
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st[1] →
- en: c / st ⇓ st[2] →
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st[2] →
- en: st[1] = st[2].
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: st[1] = st[2]。
- en: Proof.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: introv E[1] E[2]. (* was intros c st st[1] st[2] E[1] E[2] *)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: introv E[1] E[2]. (* was intros c st st[1] st[2] E[1] E[2] *)
- en: Abort.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Theorem dist_exists_or : ∀(X:Type) (P Q : X → Prop),'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '定理dist_exists_or：∀(X:Type) (P Q : X → Prop)，'
- en: (∃x, P x ∨ Q x) ↔ (∃x, P x) ∨ (∃x, Q x).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: (∃x，P x ∨ Q x) ↔ (∃x，P x) ∨ (∃x，Q x)。
- en: Proof.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: introv. (* was intros X P Q *)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: introv。(* was intros X P Q *)
- en: Abort.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Theorem ceval_deterministic'': ∀c st st[1],'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 定理ceval_deterministic'：∀c st st[1]，
- en: (c / st ⇓ st[1]) → ∀st[2], (c / st ⇓ st[2]) → st[1] = st[2].
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (c / st ⇓ st[1]) → ∀st[2]，(c / st ⇓ st[2]) → st[1] = st[2]。
- en: Proof.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: introv E[1] E[2]. (* was intros c st st[1] E[1] st[2] E[2] *)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: introv E[1] E[2]. (* was intros c st st[1] E[1] st[2] E[2] *)
- en: Abort.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Theorem exists_impl: ∀X (P : X → Prop) (Q : Prop) (R : Prop),'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '定理exists_impl：∀X (P : X → Prop) (Q : Prop) (R : Prop)，'
- en: (∀x, P x → Q) →
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (∀x，P x → Q) →
- en: ((∃x, P x) → Q).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ((∃x，P x) → Q)。
- en: Proof.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: introv [x H[2]]. eauto.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: introv [x H[2]]。eauto。
- en: (* same as intros X P Q R H[1] [x H[2]]., which is itself short      for intros
    X P Q R H[1] H[2]. destruct H[2] as [x H[2]]. *)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: (* same as intros X P Q R H[1] [x H[2]].，这本身是intros X P Q R H[1] H[2]的简写。destruct
    H[2] as [x H[2]]。*)
- en: Qed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: End IntrovExamples.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 模块IntrovExamples。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Module InvertsExamples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 模块InvertsExamples。
- en: Require Import Stlc.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Stlc。
- en: Require Import Equiv.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Equiv。
- en: Require Import Imp.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 导入Imp。
- en: Import STLC.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 导入STLC。
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Theorem skip_left: ∀c,'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 定理skip_left：∀c，
- en: cequiv (SKIP;; c) c.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: cequiv (SKIP;; c) c。
- en: Proof.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: introv. split; intros H.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: introv。分割；引入H。
- en: dup. (* duplicate the goal for comparison *)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: dup。(* 复制目标以进行比较*)
- en: (* was... *)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: (* was... *)
- en: '- inversion H. subst. inversion H[2]. subst. assumption.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反演H。替换。反演H[2]。替换。假设。'
- en: (* now... *)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: (* 现在... *)
- en: '- inverts H. inverts H[2]. assumption.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反演H。反演H[2]。假设。'
- en: Abort.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 定理ceval_deterministic：∀c st st[1] st[2]，
- en: c / st ⇓ st[1]  →
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st[1] →
- en: c / st ⇓ st[2] →
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st[2] →
- en: st[1] = st[2].
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: st[1] = st[2]。
- en: Proof.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: introv E[1] E[2]. generalize dependent st[2].
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: introv E[1] E[2]。推广依赖于st[2]。
- en: induction E[1]; intros st[2] E[2].
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对E[1]进行归纳；引入st[2]和E[2]。
- en: admit. admit. (* skip some basic cases *)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 承认。承认。(* 跳过一些基本情况*)
- en: dup. (* duplicate the goal for comparison *)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: dup。(* 复制目标以进行比较*)
- en: (* was: *)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: (* was: *)
- en: '- inversion E[2]. subst. admit.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反演E[2]。替换。承认。'
- en: (* now: *)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (* 现在：*)
- en: '- inverts E[2]. admit.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '- 反演E[2]。承认。'
- en: Abort.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Theorem ceval_deterministic'': ∀c st st[1] st[2],'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 定理ceval_deterministic'：∀c st st[1] st[2]，
- en: c / st ⇓ st[1]  →
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st[1] →
- en: c / st ⇓ st[2] →
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st[2] →
- en: st[1] = st[2].
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: st[1] = st[2]。
- en: Proof.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: introv E[1] E[2]. generalize dependent st[2].
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: introv E[1] E[2]。推广依赖于st[2]。
- en: (induction E[1]); intros st[2] E[2];
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (对E[1]进行归纳)；引入st[2]和E[2]；
- en: inverts E[2] as.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 反演E[2]为。
- en: '- (* E_Skip *) reflexivity.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E_Skip *) reflexivity.'
- en: '- (* E_Ass *)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E_Ass *)'
- en: (* Observe that the variable n is not automatically        substituted because, contrary to inversion
    E[2]; subst,        the tactic inverts E[2] does not substitute the equalities
           that exist before running the inversion. *)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: (* 请注意，变量n不会自动替换，因为与inversion E[2]; subst相反，tactic inverts E[2]在运行反演之前不会替换存在的等式。*)
- en: (* new: *) subst n.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: (* new: *) 替换n。
- en: reflexivity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 反演。
- en: '- (* E_Seq *)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* E_Seq *)'
- en: (* Here, the newly created variables can be introduced        using intros, so they can be assigned meaningful names,
           for example st[3] instead of st'0. *)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里，新创建的变量可以通过intros引入，这样它们可以被赋予有意义的名称，例如st[3]而不是st'0。*)
- en: (* new: *) intros st[3] Red1 Red2.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (* new: *) 引入st[3] Red1 Red2。
- en: assert (st' = st[3]) as EQ[1].
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 断言(st' = st[3])为EQ[1]。
- en: '{ (* Proof of assertion *) apply IHE1_1; assumption. }'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '{ (* 断言的证明*)应用IHE1_1；假设。}'
- en: subst st[3].
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 替换st[3]。
- en: apply IHE1_2. assumption.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 应用IHE1_2。假设。
- en: (* E_IfTrue *)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (* E_IfTrue *)
- en: '- (* b[1] reduces to true *)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: (* In an easy case like this one, there is no need to        provide meaningful names, so we can just use intros *)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) intros.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: apply IHE1. assumption.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b[1] reduces to false (contradiction) *)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) intros.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H in H[5]. inversion H[5].
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: (* The other cases are similiar *)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Theorem skip_left'': ∀c,'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: cequiv (SKIP;; c) c.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: introv. split; intros H.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as U V. (* new hypotheses are named U and V *)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: inverts U. assumption.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Example typing_nonexample_1 :'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: ¬ ∃T,
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: (tabs x TBool
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: (tabs y TBool
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: (tapp (tvar x) (tvar y))))
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: T.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: dup 3.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: (* The old proof: *)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '- intros C. destruct C.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. subst. clear H.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[5]. subst. clear H[5].
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[4]. subst. clear H[4].
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[2]. subst. clear H[2].
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[5]. subst. clear H[5].
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[1].
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof: *)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '- intros C. destruct C.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H[1].
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: inverts H[1] as H[2].
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: inverts H[2] as H[3].
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: inverts H[3] as H[4].
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: inverts H[4].
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof, alternative: *)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '- intros C. destruct C.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: inverts H.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: End InvertsExamples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tactics for N-ary Connectives
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Coq encodes conjunctions and disjunctions using binary
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors ∧ and ∨, working with a conjunction or a
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: disjunction of N facts can sometimes be quite cumbursome.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this reason, "LibTactics" provides tactics offering direct
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: support for n-ary conjunctions and disjunctions. It also provides
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: direct support for n-ary existententials.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This section presents the following tactics:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: splits for decomposing n-ary conjunctions,
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: branch for decomposing n-ary disjunctions,
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∃ for proving n-ary existentials.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Tactic splits
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic splits applies to a goal made of a conjunction
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of n propositions and it produces n subgoals. For example,
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it decomposes the goal G[1] ∧ G[2] ∧ G[3] into the three subgoals
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: G[1], G[2] and G[3].
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Tactic branch
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic branch k can be used to prove a n-ary disjunction.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, if the goal takes the form G[1] ∨ G[2] ∨ G[3],
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the tactic branch 2 leaves only G[2] as subgoal. The following
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example illustrates the behavior of the branch tactic.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The Tactic ∃
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library "LibTactics" introduces a notation for n-ary
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: existentials. For example, one can write ∃ x y z, H
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: instead of ∃ x, ∃ y, ∃ z, H. Similarly,
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the library provides a n-ary tactic ∃ a b c, which is a
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: shorthand for ∃ a; ∃ b; ∃ c. The following
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example illustrates both the notation and the tactic for
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dealing with n-ary existentials.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Remark: a similar facility for n-ary existentials is provided'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by the module Coq.Program.Syntax from the standard library.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (Coq.Program.Syntax supports existentials up to arity 4;
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LibTactics supports them up to arity 10.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tactics for Working with Equality
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major weakness of Coq compared with other interactive
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof assistants is its relatively poor support for reasoning
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with equalities. The tactics described next aims at simplifying
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pieces of proof scripts manipulating equalities.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This section presents the following tactics:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: asserts_rewrite for introducing an equality to rewrite with,
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cuts_rewrite, which is similar except that its subgoals are swapped,
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: substs for improving the subst tactic,
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fequals for improving the f_equal tactic,
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: applys_eq for proving P x y using an hypothesis P x z, automatically producing
    an equality y = z as subgoal.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Tactics asserts_rewrite and cuts_rewrite
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic asserts_rewrite (E[1] = E[2]) replaces E[1] with E[2] in
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the goal, and produces the goal E[1] = E[2].
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The tactic cuts_rewrite (E[1] = E[2]) is like
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: asserts_rewrite (E[1] = E[2]), except that the equality E[1] = E[2]
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: appears as first subgoal.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: More generally, the tactics asserts_rewrite and cuts_rewrite
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can be provided a lemma as argument. For example, one can write
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: asserts_rewrite (∀ a b, a*(S b) = a*b+a).
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This formulation is useful when a and b are big terms,
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: since there is no need to repeat their statements.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Tactic substs
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic substs is similar to subst except that it
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: does not fail when the goal contains "circular equalities",
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: such as x = f x.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Tactic fequals
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic fequals is similar to f_equal except that it
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: directly discharges all the trivial subgoals produced. Moreover,
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the tactic fequals features an enhanced treatment of equalities
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: between tuples.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Tactic applys_eq
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic applys_eq is a variant of eapply that introduces
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equalities for subterms that do not unify. For example, assume
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the goal is the proposition P x y and assume we have the
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assumption H asserting that P x z holds. We know that we can
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: prove y to be equal to z. So, we could call the tactic
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert_rewrite (y = z) and change the goal to P x z, but
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this would require copy-pasting the values of y and z.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the tactic applys_eq, we can call applys_eq H 1, which
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proves the goal and leaves only the subgoal y = z. The value 1
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given as argument to applys_eq indicates that we want an equality
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to be introduced for the first argument of P x y counting from
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the right. The three following examples illustrate the behavior
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of a call to applys_eq H 1, a call to applys_eq H 2, and a
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: call to applys_eq H 1 2.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the mismatch was on the first argument of P instead of
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the second, we would have written applys_eq H 2. Recall
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that the occurences are counted from the right.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When we have a mismatch on two arguments, we want to produce
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: two equalities. To achieve this, we may call applys_eq H 1 2.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More generally, the tactic applys_eq expects a lemma and a
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sequence of natural numbers as arguments.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Some Convenient Shorthands
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section of the tutorial introduces a few tactics
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'that help make proof scripts shorter and more readable:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfolds (without argument) for unfolding the head definition,
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: false for replacing the goal with False,
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gen as a shorthand for dependent generalize,
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: skip for skipping a subgoal even if it contains existential variables,
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sort for re-ordering the proof context by moving moving all propositions at
    the bottom.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Module UnfoldsExample.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Hoare.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Lemma bexp_eval_true : ∀b st,'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: beval st b = true → (bassn b) st.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: intros b st Hbe. dup.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: (* The old proof: *)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: unfold bassn. assumption.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof: *)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: unfolds. assumption.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: End UnfoldsExample.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lemma demo_false :'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: ∀n, S n = 1 → n = 0.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: intros. destruct n. reflexivity. false.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Lemma demo_false_arg :'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, n < 0 → False) → (3 < 0) → 4 < 0.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: intros H L. false H. apply L.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Lemma demo_tryfalse :'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: ∀n, S n = 1 → n = 0.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: intros. destruct n; tryfalse. reflexivity.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Module GenExample.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Import STLC.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: has_type (update Γ x U) t S →
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty v U →
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ ([x:=v]t) S.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: dup.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: (* The old proof: *)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: intros Γ x U v t S Htypt Htypv.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent S. generalize dependent Γ.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: induction t; intros; simpl.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: admit. admit. admit. admit. admit. admit.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof: *)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: introv Htypt Htypv. gen S Γ.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: induction t; intros; simpl.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: admit. admit. admit. admit. admit. admit.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: End GenExample.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Module SkipExample.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Import STLC.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Notation " t '/' st '⇒a*' t' " := (multi (astep st) t t')
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Example astep_example1 :'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: (APlus (ANum 3) (AMult (ANum 3) (ANum 4))) / empty_state ⇒[a]* (ANum 15).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: eapply multi_step. skip. (* the tactic admit would not work here *)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: eapply multi_step. skip. skip.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: (* Note that because some unification variables have      not been instantiated, we still need to write
         Abort instead of Qed at the end of the proof. *)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Theorem demo_skipH : True.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'skip H: (∀n m : nat, (0 + n) * m = n * m).'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Theorem mult_0_plus : ∀n m : nat,'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: (0 + n) * m = n * m.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: dup.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: (* The old proof: *)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: intros n m.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (H: 0 + n = n). skip. rewrite → H.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof: *)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: intros n m.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: skip_rewrite (0 + n = n).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1] →
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[2] →
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: st[1] = st[2].
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: (* The tactic skip_goal creates an hypothesis called IH      asserting that the statment of ceval_deterministic is true. *)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: skip_goal.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: (* Of course, if we call assumption here, then the goal is solved      right away, but the point is to do the proof and use IH
         only at the places where we need an induction hypothesis. *)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: introv E[1] E[2]. gen st[2].
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: (induction E[1]); introv E[2]; inverts E[2] as.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Skip *) reflexivity.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Ass *)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: subst n.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Seq *)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: intros st[3] Red1 Red2.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: assert (st' = st[3]) as EQ[1].
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* Proof of assertion *)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: (* was: apply IHE1_1; assumption. *)
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) eapply IH. eapply E1_1. eapply Red1. }
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: subst st[3].
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: (* was: apply IHE1_2. assumption.] *)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) eapply IH. eapply E1_2. eapply Red2.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: (* The other cases are similiar. *)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: End SkipExample.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Module SortExamples.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1] →
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[2] →
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st[2] →
- en: st[1] = st[2].
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: st[1] = st[2]。
- en: Proof.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros c st st[1] st[2] E[1] E[2].
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: intros c st st[1] st[2] E[1] E[2]。
- en: generalize dependent st[2].
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: generalize dependent st[2]。
- en: (induction E[1]); intros st[2] E[2]; inverts E[2].
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: （归纳 E[1]）；intros st[2] E[2]；inverts E[2]。
- en: admit. admit. (* Skipping some trivial cases *)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 承认。承认。(* 跳过一些琐碎的情况 *)
- en: sort. (* Observe how the context is reorganized *)
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 类型。(* 观察上下文如何重新组织 *)
- en: Abort.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃。
- en: End SortExamples.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 SortExamples。
- en: '[PRE43]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Working of lets
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lets 的工作
- en: When we have a lemma (or an assumption) that we want to exploit,
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们有一个我们想要利用的引理（或假设）时，
- en: we often need to explicitly provide arguments to this lemma,
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们经常需要明确为这个引理提供参数，
- en: 'writing something like:'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 写一些像：
- en: destruct (typing_inversion_var _ _ _ Htypt) as (T & Hctx & Hsub).
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: destruct (typing_inversion_var _ _ _ Htypt) as (T & Hctx & Hsub)。
- en: The need to write several times the "underscore" symbol is tedious.
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要多次写“下划线”符号是繁琐的。
- en: Not only we need to figure out how many of them to write down, but
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不仅需要弄清楚要写多少个，还需要弄清楚
- en: it also makes the proof scripts look prettly ugly. With the tactic
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也使得证明脚本看起来相当丑陋。使用这个策略
- en: 'lets, one can simply write:'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许，一个可以简单地写：
- en: 'lets (T & Hctx & Hsub): typing_inversion_var Htypt.'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'lets (T & Hctx & Hsub): typing_inversion_var Htypt。'
- en: In short, this tactic lets allows to specialize a lemma on a bunch
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简而言之，这种策略允许将引理专门化为一堆
- en: 'of variables and hypotheses. The syntax is lets I: E[0] E[1] .. EN,'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '变量和假设。语法是 lets I: E[0] E[1] .. EN，'
- en: for building an hypothesis named I by applying the fact E[0] to the
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将事实 E[0] 应用于
- en: arguments E[1] to EN. Not all the arguments need to be provided,
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数 E[1] 到 EN。不需要提供所有参数，
- en: however the arguments that are provided need to be provided in the
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而提供的参数需要在
- en: correct order. The tactic relies on a first-match algorithm based on
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确的顺序。该策略依赖于基于第一匹配算法的
- en: types in order to figure out how the to instantiate the lemma with
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了弄清楚如何实例化引理
- en: the arguments provided.
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提供的参数。
- en: '[PRE44]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, assume we have an assumption H with the type of the form
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，假设我们有一个类型为
- en: has_type G (tvar x) T. We can obtain the conclusion of the
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: has_type G (tvar x) T。我们可以获得
- en: lemma typing_inversion_var by invoking the tactics
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过调用策略来证明 typing_inversion_var
- en: 'lets K: typing_inversion_var H, as shown next.'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '允许 K: typing_inversion_var H，如下所示。'
- en: '[PRE45]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Assume now that we know the values of G, x and T and we
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在假设我们知道 G、x 和 T 的值，我们
- en: want to obtain S, and have has_type G (tvar x) T be produced
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想要获得 S，并且有 has_type G (tvar x) T 被产生
- en: as a subgoal. To indicate that we want all the remaining arguments
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一个子目标。表示我们希望所有剩余的参数
- en: of typing_inversion_var to be produced as subgoals, we use a
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要产生 typing_inversion_var 的子目标，我们使用
- en: triple-underscore symbol ___. (We'll later introduce a shorthand
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 三个下划线符号 ___.（稍后我们将介绍一个简写
- en: tactic called forwards to avoid writing triple underscores.)
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用 forwards 的策略来避免写三个下划线。）
- en: '[PRE46]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Usually, there is only one context G and one type T that are
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，只有一个上下文 G 和一个类型 T 是
- en: going to be suitable for proving has_type G (tvar x) T, so
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 适合证明 has_type G (tvar x) T，所以
- en: we don't really need to bother giving G and T explicitly.
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们实际上不需要麻烦地明确给出 G 和 T。
- en: 'It suffices to call lets (S & Eq & Sub): typing_inversion_var x.'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '只需调用 lets (S & Eq & Sub): typing_inversion_var x。'
- en: The variables G and T are then instantiated using existential
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后使用存在性实例化变量 G 和 T
- en: variables.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量。
- en: '[PRE47]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We may go even further by not giving any argument to instantiate
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们甚至可以进一步不给任何参数来实例化
- en: typing_inversion_var. In this case, three unification variables
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: typing_inversion_var。在这种情况下，三个统一变量
- en: are introduced.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被引入。
- en: '[PRE48]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Note: if we provide lets with only the name of the lemma as'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：如果我们只提供引理的名称给 lets
- en: argument, it simply adds this lemma in the proof context, without
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数，它只是将这个引理添加到��明上下文中，而不是
- en: trying to instantiate any of its arguments.
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试实例化任何一个参数。
- en: '[PRE49]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: A last useful feature of lets is the double-underscore symbol,
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lets 的最后一个有用功能是双下划线符号，
- en: which allows skipping an argument when several arguments have
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许在多个参数具有时跳过一个参数
- en: the same type. In the following example, our assumption quantifies
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相同类型。在下面的例子中，我们的假设量化
- en: over two variables n and m, both of type nat. We would like
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 超过两个类型为 nat 的变量 n 和 m。我们希望
- en: m to be instantiated as the value 3, but without specifying a
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: m 被实例化为值 3，但没有指定
- en: 'value for n. This can be achieved by writting lets K: H __ 3.'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'n 的值。这可以通过写 lets K: H __ 3 来实现。'
- en: '[PRE50]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note: one can write lets: E[0] E[1] E[2] in place of lets H: E[0] E[1] E[2].'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '注意：可以写 lets: E[0] E[1] E[2] 代替 lets H: E[0] E[1] E[2]。'
- en: In this case, the name H is chosen arbitrarily.
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，名称 H 是任意选择的。
- en: 'Note: the tactics lets accepts up to five arguments. Another'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：lets 策略最多接受五个参数。另一个
- en: syntax is available for providing more than five arguments.
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语法可提供超过五个参数。
- en: It consists in using a list introduced with the special symbol >>,
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它包括使用带有特殊符号 >> 引入的列表，
- en: 'for example lets H: (>> E[0] E[1] E[2] E[3] E[4] E[5] E[6] E[7] E[8] E[9] 10).'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '例如 lets H: (>> E[0] E[1] E[2] E[3] E[4] E[5] E[6] E[7] E[8] E[9] 10)。'
- en: '[PRE51]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Working of applys, forwards and specializes
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 applys, forwards 和 specializes 的工作方式
- en: The tactics applys, forwards and specializes are
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tactics applys, forwards 和 specializes 是
- en: shorthand that may be used in place of lets to perform
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个可以用来执行的快捷方式
- en: specific tasks.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特定任务。
- en: forwards is a shorthand for instantiating all the arguments
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: forwards 是一个快捷方式，用于实例化所有参数
- en: 'of a lemma. More precisely, forwards H: E[0] E[1] E[2] E[3] is the'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '一个引理。更准确地说，forwards H: E[0] E[1] E[2] E[3] 是'
- en: 'same as lets H: E[0] E[1] E[2] E[3] ___, where the triple-underscore'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '相同于 lets H: E[0] E[1] E[2] E[3] ___, 其中三个下划线'
- en: has the same meaning as explained earlier on.
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有与之前解释的相同含义。
- en: applys allows building a lemma using the advanced instantion
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: applys 允许使用高级实例化构建引理
- en: mode of lets, and then apply that lemma right away. So,
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lets 的模式，然后立即应用该引理。因此，
- en: 'applys E[0] E[1] E[2] E[3] is the same as lets H: E[0] E[1] E[2] E[3]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '应用 E[0] E[1] E[2] E[3] 是相同的，就像 lets H: E[0] E[1] E[2] E[3]'
- en: followed with eapply H and then clear H.
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 跟随 eapply H 然后清除 H。
- en: specializes is a shorthand for instantiating in-place
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: specializes 是一个快捷方式，用于就地实例化
- en: an assumption from the context with particular arguments.
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从上下文中得出一个特定参数的假设。
- en: More precisely, specializes H E[0] E[1] is the same as
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更准确地说，specializes H E[0] E[1] 是相同的
- en: 'lets H'': H E[0] E[1] followed with clear H and rename H'' into H.'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'lets H'': H E[0] E[1] 跟随清除 H 并将 H'' 重命名为 H。'
- en: Examples of use of applys appear further on. Several examples of
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 applys 的示例稍后出现。几个示例
- en: use of forwards can be found in the tutorial chapter [UseAuto](UseAuto.html).
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: forwards 的使用可以在教程章节 [UseAuto](UseAuto.html) 中找到。
- en: '[PRE52]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Module ExamplesInstantiations.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 ExamplesInstantiations。
- en: Require Import Sub.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Sub。
- en: '[PRE53]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 substitution_preserves_typing: ∀Γ x U v t S，'
- en: has_type (update Γ x U) t S →
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 有类型 (update Γ x U) t S →
- en: has_type empty v U →
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 有类型 empty v U →
- en: has_type Γ ([x:=v]t) S.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 有类型 Γ ([x:=v]t) S。
- en: Proof with eauto.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Proof with eauto。
- en: intros Γ x U v t S Htypt Htypv.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 Γ x U v t S Htypt Htypv。
- en: generalize dependent S. generalize dependent Γ.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 推广相关 S。推广相关 Γ。
- en: (induction t); intros; simpl.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: (对 t 进行归纳); 引入; 简化。
- en: '- (* tvar *)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tvar *)'
- en: rename i into y.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 将 i 重命名为 y。
- en: (* An example where destruct is replaced with lets. *)
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: (* 一个用 lets 替换 destruct 的例子。*)
- en: (* old: destruct (typing_inversion_var _ _ _ Htypt) as T [Hctx Hsub].*)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: (* 旧：destruct (typing_inversion_var _ _ _ Htypt) as T [Hctx Hsub].*)
- en: '(* new: *) lets (T&Hctx&Hsub): typing_inversion_var Htypt.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 新：*) lets (T&Hctx&Hsub): typing_inversion_var Htypt。'
- en: unfold update, t_update in Hctx.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 update, t_update 在 Hctx 中。
- en: destruct (beq_idP x y)...
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: destruct (beq_idP x y)...
- en: + (* x=y *)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x=y *)
- en: subst.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。
- en: inversion Hctx; subst. clear Hctx.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 Hctx；替换。清除 Hctx。
- en: apply context_invariance with empty...
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 context_invariance with empty...
- en: intros x Hcontra.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 x Hcontra。
- en: (* A more involved example. *)
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: (* 一个更复杂的例子。*)
- en: (* old: destruct (free_in_context _ _ S empty Hcontra)                  as T'
    HT'... *)
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: (* 旧：destruct (free_in_context _ _ S empty Hcontra) as T' HT'...*)
- en: (* new: *)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: (* 新：*)
- en: 'lets [T'' HT'']: free_in_context S (@empty ty) Hcontra...'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'lets [T'' HT'']: free_in_context S (@empty ty) Hcontra...'
- en: inversion HT'.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 HT'。
- en: '- (* tapp *)'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tapp *)'
- en: (* Exercise: replace the following destruct with a lets. *)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: (* 练习：用 lets 替换以下 destruct。*)
- en: (* old: destruct (typing_inversion_app _ _ _ _ Htypt)               as T[1]
    [Htypt1 Htypt2]. eapply T_App... *)
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: (* 旧：destruct (typing_inversion_app _ _ _ _ Htypt) as T[1] [Htypt1 Htypt2].
    eapply T_App...*)
- en: (* FILL IN HERE *) admit.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写*) admit。
- en: '- (* tabs *)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tabs *)'
- en: rename i into y. rename t into T[1].
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 将 i 重命名为 y。将 t 重命名为 T[1]。
- en: (* Here is another example of using lets. *)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: (* 这里是另一个使用 lets 的例子。*)
- en: (* old: destruct (typing_inversion_abs _ _ _ _ _ Htypt). *)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: (* 旧：destruct (typing_inversion_abs _ _ _ _ _ Htypt)。*)
- en: '(* new: *) lets (T[2]&Hsub&Htypt2): typing_inversion_abs Htypt.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 新：*) lets (T[2]&Hsub&Htypt2): typing_inversion_abs Htypt。'
- en: (* An example of where apply with can be replaced with applys. *)
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: (* 一个例子，其中 apply with 可以替换为 applys。*)
- en: (* old: apply T_Sub with (TArrow T[1] T[2])... *)
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: (* 旧：apply T_Sub with (TArrow T[1] T[2])...*)
- en: (* new: *) applys T_Sub (TArrow T[1] T[2])...
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: (* 新：*) 应用 T_Sub (TArrow T[1] T[2])...
- en: apply T_Abs...
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 T_Abs...
- en: destruct (beq_idP x y).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: destruct (beq_idP x y)。
- en: + (* x=y *)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x=y *)
- en: eapply context_invariance...
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: eapply context_invariance...
- en: subst.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。
- en: intros x Hafi. unfold update, t_update.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 x Hafi。展开 update, t_update。
- en: destruct (beq_idP y x)...
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: destruct (beq_idP y x)...
- en: + (* x<>y *)
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: + (* x<>y *)
- en: apply IHt. eapply context_invariance...
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHt。应用 context_invariance...
- en: intros z Hafi. unfold update, t_update.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 z Hafi。展开 update, t_update。
- en: destruct (beq_idP y z)...
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 检测 (beq_idP y z)...
- en: subst. rewrite false_beq_id...
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 替换。重写 false_beq_id...
- en: '- (* ttrue *)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* ttrue *)'
- en: 'lets: typing_inversion_true Htypt...'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 'lets: typing_inversion_true Htypt...'
- en: '- (* tfalse *)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tfalse *)'
- en: 'lets: typing_inversion_false Htypt...'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'lets: typing_inversion_false Htypt...'
- en: '- (* tif *)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tif *)'
- en: 'lets (Htyp1&Htyp2&Htyp3): typing_inversion_if Htypt...'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'lets (Htyp1&Htyp2&Htyp3): typing_inversion_if Htypt...'
- en: '- (* tunit *)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* tunit *)'
- en: (* An example where assert can be replaced with lets. *)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: (* 一个 assert 可以被 lets 替换的示例。*)
- en: (* old: assert (subtype TUnit S)              by apply (typing_inversion_unit _ _ Htypt)... *)
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: (* 旧: 断言 (subtype TUnit S)              通过 应用 (typing_inversion_unit _ _ Htypt)... *)
- en: '(* new: *) lets: typing_inversion_unit Htypt...'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '(* 新: *) lets: typing_inversion_unit Htypt...'
- en: Admitted.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 已承认。
- en: End ExamplesInstantiations.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 示例实例化。
- en: '[PRE54]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
