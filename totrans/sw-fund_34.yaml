- en: 'UseTacticsTactic Library for Coq: A Gentle Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: (* Chapter written and maintained by Arthur Chargueraud *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Types.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Smallstep.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import LibTactics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tactics for Introduction and Case Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section presents the following tactics:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: introv, for naming hypotheses more efficiently,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: inverts, for improving the inversion tactic,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cases, for performing a case analysis without losing information,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cases_if, for automating case analysis on the argument of if.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Module IntrovExamples.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  prefs: []
  type: TYPE_NORMAL
- en: Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Import STLC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1] →
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[2] →
  prefs: []
  type: TYPE_NORMAL
- en: st[1] = st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: introv E[1] E[2]. (* was intros c st st[1] st[2] E[1] E[2] *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem dist_exists_or : ∀(X:Type) (P Q : X → Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∃x, P x ∨ Q x) ↔ (∃x, P x) ∨ (∃x, Q x).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: introv. (* was intros X P Q *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ceval_deterministic'': ∀c st st[1],'
  prefs: []
  type: TYPE_NORMAL
- en: (c / st ⇓ st[1]) → ∀st[2], (c / st ⇓ st[2]) → st[1] = st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: introv E[1] E[2]. (* was intros c st st[1] E[1] st[2] E[2] *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem exists_impl: ∀X (P : X → Prop) (Q : Prop) (R : Prop),'
  prefs: []
  type: TYPE_NORMAL
- en: (∀x, P x → Q) →
  prefs: []
  type: TYPE_NORMAL
- en: ((∃x, P x) → Q).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: introv [x H[2]]. eauto.
  prefs: []
  type: TYPE_NORMAL
- en: (* same as intros X P Q R H[1] [x H[2]]., which is itself short      for intros
    X P Q R H[1] H[2]. destruct H[2] as [x H[2]]. *)
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: End IntrovExamples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Module InvertsExamples.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Equiv.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Import STLC.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem skip_left: ∀c,'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv (SKIP;; c) c.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: introv. split; intros H.
  prefs: []
  type: TYPE_NORMAL
- en: dup. (* duplicate the goal for comparison *)
  prefs: []
  type: TYPE_NORMAL
- en: (* was... *)
  prefs: []
  type: TYPE_NORMAL
- en: '- inversion H. subst. inversion H[2]. subst. assumption.'
  prefs: []
  type: TYPE_NORMAL
- en: (* now... *)
  prefs: []
  type: TYPE_NORMAL
- en: '- inverts H. inverts H[2]. assumption.'
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1]  →
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[2] →
  prefs: []
  type: TYPE_NORMAL
- en: st[1] = st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: introv E[1] E[2]. generalize dependent st[2].
  prefs: []
  type: TYPE_NORMAL
- en: induction E[1]; intros st[2] E[2].
  prefs: []
  type: TYPE_NORMAL
- en: admit. admit. (* skip some basic cases *)
  prefs: []
  type: TYPE_NORMAL
- en: dup. (* duplicate the goal for comparison *)
  prefs: []
  type: TYPE_NORMAL
- en: (* was: *)
  prefs: []
  type: TYPE_NORMAL
- en: '- inversion E[2]. subst. admit.'
  prefs: []
  type: TYPE_NORMAL
- en: (* now: *)
  prefs: []
  type: TYPE_NORMAL
- en: '- inverts E[2]. admit.'
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ceval_deterministic'': ∀c st st[1] st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1]  →
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[2] →
  prefs: []
  type: TYPE_NORMAL
- en: st[1] = st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: introv E[1] E[2]. generalize dependent st[2].
  prefs: []
  type: TYPE_NORMAL
- en: (induction E[1]); intros st[2] E[2];
  prefs: []
  type: TYPE_NORMAL
- en: inverts E[2] as.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Skip *) reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Ass *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* Observe that the variable n is not automatically        substituted because, contrary to inversion
    E[2]; subst,        the tactic inverts E[2] does not substitute the equalities
           that exist before running the inversion. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) subst n.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Seq *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* Here, the newly created variables can be introduced        using intros, so they can be assigned meaningful names,
           for example st[3] instead of st'0. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) intros st[3] Red1 Red2.
  prefs: []
  type: TYPE_NORMAL
- en: assert (st' = st[3]) as EQ[1].
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* Proof of assertion *) apply IHE1_1; assumption. }'
  prefs: []
  type: TYPE_NORMAL
- en: subst st[3].
  prefs: []
  type: TYPE_NORMAL
- en: apply IHE1_2. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: (* E_IfTrue *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b[1] reduces to true *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* In an easy case like this one, there is no need to        provide meaningful names, so we can just use intros *)
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) intros.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHE1. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* b[1] reduces to false (contradiction) *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) intros.
  prefs: []
  type: TYPE_NORMAL
- en: rewrite H in H[5]. inversion H[5].
  prefs: []
  type: TYPE_NORMAL
- en: (* The other cases are similiar *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem skip_left'': ∀c,'
  prefs: []
  type: TYPE_NORMAL
- en: cequiv (SKIP;; c) c.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: introv. split; intros H.
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as U V. (* new hypotheses are named U and V *)
  prefs: []
  type: TYPE_NORMAL
- en: inverts U. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Example typing_nonexample_1 :'
  prefs: []
  type: TYPE_NORMAL
- en: ¬ ∃T,
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty
  prefs: []
  type: TYPE_NORMAL
- en: (tabs x TBool
  prefs: []
  type: TYPE_NORMAL
- en: (tabs y TBool
  prefs: []
  type: TYPE_NORMAL
- en: (tapp (tvar x) (tvar y))))
  prefs: []
  type: TYPE_NORMAL
- en: T.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: dup 3.
  prefs: []
  type: TYPE_NORMAL
- en: (* The old proof: *)
  prefs: []
  type: TYPE_NORMAL
- en: '- intros C. destruct C.'
  prefs: []
  type: TYPE_NORMAL
- en: inversion H. subst. clear H.
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[5]. subst. clear H[5].
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[4]. subst. clear H[4].
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[2]. subst. clear H[2].
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[5]. subst. clear H[5].
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[1].
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof: *)
  prefs: []
  type: TYPE_NORMAL
- en: '- intros C. destruct C.'
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H[1].
  prefs: []
  type: TYPE_NORMAL
- en: inverts H[1] as H[2].
  prefs: []
  type: TYPE_NORMAL
- en: inverts H[2] as H[3].
  prefs: []
  type: TYPE_NORMAL
- en: inverts H[3] as H[4].
  prefs: []
  type: TYPE_NORMAL
- en: inverts H[4].
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof, alternative: *)
  prefs: []
  type: TYPE_NORMAL
- en: '- intros C. destruct C.'
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H.
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H.
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H.
  prefs: []
  type: TYPE_NORMAL
- en: inverts H as H.
  prefs: []
  type: TYPE_NORMAL
- en: inverts H.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: End InvertsExamples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tactics for N-ary Connectives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Coq encodes conjunctions and disjunctions using binary
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: constructors ∧ and ∨, working with a conjunction or a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: disjunction of N facts can sometimes be quite cumbursome.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For this reason, "LibTactics" provides tactics offering direct
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: support for n-ary conjunctions and disjunctions. It also provides
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: direct support for n-ary existententials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This section presents the following tactics:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: splits for decomposing n-ary conjunctions,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: branch for decomposing n-ary disjunctions,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ∃ for proving n-ary existentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Tactic splits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic splits applies to a goal made of a conjunction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of n propositions and it produces n subgoals. For example,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it decomposes the goal G[1] ∧ G[2] ∧ G[3] into the three subgoals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: G[1], G[2] and G[3].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The Tactic branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic branch k can be used to prove a n-ary disjunction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, if the goal takes the form G[1] ∨ G[2] ∨ G[3],
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the tactic branch 2 leaves only G[2] as subgoal. The following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example illustrates the behavior of the branch tactic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The Tactic ∃
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library "LibTactics" introduces a notation for n-ary
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: existentials. For example, one can write ∃ x y z, H
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: instead of ∃ x, ∃ y, ∃ z, H. Similarly,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the library provides a n-ary tactic ∃ a b c, which is a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: shorthand for ∃ a; ∃ b; ∃ c. The following
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example illustrates both the notation and the tactic for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: dealing with n-ary existentials.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Remark: a similar facility for n-ary existentials is provided'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by the module Coq.Program.Syntax from the standard library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (Coq.Program.Syntax supports existentials up to arity 4;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LibTactics supports them up to arity 10.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tactics for Working with Equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the major weakness of Coq compared with other interactive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proof assistants is its relatively poor support for reasoning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: with equalities. The tactics described next aims at simplifying
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pieces of proof scripts manipulating equalities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This section presents the following tactics:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: asserts_rewrite for introducing an equality to rewrite with,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cuts_rewrite, which is similar except that its subgoals are swapped,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: substs for improving the subst tactic,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fequals for improving the f_equal tactic,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: applys_eq for proving P x y using an hypothesis P x z, automatically producing
    an equality y = z as subgoal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Tactics asserts_rewrite and cuts_rewrite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic asserts_rewrite (E[1] = E[2]) replaces E[1] with E[2] in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the goal, and produces the goal E[1] = E[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The tactic cuts_rewrite (E[1] = E[2]) is like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: asserts_rewrite (E[1] = E[2]), except that the equality E[1] = E[2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: appears as first subgoal.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: More generally, the tactics asserts_rewrite and cuts_rewrite
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can be provided a lemma as argument. For example, one can write
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: asserts_rewrite (∀ a b, a*(S b) = a*b+a).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This formulation is useful when a and b are big terms,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: since there is no need to repeat their statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The Tactic substs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic substs is similar to subst except that it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: does not fail when the goal contains "circular equalities",
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: such as x = f x.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Tactic fequals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic fequals is similar to f_equal except that it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: directly discharges all the trivial subgoals produced. Moreover,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the tactic fequals features an enhanced treatment of equalities
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: between tuples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Tactic applys_eq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactic applys_eq is a variant of eapply that introduces
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: equalities for subterms that do not unify. For example, assume
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the goal is the proposition P x y and assume we have the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assumption H asserting that P x z holds. We know that we can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: prove y to be equal to z. So, we could call the tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assert_rewrite (y = z) and change the goal to P x z, but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this would require copy-pasting the values of y and z.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the tactic applys_eq, we can call applys_eq H 1, which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proves the goal and leaves only the subgoal y = z. The value 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given as argument to applys_eq indicates that we want an equality
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to be introduced for the first argument of P x y counting from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the right. The three following examples illustrate the behavior
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of a call to applys_eq H 1, a call to applys_eq H 2, and a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: call to applys_eq H 1 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the mismatch was on the first argument of P instead of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the second, we would have written applys_eq H 2. Recall
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that the occurences are counted from the right.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When we have a mismatch on two arguments, we want to produce
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: two equalities. To achieve this, we may call applys_eq H 1 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More generally, the tactic applys_eq expects a lemma and a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sequence of natural numbers as arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Some Convenient Shorthands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section of the tutorial introduces a few tactics
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'that help make proof scripts shorter and more readable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfolds (without argument) for unfolding the head definition,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: false for replacing the goal with False,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gen as a shorthand for dependent generalize,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: skip for skipping a subgoal even if it contains existential variables,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sort for re-ordering the proof context by moving moving all propositions at
    the bottom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Module UnfoldsExample.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Hoare.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma bexp_eval_true : ∀b st,'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b = true → (bassn b) st.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros b st Hbe. dup.
  prefs: []
  type: TYPE_NORMAL
- en: (* The old proof: *)
  prefs: []
  type: TYPE_NORMAL
- en: unfold bassn. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof: *)
  prefs: []
  type: TYPE_NORMAL
- en: unfolds. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: End UnfoldsExample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma demo_false :'
  prefs: []
  type: TYPE_NORMAL
- en: ∀n, S n = 1 → n = 0.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. destruct n. reflexivity. false.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma demo_false_arg :'
  prefs: []
  type: TYPE_NORMAL
- en: (∀n, n < 0 → False) → (3 < 0) → 4 < 0.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros H L. false H. apply L.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma demo_tryfalse :'
  prefs: []
  type: TYPE_NORMAL
- en: ∀n, S n = 1 → n = 0.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. destruct n; tryfalse. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Module GenExample.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  prefs: []
  type: TYPE_NORMAL
- en: Import STLC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type (update Γ x U) t S →
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty v U →
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ ([x:=v]t) S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: dup.
  prefs: []
  type: TYPE_NORMAL
- en: (* The old proof: *)
  prefs: []
  type: TYPE_NORMAL
- en: intros Γ x U v t S Htypt Htypv.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent S. generalize dependent Γ.
  prefs: []
  type: TYPE_NORMAL
- en: induction t; intros; simpl.
  prefs: []
  type: TYPE_NORMAL
- en: admit. admit. admit. admit. admit. admit.
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof: *)
  prefs: []
  type: TYPE_NORMAL
- en: introv Htypt Htypv. gen S Γ.
  prefs: []
  type: TYPE_NORMAL
- en: induction t; intros; simpl.
  prefs: []
  type: TYPE_NORMAL
- en: admit. admit. admit. admit. admit. admit.
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: End GenExample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Module SkipExample.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Stlc.
  prefs: []
  type: TYPE_NORMAL
- en: Import STLC.
  prefs: []
  type: TYPE_NORMAL
- en: Notation " t '/' st '⇒a*' t' " := (multi (astep st) t t')
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example astep_example1 :'
  prefs: []
  type: TYPE_NORMAL
- en: (APlus (ANum 3) (AMult (ANum 3) (ANum 4))) / empty_state ⇒[a]* (ANum 15).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: eapply multi_step. skip. (* the tactic admit would not work here *)
  prefs: []
  type: TYPE_NORMAL
- en: eapply multi_step. skip. skip.
  prefs: []
  type: TYPE_NORMAL
- en: (* Note that because some unification variables have      not been instantiated, we still need to write
         Abort instead of Qed at the end of the proof. *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem demo_skipH : True.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: 'skip H: (∀n m : nat, (0 + n) * m = n * m).'
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem mult_0_plus : ∀n m : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: (0 + n) * m = n * m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: dup.
  prefs: []
  type: TYPE_NORMAL
- en: (* The old proof: *)
  prefs: []
  type: TYPE_NORMAL
- en: intros n m.
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (H: 0 + n = n). skip. rewrite → H.'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: (* The new proof: *)
  prefs: []
  type: TYPE_NORMAL
- en: intros n m.
  prefs: []
  type: TYPE_NORMAL
- en: skip_rewrite (0 + n = n).
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1] →
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[2] →
  prefs: []
  type: TYPE_NORMAL
- en: st[1] = st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* The tactic skip_goal creates an hypothesis called IH      asserting that the statment of ceval_deterministic is true. *)
  prefs: []
  type: TYPE_NORMAL
- en: skip_goal.
  prefs: []
  type: TYPE_NORMAL
- en: (* Of course, if we call assumption here, then the goal is solved      right away, but the point is to do the proof and use IH
         only at the places where we need an induction hypothesis. *)
  prefs: []
  type: TYPE_NORMAL
- en: introv E[1] E[2]. gen st[2].
  prefs: []
  type: TYPE_NORMAL
- en: (induction E[1]); introv E[2]; inverts E[2] as.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Skip *) reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Ass *)'
  prefs: []
  type: TYPE_NORMAL
- en: subst n.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* E_Seq *)'
  prefs: []
  type: TYPE_NORMAL
- en: intros st[3] Red1 Red2.
  prefs: []
  type: TYPE_NORMAL
- en: assert (st' = st[3]) as EQ[1].
  prefs: []
  type: TYPE_NORMAL
- en: '{ (* Proof of assertion *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* was: apply IHE1_1; assumption. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) eapply IH. eapply E1_1. eapply Red1. }
  prefs: []
  type: TYPE_NORMAL
- en: subst st[3].
  prefs: []
  type: TYPE_NORMAL
- en: (* was: apply IHE1_2. assumption.] *)
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) eapply IH. eapply E1_2. eapply Red2.
  prefs: []
  type: TYPE_NORMAL
- en: (* The other cases are similiar. *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: End SkipExample.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Module SortExamples.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem ceval_deterministic: ∀c st st[1] st[2],'
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[1] →
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st[2] →
  prefs: []
  type: TYPE_NORMAL
- en: st[1] = st[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros c st st[1] st[2] E[1] E[2].
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent st[2].
  prefs: []
  type: TYPE_NORMAL
- en: (induction E[1]); intros st[2] E[2]; inverts E[2].
  prefs: []
  type: TYPE_NORMAL
- en: admit. admit. (* Skipping some trivial cases *)
  prefs: []
  type: TYPE_NORMAL
- en: sort. (* Observe how the context is reorganized *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: End SortExamples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Working of lets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we have a lemma (or an assumption) that we want to exploit,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we often need to explicitly provide arguments to this lemma,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'writing something like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: destruct (typing_inversion_var _ _ _ Htypt) as (T & Hctx & Hsub).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The need to write several times the "underscore" symbol is tedious.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Not only we need to figure out how many of them to write down, but
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it also makes the proof scripts look prettly ugly. With the tactic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lets, one can simply write:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lets (T & Hctx & Hsub): typing_inversion_var Htypt.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In short, this tactic lets allows to specialize a lemma on a bunch
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'of variables and hypotheses. The syntax is lets I: E[0] E[1] .. EN,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for building an hypothesis named I by applying the fact E[0] to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: arguments E[1] to EN. Not all the arguments need to be provided,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: however the arguments that are provided need to be provided in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: correct order. The tactic relies on a first-match algorithm based on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: types in order to figure out how the to instantiate the lemma with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the arguments provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: First, assume we have an assumption H with the type of the form
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: has_type G (tvar x) T. We can obtain the conclusion of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lemma typing_inversion_var by invoking the tactics
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lets K: typing_inversion_var H, as shown next.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Assume now that we know the values of G, x and T and we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: want to obtain S, and have has_type G (tvar x) T be produced
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: as a subgoal. To indicate that we want all the remaining arguments
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of typing_inversion_var to be produced as subgoals, we use a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: triple-underscore symbol ___. (We'll later introduce a shorthand
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic called forwards to avoid writing triple underscores.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Usually, there is only one context G and one type T that are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: going to be suitable for proving has_type G (tvar x) T, so
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we don't really need to bother giving G and T explicitly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It suffices to call lets (S & Eq & Sub): typing_inversion_var x.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The variables G and T are then instantiated using existential
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We may go even further by not giving any argument to instantiate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: typing_inversion_var. In this case, three unification variables
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are introduced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: if we provide lets with only the name of the lemma as'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: argument, it simply adds this lemma in the proof context, without
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: trying to instantiate any of its arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: A last useful feature of lets is the double-underscore symbol,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: which allows skipping an argument when several arguments have
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the same type. In the following example, our assumption quantifies
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: over two variables n and m, both of type nat. We would like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: m to be instantiated as the value 3, but without specifying a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'value for n. This can be achieved by writting lets K: H __ 3.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: one can write lets: E[0] E[1] E[2] in place of lets H: E[0] E[1] E[2].'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case, the name H is chosen arbitrarily.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note: the tactics lets accepts up to five arguments. Another'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: syntax is available for providing more than five arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It consists in using a list introduced with the special symbol >>,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for example lets H: (>> E[0] E[1] E[2] E[3] E[4] E[5] E[6] E[7] E[8] E[9] 10).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Working of applys, forwards and specializes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tactics applys, forwards and specializes are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: shorthand that may be used in place of lets to perform
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: specific tasks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: forwards is a shorthand for instantiating all the arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'of a lemma. More precisely, forwards H: E[0] E[1] E[2] E[3] is the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'same as lets H: E[0] E[1] E[2] E[3] ___, where the triple-underscore'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: has the same meaning as explained earlier on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: applys allows building a lemma using the advanced instantion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mode of lets, and then apply that lemma right away. So,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'applys E[0] E[1] E[2] E[3] is the same as lets H: E[0] E[1] E[2] E[3]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: followed with eapply H and then clear H.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: specializes is a shorthand for instantiating in-place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an assumption from the context with particular arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More precisely, specializes H E[0] E[1] is the same as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'lets H'': H E[0] E[1] followed with clear H and rename H'' into H.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples of use of applys appear further on. Several examples of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use of forwards can be found in the tutorial chapter [UseAuto](UseAuto.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Module ExamplesInstantiations.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Sub.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma substitution_preserves_typing : ∀Γ x U v t S,'
  prefs: []
  type: TYPE_NORMAL
- en: has_type (update Γ x U) t S →
  prefs: []
  type: TYPE_NORMAL
- en: has_type empty v U →
  prefs: []
  type: TYPE_NORMAL
- en: has_type Γ ([x:=v]t) S.
  prefs: []
  type: TYPE_NORMAL
- en: Proof with eauto.
  prefs: []
  type: TYPE_NORMAL
- en: intros Γ x U v t S Htypt Htypv.
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent S. generalize dependent Γ.
  prefs: []
  type: TYPE_NORMAL
- en: (induction t); intros; simpl.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tvar *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i into y.
  prefs: []
  type: TYPE_NORMAL
- en: (* An example where destruct is replaced with lets. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* old: destruct (typing_inversion_var _ _ _ Htypt) as T [Hctx Hsub].*)
  prefs: []
  type: TYPE_NORMAL
- en: '(* new: *) lets (T&Hctx&Hsub): typing_inversion_var Htypt.'
  prefs: []
  type: TYPE_NORMAL
- en: unfold update, t_update in Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_idP x y)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y *)
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: inversion Hctx; subst. clear Hctx.
  prefs: []
  type: TYPE_NORMAL
- en: apply context_invariance with empty...
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hcontra.
  prefs: []
  type: TYPE_NORMAL
- en: (* A more involved example. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* old: destruct (free_in_context _ _ S empty Hcontra)                  as T'
    HT'... *)
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *)
  prefs: []
  type: TYPE_NORMAL
- en: 'lets [T'' HT'']: free_in_context S (@empty ty) Hcontra...'
  prefs: []
  type: TYPE_NORMAL
- en: inversion HT'.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tapp *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* Exercise: replace the following destruct with a lets. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* old: destruct (typing_inversion_app _ _ _ _ Htypt)               as T[1]
    [Htypt1 Htypt2]. eapply T_App... *)
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) admit.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tabs *)'
  prefs: []
  type: TYPE_NORMAL
- en: rename i into y. rename t into T[1].
  prefs: []
  type: TYPE_NORMAL
- en: (* Here is another example of using lets. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* old: destruct (typing_inversion_abs _ _ _ _ _ Htypt). *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* new: *) lets (T[2]&Hsub&Htypt2): typing_inversion_abs Htypt.'
  prefs: []
  type: TYPE_NORMAL
- en: (* An example of where apply with can be replaced with applys. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* old: apply T_Sub with (TArrow T[1] T[2])... *)
  prefs: []
  type: TYPE_NORMAL
- en: (* new: *) applys T_Sub (TArrow T[1] T[2])...
  prefs: []
  type: TYPE_NORMAL
- en: apply T_Abs...
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_idP x y).
  prefs: []
  type: TYPE_NORMAL
- en: + (* x=y *)
  prefs: []
  type: TYPE_NORMAL
- en: eapply context_invariance...
  prefs: []
  type: TYPE_NORMAL
- en: subst.
  prefs: []
  type: TYPE_NORMAL
- en: intros x Hafi. unfold update, t_update.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_idP y x)...
  prefs: []
  type: TYPE_NORMAL
- en: + (* x<>y *)
  prefs: []
  type: TYPE_NORMAL
- en: apply IHt. eapply context_invariance...
  prefs: []
  type: TYPE_NORMAL
- en: intros z Hafi. unfold update, t_update.
  prefs: []
  type: TYPE_NORMAL
- en: destruct (beq_idP y z)...
  prefs: []
  type: TYPE_NORMAL
- en: subst. rewrite false_beq_id...
  prefs: []
  type: TYPE_NORMAL
- en: '- (* ttrue *)'
  prefs: []
  type: TYPE_NORMAL
- en: 'lets: typing_inversion_true Htypt...'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tfalse *)'
  prefs: []
  type: TYPE_NORMAL
- en: 'lets: typing_inversion_false Htypt...'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tif *)'
  prefs: []
  type: TYPE_NORMAL
- en: 'lets (Htyp1&Htyp2&Htyp3): typing_inversion_if Htypt...'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* tunit *)'
  prefs: []
  type: TYPE_NORMAL
- en: (* An example where assert can be replaced with lets. *)
  prefs: []
  type: TYPE_NORMAL
- en: (* old: assert (subtype TUnit S)              by apply (typing_inversion_unit _ _ Htypt)... *)
  prefs: []
  type: TYPE_NORMAL
- en: '(* new: *) lets: typing_inversion_unit Htypt...'
  prefs: []
  type: TYPE_NORMAL
- en: Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: End ExamplesInstantiations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
