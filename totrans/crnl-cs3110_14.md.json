["```\nmodule type SET = sig\n  type 'a set\n  val empty : 'a set\n  val mem : 'a -> 'a set -> bool\n  val add : 'a -> 'a set -> 'a set\n  val rem : 'a -> 'a set -> 'a set\n  val size: 'a set -> int\n  val union: 'a set -> 'a set -> 'a set\n  val inter: 'a set -> 'a set -> 'a set\nend\n\n```", "```\nmodule type EQUAL = sig\n  type t\n  val equal : t -> t -> bool\nend\n\n```", "```\nmodule type SETFUNCTOR =\n  functor (Equal : EQUAL) ->\n    sig\n      type elt = Equal.t\n      type set\n      val empty : set\n      val mem : elt -> set -> bool\n      val add: elt -> set -> set\n      val size: set -> int\n    end\n\n```", "```\nmodule MakeSet : SETFUNCTOR =\n  functor (Equal : EQUAL) ->\n    struct\n      open Equal\n      type elt = t\n      type set = elt list\n      let empty = []\n      let mem x = List.exists (equal x)\n      let add x s = if mem x s then s else x :: s\n      let size = List.length\n    end\n\n```", "```\nmodule MakeSet : SETFUNCTOR =\n\n```", "```\n  functor (Equal : EQUAL) ->\n\n```", "```\n  let mem x = List.exists (equal x)\n\n```", "```\n  let mem x s = List.exists (fun y -> equal x y) s\n\n```", "```\nmodule StringNoCase =\n  struct\n    type t = string\n    let equal s1 s2 =\n      String.lowercase s1 = String.lowercase s2\n  end\n\n```", "```\nmodule SSet = MakeSet (StringNoCase)\n\n```", "```\nmodule SSet :\n  sig\n    type elt = StringNoCase.t\n    type set = MakeSet(StringNoCase).set\n    val empty : set\n    val mem : elt -> set -> bool\n    val add : elt -> set -> set\n    val size : set -> int\n  end\n\n```", "```\n# let s = SSet.add \"I like CS 3110\" SSet.empty;;\nval s : SSet.set = <abstr>\n# SSet.mem \"i LiKe cs 3110\" s;;\n- : bool = true\n# SSet.size s;;\n- : int = 1\n\n```", "```\nmodule IntAbs = struct\n  type t = int\n  let equal i1 i2 = abs i1 = abs i2\nend\n\nmodule ISet = MakeSet (IntAbs)\n\n```", "```\n# let i = ISet.add 1 ISet.empty;;\nval i : ISet.set = <abstr>\n# ISet.mem 1 i;;\n- : bool = true\n# ISet.mem (-1) i;;\n- : bool = true\n# ISet.size i;;\n- : int = 1\n# let i = ISet.add (-1) i;;\nval i : ISet.set = <abstr>\n# ISet.size i;;\n- : int = 1\n\n```", "```\nmodule StringNoCase : EQUAL =\n  struct\n    type t = string\n    let equal s1 s2 =\n      String.lowercase s1 = String.lowercase s2\n  end\n\n```", "```\n# module SSet = MakeSet (StringNoCase);;\nmodule SSet :\n  sig\n    type elt = StringNoCase.t\n    type set = MakeSet(StringNoCase).set\n    val empty : set\n    val mem : elt -> set -> bool\n    val add : elt -> set -> set\n    val size : set -> int\n  end\n# let s = SSet.add \"I like CS 3110\" SSet.empty;;\nCharacters 17-33:\n  let s = SSet.add \"I like CS 3110\" SSet.empty;;\n                   ^^^^^^^^^^^^^^^^\nError: This expression has type string but is here used with type\n         SSet.elt = StringNoCase.t\n\n```", "```\n# module StringNoCase =\n    struct\n      type t = string\n      let equal s1 s2 =\n        String.lowercase s1 = String.lowercase s2\n    end;;\nmodule StringNoCase :\n  sig\n    type t = string\n    val equal : string -> string -> bool\n  end\n\n```", "```\nmodule StringNoCase =\n  struct\n    type t = string\n    let compare s1 s2 =\n      String.compare (String.lowercase s1) (String.lowercase s2)\n    let equal s1 s2 = compare s1 s2 = 0\n  end\n\n```", "```\n# module StringNoCaseEq = (StringNoCase : EQUAL);;\nmodule StringNoCaseEq : EQUAL\n\n```", "```\nmodule type SET =\n  sig\n    type elt\n    type set\n    val empty : set\n    val mem : elt -> set -> bool\n    val add: elt -> set -> set\n    val size: set -> int\n  end\n\nmodule type SETFUNCTOR = functor (Equal : EQUAL) -> SET\n\n```", "```\nmodule type SETFUNCTOR =\n  functor (Equal : EQUAL) -> SET with type elt = Equal.t\n\n```", "```\n# module type SETFUNCTOR =\n    functor (Equal : EQUAL) -> SET with type elt = Equal.t;;\nmodule type SETFUNCTOR =\n  functor (Equal : EQUAL) ->\n    sig\n      type elt = Equal.t\n      type set\n      val empty : set\n      val mem : elt -> set -> bool\n      val add : elt -> set -> set\n      val size : set -> int\n    end\n\n```"]