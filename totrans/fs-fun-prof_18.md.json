["```\ntype Contact = \n    {\n    FirstName: string;\n    MiddleInitial: string;\n    LastName: string;\n\n    EmailAddress: string;\n    //true if ownership of email address is confirmed\n    IsEmailVerified: bool;\n\n    Address1: string;\n    Address2: string;\n    City: string;\n    State: string;\n    Zip: string;\n    //true if validated against address service\n    IsAddressValid: bool; \n    } \n```", "```\ntype PostalAddress = \n    {\n    Address1: string;\n    Address2: string;\n    City: string;\n    State: string;\n    Zip: string;\n    }\n\ntype PostalContactInfo = \n    {\n    Address: PostalAddress;\n    IsAddressValid: bool;\n    } \n```", "```\ntype PersonalName = \n    {\n    FirstName: string;\n    // use \"option\" to signal optionality\n    MiddleInitial: string option;\n    LastName: string;\n    } \n```", "```\ntype PersonalName = \n    {\n    FirstName: string;\n    // use \"option\" to signal optionality\n    MiddleInitial: string option;\n    LastName: string;\n    }\n\ntype EmailContactInfo = \n    {\n    EmailAddress: string;\n    IsEmailVerified: bool;\n    }\n\ntype PostalAddress = \n    {\n    Address1: string;\n    Address2: string;\n    City: string;\n    State: string;\n    Zip: string;\n    }\n\ntype PostalContactInfo = \n    {\n    Address: PostalAddress;\n    IsAddressValid: bool;\n    }\n\ntype Contact = \n    {\n    Name: PersonalName;\n    EmailContactInfo: EmailContactInfo;\n    PostalContactInfo: PostalContactInfo;\n    } \n```", "```\n EmailAddress: string;\nState: string;\nZip: string; \n```", "```\ntype EmailAddress = EmailAddress of string\ntype ZipCode = ZipCode of string\ntype StateCode = StateCode of string \n```", "```\ntype EmailAddress = { EmailAddress: string }\ntype ZipCode = { ZipCode: string }\ntype StateCode = { StateCode: string} \n```", "```\ntype EmailAddress = EmailAddress of string\n\n// using the constructor as a function\n\"a\" |> EmailAddress\n[\"a\"; \"b\"; \"c\"] |> List.map EmailAddress\n\n// inline deconstruction\nlet a' = \"a\" |> EmailAddress\nlet (EmailAddress a'') = a'\n\nlet addresses = \n    [\"a\"; \"b\"; \"c\"] \n    |> List.map EmailAddress\n\nlet addresses' = \n    addresses\n    |> List.map (fun (EmailAddress e) -> e) \n```", "```\ntype PersonalName = \n    {\n    FirstName: string;\n    MiddleInitial: string option;\n    LastName: string;\n    }\n\ntype EmailAddress = EmailAddress of string\n\ntype EmailContactInfo = \n    {\n    EmailAddress: EmailAddress;\n    IsEmailVerified: bool;\n    }\n\ntype ZipCode = ZipCode of string\ntype StateCode = StateCode of string\n\ntype PostalAddress = \n    {\n    Address1: string;\n    Address2: string;\n    City: string;\n    State: StateCode;\n    Zip: ZipCode;\n    }\n\ntype PostalContactInfo = \n    {\n    Address: PostalAddress;\n    IsAddressValid: bool;\n    }\n\ntype Contact = \n    {\n    Name: PersonalName;\n    EmailContactInfo: EmailContactInfo;\n    PostalContactInfo: PostalContactInfo;\n    } \n```", "```\ntype EmailAddress = EmailAddress of string\ntype ZipCode = ZipCode of string\ntype StateCode = StateCode of string \n```", "```\nval f: string -> EmailAddress \n```", "```\nlet x = EmailAddress y \n```", "```\n ... types as above ...\n\nlet CreateEmailAddress (s:string) = \n    if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n        then Some (EmailAddress s)\n        else None\n\nlet CreateStateCode (s:string) = \n    let s' = s.ToUpper()\n    let stateCodes = [\"AZ\";\"CA\";\"NY\"] //etc\n    if stateCodes |> List.exists ((=) s')\n        then Some (StateCode s')\n        else None \n```", "```\nCreateStateCode \"CA\"\nCreateStateCode \"XX\"\n\nCreateEmailAddress \"a@example.com\"\nCreateEmailAddress \"example.com\" \n```", "```\nmatch (CreateEmailAddress \"a@example.com\") with\n| Some email -> ... do something with email\n| None -> ... ignore? \n```", "```\ntype EmailAddress = EmailAddress of string\ntype CreationResult<'T> = Success of 'T | Error of string            \n\nlet CreateEmailAddress2 (s:string) = \n    if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n        then Success (EmailAddress s)\n        else Error \"Email address must contain an @ sign\"\n\n// test\nCreateEmailAddress2 \"example.com\" \n```", "```\ntype EmailAddress = EmailAddress of string\n\nlet CreateEmailAddressWithContinuations success failure (s:string) = \n    if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n        then success (EmailAddress s)\n        else failure \"Email address must contain an @ sign\" \n```", "```\nlet success (EmailAddress s) = printfn \"success creating email %s\" s        \nlet failure  msg = printfn \"error creating email: %s\" msg\nCreateEmailAddressWithContinuations success failure \"example.com\"\nCreateEmailAddressWithContinuations success failure \"x@example.com\" \n```", "```\nlet success e = Some e\nlet failure _  = None\nCreateEmailAddressWithContinuations success failure \"example.com\"\nCreateEmailAddressWithContinuations success failure \"x@example.com\" \n```", "```\nlet success e = e\nlet failure _  = failwith \"bad email address\"\nCreateEmailAddressWithContinuations success failure \"example.com\"\nCreateEmailAddressWithContinuations success failure \"x@example.com\" \n```", "```\n// setup a partially applied function\nlet success e = Some e\nlet failure _  = None\nlet createEmail = CreateEmailAddressWithContinuations success failure\n\n// use the partially applied function\ncreateEmail \"x@example.com\"\ncreateEmail \"example.com\" \n```", "```\nmodule EmailAddress = \n\n    type T = EmailAddress of string\n\n    // wrap\n    let create (s:string) = \n        if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n            then Some (EmailAddress s)\n            else None\n\n    // unwrap\n    let value (EmailAddress e) = e \n```", "```\n // create email addresses\nlet address1 = EmailAddress.create \"x@example.com\"\nlet address2 = EmailAddress.create \"example.com\"\n\n// unwrap an email address\nmatch address1 with\n| Some e -> EmailAddress.value e |> printfn \"the value is %s\"\n| None -> () \n```", "```\n module EmailAddress = \n\n    // private type\n    type _T = EmailAddress of string\n\n    // wrap\n    let create (s:string) = \n        if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n            then Some (EmailAddress s)\n            else None\n\n    // unwrap\n    let value (EmailAddress e) = e \n```", "```\n// FILE: EmailAddress.fsi\n\nmodule EmailAddress  \n\n// encapsulated type\ntype T\n\n// wrap\nval create : string -> T option\n\n// unwrap\nval value : T -> string \n```", "```\n// FILE: EmailAddress.fs\n\nmodule EmailAddress  \n\n// encapsulated type\ntype T = EmailAddress of string\n\n// wrap\nlet create (s:string) = \n    if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n        then Some (EmailAddress s)\n        else None\n\n// unwrap\nlet value (EmailAddress e) = e \n```", "```\n// FILE: EmailAddressClient.fs\n\nmodule EmailAddressClient\n\nopen EmailAddress\n\n// code works when using the published functions\nlet address1 = EmailAddress.create \"x@example.com\"\nlet address2 = EmailAddress.create \"example.com\"\n\n// code that uses the internals of the type fails to compile\nlet address3 = T.EmailAddress \"bad email\" \n```", "```\nlet processFormSubmit () = \n    let s = uiTextBox.Text\n    if (s.Length < 50) \n        then // set email on domain object\n        else // show validation error message \n```", "```\nlet processFormSubmit () = \n    let emailOpt = uiTextBox.Text |> EmailAddress.create \n    match emailOpt with\n    | Some email -> // set email on domain object\n    | None -> // show validation error message \n```", "```\naddress |> EmailAddress.value |> printfn \"the value is %s\" \n```", "```\naddress |> EmailAddress.apply (printfn \"the value is %s\") \n```", "```\nmodule EmailAddress = \n\n    type _T = EmailAddress of string\n\n    // create with continuation\n    let createWithCont success failure (s:string) = \n        if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n            then success (EmailAddress s)\n            else failure \"Email address must contain an @ sign\"\n\n    // create directly\n    let create s = \n        let success e = Some e\n        let failure _  = None\n        createWithCont success failure s\n\n    // unwrap with continuation\n    let apply f (EmailAddress e) = f e\n\n    // unwrap directly\n    let value e = apply id e \n```", "```\nmodule EmailAddress = \n\n    type T = EmailAddress of string\n\n    // create with continuation\n    let createWithCont success failure (s:string) = \n        if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n            then success (EmailAddress s)\n            else failure \"Email address must contain an @ sign\"\n\n    // create directly\n    let create s = \n        let success e = Some e\n        let failure _  = None\n        createWithCont success failure s\n\n    // unwrap with continuation\n    let apply f (EmailAddress e) = f e\n\n    // unwrap directly\n    let value e = apply id e\n\nmodule ZipCode = \n\n    type T = ZipCode of string\n\n    // create with continuation\n    let createWithCont success failure  (s:string) = \n        if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\d{5}$\") \n            then success (ZipCode s) \n            else failure \"Zip code must be 5 digits\"\n\n    // create directly\n    let create s = \n        let success e = Some e\n        let failure _  = None\n        createWithCont success failure s\n\n    // unwrap with continuation\n    let apply f (ZipCode e) = f e\n\n    // unwrap directly\n    let value e = apply id e\n\nmodule StateCode = \n\n    type T = StateCode of string\n\n    // create with continuation\n    let createWithCont success failure  (s:string) = \n        let s' = s.ToUpper()\n        let stateCodes = [\"AZ\";\"CA\";\"NY\"] //etc\n        if stateCodes |> List.exists ((=) s')\n            then success (StateCode s') \n            else failure \"State is not in list\"\n\n    // create directly\n    let create s = \n        let success e = Some e\n        let failure _  = None\n        createWithCont success failure s\n\n    // unwrap with continuation\n    let apply f (StateCode e) = f e\n\n    // unwrap directly\n    let value e = apply id e\n\ntype PersonalName = \n    {\n    FirstName: string;\n    MiddleInitial: string option;\n    LastName: string;\n    }\n\ntype EmailContactInfo = \n    {\n    EmailAddress: EmailAddress.T;\n    IsEmailVerified: bool;\n    }\n\ntype PostalAddress = \n    {\n    Address1: string;\n    Address2: string;\n    City: string;\n    State: StateCode.T;\n    Zip: ZipCode.T;\n    }\n\ntype PostalContactInfo = \n    {\n    Address: PostalAddress;\n    IsAddressValid: bool;\n    }\n\ntype Contact = \n    {\n    Name: PersonalName;\n    EmailContactInfo: EmailContactInfo;\n    PostalContactInfo: PostalContactInfo;\n    } \n```", "```\ntype Contact = \n    {\n    Name: Name;\n    EmailContactInfo: EmailContactInfo;\n    PostalContactInfo: PostalContactInfo;\n    } \n```", "```\ntype Contact = \n    {\n    Name: PersonalName;\n    EmailContactInfo: EmailContactInfo option;\n    PostalContactInfo: PostalContactInfo option;\n    } \n```", "```\ntype ContactInfo = \n    | EmailOnly of EmailContactInfo\n    | PostOnly of PostalContactInfo\n    | EmailAndPost of EmailContactInfo * PostalContactInfo\n\ntype Contact = \n    {\n    Name: Name;\n    ContactInfo: ContactInfo;\n    } \n```", "```\nlet contactFromEmail name emailStr = \n    let emailOpt = EmailAddress.create emailStr\n    // handle cases when email is valid or invalid\n    match emailOpt with\n    | Some email -> \n        let emailContactInfo = \n            {EmailAddress=email; IsEmailVerified=false}\n        let contactInfo = EmailOnly emailContactInfo \n        Some {Name=name; ContactInfo=contactInfo}\n    | None -> None\n\nlet name = {FirstName = \"A\"; MiddleInitial=None; LastName=\"Smith\"}\nlet contactOpt = contactFromEmail name \"abc@example.com\" \n```", "```\nlet updatePostalAddress contact newPostalAddress = \n    let {Name=name; ContactInfo=contactInfo} = contact\n    let newContactInfo =\n        match contactInfo with\n        | EmailOnly email ->\n            EmailAndPost (email,newPostalAddress) \n        | PostOnly _ -> // ignore existing address\n            PostOnly newPostalAddress \n        | EmailAndPost (email,_) -> // ignore existing address\n            EmailAndPost (email,newPostalAddress) \n    // make a new contact\n    {Name=name; ContactInfo=newContactInfo} \n```", "```\nlet contact = contactOpt.Value   // see warning about option.Value below\nlet newPostalAddress = \n    let state = StateCode.create \"CA\"\n    let zip = ZipCode.create \"97210\"\n    {   \n        Address = \n            {\n            Address1= \"123 Main\";\n            Address2=\"\";\n            City=\"Beverly Hills\";\n            State=state.Value; // see warning about option.Value below\n            Zip=zip.Value;     // see warning about option.Value below\n            }; \n        IsAddressValid=false\n    }\nlet newContact = updatePostalAddress contact newPostalAddress \n```", "```\ntype ContactInfo = \n    | EmailOnly of EmailContactInfo\n    | PostOnly of PostalContactInfo\n    | EmailAndPost of EmailContactInfo * PostalContactInfo \n```", "```\ntype ContactInfo = \n    | EmailOnly of EmailContactInfo\n    | PostOnly of PostalContactInfo\n    | EmailAndPost of EmailContactInfo * PostalContactInfo \n```", "```\ntype ContactInformation = \n    {\n    EmailAddresses : EmailContactInfo list;\n    PostalAddresses : PostalContactInfo list\n    } \n```", "```\n// mock code \nlet printEmail emailAddress = \n    printfn \"Email Address is %s\" emailAddress \n\n// mock code\nlet printPostalAddress postalAddress = \n    printfn \"Postal Address is %s\" postalAddress \n\nlet printReport contactInfo = \n    let {\n        EmailAddresses = emailAddresses; \n        PostalAddresses = postalAddresses; \n        } = contactInfo\n    for email in emailAddresses do\n         printEmail email\n    for postalAddress in postalAddresses do\n         printPostalAddress postalAddress \n```", "```\ntype PhoneContactInfo = string // dummy for now\n\ntype ContactInformation = \n    {\n    EmailAddresses : EmailContactInfo list;\n    PostalAddresses : PostalContactInfo list;\n    HomePhones : PhoneContactInfo list;\n    WorkPhones : PhoneContactInfo list;\n    } \n```", "```\nlet printReport contactInfo = \n    let {\n        EmailAddresses = emailAddresses; \n        PostalAddresses = postalAddresses; \n        } = contactInfo\n    for email in emailAddresses do\n         printEmail email\n    for postalAddress in postalAddresses do\n         printPostalAddress postalAddress \n```", "```\ntype ContactMethod = \n    | Email of EmailContactInfo \n    | PostalAddress of PostalContactInfo \n    | HomePhone of PhoneContactInfo \n    | WorkPhone of PhoneContactInfo \n\ntype ContactInformation = \n    {\n    ContactMethods  : ContactMethod list;\n    } \n```", "```\n// mock code \nlet printContactMethod cm = \n    match cm with\n    | Email emailAddress -> \n        printfn \"Email Address is %s\" emailAddress \n    | PostalAddress postalAddress -> \n         printfn \"Postal Address is %s\" postalAddress \n    | HomePhone phoneNumber -> \n        printfn \"Home Phone is %s\" phoneNumber \n    | WorkPhone phoneNumber -> \n        printfn \"Work Phone is %s\" phoneNumber \n\nlet printReport contactInfo = \n    let {\n        ContactMethods=methods; \n        } = contactInfo\n    methods\n    |> List.iter printContactMethod \n```", "```\ntype Contact = \n    {\n    Name: PersonalName;\n    ContactMethods: ContactMethod list;\n    } \n```", "```\ntype Contact = \n    {\n    Name: PersonalName;\n    PrimaryContactMethod: ContactMethod;\n    SecondaryContactMethods: ContactMethod list;\n    } \n```", "```\nmodule EmailAddress = \n\n    type T = EmailAddress of string\n\n    let create (s:string) = \n        if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n            then Some (EmailAddress s)\n            else None \n```", "```\nmodule EmailAddress = \n\n    type T = \n        | ValidEmailAddress of string\n        | InvalidEmailAddress of string\n\n    let create (s:string) = \n        if System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n            then ValidEmailAddress s    // change result type \n            else InvalidEmailAddress s  // change result type\n\n    // test\n    let valid = create \"abc@example.com\"\n    let invalid = create \"example.com\" \n```", "```\nlet sendMessageTo t = \n    match t with \n    | ValidEmailAddress email ->\n         // send email\n    | InvalidEmailAddress _ -> \n         // ignore \n```", "```\ntype ActiveCartData = { UnpaidItems: string list }\ntype PaidCartData = { PaidItems: string list; Payment: float }\n\ntype ShoppingCart = \n    | EmptyCart  // no data\n    | ActiveCart of ActiveCartData\n    | PaidCart of PaidCartData \n```", "```\nlet addItem cart item = \n    match cart with\n    | EmptyCart -> \n        // create a new active cart with one item\n        ActiveCart {UnpaidItems=[item]}\n    | ActiveCart {UnpaidItems=existingItems} -> \n        // create a new ActiveCart with the item added\n        ActiveCart {UnpaidItems = item :: existingItems}\n    | PaidCart _ ->  \n        // ignore\n        cart\n\nlet makePayment cart payment = \n    match cart with\n    | EmptyCart -> \n        // ignore\n        cart\n    | ActiveCart {UnpaidItems=existingItems} -> \n        // create a new PaidCart with the payment\n        PaidCart {PaidItems = existingItems; Payment=payment}\n    | PaidCart _ ->  \n        // ignore\n        cart \n```", "```\nlet makePayment2 activeCart payment = \n    let {UnpaidItems=existingItems} = activeCart\n    {PaidItems = existingItems; Payment=payment} \n```", "```\n// the original function \nval makePayment : ShoppingCart -> float -> ShoppingCart\n\n// the new more specific function\nval makePayment2 :  ActiveCartData -> float -> PaidCartData \n```", "```\nlet paymentReport paidCarts = \n    let printOneLine {Payment=payment} = \n        printfn \"Paid %f for items\" payment\n    paidCarts |> List.iter printOneLine \n```", "```\ntype EmailContactInfo = \n    {\n    EmailAddress: EmailAddress.T;\n    IsEmailVerified: bool;\n    } \n```", "```\nmodule EmailContactInfo = \n    open System\n\n    // placeholder\n    type EmailAddress = string\n\n    // UnverifiedData = just the email\n    type UnverifiedData = EmailAddress\n\n    // VerifiedData = email plus the time it was verified\n    type VerifiedData = EmailAddress * DateTime \n\n    // set of states\n    type T = \n        | UnverifiedState of UnverifiedData\n        | VerifiedState of VerifiedData \n```", "```\nmodule EmailContactInfo = \n\n    // types as above\n\n    let create email = \n        // unverified on creation\n        UnverifiedState email\n\n    // handle the \"verified\" event\n    let verified emailContactInfo dateVerified = \n        match emailContactInfo with\n        | UnverifiedState email ->\n            // construct a new info in the verified state\n            VerifiedState (email, dateVerified) \n        | VerifiedState _ ->\n            // ignore\n            emailContactInfo \n```", "```\nmodule EmailContactInfo = \n\n    // types and functions as above\n\n    let sendVerificationEmail emailContactInfo = \n        match emailContactInfo with\n        | UnverifiedState email ->\n            // send email\n            printfn \"sending email\"\n        | VerifiedState _ ->\n            // do nothing\n            ()\n\n    let sendPasswordReset emailContactInfo = \n        match emailContactInfo with\n        | UnverifiedState email ->\n            // ignore\n            ()\n        | VerifiedState _ ->\n            // ignore\n            printfn \"sending password reset\" \n```", "```\nopen System\n\ntype PackageStatus = \n    | Undelivered\n    | OutForDelivery\n    | Delivered\n\ntype Package = \n    {\n    PackageId: int;\n    PackageStatus: PackageStatus;\n    DeliveryDate: DateTime;\n    DeliverySignature: string;\n    } \n```", "```\nlet putOnTruck package = \n    {package with PackageStatus=OutForDelivery}\n\nlet signedFor package signature = \n    let {PackageStatus=packageStatus} = package \n    if (packageStatus = Undelivered) \n    then \n        failwith \"package not out for delivery\"\n    else if (packageStatus = OutForDelivery) \n    then \n        {package with \n            PackageStatus=OutForDelivery;\n            DeliveryDate = DateTime.UtcNow;\n            DeliverySignature=signature;\n            }\n    else\n        failwith \"package already delivered\" \n```", "```\nopen System\n\ntype UndeliveredData = \n    {\n    PackageId: int;\n    }\n\ntype OutForDeliveryData = \n    {\n    PackageId: int;\n    }\n\ntype DeliveredData = \n    {\n    PackageId: int;\n    DeliveryDate: DateTime;\n    DeliverySignature: string;\n    }\n\ntype Package = \n    | Undelivered of UndeliveredData \n    | OutForDelivery of OutForDeliveryData\n    | Delivered of DeliveredData \n```", "```\nlet putOnTruck package = \n    match package with\n    | Undelivered {PackageId=id} ->\n        OutForDelivery {PackageId=id}\n    | OutForDelivery _ ->\n        failwith \"package already out\"\n    | Delivered _ ->\n        failwith \"package already delivered\"\n\nlet signedFor package signature = \n    match package with\n    | Undelivered _ ->\n        failwith \"package not out\"\n    | OutForDelivery {PackageId=id} ->\n        Delivered {\n            PackageId=id; \n            DeliveryDate = DateTime.UtcNow;\n            DeliverySignature=signature;\n            }\n    | Delivered _ ->\n        failwith \"package already delivered\" \n```", "```\nopen System\n\ntype Order = \n    {\n    OrderId: int;\n    PlacedDate: DateTime;\n    PaidDate: DateTime option;\n    PaidAmount: float option;\n    ShippedDate: DateTime option;\n    ShippingMethod: string option;\n    ReturnedDate: DateTime option;\n    ReturnedReason: string option;\n    } \n```", "```\nlet makePayment order payment = \n    if (order.PaidDate.IsSome)\n    then failwith \"order is already paid\"\n    //return an updated order with payment info\n    {order with \n        PaidDate=Some DateTime.UtcNow\n        PaidAmount=Some payment\n        }\n\nlet shipOrder order shippingMethod = \n    if (order.ShippedDate.IsSome)\n    then failwith \"order is already shipped\"\n    //return an updated order with shipping info\n    {order with \n        ShippedDate=Some DateTime.UtcNow\n        ShippingMethod=Some shippingMethod\n        } \n```", "```\nopen System\n\ntype InitialOrderData = \n    {\n    OrderId: int;\n    PlacedDate: DateTime;\n    }\ntype PaidOrderData = \n    {\n    Date: DateTime;\n    Amount: float;\n    }\ntype ShippedOrderData = \n    {\n    Date: DateTime;\n    Method: string;\n    }\ntype ReturnedOrderData = \n    {\n    Date: DateTime;\n    Reason: string;\n    }\n\ntype Order = \n    | Unpaid of InitialOrderData \n    | Paid of InitialOrderData * PaidOrderData\n    | Shipped of InitialOrderData * PaidOrderData * ShippedOrderData\n    | Returned of InitialOrderData * PaidOrderData * ShippedOrderData * ReturnedOrderData \n```", "```\nlet makePayment order payment = \n    match order with\n    | Unpaid i -> \n        let p = {Date=DateTime.UtcNow; Amount=payment}\n        // return the Paid order\n        Paid (i,p)\n    | _ ->\n        printfn \"order is already paid\"\n        order\n\nlet shipOrder order shippingMethod = \n    match order with\n    | Paid (i,p) -> \n        let s = {Date=DateTime.UtcNow; Method=shippingMethod}\n        // return the Shipped order\n        Shipped (i,p,s)\n    | Unpaid _ ->\n        printfn \"order is not paid for\"\n        order\n    | _ ->\n        printfn \"order is already shipped\"\n        order \n```", "```\ntype PersonalName = \n    {\n    FirstName: string;\n    LastName: string;\n    } \n```", "```\nvoid SaveToDatabase(PersonalName personalName) { \n   var first = personalName.First;\n   if (first.Length > 50)\n   {    \n        // ensure string is not too long\n        first = first.Substring(0,50);\n   }\n\n   //save to database\n} \n```", "```\nmodule String100 = \n    type T = String100 of string\n    let create (s:string) = \n        if s <> null && s.Length <= 100 \n        then Some (String100 s) \n        else None\n    let apply f (String100 s) = f s\n    let value s = apply id s\n\nmodule String50 = \n    type T = String50 of string\n    let create (s:string) = \n        if s <> null && s.Length <= 50 \n        then Some (String50 s) \n        else None\n    let apply f (String50 s) = f s\n    let value s = apply id s\n\nmodule String2 = \n    type T = String2 of string\n    let create (s:string) = \n        if s <> null && s.Length <= 2 \n        then Some (String2 s) \n        else None\n    let apply f (String2 s) = f s\n    let value s = apply id s \n```", "```\nlet s2good = String2.create \"CA\"\nlet s2bad = String2.create \"California\"\n\nmatch s2bad with\n| Some s2 -> // update domain object\n| None -> // handle error \n```", "```\nlet s50 = String50.create \"John\"\nlet s100 = String100.create \"Smith\"\n\nlet s50' = s50.Value\nlet s100' = s100.Value\n\nlet areEqual = (s50' = s100')  // compiler error \n```", "```\nmodule WrappedString = \n\n    /// An interface that all wrapped strings support\n    type IWrappedString = \n        abstract Value : string\n\n    /// Create a wrapped value option\n    /// 1) canonicalize the input first\n    /// 2) If the validation succeeds, return Some of the given constructor\n    /// 3) If the validation fails, return None\n    /// Null values are never valid.\n    let create canonicalize isValid ctor (s:string) = \n        if s = null \n        then None\n        else\n            let s' = canonicalize s\n            if isValid s'\n            then Some (ctor s') \n            else None\n\n    /// Apply the given function to the wrapped value\n    let apply f (s:IWrappedString) = \n        s.Value |> f \n\n    /// Get the wrapped value\n    let value s = apply id s\n\n    /// Equality test\n    let equals left right = \n        (value left) = (value right)\n\n    /// Comparison\n    let compareTo left right = \n        (value left).CompareTo (value right) \n```", "```\nmodule WrappedString = \n\n    // ... code from above ...\n\n    /// Canonicalizes a string before construction\n    /// * converts all whitespace to a space char\n    /// * trims both ends\n    let singleLineTrimmed s =\n        System.Text.RegularExpressions.Regex.Replace(s,\"\\s\",\" \").Trim()\n\n    /// A validation function based on length\n    let lengthValidator len (s:string) =\n        s.Length <= len \n\n    /// A string of length 100\n    type String100 = String100 of string with\n        interface IWrappedString with\n            member this.Value = let (String100 s) = this in s\n\n    /// A constructor for strings of length 100\n    let string100 = create singleLineTrimmed (lengthValidator 100) String100 \n\n    /// Converts a wrapped string to a string of length 100\n    let convertTo100 s = apply string100 s\n\n    /// A string of length 50\n    type String50 = String50 of string with\n        interface IWrappedString with\n            member this.Value = let (String50 s) = this in s\n\n    /// A constructor for strings of length 50\n    let string50 = create singleLineTrimmed (lengthValidator 50)  String50\n\n    /// Converts a wrapped string to a string of length 50\n    let convertTo50 s = apply string50 s \n```", "```\nmember this.Value = \n    let (String100 s) = this \n    s \n```", "```\nmember this.Value = let (String100 s) = this in s \n```", "```\nlet string100 = create singleLineTrimmed (lengthValidator 100) String100 \n```", "```\nmodule WrappedString = \n\n    // ... code from above ...\n\n    /// A multiline text of length 1000\n    type Text1000 = Text1000 of string with\n        interface IWrappedString with\n            member this.Value = let (Text1000 s) = this in s\n\n    /// A constructor for multiline strings of length 1000\n    let text1000 = create id (lengthValidator 1000) Text1000 \n```", "```\nlet s50 = WrappedString.string50 \"abc\" |> Option.get\nprintfn \"s50 is %A\" s50\nlet bad = WrappedString.string50 null\nprintfn \"bad is %A\" bad\nlet s100 = WrappedString.string100 \"abc\" |> Option.get\nprintfn \"s100 is %A\" s100\n\n// equality using module function is true\nprintfn \"s50 is equal to s100 using module equals? %b\" (WrappedString.equals s50 s100)\n\n// equality using Object method is false\nprintfn \"s50 is equal to s100 using Object.Equals? %b\" (s50.Equals s100)\n\n// direct equality does not compile\nprintfn \"s50 is equal to s100? %b\" (s50 = s100) // compiler error \n```", "```\nmodule WrappedString = \n\n    // ... code from above ...\n\n    /// map helpers\n    let mapAdd k v map = \n        Map.add (value k) v map    \n\n    let mapContainsKey k map =  \n        Map.containsKey (value k) map    \n\n    let mapTryFind k map =  \n        Map.tryFind (value k) map \n```", "```\nlet abc = WrappedString.string50 \"abc\" |> Option.get\nlet def = WrappedString.string100 \"def\" |> Option.get\nlet map = \n    Map.empty\n    |> WrappedString.mapAdd abc \"value for abc\"\n    |> WrappedString.mapAdd def \"value for def\"\n\nprintfn \"Found abc in map? %A\" (WrappedString.mapTryFind abc map)\n\nlet xyz = WrappedString.string100 \"xyz\" |> Option.get\nprintfn \"Found xyz in map? %A\" (WrappedString.mapTryFind xyz map) \n```", "```\nmodule PersonalName = \n    open WrappedString\n\n    type T = \n        {\n        FirstName: String50;\n        LastName: String100;\n        }\n\n    /// create a new value\n    let create first last = \n        match (string50 first),(string100 last) with\n        | Some f, Some l ->\n            Some {\n                FirstName = f;\n                LastName = l;\n                }\n        | _ -> \n            None \n```", "```\nlet name = PersonalName.create \"John\" \"Smith\" \n```", "```\nmodule PersonalName = \n\n    // ... code from above ...\n\n    /// concat the first and last names together \n    /// and return a raw string\n    let fullNameRaw personalName = \n        let f = personalName.FirstName |> value \n        let l = personalName.LastName |> value \n        f + \" \" + l \n\n    /// concat the first and last names together \n    /// and return None if too long\n    let fullNameOption personalName = \n        personalName |> fullNameRaw |> string100\n\n    /// concat the first and last names together \n    /// and truncate if too long\n    let fullNameTruncated personalName = \n        // helper function\n        let left n (s:string) = \n            if (s.Length > n) \n            then s.Substring(0,n)\n            else s\n\n        personalName \n        |> fullNameRaw  // concat\n        |> left 100     // truncate\n        |> string100    // wrap\n        |> Option.get   // this will always be ok \n```", "```\nmodule EmailAddress = \n\n    type T = EmailAddress of string with \n        interface WrappedString.IWrappedString with\n            member this.Value = let (EmailAddress s) = this in s\n\n    let create = \n        let canonicalize = WrappedString.singleLineTrimmed \n        let isValid s = \n            (WrappedString.lengthValidator 100 s) &&\n            System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n        WrappedString.create canonicalize isValid EmailAddress\n\n    /// Converts any wrapped string to an EmailAddress\n    let convert s = WrappedString.apply create s\n\nmodule ZipCode = \n\n    type T = ZipCode of string with\n        interface WrappedString.IWrappedString with\n            member this.Value = let (ZipCode s) = this in s\n\n    let create = \n        let canonicalize = WrappedString.singleLineTrimmed \n        let isValid s = \n            System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\d{5}$\") \n        WrappedString.create canonicalize isValid ZipCode\n\n    /// Converts any wrapped string to a ZipCode\n    let convert s = WrappedString.apply create s \n```", "```\ntype CustomerId = CustomerId of int\ntype OrderId = OrderId of int\n\nlet custId = CustomerId 42\nlet orderId = OrderId 42\n\n// compiler error\nprintfn \"cust is equal to order? %b\" (custId = orderId) \n```", "```\ntype LocalDttm = LocalDttm of System.DateTime\ntype UtcDttm = UtcDttm of System.DateTime \n```", "```\nlet SetOrderDate (d:LocalDttm) = \n    () // do something\n\nlet SetAuditTimestamp (d:UtcDttm) = \n    () // do something \n```", "```\nmodule NonNegativeInt = \n    type T = NonNegativeInt of int\n\n    let create i = \n        if (i >= 0 )\n        then Some (NonNegativeInt i)\n        else None\n\nmodule InventoryManager = \n\n    // example of NonNegativeInt in use\n    let SetStockQuantity (i:NonNegativeInt.T) = \n        //set stock\n        () \n```", "```\nmodule ShoppingCartWithBug = \n\n    let mutable itemQty = 1  // don't do this at home!\n\n    let incrementClicked() = \n        itemQty <- itemQty + 1\n\n    let decrementClicked() = \n        itemQty <- itemQty - 1 \n```", "```\nmodule ShoppingCartQty = \n\n    type T = ShoppingCartQty of int\n\n    let initialValue = ShoppingCartQty 1\n\n    let create i = \n        if (i > 0 && i < 100)\n        then Some (ShoppingCartQty i)\n        else None\n\n    let increment t = create (t + 1)\n    let decrement t = create (t - 1)\n\nmodule ShoppingCartWithTypedQty = \n\n    let mutable itemQty = ShoppingCartQty.initialValue\n\n    let incrementClicked() = \n        itemQty <- ShoppingCartQty.increment itemQty\n\n    let decrementClicked() = \n        itemQty <- ShoppingCartQty.decrement itemQty \n```", "```\ntype SafeDate = SafeDate of System.DateTime\n\nlet create dttm = \n    let min = new System.DateTime(1980,1,1)\n    let max = new System.DateTime(2038,1,1)\n    if dttm < min || dttm > max\n    then None\n    else Some (SafeDate dttm) \n```", "```\ntype TimeoutSecs = TimeoutSecs of int\ntype TimeoutMs = TimeoutMs of int\n\nlet toMs (TimeoutSecs secs)  = \n    TimeoutMs (secs * 1000)\n\nlet toSecs (TimeoutMs ms) = \n    TimeoutSecs (ms / 1000)\n\n/// sleep for a certain number of milliseconds\nlet sleep (TimeoutMs ms) = \n    System.Threading.Thread.Sleep ms\n\n/// timeout after a certain number of seconds \nlet commandTimeout (TimeoutSecs s) (cmd:System.Data.IDbCommand) = \n    cmd.CommandTimeout <- s \n```", "```\n[<Measure>] type sec \n[<Measure>] type ms\n\nlet toMs (secs:int<sec>) = \n    secs * 1000<ms/sec>\n\nlet toSecs (ms:int<ms>) = \n    ms / 1000<ms/sec>\n\n/// sleep for a certain number of milliseconds\nlet sleep (ms:int<ms>) = \n    System.Threading.Thread.Sleep (ms * 1<_>)\n\n/// timeout after a certain number of seconds \nlet commandTimeout (s:int<sec>) (cmd:System.Data.IDbCommand) = \n    cmd.CommandTimeout <- (s * 1<_>) \n```", "```\ntype Contact = \n    {\n    FirstName: string;\n    MiddleInitial: string;\n    LastName: string;\n\n    EmailAddress: string;\n    //true if ownership of email address is confirmed\n    IsEmailVerified: bool;\n\n    Address1: string;\n    Address2: string;\n    City: string;\n    State: string;\n    Zip: string;\n    //true if validated against address service\n    IsAddressValid: bool; \n    } \n```", "```\n// ========================================\n// WrappedString \n// ========================================\n\n/// Common code for wrapped strings\nmodule WrappedString = \n\n    /// An interface that all wrapped strings support\n    type IWrappedString = \n        abstract Value : string\n\n    /// Create a wrapped value option\n    /// 1) canonicalize the input first\n    /// 2) If the validation succeeds, return Some of the given constructor\n    /// 3) If the validation fails, return None\n    /// Null values are never valid.\n    let create canonicalize isValid ctor (s:string) = \n        if s = null \n        then None\n        else\n            let s' = canonicalize s\n            if isValid s'\n            then Some (ctor s') \n            else None\n\n    /// Apply the given function to the wrapped value\n    let apply f (s:IWrappedString) = \n        s.Value |> f \n\n    /// Get the wrapped value\n    let value s = apply id s\n\n    /// Equality \n    let equals left right = \n        (value left) = (value right)\n\n    /// Comparison\n    let compareTo left right = \n        (value left).CompareTo (value right)\n\n    /// Canonicalizes a string before construction\n    /// * converts all whitespace to a space char\n    /// * trims both ends\n    let singleLineTrimmed s =\n        System.Text.RegularExpressions.Regex.Replace(s,\"\\s\",\" \").Trim()\n\n    /// A validation function based on length\n    let lengthValidator len (s:string) =\n        s.Length <= len \n\n    /// A string of length 100\n    type String100 = String100 of string with\n        interface IWrappedString with\n            member this.Value = let (String100 s) = this in s\n\n    /// A constructor for strings of length 100\n    let string100 = create singleLineTrimmed (lengthValidator 100) String100 \n\n    /// Converts a wrapped string to a string of length 100\n    let convertTo100 s = apply string100 s\n\n    /// A string of length 50\n    type String50 = String50 of string with\n        interface IWrappedString with\n            member this.Value = let (String50 s) = this in s\n\n    /// A constructor for strings of length 50\n    let string50 = create singleLineTrimmed (lengthValidator 50)  String50\n\n    /// Converts a wrapped string to a string of length 50\n    let convertTo50 s = apply string50 s\n\n    /// map helpers\n    let mapAdd k v map = \n        Map.add (value k) v map    \n\n    let mapContainsKey k map =  \n        Map.containsKey (value k) map    \n\n    let mapTryFind k map =  \n        Map.tryFind (value k) map    \n\n// ========================================\n// Email address (not application specific)\n// ========================================\n\nmodule EmailAddress = \n\n    type T = EmailAddress of string with \n        interface WrappedString.IWrappedString with\n            member this.Value = let (EmailAddress s) = this in s\n\n    let create = \n        let canonicalize = WrappedString.singleLineTrimmed \n        let isValid s = \n            (WrappedString.lengthValidator 100 s) &&\n            System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\S+@\\S+\\.\\S+$\") \n        WrappedString.create canonicalize isValid EmailAddress\n\n    /// Converts any wrapped string to an EmailAddress\n    let convert s = WrappedString.apply create s\n\n// ========================================\n// ZipCode (not application specific)\n// ========================================\n\nmodule ZipCode = \n\n    type T = ZipCode of string with\n        interface WrappedString.IWrappedString with\n            member this.Value = let (ZipCode s) = this in s\n\n    let create = \n        let canonicalize = WrappedString.singleLineTrimmed \n        let isValid s = \n            System.Text.RegularExpressions.Regex.IsMatch(s,@\"^\\d{5}$\") \n        WrappedString.create canonicalize isValid ZipCode\n\n    /// Converts any wrapped string to a ZipCode\n    let convert s = WrappedString.apply create s\n\n// ========================================\n// StateCode (not application specific)\n// ========================================\n\nmodule StateCode = \n\n    type T = StateCode  of string with\n        interface WrappedString.IWrappedString with\n            member this.Value = let (StateCode  s) = this in s\n\n    let create = \n        let canonicalize = WrappedString.singleLineTrimmed \n        let stateCodes = [\"AZ\";\"CA\";\"NY\"] //etc\n        let isValid s = \n            stateCodes |> List.exists ((=) s)\n\n        WrappedString.create canonicalize isValid StateCode\n\n    /// Converts any wrapped string to a StateCode\n    let convert s = WrappedString.apply create s\n\n// ========================================\n// PostalAddress (not application specific)\n// ========================================\n\nmodule PostalAddress = \n\n    type USPostalAddress = \n        {\n        Address1: WrappedString.String50;\n        Address2: WrappedString.String50;\n        City: WrappedString.String50;\n        State: StateCode.T;\n        Zip: ZipCode.T;\n        }\n\n    type UKPostalAddress = \n        {\n        Address1: WrappedString.String50;\n        Address2: WrappedString.String50;\n        Town: WrappedString.String50;\n        PostCode: WrappedString.String50;   // todo\n        }\n\n    type GenericPostalAddress = \n        {\n        Address1: WrappedString.String50;\n        Address2: WrappedString.String50;\n        Address3: WrappedString.String50;\n        Address4: WrappedString.String50;\n        Address5: WrappedString.String50;\n        }\n\n    type T = \n        | USPostalAddress of USPostalAddress \n        | UKPostalAddress of UKPostalAddress \n        | GenericPostalAddress of GenericPostalAddress \n\n// ========================================\n// PersonalName (not application specific)\n// ========================================\n\nmodule PersonalName = \n    open WrappedString\n\n    type T = \n        {\n        FirstName: String50;\n        MiddleName: String50 option;\n        LastName: String100;\n        }\n\n    /// create a new value\n    let create first middle last = \n        match (string50 first),(string100 last) with\n        | Some f, Some l ->\n            Some {\n                FirstName = f;\n                MiddleName = (string50 middle)\n                LastName = l;\n                }\n        | _ -> \n            None\n\n    /// concat the names together \n    /// and return a raw string\n    let fullNameRaw personalName = \n        let f = personalName.FirstName |> value \n        let l = personalName.LastName |> value \n        let names = \n            match personalName.MiddleName with\n            | None -> [| f; l |]\n            | Some middle -> [| f; (value middle); l |]\n        System.String.Join(\" \", names)\n\n    /// concat the names together \n    /// and return None if too long\n    let fullNameOption personalName = \n        personalName |> fullNameRaw |> string100\n\n    /// concat the names together \n    /// and truncate if too long\n    let fullNameTruncated personalName = \n        // helper function\n        let left n (s:string) = \n            if (s.Length > n) \n            then s.Substring(0,n)\n            else s\n\n        personalName \n        |> fullNameRaw  // concat\n        |> left 100     // truncate\n        |> string100    // wrap\n        |> Option.get   // this will always be ok \n```", "```\n // ========================================\n// EmailContactInfo -- state machine\n// ========================================\n\nmodule EmailContactInfo = \n    open System\n\n    // UnverifiedData = just the EmailAddress\n    type UnverifiedData = EmailAddress.T\n\n    // VerifiedData = EmailAddress plus the time it was verified\n    type VerifiedData = EmailAddress.T * DateTime \n\n    // set of states\n    type T = \n        | UnverifiedState of UnverifiedData\n        | VerifiedState of VerifiedData\n\n    let create email = \n        // unverified on creation\n        UnverifiedState email\n\n    // handle the \"verified\" event\n    let verified emailContactInfo dateVerified = \n        match emailContactInfo with\n        | UnverifiedState email ->\n            // construct a new info in the verified state\n            VerifiedState (email, dateVerified) \n        | VerifiedState _ ->\n            // ignore\n            emailContactInfo\n\n    let sendVerificationEmail emailContactInfo = \n        match emailContactInfo with\n        | UnverifiedState email ->\n            // send email\n            printfn \"sending email\"\n        | VerifiedState _ ->\n            // do nothing\n            ()\n\n    let sendPasswordReset emailContactInfo = \n        match emailContactInfo with\n        | UnverifiedState email ->\n            // ignore\n            ()\n        | VerifiedState _ ->\n            // ignore\n            printfn \"sending password reset\"\n\n// ========================================\n// PostalContactInfo -- state machine\n// ========================================\n\nmodule PostalContactInfo = \n    open System\n\n    // InvalidData = just the PostalAddress\n    type InvalidData = PostalAddress.T\n\n    // ValidData = PostalAddress plus the time it was verified\n    type ValidData = PostalAddress.T * DateTime \n\n    // set of states\n    type T = \n        | InvalidState of InvalidData\n        | ValidState of ValidData\n\n    let create address = \n        // invalid on creation\n        InvalidState address\n\n    // handle the \"validated\" event\n    let validated postalContactInfo dateValidated = \n        match postalContactInfo with\n        | InvalidState address ->\n            // construct a new info in the valid state\n            ValidState (address, dateValidated) \n        | ValidState _ ->\n            // ignore\n            postalContactInfo \n\n    let contactValidationService postalContactInfo = \n        let dateIsTooLongAgo (d:DateTime) =\n            d < DateTime.Today.AddYears(-1)\n\n        match postalContactInfo with\n        | InvalidState address ->\n            printfn \"contacting the address validation service\"\n        | ValidState (address,date) when date |> dateIsTooLongAgo  ->\n            printfn \"last checked a long time ago.\"\n            printfn \"contacting the address validation service again\"\n        | ValidState  _ ->\n            printfn \"recently checked. Doing nothing.\"\n\n// ========================================\n// ContactMethod and Contact\n// ========================================\n\ntype ContactMethod = \n    | Email of EmailContactInfo.T \n    | PostalAddress of PostalContactInfo.T\n\ntype Contact = \n    {\n    Name: PersonalName.T;\n    PrimaryContactMethod: ContactMethod;\n    SecondaryContactMethods: ContactMethod list;\n    } \n```"]