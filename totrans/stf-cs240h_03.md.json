["```\n0\n```", "```\n0 + n == n n + 0 == n\n```", "```\n(a + b) + c == a + (b + c)\n```", "```\n1\n```", "```\n1 * n == n n * 1 == n\n```", "```\n(a * b) * c == a * (b * c)\n```", "```\n[]\n```", "```\n[] ++ n == n n ++ [] == n\n```", "```\n(a ++ b) ++ c == a ++ (b ++ c)\n```", "```\nTrue\n```", "```\nTrue && n == n n && True == n\n```", "```\n(a && b) && c == a && (b && c)\n```", "```\nclass Monoid a where -- A \"zero element\"  mempty :: a -- An associative operation  mappend :: a -> a -> a\n```", "```\nimport Data.Monoid\n```", "```\nmempty `mappend` n == n n `mappend` mempty == n\n```", "```\n(a `mappend` b) `mappend` c == a `mappend` (b `mappend` c)\n```", "```\ninstance Monoid [a] where mempty = [] xs `mappend` ys = xs ++ ys\n```", "```\nnewtype Product a = Product { getProduct :: a } deriving (Eq, Ord, Read, Show, Bounded) instance Num a => Monoid (Product a) where mempty = Product 1 Product x `mappend` Product y = Product (x * y)\n```", "```\nnewtype Sum a = Sum { getSum :: a } deriving (Eq, Ord, Read, Show, Bounded) instance Num a => Monoid (Sum a) where mempty = Sum 0 Sum x `mappend` Sum y = Sum (x + y)\n```", "```\ndata Either a b = Left a | Right b\n```", "```\ntype Result a = Either String a\n```", "```\nLeft \"you goofed\" `mappend` Left \"i win!\" `mappend` Right \"rats! you won!\" == Right \"rats! you won!\"\n```", "```\nclass Monoid a where  mempty :: a  mappend :: a -> a -> a data Either a b = Left a | Right b\n```", "```\ninstance Monoid (Either a b) where mempty = Left {- what ??? -} Right a `mappend` _ = Right a _ `mappend` b = b\n```", "```\nlength :: forall a. [a] -> Int\n```", "```\ninstance Monoid (Either a b) where mempty = Left {- what ??? -}\n```", "```\ninstance Monoid (Either a b) where mempty = Left {- what ??? -}\n```", "```\ninstance Monoid (Either String a) where mempty = Left \"fnord\" Right a `mappend` _ = Right a _ `mappend` b = b\n```", "```\n{-# LANGUAGE FlexibleInstances #-}\n```", "```\n{- i am a normal comment -} {-# i am a special comment #-}\n```", "```\n{-# LANGUAGE FlexibleInstances #-}\n```", "```\n{-# LANGUAGE FlexibleInstances #-} instance Monoid (Either String a) where mempty = Left \"fnord\" Right a `mappend` _ = Right a _ `mappend` b = b\n```", "```\n{-# LANGUAGE FlexibleInstances #-} import Data.Monoid newtype FirstRight a b = FirstRight {  getFirstRight :: Either a b } instance Monoid (FirstRight String a) where mempty = FirstRight (Left \"suxx0rz\") a@(FirstRight (Right _)) `mappend` _ = a _ `mappend` b = b\n```", "```\ncurl --data foo=bar --verbose \\ http://httpbin.org/post\n```", "```\ndata Part = Part { -- name of the <input> tag this belongs to  name :: String -- filename of file we're uploading , fileName :: Maybe FilePath -- type of file , contentType :: Maybe ContentType -- file contents , body :: String } deriving (Show)\n```", "```\ntype Param = (String, String) type ContentType = String data Payload = NoPayload | Raw ContentType String | Params [Param] | FormData [Part] deriving (Show)\n```", "```\ninstance Monoid Payload where mempty = NoPayload mappend NoPayload b = b mappend a NoPayload = a mappend (Params a) (Params b) = Params (a++b) {- ... -}\n```", "```\ndata Payload = NoPayload | Raw ContentType String | Params [Param] | FormData [Part]\n```", "```\n{-# LANGUAGE FlexibleInstances #-} -- I dropped the NoPayload constructor. Why? data Payload = Raw ContentType String | Params [Param] | FormData [Part] deriving (Show) instance Monoid (Maybe Payload) where mempty = Nothing mappend Nothing b = b mappend a Nothing = a mappend (Just (Params a)) (Just (Params b)) = Just (Params (a++b)) mappend (Just (FormData a)) (Just (FormData b)) = Just (FormData (a++b)) mappend _ _ = Nothing\n```", "```\nJust (Params []) `mappend` Just (Params [])\n```", "```\n{-# LANGUAGE FlexibleInstances, OverlappingInstances #-}\n```", "```\ndata Payload a = NoPayload | Raw ContentType String | Params [Param] | FormData [Part] deriving (Show)\n```", "```\nparam :: String -> String -> Payload [Param] param name value = Params [(name, value)]\n```", "```\nfilePart :: String -> FilePath -> IO (Payload [Part]) filePart name path = do body <- readFile name return (FormData [Part name (Just path) Nothing body])\n```", "```\nparam :: String -> String -> Payload [Param] filePart :: String -> FilePath -> IO (Payload [Part])\n```", "```\ninstance Monoid (Payload [Param]) where mempty = NoPayload mappend = addParams\n```", "```\ncurl -L http://cs240h.scs.stanford.edu/PayloadPhantom.hs\n```", "```\nparam :: String -> String -> Payload [Param] filePart :: String -> FilePath -> IO (Payload [Part]) fileString :: String -> Maybe FilePath -> String -> (Payload [Part])\n```", "```\nmodule PayloadPhantom ( Part(..) {- ... trimmed out ... -} ) where\n```", "```\nmodule PayloadPhantom ( Part(..) {- ... trimmed out ... -} ) where\n```", "```\nmodule PayloadPhantom ( Part(..) , Payload -- no constructors {- ... trimmed out ... -} ) where\n```", "```\nmodule PayloadPhantom ( Part(..) {- ... trimmed out ... -} ) where\n```", "```\nmodule PayloadPhantom ( Part(..) , Payload -- no constructors , param , filePart , fileString {- ... trimmed out ... -} ) where\n```", "```\nghci> param \"foo\" \"bar\" <> param \"baz\" \"quux\" Params [(\"foo\",\"bar\"),(\"baz\",\"quux\")]\n```", "```\n(<>) :: Monoid m => m -> m -> m (<>) = mappend\n```", "```\nparam \"foo\" \"bar\" <> fileString \"baz\" Nothing \"quux\"\n```", "```\ndata Payload a = NoPayload | Raw ContentType String | Params [Param] | FormData [Part] deriving (Show)\n```", "```\nimport Data.IORef newIORef :: a -> IO (IORef a) readIORef :: IORef a -> IO a writeIORef :: IORef a -> a -> IO () modifyIORef :: IORef a -> (a -> a) -> IO ()\n```", "```\ncurCfg <- readIORef cfgRef\n```", "```\nimport Data.IORef newtype Ref t a = Ref (IORef a)\n```", "```\ndata ReadOnly data ReadWrite\n```", "```\nnewRef :: a -> IO (Ref ReadWrite a) newRef a = Ref `fmap` newIORef a\n```", "```\nreadRef :: Ref t a -> IO a readRef (Ref ref) = readIORef ref\n```", "```\nwriteRef :: Ref ReadWrite a -> a -> IO () writeRef (Ref ref) v = writeIORef ref v\n```", "```\nreadOnly :: Ref t a -> Ref ReadOnly a readOnly (Ref ref) = Ref ref\n```", "```\nmodule Ref ( Ref, -- export type ctor, but not value ctor newRef, readOnly, readRef, writeRef ) where\n```"]