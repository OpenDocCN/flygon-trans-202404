["```\ntype CustomerName(firstName, middleInitial, lastName) = \n    member this.FirstName = firstName\n    member this.MiddleInitial = middleInitial\n    member this.LastName = lastName \n```", "```\npublic class CustomerName\n{\n    public CustomerName(string firstName, \n       string middleInitial, string lastName) {\n        this.FirstName = firstName;\n        this.MiddleInitial = middleInitial;\n        this.LastName = lastName;\n    }\n\n    public string FirstName { get; private set; }\n    public string MiddleInitial { get; private set; }\n    public string LastName { get; private set; }\n} \n```", "```\ntype CustomerName(firstName, middleInitial, lastName) \n```", "```\ntype CustomerName2(firstName:string, \n                   middleInitial:string, lastName:string) = \n    member this.FirstName = firstName\n    member this.MiddleInitial = middleInitial\n    member this.LastName = lastName \n```", "```\ntype NonTupledConstructor(x:int,y: int) = \n    do printfn \"x=%i y=%i\" x y    \n\ntype TupledConstructor(tuple:int * int) = \n    let x,y = tuple\n    do printfn \"x=%i y=%i\" x y    \n\n// calls look identical\nlet myNTC = new NonTupledConstructor(1,2)    \nlet myTC = new TupledConstructor(1,2) \n```", "```\ntype MyClass(intParam:int, strParam:string) = \n    member this.Two = 2\n    member this.Square x = x * x \n```", "```\ntype MyClass =\n  class\n    new : intParam:int * strParam:string -> MyClass\n    member Square : x:int -> int\n    member Two : int\n  end \n```", "```\nmember Square : x:int -> int \n```", "```\nval Square : int -> int \n```", "```\n// class constructor signature\nnew : intParam:int * strParam:string -> MyClass\n\n// standalone function signature\nval new : int * string -> MyClass \n```", "```\n// member property\nmember Two : int\n\n// standalone value\nval Two : int = 2 \n```", "```\ntype PrivateValueExample(seed) = \n\n    // private immutable value\n    let privateValue = seed + 1\n\n    // private mutable value\n    let mutable mutableValue = 42\n\n    // private function definition\n    let privateAddToSeed input = \n        seed + input\n\n    // public wrapper for private function\n    member this.AddToSeed x = \n        privateAddToSeed x\n\n    // public wrapper for mutable value\n    member this.SetMutableValue x = \n        mutableValue <- x \n\n// test\nlet instance = new PrivateValueExample(42)\nprintf \"%i\" (instance.AddToSeed 2)\ninstance.SetMutableValue 43 \n```", "```\ntype MutableConstructorParameter(seed) = \n    let mutable mutableSeed = seed \n\n    // public wrapper for mutable value\n    member this.SetSeed x = \n        mutableSeed <- x \n```", "```\ntype MutableConstructorParameter2(seed) = \n    let mutable seed = seed // shadow the parameter\n\n    // public wrapper for mutable value\n    member this.SetSeed x = \n        seed <- x \n```", "```\ntype DoExample(seed) = \n    let privateValue = seed + 1\n\n    //extra code to be done at construction time\n    do printfn \"the privateValue is now %i\" privateValue \n\n// test\nnew DoExample(42) \n```", "```\ntype DoPrivateFunctionExample(seed) =   \n    let privateValue = seed + 1\n\n    // some code to be done at construction time\n    do printfn \"hello world\"\n\n    // must come BEFORE the do block that calls it\n    let printPrivateValue() = \n        do printfn \"the privateValue is now %i\" privateValue \n\n    // more code to be done at construction time\n    do printPrivateValue()\n\n// test\nnew DoPrivateFunctionExample(42) \n```", "```\ntype DoPublicFunctionExample(seed) as this =   \n    // Note the \"this\" keyword in the declaration\n\n    let privateValue = seed + 1\n\n    // extra code to be done at construction time\n    do this.PrintPrivateValue()\n\n    // member\n    member this.PrintPrivateValue() = \n        do printfn \"the privateValue is now %i\" privateValue \n\n// test\nnew DoPublicFunctionExample(42) \n```", "```\ntype MethodExample() = \n\n    // standalone method\n    member this.AddOne x = \n        x + 1\n\n    // calls another method\n    member this.AddTwo x = \n        this.AddOne x |> this.AddOne\n\n    // parameterless method\n    member this.Pi() = \n        3.14159\n\n// test\nlet me = new MethodExample()\nprintfn \"%i\" <| me.AddOne 42\nprintfn \"%i\" <| me.AddTwo 42\nprintfn \"%f\" <| me.Pi() \n```", "```\ntype TupleAndCurriedMethodExample() = \n\n    // curried form\n    member this.CurriedAdd x y = \n        x + y\n\n    // tuple form\n    member this.TupleAdd(x,y) = \n        x + y\n\n// test\nlet tc = new TupleAndCurriedMethodExample()\nprintfn \"%i\" <| tc.CurriedAdd 1 2\nprintfn \"%i\" <| tc.TupleAdd(1,2)\n\n// use partial application\nlet addOne = tc.CurriedAdd 1  \nprintfn \"%i\" <| addOne 99 \n```", "```\ntype LetBoundFunctions() = \n\n    let listReduce reducer list = \n        list |> List.reduce reducer \n\n    let reduceWithSum sum elem = \n        sum + elem\n\n    let sum list = \n        list |> listReduce reduceWithSum \n\n    // finally a public wrapper \n    member this.Sum  = sum\n\n// test\nlet lbf = new LetBoundFunctions()\nprintfn \"Sum is %i\" <| lbf.Sum [1..10] \n```", "```\ntype MethodExample() = \n\n    // recursive method without \"rec\" keyword\n    member this.Fib x = \n        match x with\n        | 0 | 1 -> 1\n        | _ -> this.Fib (x-1) + this.Fib (x-2)\n\n// test\nlet me = new MethodExample()\nprintfn \"%i\" <| me.Fib 10 \n```", "```\ntype MethodExample() = \n    // explicit type annotation\n    member this.AddThree (x:int) :int = \n        x + 3 \n```", "```\ntype PropertyExample(seed) = \n    // immutable property \n    // using a constructor parameter\n    member this.Seed = seed \n```", "```\nwith get() = ...\nand set(value) = ... \n```", "```\ntype PropertyExample(seed) = \n    // private mutable value\n    let mutable myProp = seed\n\n    // mutable property\n    // changing a private mutable value\n    member this.MyProp \n        with get() = myProp \n        and set(value) =  myProp <- value \n```", "```\nmember val MyProp = initialValue \n```", "```\nmember val MyProp = initialValue with get,set \n```", "```\ntype PropertyExample(seed) = \n    // private mutable value\n    let mutable myProp = seed\n\n    // private function\n    let square x = x * x\n\n    // immutable property \n    // using a constructor parameter\n    member this.Seed = seed\n\n    // immutable property \n    // using a private function\n    member this.SeedSquared = square seed\n\n    // mutable property\n    // changing a private mutable value\n    member this.MyProp \n        with get() = myProp \n        and set(value) =  myProp <- value\n\n    // mutable property with private set\n    member this.MyProp2 \n        with get() = myProp \n        and private set(value) =  myProp <- value\n\n    // automatic immutable property (in VS2012)\n    member val ReadOnlyAuto = 1\n\n    // automatic mutable property (in VS2012)\n    member val ReadWriteAuto = 1 with get,set\n\n// test \nlet pe = new PropertyExample(42)\nprintfn \"%i\" <| pe.Seed\nprintfn \"%i\" <| pe.SeedSquared\nprintfn \"%i\" <| pe.MyProp\nprintfn \"%i\" <| pe.MyProp2\n\n// try calling set\npe.MyProp <- 43    // Ok\nprintfn \"%i\" <| pe.MyProp\n\n// try calling private set\npe.MyProp2 <- 43   // Error \n```", "```\ntype ParameterlessMethodExample() = \n    member this.MyProp = 1    // No parens!\n    member this.MyFunc() = 1  // Note the ()\n\n// in use\nlet x = new ParameterlessMethodExample()\nprintfn \"%i\" <| x.MyProp      // No parens!\nprintfn \"%i\" <| x.MyFunc()    // Note the () \n```", "```\ntype ParameterlessMethodExample =\n  class\n    new : unit -> ParameterlessMethodExample\n    member MyFunc : unit -> int\n    member MyProp : int\n  end \n```", "```\nlet MyFunc2() = 1 \nlet MyProp2 = 1 \n```", "```\nval MyFunc2 : unit -> int\nval MyProp2 : int = 1 \n```", "```\ntype MultipleConstructors(param1, param2) =\n    do printfn \"Param1=%i Param12=%i\" param1 param2\n\n    // secondary constructor\n    new(param1) = \n        MultipleConstructors(param1,-1) \n\n    // secondary constructor\n    new() = \n        printfn \"Constructing...\"\n        MultipleConstructors(13,17) \n\n// test\nlet mc1 = new MultipleConstructors(1,2)\nlet mc2 = new MultipleConstructors(42)\nlet mc3 = new MultipleConstructors() \n```", "```\ntype StaticExample() = \n    member this.InstanceValue = 1\n    static member StaticValue = 2  // no \"this\"\n\n// test\nlet instance = new StaticExample()\nprintf \"%i\" instance.InstanceValue\nprintf \"%i\" StaticExample.StaticValue \n```", "```\ntype StaticConstructor() =\n\n    // static field\n    static let rand = new System.Random()\n\n    // static do\n    static do printfn \"Class initialization!\"\n\n    // instance member accessing static field\n    member this.GetRand() = rand.Next() \n```", "```\ntype AccessibilityExample() = \n    member this.PublicValue = 1\n    member private this.PrivateValue = 2\n    member internal this.InternalValue = 3\n// test\nlet a = new AccessibilityExample();\nprintf \"%i\" a.PublicValue\nprintf \"%i\" a.PrivateValue  // not accessible \n```", "```\ntype AccessibilityExample2() = \n    let mutable privateValue = 42\n    member this.PrivateSetProperty\n        with get() = \n            privateValue \n        and private set(value) = \n            privateValue <- value\n\n// test\nlet a2 = new AccessibilityExample2();\nprintf \"%i\" a2.PrivateSetProperty  // ok to read\na2.PrivateSetProperty <- 43        // not ok to write \n```", "```\n// Note: this code will not work in an .FSX script, \n// only in an .FS source file.\nnamespace MyNamespace\n\ntype TopLevelClass() = \n    let nothing = 0\n\nmodule MyModule = \n\n    type NestedClass() = \n        let nothing = 0 \n```", "```\nnamespace MyNamespace\n{\n  public class TopLevelClass\n  {\n  // code\n  }\n\n  public static class MyModule\n  {\n    public class NestedClass\n    {\n    // code\n    }\n  }\n} \n```", "```\ntype MyClass(intParam:int, strParam:string) = \n    member this.Two = 2\n    member this.Square x = x * x\n\nlet myInstance = new MyClass(1,\"hello\") \n```", "```\nlet myInstance2 = MyClass(1,\"hello\")\nlet point = System.Drawing.Point(1,2)   // works with .NET classes too! \n```", "```\nlet sr1 = System.IO.StringReader(\"\")      // Warning\nlet sr2 = new System.IO.StringReader(\"\")  // OK \n```", "```\nmyInstance.Two\nmyInstance.Square 2 \n```", "```\ntype TupleAndCurriedMethodExample() = \n    member this.TupleAdd(x,y) = x + y\n    member this.CurriedAdd x y = x + y\n\nlet tc = TupleAndCurriedMethodExample()\ntc.TupleAdd(1,2)      // called with parens\ntc.CurriedAdd 1 2     // called without parens\n2 |> tc.CurriedAdd 1  // partial application \n```", "```\ntype DerivedClass(param1, param2) =\n   inherit BaseClass(param1) \n```", "```\npublic class MyBaseClass\n{\n    public MyBaseClass(int param1) {\n        this.Param1 = param1;\n    }\n    public int Param1 { get; private set; }\n}\n\npublic class MyDerivedClass: MyBaseClass\n{\n    public MyDerivedClass(int param1,int param2): base(param1) {\n        this.Param2 = param2;\n    }\n    public int Param2 { get; private set; }\n} \n```", "```\ntype BaseClass(param1) =\n   member this.Param1 = param1\n\ntype DerivedClass(param1, param2) =\n   inherit BaseClass(param1)\n   member this.Param2 = param2\n\n// test\nlet derived = new DerivedClass(1,2)\nprintfn \"param1=%O\" derived.Param1\nprintfn \"param2=%O\" derived.Param2 \n```", "```\n// concrete function definition\nlet Add x y = x + y\n\n// function signature\n// val Add : int -> int -> int \n```", "```\ntype BaseClass() =\n   abstract member Add: int -> int -> int \n```", "```\ntype BaseClass() =\n   abstract member Pi : float \n```", "```\ntype BaseClass() =\n   abstract Area : float with get,set \n```", "```\n// with default implementations\ntype BaseClass() =\n   // abstract method\n   abstract member Add: int -> int -> int\n   // abstract property\n   abstract member Pi : float \n\n   // defaults\n   default this.Add x y = x + y\n   default this.Pi = 3.14 \n```", "```\n[<AbstractClass>]\ntype AbstractBaseClass() =\n   // abstract method\n   abstract member Add: int -> int -> int\n\n   // abstract immutable property\n   abstract member Pi : float \n\n   // abstract read/write property\n   abstract member Area : float with get,set \n```", "```\n[<AbstractClass>]\ntype Animal() =\n   abstract member MakeNoise: unit -> unit \n\ntype Dog() =\n   inherit Animal() \n   override this.MakeNoise () = printfn \"woof\"\n\n// test\n// let animal = new Animal()  // error creating ABC\nlet dog = new Dog()\ndog.MakeNoise() \n```", "```\ntype Vehicle() =\n   abstract member TopSpeed: unit -> int\n   default this.TopSpeed() = 60\n\ntype Rocket() =\n   inherit Vehicle() \n   override this.TopSpeed() = base.TopSpeed() * 10\n\n// test\nlet vehicle = new Vehicle()\nprintfn \"vehicle.TopSpeed = %i\" <| vehicle.TopSpeed()\nlet rocket = new Rocket()\nprintfn \"rocket.TopSpeed = %i\" <| rocket.TopSpeed() \n```", "```\ntype MyInterface =\n   // abstract method\n   abstract member Add: int -> int -> int\n\n   // abstract immutable property\n   abstract member Pi : float \n\n   // abstract read/write property\n   abstract member Area : float with get,set \n```", "```\n[<AbstractClass>]\ntype AbstractBaseClass() =\n   // abstract method\n   abstract member Add: int -> int -> int\n\n   // abstract immutable property\n   abstract member Pi : float \n\n   // abstract read/write property\n   abstract member Area : float with get,set \n```", "```\ntype MyInterface =   // <- no parens! \n```", "```\ntype IAddingService =\n    abstract member Add: int -> int -> int\n\ntype MyAddingService() =\n\n    interface IAddingService with \n        member this.Add x y = \n            x + y\n\n    interface System.IDisposable with \n        member this.Dispose() = \n            printfn \"disposed\" \n```", "```\nlet mas = new MyAddingService()\nmas.Add 1 2    // error \n```", "```\n// cast to the interface\nlet mas = new MyAddingService()\nlet adder = mas :> IAddingService\nadder.Add 1 2  // ok \n```", "```\n// function that requires an interface\nlet testAddingService (adder:IAddingService) = \n    printfn \"1+2=%i\" <| adder.Add 1 2  // ok\n\nlet mas = new MyAddingService()\ntestAddingService mas // cast automatically \n```", "```\nlet testDispose = \n    use mas = new MyAddingService()\n    printfn \"testing\"\n    // Dispose() is called here \n```", "```\n// create a new object that implements IDisposable\nlet makeResource name = \n   { new System.IDisposable \n     with member this.Dispose() = printfn \"%s disposed\" name }\n\nlet useAndDisposeResources = \n    use r1 = makeResource \"first resource\"\n    printfn \"using first resource\" \n    for i in [1..3] do\n        let resourceName = sprintf \"\\tinner resource %d\" i\n        use temp = makeResource resourceName \n        printfn \"\\tdo something with %s\" resourceName \n    use r2 = makeResource \"second resource\"\n    printfn \"using second resource\" \n    printfn \"done.\" \n```", "```\nusing first resource\n    do something with   inner resource 1\n    inner resource 1 disposed\n    do something with   inner resource 2\n    inner resource 2 disposed\n    do something with   inner resource 3\n    inner resource 3 disposed\nusing second resource\ndone.\nsecond resource disposed\nfirst resource disposed\n\n```", "```\nlet makeAdder id = \n   { new IAddingService with \n     member this.Add x y =\n         printfn \"Adder%i is adding\" id \n         let result = x + y   \n         printfn \"%i + %i = %i\" x y result \n         result \n         }\n\nlet testAdders = \n    for i in [1..3] do\n        let adder = makeAdder i\n        let result = adder.Add i i \n        () //ignore result \n```"]