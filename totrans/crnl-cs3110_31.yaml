- en: VerifyCompilerA Verified Compiler for CS 3110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic expressions with constants and addition:    e ::= c | e + eIn OCaml,
    we could represent these with a data type:    type expr =
  prefs: []
  type: TYPE_NORMAL
- en: '| Const of int'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus of expr × exprIn Coq, they have a very similar representation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive expr : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| Const : nat → expr'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus : expr → expr → expr.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if we extract that Coq expr to OCaml, we get essentially what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Extraction expr.
  prefs: []
  type: TYPE_NORMAL
- en: (* type expr =
  prefs: []
  type: TYPE_NORMAL
- en: '| Const of nat'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus of expr * expr'
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  prefs: []
  type: TYPE_NORMAL
- en: The one mismatch is that Coq uses nat, whereas in OCaml we'd normally use int.
  prefs: []
  type: TYPE_NORMAL
- en: nat is (theoretically) unbounded and non-negative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: int is definitely bounded and can be negative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a library called Int31 in Coq that provides the equivalent to OCaml's
    31-bit int.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: Semantics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *dynamic semantics* of expressions is something we can easily implement.
    Here''s a simple interpreter that evaluates expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint evalExpr (e : expr) : nat :='
  prefs: []
  type: TYPE_NORMAL
- en: match e with
  prefs: []
  type: TYPE_NORMAL
- en: '| Const n ⇒ n'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus e1 e2 ⇒ plus (evalExpr e1) (evalExpr e2)'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this extracts to OCaml as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: Extraction evalExpr.
  prefs: []
  type: TYPE_NORMAL
- en: (*
  prefs: []
  type: TYPE_NORMAL
- en: let rec evalExpr = function
  prefs: []
  type: TYPE_NORMAL
- en: '| Const n -> n'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus (e1, e2) -> plus (evalExpr e1) (evalExpr e2)'
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: Unit tests of semantics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a couple test cases for our interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example source_test_1 : evalExpr (Const 42) = 42.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example source_test_2 : evalExpr (Plus (Const 2) (Const 2)) = 4.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Target Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary tasks of a *compiler* is to translate from a *high-level
    language* to a *low-level language*. For example,
  prefs: []
  type: TYPE_NORMAL
- en: The Java compiler translates from Java to JVM bytecode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OCaml compiler translates from OCaml to Zinc machine bytecode. [http://cadmium.x9c.fr/distrib/caml-instructions.pdf]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both compilers can additionally produce *native* code that runs on a particular
    machine architecture.JVM and OCaml bytecode are both based on a *stack machine*
    model, in which a stack is used as the main data structure, rather than a set
    of registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Target: Syntax'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So as a *target language*, let's use the following stack-machine instruction
    set:      inst ::= PUSH c | ADDAn inst is a machine instruction. A program prog
    is a list of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive inst : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| PUSH : nat → inst'
  prefs: []
  type: TYPE_NORMAL
- en: '| ADD : inst.'
  prefs: []
  type: TYPE_NORMAL
- en: Definition prog := list inst.
  prefs: []
  type: TYPE_NORMAL
- en: These extact to OCaml as we would expect.
  prefs: []
  type: TYPE_NORMAL
- en: Extraction inst.
  prefs: []
  type: TYPE_NORMAL
- en: (*
  prefs: []
  type: TYPE_NORMAL
- en: type inst =
  prefs: []
  type: TYPE_NORMAL
- en: '| PUSH of nat'
  prefs: []
  type: TYPE_NORMAL
- en: '| ADD'
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  prefs: []
  type: TYPE_NORMAL
- en: Extraction prog.
  prefs: []
  type: TYPE_NORMAL
- en: (*
  prefs: []
  type: TYPE_NORMAL
- en: type prog = inst list
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Target: Semantics'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define the *dynamic semantics* of this target language, we need a notion
    of a stack:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition stack := list nat.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to write an interpreter for the target language.Evaluation of
    a program takes in an initial stack, and returns the final stack. But since evaluation
    could fail (if we try to ADD when there aren't at least two values on the stack),
    we wrap the return in an option, and return None if an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint evalProg (p : prog) (s : stack) : option stack :='
  prefs: []
  type: TYPE_NORMAL
- en: match p,s with
  prefs: []
  type: TYPE_NORMAL
- en: '| (PUSH n)::p'', s ⇒ evalProg p'' (n::s)'
  prefs: []
  type: TYPE_NORMAL
- en: '| ADD::p'', x::y::s'' ⇒ evalProg p'' ((x+y)::s'')'
  prefs: []
  type: TYPE_NORMAL
- en: '| [], s ⇒ Some s'
  prefs: []
  type: TYPE_NORMAL
- en: '| _, _ ⇒ None'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'DOES THAT LOOK FAMILIAR? It should...Extraction of the deep pattern matching
    doesn''t turn out quite so nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: Extraction evalProg.
  prefs: []
  type: TYPE_NORMAL
- en: (*
  prefs: []
  type: TYPE_NORMAL
- en: let rec evalProg p s =
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  prefs: []
  type: TYPE_NORMAL
- en: '| Nil -> Some s'
  prefs: []
  type: TYPE_NORMAL
- en: '| Cons (i, p'') ->'
  prefs: []
  type: TYPE_NORMAL
- en: (match i with
  prefs: []
  type: TYPE_NORMAL
- en: '| PUSH n -> evalProg p'' (Cons (n, s))'
  prefs: []
  type: TYPE_NORMAL
- en: '| ADD ->'
  prefs: []
  type: TYPE_NORMAL
- en: (match s with
  prefs: []
  type: TYPE_NORMAL
- en: '| Nil -> None'
  prefs: []
  type: TYPE_NORMAL
- en: '| Cons (x, l) ->'
  prefs: []
  type: TYPE_NORMAL
- en: (match l with
  prefs: []
  type: TYPE_NORMAL
- en: '| Nil -> None'
  prefs: []
  type: TYPE_NORMAL
- en: '| Cons (y, s'') -> evalProg p'' (Cons ((plus x y), s'')))))'
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Target: Unit tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are a couple unit tests for the target language interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example target_test_1 : evalProg [PUSH 42] [] = Some [42].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example target_test_2 : evalProg [PUSH 2; PUSH 2; ADD] [] = Some [4].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we're ready to translate from the source language to the target language.
  prefs: []
  type: TYPE_NORMAL
- en: To translate a constant c, we just push c onto the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To translate an addition e1 + e2, we translate e2, translate e1, then append
    the instructions together, followed by an ADD instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (* returns: compile e produces a program p, such that
  prefs: []
  type: TYPE_NORMAL
- en: evaluation of p leaves a single new value at the top
  prefs: []
  type: TYPE_NORMAL
- en: of the stack, and that value would be the result of
  prefs: []
  type: TYPE_NORMAL
- en: evaluating e. *)
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint compile (e : expr) : prog :='
  prefs: []
  type: TYPE_NORMAL
- en: match e with
  prefs: []
  type: TYPE_NORMAL
- en: '| Const n ⇒ [PUSH n]'
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus e1 e2 ⇒ compile e2 ++ compile e1 ++ [ADD]'
  prefs: []
  type: TYPE_NORMAL
- en: end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that ++ is the Coq append operator, analogous to OCaml''s @.We can extract
    the compiler to its own file:'
  prefs: []
  type: TYPE_NORMAL
- en: Extraction "compiler.ml" compile.
  prefs: []
  type: TYPE_NORMAL
- en: Try using that file in the OCaml REPL!
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiler: Unit tests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a couple unit tests for our compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example compile_test_1 : compile (Const 42) = [PUSH 42].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example compile_test_2 : compile (Plus (Const 2) (Const 2))'
  prefs: []
  type: TYPE_NORMAL
- en: = [PUSH 2; PUSH 2; ADD].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'These tests demonstrate that the compiler produces some programs that do seem
    to correspond to the input expression. But we haven''t really tested the postcondition
    of compile: we want to know whether both side of the = above evaluate to the same
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example post_test_1 : evalProg (compile (Const 42)) [] = Some [evalExpr (Const
    42)].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example post_test_2 : evalProg (compile (Plus (Const 2) (Const 2))) []'
  prefs: []
  type: TYPE_NORMAL
- en: = Some [evalExpr (Plus (Const 2) (Const 2))].
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. But as we know from Dijkstra, "testing can only prove the presence
    of bugs, never their absence." How could we show that the compiler is correct
    for every input expression?WE PROVE IT...
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Verification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following theorem is a *specification* that says what it means for compile
    to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem compile_correct : ∀ e,'
  prefs: []
  type: TYPE_NORMAL
- en: evalProg (compile e) [] = Some [evalExpr e].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros; rewrite (app_nil_end (compile e));
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (lemma : ∀ e'' s p,'
  prefs: []
  type: TYPE_NORMAL
- en: 'evalProg (compile e'' ++ p) s = evalProg p (evalExpr e'' :: s)) by'
  prefs: []
  type: TYPE_NORMAL
- en: (induction e'; crush);
  prefs: []
  type: TYPE_NORMAL
- en: crush.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a *verified compiler*: we have evidence that there cannot be any
    bugs in the translation. The code we extracted is certified as correct!'
  prefs: []
  type: TYPE_NORMAL
- en: CompCert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CompCert is a certified C compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source language: ISO C 99, mostly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Target language: PowerPC, ARM, x86.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specified, programmed, proved correct in Coq.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not verified: parser, assembler, linker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Performance: about 10 percent slowdown compared to gcc -O1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main theorem from the CompCert Coq source code:'
  prefs: []
  type: TYPE_NORMAL
- en: (*
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem transf_c_program_correct:'
  prefs: []
  type: TYPE_NORMAL
- en: forall p tp,
  prefs: []
  type: TYPE_NORMAL
- en: transf_c_program p = OK tp ->
  prefs: []
  type: TYPE_NORMAL
- en: backward_simulation (Csem.semantics p) (Asm.semantics tp).
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledgment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This lecture is inspired by an example in a textbook by Adam Chlipala titled
    "Certified Programming with Dependent Types".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[Index](coqindex.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This page has been generated by [coqdoc](http://www.lix.polytechnique.fr/coq/)
  prefs: []
  type: TYPE_NORMAL
