- en: VerifyCompilerA Verified Compiler for CS 3110
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source Language
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic expressions with constants and addition:    e ::= c | e + eIn OCaml,
    we could represent these with a data type:    type expr =
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '| Const of int'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus of expr × exprIn Coq, they have a very similar representation:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive expr : Type :='
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '| Const : nat → expr'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus : expr → expr → expr.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if we extract that Coq expr to OCaml, we get essentially what we expect.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Extraction expr.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: (* type expr =
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '| Const of nat'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus of expr * expr'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The one mismatch is that Coq uses nat, whereas in OCaml we'd normally use int.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: nat is (theoretically) unbounded and non-negative
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: int is definitely bounded and can be negative.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a library called Int31 in Coq that provides the equivalent to OCaml's
    31-bit int.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: Semantics'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *dynamic semantics* of expressions is something we can easily implement.
    Here''s a simple interpreter that evaluates expressions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint evalExpr (e : expr) : nat :='
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: match e with
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '| Const n ⇒ n'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus e1 e2 ⇒ plus (evalExpr e1) (evalExpr e2)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this extracts to OCaml as we would expect:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Extraction evalExpr.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: (*
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: let rec evalExpr = function
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '| Const n -> n'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus (e1, e2) -> plus (evalExpr e1) (evalExpr e2)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: Unit tests of semantics'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a couple test cases for our interpreter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Example source_test_1 : evalExpr (Const 42) = 42.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Example source_test_2 : evalExpr (Plus (Const 2) (Const 2)) = 4.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Target Language
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary tasks of a *compiler* is to translate from a *high-level
    language* to a *low-level language*. For example,
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The Java compiler translates from Java to JVM bytecode.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OCaml compiler translates from OCaml to Zinc machine bytecode. [http://cadmium.x9c.fr/distrib/caml-instructions.pdf]
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both compilers can additionally produce *native* code that runs on a particular
    machine architecture.JVM and OCaml bytecode are both based on a *stack machine*
    model, in which a stack is used as the main data structure, rather than a set
    of registers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Target: Syntax'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So as a *target language*, let's use the following stack-machine instruction
    set:      inst ::= PUSH c | ADDAn inst is a machine instruction. A program prog
    is a list of instructions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive inst : Type :='
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '| PUSH : nat → inst'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '| ADD : inst.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Definition prog := list inst.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: These extact to OCaml as we would expect.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Extraction inst.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: (*
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: type inst =
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '| PUSH of nat'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '| ADD'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Extraction prog.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: (*
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: type prog = inst list
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Target: Semantics'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define the *dynamic semantics* of this target language, we need a notion
    of a stack:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Definition stack := list nat.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to write an interpreter for the target language.Evaluation of
    a program takes in an initial stack, and returns the final stack. But since evaluation
    could fail (if we try to ADD when there aren't at least two values on the stack),
    we wrap the return in an option, and return None if an error occurs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint evalProg (p : prog) (s : stack) : option stack :='
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: match p,s with
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '| (PUSH n)::p'', s ⇒ evalProg p'' (n::s)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '| ADD::p'', x::y::s'' ⇒ evalProg p'' ((x+y)::s'')'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '| [], s ⇒ Some s'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '| _, _ ⇒ None'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'DOES THAT LOOK FAMILIAR? It should...Extraction of the deep pattern matching
    doesn''t turn out quite so nicely:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Extraction evalProg.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: (*
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: let rec evalProg p s =
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '| Nil -> Some s'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '| Cons (i, p'') ->'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: (match i with
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '| PUSH n -> evalProg p'' (Cons (n, s))'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '| ADD ->'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: (match s with
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '| Nil -> None'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '| Cons (x, l) ->'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: (match l with
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '| Nil -> None'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '| Cons (y, s'') -> evalProg p'' (Cons ((plus x y), s'')))))'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '*)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Target: Unit tests'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are a couple unit tests for the target language interpreter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Example target_test_1 : evalProg [PUSH 42] [] = Some [42].'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Example target_test_2 : evalProg [PUSH 2; PUSH 2; ADD] [] = Some [4].'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we're ready to translate from the source language to the target language.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: To translate a constant c, we just push c onto the stack.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To translate an addition e1 + e2, we translate e2, translate e1, then append
    the instructions together, followed by an ADD instruction.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (* returns: compile e produces a program p, such that
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: evaluation of p leaves a single new value at the top
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: of the stack, and that value would be the result of
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: evaluating e. *)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Fixpoint compile (e : expr) : prog :='
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: match e with
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '| Const n ⇒ [PUSH n]'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| Plus e1 e2 ⇒ compile e2 ++ compile e1 ++ [ADD]'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: end.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that ++ is the Coq append operator, analogous to OCaml''s @.We can extract
    the compiler to its own file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Extraction "compiler.ml" compile.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Try using that file in the OCaml REPL!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Compiler: Unit tests'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a couple unit tests for our compiler:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Example compile_test_1 : compile (Const 42) = [PUSH 42].'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Example compile_test_2 : compile (Plus (Const 2) (Const 2))'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: = [PUSH 2; PUSH 2; ADD].
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'These tests demonstrate that the compiler produces some programs that do seem
    to correspond to the input expression. But we haven''t really tested the postcondition
    of compile: we want to know whether both side of the = above evaluate to the same
    value.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Example post_test_1 : evalProg (compile (Const 42)) [] = Some [evalExpr (Const
    42)].'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Example post_test_2 : evalProg (compile (Plus (Const 2) (Const 2))) []'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: = Some [evalExpr (Plus (Const 2) (Const 2))].
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Proof. reflexivity. Qed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. But as we know from Dijkstra, "testing can only prove the presence
    of bugs, never their absence." How could we show that the compiler is correct
    for every input expression?WE PROVE IT...
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Compiler Verification
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following theorem is a *specification* that says what it means for compile
    to be correct.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem compile_correct : ∀ e,'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: evalProg (compile e) [] = Some [evalExpr e].
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: intros; rewrite (app_nil_end (compile e));
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (lemma : ∀ e'' s p,'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'evalProg (compile e'' ++ p) s = evalProg p (evalExpr e'' :: s)) by'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: (induction e'; crush);
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: crush.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a *verified compiler*: we have evidence that there cannot be any
    bugs in the translation. The code we extracted is certified as correct!'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个*经过验证的编译器*：我们有证据证明翻译中不可能存在任何错误。我们提取的代码被证明是正确的！
- en: CompCert
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompCert
- en: CompCert is a certified C compiler.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CompCert 是一个经过认证的 C 编译器。
- en: 'Source language: ISO C 99, mostly.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源语言：ISO C 99，主要是。
- en: 'Target language: PowerPC, ARM, x86.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标语言：PowerPC、ARM、x86。
- en: Specified, programmed, proved correct in Coq.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Coq 中指定、编程、证明为正确。
- en: 'Not verified: parser, assembler, linker'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未经验证的部分：解析器、汇编器、链接器
- en: 'Performance: about 10 percent slowdown compared to gcc -O1.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：与 gcc -O1 相比大约减慢了 10%。
- en: 'The main theorem from the CompCert Coq source code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: CompCert Coq 源代码的主要定理：
- en: (*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: (*
- en: 'Theorem transf_c_program_correct:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 transf_c_program_correct：
- en: forall p tp,
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的 p 和 tp，
- en: transf_c_program p = OK tp ->
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: transf_c_program p = OK tp ->
- en: backward_simulation (Csem.semantics p) (Asm.semantics tp).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: backward_simulation (Csem.semantics p) (Asm.semantics tp)。
- en: '*)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*)'
- en: Acknowledgment
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 致谢
- en: This lecture is inspired by an example in a textbook by Adam Chlipala titled
    "Certified Programming with Dependent Types".
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这节课受到了 Adam Chlipala 所著书籍《带依赖类型的认证编程》中的一个例子的启发。
- en: '[PRE0]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '* * *'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[Index](coqindex.html)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[索引](coqindex.html)'
- en: '* * *'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: This page has been generated by [coqdoc](http://www.lix.polytechnique.fr/coq/)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本页由[coqdoc](http://www.lix.polytechnique.fr/coq/)生成。
