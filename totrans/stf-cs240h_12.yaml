- en: A Haskell Compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: David Terei
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why understand how GHC works?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understand Core & STG – performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarity with functional terminology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand execution model – reasonable cost model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pipeline of GHC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell -> GHC Haskell -> Core -> STG -> Cmm -> Assembly
  prefs: []
  type: TYPE_NORMAL
- en: GHC supports Haskell on top of an unsafe variant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Primitive types (GHC.Prim):'
  prefs: []
  type: TYPE_NORMAL
- en: Char#, Int#, Word#, Double#, Float#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array#, ByteArray#, ArrayArray#,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MutVar#, TVar#, MVar#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State#, exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All primitive types are *unlifted* – can’t contain ⊥.
  prefs: []
  type: TYPE_NORMAL
- en: GHC supports Haskell on top of an unsafe variant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All variants of Int (In8, Int16, Int32, Int64) are represented internally by
    Int# (64bit) on a 64bit machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Data constructors *lift* a type, allowing ⊥.
  prefs: []
  type: TYPE_NORMAL
- en: GHC implements IO through the RealWorld token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IO Monad is a state passing monad.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`RealWorld` token enforces ordering through data dependence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Various unsafe functions throw away `RealWorld` token.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Core: a small function intermediate language'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Idea: map Haskell to a small lanuage for easier optimization and compilation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional lazy language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It consists of only a hand full of constructs!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In general think, `let` means allocation, `case` means evaluation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core in one slide
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Lets now look at how Haskell is compiled to [Core](http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType).
  prefs: []
  type: TYPE_NORMAL
- en: 'GHC Haskell to Core: monomorphic functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'GHC Haskell to Core: polymorphic functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'GHC Haskell to Core: polymorphic functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'New case syntax to make obvious that evaluation is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Where transformed to let
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Patterns matching transformed to case statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Type classes transformed to dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A dictionary constructed for each instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries constructed from dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: UNPACK unboxes types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Only one data type for Point exists, GHC doesn’t duplicate it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UNPACK not always a good idea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Great code here as working with unboxed types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UNPACK not always a good idea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Need to unfortunately rebox the types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Look at Core to get an idea of how your code will perform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can see boxing an unboxing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language still lazy but `case` means evaluation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Middle of GHC: *Core -> Core*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of the optimizations that GHC does is through core to core transformations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets look at two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Strictness and unboxing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SpecConstr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Strictness & Unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider this factorial implementation in Haskell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In Haskell `x` & `n` must be represented by pointers to a possibly unevaluated
    objects (thunks)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if evaluated still represented by “boxed” values on the heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strictness & Unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Core
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We allocate thunks before the recursive call and box arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But `fac` will immediately evaluate the thunks and unbox the values!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GHC with strictness analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compile `fac` with optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Create an optimized ‘worker’ and keep original function as ‘wrapper’ to preserve
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must preserve semantics of ⊥ – `fac` ⊥ `n = optimized(fac)` ⊥ `n`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SpecConstr: Extending strictness analysis to paths'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of the SpecConstr pass is to extend the strictness and unboxing from
    before but to functions where arguments aren’t strict in every code path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this Haskell function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Not strict in first argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drop` ⊥ [] = []'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drop` ⊥ (x:xs) = ⊥'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SpecConstr: Extending strictness analysis to paths'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So we get this code without extra optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: But after the first time we call drop, we are strict in `n` and always evaluate
    it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SpecConstr
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SpecConstr pass takes advantage of this to create a specialised version
    of `drop` that is only called after we have passed the first check.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To stop code size blowing up, GHC limits the amount of specialized functions
    it creates (specified with the `-fspec-constr-threshol` and `-fspec-constr-count`
    flags).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: STG Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After Core, GHC compiles to another intermediate language called STG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'STG is very similar to Core but has one nice additional property:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: laziness is ‘explicit’
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`case` = *evaluation* and ONLY place evaluation occurs (true in Core)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let` = *allocation* and ONLY place allocation occurs (not true in Core)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: So in STG we can explicitly see thunks being allocated for laziness using `let`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To view STG use:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: STG Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Haskell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: STG
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Lambda abstraction as `[arg1 arg2] f`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\r` - re-entrant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u` - updatable (i.e., thunk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph Reduction as a computational model for Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph reduction is a good computational model for lazy functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Graph Reduction as a computational model for Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph reduction is a good computational model for lazy functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Graph Reduction as a computational model for Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Graph reduction is a good computational model for lazy functional languages.
  prefs: []
  type: TYPE_NORMAL
- en: Graph reduction allows lazy evaluation and sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*let*: adds new node to graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*case*: expression evaluation, causes the graph to be reduced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a node is reduced, it is replaced (or *updated*) with its result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can think of your Haskell program as progressing by either adding new nodes
    to the graph or reducing existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: GHC execution model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GHC uses closures as a unifying representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All objects in the heap are closures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stack frame is a closure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GHC uses continuation-passing-style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always jump to top stack frame to return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions will prepare stack in advance to setup call chains.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closure Representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Closure |  |  | Info Table |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: Header usually just a pointer to the code and metadata for the closure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get away with single pointer through positive and negative offsets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload contains the closures environment (e.g free variables, function arguments)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data closure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`[Header | Pointers... | Non-pointers...]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload is the values for the constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry code for a constructor just returns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Function closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[Header | Pointers… | Non-pointers…]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload is the bound free variables, e.g.,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ &g | x ]`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry code is the function code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial application closures (PAP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`[Header | Arity | Payload size | Function | Payload]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arity of the PAP (function of arity 3 with 1 argument applied gives PAP of arity
    2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function is the closure of the function that has been partially applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thunk closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`[Header | Pointers... | Non-pointers...]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload contains the free variables of the expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differ from function closure in that they can be updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry code is the code for the expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On X86 32bit - all arguments passed on stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On X86 64bit - first 5 arguments passed in registers, rest on stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R1` register in Cmm code usually is a pointer to the current closure (i.e.,
    similar to `this` in OO languages).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling thunk updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thunks once evaluated should update their node in the graph to be the computed
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GHC uses a *self-updating-model* – code unconditionally jumps to a thunk. Up
    to thunk to update itself, replacing code with value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling thunk updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Handling thunk updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: stg_upd_frame_info code updates a thunk with its value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To update a thunk with its value we need to change its header pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should point to code that simply returns now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload also now needs to include the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naive solution would be to synchronize on every thunk access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But we don’t need to! Races on thunks are fine since we can rely on purity.
    Races just leads to duplication of work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stg_upd_frame_info code updates a thunk with its value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thunk closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[Header | Payload]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Header` = `[ Info Table Pointer | Result Slot ]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result slot empty when thunk unevaluated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update code, first places result in result slot and secondly changes the info
    table pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safe to do without synchronization (need write barrier) on all architectures
    GHC supports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding entering values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Evaluation model is we always enter a closure, even values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is poor for performance, we prefer to avoid entering values every single
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optimization that GHC does is *pointer tagging*. The trick is to use the
    final bits of a pointer which are usually zero (last 2 for 32bit, 3 on 64) for
    storing a ‘tag’.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GHC uses this tag for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object is a constructor, the tag contains the constructor number (if
    it fits)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the object is a function, the tag contains the arity of the function (if
    it fits)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding entering values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our example code from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Changes with pointer tagging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Pointer tagging makes your own data types efficient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the closure is a constructor, the tag contains the constructor number (if
    it fits).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Will be as efficient as using an `Int#` for representing true and false.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
