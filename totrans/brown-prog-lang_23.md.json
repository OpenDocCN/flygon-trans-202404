["```\n> > import s-exp as S\n> > ```", "```\n> > S.read-s-exp(\"(+ 23 (* 5 6))\")\n> > ```", "```\ncheck:\n  S.read-s-exp(\"(+ 23 (* 5 6))\") is\n    S.s-list([list:\n      S.s-sym(\"+\"),\n      S.s-num(23),\n      S.s-list([list:\n        S.s-sym(\"*\"),\n        S.s-num(5),\n        S.s-num(6)])])\nend\n```", "```\nimport s-exp as S\nimport lists as L\n```", "```\ndata ArithC:\n  | numC(n :: Number)\n  | plusC(l :: ArithC, r :: ArithC)\n  | multC(l :: ArithC, r :: ArithC)\nend\n```", "```\nfun parse(s :: S.S-Exp) -> ArithC:\n  cases (S.S-Exp) s:\n    | s-num(n) => numC(n)\n    | s-list(shadow s) =>\n      cases (List) s:\n        | empty => raise(\"parse: unexpected empty list\")\n        | link(op, args) =>\n          argL = L.get(args, 0)\n          argR = L.get(args, 1)\n          if op.s == \"+\":\n            plusC(parse(argL), parse(argR))\n          else if op.s == \"*\":\n            multC(parse(argL), parse(argR))\n          end\n      end\n    | else =>\n      raise(\"parse: not number or list\")\n  end\nend\n```", "```\ncheck:\n  fun p(s): parse(S.read-s-exp(s)) end\n  p(\"3\") is numC(3)\n  p(\"(+ 1 2)\") is plusC(numC(1), numC(2))\n  p(\"(* (+ 1 2) (* 2 5))\") is\n    multC(plusC(numC(1), numC(2)), multC(numC(2), numC(5)))\nend\n```", "```\n> > p(\"3\") is numC(3)\n> > ```", "```\n> > p(3) is numC(3)\n> > ```"]