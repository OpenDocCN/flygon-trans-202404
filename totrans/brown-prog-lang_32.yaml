- en: '32Objects: Interpretation and Types'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 32对象：解释与类型
- en: '|     [32.1 Interpreting Objects](#%28part._.Interpreting_.Objects%29) |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [32.1 解释对象](#%28part._.Interpreting_.Objects%29) |'
- en: '|     [32.2 Objects by Desugaring](#%28part._.Objects_by_.Desugaring%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [32.2 对象的展开](#%28part._.Objects_by_.Desugaring%29) |'
- en: '|       [32.2.1 Objects as Named Collections](#%28part._.Objects_as_.Named_.Collections%29)
    |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|       [32.2.1 对象作为命名集合](#%28part._.Objects_as_.Named_.Collections%29) |'
- en: '|       [32.2.2 Constructors](#%28part._.Constructors%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [32.2.2 构造函数](#%28part._.Constructors%29) |'
- en: '|       [32.2.3 State](#%28part._.State%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [32.2.3 状态](#%28part._.State%29) |'
- en: '|       [32.2.4 Private Members](#%28part._.Private_.Members%29) |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [32.2.4 私有成员](#%28part._.Private_.Members%29) |'
- en: '|       [32.2.5 Static Members](#%28part._.Static_.Members%29) |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|       [32.2.5 静态成员](#%28part._.Static_.Members%29) |'
- en: '|       [32.2.6 Objects with Self-Reference](#%28part._obj-with-self%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [32.2.6 带自引用的对象](#%28part._obj-with-self%29) |'
- en: '|         [32.2.6.1 Self-Reference Using Mutation](#%28part._.Self-.Reference_.Using_.Mutation%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|         [32.2.6.1 使用突变的自引用](#%28part._.Self-.Reference_.Using_.Mutation%29)
    |'
- en: '|         [32.2.6.2 Self-Reference Without Mutation](#%28part._self-ref-wout-mut%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|         [32.2.6.2 无突变的自引用](#%28part._self-ref-wout-mut%29) |'
- en: '|       [32.2.7 Dynamic Dispatch](#%28part._.Dynamic_.Dispatch%29) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [32.2.7 动态分派](#%28part._.Dynamic_.Dispatch%29) |'
- en: '|     [32.3 Member Access Design Space](#%28part._member-access-design-space%29)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|     [32.3 成员访问设计空间](#%28part._member-access-design-space%29) |'
- en: '|     [32.4 What (Goes In) Else?](#%28part._.What__.Goes_.In__.Else_%29) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|     [32.4 其他是什么？](#%28part._.What__.Goes_.In__.Else_%29) |'
- en: '|       [32.4.1 Classes](#%28part._.Classes%29) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|       [32.4.1 类](#%28part._.Classes%29) |'
- en: '|       [32.4.2 Prototypes](#%28part._.Prototypes%29) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|       [32.4.2 原型](#%28part._.Prototypes%29) |'
- en: '|       [32.4.3 Multiple Inheritance](#%28part._.Multiple_.Inheritance%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|       [32.4.3 多重继承](#%28part._.Multiple_.Inheritance%29) |'
- en: '|       [32.4.4 Super-Duper!](#%28part._.Super-.Duper_%29) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|       [32.4.4 超级棒！](#%28part._.Super-.Duper_%29) |'
- en: '|       [32.4.5 Mixins and Traits](#%28part._.Mixins_and_.Traits%29) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|       [32.4.5 混合和特性](#%28part._.Mixins_and_.Traits%29) |'
- en: '|     [32.5 Object Classification and Object Equality](#%28part._nominal-equality%29)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|     [32.5 对象分类和对象相等性](#%28part._nominal-equality%29) |'
- en: '|     [32.6 Types for Objects](#%28part._types-for-objects%29) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|     [32.6 对象类型](#%28part._types-for-objects%29) |'
- en: '|       [32.6.1 Subtyping](#%28part._subtyping%29) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|       [32.6.1 子类型](#%28part._subtyping%29) |'
- en: '|         [32.6.1.1 Subtyping Functions](#%28part._.Subtyping_.Functions%29)
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|         [32.6.1.1 子类型函数](#%28part._.Subtyping_.Functions%29) |'
- en: '|         [32.6.1.2 Subtyping and Information Hiding](#%28part._.Subtyping_and_.Information_.Hiding%29)
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|         [32.6.1.2 子类型和信息隐藏](#%28part._.Subtyping_and_.Information_.Hiding%29)
    |'
- en: '|         [32.6.1.3 Implementing Subtyping](#%28part._.Implementing_.Subtyping%29)
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|         [32.6.1.3 实现子类型](#%28part._.Implementing_.Subtyping%29) |'
- en: '|       [32.6.2 Types for Self-Reference](#%28part._.Types_for_.Self-.Reference%29)
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|       [32.6.2 自引用的类型](#%28part._.Types_for_.Self-.Reference%29) |'
- en: '|       [32.6.3 Nominal Types](#%28part._nominal-types%29) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|       [32.6.3 名义类型](#%28part._nominal-types%29) |'
- en: 'When a language admits functions as values, it provides developers the most
    natural way to represent a unit of computation. Suppose a developer wants to parameterize
    some function f. Any language lets f be parameterized by passive data, such as
    numbers and strings. But it is often attractive to parameterize it over active
    data: a datum that can compute an answer, perhaps in response to some information.
    Furthermore, the function passed to f can—<wbr>assuming lexically-scoped functions—<wbr>refer
    to data from the caller without those data having to be revealed to f, thus providing
    a foundation for security and privacy. Thus, lexically-scoped functions are central
    to the design of many secure programming techniques.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当一种语言接受函数作为值时，它提供给开发者最自然的方式来表示计算单元。假设一个开发者想要给一些函数f参数化。任何语言都允许f被被被动数据参数化，比如数字和字符串。但是往往会吸引人们用活跃数据来参数化它：一个能够计算答案的数据，也许是对某些信息的响应。此外，传递给f的函数可以——<wbr>假设词法作用域函数——引用调用者的数据，而不必将这些数据透露给f，从而为安全性和隐私提供了基础。因此，词法作用域函数对于许多安全编程技术的设计至关重要。
- en: 'While a function is a splendid thing, it suffers from excessive terseness.
    Sometimes we might want multiple functions to all close over to the same shared
    data; the sharing especially matters if some of the functions mutate it and expect
    the others to see the result of those mutations. In such cases, it becomes unwieldly
    to send just a single function as a parameter; it is more useful to send a group
    of functions. The recipient then needs a way to choose between the different functions
    in the group. This grouping of functions, and the means to select one from the
    group, is the essence of an object. We are therefore perfectly placed to study
    objects having covered functions ([Functions Anywhere](Interpreting_Functions.html#%28part._higher-order-functions%29)),
    mutation ([Mutation: Structures and Variables](implementing-mutation.html)), and
    recursion ([Recursion and Cycles from Mutation](State__Change__and_More_Equality.html#%28part._rec-from-mut%29)).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数是一件很棒的事情，但它过于简洁。有时我们可能希望多个函数都闭合到相同的共享数据上；如果其中一些函数对其进行了变异并期望其他函数看到这些变异的结果，那么共享尤为重要。在这种情况下，仅发送一个函数作为参数变得难以控制；将一组函数发送更有用。接收者然后需要一种方法来在组中选择不同的函数。这些函数的分组以及从组中选择一个的方法是对象的本质。因此，我们在涵盖函数（[任何地方的函数](Interpreting_Functions.html#%28part._higher-order-functions%29)）、变异（[变异：结构和变量](implementing-mutation.html)）和递归（[从变异中的递归和循环](State__Change__and_More_Equality.html#%28part._rec-from-mut%29)）之后，完全适合研究对象。
- en: 'I cannot hope to do justice to the enormous space of object systems. Please
    read [Object-Oriented Programming Languages: Application and Interpretation](http://users.dcc.uchile.cl/~etanter/ooplai/)
    by Éric Tanter, which goes into more detail and covers topics ignored here. Let’s
    add this notion of objects to our language. Then we’ll flesh it out and grow it,
    and explore the many dimensions in the design space of objects. We’ll first show
    how to add objects to the core language, but because we’ll want to prototype many
    different ideas quickly, we’ll soon shift to a desguaring-based strategy. Which
    one you use depends on whether you think understanding them is critical to understanding
    the essence of your language. One way to measure this is how complex your desguaring
    strategy becomes, and whether by adding some key core language enhancements, you
    can greatly reduce the complexity of desugaring.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法对对象系统的巨大空间做出公正的评价。请阅读Éric Tanter的[面向对象编程语言：应用与解释](http://users.dcc.uchile.cl/~etanter/ooplai/)，该书详细介绍了这个概念，并涵盖了这里忽略的主题。让我们将对象的这个概念添加到我们的语言中。然后我们将充实它并发展它，并探索对象设计空间中的许多维度。我们首先将展示如何将对象添加到核心语言中，但因为我们希望快速原型化许多不同的想法，我们很快就会转向基于desguaring的策略。您使用哪种取决于您是否认为理解它们对于理解您的语言的本质至关重要。衡量这一点的一种方法是您的desguaring策略变得多么复杂，以及通过添加一些关键的核心语言增强，您是否可以大大减少desugaring的复杂性。
- en: 32.1Interpreting Objects
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32.1解释对象
- en: The simplest notion of an object—<wbr>pretty much the only thing everyone who
    talks about objects agrees about—<wbr>is that an object is
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的最简单概念——几乎所有谈论对象的人都同意的唯一事情——是对象是
- en: a value, that
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值，那
- en: maps names to
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将名称映射到
- en: 'stuff: either other values or “methods”.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 东西：其他值或“方法”。
- en: 'From a minimalist perspective, methods seem to be just functions, and since
    we already have those in the language, we can put aside this distinction.We’re
    about to find out that “methods” are awfully close to functions but differ in
    important ways in how they’re called and/or what’s bound in them.Starting from
    the language with variables, let’s define this very simple notion of objects by
    adding it to the core language. We clearly have to extend our notion of values:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从极简主义的角度来看，方法似乎只是函数，而由于语言中已经有了这些函数，我们可以将这种区别放在一边。我们即将发现，“方法”与函数非常接近，但在它们被调用的方式和/或绑定在其中的内容方面有重要的区别。从具有变量的语言开始，让我们通过将其添加到核心语言中来定义对象的这个非常简单的概念。我们显然必须扩展我们对值的概念：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’ll extend the expression grammar to support literal object construction
    expressions:Observe that this is already a design decision. In some languages,
    like JavaScript, a developer can write literal objects: a notion so popular that
    a subset of the syntax for it in JavaScript has become a Web standard, JSON. In
    other languages, like older versions of Java, objects can only be created by invoking
    a constructor on a class. We can simulate both by assuming that to model the latter
    kind of language, we must write object literals only in special positions following
    a stylized convention, as we do when desugaring below.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展表达式语法以支持字面对象构造表达式：请注意，这已经是一个设计决策。在一些语言中，比如JavaScript，开发人员可以编写字面对象：这个概念如此流行，以至于JavaScript中的一部分语法已经成为Web标准，即JSON。在其他语言中，比如旧版本的Java，对象只能通过在类上调用构造函数来创建。我们可以通过假设模拟后一种语言，必须按照一种风格化的约定在特殊位置写入对象字面量，就像我们在下面展开时所做的那样。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Evaluating such an object expression is easy: we just evaluate each of its
    expression positions. In the presence of state, however, we have to be careful
    to thread the store:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 评估这样的对象表达式很容易：我们只需评估其每个表达式位置。然而，在存在状态的情况下，我们必须小心地传递存储：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Exercise
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write eval-obj-vs, which evaluates each expression in vs while threading the
    store. Assume it returns an object with two fields: exprs is the list of evaluated
    expressions, while final-store is the final store ensuing from these evaluations.'
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写eval-obj-vs，它在传递存储的同时评估vs中的每个表达式。假设它返回一个具有两个字段的对象：exprs是评估表达式的列表，而final-store是由这些评估产生的最终存储。
- en: Unfortunately, we can’t actually use an object, because we have no way of obtaining
    its content. For that reason, we should add an operation to extract members:<msgC-def>
    ::=
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们实际上无法使用对象，因为我们无法获取其内容。因此，我们应该添加一个操作来提取成员：<msgC-def> ::=
- en: '|   &#124; msgC(o :: ExprC, n :: String) |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|   &#124; msgC(o :: ExprC, n :: String) |'
- en: 'whose behavior is intuitive:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其行为是直观的：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Exercise
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement lookup-msg.
  id: totrans-50
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现lookup-msg。
- en: 'In principle, msgC can be used to obtain any kind of member but for simplicity,
    we need only assume that we have functions. To use them, we must apply them to
    values. This is cumbersome to write directly, so let’s assume desugaring has taken
    care of it for us: that is, the user can write (msg o m v)—<wbr>where o evaluates
    to an object, m names a method, and v evaluates to an argument value—<wbr>and
    this desugars into using msgC to obtain the method and regular application to
    apply it.For illustration, we’ll assume methods take only one argument. This is
    easy to relax. Note that in a Lispy language we could have instead written (define (msg o m . a) (apply (o m) a)),
    which would have let msg take any number of arguments.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，msgC可以用于获取任何类型的成员，但为简单起见，我们只需要假设我们有函数。要使用它们，我们必须将它们应用于值。直接编写这样的代码很麻烦，所以让我们假设解糖已经为我们处理了：也就是说，用户可以编写(msg
    o m v)—<wbr>其中o评估为一个对象，m命名一个方法，v评估为一个参数值—<wbr>这将解糖为使用msgC获取方法和常规应用来应用它。为了说明，我们假设方法只接受一个参数。这很容易放宽。请注意，在一个Lispy语言中，我们可以写成(define (msg o m . a) (apply (o m) a))，这样就可以让msg接受任意数量的参数。
- en: 'With this we have a full first language with objects. For instance, here is
    an object definition and invocation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就有了一个完整的带有对象的第一语言。例如，这里是一个对象定义和调用：
- en: '| (let o (obj (add1 (lambda x (+ x 1))) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| (let o (obj (add1 (lambda x (+ x 1))) |'
- en: '|             (sub1 (lambda x (+ x -1)))) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|             (sub1 (lambda x (+ x -1)))) |'
- en: '|   (msg o sub1 2)) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|   (msg o sub1 2)) |'
- en: and this evaluates to (numV 1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将评估为(numV 1)。
- en: 32.2Objects by Desugaring
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32.2通过解糖实现对象
- en: While defining objects in the core language is good to really understand their
    essence, it’s an unwieldy way to go about studying them. Instead, we’ll use Pyret
    to represent objects, sticking to the parts of the language we already know how
    to implement in our interpreter. That is, we’ll assume that we are looking at
    the output of desugaring. (For this reason, we’ll also stick to stylized code,
    potentially writing unnecessary expressions on the grounds that this is what a
    simple program generator would produce.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心语言中定义对象是理解它们本质的好方法，但这是一个笨拙的学习方式。相反，我们将使用Pyret来表示对象，坚持使用我们已经知道如何在解释器中实现的语言部分。也就是说，我们假设我们正在看解糖的输出。（因此，我们也将坚持风格化的代码，可能会写入不必要的表达式，因为这是一个简单程序生成器会产生的内容。）
- en: Exercise
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code that follows largely drops type annotations. Go back in and add these
    annotations wherever possible; where you can’t, explain what problems you encounter.
    See [Types for Objects](#%28part._types-for-objects%29).
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来的代码基本上省略了类型注解。请回去添加尽可能多的注解；如果无法添加，请解释遇到的问题。参见[对象类型](#%28part._types-for-objects%29)。
- en: 32.2.1Objects as Named Collections
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.1 对象作为命名集合
- en: Let’s begin by reproducing the object language we had above. An object is just
    a value that dispatches on a given name. For simplicity, we’ll use anonymous functions
    to represent the object and conditionals to implement the dispatching.Observe
    that basic objects are a generalization of anonymous functions to have multiple
    “entry-points”. Conversely, an anonymous functions is an object with just one
    entry-point, so it doesn’t need a “method name” to disambiguate.<obj-o-1> ::=
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从复制上面的对象语言开始。一个对象只是一个根据给定名称调度的值。为简单起见，我们将使用匿名函数来表示对象，并使用条件来实现调度。注意，基本对象是匿名函数的一般化，具有多个“入口点”。相反，匿名函数是具有只有一个入口点的对象，因此它不需要“方法名称”来消除歧义。\<obj-o-1>
    ::=
- en: '|   o-1 = |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|   o-1 = |'
- en: '|     lam(m): |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|     lam(m): |'
- en: '|       if m == "add1": |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|       if m == "add1": |'
- en: '|         lam(x): x + 1 end |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|         lam(x): x + 1 end |'
- en: '|       else if m == "sub1": |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|       else if m == "sub1": |'
- en: '|         lam(x): x - 1 end |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|         lam(x): x - 1 end |'
- en: '|       else: |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|       else: |'
- en: '|         raise("message not found: " + m) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|         raise("message not found: " + m) |'
- en: '|       end |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|       end |'
- en: '|     end |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: 'This is the same object we defined earlier, and we use its method in the same
    way:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前定义的同一个对象，并且我们以同样的方式使用它的方法：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Of course, writing method invocations with these nested function calls is unwieldy
    (and is about to become even more so), so we’d be best off equipping ourselves
    with a convenient syntax for invoking methods, which we can define here as a function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，使用这些嵌套的函数调用来写方法调用是笨拙的（而且即将变得更加笨拙），所以最好给自己配备一个方便的语法来调用方法，我们可以在这里定义为一个函数：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This enables us to rewrite our test:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够重写我们的测试：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do Now!
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就行动吧！
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Something very important changed when we switched to the desguaring strategy.
    Do you see what it is?
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们切换到解糖策略时，有一件非常重要的事情发生了变化。你看到了吗？
- en: 'Recall the syntax definition we had earlier: [<msgC-def>](#%28elem._msg.C-def%29).
    The “name” position of a message was very explicitly a syntactic string. That
    is, the user had to write the literal name of the method there. In our desugared
    version, the name position is just an expression that must evaluate to a string;
    this permits the user to write the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们之前的语法定义：[<msgC-def>](#%28elem._msg.C-def%29)。消息的“名称”位置非常明确地是一个语法字符串。也就是说，用户必须在那里写入方法的文字名称。在我们解糖的版本中，名称位置只是一个必须求值为字符串的表达式；这允许用户编写以下内容：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: which may very much not be intended ([Member Access Design Space](#%28part._member-access-design-space%29)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能完全不是预期的行为（[成员访问设计空间](#%28part._member-access-design-space%29)）。
- en: 'This is a general problem with desugaring: the target language may allow computations
    that have no counterpart in the source, and hence cannot be mapped back to it.
    Fortunately we don’t often need to perform this inverse mapping, though it does
    arise in some debugging and program comprehension tools. More subtly, however,
    we must ensure that the target language does not produce values that have no corresponding
    equivalent in the source.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 解糖的一个普遍问题是：目标语言可能允许在源语言中没有对应物的计算，因此无法将其映射回去。幸运的是，我们通常不需要执行这种逆映射，尽管它在某些调试和程序理解工具中会出现。然而，更微妙的是，我们必须确保目标语言不会产生在源语言中没有对应等价物的值。
- en: Now that we have basic objects, let’s start adding the kinds of features we’ve
    come to expect from most object systems. But before we proceed, it’s unwieldy
    to define an object as an explicit conditional; we would rather write a more declarative
    mapping from names to methods, and leave the implementation of the lookup to the
    language. This, after all, is one of the key primitives provided by every definition
    of object-orientation. That is, we wish to write the previous object ([<obj-o-1>](#%28elem._obj-o-1%29))
    as
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本对象，让我们开始添加我们期望从大多数对象系统中看到的特性。但在继续之前，将对象定义为一个显式条件是不方便的；我们宁愿写一个更具声明性的映射，从名称到方法，然后将查找的实现留给语言。毕竟，这是每个面向对象定义提供的关键原语之一。也就是说，我们希望将先前的对象（[<obj-o-1>](#%28elem._obj-o-1%29)）写成
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: and to support this, we define the datatype
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 并且为了支持这一点，我们定义了数据类型
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: and the corresponding function
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以及相应的函数
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this much simpler notation—<wbr>which does not even require desugaring
    to implement—<wbr>we are now better equipped to handle the study of object system
    features.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种更简单的表示法——<wbr>甚至不需要解糖即可实现——<wbr>我们现在更能够处理对象系统特性的研究。
- en: 32.2.2Constructors
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.2构造函数
- en: 'A constructor is simply a function that is invoked at object construction time.
    We currently lack such a function. By turning an object from a literal into a
    function that takes constructor parameters, we achieve this effect:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数简单地说就是在对象构造时调用的函数。我们目前缺少这样的函数。通过将对象从字面值转换为带有构造函数参数的函数，我们实现了这一效果：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the first example, we pass 5 as the constructor’s argument, so adding 3 yields
    8. The second is similar, and shows that the two invocations of the constructors
    don’t interfere with one another.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们将 5 作为构造函数的参数传递，所以添加 3 得到 8。第二个例子类似，并且显示了两次构造函数调用不会相互干扰。
- en: 32.2.3State
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.3状态
- en: 'Many people believe that objects primarily exist to encapsulate state.Alan
    Kay, who won a Turing Award for inventing Smalltalk and modern object technology,
    disagrees. In [The Early History of Smalltalk](http://www.smalltalk.org/smalltalk/TheEarlyHistoryOfSmalltalk_Abstract.html),
    he says, “[t]he small scale [motivation for OOP] was to find a more flexible version
    of assignment, and then to try to eliminate it altogether”. He adds, “It is unfortunate
    that much of what is called ‘object-oriented programming’ today is simply old
    style programming with fancier constructs. Many programs are loaded with ‘assignment-style’
    operations now done by more expensive attached procedures.” We certainly haven’t
    lost that ability. If we desugar to a language with variables (we could equivalently
    use boxes, in return for a slight desugaring overhead), we can easily have multiple
    methods mutate common state, such as a constructor argument:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为对象主要存在于封装状态。阿兰·凯（Alan Kay）为发明 Smalltalk 和现代对象技术而获得图灵奖的人不同意。在《Smalltalk
    的早期历史》（The Early History of Smalltalk）中，他说：“[OOP 的小规模动机] 是找到一种更灵活的赋值版本，然后尝试完全消除它”。他补充道：“不幸的是，今天被称为‘面向对象编程’的许多东西只是带有更复杂结构的旧式编程。许多程序现在充斥着更昂贵的附加过程执行的‘赋值式’操作。”我们当然没有失去这种能力。如果我们将语言解糖为带有变量的语言（我们可以等效地使用箱子，作为稍微增加解糖开销的代价），我们可以很容易地让多个方法改变共同状态，比如构造函数参数：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For instance, we can test a sequence of operations:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以测试一系列操作：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'and also notice that mutating one object doesn’t affect another:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，改变一个对象不会影响另一个对象：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 32.2.4Private Members
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.4私有成员
- en: 'Another common object language feature is private members: ones that are visible
    only inside the object, not outside it.Except that, in Java, instances of other
    classes of the same type are privy to “private” members. Otherwise, you would
    simply never be able to implement an approximation to an Abstract Data Type. These
    may seem like an additional feature we need to implement, but we already have
    the necessary mechanism in the form of locally-scoped, lexically-bound variables,
    such as mut-count above: there is no way for surrounding code to access mut-count
    directly, because lexical scoping ensures that it remains hidden to the world.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的对象语言特性是私有成员：仅在对象内部可见，而在外部不可见。除了在 Java 中，同一类型的其他类的实例可以访问“私有”成员。否则，你根本无法实现对抽象数据类型的近似。这些看起来可能是我们需要实现的附加功能，但我们已经通过局部作用域、词法绑定变量等形式拥有了必要的机制，比如上面的
    mut-count：外部代码无法直接访问 mut-count，因为词法作用域确保它对世界保持隐藏。
- en: 32.2.5Static Members
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.5静态成员
- en: 'Another feature often valuable to users of objects is static members: those
    that are common to all instances of the “same” type of object.We use quotes because
    there are many notions of sameness for objects. And then some. This, however,
    is merely a lexically-scoped identifier (making it private) that lives outside
    the constructor (making it common to all uses of the constructor), such as counter
    below:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的另一个常用特性是静态成员：对于“相同”类型的所有实例都是共同的成员。我们用引号是因为对象的“相同性”有许多不同的概念。然后一些。然而，这仅仅是一个词法作用域的标识符（使其私有），它存在于构造函数之外（使其对构造函数的所有用法都是共同的），比如下面的
    counter：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ve written the counter increment where the “constructor” for this object
    would go, though it could just as well be manipulated inside the methods. This
    obeys the following tests:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将计数器增量写在了“构造函数”应该出现的地方，尽管它同样可以在方法内部操作。这遵循以下测试：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the different objects each affect the result seen by the other.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不同的对象会影响到其他对象看到的结果。
- en: 32.2.6Objects with Self-Reference
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.6具有自引用的对象
- en: Until now, our objects have simply been packages of named functions grouped
    together and hence given different, named entry-points. We’ve seen that many of
    the features considered important in object systems are actually simple patterns
    over functions and scope, and have indeed been used—<wbr>without names assigned
    to them—<wbr>for decades by programmers armed with anonymous functions (with lexical
    scope).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们的对象只是一组命名函数的打包，因此给定了不同的命名入口点。我们已经看到，在对象系统中被认为重要的许多特性实际上只是函数和作用域上的简单模式，而且确实已经被程序员使用了几十年，他们使用具有词法作用域的匿名函数（没有为它们分配名称）。
- en: One characteristic that actually distinguishes object systems is that each object
    is automatically equipped with a reference to the same object, often called self
    or this.I prefer this slightly dry way of putting it to the anthropomorphic “knows
    about itself” terminology often adopted by object advocates. Indeed, note that
    we have gotten this far into object system properties without ever needing to
    resort to anthropomorphism. Can we implement this easily?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上区分对象系统的一个特征是，每个对象都自动配备了一个指向相同对象的引用，通常称为self或this。我更喜欢这种略显干燥的表达方式，而不是对象倡导者经常采用的拟人化的“了解自己”术语。事实上，请注意，我们已经深入了解对象系统属性，而无需诉诸拟人化。我们能轻松实现这个吗？
- en: 32.2.6.1Self-Reference Using Mutation
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.6.1使用变异的自引用
- en: Yes, we can, because we have seen just this very pattern when we implemented
    recursion; we’ll just adapt it to refer not to the same box or function but to
    the same object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以，因为当我们实现递归时，我们已经看到了这个模式；我们只需将其调整为不引用相同的盒子或函数，而是引用相同的对象。
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Observe that this is precisely the recursion pattern ([Recursion and Cycles
    from Mutation](State__Change__and_More_Equality.html#%28part._rec-from-mut%29)),
    adapted slightly. We’ve tested it having "first" invoke its own "second" method.
    Sure enough, this produces the expected answer:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这正是适当调整的递归模式（[来自变异的递归和循环](State__Change__and_More_Equality.html#%28part._rec-from-mut%29)）。我们已经测试过它让"first"调用自己的"second"方法。果然，这产生了预期的答案：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 32.2.6.2Self-Reference Without Mutation
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.6.2无变异的自引用
- en: 'If you know how to implement recursion without mutation [REF], you’ll notice
    that the same solution applies here, too. Observe:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道如何在没有变异的情况下实现递归[REF]，你会注意到同样的解决方案在这里也适用。观察：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Each method now takes self as an argument. That means method invocation must
    be modified to pass along the object as part of the invocation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个方法都将self作为参数。这意味着方法调用必须修改以传递对象作为调用的一部分：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That is, when invoking a method on o, we must pass o as a parameter to the
    method. Obviously, this approach is dangerous because we can potentially pass
    a different object as the “self”. Exposing this to the developer is therefore
    probably a bad idea; if this implementation technique is used, it should only
    be done in desugaring. Nevertheless, Python exposes just this in its surface syntax.Just
    to be sure, we can check this using essentially the same code as before:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在o上调用方法时，我们必须将o作为参数传递给方法。显然，这种方法是危险的，因为我们可能会将不同的对象作为“self”传递。因此，向开发人员公开这一点可能是一个坏主意；如果使用这种实现技术，应该只在解糖时使用。尽管如此，Python在其表面语法中确实公开了这一点。为了确保，我们可以使用基本上与之前相同的代码来检查这一点：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 32.2.7Dynamic Dispatch
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.2.7动态分派
- en: Finally, we should make sure our objects can handle a characteristic attribute
    of object systems, which is the ability to invoke a method without the caller
    having to know or decide which object will handle the invocation. Suppose we have
    a binary tree data structure, where a tree consists of either empty nodes or leaves
    that hold a value. In traditional functions, we are forced to implement the equivalent
    some form of conditional that exhaustively lists and selects between the different
    kinds of trees. If the definition of a tree grows to include new kinds of trees,
    each of these code fragments must be modified. Dynamic dispatch solves this problem
    by eliminating this conditional branch from the user’s program and instead handling
    it by the method selection code built into the language. The key feature that
    this provides is an extensible conditional. This is one dimension of the extensibility
    that objects provide.This property—<wbr>which appears to make systems more black-box
    extensible because one part of the system can grow without the other part needing
    to be modified to accommodate those changes—<wbr>is often hailed as a key benefit
    of object-orientation. While this is indeed an advantage objects have over functions,
    there is a dual advantage that functions have over objects, and indeed many object
    programmers end up contorting their code—<wbr>using the Visitor pattern—<wbr>to
    make it look more like a function-based organization. Read [Synthesizing Object-Oriented
    and Functional Design to Promote Re-Use](http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/)
    for a running example that will lay out the problem in its full glory. Try to
    solve it in your favorite language, and see the [Racket solution](http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该确保我们的对象能够处理对象系统的一个特征属性，即在调用方法时，调用者无需知道或决定哪个对象将处理调用。假设我们有一个二叉树数据结构，其中树由空节点或保存值的叶子组成。在传统函数中，我们被迫实现等效的某种形式的条件语句，以穷举列出并在不同类型的树之间进行选择。如果树的定义扩展到包括新类型的树，那么每个这些代码片段都必须被修改。动态分派通过将这个条件分支从用户程序中消除，而是通过语言内置的方法选择代码来处理它，解决了这个问题。这提供的关键功能是可扩展条件。这是对象提供的可扩展性的一个维度。这个属性——看起来使系统更加黑盒可扩展，因为系统的一部分可以增长而无需修改另一部分来适应这些变化——经常被誉为面向对象的一个关键优点。虽然这确实是对象相对于函数的一个优势，但函数相对于对象也有一个双重优势，事实上许多对象程序员最终会扭曲他们的代码——使用访问者模式——使其看起来更像是基于函数的组织。阅读[Synthesizing
    Object-Oriented and Functional Design to Promote Re-Use](http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/)，了解一个完整的示例，它将详细阐述问题。尝试用你喜欢的语言解决它，并查看[Racket解决方案](http://www.cs.utah.edu/plt/publications/icfp98-ff/paper.shtml)。
- en: 'Let’s now defined our two kinds of tree objects:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的两种树对象：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With these, we can make a concrete tree:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们可以创建一个具体的树：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And finally, test it:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试它：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Observe that both in the test and in the "add" method of node, there is a reference
    to "add" without checking whether the recipient is a mt or a node. Instead, the
    run-time system extracts the recipient’s "add" method and invokes it. This missing
    conditional in the user’s source program provided automatically by the system
    is the essence of dynamic dispatch.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在测试和节点的“add”方法中，都有一个对“add”的引用，而不检查接收者是mt还是节点。相反，运行时系统提取接收者的“add”方法并调用它。系统自动提供的用户源程序中缺少的这个条件是动态分派的本质。
- en: 32.3Member Access Design Space
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32.3成员访问设计空间
- en: 'We already have two orthogonal dimensions when it comes to the treatment of
    member names. One dimension is whether the name is provided statically or computed,
    and the other is whether the set of names is fixed or variable:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及成员名称的处理时，我们已经有了两个正交维度。一个维度是名称是静态提供的还是计算的，另一个维度是名称集合是固定的还是可变的：
- en: '|  | Name is Static | Name is Computed |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  | 名称是静态的 | 名称是计算的 |'
- en: '| Fixed Set of Members | As in base Java. | As in Java with reflection to compute
    the name. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 固定成员集合 | 如基本Java。 | 如使用反射的Java来计算名称。 |'
- en: '| Variable Set of Members | Difficult to envision (what use would it be?).
    | Most scripting languages. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 可变成员集合 | 很难想象（有什么用处呢？）。 | 大多数脚本语言。 |'
- en: 'Only one case does not quite make sense: if we force the developer to specify
    the member name in the source file explicitly, then no new members would be accessible
    (and some accesses to previously-existing, but deleted, members would fail). All
    other points in this design space have, however, been explored by languages.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一种情况不太合理：如果我们强制开发人员在源文件中明确指定成员名称，则将无法访问新成员（并且对先前存在但已删除的成员的某些访问将失败）。 然而，语言已经探索了此设计空间中的所有其他点。
- en: The lower-right quadrant corresponds closely with languages that use hash-tables
    to represent objects. Then the name is simply the index into the hash-table. Some
    languages carry this to an extreme and use the same representation even for numeric
    indices, thereby (for instance) conflating objects with dictionaries and even
    arrays. Even when the object only handles “member names”, this style of object
    creates significant difficulty for type-checking [REF] and is hence not automatically
    desirable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 右下象限与使用哈希表表示对象的语言密切对应。 然后名称只是哈希表的索引。 一些语言将此推向极端，甚至对数字索引使用相同的表示，从而（例如）将对象与字典甚至数组混为一谈。
    即使对象仅处理“成员名称”，这种对象风格对类型检查[REF]造成了重大困难，因此并非自动理想。
- en: Therefore, in the rest of this section, we will stick with “traditional” objects
    that have a fixed set of names and even static member name references (the top-left
    quadrant). Even then, we will find there is much, much more to study.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节的其余部分，我们将坚持使用具有固定名称集合甚至静态成员名称引用的“传统”对象（左上象限）。 即使如此，我们会发现还有很多要研究的地方。
- en: 32.4What (Goes In) Else?
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32.4其他是什么？
- en: So far, the “else clause” of method lookup (which is currently implemented by
    mk-object)—<wbr>namely, what to do when the list of methods is empty—<wbr>has
    signaled a “method not found” error. What else might happen instead? One possibility,
    adopted by many programming languages, is to “chain” control to one or more parent
    object(s). This is called inheritance.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，方法查找的“else子句”（当前由mk-object实现）—即，当方法列表为空时该怎么办—已经发出了“未找到方法”错误。 可以发生的其他情况是什么？
    许多编程语言采用的一种可能性是将控制“链接”到一个或多个父对象。 这被称为继承。
- en: Let’s return to our model of desugared objects above. To implement inheritance,
    the object must be given “something” to which it can delegate method invocations
    that it does not recognize. A great deal will depend on what that “something”
    is.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上面的去糖化对象模型。 要实现继承，对象必须被赋予“某物”，以便它可以委托它不认识的方法调用。 很大程度上将取决于那个“某物”是什么。
- en: 'One answer could be that it is simply another object: where currently we have'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个答案可能是它只是另一个对象：目前我们只有
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: we could instead have
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Due to our representation of objects, this application effectively searches
    for the method in the parent object (and, presumably, recursively in its parents).
    If a method matching the name is found, it returns through this chain to the original
    call that sought the method. If none is found, the final parent object presumably
    signals the same “message not found” error.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对对象的表示，该应用程序有效地在父对象中搜索方法（并且可能递归地在其父对象中搜索）。 如果找到与名称匹配的方法，则通过此链返回到最初寻找方法的原始调用。
    如果找不到，则最终父对象可能会发出相同的“未找到消息”错误。
- en: Exercise
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Observe that the application parent-object(m) is like “half a msg”, just like
    an l-value was “half” a variable’s evaluation ([Interpreting Variables](implementing-mutation.html#%28part._interp-vars%29)).
    Is there any connection?
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意应用程序父对象（m）类似于“半个消息”，就像l值是“半个”变量的评估一样（[解释变量](implementing-mutation.html#%28part._interp-vars%29））。
    是否有任何联系？
- en: 'Let’s try this by extending our trees to implement another method, "size".
    We’ll write an “extension” (you may be tempted to say “sub-class”, but hold off
    for now!) for each node and mt to implement the size method. We intend these to
    extend the existing definitions of node and mt, so we’ll use the extension pattern
    described above.We’re not editing the existing definitions because that is supposed
    to be the whole point of object inheritance: to reuse code in a black-box fashion.
    This also means different parties, who do not know one another, can each extend
    the same base code. If they had to edit the base, first they have to find out
    about each other, and in addition, one might dislike the edits of the other. Inheritance
    is meant to sidestep these issues entirely.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过扩展我们的树来实现另一个方法，"size"。我们将为每个节点和mt编写一个“扩展”（你可能会说“子类”，但现在先别！）来实现size方法。我们打算扩展现有的节点和mt的定义，所以我们将使用上面描述的扩展模式。我们不修改现有的定义，因为那应该是对象继承的全部意义：以黑盒方式重用代码。这也意味着不相互了解的不同方，可以分别扩展相同的基础代码。如果他们不得不编辑基础代码，首先他们必须了解彼此，而且，一个人可能不喜欢另一个人的编辑。继承的目的是完全绕过这些问题。
- en: 32.4.1Classes
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.4.1类
- en: Immediately we see a design choice. Is this the constructor pattern?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即看到了一个设计选择。这是构造器模式吗？
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That is, we pass the parent object to node-size-ext along with the constructor
    parameters. Since the parent object will be an instance of node, and the two objects
    should presumably have the same values for the parameters, this means we would
    have had to specify those values twice (which violates the DRY principle). As
    an alternative, we can simply pass the constructor of the parent to node-size-ext
    and let it construct the parent object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们将父对象传递给node-size-ext以及构造函数参数。由于父对象将是节点的一个实例，并且两个对象应该假定具有相同的参数值，这意味着我们必须两次指定这些值（这违反了DRY原则）。作为一种替代方案，我们可以简单地将父对象的构造器传递给node-size-ext，让它构造父对象：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using this, we can make a more user-friendly interface to nodes with the size
    method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们可以为具有size方法的节点创建一个更用户友好的接口：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Do Now!
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Did you notice that instead of mk-object we’ve used mk-ext-object above? Do
    you see that it takes one extra parameter? Try to define it for yourself.
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你有没有注意到我们在上面使用了mk-ext-object而不是mk-object？你注意到它多了一个额外的参数吗？试着自己定义它。
- en: 'The entire difference in mk-ext-object is that, if it cannot find a method
    in the current object, it chains to the parent:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: mk-ext-object的整个区别在于，如果在当前对象中找不到方法，它会链到父对象：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With this, we can similarly create an extension of empty tree nodes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们同样可以创建空树节点的扩展：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we can use these objects to construct a tree:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用这些对象来构建一棵树：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When testing, we should make sure both old and new behavior work:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，我们应该确保新旧行为都正常工作：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Exercise
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Earlier, we commented that chaining method-lookup to parents presumably bottoms
    out at some sort of “empty object”, which might look like this:'
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 早些时候，我们评论说，方法查找链接到父级，可能会在某种“空对象”上触底，它可能看起来像这样：
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, we haven’t needed to define or use this despite the use of mk-ext-object.
    Why is that, and how would you fix that?
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，尽管使用了mk-ext-object，我们并没有需要定义或使用它。为什么会这样，你会如何修复呢？
- en: 'What we have done is capture the essence of a class. Each function parameterized
    over a parent is...well, it’s a bit tricky, really. Let’s call it a blob for now.
    A blob corresponds to what a Java programmer defines when they write a class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是捕捉类的本质。每个函数参数化到一个父类上...嗯，这有点棘手，真的。现在我们先称之为blob吧。一个blob对应于当Java程序员编写类时定义的内容：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Do Now!
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So why are we going out of the way to not call it a “class”?
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那么，为什么我们要绕过去不称它为“类”？
- en: When a developer invokes a Java class’s constructor, it in effect constructs
    objects all the way up the inheritance chain (in practice, a compiler might optimize
    this to require only one constructor invocation and one object allocation). These
    are private copies of the objects corresponding to the parent classes (private,
    that is, up to the presence of static members). There is, however, a question
    of how much of these objects is visible. Java chooses that—<wbr>unlike in our
    implementation above—<wbr>only one method of a given name (and signature) remains,
    no matter how many there might have been on the inheritance chain, whereas every
    field remains in the result, and can be accessed by casting. The latter makes
    some sense because each field presumably has invariants governing it, so keeping
    them separate (and hence all present) is wise. In contrast, it is easy to imagine
    an implementation that also makes all the methods available, not only the ones
    lowest (i.e., most refined) in the inheritance hierarchy. Many scripting languages
    take the latter approach.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员调用Java类的构造函数时，实际上会沿着继承链构造对象（在实践中，编译器可能会将此优化为仅需要一个构造函数调用和一个对象分配）。这些是与父类对应的对象的私有副本（私有，即直到静态成员的出现）。然而，存在一个问题，即这些对象的多少是可见的。Java选择了——<wbr>与我们上面的实现不同——<wbr>只有一个给定名称（和签名）的方法保留下来，无论继承链上可能有多少个，而每个字段都保留在结果中，并且可以通过强制转换访问。后者是有道理的，因为每个字段都可能有规定其行为的不变量，因此将它们分开（因此全部存在）是明智的。相比之下，很容易想象一个实现也使所有方法都可用，而不仅仅是继承层次结构中最低的（即最精细的）那些方法。许多脚本语言采用后一种方法。
- en: Exercise
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the implementation above, we have relied on the self-application semantics
    for recursive access to an object, rather than using state. The reason is because
    the behavior of inheritance would be subtly wrong if we used state naively, as
    we have shown above. Can you construct an example that illustrates this?
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在上面的实现中，我们依赖自应用语义来递归访问对象，而不是使用状态。原因是因为如果我们简单地使用状态，继承的行为将会有微妙的错误，就像我们上面展示的那样。你能构造一个说明这一点的例子吗？
- en: 'By examining values carefully, you will notice that the self reference is to
    the most refined object at all times. This demonstrates the other form of extensibility
    we get from traditional objects: extensible recursion. The extensible conditional
    can be viewed as free extension across “space”, namely, the different variants
    of data, whereas extensible recursion can be viewed as free extension across “time”,
    namely, the different extensions to the code. Nevertheless, as [this paper](http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/)
    points out, there’s no free lunch.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查值，你会注意到自引用始终指向最精细的对象。这展示了我们从传统对象中获得的另一种可扩展性形式：可扩展递归。可扩展条件可以被视为跨“空间”的自由扩展，即数据的不同变体，而可扩展递归可以被视为跨“时间”的自由扩展，即对代码的不同扩展。然而，正如[这篇论文](http://www.cs.brown.edu/~sk/Publications/Papers/Published/kff-synth-fp-oo/)所指出的，没有免费的午餐。
- en: 32.4.2Prototypes
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.4.2原型
- en: 'In our description above, we’ve supplied each class with a description of its
    parent class. Object construction then makes instances of each as it goes up the
    inheritance chain. There is another way to think of the parent: not as a class
    to be instantiated but, instead, directly as an object itself. Then all children
    with the same parent would observe the very same object, which means changes to
    it from one child object would be visible to another child. The shared parent
    object is known as a prototype.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上面的描述中，我们为每个类提供了其父类的描述。然后，对象构造在沿着继承链向上移动时会实例化每个对象。还有另一种方法来考虑父类：不是作为一个要实例化的类，而是直接作为一个对象本身。然后，具有相同父类的所有子类都将观察到完全相同的对象，这意味着一个子类对象对其的更改将对另一个子类可见。共享的父对象被称为原型。
- en: 'The archetypal prototype-based language is [Self](http://selflanguage.org/).
    Though you may have read that languages like JavaScript are “based on” Self, there
    is value to studying the idea from its source, especially because Self presents
    these ideas in their purest form. Some language designers have argued that prototypes
    are more primitive than classes in that, with other basic mechanisms such as functions,
    one can recover classes from prototypes—<wbr>but not the other way around. That
    is essentially what we have done above: each “class” function contains inside
    it an object description, so a class is an object-returning-function. Had we exposed
    these are two different operations and chosen to inherit directly from an object,
    we would have something akin to prototypes.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 原型语言的典型代表是 [Self](http://selflanguage.org/)。尽管你可能已经读到过类似 JavaScript 这样的语言是“基于”
    Self 的，但从其源头学习这个概念还是有价值的，特别是因为 Self 以最纯粹的形式展现了这些思想。一些语言设计者认为，原型比类更原始，因为使用其他基本机制，如函数，可以从原型中恢复类，但反过来不行。这基本上就是我们上面所做的：每个“类”函数内部包含一个对象描述，因此类是一个返回对象的函数。如果我们将这两个操作暴露出来，并选择直接从一个对象继承，我们将得到类似原型的东西。
- en: Exercise
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the inheritance pattern above to implement a Self-like, prototype-based
    language, instead of a class-based language. Because classes provide each object
    with distinct copies of their parent objects, a prototype-language might provide
    a clone operation to simplify creation of the operation that simulates classes
    atop prototypes.
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改上述继承模式以实现一个类似 Self 的、基于原型的语言，而不是基于类的语言。因为类为每个对象提供其父对象的独立副本，所以原型语言可能提供一个克隆操作，以简化在原型之上模拟类的操作的创建。
- en: 32.4.3Multiple Inheritance
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.4.3 多重继承
- en: 'Now you might ask, why is there only one fall-through option? It’s easy to
    generalize this to there being many, which leads naturally to multiple inheritance.
    In effect, we have multiple objects to which we can chain the lookup, which of
    course raises the question of what order in which we should do so. It would be
    bad enough if the ascendants were arranged in a tree, because even a tree does
    not have a canonical order of traversal: take just breadth-first and depth-first
    traversal, for instance (each of which has compelling uses). Worse, suppose a
    blob A extends B and C; but now suppose B and C each extend D.This infamous situation
    is called diamond inheritance. If you choose to include multiple inheritance in
    your language you can lose yourself for days in design decisions on this. Because
    it is highly unlikely you will find a canonical answer, your pain will have only
    begun. Now we have to confront this question: will there be one or two D objects
    in the instance of A? Having only one saves space and might interact better with
    our expectations, but then, will we visit this object once or twice? Visiting
    it twice should not make any difference, so it seems unnecessary. But visiting
    it once means the behavior of one of B or C might change. And so on. As a result,
    virtually every multiple-inheritance language is accompanied by a subtle algorithm
    merely to define the lookup order—<wbr>and each language’s designer argues why
    their algorithm is more intuitive.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问，为什么只有一个“fall-through”选项？很容易将这个概念泛化为有很多个选项，这自然会导致多重继承。实际上，我们有多个对象可以链式查找，这当然会引发一个问题，那就是我们应该按照什么顺序来查找。如果祖先被排列在树中，这已经够糟糕了，因为即使树也没有遍历的规范顺序：例如广度优先和深度优先遍历（每种都有令人信服的用途）。更糟糕的是，假设一个
    blob A 继承了 B 和 C；但是现在假设 B 和 C 分别继承了 D。这个臭名昭著的情况称为“菱形继承”。如果你选择在你的语言中包含多重继承，你可能会花上几天的时间在这些设计决策上纠结。因为你很有可能找不到一个规范的答案，你的痛苦只会刚刚开始。现在我们不得不面对这个问题：在
    A 的实例中会有一个还是两个 D 对象？只有一个可以节省空间，并且可能与我们的期望更好地交互，但是，我们会访问这个对象一次还是两次呢？访问两次不应该有任何区别，所以似乎是不必要的。但是访问一次意味着
    B 或 C 中的一个的行为可能会改变。等等。结果，几乎每种支持多重继承的语言都伴随着一个微妙的算法来定义查找顺序，而每种语言的设计者都会争辩说他们的算法更直观。
- en: Multiple inheritance is only attractive until you’ve thought it through.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承只有在你仔细考虑过后才会变得有吸引力。
- en: 32.4.4Super-Duper!
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.4.4 超级棒！
- en: Many languages have a notion of super-invocations, i.e., the ability to invoke
    a method or access a field higher up in the inheritance chain.Note that I say
    “the” and “chain”. When we switch to multiple inheritance, these concepts are
    replaced with something much more complex. This includes doing so at the point
    of object construction, where there is often a requirement that all constructors
    be invoked, to make sure the object is properly defined.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言都有超级调用的概念，即能够在继承链中更高层次地调用方法或访问字段。请注意，我说的是“链”。当我们转换为多重继承时，这些概念将被更复杂的东西所替代。这包括在对象构造点这样做，其中通常有一个要求调用所有构造函数的要求，以确保对象被正确定义。
- en: 'We have become so accustomed to thinking of these calls as going “up” the chain
    that we may have forgotten to ask whether this is the most natural direction.
    Keep in mind that constructors and methods are expected to enforce invariants.
    Whom should we trust more: the super-class or the sub-class? One argument would
    say that the sub-class is most refined, so it has the most global view of the
    object. Conversely, each super-class has a vested interest in protecting its invariants
    against violation by ignorant sub-classes.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经习惯于认为这些调用是“向上”链的，以至于我们可能忘记了是否这是最自然的方向。记住构造函数和方法被期望强制执行不变量。我们应该更信任谁：超类还是子类？一个论点会说子类最精细化，因此它对对象有最全面的视角。相反，每个超类都有一种对抗被无知的子类违反其不变量的权益。
- en: These are two fundamentally opposed views of what inheritance means. Going up
    the chain means we view the extension as replacing the parent. Going down the
    chain means we view the extension as refining the parent. Because we normally
    associate sub-classing with refinement, why do our languages choose the “wrong”
    order of calling? Some languages have, therefore, explored invocation in the downward
    direction by default.[gbeta](http://www.daimi.au.dk/~eernst/gbeta/) is a modern
    programming language that supports inner, as well as many other interesting features.
    It is also interesting to consider [combining both directions](http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两种根本相反的继承观点。向上链意味着我们将扩展视为替换父类。向下链意味着我们将扩展视为细化父类。因为我们通常将子类化与细化联系在一起，所以为什么我们的语言选择了“错误”的调用顺序呢？因此，一些语言默认探索了向下调用的方式。[gbeta](http://www.daimi.au.dk/~eernst/gbeta/)是一种支持内部以及许多其他有趣特性的现代编程语言。同时考虑[结合两个方向](http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf)也是很有意思的。
- en: 32.4.5Mixins and Traits
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.4.5混合和特质
- en: Let’s return to our “blobs”.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的“blob”。
- en: 'When we write a class in Java, what are we really defining between the opening
    and closing braces? It is not the entire class: that depends on the parent that
    it extends, and so on recursively. Rather, what we define inside the braces is
    a class extension. It only becomes a full-blown class because we also identify
    the parent class in the same place.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Java中编写一个类时，在大括号之间真正定义的是什么？它不是整个类：这取决于它扩展的父类，以及递归地等等。相反，在大括号内定义的是一个类扩展。它只有在我们在同一个地方标识父类时才变成一个全面的类。
- en: 'Naturally, we should ask: Why? Why not separate the act of defining an extension
    from applying the extension to a base class? That is, suppose instead of'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，我们应该问：为什么？为什么不把定义扩展的行为与将扩展应用到基类分开呢？也就是说，假设不是
- en: '| class C extends B { ... } |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| class C extends B { ... } |'
- en: 'we instead write:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们写成：
- en: '| classext E { ... } |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| classext E { ... } |'
- en: and separately
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 和分开
- en: '| class C = E(B); |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| class C = E(B); |'
- en: 'where B is some already-defined class.This recovers what we had before, but
    the function-application-like syntax is meant to be suggestive: we can “apply”
    this extension to several different base classes. Thus:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 B 是某个已定义的类。这样我们就恢复了之前的内容，但是函数应用的语法意味着可以应用这个扩展到几个不同的基类。因此：
- en: '| class C1 = E(B1); |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| class C1 = E(B1); |'
- en: '| class C2 = E(B2); |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| class C2 = E(B2); |'
- en: 'and so on. What we have done by separating the definition of E from that of
    the class it extends is to liberate class extensions from the tyranny of the fixed
    base class. We have a name for these extensions: they’re called mixins.The term
    “mixin” originated in Common Lisp, where it was a particular pattern of using
    multiple inheritance. Lipstick on a pig.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '等等。通过将 E 的定义与它扩展的类的定义分开，我们已经将类扩展从固定基类的暴政中解放出来。我们有一个对这些扩展的名称：它们被称为 mixins。术语“mixin”起源于Common
    Lisp，它是一种使用多重继承的特定模式。给猪化妆。 '
- en: Mixins make class definition more compositional. They provide many of the benefits
    of multiple-inheritance (reusing multiple fragments of functionality) but within
    the aegis of a single-inheritance language (i.e., no complicated rules about lookup
    order). Observe that when desugaring, it’s actually quite easy to add mixins to
    the language. A mixin is primarily a “function over classes”; because we have
    already determined how to desugar classes, and our target language for desugaring
    also has functions, and classes desugar to expressions that can be nested inside
    functions, it becomes almost trivial to implement a simple model of mixins.This
    is a case where the greater generality of the target language of desugaring can
    lead us to a better construct, if we reflect it back into the source language.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 混合使类定义更具组合性。它们提供了多重继承的许多好处（重用多个功能片段），但在单一继承语言的保护下进行（即，没有关于查找顺序的复杂规则）。请注意，当进行解糖时，向语言添加混合实际上非常容易。混合主要是“对类的函数”；因为我们已经确定了如何解糖类，并且我们解糖的目标语言也具有函数，而类解糖为可以嵌套在函数内部的表达式，因此实现一个简单的混合模型几乎变得微不足道。这是目标语言的更大一般性可以将我们引向更好的构造的一个例子，如果我们将它反映回源语言。
- en: 'In a typed language, a good design for mixins can actually improve object-oriented
    programming practice. Suppose we’re defining a mixin-based version of Java. If
    a mixin is effectively a class-to-class function, what is the “type” of this “function”?
    Clearly, a mixin ought to use interfaces to describe what it expects and provides.
    Java already enables (but does not require) the latter, but it does not enable
    the former: a class (extension) extends another class—<wbr>with all its members
    visible to the extension—<wbr>not its interface. That means it obtains all of
    the parent’s behavior, not a specification thereof. In turn, if the parent changes,
    the class might break.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类型化的语言中，一个好的混合设计实际上可以改进面向对象编程实践。假设我们正在定义一个基于混合的 Java 版本。如果混合实际上是一个类到类的函数，那么这个“函数”的“类型”是什么？显然，混合应该使用接口来描述它期望和提供的内容。Java
    已经（但不要求）实现了后者，但它没有实现前者：一个类（扩展）扩展另一个类——<wbr>所有成员对扩展可见——<wbr>而不是它的接口。这意味着它获得了父类的所有行为，而不是规范。反过来，如果父类发生变化，类可能会出问题。
- en: In a typed mixin language, we can instead write
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类型化的混合语言中，我们可以写成
- en: '| mixin M extends I { ... } |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 混合 M 扩展 I { ... } |'
- en: where I is an interface. Then M can only be applied to a class that satisfies
    the interface I, and in turn the language can ensure that only members specified
    in I are visible in M. This follows one of the important principles of good software
    design.“Program to an interface, not an implementation.” —<wbr>Design Patterns
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 I 是一个接口。然后 M 只能应用于满足接口 I 的类，并且反过来，语言可以确保只有在 I 中指定的成员在 M 中可见。这遵循了良好软件设计的一个重要原则。“根据接口而不是实现编程。”
    —<wbr>设计模式
- en: 'A good design for mixins can go even further. A class can only be used once
    in an inheritance chain, by definition (if a class eventually referred back to
    itself, there would be a cycle in the inheritance chain, causing potential infinite
    loops). In contrast, when we compose functions, we have no qualms about using
    the same function twice (e.g.: (map ... (filter ... (map ...)))). Is there value
    to using a mixin twice?There certainly is! See sections 3 and 4 of [Classes and
    Mixins](http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的混合设计甚至可以走得更远。从定义上来说，类在继承链中只能使用一次（如果一个类最终引用回自身，将导致继承链中的循环，可能导致无限循环）。相比之下，当我们组合函数时，我们对多次使用相同的函数并不犹豫（例如：(map ... (filter ... (map ...))））。两次使用混合有价值吗？当然有！请参阅[Classes
    and Mixins](http://www.cs.brown.edu/~sk/Publications/Papers/Published/fkf-classes-mixins/)的第
    3 和第 4 节。
- en: 'Mixins solve an important problem that arises in the design of libraries. Suppose
    we have a dozen features that can be combined in different ways. How many classes
    should we provide? It is obviously impractical to generate the entire combinatorial
    explosion of classes. It would be better if the devleoper could pick and choose
    the features they care about. This is precisely the problem that mixins solve:
    they provide class extensions that the developers can combine, in an interface-preserving
    way, to create just the classes they need.Mixins are used extensively in the Racket
    GUI library. For instance, color:text-mixin consumes basic text editor interfaces
    and implements the colored text editor interface. The latter is iself a basic
    text editor interface, so additional basic text mixins can be applied to the result.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins解决了在库设计中出现的一个重要问题。假设我们有十几个可以以不同方式组合的特性。我们应该提供多少个类？显然，生成整个组合爆炸的类是不现实的。如果开发者可以挑选他们关心的特性，那就更好了。这正是mixins解决的问题：它们提供了类扩展，开发者可以以保持接口的方式组合，从而创建他们需要的类。Mixins在Racket
    GUI库中被广泛使用。例如，color:text-mixin消耗基本文本编辑器接口并实现了彩色文本编辑器接口。后者本身是一个基本文本编辑器接口，因此可以将额外的基本文本mixins应用于结果。
- en: Exercise
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How does your favorite object-oriented library solve this problem?
  id: totrans-227
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你最喜欢的面向对象库是如何解决这个问题的？
- en: 'Mixins do have one limitation: they enforce a linearity of composition. This
    strictness is sometimes misplaced, because it puts a burden on programmers that
    may not be necessary. A generalization of mixins called traits says that instead
    of extending a single mixin, we can extend a set of them. Of course, the moment
    we extend more than one, we must again contend with potential name-clashes. Thus
    traits must be equipped with mechanisms for resolving name clashes, often in the
    form of some name-combination algebra. Traits thus offer a nice complement to
    mixins, enabling programmers to choose the mechanism that best fits their needs.
    A handful of languages, such as Racket, therefore provide [both traits and mixins](http://www.eecs.northwestern.edu/~robby/pubs/papers/aplas2006-fff.pdf).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins确实有一个限制：它们强制了组合的线性性。这种严格有时是不恰当的，因为它给程序员带来了可能是不必要的负担。Mixins的一个泛化称为traits，它说我们可以扩展一组mixin而不是单个mixin。当然，一旦我们扩展多个，我们必须再次处理潜在的名称冲突。因此，traits必须配备解决名称冲突的机制，通常以某种名称组合代数的形式。因此，traits为mixins提供了一个很好的补充，使程序员能够选择最适合他们需求的机制。因此，一些语言，如Racket，提供了[traits和mixins](http://www.eecs.northwestern.edu/~robby/pubs/papers/aplas2006-fff.pdf)。
- en: 32.5Object Classification and Object Equality
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32.5对象分类和对象相等性
- en: Previously [[A Family of Equality Predicates](State__Change__and_More_Equality.html#%28part._equality-operations%29)],
    we have seen three different kinds of equality operations. For the purpose of
    this discussion, we will ignore the distinction between equal-now and equal-always,
    focusing on the fact that both are primarily structural (equal-now being purely
    so). Extended to objects, this would check each member recursively, perhaps ignoring
    methods in languages that cannot compare them for equality, or comparing them
    using reference equality.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们已经看到了三种不同类型的相等操作[[一个相等谓词家族](State__Change__and_More_Equality.html#%28part._equality-operations%29)]。在本讨论中，我们将忽略equal-now和equal-always之间的区别，重点关注它们都是主要结构性的（equal-now纯粹如此）。扩展到对象，这将递归地检查每个成员，也许忽略不能比较它们的语言中的方法，或者使用引用相等性来比较它们。
- en: 'This leaves us with the very fine-grained and unforgiving identical, and the
    very coarse-grained and perhaps overly forgiving equal-now. Why is structural
    equality overly forgiving? Because two completely unrelated objects that just
    happened to have the same member names and types could end up being regarded equal:
    as a famous example in the objects community has it, draw is a meaningful method
    of both user interfaces and cowhands.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们面对非常细粒度和苛刻的identical，以及非常粗粒度且可能过于宽容的equal-now。为什么结构相等性过于宽容？因为两个完全不相关的对象，恰好具有相同的成员名称和类型，最终可能被视为相等：正如对象社区中一个著名的例子所说，draw是用户界面和牛仔的一个有意义的方法。
- en: 'Therefore, some systems provide an equality predicate “in the middle”: it is
    still fundamentally structural, but it discriminates between objects that were
    not “made the same way”. The typical notion of construction is associated with
    a class: all objects made from a certain class are considered to be candidates
    for (structural) equality, but objects made from different classes (for some notion
    of “different”) are immediately ruled unequal independent of their structure (which
    may in fact be identical).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些系统提供了一个“中间”的相等谓词：它仍然基本上是结构的，但它区分了“不同方式制作”的对象。典型的构造概念与类相关联：所有由某个类制作的对象都被认为是（结构）相等的候选对象，但是由不同类制作的对象（对于某种“不同”的概念）立即被判定为不相等，而不考虑它们的结构（实际上可能是相同的）。
- en: 'In the special case where classes are named, first-order entities, this is
    called nominal equality: an equality based on names. However, it does not have
    to depend on names, nor even on first-order classes. Some languages have dynamic
    tag creators—<wbr>known to the language—<wbr>called brands.In keeping with the
    cowhand theme. Each branding operation places a tag on an object. The built-in
    equality primitives then check for brands being identical; when this condition
    is met, they revert to structural equality (which may involve additional brand-checking
    during recursion).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在特殊情况下，如果类被命名为一阶实体，这被称为名义相等：一种基于名称的相等。然而，它不必依赖于名称，甚至不必依赖于一阶类。一些语言有动态标签创建者——语言所知的——称为品牌。为了保持牛仔主题。每次品牌操作都会在对象上放置一个标签。然后，内置的相等原语检查品牌是否相同；当满足此条件时，它们将恢复到结构相等（在递归期间可能涉及额外的品牌检查）。
- en: 32.6Types for Objects
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 32.6对象类型
- en: Having studied various programming mechanisms, we now turn our focus to types
    for them. First ([Subtyping](#%28part._subtyping%29)) we will relax the notion
    of invariance for substitutability ([The Principle of Substitutability](types.html#%28part._type-substitutability%29)).
    Then, we will discuss how new notions of equality ([Object Classification and
    Object Equality](#%28part._nominal-equality%29)) can impact subtyping to create
    a new class of types ([Nominal Types](#%28part._nominal-types%29)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究了各种编程机制之后，我们现在将重点转向用于它们的类型。首先（[子类型化](#%28part._subtyping%29））我们将放宽对可替代性的不变性概念（[可替代性原则](types.html#%28part._type-substitutability%29））。然后，我们将讨论如何新的相等概念（[对象分类和对象相等](#%28part._nominal-equality%29））可以影响子类型化，以创建一类新的类型（[名义类型](#%28part._nominal-types%29））。
- en: 32.6.1Subtyping
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.6.1子类型化
- en: 'Consider two object types. The first we will call Add1Sub1:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两种对象类型。第一个我们将其称为 Add1Sub1：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is a type for objects that have two members, add1 and sub1, of the given
    types. The question we need to answer is, precisely what objects can be given
    this type?To understand this, let us consider another, related type, which we
    will call Arith:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有给定类型的两个成员 add1 和 sub1 的对象的类型。我们需要回答的问题是，确切地说，哪些对象可以给予此类型？为了理解这一点，让我们考虑另一个相关类型，我们将其称为
    Arith：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notice that two members have the same name and the same type, but there are
    two more members (plus and mult).Consider a function designed to work with Arith
    values:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个成员具有相同的名称和相同的类型，但还有两个成员（plus 和 mult）。考虑一个设计用于处理 Arith 值的函数：
- en: '[PRE38]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Is it okay to pass a value of type Add1Sub1 to f? Of course not: the function
    invokes the member plus, which the type annotation on a says it can expect to
    find; but if the value passed in does not have this member, this would result
    in a run-time member not found error, which is precisely what the type system
    was trying to avoid. Therefore, we cannot substitute a value of type Add1Sub1
    in a context expecting a Arith.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型为 Add1Sub1 的值传递给 f 函数是否可以？当然不行：函数调用了成员 plus，而类型注释在 a 上说它可以期望找到这个成员；但是如果传入的值没有这个成员，这将导致运行时找不到成员的错误，而这正是类型系统试图避免的。因此，我们不能在期望
    Arith 的上下文中替换类型为 Add1Sub1 的值。
- en: 'But how about in the other direction? This is entirely reasonable: the context
    is expecting a Add1Sub—<wbr>and hence not using any more than what that type promises.
    Because Arith supplies everything expected by Add1Sub1, it is okay to provide
    a Arith value for a Add1Sub1.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在另一个方向上呢？这是完全合理的：上下文期望一个 Add1Sub，因此不会使用比该类型承诺更多的东西。因为 Arith 提供了 Add1Sub1 期望的一切，所以提供
    Arith 值给 Add1Sub1 是可以的。
- en: This is our first example of subtyping. We say that Arith is a subtype of Add1Sub1
    because we can supply an Arith value in any context that expected a Add1Sub1 value.
    Specifically, because this involves dropping some members—<wbr>i.e., making the
    object “less wide”—<wbr>this is called width subtyping.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个子类型示例。我们说 Arith 是 Add1Sub1 的一个子类型，因为我们可以在期望一个 Add1Sub1 值的任何上下文中提供一个
    Arith 值。具体来说，因为这涉及到删除一些成员 —— 即，使对象“更窄” —— 所以这被称为宽度子类型。
- en: 'The essence of subtyping is a relation, conventionally written as <:, between
    pairs of types. We say S <: T if a value of type S can be given where a value
    of type T is expected, and call S the subtype and T the supertype. Therefore,
    in the above example, Arith <: Add1Sub1 and Arith is a subtype of Add1Sub1.Later
    [[Nominal Types](#%28part._nominal-types%29)], we will talk about how subtypes
    correspond to subclasses. But for now observe that we’re talking only about objects,
    without any reference to the existence of classes. It is useful (and usually accurate)
    to take a subset interpretation: if the values of S are a subset of T, then an
    expression expecting T values will not be unpleasantly surprised to receive only
    S values.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '子类型的本质是一个关系，惯例上写作<:，表示两种类型之间的关系。我们说 S <: T，如果一个类型为 S 的值可以在期望一个类型为 T 的值的地方给出，并称
    S 为子类型，T 为超类型。因此，在上面的例子中，Arith <: Add1Sub1，Arith 是 Add1Sub1 的一个子类型。稍后[[命名类型](#%28part._nominal-types%29)]，我们将讨论子类型如何对应于子类。但现在请注意，我们只谈论对象，没有提到类的存在。采用子集解释是有用的（并且通常是准确的）：如果
    S 的值是 T 的一个子集，则期望 T 值的表达式不会因为只接收到 S 值而感到不愉快。'
- en: Exercise
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is subtyping a relation and not a function?
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么子类型是一个关系而不是一个函数？
- en: 'In other words:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This may momentarily look confusing: we’ve said that subtyping follows set
    inclusion, so we would expect the smaller set on the left and the larger set on
    the right. Yet, it looks like we have a “larger type” (certainly in terms of character
    count) on the left and a “smaller type” on the right.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能暂时看起来令人困惑：我们已经说过，子类型遵循集合包含，因此我们期望左侧是较小的集合，右侧是较大的集合。然而，看起来我们左边有一个“更大的类型”（至少从字符计数的角度来看），右边有一个“更小的类型”。
- en: To understand why this is sound, it helps to develop the intuition that the
    “larger” the type, the fewer values it can have. Every object that has the four
    members on the left clearly also has the two members on the right. However, there
    are many objects that have the two members on the right that fail to have all
    four on the left. If we think of a type as a constraint on acceptable value shapes,
    the “bigger” type imposes more constraints and hence admits fewer values. Thus,
    though the types may appear to be of the wrong sizes, everything is well because
    the sets of values they subscribe are of the expected sizes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这为何是合理的，有助于培养这样一种直觉：类型“越大”，它可以拥有的值就越少。每个具有左侧四个成员的对象显然也具有右侧两个成员。然而，有许多具有右侧两个成员的对象，却没有左侧四个成员。如果我们将类型视为对可接受值形状的约束，则“更大”的类型会施加更多的约束，因此接受的值会更少。因此，尽管类型可能看起来大小不对，但一切都很好，因为它们所订阅的值集是预期大小的。
- en: As you might expect, there is another important form of subtyping, which is
    within a given member. This simply says that any particular member can be subsumed
    to a supertype in its corresponding position. For obvious reasons, this form is
    called depth subtyping.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所预料的，还有另一种重要的子类型形式，即在给定成员内部的子类型。这简单地表示任何特定成员可以被包含到其相应位置的超类型中。出于显而易见的原因，这种形式被称为深度子类型。
- en: Exercise
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct two examples of depth subtyping. In one, give the field itself an
    object type, and use width subtyping to subtype that field. In the other, give
    the field a function type.
  id: totrans-257
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建两个深度子类型的示例。在一个示例中，将字段本身赋予对象类型，并使用宽度子类型来对该字段进行子类型化。在另一个示例中，将字段赋予函数类型。
- en: The combination of width and depth subtyping cover the most interesting cases
    of object subtyping. A type system that implemented only these two would, however,
    needlessly annoy programmers. Other convenient rules include the ability to permute
    names, reflexivity (every type is a subtype of itself, which gives us invariance
    for free, and lets us interpret the subtype relationship as subset), and transitivity.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度和深度子类型的组合涵盖了对象子类型的最有趣的情况。一个只实现了这两种类型的类型系统，然而，会不必要地使程序员感到烦恼。其他方便的规则包括能够对名称进行置换，自反性（每种类型都是其自身的子类型，这为我们提供了自由的不变性，并让我们将子类型关系解释为子集），以及传递性。
- en: 'Subtyping has a pervasive effect on the type system. We have to reexamine every
    kind of type and understand its interaction with subtyping. For base types, this
    is usually quite obvious: disjoint types like Number, String, etc., are all unrelated
    to each other. (In languages where one base type is used to represent another—<wbr>for
    instance, in some scripting languages numbers are merely strings written with
    a special syntax, and in other languages, Booleans are merely numbers—<wbr>there
    might be subtyping relationships even between base types, but these are not common.)
    However, we do have to consider how subtyping interacts with every single compound
    type constructor.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型对类型系统有普遍影响。我们必须重新审视每种类型并理解它与子类型的相互作用。对于基本类型，这通常是相当明显的：像 Number、String 等不相交的类型彼此之间没有关联。（在某些语言中，一个基本类型用于表示另一个——例如，在一些脚本语言中，数字仅仅是用特殊语法编写的字符串，而在其他语言中，布尔值仅仅是数字——这些基本类型之间可能存在子类型关系，但这种情况并不常见。）然而，我们必须考虑子类型如何与每种复合类型构造函数交互。
- en: In fact, even our very diction about types has to change. Suppose we have an
    expression of type T. Normally, we would say that it produces values of type T.
    Now, we should be careful to say that it produces values of up to or at most T,
    because it may only produce values of a subtype of T. Thus every reference to
    a type should implicitly be cloaked in a reference to the potential for subtyping.
    To avoid pestering you I will refrain from doing this, but be wary that it is
    possible to make reasoning errors by not keeping this implicit interpretation
    in mind.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们甚至关于类型的措辞也必须改变。假设我们有一个类型为 T 的表达式。通常，我们会说它产生了类型为 T 的值。现在，我们应该小心地说它产生了最多或最多为
    T 的值，因为它可能只产生 T 的子类型的值。因此，对类型的每个引用都应该隐含地包含对子类型潜在性的引用。为了避免打扰您，我将不做此操作，但请注意，不考虑这种隐含解释可能会导致推理错误。
- en: 32.6.1.1Subtyping Functions
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.6.1.1 函数的子类型
- en: 'Our examples above have been carefully chosen to mask an important detail:
    the subtyping of functions. To understand this, we will build up an example.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面的例子已经被精心挑选，以掩盖一个重要的细节：函数的子类型。为了理解这一点，我们将举例说明。
- en: 'Consider a hypothetical language with a new type called Boolean01, where true
    is just an alias for 1 and false is an alias for 0. Thus, in this language, Boolean01
    <: Number; all Boolean01 values are of type Number, but not all Number values
    are Boolean01 (indeed, most are not). In this language, we can write some functions:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑一个具有新类型称为 Boolean01 的假想语言，其中 true 只是 1 的别名，false 只是 0 的别名。因此，在这种语言中，Boolean01
    <: Number；所有 Boolean01 值都是 Number 类型，但不是所有 Number 值都是 Boolean01（事实上，大多数都不是）。在这种语言中，我们可以编写一些函数：'
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let us also define four types:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义四种类型：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now ask the following question: which of these types are subtypes of
    the other? In more concrete terms, which of these functions can be safely substituted
    for which others?'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以问以下问题：这些类型中哪些是另一种的子类型？更具体地说，哪些函数可以安全地替代哪些函数？
- en: 'We might expect a rule as follows. Because Boolean01 <: Number (in our imaginary
    system), a (Boolean01 -> Boolean01) function is a subtype of a (Number -> Number)
    function. This is a natural conclusion to arrive at...but wrong, as we will soon
    see.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可能期望有以下规则。因为在我们想象的系统中 Boolean01 <: Number，所以 (Boolean01 -> Boolean01) 函数是
    (Number -> Number) 函数的子类型。这是一个自然的结论...但是错误的，我们很快就会看到。'
- en: 'To make this concrete, assume we have a function p that consumes and uses one
    of these functions. The function could be a member in an object, though for the
    purposes of understanding the basic problem, we don’t need that: we can focus
    just on the function types. Thus, we have something like'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了具体化这一点，假设我们有一个函数 p，它消耗并使用其中的一个函数。虽然该函数可能是对象中的一个成员，但为了理解基本问题，我们不需要这样做：我们可以只关注函数类型。因此，我们有类似于
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: where A and B are going to be all the combinations of Number and Boolean01,
    and assume that a-value has whatever the A type is. For each type for op (column
    headers), we will ask which of the above functions (row headers) we can safely
    pass to p.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 A 和 B 将是所有 Number 和 Boolean01 的组合，并假设 a-value 具有 A 类型的任何内容。对于 op（列标题）的每种类型，我们将询问我们可以安全地将哪个上述函数（行标题）传递给
    p。
- en: Do Now!
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手吧！
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Stop and try to fill out this table first.
  id: totrans-274
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 停下来尝试首先填写这个表格。
- en: '|  |  | N2N |  | N2B |  | B2N |  | B2B |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |  | N2N |  | N2B |  | B2N |  | B2B |'
- en: '| n2n |  | yes (identical) |  | no (range) |  | yes (domain) |  | no (range)
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| n2n |  | yes（相同） |  | no（范围） |  | yes（域） |  | no（范围） |'
- en: '| n2b |  | yes (range) |  | yes (identical) |  | yes (domain and range) |  |
    yes (domain) |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| n2b |  | yes (range) |  | yes (identical) |  | yes (domain and range) |  |
    yes (domain) |'
- en: '| b2n |  | no (domain) |  | no (domain and range) |  | yes (identical) |  |
    no (range) |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| b2n |  | no (domain) |  | no (domain and range) |  | yes (identical) |  |
    no (range) |'
- en: '| b2b |  | no (domain) |  | no (domain) |  | yes (range) |  | yes (identical)
    |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| b2b |  | no (domain) |  | no (domain) |  | yes (range) |  | yes (identical)
    |'
- en: 'In each cell, “yes” means the function on the left can be passed in when the
    type at the top is expected, while “no” means it cannot. Parentheses give the
    reason: “identical” means they are the same type (so of course they can be passed
    in); in the “yes” case it says where subtyping needed to apply, while in the “no”
    case where the type error is.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个单元格中，“yes”表示左侧的函数可以在期望顶部的类型时传入，而“no”表示不能。括号中给出了原因：“identical”表示它们是相同的类型（所以当然可以传入）；在“yes”情况下，它说明需要应用子类型，而在“no”情况下说明类型错误的地方。
- en: 'Let us consider trying to pass n2n to a N2B annotation (for op). Because the
    return type of p is Boolean01, whatever uses p(n2n) assumes that it gets only
    Boolean01 values back. However, the function n2n is free to return any numeric
    value it wants: in particular, given 1 it returns 2, which does not correspond
    to either Boolean01. Therefore, allowing this parameter can result in an unsound
    program execution. To prevent that, we must flag this as a type error.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑尝试将n2n传递给N2B注释（对于op）。因为p的返回类型是Boolean01，无论谁使用p(n2n)，都假定它只会返回Boolean01值。然而，函数n2n可以自由地返回它想要的任何数字值：特别是，给定1，它返回2，这既不对应于Boolean01。因此，允许这个参数可能导致不安全的程序执行。为了防止这种情况发生，我们必须将其标记为类型错误。
- en: 'More generally, if the type of the emph formal parameter promises Boolean01,
    the actual function passed had better return only Boolean01; but if the type of
    the formal is Number, the actual can safely return Boolean01 without causing trouble.
    Thus, in general, for (A -> B) <: (C -> D), we must have that B <: D. In other
    words, the subtyping of the range parallels the subtyping of the function itself,
    so we say the range position is covariant (“co-” meaning “together”).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '更一般地说，如果强调形式参数的类型承诺为Boolean01，则传递的实际函数最好只返回Boolean01；但如果形式的类型是Number，则实际可以安全地返回Boolean01而不会引起麻烦。因此，一般来说，对于(A
    -> B) <: (C -> D)，我们必须有B <: D。换句话说，范围的子类型化与函数本身的子类型化相似，因此我们说范围位置是协变的（“co-”意味着“一起”）。'
- en: 'Now we get to the more interesting case: the domain. Consider why we can pass
    n2n where a B2N is expected. Inside the body of op, a-value can only be a Boolean01,
    because that is all the type permits. Because every Boolean01 is a Number, the
    function n2n has no trouble accepting it.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看更有趣的情况：域。考虑为什么我们可以在期望B2N的地方传递n2n。在op的主体内，a-value只能是Boolean01，因为这是类型允许的。因为每个Boolean01都是一个数字，所以函数n2n没有问题接受它。
- en: In contrast, consider passing b2n where an N2N is expected. Inside op, a-value
    can evaluate to any number, because op is expected (by the type annotation on
    p) to be able to accept it. However, b2n can accept only two numbers; everything
    else results in an error. Hence, if the type-checker were to allow this, we could
    get a run-time error even though the program passed the type-checker.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，考虑在期望N2N的地方传递b2n。在op内部，a-value可以评估为任何数字，因为根据p上的类型注释，op应该能够接受它。然而，b2n只能接受两个数字；其他一切都会导致错误。因此，如果类型检查器允许这样做，我们甚至可以在程序通过类型检查器的情况下获得运行时错误。
- en: 'From this, the moral we derive is that for the domain position, the formal
    must be a subtype of the actual. The formal parameter bounds what values op can
    expect; so long as the actual can take a set of values at least as large, there
    will be no problem. Thus, for (A -> B) <: (C -> D), we must have that C <: A.
    The subtyping of the domain goes in the direction opposite to that of the subtyping
    of the function itself, so we say the range position is contravariant (“contra-”
    meaning “opposite”).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '从中我们得出的道德是，对于域位置，形式参数必须是实际参数的子类型。形式参数限制了op可以期望的值；只要实际参数可以接受至少与之一样多的值集合，就不会有问题。因此，对于(A
    -> B) <: (C -> D)，我们必须有C <: A。域的子类型化与函数本身的子类型化方向相反，因此我们说范围位置是逆变的（“contra-”表示“相反”）。'
- en: 'Putting together these two rules, (A -> B) <: (C -> D) when C <: A and B <:
    D.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '将这两条规则放在一起，当C <: A且B <: D时，(A -> B) <: (C -> D)。'
- en: 32.6.1.2Subtyping and Information Hiding
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.6.1.2子类型和信息隐藏
- en: 'Consider an object o that implements the Add1Sub1 type. By the nature of width
    subtyping, there is absolutely nothing preventing the object from also having
    members named plus and mult of the right type. This raises a question: if we write'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个实现了 Add1Sub1 类型的对象 o。由于宽度子类型的特性，绝对没有任何阻止该对象也具有正确类型的 plus 和 mult 成员的东西。这引发了一个问题：如果我们写为
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: where ... is an object with plus and mult, and then we attempt to pass o to
    f, what should happen?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 其中... 是一个具有 plus 和 mult 的对象，然后我们尝试将 o 传递给 f，应该发生什么？
- en: In a strictly dynamic interpretation—<wbr>e.g., if this program were written
    without any annotations at all—<wbr>it would work perfectly fine. Doing so statically,
    however, means that we have violated our intuition about what these annotations
    mean. In general, it is going to be undecidable whether an object of type Add1Sub1
    actually has the additional Arith members in it, so it is safest to reject programs
    that attempt to use Add1Sub1-annotated values as Arith ones. The natural type
    system will prevent us from passing o to f.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格动态的解释中——例如，如果这个程序完全没有任何注释地编写——它将完美地工作。然而，静态地这样做意味着我们违反了对这些注释意义的直觉。一般来说，判断一个类型为
    Add1Sub1 的对象实际上是否具有附加的 Arith 成员是不可判定的，因此，试图将 Add1Sub1 注释的值用作 Arith 的程序最安全的做法是拒绝。自然类型系统将阻止我们将
    o 传递给 f。
- en: In short, the static type system becomes a mechanism for information hiding.
    By leaving out some members in type descriptions, we effectively hide the fact
    that they exist. For instance, one could create an object
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，静态类型系统成为了信息隐藏的机制。通过在类型描述中省略一些成员，我们有效地隐藏了它们的存在。例如，可以创建一个对象
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: and ascribe it the type
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 并赋予它类型
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如下：
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then all references to for-dist can only use the public interface and have
    no way to access the private-key or decrypt members, but those that have access
    to the crypto object can use those members. Provided access to crypto is provisioned
    carefully, the language will ensure the privacy of these two sensitive members.However,
    this becomes more tricky in a system that is not purely statically typed, including
    ones where a typed language can interoperate with an untyped one. In an untyped
    language there are no annotations, so there is nothing preventing the plus member
    of o or the decrypt member of for-dist from being accessed: after all, those members
    really are present in the underlying object. Thus, it is common when “exporting”
    a typed object to any kind of untrusted or unannotated context to create a proxy
    object; it would be as if the developer wrote the following by hand:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 那么所有对 DIST 的引用都只能使用公共接口，并且无法访问 private-key 或 decrypt 成员，但是那些可以访问 crypto 对象的人可以使用这些成员。只要小心配置了对
    crypto 的访问权限，语言就会确保这两个敏感成员的隐私。然而，在一个不是纯静态类型的系统中（包括那些允许类型化语言与未类型化语言进行互操作的系统），情况会变得更加棘手。在未类型化语言中，没有注释，因此没有什么阻止
    o 的 plus 成员或 for-dist 的 decrypt 成员被访问：毕竟，这些成员确实存在于底层对象中。因此，当将类型化对象“导出”到任何不受信任或未注释的上下文中时，通常会创建一个代理对象；这就好像开发者手动编写了以下内容：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is proxy-dist that is then provided to dangerous contexts. Since the resulting
    object really contains only two fields, and the underlying object is only visible
    in lexical scope (c), so long as the language does not provide a means to inspect
    or traverse the scope (an assumption not guaranteed by all languages!), the untyped
    or dangerous context cannot get access to the private content.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它就是代理 DIST，随后提供给危险环境。由于生成的对象实际上只包含两个字段，并且底层对象仅在词法范围内可见 (c)，只要语言不提供检查或遍历范围的手段（这不是所有语言都保证的假设！），未类型化或危险上下文就无法访问私有内容。
- en: 32.6.1.3Implementing Subtyping
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.6.1.3 实现子类型
- en: 'Of course, these rules assume that we have modified the type-checker to respect
    subtyping. The essence of subtyping is a rule that says, if an expression e is
    of type S, and S <: T, then e also has type T. While this sounds intuitive, it
    is also immediately problematic for two reasons:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，这些规则假设我们已经修改了类型检查器以尊重子类型。子类型的本质是一个规则，即，如果表达式 e 的类型是 S，并且 S <: T，则 e 也具有类型
    T。虽然这听起来很直观，但由于以下两个原因，这也立即成为问题：'
- en: Until now all of our type rules have been syntax-driven, which is what enabled
    us to write a recursive-descent type-checker. Now, however, we have a rule that
    applies to all expressions, so we can no longer be sure when to apply it.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的类型规则都是基于语法驱动的，这使得我们能够编写递归下降类型检查器。然而，现在，我们有了一个适用于所有表达式的规则，因此我们不能再确定何时应用它。
- en: There could be many levels of subtyping. As a result, it is no longer obvious
    when to “stop” subtyping. In particular, whereas before type-checking was able
    to calculate the type of an expression, now we have many possible types for each
    expression; if we return the “wrong” one, we might get a type error (due to that
    not being the type expected by the context) even though there exists some other
    type that was the one expected by the context.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类型化可能有多个层次。因此，当“停止”子类型化时，不再明显。特别是，在以前，类型检查能够计算表达式的类型，现在每个表达式可能有许多可能的类型；如果我们返回了“错误”的类型，我们可能会得到一个类型错误（因为那不是上下文所期望的类型），即使存在某种其他类型是上下文所期望的类型。
- en: 'What these two issues point to is that the description of subtyping we are
    giving here is fundamentally declarative: we are saying what must be true, but
    not showing how to turn it into an algorithm. For each actual type language, there
    is a less or more interesting problem in turning this into algorithmic subtyping:
    an actual algorithm that realizes a type-checker (ideally one that types exactly
    those programs that would have typed under the declarative regime, i.e., one that
    is both sound and complete).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题指出我们在此提供的子类型化描述基本上是声明性的：我们说出了什么是真的，但没有展示如何将其转换为算法。对于每种实际的类型语言，将其转换为算法子类型化存在着更或更少有趣的问题：一个真正实现了类型检查器的算法（理想情况下，它能够完全地检查那些在声明性制度下会被检查的程序，即一个既声音又完整的检查器）。
- en: 32.6.2Types for Self-Reference
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.6.2自引用类型
- en: 'Remember that one of the essential features of many object systems is having
    a reference, inside a method, to the object on which it was invoked: i.e., a self-reference
    [[Objects with Self-Reference](#%28part._obj-with-self%29)]. What is the type
    of this self identifier?'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，许多对象系统的一个重要特性是在方法内部引用调用它的对象的引用：即，一个自引用[[具有自引用的对象](#%28part._obj-with-self%29)]。这个self标识符的类型是什么？
- en: Consider the type Add1Sub1 we described earlier. To be entirely honest, the
    implementation of add1 and sub1—<wbr>to be methods—<wbr>must take an extra parameter
    that will be a self-reference. What is the nature of this self-referential parameter?
    It is clearly an object; it clearly has two methods, add1 and sub1 (at least up
    to subtyping); and each of those methods takes two parameters, one a number and...
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前描述的Add1Sub1类型。说实话，add1和sub1的实现 - 作为方法 - 必须带有一个额外的参数，这个参数将是一个自引用。这个自引用参数的性质是什么？显然它是一个对象；显然它有两个方法，add1和sub1（至少在子类型化上）；每个方法都接受两个参数，一个是数字，...
- en: You see where this is going.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你看出这是什么意思了吗？
- en: 'Object types are therefore typically recursive types: the type world’s equivalent
    of rec [REF]. Typically, they are written μ (“mu”) instead of rec; thus:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对象类型通常是递归类型：类型世界的mu（“mu”）等价物。通常，它们用μ（“mu”）而不是rec来表示；因此：
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Read the right-hand side as “construct a recursive type T such that it (a) is
    an object, (b) has two members add1 and sub1, and (c) each member has two parameters,
    the first of which is the type being defined” (and so on).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 将右边解释为“构造一个递归类型T，使其（a）是一个对象，（b）有两个成员add1和sub1，（c）每个成员有两个参数，第一个是正在定义的类型”（等等）。
- en: Unfortunately, recursive types are not as simple as they look. Note that the
    above type does not have a “base case”; thus, it is a finite representation of
    an infinite type (which is exactly what we want, because we can write an infinite
    number of self applications). Therefore, when it comes to checking for the equality
    of two recursive types, we encounter complications, which are beyond the scope
    of this study.See Pierce’s Types and Programming Languages for details.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，递归类型并不像看起来那么简单。注意，上述类型没有“基本情况”；因此，它是一个无限类型的有限表示（这正是我们想要的，因为我们可以编写无限数量的自我应用）。因此，当涉及检查两个递归类型的相等性时，我们会遇到超出本研究范围的复杂性，请参阅Pierce的Types
    and Programming Languages了解详情。
- en: 32.6.3Nominal Types
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 32.6.3名义类型
- en: 'Earlier [[Object Classification and Object Equality](#%28part._nominal-equality%29)]
    we read about nominal equality, where classes are made to aid in equality comparisons.
    In some typed languages—<wbr>Java being a poster-child—<wbr>classes carry an even
    heavier load: they are also used as the basis for the type system, rather than
    structural types.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候[[对象分类和对象相等性](#%28part._nominal-equality%29)]，我们读到了名义相等性，其中类用于辅助相等性比较。在一些类型化语言中
    - 例如Java是典型代表 - 类承担了更重要的任务：它们还用作类型系统的基础，而不是结构类型。
- en: 'The basic idea is that each class (or other nominal entity) defines an entirely
    new type, even if the type-structure of its members is exactly the same as that
    of some other type. Then, type equality mirrors nominal equality, but trivially:
    if two values have the same type they must have the same structure, and if they
    have different types then their structure doesn’t matter (even if it’s identical).
    Thus, type equality reduces to a constant-time check of whether the classes are
    the same.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是，每个类（或其他标称实体）都定义了一个全新的类型，即使其成员的类型结构与其他某些类型完全相同。然后，类型相等反映了标称相等，但是平凡的：如果两个值具有相同的类型，则它们必须具有相同的结构，如果它们具有不同的类型，则它们的结构无关紧要（即使它们相同）。因此，类型相等可以简化为一个常数时间的检查，检查类是否相同。
- en: 'Nominal types have one more advantage. They effectively make it straightforward
    to write recursive types without wrestling with μ. Consider the following Java
    class definition:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 标称类型还有一个优点。它们有效地使得编写递归类型变得直接，而不用与 μ 打交道。考虑下面的 Java 类定义：
- en: '| class Add1Sub1 { |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| class Add1Sub1 { |'
- en: '|   public int add1(int n) { ... } |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|   public int add1(int n) { ... } |'
- en: '|   public int sub1(int n) { ... } |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|   public int sub1(int n) { ... } |'
- en: '| } |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| } |'
- en: 'Implicit in these two method definitions are this parameters. But what is the
    type of this? It’s just Add1Sub1: the keyword class not only introduces a new
    name but automatically makes it a recursive binding. Thus, programmers can comfortably
    refer to and use nominal types without having to dwell on their true meaning (as
    recursive types) or their equality (because it’s by name rather than structure).
    Thus, nominal types, for all their inflexibility, do offer an elegant solution
    to a particular set of language design constraints.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法定义中隐含了 this 参数。但是，this 的类型是什么呢？它只是 Add1Sub1：关键词 class 不仅引入了一个新名称，还自动使其成为一个递归绑定。因此，程序员可以舒适地引用和使用标称类型，而不必纠结于它们的真正含义（作为递归类型）或它们的相等性（因为是按名称而不是按结构）。因此，尽管标称类型非常不灵活，但确实为特定的语言设计约束提供了一种优雅的解决方案。
- en: 'It is worth noting that in Java, inheritance (unfortunately) corresponds to
    subtyping. As we go up the inheritance chain a class has fewer and fewer members
    (width subtyping), until we reach Object, the supertype of all classes, which
    has the fewest. Thus for all class types C in Java, C <: Object.Somewhat confusingly,
    the terms narrowing and widening are sometimes used, but with what some might
    consider the opposite meaning. To widen is to go from subtype to supertype, because
    it goes from a “narrower” (smaller) to a “wider” (bigger) set. These terms evolved
    independently, but unfortunately not consistently. The interpretation of subtyping
    as subsets holds: every object that has a type lower in an inheritance hierarchy
    also has a type higher in the hierarchy, but not vice versa. When it comes to
    depth subtyping, however, Java prefers types to be invariant down the object hierarchy
    because this is a safe option for conventional mutation.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '值得注意的是，在 Java 中，继承（不幸地）对应于子类型化。当我们沿着继承链向上移动时，一个类的成员会越来越少（宽度子类型化），直到我们到达 Object，即所有类的超类型，它具有最少的成员。因此，对于
    Java 中的所有类类型 C，C <: Object。有些令人困惑的是，有时候会使用缩小和扩大这些术语，但一些人可能认为它们的含义相反。扩大是指从子类型到超类型，因为它从“更窄”的（更小的）集合到“更宽”的（更大的）集合。这些术语是独立演变的，但不幸的是不一致。子类型化的解释如下：每个在继承层次结构中较低的类型也在继承层次结构中较高的位置上具有类型，但反之则不然。然而，当涉及到深度子类型化时，Java
    更倾向于在对象层次结构下使类型不变，因为这对于常规变异是一种安全的选项。'
