- en: Managing Flash Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lecture Notes for CS 140
  prefs: []
  type: TYPE_NORMAL
- en: Spring 2014
  prefs: []
  type: TYPE_NORMAL
- en: John Ousterhout
  prefs: []
  type: TYPE_NORMAL
- en: 'Readings for this topic from *Operating Systems: Principles and Practice*:
    Section 12.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solid state (semiconductor) storage, replacing disks in many applications (e.g.
    phones and other devices). Primary advantages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nonvolatile (unlike DRAM): values persist even if device is powered off'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Better than disk:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: No moving parts, so more reliable
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster access
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: More shock-resistant
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 5-10x more expensive than disk
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 5-10x cheaper than DRAM
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two styles, NAND and NOR; NAND is most popular today:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total chip capacity up to 8 Gbytes today
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage divided into *erase units* (typically 256 Kbytes), which are subdivided
    into *pages* (typically 512 bytes or 4 Kbytes)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage is read in units of pages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two kinds of writes:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Erase: sets all of the bits in an erase unit to 1''s.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write: modifies an individual page, can only clear bits to 0 (writing 1''s
    has no effect).'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Can write repeatedly to clear more bits.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Wear-out*: once a page has been erased many times (typically around 100,000,
    as low as 10,000 in some new devices) it no longer stores information reliably.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical flash memory performance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read performance: 20-100 microsconds latency, 100-500 MBytes/sec.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Erasure time: 2 ms'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write performance: 200 microseconds latency, 100-200 MBytes/sec.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In practice, most flash memory devices are packaged with a *flash translation
    layer* (FTL):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software that manages the flash device
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically provides an interface like that for a disk (read and write blocks)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use with existing file system software
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FTLs are interesting pieces of software, but most FTLs today aren''t very good:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sacrifice performance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Waste capacity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One possible approach for FTLs: *direct mapped* (e.g., some cheap flash sticks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual block *i* is stored on page *i* of the flash device
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads are simple
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To write virtual block *i*:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Read erase unit containing page *i*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Erase the entire unit
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite erase unit with modified page
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What's wrong with this approach?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid these problems, must separate virtual block number from physical location
    in flash memory, so a given virtual block can occupy different pages in flash
    memory over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a *block map* that maps from virtual blocks to physical pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads must first lookup the physical location in the block map
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For writes:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a free and erased page
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write virtual block to that page
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Update block map with new location
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark previous page for virtual block as free
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This introduces additional issues
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage map (is it stored on the flash device?)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage free space (e.g. wear leveling)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One approach: keep block map in memory, rebuild on startup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't store block map on flash device
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each page on flash contains an additional header:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual block number
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Free/used bit (1 => free)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevalid/valid bit (1 => prevalid)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: valid/Obsolete bit (1 => valid)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'F-P-O bits track lifecycle of page:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just erased: 1-1-1'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About to write data: 0-1-1'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Block successfully written: 0-0-1'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Block deleted (new copy written elsewhere): 0-0-0'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is 0-1-1 state needed?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On startup, read entire contents of flash memory to rebuild block map (32 seconds
    for 8GB, 512 seconds for 128GB).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To reduce memory utilization for block map, store block map in flash, cache
    parts of it in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header for each flash page indicates whether that page is a data page or a map
    page
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep locations of map pages in memory (map-map)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan flash on startup to re-create map-map
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: During writes, must write new map page plus new data page
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some reads may require 2 flash operations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Obsolete blocks accumulate in erase units, which reduces effective capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution: *garbage collection*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find erase units with many free pages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy live pages to a clean erase unit (update block map)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Erase and reuse old erase unit
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: must always keep at least one clean erase unit to use for garbage collection!'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wear-leveling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want all erase units to be erased at about the same rate
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use garbage collection to move data between "hot" and "cold" pages.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hard to achieve good performance, good utilization, and longevity all the same
    time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the flash device is 90% utilized, write cost increases by 10x:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To get space for one new page, must garbage collect 10 old pages
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 9 will still be valid and must be copied
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 new page gets written
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Total: 9 reads, 10 writes to write 1 new page!'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This is called *write amplification*
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower utilization makes writes cheaper, but wastes space.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequent garbage collection (e.g. because of high utilization) also wears out
    the device faster
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ideal situation: hot and cold data'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some erase units contain only data that is never modified ("cold"), so they
    are always full and never need to be garbage collected.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other erase units contain data that is quickly overwritten; we can just wait
    until all of the pages have been overwritten, then garbage collect the erase unit
    for free.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are ways to encourage such a bimodal distribution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Incorporating flash memory as a disk-like device with FTL is inefficient:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Duplication:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OS already keeps various index structures for files:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These are equivalent to the block map
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If OS could manage the flash directly, it could combine the block map with file
    indexes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lack of information:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: FTL doesn't know when OS has freed a block; only finds out when block is overwritten
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus FTL may rewrite dead blocks during garbage collection!
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Newer flash devices offer *trim* command that allows OS to indicate deletion
    (but must modify OS file systems).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Better long-term solution: new file systems designed just for flash memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of interesting issues and design alternatives
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Has been explored by research teams, but no widely-used implementations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Need ability to bypass the FTL
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Interesting opportunity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
