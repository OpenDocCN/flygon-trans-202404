- en: Considering Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Const as Much as Possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`const` tells the compiler that a variable or method is immutable. This helps
    the compiler optimize the code and helps the developer know if a function has
    a side effect. Also, using `const &` prevents the compiler from copying data unnecessarily.
    The [comments on `const` from John Carmack](http://kotaku.com/454293019) are also
    a good read.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Carefully Consider Your Return Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning by `&` or `const &` can have significant performance savings when
    the normal use of the returned value is for observation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning by value is better for thread safety and if the normal use of the
    returned value is to make a copy anyhow, there's no performance lost
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If your API uses covariant return types, you must return by `&` or `*`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporaries and local values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always return by value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'references: [https://github.com/lefticus/cppbestpractices/issues/21](https://github.com/lefticus/cppbestpractices/issues/21)
    [https://twitter.com/lefticus/status/635943577328095232](https://twitter.com/lefticus/status/635943577328095232)'
  prefs: []
  type: TYPE_NORMAL
- en: Do not pass and return simple types by const ref
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, pass and return simple types by value. If you plan not to change passed
    value, declare them as `const`, but not `const` refs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Why? Because passing and returning by reference leads to pointer operations
    instead by much more faster passing values in processor registers.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Raw Memory Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Raw memory access, allocation and deallocation, are difficult to get correct
    in C++ without [risking memory errors and leaks](http://blog2.emptycrate.com/content/nobody-understands-c-part-6-are-you-still-using-pointers).
    C++11 provides tools to avoid these problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Use `std::array` or `std::vector` Instead of C-style Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both of these guarantee contiguous memory layout of objects and can (and should)
    completely replace your usage of C-style arrays for many of the reasons listed
    for not using bare pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Also, [avoid](http://stackoverflow.com/questions/3266443/can-you-use-a-shared-ptr-for-raii-of-c-style-arrays)
    using `std::shared_ptr` to hold an array.
  prefs: []
  type: TYPE_NORMAL
- en: Use Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions cannot be ignored. Return values, such as using `boost::optional`,
    can be ignored and if not checked can cause crashes or memory errors. An exception,
    on the other hand, can be caught and handled. Potentially all the way up the highest
    level of the application with a log and automatic restart of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Stroustrup, the original designer of C++, [makes this point](http://www.stroustrup.com/bs_faq2.html#exceptions-why)
    much better than I ever could.
  prefs: []
  type: TYPE_NORMAL
- en: Use C++-style cast instead of C-style cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the C++-style cast (static_cast<>, dynamic_cast<> ...) instead of the C-style
    cast. The C++-style cast allows more compiler checks and is considerable safer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Additionally the C++ cast style is more visible and has the possibility to search
    for.
  prefs: []
  type: TYPE_NORMAL
- en: But consider refactoring of program logic (for example, additional checking
    on overflow and underflow) if you need to cast `double` to `int`. Measure three
    times and cut 0.9999999999981 times.
  prefs: []
  type: TYPE_NORMAL
- en: Do not define a variadic function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variadic functions can accept a variable number of parameters. The probably
    best known example is printf(). You have the possibility to define this kind of
    functions by yourself but this is a possible security risk. The usage of variadic
    functions is not type safe and the wrong input parameters can cause a program
    termination with an undefined behavior. This undefined behavior can be exploited
    to a security problem. If you have the possibility to use a compiler that supports
    C++11, you can use variadic templates instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[It is technically possible to make typesafe C-style variadic functions with
    some compilers](https://github.com/lefticus/cppbestpractices/issues/53)'
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[How to Prevent The Next Heartbleed](http://www.dwheeler.com/essays/heartbleed.html)
    by David Wheeler is a good analysis of the current state of code safety and how
    to ensure safe code.'
  prefs: []
  type: TYPE_NORMAL
