- en: ImpSimple Imperative Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Z ::= X;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE not (Z = 0) DO
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y * Z;;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= Z - 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: This chapter looks at how to define the *syntax* and *semantics*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of Imp; the chapters that follow develop a theory of *program equivalence* and
    introduce *Hoare Logic*, a widely used logic for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reasoning about imperative programs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic and Boolean Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll present Imp in three parts: first a core language of'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*arithmetic and boolean expressions*, then an extension of these'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions with *variables*, and finally a language of *commands*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: including assignment, conditions, sequencing, and loops.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Module AExp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive aexp : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ANum : nat → aexp'
  prefs: []
  type: TYPE_NORMAL
- en: '| APlus : aexp → aexp → aexp'
  prefs: []
  type: TYPE_NORMAL
- en: '| AMinus : aexp → aexp → aexp'
  prefs: []
  type: TYPE_NORMAL
- en: '| AMult : aexp → aexp → aexp.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive bexp : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| BTrue : bexp'
  prefs: []
  type: TYPE_NORMAL
- en: '| BFalse : bexp'
  prefs: []
  type: TYPE_NORMAL
- en: '| BEq : aexp → aexp → bexp'
  prefs: []
  type: TYPE_NORMAL
- en: '| BLe : aexp → aexp → bexp'
  prefs: []
  type: TYPE_NORMAL
- en: '| BNot : bexp → bexp'
  prefs: []
  type: TYPE_NORMAL
- en: '| BAnd : bexp → bexp → bexp.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: APlus (ANum 1) (AMult (ANum 2) (ANum 3)).
  prefs: []
  type: TYPE_NORMAL
- en: The optional chapter [ImpParser](ImpParser.html) develops a simple
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: implementation of a lexical analyzer and parser that can perform
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this translation.  You do *not* need to understand that chapter to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: understand this one, but if you haven't taken a course where these
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: techniques are covered (e.g., a compilers course) you may want to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: skim it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For comparison, here's a conventional BNF (Backus-Naur Form)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'grammar defining the same abstract syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Evaluating* an arithmetic expression produces a number.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, evaluating a boolean expression yields a boolean.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We haven't defined very much yet, but we can already get
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: some mileage out of the definitions.  Suppose we define a function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that takes an arithmetic expression and slightly simplifies it,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: changing every occurrence of 0+e (i.e., (APlus (ANum 0) e)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: into just e.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To make sure our optimization is doing the right thing we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can test it on some examples and see if the output looks OK.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But if we want to be sure the optimization is correct —
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: i.e., that evaluating an optimized expression gives the same
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: result as the original — we should prove it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Coq Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The amount of repetition in this last proof is a little
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: annoying.  And if either the language of arithmetic expressions or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the optimization being proved sound were significantly more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: complex, it would start to be a real problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So far, we've been doing all our proofs using just a small handful
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of Coq's tactics and completely ignoring its powerful facilities
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for constructing parts of proofs automatically.  This section
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: introduces some of these facilities, and we will see more over the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: next several chapters.  Getting used to them will take some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: energy — Coq's automation is a power tool — but it will allow us
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to scale up our efforts to more complex definitions and more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: interesting properties without becoming overwhelmed by boring,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: repetitive, low-level details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The try Tactical
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If T is a tactic, then try T is a tactic that is just like T
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: except that, if T fails, try T *successfully* does nothing at
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: all (instead of failing).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There is no real reason to use try in completely manual
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proofs like these, but it is very useful for doing automated
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proofs in conjunction with the ; tactical, which we show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma foo : ∀n, leb 0 n = true.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros.
  prefs: []
  type: TYPE_NORMAL
- en: destruct n.
  prefs: []
  type: TYPE_NORMAL
- en: (* Leaves two subgoals, which are discharged identically...  *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n=0 *) simpl. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n=Sn'' *) simpl. reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma foo'' : ∀n, leb 0 n = true.'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros.
  prefs: []
  type: TYPE_NORMAL
- en: (* destruct the current goal *)
  prefs: []
  type: TYPE_NORMAL
- en: destruct n;
  prefs: []
  type: TYPE_NORMAL
- en: (* then simpl each resulting subgoal *)
  prefs: []
  type: TYPE_NORMAL
- en: simpl;
  prefs: []
  type: TYPE_NORMAL
- en: (* and do reflexivity on each resulting subgoal *)
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem optimize_0plus_sound'': ∀a,'
  prefs: []
  type: TYPE_NORMAL
- en: aeval (optimize_0plus a) = aeval a.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros a.
  prefs: []
  type: TYPE_NORMAL
- en: induction a;
  prefs: []
  type: TYPE_NORMAL
- en: (* Most cases follow directly by the IH... *)
  prefs: []
  type: TYPE_NORMAL
- en: try (simpl; rewrite IHa1; rewrite IHa2; reflexivity).
  prefs: []
  type: TYPE_NORMAL
- en: (* ... but the remaining cases -- ANum and APlus --        are different: *)
  prefs: []
  type: TYPE_NORMAL
- en: '- (* ANum *) reflexivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* APlus *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct a[1];
  prefs: []
  type: TYPE_NORMAL
- en: (* Again, most cases follow directly by the IH: *)
  prefs: []
  type: TYPE_NORMAL
- en: try (simpl; simpl in IHa1; rewrite IHa1;
  prefs: []
  type: TYPE_NORMAL
- en: rewrite IHa2; reflexivity).
  prefs: []
  type: TYPE_NORMAL
- en: (* The interesting case, on which the try...        does nothing, is when e[1]
    = ANum n. In this        case, we have to destruct n (to see whether        the optimization applies) and rewrite with the
           induction hypothesis. *)
  prefs: []
  type: TYPE_NORMAL
- en: + (* a[1] = ANum n *) destruct n;
  prefs: []
  type: TYPE_NORMAL
- en: simpl; rewrite IHa2; reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: aeval (optimize_0plus a) = aeval a.
  prefs: []
  type: TYPE_NORMAL
- en: '*Proof*: By induction on a.  Most cases follow directly from the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'IH.  The remaining cases are as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Suppose a = ANum n for some n. We must show
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Suppose a = APlus a[1] a[2] for some a[1] and a[2]. We must show
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: optimize_0plus (APlus a[1] a[2]) = optimize_0plus a[2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and the IH for a[2] is exactly what we need. On the other hand, if n = S n'
    for some n', then again optimize_0plus simply calls itself recursively, and the
    result follows from the IH. ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, this proof can still be improved: the first case (for'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a = ANum n) is very trivial — even more trivial than the cases
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that we said simply followed from the IH — yet we have chosen to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: write it out in full.  It would be better and clearer to drop it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and just say, at the top, "Most cases are either immediate or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: direct from the IH.  The only interesting case is the one for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: APlus..."  We can make the same improvement in our formal proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'too.  Here''s how it looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The ; Tactical (General Form)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ; tactical also has a more general form than the simple
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: T;T' we've seen above.  If T, T[1], ..., Tn are tactics,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: T; [T' | T' | ... | T']
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem In[10] : In 10 [1;2;3;4;5;6;7;8;9;10].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: repeat (try (left; reflexivity); right).
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem In[10]'' : In 10 [1;2;3;4;5;6;7;8;9;10].'
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: repeat (left; reflexivity).
  prefs: []
  type: TYPE_NORMAL
- en: repeat (right; try (left; reflexivity)).
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint optimize_0plus_b (b : bexp) : bexp'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem optimize_0plus_b_sound : ∀b,'
  prefs: []
  type: TYPE_NORMAL
- en: beval (optimize_0plus_b b) = beval b.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Defining New Tactic Notations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coq also provides several ways of "programming" tactic scripts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Tactic Notation idiom illustrated below gives a handy way to define "shorthand
    tactics" that bundle several tactics into a single command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more sophisticated programming, Coq offers a built-in programming language
    called Ltac with primitives that can examine and modify the proof state. The details
    are a bit too complicated to get into here (and it is generally agreed that Ltac
    is not the most beautiful part of Coq's design!), but they can be found in the
    reference manual and other books on Coq, and there are many examples of Ltac definitions
    in the Coq standard library that you can use as examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an OCaml API, which can be used to build tactics that access Coq's
    internal structures at a lower level, but this is seldom worth the trouble for
    ordinary Coq users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tactic Notation mechanism is the easiest to come to grips with,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and it offers plenty of power for many purposes.  Here's an example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This defines a new tactical called simpl_and_try that takes one
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic c as an argument and is defined to be equivalent to the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic simpl; try c.  Now writing "simpl_and_try reflexivity."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in a proof will be the same as writing "simpl; try reflexivity."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example silly_presburger_example : ∀m n o p,'
  prefs: []
  type: TYPE_NORMAL
- en: m + n ≤ n + o ∧ o + 3 = p + 3 →
  prefs: []
  type: TYPE_NORMAL
- en: m ≤ p.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros. omega.
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Evaluation as a Relation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have presented aeval and beval as functions defined by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fixpoints.  Another way to think about evaluation — one that we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: will see is often more flexible — is as a *relation* between
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions and their values.  This leads naturally to Inductive
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions like the following one for arithmetic expressions...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It will be convenient to have an infix notation for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: aevalR.  We'll write e ⇓ n to mean that arithmetic expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e evaluates to value n.  (This notation is one place where the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: limitation to ASCII symbols becomes a little bothersome.  The
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: standard notation for the evaluation relation is a double
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: down-arrow.  We'll typeset it like this in the HTML version of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: notes and use a double slash as the closest approximation in .v
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: files.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In fact, Coq provides a way to use this notation in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition of aevalR itself.  This reduces confusion by avoiding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: situations where we're working on a proof involving statements in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the form e ⇓ n but we have to refer back to a definition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: written using the form aevalR e n.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We do this by first "reserving" the notation, then giving the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition together with a declaration of what the notation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: means.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Inference Rule Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In informal discussions, it is convenient to write the rules for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: aevalR and similar relations in the more readable graphical form
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of *inference rules*, where the premises above the line justify
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the conclusion below the line (we have already seen them in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Prop](Prop.html) chapter).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, the constructor E_APlus...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Equivalence of the Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is straightforward to prove that the relational and functional
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'definitions of evaluation agree:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We can make the proof quite a bit shorter by making more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use of tacticals.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars (bevalR)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a relation bevalR in the same style as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: aevalR, and prove that it is equivalent to beval.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Computational vs. Relational Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the definitions of evaluation for arithmetic and boolean
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions, the choice of whether to use functional or relational
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'definitions is mainly a matter of taste: either way works.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, there are circumstances where relational definitions of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evaluation work much better than functional ones.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For example, suppose that we wanted to extend the arithmetic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'operations by considering also a division operation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Extending the definition of aeval to handle this new operation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: would not be straightforward (what should we return as the result
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of ADiv (ANum 5) (ANum 0)?).  But extending aevalR is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: straightforward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Suppose, instead, that we want to extend the arithmetic operations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by a nondeterministic number generator any that, when evaluated,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: may yield any number.  (Note that this is not the same as making a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*probabilistic* choice among all possible numbers — we''re not'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: specifying any particular distribution of results, but just saying
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: what results are *possible*.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Again, extending aeval would be tricky, since now evaluation is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*not* a deterministic function from expressions to numbers, but'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'extending aevalR is no problem:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point you maybe wondering: which style should I use by'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: default?  The examples above show that relational definitions are
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: fundamentally more powerful than functional ones.  For situations
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: like these, where the thing being defined is not easy to express
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: as a function, or indeed where it is *not* a function, there is no
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: choice.  But what about when both styles are workable?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One point in favor of relational definitions is that some people
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: feel they are more elegant and easier to understand.  Another is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that Coq automatically generates nice inversion and induction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: principles from Inductive definitions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the other hand, functional definitions can often be more
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'convenient:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Functions are by definition deterministic and defined on all arguments; for
    a relation we have to show these properties explicitly if we need them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With functions we can also take advantage of Coq's computation mechanism to
    simplify expressions during proofs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, functions can be directly "extracted" to executable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: code in OCaml or Haskell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ultimately, the choice often comes down to either the specifics of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a particular situation or simply a question of taste.  Indeed, in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: large Coq developments it is common to see a definition given in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*both* functional and relational styles, plus a lemma stating that'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the two coincide, allowing further proofs to switch from one point
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of view to the other at will.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: States
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we'll want to look variables up to find out their current
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values, we'll reuse the type id from the [Maps](Maps.html) chapter for the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: type of variables in Imp.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A *machine state* (or just *state*) represents the current values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of *all* variables at some point in the execution of a program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For simplicity, we assume that the state is defined for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*all* variables, even though any given program is only going to'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mention a finite number of them.  The state captures all of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: information stored in memory.  For Imp programs, because each
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variable stores a natural number, we can represent the state as a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mapping from identifiers to nat.  For more complex programming
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: languages, the state might have more structure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can add variables to the arithmetic expressions we had before by
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'simply adding one more constructor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Defining a few variable names as notational shorthands will make
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'examples easier to read:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: (This convention for naming program variables (X, Y,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Z) clashes a bit with our earlier use of uppercase letters for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: types.  Since we're not using polymorphism heavily in the chapters
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: devoped to Imp, this overloading should not cause confusion.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The definition of bexps is unchanged (except for using the new
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'aexps):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arith and boolean evaluators are extended to handle
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variables in the obvious way, taking a state as an extra
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'argument:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we are ready define the syntax and behavior of Imp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*commands* (sometimes called *statements*).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: c ::= SKIP | x ::= a | c ;; c | IFB b THEN c ELSE c FI
  prefs: []
  type: TYPE_NORMAL
- en: '| WHILE b DO c END'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s factorial in Imp:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive com : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| CSkip : com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CAss : id → aexp → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CSeq : com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CIf : bexp → com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CWhile : bexp → com → com.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Notation "'SKIP'" :=
  prefs: []
  type: TYPE_NORMAL
- en: CSkip.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "x '::=' a" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CAss x a) (at level 60).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "c1 ;; c2" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CWhile b c) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CIf c[1] c[2] c[3]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition fact_in_coq : com :='
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AId X;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= ANum 1;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BNot (BEq (AId Z) (ANum 0)) DO
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= AMult (AId Y) (AId Z);;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMinus (AId Z) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition plus2 : com :='
  prefs: []
  type: TYPE_NORMAL
- en: X ::= (APlus (AId X) (ANum 2)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition XtimesYinZ : com :='
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= (AMult (AId X) (AId Y)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition subtract_slowly_body : com :='
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= AMinus (AId Z) (ANum 1) ;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= AMinus (AId X) (ANum 1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition subtract_slowly : com :='
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BNot (BEq (AId X) (ANum 0)) DO
  prefs: []
  type: TYPE_NORMAL
- en: subtract_slowly_body
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition subtract_3_from_5_slowly : com :='
  prefs: []
  type: TYPE_NORMAL
- en: X ::= ANum 3 ;;
  prefs: []
  type: TYPE_NORMAL
- en: Z ::= ANum 5 ;;
  prefs: []
  type: TYPE_NORMAL
- en: subtract_slowly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition loop : com :='
  prefs: []
  type: TYPE_NORMAL
- en: WHILE BTrue DO
  prefs: []
  type: TYPE_NORMAL
- en: SKIP
  prefs: []
  type: TYPE_NORMAL
- en: END.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Evaluation as a Function (Failed Attempt)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here's an attempt at defining an evaluation function for commands,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: omitting the WHILE case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In a traditional functional programming language like OCaml or
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Haskell we could add the WHILE case as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Coq doesn''t accept such a definition ("Error: Cannot guess'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: decreasing argument of fix") because the function we want to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: define is not guaranteed to terminate. Indeed, it *doesn't* always
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'terminate: for example, the full version of the ceval_fun'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function applied to the loop program above would never
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: terminate. Since Coq is not just a functional programming
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language but also a consistent logic, any potentially
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: non-terminating function needs to be rejected. Here is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: an (invalid!) program showing what would go wrong if Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'allowed non-terminating recursive functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: That is, propositions like False would become provable
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (loop_false 0 would be a proof of False), which
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: would be a disaster for Coq's logical consistency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Thus, because it doesn't terminate on all inputs,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of ceval_fun cannot be written in Coq — at least not without
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: additional tricks and workarounds (see chapter [ImpCEvalFun](ImpCEvalFun.html)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if you're curious about what those might be).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Reserved Notation "c1 '/' st '⇓' st'"
  prefs: []
  type: TYPE_NORMAL
- en: (at level 40, st at level 39).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive ceval : com → state → state → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Skip : ∀st,'
  prefs: []
  type: TYPE_NORMAL
- en: SKIP / st ⇓ st
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Ass  : ∀st a[1] n x,'
  prefs: []
  type: TYPE_NORMAL
- en: aeval st a[1] = n →
  prefs: []
  type: TYPE_NORMAL
- en: (x ::= a[1]) / st ⇓ (t_update st x n)
  prefs: []
  type: TYPE_NORMAL
- en: '| E_Seq : ∀c[1] c[2] st st'' st'''','
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st  ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / st' ⇓ st'' →
  prefs: []
  type: TYPE_NORMAL
- en: (c[1] ;; c[2]) / st ⇓ st''
  prefs: []
  type: TYPE_NORMAL
- en: '| E_IfTrue : ∀st st'' b c[1] c[2],'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b = true →
  prefs: []
  type: TYPE_NORMAL
- en: c[1] / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN c[1] ELSE c[2] FI) / st ⇓ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_IfFalse : ∀st st'' b c[1] c[2],'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b = false →
  prefs: []
  type: TYPE_NORMAL
- en: c[2] / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: (IFB b THEN c[1] ELSE c[2] FI) / st ⇓ st'
  prefs: []
  type: TYPE_NORMAL
- en: '| E_WhileEnd : ∀b st c,'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b = false →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b DO c END) / st ⇓ st
  prefs: []
  type: TYPE_NORMAL
- en: '| E_WhileLoop : ∀st st'' st'''' b c,'
  prefs: []
  type: TYPE_NORMAL
- en: beval st b = true →
  prefs: []
  type: TYPE_NORMAL
- en: c / st ⇓ st' →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b DO c END) / st' ⇓ st'' →
  prefs: []
  type: TYPE_NORMAL
- en: (WHILE b DO c END) / st ⇓ st''
  prefs: []
  type: TYPE_NORMAL
- en: where "c1 '/' st '⇓' st'" := (ceval c[1] st st').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Example ceval_example1:'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 2;;
  prefs: []
  type: TYPE_NORMAL
- en: IFB BLe (AId X) (ANum 1)
  prefs: []
  type: TYPE_NORMAL
- en: THEN Y ::= ANum 3
  prefs: []
  type: TYPE_NORMAL
- en: ELSE Z ::= ANum 4
  prefs: []
  type: TYPE_NORMAL
- en: FI)
  prefs: []
  type: TYPE_NORMAL
- en: / empty_state
  prefs: []
  type: TYPE_NORMAL
- en: ⇓ (t_update (t_update empty_state X 2) Z 4).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* We must supply the intermediate state *)
  prefs: []
  type: TYPE_NORMAL
- en: apply E_Seq with (t_update empty_state X 2).
  prefs: []
  type: TYPE_NORMAL
- en: '- (* assignment command *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply E_Ass. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* if command *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply E_IfFalse.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: apply E_Ass. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Example ceval_example2:'
  prefs: []
  type: TYPE_NORMAL
- en: (X ::= ANum 0;; Y ::= ANum 1;; Z ::= ANum 2) / empty_state ⇓
  prefs: []
  type: TYPE_NORMAL
- en: (t_update (t_update (t_update empty_state X 0) Y 1) Z 2).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition pup_to_n : com'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem pup_to_2_ceval :'
  prefs: []
  type: TYPE_NORMAL
- en: pup_to_n / (t_update empty_state X 2) ⇓
  prefs: []
  type: TYPE_NORMAL
- en: t_update (t_update (t_update (t_update (t_update (t_update empty_state
  prefs: []
  type: TYPE_NORMAL
- en: X 2) Y 0) Y 2) X 1) Y 3) X 0.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Determinism of Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changing from a computational to a relational definition of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: evaluation is a good move because it frees us from the artificial
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: requirement that evaluation should be a total function.  But it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'also raises a question: Is the second definition of evaluation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: really a partial function?  Or is it possible that, beginning from
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the same state st, we could evaluate some command c in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: different ways to reach two different output states st' and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: st''?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In fact, this cannot happen: ceval *is* a partial function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Reasoning About Imp Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll get deeper into systematic techniques for reasoning about
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Imp programs in the following chapters, but we can do quite a bit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: just working with the bare definitions.  This section explores
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: some examples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Inverting Heval essentially forces Coq to expand one step of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the ceval computation — in this case revealing that st'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: must be st extended with the new value of X, since plus2
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is an assignment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, recommendedM (XtimesYinZ_spec)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: State and prove a specification of XtimesYinZ.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, recommended (loop_never_stops)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Proceed by induction on the assumed derivation showing that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: loopdef terminates.  Most of the cases are immediately
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: contradictory (and so can be solved in one step with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inversion).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (no_whilesR)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This predicate yields true just on programs that have no while
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: loops.  Using Inductive, write a property no_whilesR such that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: no_whilesR c is provable exactly when c is a program with no
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: while loops.  Then prove its equivalence with no_whiles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 starsM (no_whiles_terminating)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imp programs that don't involve while loops always terminate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: State and prove a theorem no_whiles_terminating that says this.  Use either
    no_whiles or no_whilesR, as you prefer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: (2*3)+(3*(4-2))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 2 3 * 3 4 2 - * +
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[ ]           |    2 3 * 3 4 2 - * +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[2]           |    3 * 3 4 2 - * +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[3, 2]        |    * 3 4 2 - * +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[6]           |    3 4 2 - * +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[3, 6]        |    4 2 - * +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[4, 3, 6]     |    2 - * +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[2, 4, 3, 6]  |    - * +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[2, 3, 6]     |    * +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[6, 6]        |    +'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[12]          |'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive sinstr : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| SPush : nat → sinstr'
  prefs: []
  type: TYPE_NORMAL
- en: '| SLoad : id → sinstr'
  prefs: []
  type: TYPE_NORMAL
- en: '| SPlus : sinstr'
  prefs: []
  type: TYPE_NORMAL
- en: '| SMinus : sinstr'
  prefs: []
  type: TYPE_NORMAL
- en: '| SMult : sinstr.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint s_execute (st : state) (stack : list nat)'
  prefs: []
  type: TYPE_NORMAL
- en: '(prog : list sinstr)'
  prefs: []
  type: TYPE_NORMAL
- en: ': list nat'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example s_execute1 :'
  prefs: []
  type: TYPE_NORMAL
- en: s_execute empty_state []
  prefs: []
  type: TYPE_NORMAL
- en: '[SPush 5; SPush 3; SPush 1; SMinus]'
  prefs: []
  type: TYPE_NORMAL
- en: = [2; 5].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example s_execute2 :'
  prefs: []
  type: TYPE_NORMAL
- en: s_execute (t_update empty_state X 3) [3;4]
  prefs: []
  type: TYPE_NORMAL
- en: '[SPush 4; SLoad X; SMult; SPlus]'
  prefs: []
  type: TYPE_NORMAL
- en: = [15; 4].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Fixpoint s_compile (e : aexp) : list sinstr'
  prefs: []
  type: TYPE_NORMAL
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Example s_compile1 :'
  prefs: []
  type: TYPE_NORMAL
- en: s_compile (AMinus (AId X) (AMult (ANum 2) (AId Y)))
  prefs: []
  type: TYPE_NORMAL
- en: = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem s_compile_correct : ∀(st : state) (e : aexp),'
  prefs: []
  type: TYPE_NORMAL
- en: s_execute st [] (s_compile e) = [ aeval st e ].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Module BreakImp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive com : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| CSkip : com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CBreak : com               (* <-- new *)'
  prefs: []
  type: TYPE_NORMAL
- en: '| CAss : id → aexp → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CSeq : com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CIf : bexp → com → com → com'
  prefs: []
  type: TYPE_NORMAL
- en: '| CWhile : bexp → com → com.'
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'SKIP'" :=
  prefs: []
  type: TYPE_NORMAL
- en: CSkip.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'BREAK'" :=
  prefs: []
  type: TYPE_NORMAL
- en: CBreak.
  prefs: []
  type: TYPE_NORMAL
- en: Notation "x '::=' a" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CAss x a) (at level 60).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "c1 ;; c2" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CWhile b c) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
  prefs: []
  type: TYPE_NORMAL
- en: (CIf c[1] c[2] c[3]) (at level 80, right associativity).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: X ::= 0;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: WHILE 0 ≠ Y DO
  prefs: []
  type: TYPE_NORMAL
- en: WHILE TRUE DO
  prefs: []
  type: TYPE_NORMAL
- en: BREAK
  prefs: []
  type: TYPE_NORMAL
- en: END;;
  prefs: []
  type: TYPE_NORMAL
- en: X ::= 1;;
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1
  prefs: []
  type: TYPE_NORMAL
- en: END
  prefs: []
  type: TYPE_NORMAL
- en: '... the value of X should be 1, and not 0.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One way of expressing this behavior is to add another parameter to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the evaluation relation that specifies whether evaluation of a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'command executes a BREAK statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Intuitively, c / st ⇓ s / st' means that, if c is started in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: state st, then it terminates in state st' and either signals
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that the innermost surrounding loop (or the whole program) should
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: exit immediately (s = SBreak) or that execution should continue
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: normally (s = SContinue).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The definition of the "c / st ⇓ s / st'" relation is very
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: similar to the one we gave above for the regular evaluation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation (c / st ⇓ st') — we just need to handle the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'termination signals appropriately:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the command is SKIP, then the state doesn't change and execution of any enclosing
    loop can continue normally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command is BREAK, the state stays unchanged but we signal a SBreak.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command is an assignment, then we update the binding for that variable
    in the state accordingly and signal that execution can continue normally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command is of the form IFB b THEN c[1] ELSE c[2] FI, then the state is
    updated as in the original semantics of Imp, except that we also propagate the
    signal from the execution of whichever branch was taken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command is a sequence c[1] ;; c[2], we first execute c[1]. If this yields
    a SBreak, we skip the execution of c[2] and propagate the SBreak signal to the
    surrounding context; the resulting state is the same as the one obtained by executing
    c[1] alone. Otherwise, we execute c[2] on the state obtained after executing c[1],
    and propagate the signal generated there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, for a loop of the form WHILE b DO c END, the semantics is almost the
    same as before. The only difference is that, when b evaluates to true, we execute
    c and check the signal that it raises. If that signal is SContinue, then the execution
    proceeds as in the original semantics. Otherwise, we stop the execution of the
    loop, and the resulting state is the same as the one resulting from the execution
    of the current iteration. In either case, since BREAK only terminates the innermost
    loop, WHILE signals SContinue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the above description, complete the definition of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ceval relation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Now prove the following properties of your definition of ceval:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced, optional (while_break_true)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 stars, advanced, optional (ceval_deterministic)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 4 stars, optional (add_for_loop)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add C-style for loops to the language of commands, update the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ceval definition to define the semantics of for loops, and add
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cases for for loops as needed so that all the proofs in this file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are accepted by Coq.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A for loop should be parameterized by (a) a statement executed
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: initially, (b) a test that is run on each iteration of the loop to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: determine whether the loop should continue, (c) a statement
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: executed at the end of each loop iteration, and (d) a statement
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that makes up the body of the loop.  (You don't need to worry
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about making up a concrete Notation for for loops, but feel free
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to play with this too if you like.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
