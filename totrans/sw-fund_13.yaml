- en: ImpSimple Imperative Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ImpSimple命令式程序
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Z ::= X;;
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= X;;
- en: Y ::= 1;;
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= 1;;
- en: WHILE not (Z = 0) DO
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当WHILE not (Z = 0) DO时
- en: Y ::= Y * Z;;
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= Y * Z;;
- en: Z ::= Z - 1
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= Z - 1
- en: END
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 结束
- en: This chapter looks at how to define the *syntax* and *semantics*
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章将讨论如何定义*语法*和*语义*
- en: of Imp; the chapters that follow develop a theory of *program equivalence* and
    introduce *Hoare Logic*, a widely used logic for
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 的Imp；接下来的章节将发展一个*程序等价*理论，并引入*霍尔逻辑*，这是一个广泛使用的逻辑
- en: reasoning about imperative programs.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 推理关于命令式程序。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Arithmetic and Boolean Expressions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术和布尔表达式
- en: 'We''ll present Imp in three parts: first a core language of'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将以三部分呈现Imp：首先是一个核心语言
- en: '*arithmetic and boolean expressions*, then an extension of these'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*算术和布尔表达式*，然后是这些的扩展'
- en: expressions with *variables*, and finally a language of *commands*
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 带有*变量*的表达式，最后是*命令*的语言
- en: including assignment, conditions, sequencing, and loops.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包括赋值、条件、顺序和循环。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Module AExp.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 模块AExp。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inductive aexp : Type :='
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义aexp：类型 :=
- en: '| ANum : nat → aexp'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '| ANum : nat → aexp'
- en: '| APlus : aexp → aexp → aexp'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '| APlus : aexp → aexp → aexp'
- en: '| AMinus : aexp → aexp → aexp'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '| AMinus : aexp → aexp → aexp'
- en: '| AMult : aexp → aexp → aexp.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '| AMult : aexp → aexp → aexp.'
- en: 'Inductive bexp : Type :='
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义bexp：类型 :=
- en: '| BTrue : bexp'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '| BTrue : bexp'
- en: '| BFalse : bexp'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '| BFalse : bexp'
- en: '| BEq : aexp → aexp → bexp'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '| BEq : aexp → aexp → bexp'
- en: '| BLe : aexp → aexp → bexp'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '| BLe : aexp → aexp → bexp'
- en: '| BNot : bexp → bexp'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '| BNot : bexp → bexp'
- en: '| BAnd : bexp → bexp → bexp.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '| BAnd : bexp → bexp → bexp.'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: APlus (ANum 1) (AMult (ANum 2) (ANum 3)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: APlus (ANum 1) (AMult (ANum 2) (ANum 3)).
- en: The optional chapter [ImpParser](ImpParser.html) develops a simple
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选章节[ImpParser](ImpParser.html)开发了一个简单的
- en: implementation of a lexical analyzer and parser that can perform
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现一个可以执行的词法分析器和解析器
- en: this translation.  You do *not* need to understand that chapter to
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个翻译。你*不*需要理解那一章节
- en: understand this one, but if you haven't taken a course where these
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理解这个，但如果您还没有参加过这些课程
- en: techniques are covered (e.g., a compilers course) you may want to
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要覆盖的技术（例如，编译器课程），您可能希望
- en: skim it.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 略读它。
- en: For comparison, here's a conventional BNF (Backus-Naur Form)
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为比较，这里是一个传统的BNF（巴科斯-瑙尔形式）
- en: 'grammar defining the same abstract syntax:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义相同抽象语法的语法：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Evaluation
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估
- en: '*Evaluating* an arithmetic expression produces a number.'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*评估*一个算术表达式会产生一个数字。'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly, evaluating a boolean expression yields a boolean.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，评估布尔表达式会产生一个布尔值。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Optimization
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: We haven't defined very much yet, but we can already get
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还没有定义很多，但我们已经可以得到
- en: some mileage out of the definitions.  Suppose we define a function
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些定义。假设我们定义一个函数
- en: that takes an arithmetic expression and slightly simplifies it,
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接受一个算术表达式并稍微简化它，
- en: changing every occurrence of 0+e (i.e., (APlus (ANum 0) e)
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 改变每个0+e的出现（即，(APlus (ANum 0) e)
- en: into just e.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只需e。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To make sure our optimization is doing the right thing we
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保我们的优化是正确的，我们
- en: can test it on some examples and see if the output looks OK.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以在一些示例上测试它，看看输出是否正常。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But if we want to be sure the optimization is correct —
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但如果我们想确保优化是正确的 —
- en: i.e., that evaluating an optimized expression gives the same
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即，评估优化后的表达式会产生相同的
- en: result as the original — we should prove it.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果与原始结果相同 — 我们应该证明它。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Coq Automation
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Coq自动化
- en: The amount of repetition in this last proof is a little
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这最后一个证明中的重复量���点
- en: annoying.  And if either the language of arithmetic expressions or
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 恼人。如果算术表达式的语言或
- en: the optimization being proved sound were significantly more
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正在被证明为正确的优化显着更多
- en: complex, it would start to be a real problem.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 复杂，这将开始成为一个真正的问题。
- en: So far, we've been doing all our proofs using just a small handful
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用只有一小撮的证明
- en: of Coq's tactics and completely ignoring its powerful facilities
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq的策略，完全忽略其强大的功能
- en: for constructing parts of proofs automatically.  This section
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于自动构建证明的部分。本节
- en: introduces some of these facilities, and we will see more over the
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 介绍了一些这些设施，我们将在接下来看到更多
- en: next several chapters.  Getting used to them will take some
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来的几章。习惯于它们将需要一些
- en: energy — Coq's automation is a power tool — but it will allow us
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 能量 — Coq的自动化是一个强大的工具 — 但它将允许我们
- en: to scale up our efforts to more complex definitions and more
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展我们的努力到更复杂的定义和更多
- en: interesting properties without becoming overwhelmed by boring,
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有趣的属性而不被无聊的细节所淹没，
- en: repetitive, low-level details.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重复的，低级的细节。
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The try Tactical
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试策略
- en: If T is a tactic, then try T is a tactic that is just like T
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果T是一个策略，那么try T是一个与T完全相同的策略
- en: except that, if T fails, try T *successfully* does nothing at
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除非 T 失败，否则尝试 T *成功* 什么也不做。
- en: all (instead of failing).
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 全部（而不是失败）。
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is no real reason to use try in completely manual
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没有真正的理由在完全手动的情况下使用 try
- en: proofs like these, but it is very useful for doing automated
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样的证明，但它在进行自动化时非常有用
- en: proofs in conjunction with the ; tactical, which we show
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明与; 策略一起使用的证明
- en: next.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lemma foo : ∀n, leb 0 n = true.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 foo：∀n，leb 0 n = true。
- en: Proof.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 引入。
- en: destruct n.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 n。
- en: (* Leaves two subgoals, which are discharged identically...  *)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: （* 留下两个子目标，它们以相同的方式消除... *）
- en: '- (* n=0 *) simpl. reflexivity.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* n=0 *）简化。 反射性。'
- en: '- (* n=Sn'' *) simpl. reflexivity.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* n=Sn'' *）简化。 反射性。'
- en: Qed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lemma foo'' : ∀n, leb 0 n = true.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 foo'：∀n，leb 0 n = true。
- en: Proof.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 引入。
- en: (* destruct the current goal *)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: （* 分解当前目标 *）
- en: destruct n;
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 n;
- en: (* then simpl each resulting subgoal *)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: （* 然后简化每个产生的子目标 *）
- en: simpl;
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 简化;
- en: (* and do reflexivity on each resulting subgoal *)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: （* 并对每个产生的子目标进行反射性操作 *）
- en: reflexivity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 反射性。
- en: Qed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Theorem optimize_0plus_sound'': ∀a,'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 optimize_0plus_sound'：∀a，
- en: aeval (optimize_0plus a) = aeval a.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: aeval（optimize_0plus a）= aeval a。
- en: Proof.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: intros a.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 a。
- en: induction a;
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 a;
- en: (* Most cases follow directly by the IH... *)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: （* 大多数情况都可以直接由IH... *）
- en: try (simpl; rewrite IHa1; rewrite IHa2; reflexivity).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（简化; 重写 IHa1; 重写 IHa2; 反射性）。
- en: (* ... but the remaining cases -- ANum and APlus --        are different: *)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: （* ... 但剩下的情况 -- ANum 和 APlus --        是不同的： *）
- en: '- (* ANum *) reflexivity.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* ANum *）反射性。'
- en: '- (* APlus *)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* APlus *）'
- en: destruct a[1];
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 分解 a[1];
- en: (* Again, most cases follow directly by the IH: *)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，大多数情况都可以直接通过 IH 解决：
- en: try (simpl; simpl in IHa1; rewrite IHa1;
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试（简化; 简化在 IHa1 中; 重写 IHa1;
- en: rewrite IHa2; reflexivity).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 IHa2; 反射性）。
- en: (* The interesting case, on which the try...        does nothing, is when e[1]
    = ANum n. In this        case, we have to destruct n (to see whether        the optimization applies) and rewrite with the
           induction hypothesis. *)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: （* 有趣的情况，在这种情况下，尝试...        什么也不做，是当 e[1] = ANum n 时。 在这种情况下，我们必须分解 n （看看是否 
           应用了优化）并使用归纳假设进行重写。 *）
- en: + (* a[1] = ANum n *) destruct n;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: + （* a[1] = ANum n *）分解 n;
- en: simpl; rewrite IHa2; reflexivity. Qed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 简化; 重写 IHa2; 反射性。 结束。
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: aeval (optimize_0plus a) = aeval a.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: aeval（optimize_0plus a）= aeval a。
- en: '*Proof*: By induction on a.  Most cases follow directly from the'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*证明*：通过对 a 进行归纳。 大多数情况直接由'
- en: 'IH.  The remaining cases are as follows:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: IH。 剩余的情况如下：
- en: Suppose a = ANum n for some n. We must show
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 a = ANum n 对某个 n 成立。 我们必须展示
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Suppose a = APlus a[1] a[2] for some a[1] and a[2]. We must show
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设 a = APlus a[1] a[2] 对某些 a[1] 和 a[2] 成立。 我们必须展示
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: optimize_0plus (APlus a[1] a[2]) = optimize_0plus a[2]
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: optimize_0plus（APlus a[1] a[2]）= optimize_0plus a[2]
- en: and the IH for a[2] is exactly what we need. On the other hand, if n = S n'
    for some n', then again optimize_0plus simply calls itself recursively, and the
    result follows from the IH. ☐
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 a[2] 的 IH 恰好是我们所需的。 另一方面，如果 n = S n' 对某个 n' 成立，那么 optimize_0plus 再次简单地递归调用自身，结果就是由
    IH 得出的。 ☐
- en: '[PRE19]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, this proof can still be improved: the first case (for'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，这个证明仍然可以改进：第一个情况（对于
- en: a = ANum n) is very trivial — even more trivial than the cases
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a = ANum n）非常微不足道 —— 甚至比我们选择的案例
- en: that we said simply followed from the IH — yet we have chosen to
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们简单地说是从 IH 中简单地得出的 —— 然而我们选择了
- en: write it out in full.  It would be better and clearer to drop it
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整地写出它会更好更清晰。最好是将其删除
- en: and just say, at the top, "Most cases are either immediate or
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且只需在顶部说，“大多数情况要么是即时的要么是
- en: direct from the IH.  The only interesting case is the one for
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直接来自 IH。 唯一有趣的情况是
- en: APlus..."  We can make the same improvement in our formal proof
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: APlus..." 我们可以在我们的形式证明中做同样的改进
- en: 'too.  Here''s how it looks:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也。 这是它的样子：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The ; Tactical (General Form)
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ; 策略（一般形式）
- en: The ; tactical also has a more general form than the simple
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该; 策略也比简单的形式更加一般化
- en: T;T' we've seen above.  If T, T[1], ..., Tn are tactics,
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: T;T' 上面我们已经见过。 如果 T、T[1]、...、Tn 是策略，
- en: then
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: T; [T' | T' | ... | T']
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: T； [T' | T' | ... | T']
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Theorem In[10] : In 10 [1;2;3;4;5;6;7;8;9;10].'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 In[10]：在[1;2;3;4;5;6;7;8;9;10]中的10。
- en: Proof.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: repeat (try (left; reflexivity); right).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重复（尝试（左; 反射性）; 右）。
- en: Qed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Theorem In[10]'' : In 10 [1;2;3;4;5;6;7;8;9;10].'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 In[10]'：在[1;2;3;4;5;6;7;8;9;10]中的10。
- en: Proof.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: repeat (left; reflexivity).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重复（左; 反射性）。
- en: repeat (right; try (left; reflexivity)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重复（右; 尝试（左; 反射性））。
- en: Qed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结束。
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Fixpoint optimize_0plus_b (b : bexp) : bexp'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 定点 optimize_0plus_b（b：bexp）：bexp
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: （* 用你的定义替换此行为":= _your_definition_ ." *）。承认。
- en: 'Theorem optimize_0plus_b_sound : ∀b,'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 optimize_0plus_b_sound：∀b，
- en: beval (optimize_0plus_b b) = beval b.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: beval（optimize_0plus_b b）= beval b。
- en: Proof.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Defining New Tactic Notations
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coq also provides several ways of "programming" tactic scripts.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Tactic Notation idiom illustrated below gives a handy way to define "shorthand
    tactics" that bundle several tactics into a single command.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more sophisticated programming, Coq offers a built-in programming language
    called Ltac with primitives that can examine and modify the proof state. The details
    are a bit too complicated to get into here (and it is generally agreed that Ltac
    is not the most beautiful part of Coq's design!), but they can be found in the
    reference manual and other books on Coq, and there are many examples of Ltac definitions
    in the Coq standard library that you can use as examples.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also an OCaml API, which can be used to build tactics that access Coq's
    internal structures at a lower level, but this is seldom worth the trouble for
    ordinary Coq users.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tactic Notation mechanism is the easiest to come to grips with,
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and it offers plenty of power for many purposes.  Here's an example.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This defines a new tactical called simpl_and_try that takes one
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic c as an argument and is defined to be equivalent to the
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic simpl; try c.  Now writing "simpl_and_try reflexivity."
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in a proof will be the same as writing "simpl; try reflexivity."
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Require Import Coq.omega.Omega.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Example silly_presburger_example : ∀m n o p,'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: m + n ≤ n + o ∧ o + 3 = p + 3 →
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: m ≤ p.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: intros. omega.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Evaluation as a Relation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have presented aeval and beval as functions defined by
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Fixpoints.  Another way to think about evaluation — one that we
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: will see is often more flexible — is as a *relation* between
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: expressions and their values.  This leads naturally to Inductive
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definitions like the following one for arithmetic expressions...
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It will be convenient to have an infix notation for
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: aevalR.  We'll write e ⇓ n to mean that arithmetic expression
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e evaluates to value n.  (This notation is one place where the
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: limitation to ASCII symbols becomes a little bothersome.  The
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: standard notation for the evaluation relation is a double
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: down-arrow.  We'll typeset it like this in the HTML version of the
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: notes and use a double slash as the closest approximation in .v
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: files.)
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In fact, Coq provides a way to use this notation in the
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition of aevalR itself.  This reduces confusion by avoiding
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: situations where we're working on a proof involving statements in
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the form e ⇓ n but we have to refer back to a definition
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: written using the form aevalR e n.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We do this by first "reserving" the notation, then giving the
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition together with a declaration of what the notation
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: means.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Inference Rule Notation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In informal discussions, it is convenient to write the rules for
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: aevalR and similar relations in the more readable graphical form
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of *inference rules*, where the premises above the line justify
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the conclusion below the line (we have already seen them in the
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Prop](Prop.html) chapter).'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, the constructor E_APlus...
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Equivalence of the Definitions
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义的等价性
- en: It is straightforward to prove that the relational and functional
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明关系和功能性
- en: 'definitions of evaluation agree:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 评估定义一致：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can make the proof quite a bit shorter by making more
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过更多地使用
- en: use of tacticals.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用战术。
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Exercise: 3 stars (bevalR)'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星（bevalR）
- en: Write a relation bevalR in the same style as
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以与bevalR相同的风格编写一个关系
- en: aevalR, and prove that it is equivalent to beval.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: aevalR，并证明它等效于beval。
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ☐
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Computational vs. Relational Definitions
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算与关系定义
- en: For the definitions of evaluation for arithmetic and boolean
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于算术和布尔值的评估定义
- en: expressions, the choice of whether to use functional or relational
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达式，选择使用函数式还是关系式
- en: 'definitions is mainly a matter of taste: either way works.'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义主要是品味问题：任何一种方式都可以。
- en: However, there are circumstances where relational definitions of
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，关系定义的
- en: evaluation work much better than functional ones.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 评估工作比功能性更好。
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For example, suppose that we wanted to extend the arithmetic
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，假设我们想要扩展算术
- en: 'operations by considering also a division operation:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过考虑除法运算来扩展操作：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Extending the definition of aeval to handle this new operation
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展aeval的定义以处理这个新操作
- en: would not be straightforward (what should we return as the result
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将不是简单的（我们应该返回什么作为结果
- en: of ADiv (ANum 5) (ANum 0)?).  But extending aevalR is
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: of ADiv（ANum 5）（ANum 0）？）。但扩展aevalR是
- en: straightforward.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直接的。
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Suppose, instead, that we want to extend the arithmetic operations
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设，相反，我们想要扩展算术运算
- en: by a nondeterministic number generator any that, when evaluated,
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由一个非确定性数生成器生成，当评估时，
- en: may yield any number.  (Note that this is not the same as making a
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能产生任何数字。（请注意，这与制作
- en: '*probabilistic* choice among all possible numbers — we''re not'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*概率*在所有可能的数字中进行选择——我们不是'
- en: specifying any particular distribution of results, but just saying
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指定任何特定结果分布，而只是说
- en: what results are *possible*.)
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 什么结果是*可能的*。）
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Again, extending aeval would be tricky, since now evaluation is
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，扩展aeval将会很棘手，因为现在评估是
- en: '*not* a deterministic function from expressions to numbers, but'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*不*是从表达式到数字的确定性函数，而是'
- en: 'extending aevalR is no problem:'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展aevalR没有问题：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At this point you maybe wondering: which style should I use by'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此时，您可能会想：我应该使用哪种风格
- en: default?  The examples above show that relational definitions are
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认值？上面的例子表明关系定义是
- en: fundamentally more powerful than functional ones.  For situations
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基本上比功能性更强大。对于情况
- en: like these, where the thing being defined is not easy to express
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像这样的情况，其中定义的事物不容易表达
- en: as a function, or indeed where it is *not* a function, there is no
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为一个函数，或者确实不是一个函数，没有
- en: choice.  But what about when both styles are workable?
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择。但是当两种风格都可行时呢？
- en: One point in favor of relational definitions is that some people
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 支持关系定义的一个观点是，有些人
- en: feel they are more elegant and easier to understand.  Another is
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 感觉它们更加优雅和易于理解。另一个是
- en: that Coq automatically generates nice inversion and induction
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq自动生成漂亮的反演和归纳
- en: principles from Inductive definitions.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从归纳定义中的原则。
- en: On the other hand, functional definitions can often be more
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，功能性定义通常更
- en: 'convenient:'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方便：
- en: Functions are by definition deterministic and defined on all arguments; for
    a relation we have to show these properties explicitly if we need them.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数根据定义是确定性的，并且对所有参数进行定义；对于关系，如果需要这些属性，我们必须明确显示这些属性。
- en: With functions we can also take advantage of Coq's computation mechanism to
    simplify expressions during proofs.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数，我们还可以利用Coq的计算机制制简化证明过程中的表达式。
- en: Furthermore, functions can be directly "extracted" to executable
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，函数可以直接“提取”为可执行
- en: code in OCaml or Haskell.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在OCaml或Haskell中的代码。
- en: Ultimately, the choice often comes down to either the specifics of
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终，选��通常取决于具体情况。
- en: a particular situation or simply a question of taste.  Indeed, in
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个特定的情况或仅仅是品味问题。实际上，在
- en: large Coq developments it is common to see a definition given in
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大型Coq开发中，通常会看到一个定义以
- en: '*both* functional and relational styles, plus a lemma stating that'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*功能*和关系风格，再加上一个引理说明'
- en: the two coincide, allowing further proofs to switch from one point
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两者重合，允许进一步的证明从一个观点转换
- en: of view to the other at will.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从一个视角到另一个视角。
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: States
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: Since we'll want to look variables up to find out their current
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们将想要查找变量以了解它们当前的
- en: values, we'll reuse the type id from the [Maps](Maps.html) chapter for the
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值，我们将从 [Maps](Maps.html) 章节中重用类型 id
- en: type of variables in Imp.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Imp 中变量的类型。
- en: A *machine state* (or just *state*) represents the current values
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*机器状态*（或者只是 *状态*）表示当前值'
- en: of *all* variables at some point in the execution of a program.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在程序执行的某个时刻获取所有变量的值。
- en: For simplicity, we assume that the state is defined for
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为简单起见，我们假设状态已经定义好了
- en: '*all* variables, even though any given program is only going to'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*所有* 变量，尽管任何给定的程序只会'
- en: mention a finite number of them.  The state captures all of the
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提到它们的有限数量。状态捕获了所有
- en: information stored in memory.  For Imp programs, because each
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储在内存中的信息。对于 Imp 程序，因为每个
- en: variable stores a natural number, we can represent the state as a
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量存储一个自然数，我们可以将状态表示为
- en: mapping from identifiers to nat.  For more complex programming
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从标识符到自然数的映射。���于更复杂的编程
- en: languages, the state might have more structure.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语言，状态可能具有更多结构。
- en: '[PRE43]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Syntax
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法
- en: We can add variables to the arithmetic expressions we had before by
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过在之前的算术表达式中添加变量来
- en: 'simply adding one more constructor:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单地添加一个构造函数：
- en: '[PRE44]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Defining a few variable names as notational shorthands will make
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将一些变量名定义为符号缩写将使
- en: 'examples easier to read:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例子更容易阅读：
- en: '[PRE45]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: (This convention for naming program variables (X, Y,
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （这种命名程序变量（X、Y、
- en: Z) clashes a bit with our earlier use of uppercase letters for
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Z) 与我们之前使用大写字母表示
- en: types.  Since we're not using polymorphism heavily in the chapters
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型。由于我们在章节中没有大量使用多态性
- en: devoped to Imp, this overloading should not cause confusion.)
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 开发到 Imp，这种重载不应该引起混淆。）
- en: The definition of bexps is unchanged (except for using the new
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: bexps 的定义没有改变（除了使用新的
- en: 'aexps):'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: aexps)：
- en: '[PRE46]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Evaluation
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估
- en: The arith and boolean evaluators are extended to handle
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 算术和布尔表达式的评估器被扩展以处理
- en: variables in the obvious way, taking a state as an extra
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量的约定方式，以一个状态作为额外参数
- en: 'argument:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数：
- en: '[PRE47]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Commands
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: Now we are ready define the syntax and behavior of Imp
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们准备定义 Imp 的语法和行为
- en: '*commands* (sometimes called *statements*).'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*命令*（有时称为 *语句*）有点冲突。'
- en: '[PRE48]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: c ::= SKIP | x ::= a | c ;; c | IFB b THEN c ELSE c FI
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: c ::= SKIP | x ::= a | c ;; c | IFB b THEN c ELSE c FI
- en: '| WHILE b DO c END'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '| WHILE b DO c END'
- en: 'For example, here''s factorial in Imp:'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在 Imp 中这是阶乘：
- en: '[PRE49]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inductive com : Type :='
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳定义 com : Type :='
- en: '| CSkip : com'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSkip : com'
- en: '| CAss : id → aexp → com'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '| CAss : id → aexp → com'
- en: '| CSeq : com → com → com'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSeq : com → com → com'
- en: '| CIf : bexp → com → com → com'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '| CIf : bexp → com → com → com'
- en: '| CWhile : bexp → com → com.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '| CWhile : bexp → com → com'
- en: '[PRE50]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notation "'SKIP'" :=
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "'SKIP'" :=
- en: CSkip.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: CSkip
- en: Notation "x '::=' a" :=
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "x '::=' a" :=
- en: (CAss x a) (at level 60).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: （CAss x a）（在级别 60）。
- en: Notation "c1 ;; c2" :=
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "c1 ;; c2" :=
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: (CSeq c[1] c[2]) (at level 80, right associativity)
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "'WHILE' b 'DO' c 'END'" :=
- en: (CWhile b c) (at level 80, right associativity).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: (CWhile b c) (at level 80, right associativity)
- en: Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
- en: (CIf c[1] c[2] c[3]) (at level 80, right associativity).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: (CIf c[1] c[2] c[3]) (at level 80, right associativity)
- en: '[PRE51]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Definition fact_in_coq : com :='
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'Definition fact_in_coq : com :='
- en: Z ::= AId X;;
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= AId X;;
- en: Y ::= ANum 1;;
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= ANum 1;;
- en: WHILE BNot (BEq (AId Z) (ANum 0)) DO
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE BNot (BEq (AId Z) (ANum 0)) DO
- en: Y ::= AMult (AId Y) (AId Z);;
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Y ::= AMult (AId Y) (AId Z);;
- en: Z ::= AMinus (AId Z) (ANum 1)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= AMinus (AId Z) (ANum 1)
- en: END.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: '[PRE52]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Definition plus2 : com :='
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'Definition plus2 : com :='
- en: X ::= (APlus (AId X) (ANum 2)).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= (APlus (AId X) (ANum 2))
- en: 'Definition XtimesYinZ : com :='
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'Definition XtimesYinZ : com :='
- en: Z ::= (AMult (AId X) (AId Y)).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= (AMult (AId X) (AId Y))
- en: 'Definition subtract_slowly_body : com :='
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 subtract_slowly_body : com :='
- en: Z ::= AMinus (AId Z) (ANum 1) ;;
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= AMinus (AId Z) (ANum 1) ;;
- en: X ::= AMinus (AId X) (ANum 1).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= AMinus (AId X) (ANum 1)
- en: '[PRE53]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Definition subtract_slowly : com :='
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'Definition subtract_slowly : com :='
- en: WHILE BNot (BEq (AId X) (ANum 0)) DO
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE BNot (BEq (AId X) (ANum 0)) DO
- en: subtract_slowly_body
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: subtract_slowly_body
- en: END.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: 'Definition subtract_3_from_5_slowly : com :='
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 subtract_3_from_5_slowly : com :='
- en: X ::= ANum 3 ;;
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: X ::= ANum 3 ;;
- en: Z ::= ANum 5 ;;
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Z ::= ANum 5 ;;
- en: subtract_slowly.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: subtract_slowly
- en: '[PRE54]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Definition loop : com :='
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 loop : com :='
- en: WHILE BTrue DO
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: WHILE BTrue DO
- en: SKIP
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP
- en: END.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: END
- en: '[PRE55]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Evaluation as a Function (Failed Attempt)
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为一个函数的评估（失败的尝试）
- en: Here's an attempt at defining an evaluation function for commands,
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是为命令定义评估函数的尝试，
- en: omitting the WHILE case.
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 省略 WHILE 情况。
- en: '[PRE56]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In a traditional functional programming language like OCaml or
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在传统的函数式编程语言如 OCaml 或
- en: 'Haskell we could add the WHILE case as follows:'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Haskell 中我们可以添加 WHILE 情况如下：
- en: '[PRE57]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Coq doesn''t accept such a definition ("Error: Cannot guess'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Coq 不接受这样的定义（"错误：无法猜测
- en: decreasing argument of fix") because the function we want to
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修复 fix 的递减参数")，因为我们想要的函数
- en: define is not guaranteed to terminate. Indeed, it *doesn't* always
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义并不保证终止。实际上，它*并不*总是
- en: 'terminate: for example, the full version of the ceval_fun'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 终止：例如，ceval_fun 的完整版本
- en: function applied to the loop program above would never
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用于上述循环程序的函数永远不会
- en: terminate. Since Coq is not just a functional programming
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 终止。由于 Coq 不仅仅是一个函数式编程
- en: language but also a consistent logic, any potentially
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语言，而且是一致的逻辑，任何潜在的
- en: non-terminating function needs to be rejected. Here is
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非终止函数需要被拒绝。这里是
- en: an (invalid!) program showing what would go wrong if Coq
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个（无效的！）程序展示了如果 Coq 出了什么问题
- en: 'allowed non-terminating recursive functions:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许非终止递归函数：
- en: '[PRE58]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That is, propositions like False would become provable
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也就是说，像 False 这样的命题将变得可证明
- en: (loop_false 0 would be a proof of False), which
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (loop_false 0 would be a proof of False)，这
- en: would be a disaster for Coq's logical consistency.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对 Coq 的逻辑一致性将是一场灾难。
- en: Thus, because it doesn't terminate on all inputs,
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，因为它不会在所有输入上终止，
- en: of ceval_fun cannot be written in Coq — at least not without
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ceval_fun 的定义不能在 Coq 中写出 — 至少不能没有
- en: additional tricks and workarounds (see chapter [ImpCEvalFun](ImpCEvalFun.html)
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他技巧和解决方法（参见章节 [ImpCEvalFun](ImpCEvalFun.html)
- en: if you're curious about what those might be).
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你对这些感兴趣的话）。
- en: '[PRE59]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Reserved Notation "c1 '/' st '⇓' st'"
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 保留记号 "c1 '/' st '⇓' st'"
- en: (at level 40, st at level 39).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: （在第 40 级，st 在第 39 级）。
- en: 'Inductive ceval : com → state → state → Prop :='
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义 ceval：com → state → state → Prop :=
- en: '| E_Skip : ∀st,'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Skip : ∀st，'
- en: SKIP / st ⇓ st
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: SKIP / st ⇓ st
- en: '| E_Ass  : ∀st a[1] n x,'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Ass  : ∀st a[1] n x，'
- en: aeval st a[1] = n →
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: aeval st a[1] = n →
- en: (x ::= a[1]) / st ⇓ (t_update st x n)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: (x ::= a[1]) / st ⇓ (t_update st x n)
- en: '| E_Seq : ∀c[1] c[2] st st'' st'''','
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_Seq : ∀c[1] c[2] st st'' st'''','
- en: c[1] / st  ⇓ st' →
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st  ⇓ st' →
- en: c[2] / st' ⇓ st'' →
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / st' ⇓ st'' →
- en: (c[1] ;; c[2]) / st ⇓ st''
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: (c[1] ;; c[2]) / st ⇓ st''
- en: '| E_IfTrue : ∀st st'' b c[1] c[2],'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_IfTrue : ∀st st'' b c[1] c[2]，'
- en: beval st b = true →
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b = true →
- en: c[1] / st ⇓ st' →
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: c[1] / st ⇓ st' →
- en: (IFB b THEN c[1] ELSE c[2] FI) / st ⇓ st'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b THEN c[1] ELSE c[2] FI) / st ⇓ st'
- en: '| E_IfFalse : ∀st st'' b c[1] c[2],'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_IfFalse : ∀st st'' b c[1] c[2],'
- en: beval st b = false →
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b = false →
- en: c[2] / st ⇓ st' →
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: c[2] / st ⇓ st' →
- en: (IFB b THEN c[1] ELSE c[2] FI) / st ⇓ st'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: (IFB b THEN c[1] ELSE c[2] FI) / st ⇓ st'
- en: '| E_WhileEnd : ∀b st c,'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_WhileEnd : ∀b st c，'
- en: beval st b = false →
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b = false →
- en: (WHILE b DO c END) / st ⇓ st
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b DO c END) / st ⇓ st
- en: '| E_WhileLoop : ∀st st'' st'''' b c,'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '| E_WhileLoop : ∀st st'' st'''' b c，'
- en: beval st b = true →
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: beval st b = true →
- en: c / st ⇓ st' →
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: c / st ⇓ st' →
- en: (WHILE b DO c END) / st' ⇓ st'' →
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b DO c END) / st' ⇓ st'' →
- en: (WHILE b DO c END) / st ⇓ st''
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: (WHILE b DO c END) / st ⇓ st''
- en: where "c1 '/' st '⇓' st'" := (ceval c[1] st st').
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 "c1 '/' st '⇓' st'" := (ceval c[1] st st')。
- en: '[PRE60]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Example ceval_example1:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 例子 ceval_example1：
- en: (X ::= ANum 2;;
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= ANum 2;;
- en: IFB BLe (AId X) (ANum 1)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: IFB BLe (AId X) (ANum 1)
- en: THEN Y ::= ANum 3
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Y ::= ANum 3
- en: ELSE Z ::= ANum 4
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ELSE Z ::= ANum 4
- en: FI)
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: FI）
- en: / empty_state
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: / empty_state
- en: ⇓ (t_update (t_update empty_state X 2) Z 4).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ⇓ (t_update (t_update empty_state X 2) Z 4)。
- en: Proof.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* We must supply the intermediate state *)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: (* 我们必须提供中间状态 *)
- en: apply E_Seq with (t_update empty_state X 2).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_Seq with (t_update empty_state X 2)。
- en: '- (* assignment command *)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* 赋值命令 *)'
- en: apply E_Ass. reflexivity.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_Ass。反射性。
- en: '- (* if command *)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* if 命令 *)'
- en: apply E_IfFalse.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_IfFalse。
- en: reflexivity.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 反射性。
- en: apply E_Ass. reflexivity. Qed.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 E_Ass。反射性。证毕。
- en: '[PRE61]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Example ceval_example2:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 例子 ceval_example2：
- en: (X ::= ANum 0;; Y ::= ANum 1;; Z ::= ANum 2) / empty_state ⇓
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: (X ::= ANum 0;; Y ::= ANum 1;; Z ::= ANum 2) / empty_state ⇓
- en: (t_update (t_update (t_update empty_state X 0) Y 1) Z 2).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: (t_update (t_update (t_update empty_state X 0) Y 1) Z 2)。
- en: Proof.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写内容 *) 已承认。
- en: '[PRE62]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Definition pup_to_n : com'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 pup_to_n：com
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用 ":= _your_definition_ ." 替换这一行 *). 已承认。
- en: 'Theorem pup_to_2_ceval :'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 pup_to_2_ceval：
- en: pup_to_n / (t_update empty_state X 2) ⇓
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: pup_to_n / (t_update empty_state X 2) ⇓
- en: t_update (t_update (t_update (t_update (t_update (t_update empty_state
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: t_update (t_update (t_update (t_update (t_update (t_update empty_state
- en: X 2) Y 0) Y 2) X 1) Y 3) X 0.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: X 2) Y 0) Y 2) X 1) Y 3) X 0。
- en: Proof.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在这里填写内容 *) 已承认。
- en: '[PRE63]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Determinism of Evaluation
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估的确定性
- en: Changing from a computational to a relational definition of
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从计算定义转变为关系定义
- en: evaluation is a good move because it frees us from the artificial
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 评估是一个��的举措，因为它使我们摆脱了人为的
- en: requirement that evaluation should be a total function.  But it
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 评估应该是一个全函数的要求。但是它
- en: 'also raises a question: Is the second definition of evaluation'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也提出了一个问题：评估的第二个定义是什么
- en: really a partial function?  Or is it possible that, beginning from
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 真的是一个偏函数吗？或者可能是，从
- en: the same state st, we could evaluate some command c in
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在相同的状态 st 下，我们可以评估一些命令 c
- en: different ways to reach two different output states st' and
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 达到两个不同输出状态st'和的不同方式
- en: st''?
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: st''？
- en: 'In fact, this cannot happen: ceval *is* a partial function:'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，这是不可能发生的：ceval *是*一个部分函数：
- en: '[PRE64]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Reasoning About Imp Programs
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Imp程序的推理
- en: We'll get deeper into systematic techniques for reasoning about
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将深入研究关于推理的系统技术
- en: Imp programs in the following chapters, but we can do quite a bit
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下章节中的Imp程序，但我们可以做很多
- en: just working with the bare definitions.  This section explores
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅使用基本定义。本节探讨
- en: some examples.
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些例子。
- en: '[PRE65]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Inverting Heval essentially forces Coq to expand one step of
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反演Heval基本上迫使Coq展开一步
- en: the ceval computation — in this case revealing that st'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ceval计算 - 在这种情况下揭示了st'
- en: must be st extended with the new value of X, since plus2
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 必须扩展为X的新值的st，因为plus2
- en: is an assignment
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是一个赋值
- en: '[PRE66]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Exercise: 3 stars, recommendedM (XtimesYinZ_spec)'
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，推荐M（XtimesYinZ_spec）
- en: State and prove a specification of XtimesYinZ.
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 状态并证明XtimesYinZ的规范。
- en: '[PRE67]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ☐
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, recommended (loop_never_stops)'
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，推荐（loop_never_stops）
- en: '[PRE68]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Proceed by induction on the assumed derivation showing that
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过对假设的推导进行归纳，展示
- en: loopdef terminates.  Most of the cases are immediately
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: loopdef终止。大多数情况立即
- en: contradictory (and so can be solved in one step with
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 矛盾（因此可以在一步内解决
- en: inversion).
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反演）。
- en: '[PRE69]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ☐
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars (no_whilesR)'
  id: totrans-497
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星（无whilesR）
- en: 'Consider the following function:'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 考虑以下函数：
- en: '[PRE70]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This predicate yields true just on programs that have no while
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个谓词仅在没有while的程序上返回true
- en: loops.  Using Inductive, write a property no_whilesR such that
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 循环。使用归纳，编写一个属性no_whilesR，使得
- en: no_whilesR c is provable exactly when c is a program with no
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当c是一个没有时的程序时，no_whilesR c是可证明的
- en: while loops.  Then prove its equivalence with no_whiles.
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: while循环。然后证明它与no_whiles的等价性。
- en: '[PRE71]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ☐
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 4 starsM (no_whiles_terminating)'
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：4星M（no_whiles_terminating）
- en: Imp programs that don't involve while loops always terminate.
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不涉及while循环的Imp程序总是终止。
- en: State and prove a theorem no_whiles_terminating that says this.  Use either
    no_whiles or no_whilesR, as you prefer.
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 状态并证明一个定理no_whiles_terminating，它说这个。使用no_whiles或no_whilesR，根据您的喜好选择。
- en: '[PRE72]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ☐
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE73]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: (2*3)+(3*(4-2))
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （2*3）+（3*（4-2））
- en: '[PRE74]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 2 3 * 3 4 2 - * +
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2 3 * 3 4 2 - * +
- en: '[PRE75]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[ ]           |    2 3 * 3 4 2 - * +'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[ ]           |    2 3 * 3 4 2 - * +'
- en: '[2]           |    3 * 3 4 2 - * +'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[2]           |    3 * 3 4 2 - * +'
- en: '[3, 2]        |    * 3 4 2 - * +'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[3, 2]        |    * 3 4 2 - * +'
- en: '[6]           |    3 4 2 - * +'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[6]           |    3 4 2 - * +'
- en: '[3, 6]        |    4 2 - * +'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[3, 6]        |    4 2 - * +'
- en: '[4, 3, 6]     |    2 - * +'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[4, 3, 6]     |    2 - * +'
- en: '[2, 4, 3, 6]  |    - * +'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[2, 4, 3, 6]  |    - * +'
- en: '[2, 3, 6]     |    * +'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[2, 3, 6]     |    * +'
- en: '[6, 6]        |    +'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[6, 6]        |    +'
- en: '[12]          |'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[12]          |'
- en: '[PRE76]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Inductive sinstr : Type :='
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳sinstr：类型 :=
- en: '| SPush : nat → sinstr'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '| SPush：nat → sinstr'
- en: '| SLoad : id → sinstr'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '| SLoad：id → sinstr'
- en: '| SPlus : sinstr'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '| SPlus：sinstr'
- en: '| SMinus : sinstr'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '| SMinus：sinstr'
- en: '| SMult : sinstr.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '| SMult：sinstr。'
- en: '[PRE77]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Fixpoint s_execute (st : state) (stack : list nat)'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 递归s_execute（st：state）（stack：list nat）
- en: '(prog : list sinstr)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: （prog：list sinstr）
- en: ': list nat'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: ：list nat
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ."替换此行*）。已承认。
- en: 'Example s_execute1 :'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 示例s_execute1：
- en: s_execute empty_state []
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: s_execute empty_state []
- en: '[SPush 5; SPush 3; SPush 1; SMinus]'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[SPush 5; SPush 3; SPush 1; SMinus]'
- en: = [2; 5].
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: = [2; 5]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *)
- en: 'Example s_execute2 :'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 示例s_execute2：
- en: s_execute (t_update empty_state X 3) [3;4]
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: s_execute（t_update empty_state X 3）[3;4]
- en: '[SPush 4; SLoad X; SMult; SPlus]'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[SPush 4; SLoad X; SMult; SPlus]'
- en: = [15; 4].
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: = [15; 4]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *)
- en: '[PRE78]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Fixpoint s_compile (e : aexp) : list sinstr'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 递归s_compile（e：aexp）：list sinstr
- en: (* REPLACE THIS LINE WITH ":= _your_definition_ ." *). Admitted.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用":= _your_definition_ ."替换此行*）。已承认。
- en: '[PRE79]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Example s_compile1 :'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 示例s_compile1：
- en: s_compile (AMinus (AId X) (AMult (ANum 2) (AId Y)))
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: s_compile（AMinus（AId X）（AMult（ANum 2）（AId Y）））
- en: = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: = [SLoad X; SPush 2; SLoad Y; SMult; SMinus]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *)
- en: '[PRE80]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Theorem s_compile_correct : ∀(st : state) (e : aexp),'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 定理s_compile_correct：∀（st：state）（e：aexp），
- en: s_execute st [] (s_compile e) = [ aeval st e ].
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: s_execute st []（s_compile e）= [ aeval st e ]。
- en: Proof.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *)
- en: '[PRE81]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: (* FILL IN HERE *)
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: (* 在此填写 *)
- en: '[PRE82]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Module BreakImp.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 模块BreakImp。
- en: '[PRE83]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Inductive com : Type :='
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳com：类型 :=
- en: '| CSkip : com'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSkip：com'
- en: '| CBreak : com               (* <-- new *)'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '| CBreak：com               （<-- 新的）'
- en: '| CAss : id → aexp → com'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '| CAss：id → aexp → com'
- en: '| CSeq : com → com → com'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '| CSeq：com → com → com'
- en: '| CIf : bexp → com → com → com'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '| CIf：bexp → com → com → com'
- en: '| CWhile : bexp → com → com.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '| CWhile：bexp → com → com。'
- en: Notation "'SKIP'" :=
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"'SKIP'"的表示法 :=
- en: CSkip.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: CSkip。
- en: Notation "'BREAK'" :=
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"'BREAK'"的表示法 :=
- en: CBreak.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: CBreak。
- en: Notation "x '::=' a" :=
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 符号"x '::=' a"的表示法 :=
- en: (CAss x a) (at level 60).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: （CAss x a）（在级别60处）。
- en: Notation "c1 ;; c2" :=
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: (CSeq c[1] c[2]) (at level 80, right associativity).
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'WHILE' b 'DO' c 'END'" :=
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: (CWhile b c) (at level 80, right associativity).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: (CIf c[1] c[2] c[3]) (at level 80, right associativity).
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: X ::= 0;;
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= 1;;
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: WHILE 0 ≠ Y DO
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: WHILE TRUE DO
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: BREAK
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: END;;
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: X ::= 1;;
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Y ::= Y - 1
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: END
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '... the value of X should be 1, and not 0.'
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One way of expressing this behavior is to add another parameter to
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the evaluation relation that specifies whether evaluation of a
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'command executes a BREAK statement:'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Intuitively, c / st ⇓ s / st' means that, if c is started in
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: state st, then it terminates in state st' and either signals
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that the innermost surrounding loop (or the whole program) should
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: exit immediately (s = SBreak) or that execution should continue
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: normally (s = SContinue).
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The definition of the "c / st ⇓ s / st'" relation is very
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: similar to the one we gave above for the regular evaluation
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation (c / st ⇓ st') — we just need to handle the
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'termination signals appropriately:'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the command is SKIP, then the state doesn't change and execution of any enclosing
    loop can continue normally.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command is BREAK, the state stays unchanged but we signal a SBreak.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command is an assignment, then we update the binding for that variable
    in the state accordingly and signal that execution can continue normally.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command is of the form IFB b THEN c[1] ELSE c[2] FI, then the state is
    updated as in the original semantics of Imp, except that we also propagate the
    signal from the execution of whichever branch was taken.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command is a sequence c[1] ;; c[2], we first execute c[1]. If this yields
    a SBreak, we skip the execution of c[2] and propagate the SBreak signal to the
    surrounding context; the resulting state is the same as the one obtained by executing
    c[1] alone. Otherwise, we execute c[2] on the state obtained after executing c[1],
    and propagate the signal generated there.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, for a loop of the form WHILE b DO c END, the semantics is almost the
    same as before. The only difference is that, when b evaluates to true, we execute
    c and check the signal that it raises. If that signal is SContinue, then the execution
    proceeds as in the original semantics. Otherwise, we stop the execution of the
    loop, and the resulting state is the same as the one resulting from the execution
    of the current iteration. In either case, since BREAK only terminates the innermost
    loop, WHILE signals SContinue.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the above description, complete the definition of the
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ceval relation.
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now prove the following properties of your definition of ceval:'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ☐
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced, optional (while_break_true)'
  id: totrans-621
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: ☐
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 4 stars, advanced, optional (ceval_deterministic)'
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: ☐
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Exercise: 4 stars, optional (add_for_loop)'
  id: totrans-628
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add C-style for loops to the language of commands, update the
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ceval definition to define the semantics of for loops, and add
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cases for for loops as needed so that all the proofs in this file
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are accepted by Coq.
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被 Coq 接受。
- en: A for loop should be parameterized by (a) a statement executed
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个 for 循环应该由（a）一条在每次迭代中执行的语句参数化
- en: initially, (b) a test that is run on each iteration of the loop to
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最初，（b）在循环的每次迭代上运行的测试
- en: determine whether the loop should continue, (c) a statement
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定循环是否应该继续，（c）一个语句
- en: executed at the end of each loop iteration, and (d) a statement
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每次循环迭代结束时执行，并且（d）一个语句
- en: that makes up the body of the loop.  (You don't need to worry
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构成循环主体的部分。（你不需要担心
- en: about making up a concrete Notation for for loops, but feel free
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于为循环制定一个具体的符号表示，但随意
- en: to play with this too if you like.)
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你喜欢的话，也可以玩一下这个。）
- en: '[PRE91]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ☐
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE92]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
