- en: SmallstepSmall-step Operational Semantics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SmallstepSmall-step Operational Semantics
- en: '[PRE0]'
  id: totrans-1
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Require Import Coq.Arith.Arith.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Arith.Arith.
- en: Require Import Coq.Arith.EqNat.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Arith.EqNat.
- en: Require Import Coq.omega.Omega.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.omega.Omega.
- en: Require Import Coq.Lists.List.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Coq.Lists.List.
- en: Import ListNotations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Import ListNotations.
- en: Require Import Maps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Maps.
- en: Require Import Imp.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Require Import Imp.
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A Toy Language
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个玩具语言
- en: To save space in the discussion, let's go back to an
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了节省空间，讨论让我们回到一个
- en: incredibly simple language containing just constants and
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 极其简单的语言仅包含常数和
- en: addition.  (We use single letters — C and P (for Command and
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加法。（我们使用单个字母 —— C 和 P（对于命令和
- en: Plus) — as constructor names, for brevity.)  At the end of the
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Plus） —— 作为构造器名称，简洁起见。）在
- en: chapter, we'll see how to apply the same techniques to the full
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 章节，我们将看到如何将相同的技术应用到完整
- en: Imp language.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Imp 语言。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here is a standard evaluator for this language, written in
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是这种语言的标准求值器，编写于
- en: the big-step style that we've been using up to this point.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止我们一直在使用的大步骤样式。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here is the same evaluator, written in exactly the same
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是相同的求值器，完全相同地编写
- en: style, but formulated as an inductively defined relation.  Again,
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 样式，但被规定为归纳定义的关系。再次，
- en: we use the notation t ⇓ n for "t evaluates to n."
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用符号 t ⇓ n 表示“t 评估为 n”。
- en: '|'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (E_Const)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （E_Const）
- en: '|'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: C n ⇓ n
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: C n ⇓ n
- en: '|'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: t[1] ⇓ n[1]
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: t[1] ⇓ n[1]
- en: '|'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: t[2] ⇓ n[2]
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: t[2] ⇓ n[2]
- en: '|'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (E_Plus)
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （E_Plus）
- en: '|'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P t[1] t[2] ⇓ n[1] + n[2]
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P t[1] t[2] ⇓ n[1] + n[2]
- en: '|'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, here is the corresponding *small-step* evaluation relation.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，这是相应的 *小步* 评估关系。
- en: '|'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (ST_PlusConstConst)
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （ST_PlusConstConst）
- en: '|'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
- en: '|'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: t[1] ⇒ t[1]'
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: t[1] ⇒ t[1]'
- en: '|'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (ST_Plus1)
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （ST_Plus1）
- en: '|'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P t[1] t[2] ⇒ P t[1]' t[2]
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P t[1] t[2] ⇒ P t[1]' t[2]
- en: '|'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: t[2] ⇒ t[2]'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: t[2] ⇒ t[2]'
- en: '|'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (ST_Plus2)
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （ST_Plus2）
- en: '|'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P (C n[1]) t[2] ⇒ P (C n[1]) t[2]'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P (C n[1]) t[2] ⇒ P (C n[1]) t[2]'
- en: '|'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Things to notice:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意事项：
- en: We are defining just a single reduction step, in which one P node is replaced
    by its value.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只定义了一个单个的减少步骤，其中一个 P 节点被其值替换。
- en: Each step finds the *leftmost* P node that is ready to go (both of its operands
    are constants) and rewrites it in place. The first rule tells how to rewrite this
    P node itself; the other two rules tell how to find it.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一步都找到最左边的准备好的 P 节点（其两个操作数都是常量）并就地重写它。第一条规则告诉如何重写此 P 节点本身；另外两条规则告诉如何找到它。
- en: A term that is just a constant cannot take a step.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个仅是常量的术语不能走一步。
- en: Let's pause and check a couple of examples of reasoning with
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们暂停一下，检查一下几个推理示例
- en: the step relation...
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 步骤关系…
- en: If t[1] can take a step to t[1]', then P t[1] t[2] steps
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 t[1] 可以向 t[1]' 步进，则 P t[1] t[2] 步
- en: 'to P t[1]'' t[2]:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对 P t[1]' t[2]：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Exercise: 1 star (test_step_2)'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1 星（test_step_2）
- en: Right-hand sides of sums can take a step only when the
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和的右手边只有当
- en: 'left-hand side is finished: if t[2] can take a step to t[2]'','
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 左侧已完成：如果 t[2] 可以向 t[2]' 步进，
- en: 'then P (C n) t[2] steps to P (C n) t[2]'':'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '那么 P (C n) t[2] 步至 P (C n) t[2]'':'
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ☐
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Relations
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系
- en: We will be working with several different single-step relations,
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用几种不同的单步关系，
- en: so it is helpful to generalize a bit and state a few definitions
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，泛化并声明一些定义会很有帮助
- en: and theorems about relations in general.  (The optional chapter
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和关于关系的定理。 （可选章节
- en: Rel.v develops some of these ideas in a bit more detail; it may
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Rel.v 在更详细地开发了一些这些想法；它可能会
- en: be useful if the treatment here is too dense.)
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这里的处理过于密集，可能会有用。）
- en: A *binary relation* on a set X is a family of propositions
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于集合 X 的 *二元关系* 是一组命题
- en: parameterized by two elements of X — i.e., a proposition about
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数化由 X 的两个元素 —— 即关于
- en: pairs of elements of X.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由 X 的元素对。
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our main examples of such relations in this chapter will be
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，这些关系的主要示例将是
- en: the single-step reduction relation, ⇒, and its multi-step
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单步减少关系，⇒，及其多步
- en: variant, ⇒* (defined below), but there are many other
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变种，⇒*（下面定义），但还有许多其他
- en: examples — e.g., the "equals," "less than," "less than or equal
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如 —— 例如，“等于”，“小于”，“小于等于”
- en: to," and "is the square of" relations on numbers, and the "prefix
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 至，”以及“是的平方”的关系，以及“前缀
- en: of" relation on lists and strings.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在列表和字符串上的"之间关系。
- en: One simple property of the ⇒ relation is that, like the
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ⇒ 关系的一个简单性质是，就像
- en: big-step evaluation relation for Imp, it is *deterministic*.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Imp 的大步评估关系是 *确定的*。
- en: '*Theorem*: For each t, there is at most one t'' such that t'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*定理*：对于每个 t，最多有一个 t''，使得 t'
- en: steps to t' (t ⇒ t' is provable).  Formally, this is the
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 步骤到 t'（t ⇒ t' 是可证明的）。形式上，这是
- en: same as saying that ⇒ is deterministic.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相当于说⇒是确定性的。
- en: '*Proof sketch*: We show that if x steps to both y[1] and'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*证明概述*：我们证明如果x同时步进到y[1]和'
- en: y[2], then y[1] and y[2] are equal, by induction on a derivation
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: y[2]，那么y[1]和y[2]相等，通过对推导进行归纳
- en: of step x y[1].  There are several cases to consider, depending on
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 步骤x y[1]。有几种情况需要考虑，取决于
- en: the last rule used in this derivation and the last rule in the
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个推导中使用的最后一个规则和最后一个规则
- en: given derivation of step x y[2].
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给定步骤x y[2]的推导。
- en: If both are ST_PlusConstConst, the result is immediate.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两者都是ST_PlusConstConst，结果是显而易见的。
- en: The cases when both derivations end with ST_Plus1 or ST_Plus2 follow by the
    induction hypothesis.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个推导都以ST_Plus1或ST_Plus2结尾时，遵循归纳假设。
- en: It cannot happen that one is ST_PlusConstConst and the other is ST_Plus1 or
    ST_Plus2, since this would imply that x has the form P t[1] t[2] where both t[1]
    and t[2] are constants (by ST_PlusConstConst) *and* one of t[1] or t[2] has the
    form P _.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能一个是ST_PlusConstConst，另一个是ST_Plus1或ST_Plus2，因为这将意味着x具有形式P t[1] t[2]，其中t[1]和t[2]都是常数（通过ST_PlusConstConst）*并且*
    t[1]或t[2]中的一个具有形式P _。
- en: Similarly, it cannot happen that one is ST_Plus1 and the other is ST_Plus2,
    since this would imply that x has the form P t[1] t[2] where t[1] has both the
    form P t[11] t[12] and the form C n. ☐
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，不可能发生一个是ST_Plus1，另一个是ST_Plus2，因为这将意味着x具有形式P t[1] t[2]，其中t[1]既具有形式P t[11]
    t[12]，也具有形式C n。☐
- en: 'Formally:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 形式上：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is some annoying repetition in this proof.  Each use of
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个证明中有一些令人讨厌的重复。每次使用
- en: inversion Hy[2] results in three subcases, only one of which is
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对Hy[2]进行反演会导致三个子情况，只有一个是
- en: relevant (the one that matches the current case in the induction
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相关的（与归纳中的当前情况匹配的那个
- en: on Hy[1]).  The other two subcases need to be dismissed by finding
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Hy[1]上）。其他两种情况需要通过找到来解决
- en: the contradiction among the hypotheses and doing inversion on it.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设之间的矛盾并对其进行反演。
- en: The following custom tactic, called solve_by_inverts, can be
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下自定义策略，称为solve_by_inverts，可以
- en: helpful in such cases.  It will solve the goal if it can be solved
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下很有帮助。如果可以解决，它将解决目标
- en: by inverting some hypothesis; otherwise, it fails.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过反演一些假设；否则，它会失败。
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The details of how this works are not important for now, but it
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是如何工作的细节现在并不重要，但是它
- en: illustrates the power of Coq's Ltac language for
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 展示了Coq的Ltac语言的强大之处
- en: programmatically defining special-purpose tactics.  It looks
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以编程方式定义特定目的的策略。看起来
- en: through the current proof state for a hypothesis H (the first
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过当前证明状态查找假设H（第一个
- en: match) of type Prop (the second match) such that performing
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 匹配）的类型Prop（第二个匹配），使得执行
- en: inversion on H (followed by a recursive invocation of the same
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: H上的反演（后跟对相同的递归调用
- en: tactic, if its argument n is greater than one) completely solves
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略，如果其参数n大于一）完全解决
- en: the current goal.  If no such hypothesis exists, it fails.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当前目标。如果不存在这样的假设，它会失败。
- en: We will usually want to call solve_by_inverts with argument
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通常会想要调用带有参数的solve_by_inverts
- en: 1 (especially as larger arguments can lead to very slow proof
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1（特别是因为较大的参数可能导致非常缓慢的证明
- en: checking), so we define solve_by_invert as a shorthand for this
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查），因此我们将solve_by_invert定义为这个的简写
- en: case.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 情况。
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's see how a proof of the previous theorem can be simplified
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看如何简化前一个定理的证明
- en: using this tactic...
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这个策略...
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Values
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值
- en: Next, it will be useful to slightly reformulate the
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，稍微重新制定将会很有用
- en: definition of single-step reduction by stating it in terms of
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过以单步减���的方式来定义它，以术语形式陈述
- en: '"values."'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “值”。
- en: It is useful to think of the ⇒ relation as defining an
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将⇒关系视为定义一个
- en: '*abstract machine*:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*抽象机器*：'
- en: At any moment, the *state* of the machine is a term.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时刻，机器的*状态*是一个术语。
- en: A *step* of the machine is an atomic unit of computation — here, a single "add"
    operation.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器的*步骤*是计算的原子单位 — 这里是单个“add”操作。
- en: The *halting states* of the machine are ones where there is no more computation
    to be done.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器的*停机状态*是没有更多计算要做的状态。
- en: 'We can then execute a term t as follows:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们可以执行一个术语t如下：
- en: Take t as the starting state of the machine.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将t作为机器的起始状态。
- en: Repeatedly use the ⇒ relation to find a sequence of machine states, starting
    with t, where each state steps to the next.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反复使用⇒关系找到一系列机器状态，从t开始，每个状态都步进到下一个。
- en: When no more reduction is possible, "read out" the final state of the machine
    as the result of execution.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有更多的规约时，“读取”机器的最终状态作为执行的结果。
- en: Intuitively, it is clear that the final states of the
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 直观上，最终状态的
- en: machine are always terms of the form C n for some n.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机器始终是形式为 C n 的术语。
- en: We call such terms *values*.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们称这样的术语为*值*。
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Having introduced the idea of values, we can use it in the
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引入了值的概念后，我们可以在其中使用它
- en: definition of the ⇒ relation to write ST_Plus2 rule in a
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义 ⇒ 关系的 ST_Plus2 规则的形式化版本
- en: 'slightly more elegant way:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 稍微更加优雅的方式：
- en: '|'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (ST_PlusConstConst)
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (ST_PlusConstConst)
- en: '|'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
- en: '|'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: t[1] ⇒ t[1]'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: t[1] ⇒ t[1]'
- en: '|'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (ST_Plus1)
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (ST_Plus1)
- en: '|'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P t[1] t[2] ⇒ P t[1]' t[2]
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P t[1] t[2] ⇒ P t[1]' t[2]
- en: '|'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: value v[1]
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值 v[1]
- en: '|'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: t[2] ⇒ t[2]'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: t[2] ⇒ t[2]'
- en: '|'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: (ST_Plus2)
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: (ST_Plus2)
- en: '|'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '* * *'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: P v[1] t[2] ⇒ P v[1] t[2]'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: P v[1] t[2] ⇒ P v[1] t[2]'
- en: '|'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: 'Again, the variable names here carry important information:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，这里的变量名携带重要信息：
- en: by convention, v[1] ranges only over values, while t[1] and t[2]
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按照惯例，v[1] 仅限于值，而 t[1] 和 t[2]
- en: range over arbitrary terms.  (Given this convention, the explicit
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 范围涵盖任意术语。（鉴于这一约定，显式
- en: value hypothesis is arguably redundant.  We'll keep it for now,
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值假设可能是多余的。我们暂时保留它，
- en: to maintain a close correspondence between the informal and Coq
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持非正式和 Coq 之间的密切对应
- en: versions of the rules, but later on we'll drop it in informal
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 规则的版本，但后来我们会在非正式的情况下放弃它
- en: rules for brevity.)
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简洁起见的规则。）
- en: 'Here are the formal rules:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是正式规则：
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Exercise: 3 stars, recommended (redo_determinism)'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3 星，推荐（redo_determinism）
- en: As a sanity check on this change, let's re-verify determinism.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为对这一变化的健全性检查，让我们重新验证确定性。
- en: '*Proof sketch*: We must show that if x steps to both y[1] and'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*证明概述*：我们必须证明如果 x 同时步进到 y[1] 和'
- en: y[2], then y[1] and y[2] are equal.  Consider the final rules used
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: y[2]，那么 y[1] 和 y[2] 是相等的。考虑使用的最终规则
- en: in the derivations of step x y[1] and step x y[2].
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在步骤 x y[1] 和步骤 x y[2] 的推导中。
- en: If both are ST_PlusConstConst, the result is immediate.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两者都是 ST_PlusConstConst，结果是显而易见的。
- en: It cannot happen that one is ST_PlusConstConst and the other is ST_Plus1 or
    ST_Plus2, since this would imply that x has the form P t[1] t[2] where both t[1]
    and t[2] are constants (by ST_PlusConstConst) *and* one of t[1] or t[2] has the
    form P _.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能出现一个是 ST_PlusConstConst 而另一个是 ST_Plus1 或 ST_Plus2 的情况，因为这将意味着 x 具有形式 P t[1]
    t[2]，其中 t[1] 和 t[2] 都是常数（通过 ST_PlusConstConst）*并且* t[1] 或 t[2] 中的一个具有形式 P _。
- en: Similarly, it cannot happen that one is ST_Plus1 and the other is ST_Plus2,
    since this would imply that x has the form P t[1] t[2] where t[1] both has the
    form P t[11] t[12] and is a value (hence has the form C n).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，不可能出现一个是 ST_Plus1 而另一个是 ST_Plus2 的情况，因为这将意味着 x 具有形式 P t[1] t[2]，其中 t[1] 既具有形式
    P t[11] t[12] 又是一个值（因此具有形式 C n）。
- en: The cases when both derivations end with ST_Plus1 or ST_Plus2 follow by the
    induction hypothesis. ☐
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个推导都以 ST_Plus1 或 ST_Plus2 结束时，根据归纳假设即可得出结论。☐
- en: Most of this proof is the same as the one above.  But to get
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大部分证明与上面的证明相同。但为了得到
- en: maximum benefit from the exercise you should try to write your
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从练习中获得最大的收益，你应该尝试写下你的
- en: formal version from scratch and just use the earlier one if you
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从头开始形式化版本，如果你只需使用之前的一个
- en: get stuck.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 卡住了。
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ☐
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Theorem strong_progress : ∀t,'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 strong_progress：∀t，
- en: value t ∨ (∃t', t ⇒ t').
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 值 t ∨ (∃t'，t ⇒ t')。
- en: Proof.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: induction t.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t 进行归纳。
- en: '- (* C *) left. apply [v_const](Smallstep.html#v_const).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* C *) 左。应用 [v_const](Smallstep.html#v_const)。'
- en: '- (* P *) right. inversion IHt1.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '- (* P *) 右。反演 IHt1。'
- en: + (* l *) inversion IHt2.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: + (* l *) 反演 IHt2。
- en: '* (* l *) inversion H. inversion H[0].'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* l *) 反演 H。反演 H[0]。'
- en: ∃([C](Smallstep.html#C) (n + n[0])).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([C](Smallstep.html#C) (n + n[0]))。
- en: apply [ST_PlusConstConst](Smallstep.html#ST_PlusConstConst).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [ST_PlusConstConst](Smallstep.html#ST_PlusConstConst)。
- en: '* (* r *) inversion H[0] as [t'' H[1]].'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '* (* r *) 反演 H[0] 得到 [t'' H[1]]。'
- en: ∃([P](Smallstep.html#P) t[1] t').
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([P](Smallstep.html#P) t[1] t')。
- en: apply [ST_Plus2](Smallstep.html#ST_Plus2). apply H. apply H[1].
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [ST_Plus2](Smallstep.html#ST_Plus2)。应用 H。应用 H[1]。
- en: + (* r *) inversion H as [t' H[0]].
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: + (* r *) 反演 H 得到 [t' H[0]]。
- en: ∃([P](Smallstep.html#P) t' t[2]).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ∃([P](Smallstep.html#P) t' t[2])。
- en: apply [ST_Plus1](Smallstep.html#ST_Plus1). apply H[0]. Qed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [ST_Plus1](Smallstep.html#ST_Plus1)。应用 H[0]。Qed。
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Definition normal_form {X:Type} (R:relation X) (t:X) : Prop :='
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 normal_form {X:Type} (R:relation X) (t:X) : Prop :='
- en: ¬ ∃t', R t t'.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ¬ ∃t'，R t t'。
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lemma value_is_nf : ∀v,'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 value_is_nf：∀v，
- en: value v → normal_form step v.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v → 步骤 v 的正规形式。
- en: Proof.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: unfold [normal_form](Smallstep.html#normal_form). intros v H. inversion H.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [normal_form](Smallstep.html#normal_form)。引入 v H。反演 H。
- en: intros contra. inversion contra. inversion H[1].
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 contra。反演 contra。反演 H[1]。
- en: Qed.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qed。
- en: 'Lemma nf_is_value : ∀t,'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 nf_is_value：∀t，
- en: normal_form step t → value t.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤 t 的正规形式 → 值 t。
- en: Proof. (* a corollary of strong_progress... *)
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。 (* 一个强进展的推论... *)
- en: unfold [normal_form](Smallstep.html#normal_form). intros t H.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [normal_form](Smallstep.html#normal_form)。引入 t H。
- en: 'assert (G : [value](Smallstep.html#value) t ∨ ∃t'', t ⇒ [t''](Smallstep.html#t'')).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 断言（G：[value](Smallstep.html#value) t ∨ ∃t'，t ⇒ [t'](Smallstep.html#t')）。
- en: '{ apply [strong_progress](Smallstep.html#strong_progress). }'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 应用 [strong_progress](Smallstep.html#strong_progress)。 }'
- en: inversion G.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 G。
- en: + (* l *) apply H[0].
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: + (* l *) 应用 H[0]。
- en: + (* r *) exfalso. apply H. assumption. Qed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: + (* r *) 反证法。应用 H。假设成立。证毕。
- en: 'Corollary nf_same_as_value : ∀t,'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 推论 nf_same_as_value：∀t，
- en: normal_form step t ↔ value t.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: normal_form step t ↔ value t。
- en: Proof.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ��明。
- en: split. apply [nf_is_value](Smallstep.html#nf_is_value). apply [value_is_nf](Smallstep.html#value_is_nf).
    Qed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 分裂。应用 [nf_is_value](Smallstep.html#nf_is_value)。应用 [value_is_nf](Smallstep.html#value_is_nf)。证毕。
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Module Temp1.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 Temp1。
- en: 'Inductive value : tm → Prop :='
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳值：tm → Prop :=
- en: '| v_const : ∀n, value (C n)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '| v_const：∀n，值 (C n)'
- en: '| v_funny : ∀t[1] n[2],                       (* <---- *)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '| v_funny：∀t[1] n[2]，                       (* <---- *)'
- en: value (P t[1] (C n[2])).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 值 (P t[1] (C n[2]))。
- en: Reserved Notation " t '⇒' t' " (at level 40).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 保留符号 " t '⇒' t' "（在级别 40）。
- en: 'Inductive step : tm → tm → Prop :='
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳步骤：tm → tm → Prop :=
- en: '| ST_PlusConstConst : ∀n[1] n[2],'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_PlusConstConst：∀n[1] n[2]，'
- en: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
- en: '| ST_Plus1 : ∀t[1] t[1]'' t[2],'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Plus1：∀t[1] t[1]'' t[2]，'
- en: t[1] ⇒ t[1]' →
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] ⇒ t[1]' →
- en: P t[1] t[2] ⇒ P t[1]' t[2]
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: P t[1] t[2] ⇒ P t[1]' t[2]
- en: '| ST_Plus2 : ∀v[1] t[2] t[2]'','
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_Plus2：∀v[1] t[2] t[2]''，'
- en: value v[1] →
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 值 v[1] →
- en: t[2] ⇒ t[2]' →
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: t[2] ⇒ t[2]' →
- en: P v[1] t[2] ⇒ P v[1] t[2]'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: P v[1] t[2] ⇒ P v[1] t[2]'
- en: where " t '⇒' t' " := (step t t').
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 " t '⇒' t' " := (step t t')。
- en: 'Lemma value_not_same_as_normal_form :'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 value_not_same_as_normal_form：
- en: ∃v, value v ∧ ¬ normal_form step v.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ∃v，值 v ∧ ¬ normal_form step v。
- en: Proof.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处*) 已承认。
- en: End Temp1.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 结束 Temp1。
- en: '[PRE21]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Exercise: 2 stars, optional (value_not_same_as_normal_form2)'
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星，可选（value_not_same_as_normal_form2）
- en: Alternatively, we might mistakenly define step so that it
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，我们可能错误地定义步骤，以便它
- en: permits something designated as a value to reduce further.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许某些被指定为值的东西进一步减少。
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ☐
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, optional (value_not_same_as_normal_form3)'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，可选（value_not_same_as_normal_form3）
- en: Finally, we might define value and step so that there is some
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们可以定义值和步骤，以便存在一些
- en: term that is not a value but that cannot take a step in the step
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不是值但在步骤中无法进行进一步的术语
- en: relation.  Such terms are said to be *stuck*. In this case this is
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关系。这些术语被称为*卡住*。在这种情况下，这是
- en: caused by a mistake in the semantics, but we will also see
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由语义错误引起，但我们也会看到
- en: situations where, even in a correct language definition, it makes
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有些情况下，即使在正确的语言定义中，也会出现
- en: sense to allow some terms to be stuck.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许一些术语卡住是有意义的。
- en: '[PRE23]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: (Note that ST_Plus2 is missing.)
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （请注意 ST_Plus2 缺失。）
- en: '[PRE24]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ☐
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE25]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Module Temp4.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 Temp4。
- en: '[PRE26]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inductive tm : Type :='
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳定义 tm：Type :=
- en: '| ttrue : tm'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '| ttrue：tm'
- en: '| tfalse : tm'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '| tfalse：tm'
- en: '| tif : tm → tm → tm → tm.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '| tif：tm → tm → tm → tm。'
- en: 'Inductive value : tm → Prop :='
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳值：tm → Prop :=
- en: '| v_true : value ttrue'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '| v_true：值 ttrue'
- en: '| v_false : value tfalse.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '| v_false：值 tfalse。'
- en: Reserved Notation " t '⇒' t' " (at level 40).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 保留符号 " t '⇒' t' "（在级别 40）。
- en: 'Inductive step : tm → tm → Prop :='
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳步骤：tm → tm → Prop :=
- en: '| ST_IfTrue : ∀t[1] t[2],'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_IfTrue：∀t[1] t[2]，'
- en: tif ttrue t[1] t[2] ⇒ t[1]
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ttrue t[1] t[2] ⇒ t[1]
- en: '| ST_IfFalse : ∀t[1] t[2],'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_IfFalse：∀t[1] t[2]，'
- en: tif tfalse t[1] t[2] ⇒ t[2]
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 tfalse t[1] t[2] ⇒ t[2]
- en: '| ST_If : ∀t[1] t[1]'' t[2] t[3],'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '| ST_If：∀t[1] t[1]'' t[2] t[3]，'
- en: t[1] ⇒ t[1]' →
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] ⇒ t[1]' →
- en: tif t[1] t[2] t[3] ⇒ tif t[1]' t[2] t[3]
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 t[1] t[2] t[3] ⇒ tif t[1]' t[2] t[3]
- en: where " t '⇒' t' " := (step t t').
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 " t '⇒' t' " := (step t t')。
- en: '[PRE27]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Definition bool_step_prop1 :=
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 bool_step_prop1 :=
- en: tfalse ⇒ tfalse.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: tfalse ⇒ tfalse。
- en: (* FILL IN HERE *)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处*)
- en: Definition bool_step_prop2 :=
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 bool_step_prop2 :=
- en: tif
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: ttrue
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ttrue
- en: (tif ttrue ttrue ttrue)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 ttrue ttrue ttrue)
- en: (tif tfalse tfalse tfalse)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 tfalse tfalse tfalse)
- en: ⇒
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ⇒
- en: ttrue.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ttrue。
- en: (* FILL IN HERE *)
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处*)
- en: Definition bool_step_prop3 :=
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 bool_step_prop3 :=
- en: tif
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (tif ttrue ttrue ttrue)
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 ttrue ttrue ttrue)
- en: (tif ttrue ttrue ttrue)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 ttrue ttrue ttrue)
- en: tfalse
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: tfalse
- en: ⇒
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ⇒
- en: tif
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: ttrue
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ttrue
- en: (tif ttrue ttrue ttrue)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 ttrue ttrue ttrue)
- en: tfalse.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: tfalse。
- en: (* FILL IN HERE *)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处*)
- en: '[PRE28]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Theorem strong_progress : ∀t,'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 strong_progress：∀t，
- en: value t ∨ (∃t', t ⇒ t').
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 值 t ∨ (∃t'，t ⇒ t')。
- en: Proof.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处*) 已承认。
- en: '[PRE29]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Theorem step_deterministic :'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 step_deterministic：
- en: deterministic step.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性步骤。
- en: Proof.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: (* 填写此处*) 已承认。
- en: '[PRE30]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Module Temp5.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 模块 Temp5。
- en: '[PRE31]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: tif
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果
- en: (tif ttrue ttrue ttrue)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: (如果 ttrue ttrue ttrue)
- en: tfalse
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: tfalse
- en: tfalse
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: tfalse
- en: ⇒
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ⇒
- en: tfalse.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: tfalse。
- en: Write an extra clause for the step relation that achieves this
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为步骤关系编写一个额外的子句，以实现这一点
- en: effect and prove bool_step_prop4.
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 效果并证明 bool_step_prop4。
- en: '[PRE32]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ☐
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, optional (properties_of_altered_step)'
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，可选（properties_of_altered_step）
- en: It can be shown that the determinism and strong progress theorems
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以证明决定性和强进展定理
- en: for the step relation in the lecture notes also hold for the
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于讲义中的步骤关系也适用于
- en: definition of step given above.  After we add the clause
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述给出的步骤的定义。在我们添加子句之后
- en: ST_ShortCircuit...
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ST_ShortCircuit...
- en: Is the step relation still deterministic? Write yes or no and briefly (1 sentence)
    explain your answer.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤关系仍然是确定性的吗？写下是或否，并简要（1句话）解释你的答案。
- en: 'Optional: prove your answer correct in Coq.'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选：在 Coq 中证明你的答案正确。
- en: '[PRE33]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Does a strong progress theorem hold? Write yes or no and briefly (1 sentence)
    explain your answer.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强进展定理成立吗？写下是或否，并简要（1句话）解释你的答案。
- en: 'Optional: prove your answer correct in Coq.'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选：在 Coq 中证明你的答案正确。
- en: '[PRE34]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In general, is there any way we could cause strong progress to fail if we took
    away one or more constructors from the original step relation? Write yes or no
    and briefly (1 sentence) explain your answer.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，如果我们从原始步骤关系中去掉一个或多个构造器，是否有任何方法可以导致强进展失败？写下是或否，并简要（1句话）解释你的答案。
- en: (* FILL IN HERE *)
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （* 填写此处 *）
- en: ☐
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE35]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Multi-Step Reduction
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多步减少
- en: We've been working so far with the *single-step reduction*
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用*单步减少*
- en: relation ⇒, which formalizes the individual steps of an
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关系 ⇒，它形式化了一个
- en: abstract machine for executing programs.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于执行程序的抽象机器。
- en: We can use the same machine to reduce programs to completion — to
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以使用相同的机器将程序减少到完成——到
- en: find out what final result they yield.  This can be formalized as
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 找出它们产生的最终结果。这可以形式化为
- en: 'follows:'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下：
- en: First, we define a *multi-step reduction relation* ⇒*, which relates terms t
    and t' if t can reach t' by any number (including zero) of single reduction steps.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个*多步减少关系* ⇒*，它将项 t 和 t' 相关联，如果 t 可以通过任意数量（包括零）的单次减少步骤达到 t'。
- en: Then we define a "result" of a term t as a normal form that t can reach by multi-step
    reduction.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将一个项 t 的“结果”定义为 t 可以通过多步减少达到的正常形式。
- en: '[PRE36]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inductive multi {X:Type} (R: relation X) : relation X :='
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '归纳多 {X:Type} (R: 关系 X) : 关系 X :='
- en: '| multi_refl  : ∀(x : X), multi R x x'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '| multi_refl  : ∀(x : X), multi R x x'
- en: '| multi_step : ∀(x y z : X),'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '| multi_step : ∀(x y z : X)，'
- en: R x y →
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: R x y →
- en: multi R y z →
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: multi R y z →
- en: multi R x z.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: multi R x z。
- en: '[PRE37]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: R x z[1]
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R x z[1]
- en: R z[1] z[2]
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R z[1] z[2]
- en: '...'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: R zn y.
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: R zn y。
- en: '[PRE38]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notation " t '⇒*' t' " := (multi step t t') (at level 40).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 " t '⇒*' t' " := (multi step t t') (在级别 40)。
- en: '[PRE39]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Theorem multi_R : ∀(X:Type) (R:relation X) (x y : X),'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 multi_R: ∀(X:Type) (R:关系 X) (x y : X)，'
- en: R x y → (multi R) x y.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: R x y → (multi R) x y。
- en: Proof.
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明
- en: intros X R x y H.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 X R x y H。
- en: apply [multi_step](Smallstep.html#multi_step) with y. apply H. apply [multi_refl](Smallstep.html#multi_refl).
    Qed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [multi_step](Smallstep.html#multi_step) 与 y。应用 H。应用 [multi_refl](Smallstep.html#multi_refl)。Qed。
- en: '[PRE40]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Theorem multi_trans :'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 multi_trans：
- en: '∀(X:Type) (R: relation X) (x y z : X),'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '∀(X:Type) (R: 关系 X) (x y z : X)，'
- en: multi R x y  →
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: multi R x y  →
- en: multi R y z →
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: multi R y z →
- en: multi R x z.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: multi R x z。
- en: Proof.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明
- en: intros X R x y z G H.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 X R x y z G H。
- en: induction G.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳 G。
- en: '- (* multi_refl *) assumption.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* multi_refl *）假设。'
- en: '- (* multi_step *)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '- （* multi_step *）'
- en: apply [multi_step](Smallstep.html#multi_step) with y. assumption.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [multi_step](Smallstep.html#multi_step) 与 y。假设。
- en: apply IHG. assumption. Qed.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHG。假设。Qed。
- en: '[PRE41]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Examples
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: 'Here''s a specific instance of the multi step relation:'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是多步关系的一个具体实例：
- en: '[PRE42]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here's an alternate proof of the same fact that uses eapply to
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是相同事实的另一种证明，使用 eapply
- en: avoid explicitly constructing all the intermediate terms.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免显式构造所有中间项。
- en: '[PRE43]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Exercise: 1 star, optional (test_multistep_2)'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星，可选（test_multistep_2）
- en: '[PRE44]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ☐
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 1 star, optional (test_multistep_3)'
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：1星，可选（test_multistep_3）
- en: '[PRE45]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ☐
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 2 stars (test_multistep_4)'
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：2星（test_multistep_4）
- en: '[PRE46]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ☐
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE47]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Definition step_normal_form := normal_form step.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 step_normal_form := normal_form step。
- en: 'Definition normal_form_of (t t'' : tm) :='
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 normal_form_of (t t'' : tm) :='
- en: (t ⇒* t' ∧ step_normal_form t').
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: （t ⇒* t' ∧ step_normal_form t'）。
- en: '[PRE48]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Theorem normal_forms_unique:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '定理 normal_forms_unique:'
- en: deterministic normal_form_of.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性 normal_form_of。
- en: Proof.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 证明
- en: (* We recommend using this initial setup as-is! *)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: （* 我们建议保持此初始设置不变！*）
- en: unfold deterministic. unfold normal_form_of.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 展开确定性。展开 normal_form_of。
- en: intros x y[1] y[2] P[1] P[2].
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 x y[1] y[2] P[1] P[2]。
- en: inversion P[1] as [P[11] P[12]]; clear P[1].
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 P[1] 为 [P[11] P[12]]; 清除 P[1]。
- en: inversion P[2] as [P[21] P[22]]; clear P[2].
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 反演 P[2] 为 [P[21] P[22]]; 清除 P[2]。
- en: generalize dependent y[2].
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化相关的 y[2]。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: （* 填写此处 *）已承认。
- en: '[PRE49]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Definition normalizing {X:Type} (R:relation X) :=
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 normalizing {X:Type} (R:关系 X) :=
- en: ∀t, ∃t',
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: ∀t, ∃t'，
- en: (multi R) t t' ∧ normal_form R t'.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: （multi R）t t' ∧ normal_form R t'。
- en: '[PRE50]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Lemma multistep_congr_1 : ∀t[1] t[1]'' t[2],'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '引理 multistep_congr_1: ∀t[1] t[1]'' t[2]，'
- en: t[1] ⇒* t[1]' →
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] ⇒* t[1]' →
- en: P t[1] t[2] ⇒* P t[1]' t[2].
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: P t[1] t[2] ⇒* P t[1]' t[2]。
- en: Proof.
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: intros t[1] t[1]' t[2] H. induction H.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t[1] t[1]' t[2] H 进行归纳。
- en: '- (* multi_refl *) apply [multi_refl](Smallstep.html#multi_refl).'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: -（* multi_refl *）应用 [multi_refl](Smallstep.html#multi_refl)。
- en: '- (* multi_step *) apply [multi_step](Smallstep.html#multi_step) with ([P](Smallstep.html#P)
    y t[2]).'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: -（* multi_step *）使用 [multi_step](Smallstep.html#multi_step) 和 ([P](Smallstep.html#P)
    y t[2]) 进行应用。
- en: apply [ST_Plus1](Smallstep.html#ST_Plus1). apply H.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 [ST_Plus1](Smallstep.html#ST_Plus1)。应用 H。
- en: apply IHmulti. Qed.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 IHmulti。证毕。
- en: '[PRE51]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Lemma multistep_congr_2 : ∀t[1] t[2] t[2]'','
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 multistep_congr_2：对于所有的 t[1]、t[2] 和 t[2]'，
- en: value t[1] →
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 值 t[1] →
- en: t[2] ⇒* t[2]' →
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: t[2] ⇒* t[2]' →
- en: P t[1] t[2] ⇒* P t[1] t[2]'.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: P t[1] t[2] ⇒* P t[1] t[2]'。
- en: Proof.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 证明。
- en: (* FILL IN HERE *) Admitted.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: （* 在此填写 *）已承��。
- en: '[PRE52]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Theorem step_normalizing :'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 step_normalizing：
- en: normalizing step.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化步骤。
- en: Proof.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 证明。
- en: unfold [normalizing](Smallstep.html#normalizing).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 [normalizing](Smallstep.html#normalizing)。
- en: induction t.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 对 t 进行归纳。
- en: '- (* C *)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: -（* C *）
- en: ∃([C](Smallstep.html#C) n).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: ∃（[C](Smallstep.html#C) n）。
- en: split.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 分割。
- en: + (* l *) apply [multi_refl](Smallstep.html#multi_refl).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: +（* l *）应用 [multi_refl](Smallstep.html#multi_refl)。
- en: + (* r *)
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: +（* r *）
- en: (* We can use rewrite with "iff" statements, not            just equalities: *)
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: （* 我们可以使用“iff”语句进行重写，而不仅仅是相等关系：*）
- en: rewrite [nf_same_as_value](Smallstep.html#nf_same_as_value). apply [v_const](Smallstep.html#v_const).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 [nf_same_as_value](Smallstep.html#nf_same_as_value)。应用 [v_const](Smallstep.html#v_const)。
- en: '- (* P *)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: -（* P *）
- en: destruct IHt1 as [t[1]' [H[11] H[12]]].
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IHt1 分解�� [t[1]' [H[11] H[12]]]。
- en: destruct IHt2 as [t[2]' [H[21] H[22]]].
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 将 IHt2 分解为 [t[2]' [H[21] H[22]]]。
- en: rewrite [nf_same_as_value](Smallstep.html#nf_same_as_value) in H[12]. rewrite
    [nf_same_as_value](Smallstep.html#nf_same_as_value) in H[22].
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H[12] 中重写 [nf_same_as_value](Smallstep.html#nf_same_as_value)。在 H[22] 中重写
    [nf_same_as_value](Smallstep.html#nf_same_as_value)。
- en: inversion H[12] as [n[1] H]. inversion H[22] as [n[2] H'].
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 将 H[12] 反演为 [n[1] H]。将 H[22] 反演为 [n[2] H']。
- en: rewrite ← H in H[11].
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H 中重写 ← H[11]。
- en: rewrite ← H' in H[21].
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在 H' 中重写 ← H[21]。
- en: ∃([C](Smallstep.html#C) (n[1] + n[2])).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ∃（[C](Smallstep.html#C)（n[1] + n[2])）。
- en: split.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 分割。
- en: + (* l *)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: +（* l *）
- en: apply [multi_trans](Smallstep.html#multi_trans) with ([P](Smallstep.html#P)
    ([C](Smallstep.html#C) n[1]) t[2]).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [multi_trans](Smallstep.html#multi_trans) 和 ([P](Smallstep.html#P) ([C](Smallstep.html#C)
    n[1]) t[2]) 进行应用。
- en: '* apply [multistep_congr_1](Smallstep.html#multistep_congr_1). apply H[11].'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '* 应用 [multistep_congr_1](Smallstep.html#multistep_congr_1)。应用 H[11]。'
- en: '* apply [multi_trans](Smallstep.html#multi_trans) with'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '* 使用 [multi_trans](Smallstep.html#multi_trans) 和'
- en: ([P](Smallstep.html#P) ([C](Smallstep.html#C) n[1]) ([C](Smallstep.html#C) n[2])).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: （[P](Smallstep.html#P)（[C](Smallstep.html#C) n[1]）（[C](Smallstep.html#C) n[2])）。
- en: '{ apply [multistep_congr_2](Smallstep.html#multistep_congr_2). apply [v_const](Smallstep.html#v_const).
    apply H[21]. }'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 应用 [multistep_congr_2](Smallstep.html#multistep_congr_2)。应用 [v_const](Smallstep.html#v_const)。应用
    H[21]。 }'
- en: '{ apply [multi_R](Smallstep.html#multi_R). apply [ST_PlusConstConst](Smallstep.html#ST_PlusConstConst).
    }'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '{ 应用 [multi_R](Smallstep.html#multi_R)。应用 [ST_PlusConstConst](Smallstep.html#ST_PlusConstConst)。
    }'
- en: + (* r *)
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: +（* r *）
- en: rewrite [nf_same_as_value](Smallstep.html#nf_same_as_value). apply [v_const](Smallstep.html#v_const).
    Qed.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 [nf_same_as_value](Smallstep.html#nf_same_as_value)。应用 [v_const](Smallstep.html#v_const)。证毕。
- en: '[PRE53]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Theorem eval__multistep : ∀t n,'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 eval__multistep：对于所有的 t 和 n，
- en: t ⇓ n → t ⇒* C n.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: t ⇓ n → t ⇒* C n.
- en: '[PRE54]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: P t[1] t[2] ⇒            (by ST_Plus1)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: P t[1] t[2] ⇒            （通过 ST_Plus1）
- en: P t[1]' t[2] ⇒           (by ST_Plus1)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: P t[1]' t[2] ⇒           （通过 ST_Plus1）
- en: P t[1]'' t[2] ⇒          (by ST_Plus1)
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: P t[1]'' t[2] ⇒          （通过 ST_Plus1）
- en: '...'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: P (C n[1]) t[2] ⇒        (by ST_Plus2)
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: P（C n[1]）t[2] ⇒        （通过 ST_Plus2）
- en: P (C n[1]) t[2]' ⇒       (by ST_Plus2)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: P（C n[1]）t[2]' ⇒       （通过 ST_Plus2）
- en: P (C n[1]) t[2]'' ⇒      (by ST_Plus2)
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: P（C n[1]）t[2]'' ⇒      （通过 ST_Plus2）
- en: '...'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: P (C n[1]) (C n[2]) ⇒    (by ST_PlusConstConst)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: P（C n[1]）（C n[2]） ⇒    （通过 ST_PlusConstConst）
- en: C (n[1] + n[2])
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: C（n[1] + n[2]）
- en: That is, the multistep reduction of a term of the form P t[1] t[2]
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，形式为 P t[1] t[2] 的项的多步规约
- en: 'proceeds in three phases:'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分为三个阶段：
- en: First, we use ST_Plus1 some number of times to reduce t[1] to a normal form,
    which must (by nf_same_as_value) be a term of the form C n[1] for some n[1].
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用一定次数的 ST_Plus1 将 t[1] 减少到一个正常形式，这必须（通过 nf_same_as_value）是形式为 C n[1] 的项，其中
    n[1] 是某个数。
- en: Next, we use ST_Plus2 some number of times to reduce t[2] to a normal form,
    which must again be a term of the form C n[2] for some n[2].
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用一定次数的 ST_Plus2 将 t[2] 减少到一个正常形式，这必须再次是形式为 C n[2] 的项，其中 n[2] 是某个数。
- en: Finally, we use ST_PlusConstConst one time to reduce P (C n[1]) (C n[2]) to
    C (n[1] + n[2]).
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用一次 ST_PlusConstConst 将 P（C n[1]）（C n[2]） 减少为 C（n[1] + n[2]）。
- en: To formalize this intuition, you'll need to use the congruence
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要形式化这种直觉，你需要使用等价关系
- en: lemmas from above (you might want to review them now, so that
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述引理（你可能现在想要复习它们，以便
- en: you'll be able to recognize when they are useful), plus some basic
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将能够识别它们何时有用），再加上一些基本的
- en: 'properties of ⇒*: that it is reflexive, transitive, and'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ⇒* 的性质：它是自反的、传递的和
- en: includes ⇒.
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ☐
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced (eval__multistep_inf)'
  id: totrans-531
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a detailed informal version of the proof of eval__multistep.
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the other direction, we need one lemma, which establishes a
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation between single-step reduction and big-step evaluation.
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (step__eval)'
  id: totrans-537
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ☐
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The fact that small-step reduction implies big-step evaluation is
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: now straightforward to prove, once it is stated correctly.
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The proof proceeds by induction on the multi-step reduction
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sequence that is buried in the hypothesis normal_form_of t t'.
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure you understand the statement before you start to
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: work on the proof.
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (multistep__eval)'
  id: totrans-546
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ☐
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Theorem evalF_eval : ∀t n,'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: evalF t = n ↔ t ⇓ n.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Module Combined.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive tm : Type :='
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '| C : nat → tm'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '| P : tm → tm → tm'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '| ttrue : tm'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '| tfalse : tm'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '| tif : tm → tm → tm → tm.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive value : tm → Prop :='
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '| v_const : ∀n, value (C n)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '| v_true : value ttrue'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '| v_false : value tfalse.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Notation " t '⇒' t' " (at level 40).
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step : tm → tm → Prop :='
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_PlusConstConst : ∀n[1] n[2],'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Plus1 : ∀t[1] t[1]'' t[2],'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: P t[1] t[2] ⇒ P t[1]' t[2]
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Plus2 : ∀v[1] t[2] t[2]'','
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: value v[1] →
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: t[2] ⇒ t[2]' →
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: P v[1] t[2] ⇒ P v[1] t[2]'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IfTrue : ∀t[1] t[2],'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: tif ttrue t[1] t[2] ⇒ t[1]
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IfFalse : ∀t[1] t[2],'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: tif tfalse t[1] t[2] ⇒ t[2]
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_If : ∀t[1] t[1]'' t[2] t[3],'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: tif t[1] t[2] t[3] ⇒ tif t[1]' t[2] t[3]
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: where " t '⇒' t' " := (step t t').
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: (* FILL IN HERE *)
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: End Combined.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Small-Step Imp
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now for a more serious example: a small-step version of the Imp'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: operational semantics.
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The small-step reduction relations for arithmetic and
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: boolean expressions are straightforward extensions of the tiny
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language we've been working up to now.  To make them easier to
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: read, we introduce the symbolic notations ⇒[a] and ⇒[b] for
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the arithmetic and boolean step relations.
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are not actually going to bother to define boolean
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values, since they aren't needed in the definition of ⇒[b]
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: below (why?), though they might be if our language were a bit
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: larger (why?).
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The semantics of commands is the interesting part.  We need two
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'small tricks to make it work:'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use SKIP as a "command value" — i.e., a command that has reached a normal
    form.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assignment command reduces to SKIP (and an updated state).
  id: totrans-606
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequencing command waits until its left-hand subcommand has reduced to SKIP,
    then throws it away so that reduction can continue with the right-hand subcommand.
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We reduce a WHILE command by transforming it into a conditional followed by
    the same WHILE.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (There are other ways of achieving the effect of the latter
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: trick, but they all share the feature that the original WHILE
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command needs to be saved somewhere while a single copy of the loop
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: body is being reduced.)
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Concurrent Imp
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, to show the power of this definitional style, let's
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: enrich Imp with a new form of command that runs two subcommands in
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parallel and terminates when both have terminated.  To reflect the
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并行，并在两者都终止时终止。为了反映
- en: unpredictability of scheduling, the actions of the subcommands may
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调度的不可预测性，子命令的操作可能
- en: be interleaved in any order, but they share the same memory and
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以任何顺序交错进行，但它们共享相同的内存和
- en: can communicate by reading and writing the same variables.
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以通过读写相同的变量进行通信。
- en: '[PRE65]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Among the many interesting properties of this language is the fact
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种语言的许多有趣特性之一是事实
- en: that the following program can terminate with the variable X set
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下程序可以以变量X设置为终止
- en: to any value.
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于任何值。
- en: '[PRE66]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In particular, it can terminate with X set to 0:'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是，它可以以X设置为0终止：
- en: '[PRE67]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'It can also terminate with X set to 2:'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它也可以以X设置为2终止：
- en: '[PRE68]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: More generally...
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更一般地说...
- en: 'Exercise: 3 stars, optional (par_body_n__Sn)'
  id: totrans-631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，可选（par_body_n__Sn）
- en: '[PRE69]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ☐
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: 'Exercise: 3 stars, optional (par_body_n)'
  id: totrans-634
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，可选（par_body_n）
- en: '[PRE70]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ☐
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '... the above loop can exit with X having any value'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...上述循环可以以X具有任何值退出'
- en: whatsoever.
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 丝毫没有。
- en: '[PRE71]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A Small-Step Stack Machine
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个小步栈机器
- en: Our last example is a small-step semantics for the stack machine
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的最后一个示例是栈机器的小步语义
- en: example from the [Imp](Imp.html) chapter.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 来自[Imp](Imp.html)章节的示例。
- en: '[PRE72]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Exercise: 3 stars, advanced (compiler_is_correct)'
  id: totrans-644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习：3星，高级（compiler_is_correct）
- en: Remember the definition of compile for aexp given in the
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住给出aexp编译的定义
- en: '[Imp](Imp.html) chapter. We want now to prove compile correct with respect'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Imp](Imp.html)章节。我们现在想证明编译正确性'
- en: to the stack machine.
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到栈机器。
- en: State what it means for the compiler to be correct according to
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 说明编译器正确的含义是什么
- en: the stack machine small step semantics and then prove it.
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 栈机器的小步语义，然后证明它。
- en: '[PRE73]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ☐
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ☐
- en: '[PRE74]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
