- en: SmallstepSmall-step Operational Semantics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Coq.Arith.Arith.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Arith.EqNat.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.omega.Omega.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Coq.Lists.List.
  prefs: []
  type: TYPE_NORMAL
- en: Import ListNotations.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Maps.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A Toy Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To save space in the discussion, let's go back to an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: incredibly simple language containing just constants and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: addition.  (We use single letters — C and P (for Command and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Plus) — as constructor names, for brevity.)  At the end of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: chapter, we'll see how to apply the same techniques to the full
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Imp language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here is a standard evaluator for this language, written in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the big-step style that we've been using up to this point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here is the same evaluator, written in exactly the same
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: style, but formulated as an inductively defined relation.  Again,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we use the notation t ⇓ n for "t evaluates to n."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (E_Const)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: C n ⇓ n
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: t[1] ⇓ n[1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: t[2] ⇓ n[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (E_Plus)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P t[1] t[2] ⇓ n[1] + n[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, here is the corresponding *small-step* evaluation relation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (ST_PlusConstConst)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (ST_Plus1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P t[1] t[2] ⇒ P t[1]' t[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: t[2] ⇒ t[2]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (ST_Plus2)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P (C n[1]) t[2] ⇒ P (C n[1]) t[2]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Things to notice:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are defining just a single reduction step, in which one P node is replaced
    by its value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each step finds the *leftmost* P node that is ready to go (both of its operands
    are constants) and rewrites it in place. The first rule tells how to rewrite this
    P node itself; the other two rules tell how to find it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A term that is just a constant cannot take a step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's pause and check a couple of examples of reasoning with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the step relation...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If t[1] can take a step to t[1]', then P t[1] t[2] steps
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'to P t[1]'' t[2]:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (test_step_2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Right-hand sides of sums can take a step only when the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'left-hand side is finished: if t[2] can take a step to t[2]'','
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'then P (C n) t[2] steps to P (C n) t[2]'':'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be working with several different single-step relations,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: so it is helpful to generalize a bit and state a few definitions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and theorems about relations in general.  (The optional chapter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Rel.v develops some of these ideas in a bit more detail; it may
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: be useful if the treatment here is too dense.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A *binary relation* on a set X is a family of propositions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parameterized by two elements of X — i.e., a proposition about
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pairs of elements of X.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our main examples of such relations in this chapter will be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the single-step reduction relation, ⇒, and its multi-step
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variant, ⇒* (defined below), but there are many other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: examples — e.g., the "equals," "less than," "less than or equal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to," and "is the square of" relations on numbers, and the "prefix
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of" relation on lists and strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One simple property of the ⇒ relation is that, like the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: big-step evaluation relation for Imp, it is *deterministic*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Theorem*: For each t, there is at most one t'' such that t'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: steps to t' (t ⇒ t' is provable).  Formally, this is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: same as saying that ⇒ is deterministic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Proof sketch*: We show that if x steps to both y[1] and'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: y[2], then y[1] and y[2] are equal, by induction on a derivation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of step x y[1].  There are several cases to consider, depending on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the last rule used in this derivation and the last rule in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: given derivation of step x y[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If both are ST_PlusConstConst, the result is immediate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cases when both derivations end with ST_Plus1 or ST_Plus2 follow by the
    induction hypothesis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot happen that one is ST_PlusConstConst and the other is ST_Plus1 or
    ST_Plus2, since this would imply that x has the form P t[1] t[2] where both t[1]
    and t[2] are constants (by ST_PlusConstConst) *and* one of t[1] or t[2] has the
    form P _.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, it cannot happen that one is ST_Plus1 and the other is ST_Plus2,
    since this would imply that x has the form P t[1] t[2] where t[1] has both the
    form P t[11] t[12] and the form C n. ☐
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Formally:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is some annoying repetition in this proof.  Each use of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inversion Hy[2] results in three subcases, only one of which is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relevant (the one that matches the current case in the induction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: on Hy[1]).  The other two subcases need to be dismissed by finding
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the contradiction among the hypotheses and doing inversion on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The following custom tactic, called solve_by_inverts, can be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: helpful in such cases.  It will solve the goal if it can be solved
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by inverting some hypothesis; otherwise, it fails.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The details of how this works are not important for now, but it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: illustrates the power of Coq's Ltac language for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: programmatically defining special-purpose tactics.  It looks
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: through the current proof state for a hypothesis H (the first
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: match) of type Prop (the second match) such that performing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inversion on H (followed by a recursive invocation of the same
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tactic, if its argument n is greater than one) completely solves
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the current goal.  If no such hypothesis exists, it fails.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will usually want to call solve_by_inverts with argument
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 (especially as larger arguments can lead to very slow proof
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: checking), so we define solve_by_invert as a shorthand for this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how a proof of the previous theorem can be simplified
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using this tactic...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, it will be useful to slightly reformulate the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition of single-step reduction by stating it in terms of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"values."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is useful to think of the ⇒ relation as defining an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*abstract machine*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At any moment, the *state* of the machine is a term.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *step* of the machine is an atomic unit of computation — here, a single "add"
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *halting states* of the machine are ones where there is no more computation
    to be done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then execute a term t as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take t as the starting state of the machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeatedly use the ⇒ relation to find a sequence of machine states, starting
    with t, where each state steps to the next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When no more reduction is possible, "read out" the final state of the machine
    as the result of execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intuitively, it is clear that the final states of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: machine are always terms of the form C n for some n.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We call such terms *values*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Having introduced the idea of values, we can use it in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition of the ⇒ relation to write ST_Plus2 rule in a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'slightly more elegant way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (ST_PlusConstConst)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (ST_Plus1)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P t[1] t[2] ⇒ P t[1]' t[2]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: value v[1]
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: t[2] ⇒ t[2]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (ST_Plus2)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: P v[1] t[2] ⇒ P v[1] t[2]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Again, the variable names here carry important information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: by convention, v[1] ranges only over values, while t[1] and t[2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: range over arbitrary terms.  (Given this convention, the explicit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: value hypothesis is arguably redundant.  We'll keep it for now,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to maintain a close correspondence between the informal and Coq
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: versions of the rules, but later on we'll drop it in informal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rules for brevity.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here are the formal rules:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, recommended (redo_determinism)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a sanity check on this change, let's re-verify determinism.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Proof sketch*: We must show that if x steps to both y[1] and'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: y[2], then y[1] and y[2] are equal.  Consider the final rules used
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the derivations of step x y[1] and step x y[2].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If both are ST_PlusConstConst, the result is immediate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot happen that one is ST_PlusConstConst and the other is ST_Plus1 or
    ST_Plus2, since this would imply that x has the form P t[1] t[2] where both t[1]
    and t[2] are constants (by ST_PlusConstConst) *and* one of t[1] or t[2] has the
    form P _.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, it cannot happen that one is ST_Plus1 and the other is ST_Plus2,
    since this would imply that x has the form P t[1] t[2] where t[1] both has the
    form P t[11] t[12] and is a value (hence has the form C n).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cases when both derivations end with ST_Plus1 or ST_Plus2 follow by the
    induction hypothesis. ☐
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of this proof is the same as the one above.  But to get
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: maximum benefit from the exercise you should try to write your
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: formal version from scratch and just use the earlier one if you
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get stuck.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem strong_progress : ∀t,'
  prefs: []
  type: TYPE_NORMAL
- en: value t ∨ (∃t', t ⇒ t').
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction t.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* C *) left. apply [v_const](Smallstep.html#v_const).'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* P *) right. inversion IHt1.'
  prefs: []
  type: TYPE_NORMAL
- en: + (* l *) inversion IHt2.
  prefs: []
  type: TYPE_NORMAL
- en: '* (* l *) inversion H. inversion H[0].'
  prefs: []
  type: TYPE_NORMAL
- en: ∃([C](Smallstep.html#C) (n + n[0])).
  prefs: []
  type: TYPE_NORMAL
- en: apply [ST_PlusConstConst](Smallstep.html#ST_PlusConstConst).
  prefs: []
  type: TYPE_NORMAL
- en: '* (* r *) inversion H[0] as [t'' H[1]].'
  prefs: []
  type: TYPE_NORMAL
- en: ∃([P](Smallstep.html#P) t[1] t').
  prefs: []
  type: TYPE_NORMAL
- en: apply [ST_Plus2](Smallstep.html#ST_Plus2). apply H. apply H[1].
  prefs: []
  type: TYPE_NORMAL
- en: + (* r *) inversion H as [t' H[0]].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([P](Smallstep.html#P) t' t[2]).
  prefs: []
  type: TYPE_NORMAL
- en: apply [ST_Plus1](Smallstep.html#ST_Plus1). apply H[0]. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Definition normal_form {X:Type} (R:relation X) (t:X) : Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: ¬ ∃t', R t t'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma value_is_nf : ∀v,'
  prefs: []
  type: TYPE_NORMAL
- en: value v → normal_form step v.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold [normal_form](Smallstep.html#normal_form). intros v H. inversion H.
  prefs: []
  type: TYPE_NORMAL
- en: intros contra. inversion contra. inversion H[1].
  prefs: []
  type: TYPE_NORMAL
- en: Qed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Lemma nf_is_value : ∀t,'
  prefs: []
  type: TYPE_NORMAL
- en: normal_form step t → value t.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. (* a corollary of strong_progress... *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold [normal_form](Smallstep.html#normal_form). intros t H.
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (G : [value](Smallstep.html#value) t ∨ ∃t'', t ⇒ [t''](Smallstep.html#t'')).'
  prefs: []
  type: TYPE_NORMAL
- en: '{ apply [strong_progress](Smallstep.html#strong_progress). }'
  prefs: []
  type: TYPE_NORMAL
- en: inversion G.
  prefs: []
  type: TYPE_NORMAL
- en: + (* l *) apply H[0].
  prefs: []
  type: TYPE_NORMAL
- en: + (* r *) exfalso. apply H. assumption. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Corollary nf_same_as_value : ∀t,'
  prefs: []
  type: TYPE_NORMAL
- en: normal_form step t ↔ value t.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: split. apply [nf_is_value](Smallstep.html#nf_is_value). apply [value_is_nf](Smallstep.html#value_is_nf).
    Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Module Temp1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive value : tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| v_const : ∀n, value (C n)'
  prefs: []
  type: TYPE_NORMAL
- en: '| v_funny : ∀t[1] n[2],                       (* <---- *)'
  prefs: []
  type: TYPE_NORMAL
- en: value (P t[1] (C n[2])).
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Notation " t '⇒' t' " (at level 40).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step : tm → tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_PlusConstConst : ∀n[1] n[2],'
  prefs: []
  type: TYPE_NORMAL
- en: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Plus1 : ∀t[1] t[1]'' t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: P t[1] t[2] ⇒ P t[1]' t[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Plus2 : ∀v[1] t[2] t[2]'','
  prefs: []
  type: TYPE_NORMAL
- en: value v[1] →
  prefs: []
  type: TYPE_NORMAL
- en: t[2] ⇒ t[2]' →
  prefs: []
  type: TYPE_NORMAL
- en: P v[1] t[2] ⇒ P v[1] t[2]'
  prefs: []
  type: TYPE_NORMAL
- en: where " t '⇒' t' " := (step t t').
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma value_not_same_as_normal_form :'
  prefs: []
  type: TYPE_NORMAL
- en: ∃v, value v ∧ ¬ normal_form step v.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: End Temp1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 2 stars, optional (value_not_same_as_normal_form2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Alternatively, we might mistakenly define step so that it
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: permits something designated as a value to reduce further.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (value_not_same_as_normal_form3)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we might define value and step so that there is some
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: term that is not a value but that cannot take a step in the step
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation.  Such terms are said to be *stuck*. In this case this is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: caused by a mistake in the semantics, but we will also see
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: situations where, even in a correct language definition, it makes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sense to allow some terms to be stuck.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: (Note that ST_Plus2 is missing.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Module Temp4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive tm : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ttrue : tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tfalse : tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tif : tm → tm → tm → tm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive value : tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| v_true : value ttrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| v_false : value tfalse.'
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Notation " t '⇒' t' " (at level 40).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step : tm → tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IfTrue : ∀t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: tif ttrue t[1] t[2] ⇒ t[1]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IfFalse : ∀t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: tif tfalse t[1] t[2] ⇒ t[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_If : ∀t[1] t[1]'' t[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: tif t[1] t[2] t[3] ⇒ tif t[1]' t[2] t[3]
  prefs: []
  type: TYPE_NORMAL
- en: where " t '⇒' t' " := (step t t').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Definition bool_step_prop1 :=
  prefs: []
  type: TYPE_NORMAL
- en: tfalse ⇒ tfalse.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: Definition bool_step_prop2 :=
  prefs: []
  type: TYPE_NORMAL
- en: tif
  prefs: []
  type: TYPE_NORMAL
- en: ttrue
  prefs: []
  type: TYPE_NORMAL
- en: (tif ttrue ttrue ttrue)
  prefs: []
  type: TYPE_NORMAL
- en: (tif tfalse tfalse tfalse)
  prefs: []
  type: TYPE_NORMAL
- en: ⇒
  prefs: []
  type: TYPE_NORMAL
- en: ttrue.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: Definition bool_step_prop3 :=
  prefs: []
  type: TYPE_NORMAL
- en: tif
  prefs: []
  type: TYPE_NORMAL
- en: (tif ttrue ttrue ttrue)
  prefs: []
  type: TYPE_NORMAL
- en: (tif ttrue ttrue ttrue)
  prefs: []
  type: TYPE_NORMAL
- en: tfalse
  prefs: []
  type: TYPE_NORMAL
- en: ⇒
  prefs: []
  type: TYPE_NORMAL
- en: tif
  prefs: []
  type: TYPE_NORMAL
- en: ttrue
  prefs: []
  type: TYPE_NORMAL
- en: (tif ttrue ttrue ttrue)
  prefs: []
  type: TYPE_NORMAL
- en: tfalse.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem strong_progress : ∀t,'
  prefs: []
  type: TYPE_NORMAL
- en: value t ∨ (∃t', t ⇒ t').
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem step_deterministic :'
  prefs: []
  type: TYPE_NORMAL
- en: deterministic step.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Module Temp5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: tif
  prefs: []
  type: TYPE_NORMAL
- en: (tif ttrue ttrue ttrue)
  prefs: []
  type: TYPE_NORMAL
- en: tfalse
  prefs: []
  type: TYPE_NORMAL
- en: tfalse
  prefs: []
  type: TYPE_NORMAL
- en: ⇒
  prefs: []
  type: TYPE_NORMAL
- en: tfalse.
  prefs: []
  type: TYPE_NORMAL
- en: Write an extra clause for the step relation that achieves this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: effect and prove bool_step_prop4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (properties_of_altered_step)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It can be shown that the determinism and strong progress theorems
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for the step relation in the lecture notes also hold for the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: definition of step given above.  After we add the clause
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ST_ShortCircuit...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Is the step relation still deterministic? Write yes or no and briefly (1 sentence)
    explain your answer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: prove your answer correct in Coq.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Does a strong progress theorem hold? Write yes or no and briefly (1 sentence)
    explain your answer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: prove your answer correct in Coq.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In general, is there any way we could cause strong progress to fail if we took
    away one or more constructors from the original step relation? Write yes or no
    and briefly (1 sentence) explain your answer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Multi-Step Reduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been working so far with the *single-step reduction*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation ⇒, which formalizes the individual steps of an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: abstract machine for executing programs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use the same machine to reduce programs to completion — to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: find out what final result they yield.  This can be formalized as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we define a *multi-step reduction relation* ⇒*, which relates terms t
    and t' if t can reach t' by any number (including zero) of single reduction steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we define a "result" of a term t as a normal form that t can reach by multi-step
    reduction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive multi {X:Type} (R: relation X) : relation X :='
  prefs: []
  type: TYPE_NORMAL
- en: '| multi_refl  : ∀(x : X), multi R x x'
  prefs: []
  type: TYPE_NORMAL
- en: '| multi_step : ∀(x y z : X),'
  prefs: []
  type: TYPE_NORMAL
- en: R x y →
  prefs: []
  type: TYPE_NORMAL
- en: multi R y z →
  prefs: []
  type: TYPE_NORMAL
- en: multi R x z.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: R x z[1]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: R z[1] z[2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: R zn y.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notation " t '⇒*' t' " := (multi step t t') (at level 40).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem multi_R : ∀(X:Type) (R:relation X) (x y : X),'
  prefs: []
  type: TYPE_NORMAL
- en: R x y → (multi R) x y.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros X R x y H.
  prefs: []
  type: TYPE_NORMAL
- en: apply [multi_step](Smallstep.html#multi_step) with y. apply H. apply [multi_refl](Smallstep.html#multi_refl).
    Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem multi_trans :'
  prefs: []
  type: TYPE_NORMAL
- en: '∀(X:Type) (R: relation X) (x y z : X),'
  prefs: []
  type: TYPE_NORMAL
- en: multi R x y  →
  prefs: []
  type: TYPE_NORMAL
- en: multi R y z →
  prefs: []
  type: TYPE_NORMAL
- en: multi R x z.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros X R x y z G H.
  prefs: []
  type: TYPE_NORMAL
- en: induction G.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* multi_refl *) assumption.'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* multi_step *)'
  prefs: []
  type: TYPE_NORMAL
- en: apply [multi_step](Smallstep.html#multi_step) with y. assumption.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHG. assumption. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s a specific instance of the multi step relation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here's an alternate proof of the same fact that uses eapply to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: avoid explicitly constructing all the intermediate terms.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star, optional (test_multistep_2)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star, optional (test_multistep_3)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (test_multistep_4)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Definition step_normal_form := normal_form step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition normal_form_of (t t'' : tm) :='
  prefs: []
  type: TYPE_NORMAL
- en: (t ⇒* t' ∧ step_normal_form t').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem normal_forms_unique:'
  prefs: []
  type: TYPE_NORMAL
- en: deterministic normal_form_of.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* We recommend using this initial setup as-is! *)
  prefs: []
  type: TYPE_NORMAL
- en: unfold deterministic. unfold normal_form_of.
  prefs: []
  type: TYPE_NORMAL
- en: intros x y[1] y[2] P[1] P[2].
  prefs: []
  type: TYPE_NORMAL
- en: inversion P[1] as [P[11] P[12]]; clear P[1].
  prefs: []
  type: TYPE_NORMAL
- en: inversion P[2] as [P[21] P[22]]; clear P[2].
  prefs: []
  type: TYPE_NORMAL
- en: generalize dependent y[2].
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Definition normalizing {X:Type} (R:relation X) :=
  prefs: []
  type: TYPE_NORMAL
- en: ∀t, ∃t',
  prefs: []
  type: TYPE_NORMAL
- en: (multi R) t t' ∧ normal_form R t'.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma multistep_congr_1 : ∀t[1] t[1]'' t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒* t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: P t[1] t[2] ⇒* P t[1]' t[2].
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros t[1] t[1]' t[2] H. induction H.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* multi_refl *) apply [multi_refl](Smallstep.html#multi_refl).'
  prefs: []
  type: TYPE_NORMAL
- en: '- (* multi_step *) apply [multi_step](Smallstep.html#multi_step) with ([P](Smallstep.html#P)
    y t[2]).'
  prefs: []
  type: TYPE_NORMAL
- en: apply [ST_Plus1](Smallstep.html#ST_Plus1). apply H.
  prefs: []
  type: TYPE_NORMAL
- en: apply IHmulti. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma multistep_congr_2 : ∀t[1] t[2] t[2]'','
  prefs: []
  type: TYPE_NORMAL
- en: value t[1] →
  prefs: []
  type: TYPE_NORMAL
- en: t[2] ⇒* t[2]' →
  prefs: []
  type: TYPE_NORMAL
- en: P t[1] t[2] ⇒* P t[1] t[2]'.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem step_normalizing :'
  prefs: []
  type: TYPE_NORMAL
- en: normalizing step.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unfold [normalizing](Smallstep.html#normalizing).
  prefs: []
  type: TYPE_NORMAL
- en: induction t.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* C *)'
  prefs: []
  type: TYPE_NORMAL
- en: ∃([C](Smallstep.html#C) n).
  prefs: []
  type: TYPE_NORMAL
- en: split.
  prefs: []
  type: TYPE_NORMAL
- en: + (* l *) apply [multi_refl](Smallstep.html#multi_refl).
  prefs: []
  type: TYPE_NORMAL
- en: + (* r *)
  prefs: []
  type: TYPE_NORMAL
- en: (* We can use rewrite with "iff" statements, not            just equalities: *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [nf_same_as_value](Smallstep.html#nf_same_as_value). apply [v_const](Smallstep.html#v_const).
  prefs: []
  type: TYPE_NORMAL
- en: '- (* P *)'
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHt1 as [t[1]' [H[11] H[12]]].
  prefs: []
  type: TYPE_NORMAL
- en: destruct IHt2 as [t[2]' [H[21] H[22]]].
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [nf_same_as_value](Smallstep.html#nf_same_as_value) in H[12]. rewrite
    [nf_same_as_value](Smallstep.html#nf_same_as_value) in H[22].
  prefs: []
  type: TYPE_NORMAL
- en: inversion H[12] as [n[1] H]. inversion H[22] as [n[2] H'].
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H in H[11].
  prefs: []
  type: TYPE_NORMAL
- en: rewrite ← H' in H[21].
  prefs: []
  type: TYPE_NORMAL
- en: ∃([C](Smallstep.html#C) (n[1] + n[2])).
  prefs: []
  type: TYPE_NORMAL
- en: split.
  prefs: []
  type: TYPE_NORMAL
- en: + (* l *)
  prefs: []
  type: TYPE_NORMAL
- en: apply [multi_trans](Smallstep.html#multi_trans) with ([P](Smallstep.html#P)
    ([C](Smallstep.html#C) n[1]) t[2]).
  prefs: []
  type: TYPE_NORMAL
- en: '* apply [multistep_congr_1](Smallstep.html#multistep_congr_1). apply H[11].'
  prefs: []
  type: TYPE_NORMAL
- en: '* apply [multi_trans](Smallstep.html#multi_trans) with'
  prefs: []
  type: TYPE_NORMAL
- en: ([P](Smallstep.html#P) ([C](Smallstep.html#C) n[1]) ([C](Smallstep.html#C) n[2])).
  prefs: []
  type: TYPE_NORMAL
- en: '{ apply [multistep_congr_2](Smallstep.html#multistep_congr_2). apply [v_const](Smallstep.html#v_const).
    apply H[21]. }'
  prefs: []
  type: TYPE_NORMAL
- en: '{ apply [multi_R](Smallstep.html#multi_R). apply [ST_PlusConstConst](Smallstep.html#ST_PlusConstConst).
    }'
  prefs: []
  type: TYPE_NORMAL
- en: + (* r *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite [nf_same_as_value](Smallstep.html#nf_same_as_value). apply [v_const](Smallstep.html#v_const).
    Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem eval__multistep : ∀t n,'
  prefs: []
  type: TYPE_NORMAL
- en: t ⇓ n → t ⇒* C n.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: P t[1] t[2] ⇒            (by ST_Plus1)
  prefs: []
  type: TYPE_NORMAL
- en: P t[1]' t[2] ⇒           (by ST_Plus1)
  prefs: []
  type: TYPE_NORMAL
- en: P t[1]'' t[2] ⇒          (by ST_Plus1)
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: P (C n[1]) t[2] ⇒        (by ST_Plus2)
  prefs: []
  type: TYPE_NORMAL
- en: P (C n[1]) t[2]' ⇒       (by ST_Plus2)
  prefs: []
  type: TYPE_NORMAL
- en: P (C n[1]) t[2]'' ⇒      (by ST_Plus2)
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: P (C n[1]) (C n[2]) ⇒    (by ST_PlusConstConst)
  prefs: []
  type: TYPE_NORMAL
- en: C (n[1] + n[2])
  prefs: []
  type: TYPE_NORMAL
- en: That is, the multistep reduction of a term of the form P t[1] t[2]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'proceeds in three phases:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, we use ST_Plus1 some number of times to reduce t[1] to a normal form,
    which must (by nf_same_as_value) be a term of the form C n[1] for some n[1].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we use ST_Plus2 some number of times to reduce t[2] to a normal form,
    which must again be a term of the form C n[2] for some n[2].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use ST_PlusConstConst one time to reduce P (C n[1]) (C n[2]) to
    C (n[1] + n[2]).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To formalize this intuition, you'll need to use the congruence
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lemmas from above (you might want to review them now, so that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: you'll be able to recognize when they are useful), plus some basic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'properties of ⇒*: that it is reflexive, transitive, and'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: includes ⇒.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, advanced (eval__multistep_inf)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a detailed informal version of the proof of eval__multistep.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the other direction, we need one lemma, which establishes a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: relation between single-step reduction and big-step evaluation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (step__eval)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The fact that small-step reduction implies big-step evaluation is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: now straightforward to prove, once it is stated correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The proof proceeds by induction on the multi-step reduction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sequence that is buried in the hypothesis normal_form_of t t'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure you understand the statement before you start to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: work on the proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars (multistep__eval)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem evalF_eval : ∀t n,'
  prefs: []
  type: TYPE_NORMAL
- en: evalF t = n ↔ t ⇓ n.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: (* FILL IN HERE *) Admitted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Module Combined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive tm : Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| C : nat → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| P : tm → tm → tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| ttrue : tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tfalse : tm'
  prefs: []
  type: TYPE_NORMAL
- en: '| tif : tm → tm → tm → tm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive value : tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| v_const : ∀n, value (C n)'
  prefs: []
  type: TYPE_NORMAL
- en: '| v_true : value ttrue'
  prefs: []
  type: TYPE_NORMAL
- en: '| v_false : value tfalse.'
  prefs: []
  type: TYPE_NORMAL
- en: Reserved Notation " t '⇒' t' " (at level 40).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inductive step : tm → tm → Prop :='
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_PlusConstConst : ∀n[1] n[2],'
  prefs: []
  type: TYPE_NORMAL
- en: P (C n[1]) (C n[2]) ⇒ C (n[1] + n[2])
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Plus1 : ∀t[1] t[1]'' t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: P t[1] t[2] ⇒ P t[1]' t[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_Plus2 : ∀v[1] t[2] t[2]'','
  prefs: []
  type: TYPE_NORMAL
- en: value v[1] →
  prefs: []
  type: TYPE_NORMAL
- en: t[2] ⇒ t[2]' →
  prefs: []
  type: TYPE_NORMAL
- en: P v[1] t[2] ⇒ P v[1] t[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IfTrue : ∀t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: tif ttrue t[1] t[2] ⇒ t[1]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_IfFalse : ∀t[1] t[2],'
  prefs: []
  type: TYPE_NORMAL
- en: tif tfalse t[1] t[2] ⇒ t[2]
  prefs: []
  type: TYPE_NORMAL
- en: '| ST_If : ∀t[1] t[1]'' t[2] t[3],'
  prefs: []
  type: TYPE_NORMAL
- en: t[1] ⇒ t[1]' →
  prefs: []
  type: TYPE_NORMAL
- en: tif t[1] t[2] t[3] ⇒ tif t[1]' t[2] t[3]
  prefs: []
  type: TYPE_NORMAL
- en: where " t '⇒' t' " := (step t t').
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: End Combined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Small-Step Imp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now for a more serious example: a small-step version of the Imp'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: operational semantics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The small-step reduction relations for arithmetic and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: boolean expressions are straightforward extensions of the tiny
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: language we've been working up to now.  To make them easier to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: read, we introduce the symbolic notations ⇒[a] and ⇒[b] for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the arithmetic and boolean step relations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We are not actually going to bother to define boolean
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: values, since they aren't needed in the definition of ⇒[b]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: below (why?), though they might be if our language were a bit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: larger (why?).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The semantics of commands is the interesting part.  We need two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'small tricks to make it work:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We use SKIP as a "command value" — i.e., a command that has reached a normal
    form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assignment command reduces to SKIP (and an updated state).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The sequencing command waits until its left-hand subcommand has reduced to SKIP,
    then throws it away so that reduction can continue with the right-hand subcommand.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We reduce a WHILE command by transforming it into a conditional followed by
    the same WHILE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (There are other ways of achieving the effect of the latter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: trick, but they all share the feature that the original WHILE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command needs to be saved somewhere while a single copy of the loop
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: body is being reduced.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Concurrent Imp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, to show the power of this definitional style, let's
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: enrich Imp with a new form of command that runs two subcommands in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: parallel and terminates when both have terminated.  To reflect the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: unpredictability of scheduling, the actions of the subcommands may
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: be interleaved in any order, but they share the same memory and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: can communicate by reading and writing the same variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Among the many interesting properties of this language is the fact
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: that the following program can terminate with the variable X set
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to any value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In particular, it can terminate with X set to 0:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also terminate with X set to 2:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: More generally...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (par_body_n__Sn)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (par_body_n)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '... the above loop can exit with X having any value'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: whatsoever.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: A Small-Step Stack Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last example is a small-step semantics for the stack machine
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: example from the [Imp](Imp.html) chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 3 stars, advanced (compiler_is_correct)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember the definition of compile for aexp given in the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Imp](Imp.html) chapter. We want now to prove compile correct with respect'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to the stack machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: State what it means for the compiler to be correct according to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the stack machine small step semantics and then prove it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
