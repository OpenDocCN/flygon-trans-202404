- en: 'Recitation 11: Functional Arrays'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the data structures we have covered in this course so far are *functional*.
    You can access old versions of these data structure, even when you update them.
    For example, you can cons an element onto a list without affecting references
    to the original list.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen efficient functional implementations for stacks, queues, and binary
    trees. Can we come up with an efficient implementation of functional arrays, too?
    It turns out that we can, but we will need to use imperative language features.
    Our array will be implemented using an OCaml array for efficiency, but we need
    to be careful that updates to the array do not affect previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: First attempt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's define the `set` function so that it makes a copy of the array it was
    given, then updates the copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This array is purely functional, but it's slow, because we make a new array
    every time call `set`.
  prefs: []
  type: TYPE_NORMAL
- en: Second attempt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say we execute `FunArray.set a i x`. Let's imperatively set `a.(i) <- x<=""
    code="">. Then, let's update all of the old references to `a` so that they point
    to the old version of `a`.`
  prefs: []
  type: TYPE_NORMAL
- en: '`How are we going to update the old references to `a`? One idea is to make
    `''a t` a `ref`. Every time `FunArray.set` is called, we change the value stored
    at `a` so that it has the same mappings as the original array. Thus the old references
    to `a` will still refer to the old version of `a`, even though the underlying
    array is different.`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`An array can either be an `Arr(arr)`, which has the same mappings as the OCaml
    array `arr`, or it can be a `Diff(i, x, a'')`, which has all of the same mappings
    as the functional array a'', exception with the mapping `i -> x`. We then define
    the type `''a t` so that it is a `ref` to a value of type `data`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting a value from such an array is simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the array points to an `Arr(arr)`, then we just look up the given index in
    `arr`. If it points to a `Diff(j, x, a')`, then we see if `j` is the index we
    are searching for. If it is, then we return `x`, the value it maps to.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a value is more complicated
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If `a` points to a `Diff`, then we return a reference to a new `Diff` which
    maps `i` to `x`.
  prefs: []
  type: TYPE_NORMAL
- en: If `a` points to an `Arr(arr)`, then we imperatively set `arr.(i) <- x<="" code="">.
    This operation invalidates the old references to `a`. These old references to
    `a` ought to refer to the old version of `a` before the update. To get around
    this problem, we add a level of indirection. We update the value stored at `a`
    so that it contains a `Diff` preserving the old mapping of `i`.`
  prefs: []
  type: TYPE_NORMAL
- en: '`Rerooting`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Our implementation is efficient for accessing the most recent version of an
    array. However, accessing old versions of the array are slow, because you have
    to traverse a list of `Diff` nodes before you reach the `Arr`. There will be one
    of these `Diff` nodes per update.'
  prefs: []
  type: TYPE_NORMAL
- en: We can improve performance when a user stops using the newest version of the
    array and starts using an old version instead (for example, in a backtracking
    algorithm). Every time a user sets or gets an element of an array `a`, we reverse
    the list of `Diff` nodes on the path to the `Arr` so that `a` points directly
    to the `Arr`. This operation is known as *rerooting*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Every time the user calls `get` or `set`, we reroot the tree. Note that this
    implementation is still inefficient for some use cases. If a user frequently accesses
    many different versions of an array, then rerooting will occur every time, and
    performance will suffer. Another problem is that our definition of `reroot` is
    not tail recursive (it is possible to fix this problem).
  prefs: []
  type: TYPE_NORMAL
- en: For more details, please see [this paper](http://www.lri.fr/~filliatr/ftp/publis/puf-wml07.ps)
    on which this recitation is based. They use functional arrays to implement a functional
    disjoint set, a data structure that we will cover later in the course.
  prefs: []
  type: TYPE_NORMAL
- en: Here is our final implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]``'
  prefs: []
  type: TYPE_NORMAL
