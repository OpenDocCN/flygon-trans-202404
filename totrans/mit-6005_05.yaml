- en: 'Reading 5: Version Control'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Know what version control is and why we use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how Git stores version history as a graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practice reading, creating, and using version history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Version control systems](http://en.wikipedia.org/wiki/Revision_control) are
    essential tools of the software engineering world. More or less every project
    — serious or hobby, open source or proprietary — uses version control. Without
    version control, coordinating a team of programmers all editing the same project’s
    code will reach pull-out-your-hair levels of aggravation.'
  prefs: []
  type: TYPE_NORMAL
- en: Version control systems you’ve already used
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dropbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Undo/redo buffer](http://en.wikipedia.org/wiki/Undo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping multiple copies of files with version numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg) | ![](../Images/7428bd5cc9ff3bf86b3ae95018eee73f.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Project Report | Project Report v2 | Project Report v3 | Project Report final
    | Project Report final-v2 | Project Report final-v2-fix-part-5 |'
  prefs: []
  type: TYPE_TB
- en: Inventing version control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose [Alice](http://en.wikipedia.org/wiki/Alice_and_Bob) is working on a
    problem set by herself.
  prefs: []
  type: TYPE_NORMAL
- en: '|   Alice | Version 1  Hello.java |'
  prefs: []
  type: TYPE_TB
- en: She starts with one file `Hello.java` in her pset, which she works on for several
    days.
  prefs: []
  type: TYPE_NORMAL
- en: At the last minute before she needs to hand in her pset to be graded, she realizes
    she has made a change that breaks everything. If only she could go back in time
    and retrieve a past version!
  prefs: []
  type: TYPE_NORMAL
- en: A simple discipline of saving backup files would get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: '|   Alice | Version 1  Hello.1.java | Version 2  Hello.2.java | Version 3  Hello.java
    |  HEAD |'
  prefs: []
  type: TYPE_TB
- en: Alice uses her judgment to decide when she has reached some milestone that justifies
    saving the code. She saves the versions of `Hello.java` as `Hello.1.java`, `Hello.2.java`,
    and `Hello.java`. She follows the convention that the most recent version is just
    `Hello.java` to avoid confusing Eclipse. We will call the most recent version
    the *head*.
  prefs: []
  type: TYPE_NORMAL
- en: Now when Alice realizes that version 3 is fatally flawed, she can just copy
    version 2 back into the location for her current code. Disaster averted! But what
    if version 3 included some changes that were good and some that were bad? Alice
    can compare the files manually to find the changes, and sort them into good and
    bad changes. Then she can copy the good changes into version 2.
  prefs: []
  type: TYPE_NORMAL
- en: This is a lot of work, and it’s easy for the human eye to miss changes. Luckily,
    there are standard software tools for comparing text; in the UNIX world, one such
    tool is [`diff`](http://en.wikipedia.org/wiki/Diff). A better version control
    system will make diffs easy to generate.
  prefs: []
  type: TYPE_NORMAL
- en: '|   Cloud | Version 1  Hello.1.java | Version 2  Hello.2.java | Version 3  Hello.java
    |'
  prefs: []
  type: TYPE_TB
- en: '|  |'
  prefs: []
  type: TYPE_TB
- en: '|   Alice | Version 1  Hello.1.java | Version 2  Hello.2.java | Version 3  Hello.java
    |'
  prefs: []
  type: TYPE_TB
- en: Alice also wants to be prepared in case her laptop gets run over by a bus, so
    she saves a backup of her work in the cloud, uploading the contents of her working
    directory whenever she’s satisfied with its contents.
  prefs: []
  type: TYPE_NORMAL
- en: If her laptop is kicked into the Charles, Alice can retrieve the backup and
    resume work on the pset on a fresh machine, retaining the ability to time-travel
    back to old versions at will.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, she can develop her pset on multiple machines, using the cloud
    provider as a common interchange point. Alice makes some changes on her laptop
    and uploads them to the cloud. Then she downloads onto her desktop machine at
    home, does some more work, and uploads the improved code (complete with old file
    versions) back to the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  Cloud |'
  prefs: []
  type: TYPE_TB
- en: '|  |    |  |'
  prefs: []
  type: TYPE_TB
- en: '| Version 5L  Hello.java |  Alice on laptop |  |  Alice on desktop | Version
    5D  Hello.java |'
  prefs: []
  type: TYPE_TB
- en: If Alice isn’t careful, though, she can run into trouble with this approach.
    Imagine that she starts editing `Hello.java` to create “version 5” on her laptop.
    Then she gets distracted and forgets about her changes. Later, she starts working
    on a new “version 5” on her desktop machine, including *different* improvements.
    We’ll call these versions “5L” and “5D,” for “laptop” and “desktop.”
  prefs: []
  type: TYPE_NORMAL
- en: When it comes time to upload changes to the cloud, there is an opportunity for
    a mishap! Alice might copy all her local files into the cloud, causing it to contain
    version 5D only. Later Alice syncs from the cloud to her laptop, potentially overwriting
    version 5L, losing the worthwhile changes. What Alice really wants here is a *merge*,
    to create a new version based on the two version 5’s.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, considering just the scenario of one programmer working alone,
    we already have a list of operations that should be supported by a version control
    scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '*reverting* to a past version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*comparing* two different versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pushing* full version history to another location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*pulling* history back from that location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*merging* versions that are offshoots of the same earlier version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple developers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s add into the picture Bob, another developer. The picture isn’t too
    different from what we were just thinking about.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  Cloud |'
  prefs: []
  type: TYPE_TB
- en: '|  |    |'
  prefs: []
  type: TYPE_TB
- en: '| Version 5A  Hello.java | Version 5A  Greet.java |   Alice |  |   Bob | Version
    5B  Hello.java | Version 5B  Greet.java |'
  prefs: []
  type: TYPE_TB
- en: Alice and Bob here are like the two Alices working on different computers. They
    no longer share a brain, which makes it even more important to follow a strict
    discipline in pushing to and pulling from the shared cloud server. The two programmers
    must coordinate on a scheme for coming up with version numbers. Ideally, the scheme
    allows us to assign clear names to *whole sets of files*, not just individual
    files. (Files depend on other files, so thinking about them in isolation allows
    inconsistencies.)
  prefs: []
  type: TYPE_NORMAL
- en: Merely uploading new source files is not a very good way to communicate to others
    the high-level idea of a set of changes. So let’s add a log that records for each
    version *who* wrote it, *when* it was finalized, and *what* the changes were,
    in the form of a short human-authored message.
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  Cloud |'
  prefs: []
  type: TYPE_TB
- en: '|  |    |'
  prefs: []
  type: TYPE_TB
- en: '| Log: 1: Alice, 7pm, ...'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '4: Bob, 8pm, ...'
  prefs: []
  type: TYPE_NORMAL
- en: '5A: Alice, 9pm, ... | Ver. 5A  Hello.java | Ver. 5A  Greet.java |   Alice |  |   Bob
    | Ver. 5B  Hello.java | Ver. 5B  Greet.java | Log: 1: Alice, 7pm, ...'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '4: Bob, 8pm, ...'
  prefs: []
  type: TYPE_NORMAL
- en: '5B: Bob, 9pm, ... |'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pushing another version now gets a bit more complicated, as we need to merge
    the logs. This is easier to do than for Java files, since logs have a simpler
    structure – but without tool support, Alice and Bob will need to do it manually!
    We also want to enforce consistency between the logs and the actual sets of available
    files: for each log entry, it should be easy to extract the complete set of files
    that were current at the time the entry was made.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But with logs, all sorts of useful operations are enabled. We can look at the
    log for just a particular file: a view of the log restricted to those changes
    that involved modifying some file. We can also use the log to figure out which
    change contributed each line of code, or, even better, which person contributed
    each line, so we know who to complain to when the code doesn’t work. This sort
    of operation would be tedious to do manually; the automated operation in version
    control systems is called *annotate* (or, unfortunately, *blame*).'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It sometimes makes sense for a subset of the developers to go off and work on
    a *branch*, a parallel code universe for, say, experimenting with a new feature.
    The other developers don’t want to pull in the new feature until it is done, even
    if several coordinated versions are created in the meantime. Even a single developer
    can find it useful to create a branch, for the same reasons that Alice was originally
    using the cloud server despite working alone.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it will be useful to have many shared places for exchanging project
    state. There may be multiple branch locations at once, each shared by several
    programmers. With the right set-up, any programmer can pull from or push to any
    location, creating serious flexibility in cooperation patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The shocking conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, it turns out we haven’t invented anything here: [Git](http://git-scm.com)
    does all these things for you, and so do many other version control systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Distributed vs. centralized
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Dan |  | Carol |'
  prefs: []
  type: TYPE_TB
- en: '|   |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud |'
  prefs: []
  type: TYPE_TB
- en: '|   |'
  prefs: []
  type: TYPE_TB
- en: '| Alice |  | Bob |'
  prefs: []
  type: TYPE_TB
- en: Traditional *centralized* version control systems like CVS and [Subversion](http://subversion.apache.org/)
    do a subset of the things we’ve imagined above. They support a collaboration graph
    – who’s sharing what changes with whom – with one master server and copies that
    only communicate with the master.
  prefs: []
  type: TYPE_NORMAL
- en: In a centralized system, everyone must share their work to and from the master
    repository. Changes are safely stored *in version control* if they are *in the
    master repository*, because that’s the only repository.
  prefs: []
  type: TYPE_NORMAL
- en: '| Dan |    | Carol |'
  prefs: []
  type: TYPE_TB
- en: '|     |'
  prefs: []
  type: TYPE_TB
- en: '| Cloud |'
  prefs: []
  type: TYPE_TB
- en: '|   |'
  prefs: []
  type: TYPE_TB
- en: '| Alice |    | Bob |'
  prefs: []
  type: TYPE_TB
- en: In contrast, *distributed* version control systems like [Git](http://git-scm.com)
    and [Mercurial](https://mercurial.selenic.com) allow all sorts of different collaboration
    graphs, where teams and subsets of teams can experiment easily with alternate
    versions of code and history, merging versions together as they are determined
    to be good ideas.
  prefs: []
  type: TYPE_NORMAL
- en: In a distributed system, all repositories are created equal, and it’s up to
    users to assign them different roles. Different users might share their work to
    and from different repos, and the team must decide what it means for a change
    to be *in version control*. If the change is stored in just a single programmer’s
    repo, do they still need to share it with a designated collaborator or specific
    server before the rest of the team considers it official?
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: More equal(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Version control terminology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Repository**: a local or remote store of the versions in our project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working copy**: a local, editable copy of our project that we can work on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File**: a single file in our project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version** or **revision**: a record of the contents of our project at a point
    in time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change** or **diff**: the difference between two versions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Head**: the current version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of a version control system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Reliable**: keep versions around for as long as we need them; allow backups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple files**: track versions of a project, not single files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meaningful versions**: what were the changes, why were they made?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Revert**: restore old versions, in whole or in part'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compare versions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Review history**: for the whole project or individual files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not just for code**: prose, images, …'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It should **allow multiple people to work together**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Merge**: combine versions that diverged from a common previous version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Track responsibility**: who made that change, who touched that line of code?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Work in parallel**: allow one programmer to work on their own for a while
    (without giving up version control)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Work-in-progress**: allow multiple programmers to share unfinished work (without
    disrupting others, without giving up version control)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/87b570f0480736496827cc0b40c857e7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The version control system we’ll use in 6.005 is [Git](http://git-scm.com).
    It’s powerful and worth learning. But Git’s user interface can be terribly frustrating.
    What is Git’s user interface?
  prefs: []
  type: TYPE_NORMAL
- en: '**In 6.005, we will use Git on the command line.** The command line is a fact
    of life, ubiquitous because it is so powerful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command line can make it very difficult to see what is going on in your
    repositories. You may find [SourceTree](http://www.sourcetreeapp.com) (shown on
    the right) for Mac & Windows useful. On any platform, [gitk](http://git-scm.com/docs/gitk)
    can give you a basic Git GUI. Ask Google for other suggestions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An important note about tools for Git:'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse has built-in support for Git. If you follow the [problem set instructions](../../psets/ps0/),
    Eclipse will know your project is in Git and will show you helpful icons. We do
    not recommend using the Eclipse Git UI to make changes, commit, etc., and course
    staff may not be able to help you with problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitHub](http://github.com/) makes desktop apps for Mac and Windows. Because
    the GitHub app changes how some Git operations work, if you use the GitHub app,
    course staff will not be able to help you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the [Git](http://git-scm.com) website, you can find two particularly useful
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Pro Git*](http://git-scm.com/book) documents everything you might need to
    know about Git.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [Git command reference](http://git-scm.com/docs) can help with the syntax
    of Git commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ve already completed **[PS0](../../psets/ps0/#clone)** and the **[Getting
    Started intro to Git](../../getting-started/#git)**.
  prefs: []
  type: TYPE_NORMAL
- en: The Git object graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read: [*Pro Git* 1.3: Git Basics](http://git-scm.com/book/en/v2/Getting-Started-Git-Basics)'
  prefs: []
  type: TYPE_NORMAL
- en: 'That reading introduces the three pieces of a Git repo: `.git` directory, working
    directory, and staging area.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the operations we do with Git — clone, add, commit, push, log, merge,
    … — are operations on a graph data structure that stores all of the versions of
    files in our project, and all the log entries describing those changes. The **Git
    object graph** is stored in the `.git` directory of your local repository. Another
    copy of the graph, e.g. for PS0, is on Athena in:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/mit/6.005/git/fa16/psets/ps0/[your username].git`'
  prefs: []
  type: TYPE_NORMAL
- en: Copy an object graph with `git clone`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do you get the object graph from Athena to your local machine in order to
    start working on the problem set? **`git clone`** copies the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose your username is `bitdiddle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone ssh://.../psets/ps0/bitdiddle.git ps0`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover or tap on each step to update the diagram below:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty local directory `ps0`, and `ps0/.git`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the object graph from `ssh://.../psets/ps0/bitdiddle.git` into `ps0/.git`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Check out** the current version of the **`master` branch**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Diagram for highlighted step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b678e7e1dea8e326dbd0cc06be9f1df8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We still haven’t explained what’s in the object graph. But before we do that,
    let’s understand step 3 of `git clone`: check out the current version of the `master`
    branch.'
  prefs: []
  type: TYPE_NORMAL
- en: The object graph is stored on disk in a convenient and efficient structure for
    performing Git operations, but not in a format we can easily use. In [Alice’s
    invented version control scheme](#inventing_version_control), the current version
    of `Hello.java` was just called `Hello.java` because she needed to be able to
    edit it normally. In Git, we obtain normal copies of our files by *checking them
    out* from the object graph. These are the files we see and edit in Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: We also decided above that it might be useful to support [multiple *branches*
    in the version history](#multiple_branches). Multiple branches are essential for
    large teams working on long-term projects. To keep things simple in 6.005, we
    will not use branches and we don’t recommend that you create any. Every Git repo
    comes with a default branch called `master`, and all of our work will be on the
    `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: So step 2 of `git clone` gets us an object graph, and step 3 gets us a **working
    directory** full of files we can edit, starting from the current version of the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finally dive into that object graph!
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone an example repo: **`https://github.com/mit6005/fa16-ex05-hello-git.git`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using commands from [Getting Started](../../getting-started/#git) or [*Pro
    Git* 2.3: Viewing the Commit History](http://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History),
    or by using a tool like SourceTree, explain the history of this little project
    to yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of [`git lol`](../../getting-started/#config-git) for this
    example repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The history of a Git project is a [**directed acyclic graph**](http://en.wikipedia.org/wiki/Directed_acyclic_graph)
    (DAG). The history graph is the backbone of the full object graph stored in `.git`,
    so let’s focus on it for a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/25abd569a317b82518b3087da6480528.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each node in the history graph is a **commit** a.k.a. **version** a.k.a. **revision**
    of the project: a complete snapshot of all the files in the project at that point
    in time. You may recall from our [earlier reading](../../getting-started/#getting_the_history_of_the_repository)
    that each commit is identified by a unique ID, displayed as a hexadecimal number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Except for the initial commit, each commit has a pointer to its **parent**
    commit. For example, commit `1255f4e` has parent `41c4b8f`: this means `41c4b8f`
    happened first, then `1255f4e`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some commits have the same parent: they are versions that diverged from a common
    previous version. And some commits have two parents: they are versions that tie
    divergent histories back together.'
  prefs: []
  type: TYPE_NORMAL
- en: A branch — remember `master` will be our only branch for now — is just a name
    that points to a commit.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, HEAD points to our current commit — almost. We also need to remember
    which branch we’re working on. So HEAD points to the current branch, which points
    to the current commit.
  prefs: []
  type: TYPE_NORMAL
- en: Check your understanding…
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: HEAD count(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: First impression(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Graph-ical
  prefs: []
  type: TYPE_NORMAL
- en: Choose all the correct answers.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Around and around(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: What else is in the object graph?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The history graph is the backbone of the full object graph. What else is in
    there?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/148f747fdadb44cd81e2fcca34727efb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each commit is a snapshot of our entire project, which Git represents with a
    **tree** node. For a project of any reasonable size, most of the files *won’t*
    change in any given revision. Storing redundant copies of the files would be wasteful,
    so Git doesn’t do that.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the Git object graph stores each version of an individual file *once*,
    and allows multiple commits to *share* that one copy. To the left is a more complete
    rendering of the Git object graph for our example.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this picture in the back of your mind, because it’s a wonderful example
    of the sharing enabled by *immutable data types*, which we’re going to discuss
    a few classes from now.
  prefs: []
  type: TYPE_NORMAL
- en: Each commit also has log data — who, when, short log message, etc. — not shown
    in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Add to the object graph with `git commit`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do we add new commits to the history graph? **`git commit`** creates a new
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: In some alternate universe, `git commit` might create a new commit based on
    the current contents of your working directory. So if you edited `Hello.java`
    and then did `git commit`, the snapshot would include your changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re not in that universe; in our universe, Git uses that third and final
    piece of the repository: the **staging area** (a.k.a. the **index**, which is
    only a useful name to know because sometimes it shows up in documentation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The staging area is like a proto-commit, a commit-in-progress. Here’s how we
    use the staging area and **`git add`** to build up a new snapshot, which we then
    cast in stone using **`git commit`**:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify `hello.txt`, `git add hello.txt`, `git commit`
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover or tap on each step to update the diagram, and to see the output of `git
    status` at each step:'
  prefs: []
  type: TYPE_NORMAL
- en: If we haven’t made any changes yet, then the working directory, staging area,
    and HEAD commit are all identical.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a change to a file. For example, let’s edit `hello.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other changes might be creating a new file, or deleting a file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stage** those changes using `git add`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new commit out of all the staged changes using `git commit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/a75b7711efba2027df60e00296c8176a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Use **`git status`** frequently to keep track of whether you have no changes,
    unstaged changes, or staged changes; and whether you have new commits in your
    local repository that haven’t been pushed.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Classy
  prefs: []
  type: TYPE_NORMAL
- en: The Java compiler compiles `.java` files into `.class` files.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Take the stage(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Upstaged
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have a repo and there are *changes staged for commit*.
  prefs: []
  type: TYPE_NORMAL
- en: We run `git commit` (with no fancy arguments).
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Downplayed
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we start at version A of our project.
  prefs: []
  type: TYPE_NORMAL
- en: In version B, we make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Then in version C, we make exactly the inverse changes we made in version B.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Sequences, trees, and graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you’re working independently, on a single machine, the DAG of your version
    history will usually look like a sequence: commit 1 is the parent of commit 2
    is the parent of commit 3…'
  prefs: []
  type: TYPE_NORMAL
- en: There are three programmers involved in the history of our example repository.
    Two of them – Alyssa and Ben – made changes “at the same time.” In this case,
    “at the same time” doesn’t mean precisely contemporaneous. Instead, it means they
    made two different *new* versions based on the same *previous* version, just as
    [Alice made version 5L and 5D on her laptop and desktop](#inventing_version_control).
  prefs: []
  type: TYPE_NORMAL
- en: 'When multiple commits share the same parent commit, our history DAG changes
    from a sequence to a tree: it branches apart. Notice that a branch in the history
    of the project doesn’t require anyone to create a new Git branch, merely that
    we start from the same commit and work in parallel on different copies of the
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the history DAG changes from tree- to graph-shaped when the branching
    changes are merged together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How is it that changes are merged together? First we’ll need to understand how
    history is shared between different users and repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Send & receive object graphs with `git push` & `git pull`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can send new commits to a remote repository using **`git push`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git push origin master`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover or tap on each step to update the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: When we clone a repository, we obtain a copy of the history graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git remembers where we cloned from as a **remote repository** called **`origin`**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `git commit`, we add new commits to the local history on the `master`
    branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To send those changes back to the `origin` remote, use `git push origin master`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/b7bf364c0562d841336c4977e71b7337.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And we receive new commits using **`git pull`**. Note that `git pull`, in addition
    to fetching new parts of the object graph, also updates the working copy by checking
    out the latest version (just like `git clone` checked out a working copy to start
    with).
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s examine what happens when changes occur in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and commit `hello.scm` and `hello.rb` in parallel
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover or tap on each step to update the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: Both Alyssa and Ben **clone** the repository with two commits (`41c4b8f` and
    `1255f4e`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alyssa creates `hello.scm` and **commits** her change as `6400936`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the same time, Ben creates `hello.rb` and **commits** his change as `82e049e`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, both of their changes only exist in their local repositories.
    In each repo, `master` now points to a different commit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s suppose Alyssa is the first to **push** her change up to Athena.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What happens if Ben tries to push now? The push will be rejected: if the server
    updates `master` to point to Ben’s commit, Alyssa’s commit will disappear from
    the project history!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ben must **merge** his changes with Alyssa’s.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To perform the merge, he **pulls** her commit from Athena, which does two things:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (a) Downloads new commits into Ben’s repository’s object graph
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '(b) Merges Ben’s history with Alyssa’s, creating a new commit (`3e62e60`) that
    joins together the disparate histories. This commit is a snapshot like any other:
    a snapshot of the repository with both of their changes applied.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now Ben can `git push`, because no history will go missing when he does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And Alyssa can `git pull` to obtain Ben’s work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/b0cb60124809c62730dd0d3ff0cbebc5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, Git was able to merge Alyssa’s and Ben’s changes automatically,
    because they each modified different files. If both of them had edited the *same
    parts of the same files*, Git would report a **merge conflict**. Ben would have
    to manually weave their changes together before committing the merge. All of this
    is discussed in the [Getting Started section on merges, merging, and merge conflicts](../../getting-started/#merges).
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Merge
  prefs: []
  type: TYPE_NORMAL
- en: 'Alice and Bob both start with the same Java file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| Alice changes `greet(..)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| Bob changes `greeting()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Dangerous Merge Ahead
  prefs: []
  type: TYPE_NORMAL
- en: 'Same starting program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| Alice changes `greeting()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| Bob changes where the comma appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Continue Merging
  prefs: []
  type: TYPE_NORMAL
- en: 'Same starting program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alice changes `greet(..)` to return instead of print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Bob creates a new file, `Main.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Why do commits look like diffs?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve defined a commit as a snapshot of our entire project, but if you ask
    Git, it doesn’t seem to see things that way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Git is assuming that most of our project does not change in any given commit,
    so showing only the differences will be more useful. Almost all the time, that’s
    true.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can ask Git to show us what was in the repo at a particular commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the addition of a `:` completely changes the meaning of that command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see what was in a particular file in that commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one of the simplest ways you can use Git to recover from a disaster:
    ask it to `git show` you the contents of a now-broken file at some earlier version
    when the file was OK.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll practice some disaster recovery commands in class.
  prefs: []
  type: TYPE_NORMAL
- en: Version control and the big three
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does version control relate to the three big ideas of 6.005?
  prefs: []
  type: TYPE_NORMAL
- en: Safe from bugs
  prefs: []
  type: TYPE_NORMAL
- en: find when and where something broke
  prefs: []
  type: TYPE_NORMAL
- en: look for other, similar mistakes
  prefs: []
  type: TYPE_NORMAL
- en: gain confidence that code hasn’t changed accidentally
  prefs: []
  type: TYPE_NORMAL
- en: Easy to understand
  prefs: []
  type: TYPE_NORMAL
- en: why was a change made?
  prefs: []
  type: TYPE_NORMAL
- en: what else was changed at the same time?
  prefs: []
  type: TYPE_NORMAL
- en: who can I ask about this code?
  prefs: []
  type: TYPE_NORMAL
- en: Ready for change
  prefs: []
  type: TYPE_NORMAL
- en: all about managing and organizing changes
  prefs: []
  type: TYPE_NORMAL
- en: accept and integrate changes from other developers
  prefs: []
  type: TYPE_NORMAL
- en: isolate speculative work on branches
  prefs: []
  type: TYPE_NORMAL
