- en: 1  Introduction to Abstract Interpretation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *formal verification* of a program (and more generally a computer system)
    consists in proving that its *semantics* (describing "what the program executions
    actually do") satisfies its *specification* (describing "what the program executions
    are supposed to do").*Abstract interpretation* [[22](#CousotCousot77-1-POPL),[26](#CousotCousot79-1-POPL)]
    formalizes the idea that this formal proof can be done at some level of abstraction
    where irrelevant details about the semantics and the specification are ignored.
    This amounts to proving that an *abstract semantics* satisfies an *abstract specification*.
    An example of abstract semantics is Hoare logic while examples of abstract specifications
    are invariance, partial, or total correctness. This abstracts away from concrete
    properties such as execution times.Abstractions should preferably be *sound* (no
    conclusion derived from the abstract semantics is wrong relative to the program
    concrete semantics and specification). Otherwise stated, a proof that the abstract
    semantics satisfies the abstract specification should imply that the concrete
    semantics also satisfies the concrete specification. Hoare logic is a sound verification
    method, debugging is not (since some executions are left out), bounded model checking
    is not either (since parts of some executions are left out). Unsound abstractions
    lead to *false negatives* (the program may be claimed to be correct/non erroneous
    with respect to the specification whereas it is indeed incorrect).Abstractions
    should also preferably be *complete* (no aspect of the semantics relevant to the
    specification is left out). So if the concrete semantics satisfies the concrete
    specification this should be provable in the abstract. However program proofs
    are undecidable, and so automatic tools for reasoning about programs are all incomplete
    (for non trivial program properties such as safety, liveness, or security) and
    must therefore fail on some programs. This can be achieved by allowing the tool
    not to terminate, to be unsound (e.g. debugging tools omit possible executions),
    or to be incomplete (e.g. static analysis tools may produce false alarms). Incomplete
    abstractions lead to *false positives* or *false alarms* (the specification is
    claimed to be potentially violated by some program executions while it is not).Potentially
    non-terminating and unsound program verification tools are easy to design. Terminating
    and sound tools are much more difficult to design. Complete tools are impossible
    to design, by undecidability. However static analysis tools producing very few
    or no false alarms have been designed and used in industrial contexts for specific
    families of properties and programs [[42](#CousotEtAl05-ESOP)]. In all cases,
    abstract interpretation provides a systematic construction method based on the
    effective approximation of the concrete semantics, which can be (partly) automated
    and/or formally verified.Abstract interpretation aims at
  prefs: []
  type: TYPE_NORMAL
- en: providing a basic coherent and conceptual theory for understanding in a unified
    framework the thousands of ideas, concepts, reasonings, methods, and tools on
    formal program analysis and verification [[22](#CousotCousot77-1-POPL),[26](#CousotCousot79-1-POPL)];
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: guiding the correct formal design of automatic tools for *program analysis*
    (computing an abstract semantics) and *program verification* (proving that an
    abstract semantics satisfies an abstract specification) [[17](#Cousot99-3-Marktoberdorf-paper)].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract interpretation theory studies semantics (formal models of computer
    systems), abstractions, their soundness, and completeness.The informal presentation
    "[Abstract Interpretation in a Nutshell](http://www.astree.ens.fr/IntroAbsInt.html)"
    aims at providing a short intuitive introduction to the theory. The "[basic](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)
    [concepts](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml) [of](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)
    [abstract](http://www.di.ens.fr/~cou''sot/COUSOTpapers/WCC04.shtml) [interpretation](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)"
    and an elementary "[course on abstract interpretation](http://web.mit.edu/afs/athena.mit.edu/course/16/16.399/www/)"
    can also be found on the web.
  prefs: []
  type: TYPE_NORMAL
