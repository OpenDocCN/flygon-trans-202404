- en: 1  Introduction to Abstract Interpretation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1  抽象解释介绍
- en: The *formal verification* of a program (and more generally a computer system)
    consists in proving that its *semantics* (describing "what the program executions
    actually do") satisfies its *specification* (describing "what the program executions
    are supposed to do").*Abstract interpretation* [[22](#CousotCousot77-1-POPL),[26](#CousotCousot79-1-POPL)]
    formalizes the idea that this formal proof can be done at some level of abstraction
    where irrelevant details about the semantics and the specification are ignored.
    This amounts to proving that an *abstract semantics* satisfies an *abstract specification*.
    An example of abstract semantics is Hoare logic while examples of abstract specifications
    are invariance, partial, or total correctness. This abstracts away from concrete
    properties such as execution times.Abstractions should preferably be *sound* (no
    conclusion derived from the abstract semantics is wrong relative to the program
    concrete semantics and specification). Otherwise stated, a proof that the abstract
    semantics satisfies the abstract specification should imply that the concrete
    semantics also satisfies the concrete specification. Hoare logic is a sound verification
    method, debugging is not (since some executions are left out), bounded model checking
    is not either (since parts of some executions are left out). Unsound abstractions
    lead to *false negatives* (the program may be claimed to be correct/non erroneous
    with respect to the specification whereas it is indeed incorrect).Abstractions
    should also preferably be *complete* (no aspect of the semantics relevant to the
    specification is left out). So if the concrete semantics satisfies the concrete
    specification this should be provable in the abstract. However program proofs
    are undecidable, and so automatic tools for reasoning about programs are all incomplete
    (for non trivial program properties such as safety, liveness, or security) and
    must therefore fail on some programs. This can be achieved by allowing the tool
    not to terminate, to be unsound (e.g. debugging tools omit possible executions),
    or to be incomplete (e.g. static analysis tools may produce false alarms). Incomplete
    abstractions lead to *false positives* or *false alarms* (the specification is
    claimed to be potentially violated by some program executions while it is not).Potentially
    non-terminating and unsound program verification tools are easy to design. Terminating
    and sound tools are much more difficult to design. Complete tools are impossible
    to design, by undecidability. However static analysis tools producing very few
    or no false alarms have been designed and used in industrial contexts for specific
    families of properties and programs [[42](#CousotEtAl05-ESOP)]. In all cases,
    abstract interpretation provides a systematic construction method based on the
    effective approximation of the concrete semantics, which can be (partly) automated
    and/or formally verified.Abstract interpretation aims at
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: providing a basic coherent and conceptual theory for understanding in a unified
    framework the thousands of ideas, concepts, reasonings, methods, and tools on
    formal program analysis and verification [[22](#CousotCousot77-1-POPL),[26](#CousotCousot79-1-POPL)];
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个统一的框架中提供了一个基本的连贯和概念性理论，用于理解形式程序分析和验证中的成千上万个想法、概念、推理、方法和工具[[22](#CousotCousot77-1-POPL),[26](#CousotCousot79-1-POPL)];
- en: guiding the correct formal design of automatic tools for *program analysis*
    (computing an abstract semantics) and *program verification* (proving that an
    abstract semantics satisfies an abstract specification) [[17](#Cousot99-3-Marktoberdorf-paper)].
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指导正确的自动工具的形式设计，用于*程序分析*（计算抽象语义）和*程序验证*（证明抽象语义满足抽象规范）[[17](#Cousot99-3-Marktoberdorf-paper)]。
- en: Abstract interpretation theory studies semantics (formal models of computer
    systems), abstractions, their soundness, and completeness.The informal presentation
    "[Abstract Interpretation in a Nutshell](http://www.astree.ens.fr/IntroAbsInt.html)"
    aims at providing a short intuitive introduction to the theory. The "[basic](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)
    [concepts](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml) [of](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)
    [abstract](http://www.di.ens.fr/~cou''sot/COUSOTpapers/WCC04.shtml) [interpretation](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)"
    and an elementary "[course on abstract interpretation](http://web.mit.edu/afs/athena.mit.edu/course/16/16.399/www/)"
    can also be found on the web.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象解释理论研究语义（计算机系统的形式模型）、抽象、它们的正确性和完整性。非正式的介绍 "[摘要解释简介](http://www.astree.ens.fr/IntroAbsInt.html)"
    旨在提供对该理论的简短直观介绍。网络上还可以找到关于抽象解释的 "[基本](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)
    [概念](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml) [of](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)
    [abstract](http://www.di.ens.fr/~cou''sot/COUSOTpapers/WCC04.shtml) [interpretation](http://www.di.ens.fr/~cousot/COUSOTpapers/WCC04.shtml)"
    和初级 "[抽象解释课程](http://web.mit.edu/afs/athena.mit.edu/course/16/16.399/www/)"。
