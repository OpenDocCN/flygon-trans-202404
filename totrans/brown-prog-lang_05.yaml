- en: 5From Tables to Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [5.1 Basic Statistical Questions](#%28part._table-stat-qs%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [5.2 Extracting a Column from a Table](#%28part._.Extracting_a_.Column_from_a_.Table%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [5.3 Understanding Lists](#%28part._.Understanding_.Lists%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [5.3.1 Lists as Anonymous Data](#%28part._lists-generic-data%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [5.3.2 Creating Literal Lists](#%28part._.Creating_.Literal_.Lists%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [5.4 Operating on Lists](#%28part._.Operating_on_.Lists%29) |'
  prefs: []
  type: TYPE_TB
- en: '|       [5.4.1 Built-In Operations on Lists](#%28part._.Built-.In_.Operations_on_.Lists%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|       [5.4.2 Combining Lists and Tables](#%28part._.Combining_.Lists_and_.Tables%29)
    |'
  prefs: []
  type: TYPE_TB
- en: Previously [[Introduction to Tabular Data](intro-tabular-data.html)] we began
    to process collective data in the form of tables. Though we saw several powerful
    operations that let us quickly and easily ask sophisticated questions about our
    data, they all had two things in commmon. First, all were operations by rows.
    None of the operations asked questions about an entire column at a time. Second,
    all the operations not only consumed but also produced tables. However, we already
    know [[Basic Data and Expressions](basic-data-expr.html)] there are many other
    kinds of data, and sometimes we will want to compute one of them. We will now
    see how to achieve both of these things, introducing an important new type of
    data in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1Basic Statistical Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many more questions we might want to ask of our data. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: The most-played song in a playlist, which translates to the maximum value in
    a column of play counts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The largest file in a filesystem, which translates to the maximum value in a
    column of file sizes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shortest person in a table of people, which translates to the smallest value
    in a column of heights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most-played song in a playlist, which translates to the smallest value in
    a column of play counts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of songs in a playlist. (This is arguably a question about all the
    columns combined, not any one specific column, since they all have the same number
    of entries.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the distinct entries in the play-counts column. (This, naturally, is a question
    about a specific column, because the number of distinct entries will differ depending
    on the column.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of distinct entries in the play-counts column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The average in a column of wages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other statistics (the median, mode, standard deviation, etc.) in a column of
    heights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice the kinds of operations that we are talking about: computing the maximum,
    minimum, average, median, and other basic statistics.Pyret has several built-in
    [statistics functions](http://www.pyret.org/docs/latest/statistics.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Think about whether and how you would express these questions with the operations
    you have already seen.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 5.2Extracting a Column from a Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hopefully you found select attractive, because it gives us a column in isolation:
    e.g.,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: But in the end we’re still stuck with a column in a table, and none of the other
    operations let us compute the answers we’re looking for. Therefore, there is no
    (straightforward) way to express these questions at all, because they require
    us to be perform a computation looking at the values of a table relative to one
    another, rather than in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, we could have a collection of operations on a single column. In
    some languages that focus solely on tables, such as [SQL](https://en.wikipedia.org/wiki/SQL),
    this is what you’ll find. However, in Pyret we have many more kinds of data than
    just columns (as we’ll soon see [REF], we can even create our own!), so it makes
    sense to leave the gentle cocoon of tables sooner or later. An extracted column
    is a more basic kind of datum called a list, which can be used to represent other
    data in programs (as we see in [REF] and elsewhere), without the bother of having
    to create a table every single time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we introduce one more operation, extract, which takes a column name
    and gives just the content of that one column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And now we can answer the critical question—<wbr>what is the difference between
    select and extract—<wbr>by saying that while select produces a table, extract
    produces a list.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3Understanding Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A list has much in common with a single-column table:'
  prefs: []
  type: TYPE_NORMAL
- en: The elements have an order, so it makes sense to talk about the “first”, “second”,
    “last”—<wbr>and so on—<wbr>element of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All elements of a list are expected to have the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The crucial difference is that a list does not have a “column name”; it is anonymous.
    That is, by itself a list does not describe what it represents; this interpretation
    is done by our program.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1Lists as Anonymous Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This might sound rather abstract—<wbr>and it is—<wbr>but this isn’t actually
    a new idea in our programming experience. Consider a value like 3 or -1: what
    is it? It’s the same sort of thing: an anonymous value that does not describe
    what it represents; the interpretation is done by our program. In one setting
    3 may represent an age, in another a play count; in one setting -1 may be a temperature,
    in another the average of several temperatures. Similarly with a string: Is "project"
    a noun (an activity that one or more people perform) or a verb (as when we display
    something on a screen)? Likewise with images and so on. In fact, tables have been
    the exception so far in having description built into the data rather than being
    provided by a program!'
  prefs: []
  type: TYPE_NORMAL
- en: This genericity is both a virtue and a problem. Because, like other anonymous
    data, a list does not provide any interpretation of its use, if we are not careful
    we can accidentally mis-interpret the values. On the other hand, it means we can
    use the same datum in several different contexts, and one operation can be used
    in many settings.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, if we look at the list of questions we asked earlier, we see that there
    are several common operations—<wbr>maximum, minimum, average, and so on—<wbr>that
    can be asked of a list of values without regard for what the list represents (heights,
    ages, playcounts). In fact, some are specific to numbers (like average) while
    some (like maximum) can be asked of any type on which we can perform a comparison
    (like strings).
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2Creating Literal Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already seen how we can create lists from a table, using extract. As
    you might expect, however, we can also create lists directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Of course, lists are values so we can name them using variables—<wbr>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: —<wbr>pass them to functions (as we will soon see), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on these examples, can you figure out how to create an empty list?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As you might have guessed, it’s [list: ] (the space isn’t necessary, but it’s
    a useful visual reminder of the void).'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4Operating on Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 5.4.1Built-In Operations on Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pyret handily provides a useful set of operations we can already perform on
    lists. As you might have guessed, we can already compute all the answers we’ve
    asked for above:'
  prefs: []
  type: TYPE_NORMAL
- en: list-max computes the maximum element of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list-min computes the minimum element of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list-avg computes the average of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list-distinct computes the distinct elements a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list-std-dev computes the standard deviation of the values in list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 5.4.2Combining Lists and Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the questions we originally asked were slightly different: we didn’t
    ask for the tallest height but the tallest person, or likewise the most most-played
    song. Because we’ve stripped the heights and counts of their surrounding context,
    we can no longer tell which person or song these values correspond to. For that,
    we have to go back to the table.'
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see how we can use the values above, like most-played-count or shortest-height,
    to obtain the corresponding songs or people?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The key is to write a query over the corresponding table that refers to this
    value. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a reason we are careful to always use the plural—<wbr>people, songs—<wbr>rather
    than the singular. This is because we cannot be sure there is only one person
    or one song with this height or play count. That is, there is a single biggest
    or smallest value in the list, because the value has no other information about
    it (so the same height coming from two different people, or the same play count
    coming from two different songs, looks the same in the list). But when put back
    in the context of the original table, the other values may be different.In short,
    our overall answer is computed quite simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement all the other statistical questions posed in [Basic Statistical Questions](#%28part._table-stat-qs%29).
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Until now we’ve only seen how to use built-in functions over lists. Next [[Processing
    Lists](processing-lists.html)], we will study how to create our own functions
    that process lists. Once we learn that, these list processing functions will remain
    powerful but will no longer seem quite so magical, because we’ll be able to build
    them for ourselves!
  prefs: []
  type: TYPE_NORMAL
