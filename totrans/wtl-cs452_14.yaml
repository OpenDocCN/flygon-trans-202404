- en: Lecture 14 - Serial I/O, Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Public Service Annoucements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assignment 4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance measurements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Serial I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [pdf](../../s10/pdf/sio.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: FIFO
  prefs: []
  type: TYPE_NORMAL
- en: Why do FIFOs exist in UARTS?
  prefs: []
  type: TYPE_NORMAL
- en: The Big Blunder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use the FIFO effectively you must be able to turn off the transmitter & receiver
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: But look at UARTE in UARTxCtrl
  prefs: []
  type: TYPE_NORMAL
- en: UART Enable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this bit is set to 1, the UART is enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data transmission and reception occurs for UART signals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Little Blunder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`It is assumed that various configuration registers for the UART are not written
    more than once in quick succession, in order to insure proper synchronization
    of configuration information across the implementation. Such registers include
    UART1Ctrl and UART1LinCtrlHigh. ... In between the two writes, at least two UARTCLK
    periods must occur. Under worst case conditions, at least 55 HCLK periods must
    separate the two writes. The simplest way to due [sic] this is to separate the
    two writes by 55 NOPs.'''
  prefs: []
  type: TYPE_NORMAL
- en: Why does this occur?
  prefs: []
  type: TYPE_NORMAL
- en: CPU clocked by CPU clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System buses clocked by several different clocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UART clocked by its own clock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The clocks were not suitably synchronized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why doesn't anybody care?
  prefs: []
  type: TYPE_NORMAL
- en: UARTs are used at the beginning of the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once other I/O (ethernet, USB, etc.) is working, UARTs are no longer used, except
    possibly by the boot loader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interrupts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Five interrupts in the device
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: These interrupts are separately enabled and disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Transmit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FIFO enabled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asserted when transmit FIFO is less than half full.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleared when transmit FIFO is more than half full.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: FIFO disabled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asserted when holding register is empty
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleared on write to the holding register
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Not conditioned by enable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FIFO enabled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asserted when receive FIFO is half full
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleared when receive FIFO is read to less than half full.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: FIFO disabled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asserted when receive buffer is full
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleared when receive buffer is read
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Modem status
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Asserted when hardware flow control bits change
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleared when the modem status register is written
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive timeout
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Asserted when receive FIFO is not empty and 32 bit periods pass with no new
    data
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleared when all data has been read from FIFO
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Combined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OR of the four above interrupts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Asserted when at least one of the above interrupts is asserted
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleared when all the above interrupts are not asserted.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Three inputs to the ICU
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Transmit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Receive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are adequate for interacting with the terminal, but not for interacting
    with the train controller.
  prefs: []
  type: TYPE_NORMAL
- en: Easy way to use interrupts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Enable only combined; read UART registers to decide what to do.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the receive and transmit parts of the UART as separate state machines
  prefs: []
  type: TYPE_NORMAL
- en: Base the state machine on bits in the status registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a separate state machine for flow control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical Advice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now you have been using busy-wait I/O for getting debugging output. You
    would like to continue to have debugging output while you are implementing interrupt-mediated
    I/O.
  prefs: []
  type: TYPE_NORMAL
- en: There are two UART ports on the ARM board.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect each one to a different terminal window on the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do busy-wait I/O to one for debugging while getting interrupt-mediated I/O working
    on the other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then do debugging I/O on the working serial server while you create and debig
    the other server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**. The serial server for the terminal must be a lot more complex than
    the esrial server for the train controller.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Real-time Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common set of debugging tools used by experienced programmers is the
    oldest: printf, grep & stack trace.'
  prefs: []
  type: TYPE_NORMAL
- en: The power of these tools is greatly enhanced by strong conventions in code formatting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging real-time programs, at its base, is just the same as any other debugging,
    and just the same as empirical science.
  prefs: []
  type: TYPE_NORMAL
- en: Gather data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a model that explains the data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the model is not correct, go to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember that the model is ALWAYS provisional: data collected later may invalidate
    it, no matter how much data has confirmed it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But real-time programs are harder to debug. Very few programs are entirely free
    of critical races, which are the worst type of bug, lurking for weeks months or
    years in seemingly correct code, then appearing when innocuous, unconnected changes
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: Critical Races
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There is no known method for eliminating critical races.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing everything, which seems to be an obvious solution, kills performance
    because it removes flexibility from the execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is, in principle, impossible to test away critical races. Why?
  prefs: []
  type: TYPE_NORMAL
- en: When three trains run continuously for ten minutes, how many events occur in
    the real world?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many possible orders are there for these events?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-ordering isn't even necessary for a critical race to occur, just getting
    too close in time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RedBoot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The memory contents are not wiped by reset. Some of the most difficult errors
    can be detected only by using the contents of memory after a reset. Produce useful
    results by inserting
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: many places in your code. Then, with the assistance of a load map, you can find
    out where you were in which code when the problem occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In RedBoot you can, in principle, trace any of the kernel
  prefs: []
  type: TYPE_NORMAL
- en: Stack Trace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In single-threaded programs this is often the most useful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Anything that terminates execution abnormally prints the set of active stack
    frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: name of calling function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: line number of call
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Extreme version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: values of arguments
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: values of local variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the equivalent of a stack trace in a real-time multi-tasking environment?
  prefs: []
  type: TYPE_NORMAL
- en: How would you implement it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two basic questions to answer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When is it produced?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What should be in it?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you make it readable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breakpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does it do?
  prefs: []
  type: TYPE_NORMAL
- en: snapshot of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that computation, including respose to interrupts, must stop, or
    it isn't a snapshot.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: provides interactive tools for examining kernel data structures, such as
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: task descriptors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: lists and queues
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: stacks, including the program counter and local variables, of individual tasks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: restart system immediately afterwards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to continue where processing stopped you must make certain that
    all state is saved when you enter Beakpoint and restored when you leave it. What
    about pending interrupts? You can't stop the entire universe!
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise you can re-enter RedBoot.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you get it started?
  prefs: []
  type: TYPE_NORMAL
- en: function call, which you insert in your code when compiling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The easiest and fastest form to implement.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Having the call as part of ASSERT is common.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Has to exit to RedBoot. (Jump to x00.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: system call instead of function call, which respects the kernel/user distinction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an exception triggered externally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: at initialization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the system so that the external event will generate an exception
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: E.g. attach a button to PDIO on the third connector, set up ICU.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: at run-time
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Trigger the interrupt
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to Breakpoint in the event handler
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Either exit to RedBoot,
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Or clean up pending interrupts and resume execution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Breakpoint is a special case of a particular sort of tool that is very common.
  prefs: []
  type: TYPE_NORMAL
- en: condition occurs => information is made available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: breakpoint provides the information interactively (`interactively' = `on the
    time scale of the user')
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it can stop the system completely. How?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: but it has limited ability to stop the real world
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: i.e., it hides some bugs
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting information closer to real-time.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bill Cowan''s lecture notes for CS452 in s12](index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s Spring 2012 CS452 page](../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s CS452 page](../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s teaching page](../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s home page](../../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
