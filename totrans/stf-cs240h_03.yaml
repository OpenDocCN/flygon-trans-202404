- en: Phantoms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's think about a programming pattern we've seen, but not paid attention to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns: I'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Patterns: II'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Patterns: III'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Patterns: IV'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Patterns, abstracted
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typeclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Where can you find this typeclass?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Monoids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instances of `Monoid` must obey some rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rule 1: identity element'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Rule 2: our associative operation *must actually associate*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Rules?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monoids come from abstract algebra.
  prefs: []
  type: TYPE_NORMAL
- en: In abstract algebra, rules that must be true are called *axioms*.
  prefs: []
  type: TYPE_NORMAL
- en: Also called *laws*.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, how are these rules/axioms/laws enforced?
  prefs: []
  type: TYPE_NORMAL
- en: They are not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoids for lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s the easiest and most familiar-to-Haskellers case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Pop quiz:'
  prefs: []
  type: TYPE_NORMAL
- en: What other definition(s) would follow the `Monoid` laws?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do they make any sense?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoids for numbers?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers are an interesting case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Addition as monoid:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative operator `+`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiplication as monoid:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associative operator `*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When do we use typeclasses?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you want to abstract a code pattern into a typeclass.
  prefs: []
  type: TYPE_NORMAL
- en: Under what circumstances is this likely to work best?
  prefs: []
  type: TYPE_NORMAL
- en: When there is *just one* "canonical" behaviour you expect for a given type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For lists, our `Monoid` instance *is* canonical:'
  prefs: []
  type: TYPE_NORMAL
- en: Any other behaviour that follows the laws is just *weird*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For numbers, we have two sensible behaviours:'
  prefs: []
  type: TYPE_NORMAL
- en: No one `Monoid` instance can be called canonical!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoids for multiplication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Monoids for addition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Either` type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There exists a built-in type named `Either`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'By convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Left` means "something went wrong"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Right` means "result was a success"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Often used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: (where the `String` carries an error message)
  prefs: []
  type: TYPE_NORMAL
- en: Coding exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `Monoid` instance that will give the *first success* from a chain of
    `Either` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Desired behaviour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You have five minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Ambient machinery for the coding exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you import `Data.Monoid` you will have the following definitions available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Language hitch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Did you try to write code like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You surely ran into trouble while trying to define `mempty`.
  prefs: []
  type: TYPE_NORMAL
- en: Why?
  prefs: []
  type: TYPE_NORMAL
- en: Type quantification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Haskell, type variables are *quantified*.
  prefs: []
  type: TYPE_NORMAL
- en: They stand in for all types in a given domain.
  prefs: []
  type: TYPE_NORMAL
- en: If there's no typeclass mentioned, a type variable is implicitly *universally*
    quantified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write these quantifiers explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '"The `length` function must accept any list, no matter what type of data it
    contains."'
  prefs: []
  type: TYPE_NORMAL
- en: Universal quantification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why is universal quantification relevant here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Universal quantification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why is universal quantification relevant here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since `mempty` gives a "zero element", it must somehow produce a zero element
    for the type `a`.
  prefs: []
  type: TYPE_NORMAL
- en: But since `a` is universally quantified, it stands in for *every type*.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly there is no one legal value that is of every type.
  prefs: []
  type: TYPE_NORMAL
- en: It is impossible to write a sensible instance.
  prefs: []
  type: TYPE_NORMAL
- en: A possible fix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This won''t typecheck either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can make it compile by adding the following to the top of our source
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Pragmas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a specially formatted comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '"Special" comments usually contain directives ("pragmas") that change the compiler''s
    behaviour.'
  prefs: []
  type: TYPE_NORMAL
- en: The `LANGUAGE` pragma enables non-standard language features.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`FlexibleInstances` makes the compiler consider [more typeclass instances as
    legal](http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules)
    than the Haskell 98 standard allows.'
  prefs: []
  type: TYPE_NORMAL
- en: More about pragmas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll see a few more pragmas as we progress.
  prefs: []
  type: TYPE_NORMAL
- en: Some are widely used, others are not.
  prefs: []
  type: TYPE_NORMAL
- en: Some are safe, others are not...
  prefs: []
  type: TYPE_NORMAL
- en: up to and including allowing the typechecker to go into an infinite loop! (`UndecidableInstances`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlexibleInstances` is widely used and often safe.'
  prefs: []
  type: TYPE_NORMAL
- en: Back to our fix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This *will* typecheck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: But is it canonical?
  prefs: []
  type: TYPE_NORMAL
- en: Canonicality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why worry about our `Monoid` instance being canonical?
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time you declare an instance of any typeclass:'
  prefs: []
  type: TYPE_NORMAL
- en: It is automatically made available to every module that imports your module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't say "I don't want to import instance `X`" :-(
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you define a weird instance of a popular typeclass, you'll "infect" people
    who import your module.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your instances make sense!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Via use of `newtype`, we don't accidentally associate a silly `Monoid` instance
    with `Either String a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: HTTP POST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's upload some vitally important data to a server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Multipart form upload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we POST multipart data to a form (e.g. uploading a photo), some information
    is mandatory, while other stuff is optional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Uploading data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we want to build a HTTP client that supports POST.
  prefs: []
  type: TYPE_NORMAL
- en: Web pages tend to expect multipart form data, while REST APIs have different
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some types that let us represent a POST body.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Can you write a `Monoid` instance for `Payload`?
  prefs: []
  type: TYPE_NORMAL
- en: Decide for yourself, then discuss with a partner for 2 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Huh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This part is easy enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What about the rest of `mappend`?
  prefs: []
  type: TYPE_NORMAL
- en: Semantic problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is easy to see how we can glom together `Params` or `FormData`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: However, mixing `Raw` with `Params`, or `Params` with `FormData`, is nonsensical.
  prefs: []
  type: TYPE_NORMAL
- en: A straightforward `Monoid` instance will have to crash (!!!) if we try this.
  prefs: []
  type: TYPE_NORMAL
- en: Handling failure (badly)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we use the `Maybe` type to represent a failed attempt to `mappend`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Yay?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This compiles, but it has a conceptual problem.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we use `mappend`, we have to pattern-match the result to see if the
    `mappend` succeeded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In API design circles, this is called "crappy".
  prefs: []
  type: TYPE_NORMAL
- en: But wait, it gets worse!
  prefs: []
  type: TYPE_NORMAL
- en: O error message, where art thou?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let me try this in `ghci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Overlapping instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember `FlexibleInstances`?
  prefs: []
  type: TYPE_NORMAL
- en: It allowed us to write a `Monoid` instance for the type `Maybe Payload`.
  prefs: []
  type: TYPE_NORMAL
- en: Trouble is, `Data.Monoid` already defined an instance for `Maybe a`.
  prefs: []
  type: TYPE_NORMAL
- en: '`FlexibleInstances` allows these two *definitions* to coexist happily.'
  prefs: []
  type: TYPE_NORMAL
- en: But when we want to *use* an instance, GHC doesn't know which one to use!
  prefs: []
  type: TYPE_NORMAL
- en: Overlapping instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the `OverlappingInstances` pragma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This allows multiple instances to coexist *and* be used.
  prefs: []
  type: TYPE_NORMAL
- en: The most specific instance that is visible will be used.
  prefs: []
  type: TYPE_NORMAL
- en: A very handy extension!
  prefs: []
  type: TYPE_NORMAL
- en: Also a big semantic gun pointing at your foot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems with overlapping instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why worry about `OverlappingInstances`?
  prefs: []
  type: TYPE_NORMAL
- en: Makes it very easy for incorrect programs to still typecheck.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can cause confusing error messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A program that typechecks can have its meaning changed by adding an instance
    declaration in some remote module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the plus side, you can [publish papers about their problems](http://web.cecs.pdx.edu/~jgmorris/pubs/morris-icfp2010-instances.pdf),
    so they're not bad for an academic career.
  prefs: []
  type: TYPE_NORMAL
- en: Checking in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a `Monoid` instance that:'
  prefs: []
  type: TYPE_NORMAL
- en: Has a janky API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses a dodgy language extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we do better?
  prefs: []
  type: TYPE_NORMAL
- en: Phantom types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's add a type parameter on the left hand side of our `Payload` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The type variable `a` *does not appear in the RHS*.
  prefs: []
  type: TYPE_NORMAL
- en: We call this a *phantom type*.
  prefs: []
  type: TYPE_NORMAL
- en: What's it for?
  prefs: []
  type: TYPE_NORMAL
- en: A tiny upload API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Consider the types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice:'
  prefs: []
  type: TYPE_NORMAL
- en: The first function returns a `Payload [Param]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second returns a `Payload [Part]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phantom parameter makes these *distinct types*.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime representation is the same in each case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler prevents us from mixing the two by accident.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code moment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please write a body for `addParams` below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the code you''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You have five minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Making this all work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a constrained public API for creating `Payload` values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How do we enforce this?
  prefs: []
  type: TYPE_NORMAL
- en: We export the *name* of the type `Part`, but *not any of its constructors*.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `(..)` notation below means "export the type `Part` and all of its constructors".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Exporting a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `(..)` notation below means "export the type `Part` and all of its constructors".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we omit the `(..)` below, meaning "export the type `Payload`, but
    *not any of its constructors*".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Exporting a type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `(..)` notation below means "export the type `Part` and all of its constructors".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: So we export the `Payload` type, and *only* the functions that we defined and
    control ("smart constructors") that construct values of this type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Trying it out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `ghci`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses my favourite operator from `Data.Monoid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: What do we get if we try this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Last of the monoids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For which of the following should we write `Monoid` instances?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Why care so much about monoids?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Monoids have many merits:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy for clients to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force you to address API design problems early on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoids without an identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like the abstract algebraic approach?
  prefs: []
  type: TYPE_NORMAL
- en: 'A package on Hackage named `semigroups` gives us monoids *without* an identity
    operation: semigroups.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alas:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Monoid` type was developed before the `semigroups` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two should be related, but thanks to this accident of history are not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why care about phantom types and monoids?
  prefs: []
  type: TYPE_NORMAL
- en: We want to build the simplest correct libraries we can
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoids help us focus on simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Phantom types make it easier to build APIs where flat-out broken behaviours
    can be made impossible by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already seen the very handy `MVar` type, which represents a "blocking
    mutable box": we can put a value in or take one out, but we''ll block if we put
    when full or take when empty.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though `MVar`s are the fastest blocking concurrent structure in the industry
    (they made the the Kessel Run in less than twelve parsecs!), we don't always want
    blocking semantics.
  prefs: []
  type: TYPE_NORMAL
- en: For cases where we want *non-*blocking updates, there's the `IORef` type, which
    gives us mutable references.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Managing mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Application writers are often faced with a question like this:'
  prefs: []
  type: TYPE_NORMAL
- en: I have a big app, and parts of it need their behaviour tweaked by an administrator
    at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are of course many ways to address this sort of problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider one where we use a reference to a piece of config data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any code that''s executing in the `IO` monad can, if it knows the name of the
    config reference, retrieve the current config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The trouble is, ill-behaved code could clearly also *modify* the current configuration,
    and leave us with a debugging nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: Phantom types to the rescue!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new type of mutable reference.
  prefs: []
  type: TYPE_NORMAL
- en: We use a phantom type `t` to statically track whether a piece of code is allowed
    to modify the reference or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, our use of `newtype` here means that the `Ref` type only exists at
    compile time: it imposes *no* runtime cost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using a phantom type, we don''t even need values of our access
    control types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We're already in a good spot! Not only are we creating compiler-enforced access
    control, but it will have *zero* runtime cost.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mutable reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a new reference, we just have to ensure that it has the right type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Reading and writing a mutable reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we want to be able to read both read-only and read-write references, we
    don't need to mention the access mode when writing a type signature for `readRef`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Of course, code can only write to a reference if the compiler can statically
    prove (via the type system) that it has write access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Converting a reference to read-only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function allows us to convert any kind of reference into a read-only reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In order to prevent clients from promoting a reference from read-only to read-write,
    we do *not* provide a function that goes in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also use the familiar technique of constructor hiding at the top of our
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *really* good read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Data analysis with monoids](http://twdkz.wordpress.com/2013/05/31/data-analysis-with-monoids/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monoids for MapReduce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Googleâ€™s MapReduce Programming Model---Revisited](http://userpages.uni-koblenz.de/~laemmel/MapReduce/paper.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
