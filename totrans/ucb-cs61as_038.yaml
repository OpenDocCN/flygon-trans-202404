- en: Using Let to Create Local Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Local variables** are variables that only exist within a local environment.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The local environment is the environment created by the function `foo`, and
    the local variable is `a`. Note that `x` is *not* a local variable, even though
    it also cannot be accessed outside of `foo`â€”it is formally called the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to `let`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The special form `let` is essentially a call to a lambda function, arranged
    differently. For example, take the following lambda function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following let statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When will this ever be useful? Two words: local variables. Rarely will we use
    a `let` statement to simply call a lambda function. Instead, we use it create
    local variables inside of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An Example: Polynomials'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we want to use Racket to compute the following polynomial with any
    given *x* and *y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax]f(x,y) = x(1+xy)^2 + y (1-y) + (1+xy)(1-y)[/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rewriting this ugly polynomial as an ugly procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Yuck. Instead, we could use some substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax]\displaystyle a = 1 + xy[/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax]\displaystyle b = 1 -y[/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: 'So that we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax]\displaystyle f(x,y) = xa^2 + yb + ab[/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, I guess that''s better. Writing this in Racket, we will define a helper
    function called `f-helper` so that we can use substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a minute to confirm that this does the same thing as the earlier definition
    of `f`. As we learned in the previous section, we don''t really need an extra
    function definition inside `f`. Instead, we can use a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, even after all this substitution and reorganizing, it's still a bit messy.
    This is where `let` comes in!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we get a more readable version of our initial polynomial function `f`.
    We can clearly see that we're assigning a value to `a` and `b`, then plugging
    it into the body of the `let` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '`let`: General Form'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The general structure of a let statement is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Remember, underneath, this is nothing more than a lambda call. The above structure
    is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Try out these expressions (and more!) in the Racket interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '(Note: A semicolon denotes a comment. Racket will ignore the rest of the line
    after a semicolon.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
