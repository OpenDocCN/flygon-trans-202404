["```\n\n      \"*Algorithms are the computational content of proofs*.\"  \u2014Robert Harper\n\n```", "```\n\n    We have seen that Coq has mechanisms both for *programming*,\n    using inductive data types like nat or list and functions over\n    these types, and for *proving* properties of these programs, using\n    inductive propositions (like ev), implication, universal\n    quantification, and the like.  So far, we have mostly treated\n    these mechanisms as if they were quite separate, and for many\n    purposes this is a good way to think.  But we have also seen hints\n    that Coq's programming and proving facilities are closely related.\n    For example, the keyword Inductive is used to declare both data\n    types and propositions, and \u2192 is used both to describe the type\n    of functions on data and logical implication.  This is not just a\n    syntactic accident!  In fact, programs and proofs in Coq are\n    almost the same thing.  In this chapter we will study how this\n    works.\n\n    We have already seen the fundamental idea: provability in Coq is\n    represented by concrete *evidence*.  When we construct the proof\n    of a basic proposition, we are actually building a tree of\n    evidence, which can be thought of as a data structure.\n\n    If the proposition is an implication like A \u2192 B, then its proof\n    will be an evidence *transformer*: a recipe for converting\n    evidence for A into evidence for B.  So at a fundamental level,\n    proofs are simply programs that manipulate evidence. \n\n    Question: If evidence is data, what are propositions themselves?\n\n    Answer: They are types!\n\n    Look again at the formal definition of the ev property.\n\n```", "```\n\n    Suppose we introduce an alternative pronunciation of \":\".\n    Instead of \"has type,\" we can say \"is a proof of.\"  For example,\n    the second line in the definition of ev declares that ev_0 : ev 0.  Instead of \"ev_0 has type ev 0,\" we can say that \"ev_0\n    is a proof of ev 0.\" \n\n    This pun between types and propositions \u2014 between : as \"has type\"\n    and : as \"is a proof of\" or \"is evidence for\" \u2014 is called the\n    *Curry-Howard correspondence*.  It proposes a deep connection\n    between the world of logic and the world of computation:\n\n```", "```\n\n    See [[Wadler 2015]](Bib.html#Wadler 2015) for a brief history and an up-to-date exposition.\n\n    Many useful insights follow from this connection.  To begin with,\n    it gives us a natural interpretation of the type of the ev_SS\n    constructor:\n\n```", "```\n\n    This can be read \"ev_SS is a constructor that takes two\n    arguments \u2014 a number n and evidence for the proposition ev n \u2014 and yields evidence for the proposition ev (S (S n)).\" \n\n    Now let's look again at a previous proof involving ev.\n\n```", "```\n\n    As with ordinary data values and functions, we can use the Print\n    command to see the *proof object* that results from this proof\n    script.\n\n```", "```\n\n    As a matter of fact, we can also write down this proof object\n    *directly*, without the need for a separate proof script:\n\n```", "```\n\n    The expression ev_SS 2 (ev_SS 0 ev_0) can be thought of as\n    instantiating the parameterized constructor ev_SS with the\n    specific arguments 2 and 0 plus the corresponding proof\n    objects for its premises ev 2 and ev 0.  Alternatively, we can\n    think of ev_SS as a primitive \"evidence constructor\" that, when\n    applied to a particular number, wants to be further applied to\n    evidence that that number is even; its type,\n\n```", "```\nTheorem ev_4': ev 4.\nProof.\n\u00a0\u00a0apply (ev_SS 2 (ev_SS 0 ev_0)).\nQed.\n\n```", "```\n\n# Proof Scripts\n\n    The *proof objects* we've been discussing lie at the core of how\n    Coq operates.  When Coq is following a proof script, what is\n    happening internally is that it is gradually constructing a proof\n    object \u2014 a term whose type is the proposition being proved.  The\n    tactics between Proof and Qed tell it how to build up a term\n    of the required type.  To see this process in action, let's use\n    the Show Proof command to display the current state of the proof\n    tree at various points in the following tactic proof.\n\n```", "```\n\n    At any given moment, Coq has constructed a term with a\n    \"hole\" (indicated by ?Goal here, and so on), and it knows what\n    type of evidence is needed to fill this hole.  \n\n    Each hole corresponds to a subgoal, and the proof is\n    finished when there are no more subgoals.  At this point, the\n    evidence we've built stored in the global context under the name\n    given in the Theorem command. \n\n    Tactic proofs are useful and convenient, but they are not\n    essential: in principle, we can always construct the required\n    evidence by hand, as shown above. Then we can use Definition\n    (rather than Theorem) to give a global name directly to a\n    piece of evidence.\n\n```", "```\n\n    All these different ways of building the proof lead to exactly the\n    same evidence being saved in the global environment.\n\n```", "```\n\n#### Exercise: 1 star (eight_is_even)\n\n    Give a tactic proof and a proof object showing that ev 8.\n\n```", "```\n\n    \u2610\n\n```", "```\nTheorem ev_plus4 : \u2200n, ev n \u2192 ev (4 + n).\nProof.\n\u00a0\u00a0intros n H. simpl.\n\u00a0\u00a0apply ev_SS.\n\u00a0\u00a0apply ev_SS.\n\u00a0\u00a0apply H.\nQed.\n\n```", "```\nDefinition ev_plus4' : \u2200n, ev n \u2192 ev (4 + n) :=\n\u00a0\u00a0fun (n : nat) \u21d2 fun (H : ev n) \u21d2\n\u00a0\u00a0\u00a0\u00a0ev_SS (S (S n)) (ev_SS n H).\n\n```", "```\nDefinition ev_plus4'' (n : nat) (H : ev n) : ev (4 + n) :=\n\u00a0\u00a0ev_SS (S (S n)) (ev_SS n H).\n\nCheck ev_plus4''.\n(*\u00a0===>\u00a0ev_plus4''\u00a0:\u00a0forall\u00a0n\u00a0:\u00a0nat,\u00a0ev\u00a0n\u00a0->\u00a0ev\u00a0(4\u00a0+\u00a0n)\u00a0*)\n\n```", "```\nDefinition ev_plus2 : Prop :=\n\u00a0\u00a0\u2200n, \u2200(E : ev n), ev (n + 2).\n\n```", "```\nDefinition ev_plus2' : Prop :=\n\u00a0\u00a0\u2200n, \u2200(_ : ev n), ev (n + 2).\n\n```", "```\nDefinition ev_plus2'' : Prop :=\n\u00a0\u00a0\u2200n, ev n \u2192 ev (n + 2).\n\n```", "```\n\n# Programming with Tactics\n\n    If we can build proofs by giving explicit terms rather than\n    executing tactic scripts, you may be wondering whether we can\n    build *programs* using *tactics* rather than explicit terms.\n    Naturally, the answer is yes!\n\n```", "```\n\n    Notice that we terminate the Definition with a . rather than\n    with := followed by a term.  This tells Coq to enter *proof scripting mode* to build an object of type nat \u2192 nat.  Also, we\n    terminate the proof with Defined rather than Qed; this makes\n    the definition *transparent* so that it can be used in computation\n    like a normally-defined function.  (Qed-defined objects are\n    opaque during computation.)\n\n    This feature is mainly useful for writing functions with dependent\n    types, which we won't explore much further in this book.  But it\n    does illustrate the uniformity and orthogonality of the basic\n    ideas in Coq.\n\n```", "```\nModule Props.\n\n```", "```\nModule And.\n\nInductive and (P Q : Prop) : Prop :=\n| conj : P \u2192 Q \u2192 and P Q.\n\nEnd And.\n\n```", "```\nPrint prod.\n(*\u00a0===> \u00a0\u00a0\u00a0Inductive\u00a0prod\u00a0(X\u00a0Y\u00a0:\u00a0Type)\u00a0:\u00a0Type\u00a0:= \u00a0\u00a0\u00a0|\u00a0pair\u00a0:\u00a0X\u00a0->\u00a0Y\u00a0->\u00a0X\u00a0*\u00a0Y.\u00a0*)\n\n```", "```\nLemma and_comm : \u2200P Q : Prop, P \u2227 Q \u2194 Q \u2227 P.\nProof.\n\u00a0\u00a0intros P Q. split.\n\u00a0\u00a0- intros [HP HQ]. split.\n\u00a0\u00a0\u00a0\u00a0+ apply HQ.\n\u00a0\u00a0\u00a0\u00a0+ apply HP.\n\u00a0\u00a0- intros [HP HQ]. split.\n\u00a0\u00a0\u00a0\u00a0+ apply HQ.\n\u00a0\u00a0\u00a0\u00a0+ apply HP.\nQed.\n\n```", "```\nDefinition and_comm'_aux P Q (H : P \u2227 Q) :=\n\u00a0\u00a0match H with\n\u00a0\u00a0| conj HP HQ \u21d2 conj HQ HP\n\u00a0\u00a0end.\n\nDefinition and_comm' P Q : P \u2227 Q \u2194 Q \u2227 P :=\n\u00a0\u00a0conj (and_comm'_aux P Q) (and_comm'_aux Q P).\n\n```", "```\nDefinition conj_fact : \u2200P Q R, P \u2227 Q \u2192 Q \u2227 R \u2192 P \u2227 R \n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\n```", "```\nModule Or.\n\nInductive or (P Q : Prop) : Prop :=\n| or_introl : P \u2192 or P Q\n| or_intror : Q \u2192 or P Q.\n\nEnd Or.\n\n```", "```\nDefinition or_comm : \u2200P Q, P \u2228 Q \u2192 Q \u2228 P \n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\n```", "```\nModule Ex.\n\nInductive ex {A : Type} (P : A \u2192 Prop) : Prop :=\n| ex_intro : \u2200x : A, P x \u2192 ex P.\n\nEnd Ex.\n\n```", "```\nCheck ex (fun n \u21d2 ev n).\n(*\u00a0===>\u00a0exists\u00a0n\u00a0:\u00a0nat,\u00a0ev\u00a0n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0:\u00a0Prop\u00a0*)\n\n```", "```\nDefinition some_nat_is_even : \u2203n, ev n :=\n\u00a0\u00a0ex_intro ev 4 (ev_SS 2 (ev_SS 0 ev_0)).\n\n```", "```\nDefinition ex_ev_Sn : ex (fun n \u21d2 ev (S n)) \n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\n```", "```\nInductive True : Prop :=\n\u00a0\u00a0| I : True.\n\n```", "```\nInductive False : Prop :=.\n\n```", "```\nEnd Props.\n\n```", "```\nModule MyEquality.\n\nInductive eq {X:Type} : X \u2192 X \u2192 Prop :=\n| eq_refl : \u2200x, eq x x.\n\nNotation \"x = y\" := (eq x y)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(at level 70, no associativity)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0: type_scope.\n\n```", "```\nLemma leibniz_equality : \u2200(X : Type) (x y: X),\n\u00a0\u00a0x = y \u2192 \u2200P:X\u2192Prop, P x \u2192 P y.\nProof.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nLemma four: 2 + 2 = 1 + 3.\nProof.\n\u00a0\u00a0apply eq_refl.\nQed.\n\n```", "```\nDefinition four' : 2 + 2 = 1 + 3 :=\n\u00a0\u00a0eq_refl 4.\n\nDefinition singleton : \u2200(X:Set) (x:X), []++[x] = x::[]  :=\n\u00a0\u00a0fun (X:Set) (x:X) \u21d2 eq_refl [x].\n\nEnd MyEquality.\n\nDefinition quiz6 : \u2203x,  x + 3 = 4\n\u00a0\u00a0:= ex_intro (fun z \u21d2 (z + 3 = 4)) 1 (refl_equal 4).\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]