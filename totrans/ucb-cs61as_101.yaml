- en: Exercises for Partner B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Question B3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define a method `take-all` for people. If given that message, a person should
    `take` all the things at the current location that are not already owned by someone.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Question B4: Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's unrealistic that anyone can take anything from anyone. We want to give
    our characters a `strength`, and then one person can take something from another
    only if the first has greater `strength` than the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we aren''t going to clutter up the person class by adding a local
    `strength` variable. That''s because we can anticipate wanting to add lots more
    attributes as we develop the program further. People can have *charisma* or *wisdom*;
    things can be *food* or not; places can be *indoors* or not. Therefore, you will
    create a class called `basic-object` that keeps a local variable called `properties`
    containing an attribute-value table like the one that we used with `get` and `put`
    in Lesson 6\. However, `get` and `put` refer to a single, fixed table for all
    operations; in this situation we need a separate table for every object. The file
    `tables.scm` contains an implementation of the table Abstract Data Type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor: `(make-table)` returns a new, empty table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mutator: `(insert! key value table)` adds a new key-value pair to a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Selector: `(lookup key table)` returns the corresponding value, or `#f` if
    the key is not in the table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll learn how tables are implemented in [SICP 3.3.3 (pp. 266-268)](https://mitpress.mit.edu/sicp/full-text/sicp/book/node63.html).
    For now, just take them as primitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll modify the `person`, `place` and `thing` classes so that they will
    inherit from `basic-object`. This object will accept a message `put` so that the
    following call does the right thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Also, the `basic-object` should treat any message not otherwise recognized as
    a request for the attribute of that name, so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: should work WITHOUT having to write an explicit `strength` method in the class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget that the property list mechanism returns `#f` if you ask for
    a property that isn''t in the list. This means that the following call should
    never give an error message, even if we haven''t `put` that property in that object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is important for true-or-false properties, which will automatically be
    `#f` (but not an error) unless we explicitly `put` a `#t` value for them.
  prefs: []
  type: TYPE_NORMAL
- en: Give people some reasonable initial strength. (They should be the same for every
    newly instantiated person object.) Later, they'll be able to get stronger by eating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Question B4: Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll notice that the type predicate `person?` checks to see if the type of
    the argument is a member of the list `'(person police thief)`. This means that
    the `person?` procedure has to keep a list of all the classes that inherit from
    `person`, which is a pain if we make a new subclass.
  prefs: []
  type: TYPE_NORMAL
- en: We'll take advantage of the property list to implement a better system for type
    checking. If we add a method named `person?` to the person class, and have it
    always return `#t`, then any object that's a type of person will automatically
    inherit this method. Objects that don't inherit from person won't find a `person?`
    method and won't find an entry for `person?` in their property table, so they'll
    return `#f`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, places should have a `place?` method, and things a `thing?` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Add these type methods and change the implementation of the type predicate procedures
    (at the very bottom of `adv.scm`) to this new implementation. Don't forget to
    add the definition for `place?`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new type predicate should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `person?` should work for classes that inherit from `person`,
    like `thief` and `police` (defined later). Similarly with `place?` and `thing`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Question B5: Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the modern era, many places allow you to get connected to the net. Define
    a `hotspot` as a kind of place that allows network connectivity. Each hotspot
    should have a `name` and a `password` as instantiation variables that you must
    know to connect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '(Note: We''re envisioning a per-network password, not a per-person password
    as you use with AirBears.) The hotspot has a `connect` method with two arguments,
    a `laptop` (a kind of thing, to be invented in a moment) and a password. If the
    password is correct, and the laptop is in the hotspot, add it to a list of connected
    laptops otherwise, return an error. When the laptop leaves the hotspot, remove
    it from the list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Hotspots also have a `surf` method with two arguments, a laptop and a text string,
    such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the laptop is connected to the network, then the surf method should
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: where URL is the text string argument (note the space after x in "lynx "). Otherwise,
    return an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Question B5: Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now invent the `laptop` class. A laptop has one instantiation variable, its
    name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A laptop is a thing that has two extra methods: `connect`, with a password
    as argument, sends a `connect` message to the place where the laptop is. If the
    password is wrong, return an error.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A laptop also has another method, `surf`, with a URL text string as argument,
    sends a `surf` message to the place where it is. Thus, whenever a laptop enters
    a new hotspot, the user must ask to `connect` to that hotspot's network; when
    the laptop leaves the hotspot, it must automatically be disconnected from the
    network. (If it's in a place other than a hotspot, the `surf` message won't be
    understood; if it's in a hotspot but not connected, return an error).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
