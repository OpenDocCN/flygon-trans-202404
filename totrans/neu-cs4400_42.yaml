- en: Feature EmbeddingTuesday, February 14th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw that the difference between lazy evaluation and eager evaluation is
    in the evaluation rules for `with` forms, function applications, etc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: is eager, and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: is lazy. But is the first rule *really* eager? The fact is that the only thing
    that makes it eager is the fact that our understanding of the mathematical notation
    is eager — if we were to take math as lazy, then the description of the rule becomes
    a description of lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to look at this is — take the piece of code that implements this
    evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'and the same question applies: is this really implementing eager evaluation?
    We know that this is indeed eager — we can simply try it and check that it is,
    but it is only eager because we are using an eager language for the implementation!
    If our own language was lazy, then the evaluator’s implementation would run lazily,
    which means that the above applications of the the `eval` and the `subst` functions
    would also be lazy, making our evaluator lazy as well.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a general phenomena where some of the semantic features of the language
    we use (math in the formal description, Racket in our code) gets *embedded* into
    the language we implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example — consider the code that implements arithmetics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'what if it was written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Would it still implement unlimited integers and exact fractions? That depends
    on the language that was used to implement it: the above syntax suggests C, C++,
    Java, or some other relative, which usually come with limited integers and no
    exact fractions. But this really depends on the language — even our own code has
    unlimited integers and exact rationals only because Racket has them. If we were
    using a language that didn’t have such features (there are such Scheme implementations),
    then our implemented language would absorb these (lack of) features too, and its
    own numbers would be limited in just the same way. (And this includes the syntax
    for numbers, which we embedded intentionally, like the syntax for identifiers).'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that we should be aware of such issues, and be very careful
    when we talk about semantics. Even the language that we use to communicate (semi-formal
    logic) can mean different things.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside: read “Reflections on Trusting Trust” by Ken Thompson (You can skip to
    the “Stage II” part to get to the interesting stuff.)'
  prefs: []
  type: TYPE_NORMAL
- en: (And when you’re done, look for “XcodeGhost” to see a relevant example, and
    don’t miss the leaked document on the wikipedia page…)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is yet another variation of our evaluator that is even closer to a meta-circular
    evaluator. It uses Racket values directly to implement values, so arithmetic operations
    become straightforward. Note especially how the case for function application
    is similar to arithmetics: a FLANG function application translates to a Racket
    function application. In both cases (applications and arithmetics) we don’t even
    check the objects since they are simple Racket objects — if our language happens
    to have some meaning for arithmetics with functions, or for applying numbers,
    then we will inherit the same semantics in our language. This means that we now
    specify less behavior and fall back more often on what Racket does.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use Racket values with this type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And the evaluation function can now be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the arithmetics implementation is simple — it’s a direct translation
    of the FLANG syntax to Racket operations, and since we don’t check the inputs
    to the Racket operations, we let Racket throw type errors for us. Note also how
    function application is just like the arithmetic operations: a FLANG application
    is directly translated to a Racket application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this does not work quite as simply in Typed Racket. The whole point
    of typechecking is that we never run into type errors — so we cannot throw back
    on Racket errors since code that might produce them is forbidden! A way around
    this is to perform explicit checks that guarantee that Racket cannot run into
    type errors. We do this with the following two helpers that are defined inside
    `eval`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that Typed Racket is “smart enough” to figure out that in `evalF` the result
    of the recursive evaluation has to be either `Number` or `(VAL -> VAL)`; and since
    the `if` throws out on numbers, we’re left with `(VAL -> VAL)` functions, not
    just any function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
