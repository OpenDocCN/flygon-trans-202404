- en: '| [![](../Images/d03dc8ab9854158ad15ab0c1410b2f9f.jpg)](/http://philip.greenspun.com/images/pcd1587/17-17.tcl)
    |'
  id: totrans-0
  prefs: []
  type: TYPE_TB
  zh: '| [![](../Images/d03dc8ab9854158ad15ab0c1410b2f9f.jpg)](/http://philip.greenspun.com/images/pcd1587/17-17.tcl)
    |'
- en: Foreign and Legacy Data
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部和遗留数据
- en: part of [SQL for Web Nerds](index.html) (this chapter written by [Michael Booth](mailto:mbooth@arsdigita.com)
    and [Philip Greenspun](http://philip.greenspun.com/)) |
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 部分来自[Web 网络爱好者的 SQL](index.html)（本章由[Michael Booth](mailto:mbooth@arsdigita.com)和[Philip
    Greenspun](http://philip.greenspun.com/)编写）|
- en: '* * *'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[![](../Images/c81fd517eae17ed3d32975824febb5ca.jpg)](/http://philip.greenspun.com/images/pcd1587/1-1.tcl)
    Most of the world''s useful data are either residing on a server beyond your control
    or inside a database management system other than Oracle. Either way, we refer
    to these data as *foreign* from the perspective of one''s local Oracle database.
    Your objective is always the same: **Treat foreign data as though they were residing
    in local SQL tables.**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/c81fd517eae17ed3d32975824febb5ca.jpg)](/http://philip.greenspun.com/images/pcd1587/1-1.tcl)
    世界上大部分有用的数据要么存储在您无法控制的服务器上，要么存储在除 Oracle 之外的数据库管理系统中。无论哪种方式，从本地 Oracle 数据库的角度来看，我们将这些数据称为*外部数据*。您的目标始终是相同的：**将外部数据视为存储在本地
    SQL 表中一样处理**。'
- en: 'The benefits of physically or virtually dragging foreign data back to your
    Oracle cave are the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将外部数据物理或虚拟地拖回您的 Oracle 洞穴的好处如下：
- en: New developers don't have to think about where data are coming from.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新开发人员不必考虑数据来自何处。
- en: 'Developers can work with foreign data using the same query language that they
    use every day: SQL.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可以使用他们每天使用的相同查询语言处理外部数据：SQL。
- en: Developers can work with the same programming tools and systems that they've
    been using daily. They might use COBOL, they might use C, they might use Java,
    they might use Common Lisp, they might use Perl or Tcl, but you can be sure that
    they've learned how to send an SQL query to Oracle from these tools and therefore
    that they will be able to use the foreign data.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可以使用他们每天使用的相同编程工具和系统。他们可能使用 COBOL，他们可能使用 C，他们可能使用 Java，他们可能使用 Common Lisp，他们可能使用
    Perl 或 Tcl，但您可以肯定他们已经学会如何从这些工具向 Oracle 发送 SQL 查询，因此他们将能够使用外部数据。
- en: A good conceptual way to look at what we're trying to accomplish is the construction
    of an SQL view of the foreign data. A standard SQL view may hide a 5-way join
    from the novice programmer. A *foreign table* hides the fact that data are coming
    from a foreign source.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的概念性方式来看待我们试图实现的目标是构建外部数据的 SQL 视图。标准的 SQL 视图可能会对初学者程序员隐藏一个 5 路连接。*外部表*隐藏了数据来自外部来源的事实。
- en: 'We will refer to the system that makes foreign data available locally as an
    *aggregation architecture*. In designing an individual aggregation architecture
    you will need to address the following issues:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使外部数据在本地可用的系统称为*聚合架构*。在设计个体聚合架构时，您需要解决以下问题：
- en: 'Coherency: Is it acceptable for your local version of the data to be out of
    sync with the foreign data? If so, to what extent?'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一致性：您的数据的本地版本与外部数据不同步是否可以接受？如果可以，程度如何？
- en: 'Updatability: Is your local view updatable? I.e., can a programmer perform
    a transaction on the foreign database management system by updating the local
    view?'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可更新性：您的本地视图是否可更新？即，程序员是否可以通过更新本地视图在外部数据库管理系统上执行事务？
- en: 'Social: To what extent is the foreign data provider willing to let you into
    his or her database?'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 社交：外部数据提供者愿意让您进入他或她的数据库的程度如何？
- en: Degenerate Aggregation
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退化聚合
- en: 'If the foreign data are stored in an Oracle database and the people who run
    that database are cooperative, you can practice a degenerate form of aggregation:
    Oracle to Oracle communication.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部数据存储在 Oracle 数据库中，并且管理该数据库的人员愿意合作，您可以练习一种退化形式的聚合：Oracle 到 Oracle 的通信。
- en: 'The most degenerate form of degenerate aggregation is when the foreign data
    are in the same Oracle installation but owned by a different user. To make it
    concrete, let''s assume that you work for Eli Lilly in the data warehousing department,
    which is part of marketing. Your Oracle user name is "marketing". The foreign
    data in which you''re interested are in the `prozac_orders` table, owned by the
    "sales" user. In this case your aggregation architecture is the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最退化的退化聚合形式是当外部数据位于同一 Oracle 安装中但由不同用户拥有时。具体来说，假设您在 Eli Lilly 公司的数据仓库部门工作，该部门隶属于市场营销部门。您的
    Oracle 用户名是"marketing"。您感兴趣的外部数据位于由"sales"用户拥有的`prozac_orders`表中。在这种情况下，您的聚合架构如下：
- en: connect to Oracle as the foreign data owner (sales) and GRANT SELECT ON PROZAC_ORDERS
    TO MARKETING
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以外部数据所有者（sales）的身份连接到 Oracle 并授予 MARKETING 对 PROZAC_ORDERS 的 SELECT 权限
- en: connect to Oracle as the local user (marketing) and type SELECT * FROM SALES.PROZAC_ORDERS
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为本地用户（marketing）连接到 Oracle 并键入 SELECT * FROM SALES.PROZAC_ORDERS
- en: Done.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 完成。
- en: Slightly Less Degenerate Aggregation
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 稍微不那么退化的聚合
- en: 'Imagine now that Prozac orders are processed on a dedicated on-line transaction
    processing (OLTP) database installation and your data warehouse (DW) is running
    on a physically separate computer. Both the OLTP and DW systems are running the
    Oracle database server and they are connected via a network. You need to take
    the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，Prozac 订单是在专用的在线事务处理（OLTP）数据库安装上处理的，而您的数据仓库（DW）在一个物理上独立的计算机上运行。OLTP 和
    DW 系统都在运行 Oracle 数据库服务器，并通过网络连接。您需要采取以下步骤：
- en: set up SQL*Net (Net8) on the OLTP system
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OLTP 系统上设置 SQL*Net (Net8)
- en: set up the DW Oracle server to be a client to the OLTP server. If you are not
    using the Oracle naming services, you must edit $ORACLE_HOME/network/admin/tnsnames.ora
    to reference the OLTP system.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 DW Oracle 服务器作为 OLTP 服务器的客户端。如果您没有使用 Oracle 命名服务，您必须编辑 $ORACLE_HOME/network/admin/tnsnames.ora
    文件以引用 OLTP 系统。
- en: create a "marketing" user on the OLTP system
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OLTP 系统上创建一个名为"marketing"的用户
- en: on the OLTP system, log in as "sales" and GRANT SELECT ON PROZAC_ORDERS TO MARKETING
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 OLTP 系统上，以"sales"身份登录并授予 MARKETING 对 PROZAC_ORDERS 的 SELECT 权限
- en: 'on the DW system, create a database link to the OLTP system named "OLTP": CREATE
    DATABASE LINK OLTP CONNECT TO MARKETING IDENTIFIED BY *password for marketing*
    USING ''OLTP'';'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 DW 系统上，创建一个名为"OLTP"的到 OLTP 系统的数据库链接：CREATE DATABASE LINK OLTP CONNECT TO MARKETING
    IDENTIFIED BY *marketing 的密码* USING 'OLTP';
- en: on the DW system, log in as "marketing" and SELECT * FROM SALES.PROZAC_ORDERS@OLTP;
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 DW 系统上，以"marketing"身份登录并键入 SELECT * FROM SALES.PROZAC_ORDERS@OLTP;
- en: In both of these degenerate cases, there were no coherency issues. The foreign
    data were queried in real-time from their canonical database. This was made possible
    because of social agreement. The owners of the foreign data were willing to grant
    you unlimited access. Similarly, social issues decided the issue of updatability.
    With a GRANT only on SELECT, the foreign table would not be updatable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种退化情况下，没有一致性问题。外部数据是实时从其规范数据库中查询的。这是因为社会协议的存在。外部数据的所有者愿意授予您无限访问权限。同样，社会问题决定了可更新性问题。只有在
    SELECT 上授予权限，外部表才不可更新。
- en: Non-Oracle-Oracle Aggregation
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非 Oracle-Oracle 聚合
- en: What if foreign data aren't stored in an Oracle database or they are but you
    can't convince the owners to give you access? You will need some sort of computer
    program that knows how to fetch some or all of the foreign data and stuff it into
    an Oracle table locally. Let's start with a concrete example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部数据没有存储在 Oracle 数据库中，或者虽然存储在其中但您无法说服所有者给您访问权限，那该怎么办？您将需要一种计算机程序，它知道如何获取部分或全部外部数据并将其填充到本地的
    Oracle 表中。让我们从一个具体的例子开始。
- en: 'Suppose you work at Silicon Valley Blue Cross. The dimensional data warehouse
    has revealed a strong correlation between stock market troubles and clinical depression.
    People working for newly public companies with volatile stocks tend to get into
    a funk when their paper wealth proves illusory. The suits at Blue Cross think
    that they can save money and doctors'' visits by automatically issuing prescriptions
    for Prozac whenever an insured''s employer''s stock drops more than 10% in a day.
    To find candidates for happy pills, the following query should suffice:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在硅谷蓝十字工作。维度数据仓库揭示了股市困境和临床抑郁之间的强烈相关性。在股票波动较大的新上市公司工作的人在他们的虚拟财富被证明是虚幻时往往会陷入沮丧。蓝十字的人认为，他们可以通过在被保险人的雇主股票在一天内下跌超过
    10% 时自动开具 Prozac 处方来节省医疗费用和医生就诊次数。要找到开心药丸的候选人，以下查询应该足够：
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `stock_quotes` table is the foreign table here. Blue Cross does not operate
    a stock exchange. Therefore the authoritative price change data must necessarily
    be pulled from an external source. Imagine that the external source is http://quote.yahoo.com/.
    The mature engineering perspective on a Web site such as quote.yahoo.com is that
    it is an object whose methods are its URLs and the arguments to those methods
    are the form variables. To get a quotation for the software company Ariba (ticker
    ARBA), for example, we need to visit [http://quote.yahoo.com/q?s=arba](http://quote.yahoo.com/q?s=arba)
    in a Web browser. This is invoking the method "q" with an argument of "arba" for
    the form variable "s". The results come back in a human-readable HTML page with
    a lot of presentation markup and English text. It would be more convenient if
    Yahoo gave us results in a machine-readable form, e.g., a comma-separated list
    of values or an XML document. However, the HTML page may still be used as long
    as its structure does not vary from quote to quote and the percent change number
    can be pulled out with a regular expression or other computer program.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`stock_quotes` 表在这里是外部表。Blue Cross 没有运营股票交易所。因此，权威的价格变动数据必须从外部来源获取。想象一下，外部来源是
    http://quote.yahoo.com/。对于像 Ariba（股票代码 ARBA）这样的软件公司，我们需要在 Web 浏览器中访问 [http://quote.yahoo.com/q?s=arba](http://quote.yahoo.com/q?s=arba)
    来获取报价。这是使用带有形式变量 "s" 的参数 "arba" 调用方法 "q"。结果以人类可读的 HTML 页面的形式返回，其中包含大量的呈现标记和英文文本。如果
    Yahoo 给我们提供机器可读的结果会更方便，例如，以逗号分隔的值列表或 XML 文档。但是，只要 HTML 页面的结构不因报价而变化，并且百分比变化数字可以用正则表达式或其他计算机程序提取出来，它仍然可以使用。'
- en: What are the issues in designing an aggregation architecture for this problem?
    First is coherency. It would be nice to have up-to-the-minute stock quotes but,
    on the other hand, it seems kind of silly to repeatedly query quote.yahoo.com
    for the same symbol. In fact, after 4:30 PM eastern time when the US stock market
    closes, there really isn't any reason to ask for a new quote on a symbol until
    9:30 AM the next day. Given some reasonable assumptions about caching, once the
    `stock_quotes` table has been used a few times, queries will be able to execute
    much much faster since quote data will be pulled from a local cache rather than
    fetched over the Internet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 设计此问题的聚合架构时有哪些问题？首先是一致性。拥有最新的股票报价会很好，但另一方面，反复查询相同的符号似乎有点愚蠢。实际上，在美国股市关闭后的东部时间下午
    4:30 之后，没有任何理由在第二天上午 9:30 之前询问相同的符号的新报价。在对缓存做出一些合理假设后，一旦 `stock_quotes` 表被使用了几次，查询将能够执行得更快，因为报价数据将从本地缓存中提取，而不是从互联网上获取。
- en: We don't have to think very hard about updatability. Blue Cross does not run
    a stock exchange therefore Blue Cross cannot update a stock's price. Our local
    view will not be updatable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必过多考虑可更新性。Blue Cross 不经营股票交易所，因此 Blue Cross 无法更新股票价格。我们的本地视图将不可更新。
- en: The social issue seems straightforward at first. Yahoo is making quotes available
    to any client on the public Internet. It looks at first glance as though our computer
    program can only request one quote at a time. However, if we fetch [http://quote.yahoo.com/q?s=arba**+ibm**](http://quote.yahoo.com/q?s=arba+ibm),
    we can get two quotes at the same time. It might even be possible to grab all
    of our insureds' employers' stock prices in one big page. A potential fly in the
    ointment is Yahoo's terms of service at [http://docs.yahoo.com/info/terms/](http://docs.yahoo.com/info/terms/)
    where they stipulate
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个社会问题乍看起来很简单。Yahoo可以向公共互联网上的任何客户提供报价。乍一看，我们的计算机程序似乎只能一次请求一个报价。然而，如果我们获取 [http://quote.yahoo.com/q?s=arba**+ibm**](http://quote.yahoo.com/q?s=arba+ibm)，我们可以同时获得两个报价。甚至可能一次性获取所有被保险人的雇主的股价，放在一个大页面上。一个潜在的麻烦在于
    Yahoo 在其服务条款 [http://docs.yahoo.com/info/terms/](http://docs.yahoo.com/info/terms/)
    中规定了。
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Where and when to run our programs
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们的程序在哪里和何时运行
- en: We need to write a computer program (the "fetcher") that can fetch the HTML
    page from Yahoo, pull out the price change figures, and stuff them into the `stock_quotes`
    table. We also need a more general computer program (the "checker") that can look
    at the foreign data required, see how old the cached data in `stock_quotes` are,
    and run the fetcher program if necessary.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个计算机程序（“抓取程序”），它可以从 Yahoo 获取 HTML 页面，提取价格变动数据，并将其放入 `stock_quotes` 表中。我们还需要一个更通用的计算机程序（“检查程序”），它可以查看所需的外部数据，查看
    `stock_quotes` 中缓存数据的年龄，并在必要时运行抓取程序。
- en: 'There are three Turing-complete computer languages built into Oracle: C, Java,
    PL/SQL. "Turing-complete" means that any program that can be written for any computer
    can be written to run inside Oracle. Since you eventually want the foreign data
    to be combined with data inside Oracle, it makes sense to run all of your aggregation
    code inside the database. Oracle includes built-in functions to facilitate the
    retrieval of Web pages (see [http://oradoc.photo.net/ora816/server.816/a76936/utl_http.htm#998100](http://oradoc.photo.net/ora816/server.816/a76936/utl_http.htm#998100)).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 内置了三种图灵完备的计算机语言：C、Java、PL/SQL。“图灵完备”意味着可以为任何计算机编写的任何程序都可以编写为在 Oracle
    内运行。由于最终希望将外部数据与 Oracle 内部数据结合起来，因此在数据库内运行所有聚合代码是有意义的。Oracle 包含了用于方便检索 Web 页面的内置函数（参见
    [http://oradoc.photo.net/ora816/server.816/a76936/utl_http.htm#998100](http://oradoc.photo.net/ora816/server.816/a76936/utl_http.htm#998100)）。
- en: In an ideal world you could define a database trigger that would fire every
    time a query was about to SELECT from the `stock_quotes` table. This trigger would
    somehow figure out which rows of the foreign table were going to be required.
    It would run the checker program to make sure that none of the cached data were
    too old, and the checker in turn might run the fetcher.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界中，您可以定义一个数据库触发器，每次查询将要从 `stock_quotes` 表中选择时触发。这个触发器将以某种方式找出需要哪些行的外部表。它将运行检查程序，以确保缓存的数据都不太旧，而检查程序可能反过来会运行抓取程序。
- en: Why won't this work? As of Oracle version 8.1.6, it is impossible to define
    a trigger on SELECT. Even if you could, there is no advertised way for the triggered
    program to explore the SQL query that is being executed or to ask the SQL optimizer
    which rows will be required.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这不起作用？截至 Oracle 版本 8.1.6，无法定义对 SELECT 的触发器。即使可以，触发程序也无法探索正在执行的 SQL 查询或询问
    SQL 优化器将要求哪些行。
- en: The PostgreSQL RDBMS has a "rule system" (see [http://www.postgresql.org/docs/programmer/x968.htm](http://www.postgresql.org/docs/programmer/x968.htm))
    which can intercept and transform a SELECT. It takes the output of the SQL parser,
    applies one or more transformation rules, and produces a new set of queries to
    be executed. For example, a rule may specify that any SELECT which targets the
    table "foo" should be turned into a SELECT from the table "bar" instead; this
    is how Postgres implements views. As it stands, the only transformation that can
    be applied to a SELECT is to replace it with a single, alternative SELECT - but
    PostgreSQL is open source software which anyone is free to enhance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 关系型数据库管理系统具有一个“规则系统”（参见 [http://www.postgresql.org/docs/programmer/x968.htm](http://www.postgresql.org/docs/programmer/x968.htm)），它可以拦截和转换
    SELECT 查询。它接收 SQL 解析器的输出，应用一个或多个转换规则，并产生一组新的要执行的查询。例如，一条规则可能指定任何针对表“foo”的 SELECT
    应该改为从表“bar”中进行 SELECT；这就是 Postgres 实现视图的方式。目前，对 SELECT 可应用的唯一转换是用单个替代 SELECT 替换它
    - 但 PostgreSQL 是开源软件，任何人都可以自由增强它。
- en: The long term fix is to wait for the RDBMS vendors to augment their products.
    Help is on the way. The good news is that a portion of the ANSI/ISO SQL-99 standard
    mandates that RDBMS vendors, including Oracle, provide support for wrapping external
    data sources. The bad news is that the SQL-99 standard is being released in chunks,
    the wrapper extension won't be published until 2001, and it may be several years
    before commercial RDBMSes implement the new standard.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 长期的解决方案是等待关系型数据库管理系统供应商增强其产品。帮助即将到来。好消息是，ANSI/ISO SQL-99 标准的一部分要求关系型数据库管理系统供应商，包括
    Oracle，在外部数据源上提供支持。坏消息是，SQL-99 标准正在分阶段发布，包装器扩展将在2001年之前发布，并且可能需要几年时间才能商业关系型数据库管理系统实现新标准。
- en: 'The short term fix is to run a procedure right before we send the query to
    Oracle:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 短期的解决方案是在将查询发送到 Oracle 之前运行一个过程：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our checker is an Oracle stored procedure named `checker.stock_quotes`. It
    checks every ticker symbol in `stock_quotes` and calls the fetcher if the quote
    is older than the specified interval, measured in days. If we want to add a new
    `ticker_symbol` to the table, we call a different version of `checker.stock_quotes`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的检查器是一个名为`checker.stock_quotes`的Oracle存储过程。它检查`stock_quotes`中的每个股票代码，并在报价比指定的时间间隔（以天为单位）旧时调用获取器。如果我们想要向表中添加一个新的`ticker_symbol`，我们调用一个不同版本的`checker.stock_quotes`：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If there is no entry for IBM which is less than half a day old, the checker
    will ask the fetcher to get a stock quote for IBM.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有半天内更新的IBM条目，检查器将要求获取IBM的股票报价。
- en: An Aggregation Example
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合示例
- en: 'Blue Cross will dispense a lot of Prozac before Oracle implements the SQL-99
    wrapper extension. So let''s build a `stock_quotes` foreign table which uses Java
    stored procedures to do the checking and fetching. We''ll begin with a data model:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oracle实现SQL-99包装器扩展之前，Blue Cross将提供大量Prozac。因此，让我们构建一个使用Java存储过程来执行检查和获取的`stock_quotes`外部表。我们将从数据模型开始：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a stripped-down version, where we only store the most recent price quote
    for each ticker symbol. In a real application we would certainly want to maintain
    an archive of old quotes, perhaps by using [triggers](triggers.html) to populate
    an audit table whenever `stock_quotes` is updated. Even if your external source
    provides its own historical records, fetching them is bound to be slower, less
    reliable, and more complicated than pulling data from your own audit tables.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化版本，我们只存储每个股票代码的最新价格报价。在实际应用程序中，我们肯定希望维护一个旧报价的存档，也许可以使用[触发器](triggers.html)在更新`stock_quotes`时填充审计表。即使您的外部来源提供其自己的历史记录，获取它们也比从自己的审计表中获取数据慢、不可靠且更复杂。
- en: 'We''ll create a single source code file, `StockUpdater.java`. Oracle 8.1.6
    includes a Java compiler as well as a virtual machine, so when this file is ready
    we can load it into Oracle and compile it with a single command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个单独的源代码文件，`StockUpdater.java`。Oracle 8.1.6包括一个Java编译器以及一个虚拟机，因此当这个文件准备好时，我们可以将其加载到Oracle中，并用一个命令编译它：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Oops. The `-resolve` option tells Oracle's `loadjava` utility to compile and
    link the class right away, but `StockUpdater` depends on classes that haven't
    yet been loaded into Oracle. Most Java virtual machines are designed to automatically
    locate and load classes at runtime by searching through the filesystem, but the
    Oracle JVM requires every class to be loaded into the database in advance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 噢。`-resolve`选项告诉Oracle的`loadjava`实用程序立即编译和链接类，但`StockUpdater`依赖于尚未加载到Oracle中的类。大多数Java虚拟机都设计成通过搜索文件系统在运行时自动定位和加载类，但Oracle
    JVM要求预先将每个类加载到数据库中。
- en: We need to obtain the `Perl5Util` and `PatternMatcherInput` classes. These are
    part of the Oro library, an open-source regular expression library that's available
    from [http://jakarta.apache.org/oro/index.html](http://jakarta.apache.org/oro/index.html).
    When we download and untar the distribution, we'll find a JAR file that contains
    the classes we need. We'll load the entire JAR file into Oracle and then try to
    load `StockUpdater` again.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要获取`Perl5Util`和`PatternMatcherInput`类。这些是Oro库的一部分，一个开源的正则表达式库，可以从[http://jakarta.apache.org/oro/index.html](http://jakarta.apache.org/oro/index.html)获取。当我们下载并解压分发时，会找到一个包含我们所需类的JAR文件。我们将整个JAR文件加载到Oracle中，然后再尝试加载`StockUpdater`。
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'These commands take a while to execute. When they''re done, we can check the
    results by running this SQL query:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令执行需要一段时间。完成后，我们可以通过运行以下SQL查询来检查结果：
- en: '[PRE7]'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s a small portion of the output from this query:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查询的输出的一小部分：
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our source code is marked `VALID`, and there's an associated class which is
    also `VALID`. There are a bunch of `VALID` regexp classes. All is well.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的源代码标记为`VALID`，并且有一个关联的类也是`VALID`。还有一堆`VALID`正则表达式类。一切正常。
- en: If we wanted, we could have compiled the `StockUpdater` class using a free-standing
    Java compiler and then loaded the resulting class files into Oracle. We aren't
    required to use the built-in Oracle compiler.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以使用独立的Java编译器编译`StockUpdater`类，然后将生成的类文件加载到Oracle中。我们不需要使用内置的Oracle编译器。
- en: The `-force` option forces `loadjava` to overwrite any existing class with the
    same name, so if we change our class we don't necessarily have to drop the old
    version before loading the new one. If we do want to drop one of Oracle's stored
    Java classes, we can use the `dropjava` utility.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`-force`选项强制`loadjava`覆盖任何具有相同名称的现有类，因此如果我们更改我们的类，则不一定需要在加载新类之前删除旧版本。如果我们确实想删除Oracle的存储Java类之一，我们可以使用`dropjava`实用程序。'
- en: Calling our Stored Procedures
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用我们的存储过程
- en: '![Diagram of the aggregation architecture](agg-arch.gif)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![聚合架构的图示](agg-arch.gif)'
- en: '**Figure 15-1**: The aggregation architecture. The client application obtains
    data by querying Oracle tables using SQL. To keep the foreign tables up to date,
    the application calls the Checker and the Fetcher, which are Java stored procedures
    running inside Oracle. The Checker is called via two layers of PL/SQL: one layer
    is a call spec which translates a PL/SQL call to a Java call, and the other is
    a wrapper procedure which provides an autonomous transaction for the aggregation
    code to run in.'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**图15-1**：聚合架构。客户端应用程序通过使用SQL查询Oracle表来获取数据。为了保持外部表的最新状态，应用程序调用运行在Oracle内部的Java存储过程Checker和Fetcher。Checker通过两层PL/SQL调用：一层是将PL/SQL调用转换为Java调用的调用规范，另一层是提供自主事务以运行聚合代码的包装过程。'
- en: 'In order to call Java stored procedures from SQL, we need to define *call specs*,
    which are PL/SQL front ends to static Java methods. Here''s an example of a call
    spec:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从SQL调用Java存储过程，我们需要定义*调用规范*，这是静态Java方法的PL/SQL前端。以下是一个调用规范的示例：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code says: "when the programmer calls this PL/SQL procedure, call the
    `checkAll` method of the Java class `StockUpdater`." The `checkAll` method must
    be `static`: Oracle doesn''t automatically construct a new `StockUpdater` object.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的含义是：“当程序员调用这个PL/SQL过程时，调用Java类`StockUpdater`的`checkAll`方法。” `checkAll`方法必须是`static`的：Oracle不会自动构造一个新的`StockUpdater`对象。
- en: 'We don''t allow developers to use the call spec directly. Instead we make them
    call a separate PL/SQL procedure which initiates an *autonomous transaction*.
    We need to do this because an application might call the checker in the middle
    of a big transaction. The checker uses the fetcher to add fresh data to the `stock_quotes`
    table. Now the question arises: when do we commit the changes to the `stock_quotes`
    table? There are three options:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不允许开发人员直接使用调用规范。相反，我们让他们调用一个单独的PL/SQL过程来启动*自主事务*。我们需要这样做是因为应用程序可能在一个大事务中调用检查器。检查器使用获取器向`stock_quotes`表添加新数据。现在问题是：何时提交对`stock_quotes`表的更改？有三种选择：
- en: Have the fetcher issue a COMMIT. This will commit the changes to `stock_quotes`.
    It will also commit any changes that were made before the checker was called.
    This is a very bad idea.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使获取器发出COMMIT。这将提交对`stock_quotes`的更改。它还将提交在调用检查器之前进行的任何更改。这是一个非常糟糕的主意。
- en: 'Have the fetcher update `stock_quotes` without issuing a COMMIT. This is also
    a bad idea: if the calling routine decides to abort the transaction, the new stock
    quote data will be lost.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使获取器更新`stock_quotes`而不发出COMMIT。这也是一个不好的主意：如果调用例程决定中止事务，则新的股票报价数据将丢失。
- en: Run the checker and the fetcher in an independent transaction of their own.
    The fetcher can commit or roll back changes without affecting the main transaction.
    Oracle provides the `AUTONOMOUS_TRANSACTION` pragma for this purpose, but the
    pragma doesn't work in a call spec - it's only available for regular PL/SQL procedures.
    So we need a separate layer of glue code just to initiate the autonomous transaction.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在独立的事务中运行检查器和获取器。获取器可以提交或回滚更改，而不会影响主事务。Oracle为此提供了`AUTONOMOUS_TRANSACTION`声明，但该声明在调用规范中不起作用
    - 它仅适用于常规的PL/SQL过程。因此，我们需要一个单独的粘合代码层来启动自主事务。
- en: 'Here''s the SQL which defines all of our PL/SQL procedures:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是定义所有PL/SQL过程的SQL代码：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We've placed the routines in a *package* called `checker`. Packages allow us
    to group procedures and datatypes together. We're using one here because packaged
    procedure definitions can be *overloaded*. The `checker.stock_quotes` procedure
    can be called with either one or two arguments and a different version will be
    run in each case. The `stock_quotes_spec` procedure also comes in two versions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些例程放在一个名为`checker`的*包*中。包允许我们将过程和数据类型分组在一起。我们在这里使用一个包是因为打包的过程定义可以*重载*。`checker.stock_quotes`过程可以使用一个或两个参数调用，并且在每种情况下将运行不同版本。`stock_quotes_spec`过程也有两个版本。
- en: Writing a Checker in Java
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Java中编写一个Checker
- en: 'We''re ready to start looking at the `StockUpdater.java` file itself. It begins
    in typical Java fashion:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备开始查看 `StockUpdater.java` 文件本身。它以典型的 Java 方式开始：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we have the two checker routine, starting with the one that updates the
    entire table:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有两个检查例程，首先是更新整个表格的例程：
- en: '[PRE12]'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This routine uses JDBC to access the `stock_quotes` table. JDBC calls throw
    exceptions of type `SQLException` which we don''t bother to catch; instead, we
    propagate them back to the calling programmer to indicate that something went
    wrong. We also print debugging information to standard output. When running this
    class outside Oracle, the debug messages will appear on the screen. Inside Oracle,
    we can view them by issuing some SQL*Plus commands in advance:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程使用 JDBC 访问 `stock_quotes` 表。JDBC 调用会抛出 `SQLException` 类型的异常，我们不需要捕获它们；相反，我们将它们传播回调用程序员，以指示出现了问题。我们还会将调试信息打印到标准输出。当在
    Oracle 外部运行这个类时，调试消息将显示在屏幕上。在 Oracle 内部，我们可以提前发出一些 SQL*Plus 命令来查看它们：
- en: '[PRE13]'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Standard output will be echoed to the screen, 5000 characters at a time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输出将被回显到屏幕上，每次回显 5000 个字符。
- en: 'The second checker operates on one ticker symbol at a time, and is used to
    add a new ticker symbol to the table:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个检查例程逐个处理一个股票代码，并用于将一个新的股票代码添加到表中：
- en: '[PRE14]'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Writing a Fetcher in Java
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Java 中编写一个抓取器
- en: The fetcher is implemented as a long Java method called `fetchList`. It begins
    by retrieving a Web page from Yahoo. For speed and simplicity, we extract all
    of the stock quotes on a single page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 抓取器被实现为一个名为 `fetchList` 的长 Java 方法。它首先从雅虎那里检索一个网页。为了速度和简单起见，我们从一个页面中提取所有的股票报价。
- en: '[PRE15]'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The fetcher uses a helper routine called `getPage` to retrieve Yahoo''s HTML,
    which we stuff into the `yahooPage` variable. Now we can use Perl 5 regular expressions
    to extract the values we need. We create a new `Perl5Util` object and use the
    `split()` and `match()` methods to extract the section of the page where the data
    is:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 抓取器使用一个名为 `getPage` 的辅助函数来检索雅虎的 HTML，我们将其塞入 `yahooPage` 变量中。现在我们可以使用 Perl 5
    正则表达式来提取我们需要的值。我们创建一个新的 `Perl5Util` 对象，并使用 `split()` 和 `match()` 方法来提取页面中数据的部分：
- en: '[PRE16]'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to pick out today's date from the page. This is the date when the page
    was retrieved, which we'll call the "fetch date". Each stock quote also has an
    individual timestamp, which we'll call the "quote date". We use a little class
    of our own (`OracleDate`) to represent dates, and a helper routine (`matchFetchDate`)
    to do the regexp matching.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从页面中提取出今天的日期。这是页面被检索时的日期，我们称之为“抓取日期”。每个股票报价也有一个独立的时间戳，我们称之为“报价日期”。我们使用我们自己的一个小类
    (`OracleDate`) 来表示日期，并使用一个辅助函数 (`matchFetchDate`) 来执行正则表达式匹配。
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we can't match the fetch date, we throw an exception to tell the client programmer
    that the fetcher didn't work. Perhaps the network is down, or Yahoo's server is
    broken, or Yahoo's graphic designers decided to redesign the page layout.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法匹配到抓取日期，我们会抛出一个异常，告诉客户端程序员抓取器没有工作。也许是网络出了问题，或者雅虎的服务器出了故障，或者雅虎的图形设计师决定重新设计页面布局。
- en: 'We''re ready to extract the stock quotes themselves. They''re in an HTML table,
    with one row for each quote. We set up a single JDBC statement which will be executed
    over and over, using placeholders to represent the data:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备提取股票报价本身。它们在一个 HTML 表格中，每个报价一行。我们设置了一个单独的 JDBC 语句，它将一遍又一遍地执行，使用占位符来表示数据：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we pick apart the HTML table one row at a time, using a huge regexp that
    represents an entire table row. By using a `PatternMatcherInput` object, we can
    make `regexp.match()` traverse the `dataSection` string and return one match after
    another until it runs out of matches. For each stock quote we find, we clean up
    the data and perform a database INSERT.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们逐行分析 HTML 表格，使用一个巨大的正则表达式来表示整个表格行。通过使用 `PatternMatcherInput` 对象，我们可以让 `regexp.match()`
    遍历 `dataSection` 字符串，并返回一个接一个的匹配，直到没有更多匹配为止。对于我们找到的每一个股票报价，我们会清理数据并执行数据库插入操作。
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Helper Routines for the Fetcher
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抓取器的辅助例程
- en: The fetcher loads HTML pages using the `getPage` method, which uses the `URL`
    class from the Java standard library. For a simple HTTP GET, this routine is all
    we need.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 抓取器使用 `getPage` 方法加载 HTML 页面，该方法使用 Java 标准库中的 `URL` 类。对于一个简单的 HTTP GET，这个例程就是我们需要的。
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Dates, along with their Oracle format strings, are stored inside `OracleDate`
    objects. `OracleDate` is an "inner class", defined inside the StockUpdater class.
    Because it is a private class, it can't be seen or used outside of StockUpdater.
    Later, if we think `OracleDate` will be useful for other programmers, we can turn
    it into a public class by moving the definition to a file of its own.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 日期及其Oracle格式字符串存储在`OracleDate`对象中。 `OracleDate`是一个“内部类”，定义在StockUpdater类内部。
    因为它是一个私有类，所以在StockUpdater之外看不到或使用它。 如果以后我们认为`OracleDate`对其他程序员有用，我们可以通过将定义移动到自己的文件中将其转换为公共类。
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To extract the dates from the Web page, we have a couple of routines called
    `matchFetchDate` and `matchQuoteDate`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要从网页中提取日期，我们有一些名为`matchFetchDate`和`matchQuoteDate`的例程：
- en: '[PRE22]'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The stock prices coming back from Yahoo often contain fractions, which have
    special HTML markup. The `parseFraction` method pulls the HTML apart and returns
    the stock price as a Java `float`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从Yahoo返回的股价通常包含分数，这些分数具有特殊的HTML标记。 `parseFraction`方法将HTML拆分并将股价作为Java `float`返回：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Odds and Ends
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 杂项
- en: All of our methods obtain their JDBC connections by calling `getConnection()`.
    By routing all database connection requests through this method, our class will
    be able to run either inside or outside the database - `getConnection` checks
    its environment and sets up the connection accordingly. Loading Java into Oracle
    is a tedious process, so it's nice to be able to debug your code from an external
    JVM.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的方法都通过调用`getConnection()`来获取它们的JDBC连接。 通过将所有数据库连接请求路由通过这个方法，我们的类将能够在数据库内部或外部运行
    - `getConnection`检查其环境并相应地设置连接。 将Java加载到Oracle是一个繁琐的过程，因此能够从外部JVM调试代码是很好的。
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To call `StockUpdater` from the command line, we also need to provide a `main`
    method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行调用`StockUpdater`，我们还需要提供一个`main`方法：
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, the fetcher needs a utility which can join strings together. It's similar
    to the "join" command in Perl or Tcl.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，抓取程序需要一个可以将字符串连接在一起的实用程序。 它类似于Perl或Tcl中的“join”命令。
- en: '[PRE26]'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A Foreign Table In Action
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 外部表的实际操作
- en: 'Now that we''ve implemented all of this, we can take a look at our foreign
    table in SQL*Plus:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了所有这些，我们可以在SQL*Plus中查看我们的外部表：
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This data is over three hours old. Let''s request data from within the last
    hour:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据已经超过三个小时了。 让我们请求在最近一个小时内的数据：
- en: '[PRE28]'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That's better. But I'm curious about the Intel Corporation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好。 但我对英特尔公司很好奇。
- en: '[PRE29]'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Reference
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考
- en: The pioneering work in this area was done in the mid-1990s by the Garlic project
    at IBM Almaden Research Center. This is the same laboratory that developed System
    R, the first relational database management system, which eventually became IBM's
    DB2 product. To see how IBM's ideas unfolded in the area of wrapping legacy databases
    and foreign Web sites, visit [http://www.almaden.ibm.com/cs/garlic/](http://www.almaden.ibm.com/cs/garlic/).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个领域的开创性工作是在1990年代中期由IBM Almaden研究中心的大蒜项目完成的。 这是同一个开发了System R的实验室，这是第一个关系数据库管理系统，最终成为IBM的DB2产品。
    要了解IBM在包装传统数据库和外部网站方面的想法是如何展开的，请访问[http://www.almaden.ibm.com/cs/garlic/](http://www.almaden.ibm.com/cs/garlic/)。
- en: Java Stored Procedures Developer's Guide at [http://www.oradoc.com/keyword/java_stored_procedures](http://www.oradoc.com/keyword/java_stored_procedures).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java存储过程开发人员指南位于[http://www.oradoc.com/keyword/java_stored_procedures](http://www.oradoc.com/keyword/java_stored_procedures)。
- en: PL/SQL User's Guide and Reference at [http://www.oradoc.com/keyword/plsql](http://www.oradoc.com/keyword/plsql).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PL/SQL用户指南和参考资料位于[http://www.oradoc.com/keyword/plsql](http://www.oradoc.com/keyword/plsql)。
- en: Sun's Java2 Documentation at [http://java.sun.com/j2se/1.3/docs/index.html](http://java.sun.com/j2se/1.3/docs/index.html).
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sun的Java2文档位于[http://java.sun.com/j2se/1.3/docs/index.html](http://java.sun.com/j2se/1.3/docs/index.html)。
- en: 'Next: [Normalization](normalization)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来：[规范化](normalization)
- en: '* * *'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '[mbooth@arsdigita.com](mailto:mbooth@arsdigita.com)[philg@mit.edu](http://philip.greenspun.com/)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[mbooth@arsdigita.com](mailto:mbooth@arsdigita.com)[philg@mit.edu](http://philip.greenspun.com/)'
- en: Reader's Comments
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读者评论
- en: Okay, I think the statute of limitations on this page has expired, so I'm free
    to point out that (alas!) my email address is no longer mbooth@arsdigita.com.
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 好吧，我认为这个页面的时效性已经到期了，所以我可以指出（遗憾的是！）我的电子邮件地址不再是mbooth@arsdigita.com。
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can find me at [michaelfbooth.com](http://michaelfbooth.com).
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[michaelfbooth.com](http://michaelfbooth.com)找到我。
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Michael Booth](/shared/community-member?user_id=286155), November 15, 2007
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: -- [迈克尔·布斯](/shared/community-member?user_id=286155)，2007年11月15日
- en: '[Add a comment](/comments/add?page_id=7344) | [Add a link](/links/add?page_id=7344)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[添加评论](/comments/add?page_id=7344) | [添加链接](/links/add?page_id=7344)'
