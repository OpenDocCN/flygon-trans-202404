- en: OOP Below the Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Below the Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/c3229d7fec712b3fbb256433b56ae890.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using your new-found knowledge of environments, it'll be much easier to understand
    how OOP works! We call this "below-the-line" because we're achieving the functionality
    of OOP without any special procedures (such as `define-class`).
  prefs: []
  type: TYPE_NORMAL
- en: Message Passing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a complex number object is represented by a dispatch procedure.
    The procedure takes a message as its argument, and returns a number as its result.
    However, `dispatch` can return a procedure instead of a number, and it allows
    for extra arguments to what we are calling the method that responds to a message.
  prefs: []
  type: TYPE_NORMAL
- en: The user says
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Evaluating this expression requires a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: The dispatch procedure `(named acc)` is invoked with the message withdraw as
    its argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `dispatch` procedure returns the `withdraw` method procedure, and that second
    procedure is invoked with 100 as its argument to do the actual work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of an object's activity comes from invoking its method procedures; the only
    job of the object itself is to return the right procedure when it gets sent a
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any OOP system that uses the message-passing model must have some below-the-
    line mechanism for associating methods with messages. In Scheme, with its first-class
    procedures, it is very natural to use a `dispatch` procedure as the association
    mechanism. In some other language the object might instead be represented as an
    array of message-method pairs. If we are treating objects as an abstract data
    type, programs that use objects shouldn''t have to know that we happen to be representing
    objects as procedures. The two-step notation for invoking a method violates this
    abstraction barrier. To fix this, we invent the ask procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`ask` carries out essentially the same steps as the explicit notation used
    in the text. First, it invokes the dispatch procedure (that is, the object itself)
    with the message as its argument. This should return a method (another procedure).
    The second step is to invoke that method procedure with whatever extra arguments
    have been provided to `ask`. The body of `ask` looks more complicated than the
    earlier version, but most of that has to do with error- checking: What if the
    object doesn''t recognize the message we send it? These details aren''t very important.
    `ask` does use two features of Scheme that we haven''t discussed before:'
  prefs: []
  type: TYPE_NORMAL
- en: The dot notation used in the formal parameter list of `ask` means that it accepts
    any number of arguments. The first two are associated with the formal parameters
    object and message; all the remaining arguments (zero or more of them) are put
    in a list and associated with the formal parameter args.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure `apply` takes a procedure and a list of arguments and applies
    the procedure to the arguments. The reason we need it here is that we don't know
    in advance how many arguments the method will be given; if we said (method args)
    we would be giving the method one argument, namely, a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our OOP system, you generally send messages to instances, but you can also
    send some messages to classes, namely the ones to examine class variables. When
    you send a message to a class, just as when you send one to an instance, you get
    back a method. That''s why we can use ask with both instances and classes. (The
    OOP system itself also sends the class an instantiate message when you ask it
    to create a new instance.) Therefore, both the class and each instance is represented
    by a dispatch procedure. The overall structure of a class definition looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (Please note that this is not exactly what a class really looks like. In this
    simplified version we have left out many details. The only crucial point here
    is that there are two dispatch procedures, one inside the other.) In each procedure,
    there is a `cond` with a clause for each allowable message. The consequent expression
    of each clause is a `lambda` expression that defines the coreesponding method.
  prefs: []
  type: TYPE_NORMAL
- en: Local State (Again)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous subsection, you learned how to give a procedure a local state
    variable: define that procedure inside another procedure that establishes a variable.
    So it can be written as the follwing example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the OOP system, there are three kinds of local state variables: class variables,
    instance variables, and instantiation variables. Although instantiation variables
    are just a special kind of instance variable above the line, they are implemented
    di erently. Here is another simpli ed view of a class definition, this time leaving
    out all the message passing stuff and focusing on the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The scope of a class variable includes the class dispatch procedure, the instance
    dispatch procedure, and all of the methods within those. The scope of an instance
    variable does not include the class dispatch procedure in its methods. Each invocation
    of the class `instantiate` method gives rise to a new set of instance variables,
    just as each new bank account in the book has its own local state variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why are class variables and instance variables implemented using `let`, but
    not instantiation variables? The reason is that class and instance variables are
    given their (initial) values by the class definition itself. That''s what `let`
    does: It establishes the connection between a name and a value. Instatiation variables,
    however, don''t get values until each particular instance of the class is created,
    so we implement these variables as the formal parameters of a `lambda` that will
    be invoked to create an instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and Delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance is the mechanism through which objects of a child class can use
    methods from a parent class. Ideally, all such methods would just be part of the
    repertoire of the child class; the parent''s procedure de nitions would be "copied
    into" the Scheme implementation of the child class. The actual implementation
    in our OOP system, although it has the same purpose, uses a somewhat di fferent
    technique called delegation. Each object''s dispatch procedure contains entries
    only for the methods of its own class, not its parent classes. But each object
    has, in an instance variable, an object of its parent class. To make it easier
    to talk about all these objects and classes, let''s take an example that we looked
    at before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an instance of that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then the object named `Gerry-account` will have an instance variable named `my-account`
    whose value is an instance of the account class. (The variables "my-whatever"
    are created automatically by `define-class`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What good is this parent instance? If the dispatch procedure for `Gerry- account`
    doesn''t recognize some message, then it reaches the `else` clause of the `cond`.
    In an object without a parent, that clause will generate an error message. But
    if the object does have a parent, the `else` clause passes the message on to the
    parent''s dispatch procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: (Naturally, this is a vastly simplified picture. We've left out the class dispatch
    procedure, among other details. There isn't really a procedure named `make-checking-account-instance`
    in the implementation; this procedure is really the instantiate method for the
    class, as we explained earlier.)
  prefs: []
  type: TYPE_NORMAL
- en: When we send `Gerry-account` a `write-check` message, it's handled in the straightforward
    way we've been talking about. But when we send `Gerry-account` a deposit message,
    we reach the `else` clause of the `cond` and the message is delegated to the parent
    account object. That object (that is, its dispatch procedure) returns a method,
    and `Gerry-account` returns the method too.
  prefs: []
  type: TYPE_NORMAL
- en: The crucial thing to understand is why the `else` clause does not say
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Gerry-account` dispatch procedure takes a message as its argument, and
    returns a method as its result. `Ask`, you'll recall, carries out a two-step process
    in which it first gets the method and then invokes that method. Within the dispatch
    procedure we only want to get the method, not invoke it. (Somewhere there is an
    invocation of ask waiting for `Gerry-account`'s dispatch procedure to return a
    method, which `ask` will then invoke.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one drawback to the delegation technique. When we ask `Gerry-account`
    to deposit some money, the `deposit` method only has access to the local state
    variables of the `account` class, not those of the `checking-account` class. Similarly,
    the `write-check` method doesn''t have access to the account local state variables
    like `balance`. You can see why this limitation occurs: Each method is a procedure
    defi ned within the scope of one or the other class procedure, and Scheme''s lexical
    scoping rules restrict each method to the variables whose scope contains it. The
    technical distinction between inheritance and delegation is that an inheritance-based
    OOP system does not have this restriction. We can get around the limitation by
    using messages that ask the other class (the child asks the parent, or vice versa)
    to return (or modify) one of its variables. The `(ask self ''withdraw ...)` in
    the `write-check` method is an example.'
  prefs: []
  type: TYPE_NORMAL
- en: Bells and Whistles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplified Scheme implementation shown so far hides several complications
    in the actual OOP system. What we have explained so far is really the most important
    part of the implementation, and you shouldn't let the details that follow confuse
    you about the core ideas. We're giving pretty brief explanations of these things,
    leaving out the gory details.
  prefs: []
  type: TYPE_NORMAL
- en: One complication is multiple inheritance. Instead of delegating an unknown message
    to just one parent, we have to try more than one. The real `else` clauses invoke
    a procedure called `get-method` that accepts any number of objects (i.e., dispatch
    procedures) as arguments, in addition to the message. `Get-method` tries to fi
    nd a method in each object in turn; only if all of the parents fail to provide
    a method does it give an error message. (There will be a "my-whatever" variable
    for each of the parent classes.)
  prefs: []
  type: TYPE_NORMAL
- en: Another complication that aff ects the `else` clause is the possible use of
    a `default-method` in the class de nition. If this optional feature is used, the
    body of the `default-method` clause becomes part of the object's `else` clause.
  prefs: []
  type: TYPE_NORMAL
- en: When an instance is created, the `instantiate` procedure sends it an `initialize`
    message. Every dispatch procedure automatically has a corresponding method. If
    the `initialize` clause is used in `define-class`, then the method includes that
    code. But even if there is no `initialize` clause, the OOP system has some initialization
    tasks of its own to perform. In particular, the initialization must provide a
    value for the self variable. Every `initialize` method takes the desired value
    for self as an argument. If there are no parents or children involved, `self`
    is just another name for the object's own dispatch procedure. But if an instance
    is the `my-whatever` of some child instance, then `self` should mean that child.
    The solution is that the child's `initialize` method invokes the parent's `initialize`
    method with the child's own self as the argument. (Where does the child get its
    self argument? It is provided by the `instantiate` procedure.)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `usual` involves some complications. Each object has a `send-usual-to-parent`
    method that essentially duplicates the job of the `ask` procedure, except that
    it only looks for methods in the parents, as the `else` clause does. Invoking
    `usual` causes this method to be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Counter Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s implement a simple counter. Every time the `counter` is called,
    it increments its own local variable and the global variable for all counters.
    Here is the code for our counter class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It works something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The class variable `glob` is created in an environment that surrounds the creation
    of the outer lambda, which represents the entire class. The instance variable
    `loc` is created in an environment that's inside the class lambda, but outside
    the second lambda that represents an instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: The example above shows how environments support state variables in OOP, but
    itâ€™s simplified in that the instance is not a message-passing dispatch procedure.
    In short, it isn't very realistic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we call the counter with no arguments and are returned a list of
    the local and global variables for that counter. Change this class so that the
    counter has two methods, either ''local or ''global. Each of these methods takes
    in exactly one argument: the number by which to increment the counter. Your code
    should work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
