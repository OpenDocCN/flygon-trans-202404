- en: Lecture 7 - Create, Scheduling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pubilc Service Annoucements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due date for assignment 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partners
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: After the Software Interrupt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the kernel
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The order matters, except for the last two
  prefs: []
  type: TYPE_NORMAL
- en: Save the user state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the kernel state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is more than one way to do almost everything in this list, and I have
    chosen this way of describing what is to be done because it's simplest to describe,
    not because it's necessarily best!.
  prefs: []
  type: TYPE_NORMAL
- en: At this point the kernel is ready to handle the request.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What needs to be done
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Check for errors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manipulating TDs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, copying bytes from one address space to another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving up the return value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The task that made the request may not be the next one to run.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel needs to save the request's return value until the next time the
    requester is scheduled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One solution is to put it in the TD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's also possible to put it where it will be needed (such as r0) immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two important issues for scheduling
  prefs: []
  type: TYPE_NORMAL
- en: When do we reschedule?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who do we activate when we schedule
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When to schedule
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Every time we are in the kernel, so the issue is `When do we enter the kernel?'
  prefs: []
  type: TYPE_NORMAL
- en: Three possibilities
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Tasks run to completion, which means until they make a request for kernel services
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Event-driven pre-emption, which means when hardware makes a request for service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Time-slicing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: re-schedule only when the slice-timer times out
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: two problems with time slicing
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: slices are too big => bad response
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: slices are too small => kernel runs too much = bad response
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What defines `too big' and `too small'?
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: desired response times
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: frequency of requests from hardware
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: both of which vary widely
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We do 1 & 2, but not 3, because our tasks co-operate. Time-slicing is needed
    when tasks are adversarial.
  prefs: []
  type: TYPE_NORMAL
- en: Who to Schedule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whoever is needed to meet all the deadlines
  prefs: []
  type: TYPE_NORMAL
- en: or to optimize something.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because this is not an easy problem, we don't want to solve it within the kernel.
    What the kernel does should be fast (=constant time) and not resource constrained.
  prefs: []
  type: TYPE_NORMAL
- en: Inexpensive (=constant time)ways to schedule
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Least expensive first
  prefs: []
  type: TYPE_NORMAL
- en: active task decides = co-routines
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: round robin
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: everybody gets the same chance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: but usually long running time = unimportant
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: priorities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: fixed at compile time
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: fixed when task is created
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: re-fixed every time task is scheduled
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you have a good algorithm?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of priorities should be small, but not too small.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks at the same priority should have the same precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Find the highest priority non-empty ready queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Schedule the first task in the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The state of the most recently scheduled (running) task is ACTIVE, not READY.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The kernel maintains a pointer to the TD of the active task so it knows which
    task is making the current request.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When a task is made ready it is put at the end of its ready queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Array of ready queues, one for each priority.
  prefs: []
  type: TYPE_NORMAL
- en: Each ready queue is a list with a head pointer (for extraction)and a tail pointer
    (for insertion).
  prefs: []
  type: TYPE_NORMAL
- en: Hint. The Art of Computer Programming (Donald Knuth) says that circular queues
    are better. Why?
  prefs: []
  type: TYPE_NORMAL
- en: Implementation decisions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How many priorities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which task should have which priority
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What to do when there is no ready task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The queues of typical running system
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Highest priority:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: tasks waiting on interrupts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: almost always blocked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: do minimal processing, then release tasks blocked on them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Medium priority
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: receive blocked tasks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: almost always blocked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: provide service to application tasks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Low priority
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: send-blocked tasks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: blocked more often than not
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: make decisions about what should be done next
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowest priority
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: one task that runs without blocking
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the idle task
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: uses power without doing anything
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Before the Software Interrupt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After a while it's time to leave the kernel
  prefs: []
  type: TYPE_NORMAL
- en: Schedule the next task to run
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: i.e. get the value of `active`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `GetNextRequest( active )`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside GetNextRequest
  prefs: []
  type: TYPE_NORMAL
- en: From TD, or the user stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: get sp_usr
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: set spsr_svc = cpsr_usr
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You should understand how this takes us back to user mode.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: set lr_svc = pc for return to user mode
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Save kernel state on kernel stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combined with 6, above this should be a NOP
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set return value by overwriting r0 on user stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to system mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load registers from user stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combined with 3 above this should be a NOP
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Return to supervisor mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let it go
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The instruction after this one is normally the kernel entry.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Making the Stub that Wraps swi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For each kernel primitive there must be a function available in usr code: the
    kernel''s API.'
  prefs: []
  type: TYPE_NORMAL
- en: e.g. `int Create( int priority, void ( *code ) ( ) );`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What gcc does for you
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before calling Create
  prefs: []
  type: TYPE_NORMAL
- en: gcc saves the scratch registers to memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: gcc puts the arguments into the scratch registers, and possibly on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While calling Create
  prefs: []
  type: TYPE_NORMAL
- en: '`bl` to the entry point of Create'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While executing Create
  prefs: []
  type: TYPE_NORMAL
- en: gcc saves the registers that **it thinks** will be altered during execution
    of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: gcc thinks wrong, because only the assembler knows that swi is in the instruction
    stream
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: your code gets executed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: gcc restores the registers it saved, and only those registers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exiting from Create
  prefs: []
  type: TYPE_NORMAL
- en: mov pc, lr, or equivalent, is executed, returning the execution to the instruction
    following bl
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After calling Create
  prefs: []
  type: TYPE_NORMAL
- en: gcc stores register r0, the return value, in the variable to which the result
    of Create is assigned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What the code you write does
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Moves the arguments from gcc's locations to whatever convention you choose for
    your kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Does swi n, where n is the code for Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moves the return value from your kernel's conventional location to r0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In creating a task you have to do two things
  prefs: []
  type: TYPE_NORMAL
- en: Get and initialize resources needed by the task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TD
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the task look as if it had just entered the kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: it's ready to execute when it's scheduled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Things you need to do
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Get an unused TD and memory for its stack
  prefs: []
  type: TYPE_NORMAL
- en: memory could be associated with TD during initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: actually a form of constant time memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unless you implement Destroy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mostly filling in fields in the TD.
  prefs: []
  type: TYPE_NORMAL
- en: task id
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: stack pointer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SPSR
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: link register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: parent tid
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the active task
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: return value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: dummy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: different return value for the active task, which goes in its TD
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: READY
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: install in the ready queues
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: pointers in the TD
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Must also initialize the stack
  prefs: []
  type: TYPE_NORMAL
- en: exactly as if the task had just done a kernel entry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: look carefully at what your kernel exit code will do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end stack pointer must correspond to stack contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I initialize the stack pointer to the top of allocated memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: my stacks grow down
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: then change it as I push stuff onto the stack
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: imitating the context switch code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The Create Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You also need a `int Create( int priority, void (*code) ( ) )` function to call
    from user tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Although it's no more than a wrapper there are a few problems to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On entry the arguments are somewhere, usually r0 & r1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to put them where the kernel can find them.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: gcc's function extry code immediately puts them on the stack.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In assembly you can find them using the frame pointer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumping into the kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the return value from the kernel and returning it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You find it where the kernel put it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: gcc's function exit code expects it to be indexed off the frame pointer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: from where it does into r0
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Other Primitives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These primitives exist mostly so that we, which includes you, can ensure that
    task creation and scheduling are working when there is not much else implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '`Tid MyTid( )`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Self-explanatory
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't block, but does reschedule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A question, to which there is a correct answer, or more specifically, a correct
    (answer, reason) pair.
  prefs: []
  type: TYPE_NORMAL
- en: Should the Tid be stored in user space?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tid MyParentTid( )`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Self-explanatory
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't block, but does reschedule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where is the parent Tid, and how does the kernel find it?
  prefs: []
  type: TYPE_NORMAL
- en: '`void Pass( )`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Doesn''t block: task calling `Pass( )` remains ready to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: Does reschedule.
  prefs: []
  type: TYPE_NORMAL
- en: When is `Pass( )` a `NOP`?
  prefs: []
  type: TYPE_NORMAL
- en: '`void Exit( )`'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Calling task is removed from all queues, but its resources are not reclaimed
    or reused.
  prefs: []
  type: TYPE_NORMAL
- en: That is, the task goes into a zombie state, in which it cannot be active or
    ready, but continues to own all its resources.
  prefs: []
  type: TYPE_NORMAL
- en: How Should Execution Terminate?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nicely.
  prefs: []
  type: TYPE_NORMAL
- en: When there are no tasks left on the ready queues, it goes back to RedBoot.
  prefs: []
  type: TYPE_NORMAL
- en: This behaviour changes when hardware interrupts are implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bill Cowan''s lecture notes for CS452 in s12](index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s Spring 2012 CS452 page](../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s CS452 page](../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s teaching page](../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s home page](../../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
