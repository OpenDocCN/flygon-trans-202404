- en: '| [![The circular staircase leading up to the Vatican museums.  It was designed
    by Giuseppe Momo in 1932](../Images/3fbcbc9d7a597ec2fc38bb6f90044200.jpg)](/http://philip.greenspun.com/images/pcd0800/vatican-museum-staircase-4.tcl)
    |'
  prefs: []
  type: TYPE_TB
- en: Data Warehousing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: part of [SQL for Web Nerds](index.html) by [Philip Greenspun](http://philip.greenspun.com/)
    |
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[![Tom Huntington in waterfall.  Grand Canyon National Park.](../Images/1cc22b005cd8e7bee2940417de5fca3c.jpg)](/http://philip.greenspun.com/images/pcd2899/tom-in-waterfall-41.tcl)
    In the preceding chapters, you''ve been unwittingly immersed in the world of on-line
    transaction processing (OLTP). This world carries with it some assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Only store a piece of information once. If there are N copies of something in
    the database and you need to change it, you might forget to change it in all N
    places. Note that only storing information in one spot also enables updates to
    be fast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is okay if queries are complex because they are authored infrequently and
    by professional programmers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Never sequentially scan large tables; reread [the tuning chapter](tuning.html)
    if Oracle takes more than one second to perform any operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are wonderful rules to live by if one is booking orders, adding user comments
    to pages, recording a clickthrough, or seeing if someone is authorized to download
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: You can probably continue to live by these rules if you want some answers from
    your data. Write down a list of questions that are important and build some report
    pages. You might need [materialized views](views.html#materialized) to make these
    reports fast and your queries might be complex, but you don't need to leave the
    OLTP world simply because business dictates that you answer a bunch of questions.
  prefs: []
  type: TYPE_NORMAL
- en: Why would anyone leave the OLTP world? Data warehousing is useful when you don't
    know what questions to ask.
  prefs: []
  type: TYPE_NORMAL
- en: What it means to facilitate exploration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[![Reenactment of Powell''s trip.  Lava Falls.  Grand Canyon National Park.  August
    1999.](../Images/17b7699b1e0448581b0dbe14c40581a3.jpg)](/http://philip.greenspun.com/images/pcd2882/grand-canyon-powell-reenactment-38.tcl)
    Data exploration is only useful when non-techies are able to explore. That means
    people with very weak skills will be either authoring queries or specifying queries
    with menus. You can''t ask a marketing executive to look at a 600-table data model
    and pick and choose the relevant columns. You can''t ask a salesman to pull the
    answer to "is this a repeat customer or not?" out of a combination of the `customers`
    and `orders` tables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a data exploration environment is to be useful it must fulfill the following
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: complex questions can be asked with a simple SQL query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: different questions imply very similar SQL query structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: very different questions require very similar processing time to answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: exploration can be done from any computer anywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is that a business expert can sit down at a Web browser, use a sequence
    of forms to specify a query, and get a result back in an amount of time that seems
    reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: It will be impossible to achieve this with our standard OLTP data models. Answering
    a particular question may require JOINing in four or five extra tables, which
    could result in a 10,000-fold increase in processing time. Even if a novice user
    could be guided to specifying a 7-way JOIN from among 600 tables, that person
    would have no way of understanding or predicting query processing time. Finally
    there is the question of whether you want novices querying your OLTP tables. If
    they are only typing SELECTs they might not be doing too much long-term harm but
    the short-term processing load might result in a system that feels crippled.
  prefs: []
  type: TYPE_NORMAL
- en: It is time to study *data warehousing*.
  prefs: []
  type: TYPE_NORMAL
- en: Classical Retail Data Warehousing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"Another segment of society that has constructed a language of its own is business.
    ... [The businessman] is speaking a language that is familiar to him and dear
    to him. Its portentous nouns and verbs invest ordinary events with high adventure;
    the executive walks among ink erasers caparisoned like a knight. This we should
    be tolerant of--every man of spirit wants to ride a white horse. ... A good many
    of the special words of business seem designed more to express the user''s dreams
    than to express his precise meaning."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- last chapter of [The Elements of Style](http://www.amazon.com/exec/obidos/ASIN/020530902X/pgreenspun-20),
    Strunk and White
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's imagine a conversation between the Chief Information Officer of WalMart
    and a sales guy from Sybase. We've picked these companies for concreteness but
    they stand for "big Management Information System (MIS) user" and "big relational
    database management system (RDBMS) vendor".
  prefs: []
  type: TYPE_NORMAL
- en: 'Walmart: "I want to keep track of sales in all of my stores simultaneously."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sybase: "You need our wonderful RDBMS software. You can stuff data in as sales
    are rung up at cash registers and simultaneously query data out right here in
    your office. That''s the beauty of concurrency control."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So Walmart buys a $1 million Sun E10000 multi-CPU server and a $500,000 Sybase
    license. They buy [Database Design for Smarties](http://www.amazon.com/exec/obidos/ASIN/1558605150/pgreenspun-20)
    and build themselves a normalized SQL data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: What do we have now?
  prefs: []
  type: TYPE_NORMAL
- en: SALES table
  prefs: []
  type: TYPE_NORMAL
- en: '| product id | store id | quantity sold | date/time of sale |'
  prefs: []
  type: TYPE_TB
- en: '| 567 | 17 | 1 | 1997-10-22 09:35:14 |'
  prefs: []
  type: TYPE_TB
- en: '| 219 | 16 | 4 | 1997-10-22 09:35:14 |'
  prefs: []
  type: TYPE_TB
- en: '| 219 | 17 | 1 | 1997-10-22 09:35:17 |'
  prefs: []
  type: TYPE_TB
- en: '| ... |'
  prefs: []
  type: TYPE_TB
- en: PRODUCTS table
  prefs: []
  type: TYPE_NORMAL
- en: '| product id | product name | product category | manufacturer id |'
  prefs: []
  type: TYPE_TB
- en: '| 567 | Colgate Gel Pump 6.4 oz. | 1 | 68 |'
  prefs: []
  type: TYPE_TB
- en: '| 219 | Diet Coke 12 oz. can | 2 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| ... |'
  prefs: []
  type: TYPE_TB
- en: PRODUCT_CATEGORIES table
  prefs: []
  type: TYPE_NORMAL
- en: '| product category id | product category name |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | toothpaste |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | soda |'
  prefs: []
  type: TYPE_TB
- en: '| ... |'
  prefs: []
  type: TYPE_TB
- en: MANUFACTURERS table
  prefs: []
  type: TYPE_NORMAL
- en: '| manufacturer id | manufacturer name |'
  prefs: []
  type: TYPE_TB
- en: '| 68 | Colgate |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Coca Cola |'
  prefs: []
  type: TYPE_TB
- en: '| ... |'
  prefs: []
  type: TYPE_TB
- en: STORES table
  prefs: []
  type: TYPE_NORMAL
- en: '| store id | city id | store location | phone number |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 34 | 510 Main Street | 415-555-1212 |'
  prefs: []
  type: TYPE_TB
- en: '| 17 | 58 | 13 Maple Avenue | 914-555-1212 |'
  prefs: []
  type: TYPE_TB
- en: '| ... |'
  prefs: []
  type: TYPE_TB
- en: CITIES table
  prefs: []
  type: TYPE_NORMAL
- en: '| city id | city name | state | population |'
  prefs: []
  type: TYPE_TB
- en: '| 34 | San Francisco | California | 700,000 |'
  prefs: []
  type: TYPE_TB
- en: '| 58 | East Fishkill | New York | 30,000 |'
  prefs: []
  type: TYPE_TB
- en: '| ... |'
  prefs: []
  type: TYPE_TB
- en: After a few months of stuffing data into these tables, a WalMart executive,
    call her Jennifer Amolucre asks "I noticed that there was a Colgate promotion
    recently, directed at people who live in small towns. How much Colgate toothpaste
    did we sell in those towns yesterday? And how much on the same day a month ago?"
  prefs: []
  type: TYPE_NORMAL
- en: At this point, reflect that because the data model is normalized, this information
    can't be obtained from scanning one table. A normalized data model is one in which
    all the information in a row depends only on the primary key. For example, the
    city population is not contained in the `stores` table. That information is stored
    once per city in the `cities` table and only `city_id` is kept in the `stores`
    table. This ensures efficiency for transaction processing. If Walmart has to update
    a city's population, only one record on disk need be touched. As computers get
    faster, what is more interesting is the consistency of this approach. With the
    city population kept only in one place, there is no risk that updates will be
    applied to some records and not to others. If there are multiple stores in the
    same city, the population will be pulled out of the same slot for all the stores
    all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Ms. Amolucre's query will look something like this...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: This query would be tough for a novice to read and, being a 6-way JOIN of some
    fairly large tables, might take quite a while to execute. Moreover, these tables
    are being updated as Ms. Amolucre's query is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Soon after the establishment of Jennifer Amolucre's quest for marketing information,
    store employees notice that there are times during the day when it is impossible
    to ring up customers. Any attempt to update the database results in the computer
    freezing up for 20 minutes. Eventually the database administrators realize that
    the system collapses every time Ms. Amolucre's toothpaste query gets run. They
    complain to Sybase tech support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Walmart: "We type in the toothpaste query and our system wedges."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sybase: "Of course it does! You built an on-line transaction processing (OLTP)
    system. You can''t feed it a decision support system (DSS) query and expect things
    to work!"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Walmart: "But I thought the whole point of SQL and your RDBMS was that users
    could query and insert simultaneously."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sybase: "Uh, not exactly. If you''re reading from the database, nobody can
    write to the database. If you''re writing to the database, nobody can read from
    the database. So if you''ve got a query that takes 20 minutes to run and don''t
    specify special locking instructions, nobody can update those tables for 20 minutes."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Walmart: "That sounds like a bug."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sybase: "Actually it is a feature. We call it *pessimistic locking*."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Walmart: "Can you fix your system so that it doesn''t lock up?"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Sybase: "No. But we made this great loader tool so that you can copy everything
    from your OLTP system into a separate DSS system at 100 GB/hour."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since you are reading this book, you are probably using Oracle, which is one
    of the few database management systems that achieves consistency among concurrent
    users via versioning rather than locking (the other notable example is the free
    open-source PostgreSQL RDBMS). However, even if you are using Oracle, where readers
    never wait for writers and writers never wait for readers, you still might not
    want the transaction processing operation to slow down in the event of a marketing
    person entering an expensive query.
  prefs: []
  type: TYPE_NORMAL
- en: Basically what IT vendors want Walmart to do is set up another RDBMS installation
    on a separate computer. Walmart needs to buy another $1 million of computer hardware.
    They need to buy another RDBMS license. They also need to hire programmers to
    make sure that the OLTP data is copied out nightly and stuffed into the DSS system--*data
    extraction*. Walmart is now building the *data warehouse*.
  prefs: []
  type: TYPE_NORMAL
- en: Insight 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A data warehouse is a separate RDBMS installation that contains copies of data
    from on-line systems. A physically separate data warehouse is not absolutely necessary
    if you have a lot of extra computing horsepower. With a DBMS that uses optimistic
    locking you might even be able to get away with keeping only one copy of your
    data.
  prefs: []
  type: TYPE_NORMAL
- en: As long as we're copying...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As long as you're copying data from the OLTP system into the DSS system ("data
    warehouse"), you might as well think about organizing and indexing it for faster
    retrieval. Extra indices on production tables are bad because they slow down inserts
    and updates. Every time you add or modify a row to a table, the RDBMS has to update
    the indices to keep them consistent. But in a data warehouse, the data are static.
    You build indices once and they take up space and sometimes make queries faster
    and that's it.
  prefs: []
  type: TYPE_NORMAL
- en: If you know that Jennifer Amolucre is going to do the toothpaste query every
    day, you can denormalize the data model for her. If you add a `town_population`
    column to the `stores` table and copy in data from the `cities` table, for example,
    you sacrifice some cleanliness of data model but now Ms. Amolucre's query only
    requires a 5-way JOIN. If you add `manufacturer` and `product_category` columns
    to the `sales` table, you don't need to JOIN in the `products` table.
  prefs: []
  type: TYPE_NORMAL
- en: Where does denormalization end?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you give up the notion that the data model in the data warehouse need bear
    some resemblance to the data model in the OLTP system, you begin to think about
    reorganizing the data model further. Remember that we're trying to make sure that
    new questions can be asked by people with limited SQL experience, i.e., many different
    questions can be answered with morphologically similar SQL. Ideally the task of
    constructing SQL queries can be simplified enough to be doable from a menu system.
    Also, we are trying to delivery predictable response time. A minor change in a
    question should not result in a thousand-fold increase in system response time.
  prefs: []
  type: TYPE_NORMAL
- en: The irreducible problem with the OLTP data model is that it is tough for novices
    to construct queries. Given that computer systems are not infinitely fast, a practical
    problem is inevitably that the response times of a query into the OLTP tables
    will vary in a way that is unpredictable to the novice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose, for example, that Bill Novice wants to look at sales on holidays versus
    non-holidays with the OLTP model. Bill will need to go look at the data model,
    which on a production system will contain hundreds of tables, to find out if any
    of them contain information on whether or not a date is a holiday. Then he will
    need to use it in a query, something that isn''t obvious given the peculiar nature
    of the Oracle `date` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'That one was pretty simple because JOINing to the `holiday_map` table knocks
    out sales on days that aren''t holidays. To compare to sales on non-holidays,
    he will need to come up with a different query strategy, one that knocks out sales
    on days that *are* holidays. Here is one way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Note that the morphology (structure) of this query is completely different from
    the one asking for sales on holidays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose now that Bill is interested in unit sales just at those stores where
    the unit sales tended to be high overall. First Bill has to experiment to find
    a way to ask the database for the big-selling stores. Probably this will involve
    grouping the `sales` table by the `store_id` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Now we know how to find stores that have sold more than 1000 units total, so
    we can add this as a subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Morphologically this doesn't look very different from the preceding non-holiday
    query. Bill has had to figure out how to use the GROUP BY and HAVING constructs
    but otherwise it is a single table query with a subquery. Think about the time
    to execute, however. The `sales` table may contain millions of rows. The `holiday_map`
    table probably only contains 50 or 100 rows, depending on how long the OLTP system
    has been in place. The most obvious way to execute these subqueries will be to
    perform the subquery for each row examined by the main query. In the case of the
    "big stores" query, the subquery requires scanning and sorting the entire `sales`
    table. So the time to execute this query might be 10,000 times longer than the
    time to execute the "non-holiday sales" query. Should Bill Novice expect this
    behavior? Should he have to think about it? Should the OLTP system grind to a
    halt because he didn't think about it hard enough?
  prefs: []
  type: TYPE_NORMAL
- en: Virtually all the organizations that start by trying to increase similarity
    and predictability among decision support queries end up with a *dimensional data
    warehouse*. This necessitates a new data model that shares little with the OLTP
    data model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dimensional Data Modeling: First Steps'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dimensional data modeling starts with a *fact table*. This is where we record
    what happened, e.g., someone bought a Diet Coke in East Fishkill. What you want
    in the fact table are facts about the sale, ideally ones that are numeric, continuously
    valued, and additive. The last two properties are important because typical fact
    tables grow to a billion rows or more. People will be much happier looking at
    sums or averages than detail. An important decision to make is the granularity
    of the fact table. If Walmart doesn't care about whether or not a Diet Coke was
    sold at 10:31 AM or 10:33 AM, recording each sale individually in the fact table
    is too granular. CPU time, disk bandwidth, and disk space will be needlessly consumed.
    Let's aggregate all the sales of any particular product in one store on a per-day
    basis. So we will only have one row in the fact table recording that 200 cans
    of Diet Coke were sold in East Fishkill on November 30, even if those 200 cans
    were sold at 113 different times to 113 different customers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: So far so good, we can pull together this table with a query JOINing the `sales`,
    `products`, and `product_prices` (to fill the `dollar_sales` column) tables. This
    JOIN will group by `product_id`, `store_id`, and the truncated `date_time_of_sale`.
    Constructing this query will require a professional programmer but keep in mind
    that this work only need be done once. The marketing experts who will be using
    the data warehouse will be querying from the `sales_fact` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'In building just this one table, we''ve already made life easier for marketing.
    Suppose they want total dollar sales by product. In the OLTP data model this would
    have required tangling with the `product_prices` table and its different prices
    for the same product on different days. With the sales fact table, the query is
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'We have a *fact table*. In a dimensional data warehouse there will always be
    just one of these. All of the other tables will define the *dimensions*. Each
    dimension contains extra information about the facts, usually in a human-readable
    text string that can go directly into a report. For example, let us define the
    time dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Why is it useful to define a time dimension? If we keep the date of the sales
    fact as an Oracle date column, it is still just about as painful as ever to ask
    for holiday versus non-holiday sales. We need to know about the existence of the
    `holiday_map` table and how to use it. Suppose we redefine the fact table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Instead of storing an Oracle date in the fact table, we''re keeping an integer
    key pointing to an entry in the time dimension. The time dimension stores, for
    each day, the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: whether or not the day was a holiday
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: into which fiscal period this day fell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: whether or not the day was part of the "Christmas season" or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want a report of sales by season, the query is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'If we want to get a report of sales by fiscal quarter or sales by day of week,
    the SQL is structurally identical to the above. If we want to get a report of
    sales by manufacturer, however, we realize that we need another dimension: *product*.
    Instead of storing the `product_id` that references the OLTP `products` table,
    much better to use a synthetic product key that references a product dimension
    where data from the OLTP `products`, `product_categories`, and `manufacturers`
    tables are aggregated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are Walmart, a multi-store chain, we will want a *stores* dimension.
    This table will aggregate information from the `stores` and `cities` tables in
    the OLTP system. Here is how we would define the stores dimension in an Oracle
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'This new dimension gives us the opportunity to compare sales for large versus
    small stores, for new and old ones, and for stores in different regions. We can
    aggregate sales by geographical region, starting at the state level and drilling
    down to county, city, or ZIP code. Here is how we''d query for sales by city:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Dimensions can be combined. To report sales by city on a quarter-by-quarter
    basis, we would use the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: (extra SQL compared to previous query shown in bold).
  prefs: []
  type: TYPE_NORMAL
- en: The final dimension in a generic Walmart-style data warehouse is *promotion*.
    The marketing folks will want to know how much a price reduction boosted sales,
    how much of that boost was permanent, and to what extent the promoted product
    cannibalized sales from other products sold at the same store. Columns in the
    promotion dimension table would include a promotion type (coupon or sale price),
    full information on advertising (type of ad, name of publication, type of publication),
    full information on in-store display, the cost of the promotion, etc.
  prefs: []
  type: TYPE_NORMAL
- en: At this point it is worth stepping back from the details to notice that the
    data warehouse contains less information than the OLTP system but it can be more
    useful in practice because queries are easier to construct and faster to execute.
    Most of the art of designing a good data warehouse is in defining the dimensions.
    Which aspects of the day-to-day business may be condensed and treated in blocks?
    Which aspects of the business are interesting?
  prefs: []
  type: TYPE_NORMAL
- en: 'Real World Example: A Data Warehouse for Levis Strauss'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1998, ArsDigita Corporation built a Web service as a front end to an experimental
    custom clothing factory operated by Levi Strauss. Users would visit our site to
    choose a style of khaki pants, enter their waist, inseam, height, weight, and
    shoe size, and finally check out with their credit card. Our server would attempt
    to authorize a charge on the credit card through CyberCash. The factory IT system
    would poll our server's Oracle database periodically so that it could start cutting
    pants within 10 minutes of a successfully authorized order.
  prefs: []
  type: TYPE_NORMAL
- en: The whole purpose of the factory and Web service was to test and analyze consumer
    reaction to this method of buying clothing. Therefore, a data warehouse was built
    into the project almost from the start.
  prefs: []
  type: TYPE_NORMAL
- en: We did not buy any additional hardware or software to support the data warehouse.
    The public Web site was supported by a mid-range Hewlett-Packard Unix server that
    had ample leftover capacity to run the data warehouse. We created a new "dw" Oracle
    user, GRANTed SELECT on the OLTP tables to the "dw" user, and wrote procedures
    to copy all the data from the OLTP system into a star schema of tables owned by
    the "dw" user. For queries, we added an IP address to the machine and ran a Web
    server program bound to that second IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we explained our engineering decisions to our customer (Levi Strauss):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'After some discussions with Levi''s executives, we designed in the following
    dimension tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**time**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for queries comparing sales by season, quarter, or holiday
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**product**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for queries comparing sales by color or style
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**ship to**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for queries comparing sales by region or state
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**promotion**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for queries aimed at determining the relationship between discounts and sales
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**consumer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for queries comparing sales by first-time and repeat buyers
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**user experience**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for queries looking at returned versus exchanged versus accepted items (most
    useful when combined with other dimensions, e.g., was a particular color more
    likely to lead to an exchange request)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These dimensions allow us to answer questions such as
  prefs: []
  type: TYPE_NORMAL
- en: In what regions of the country are pleated pants most popular? (fact table joined
    with the product and ship-to dimensions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What percentage of pants were bought with coupons and how has that varied from
    quarter to quarter? (fact table joined with the promotion and time dimensions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many pants were sold on holidays versus non-holidays? (fact table joined
    with the time dimension)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dimension Tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `time_dimension` table is identical to the example given above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: We populated the `time_dimension` table with a single INSERT statement. The
    core work is done by Oracle date formatting functions. A helper table, `integers`,
    is used to supply a series of numbers to add to a starting date (we picked July
    1, 1998, a few days before our first real order).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Remember the Oracle date minutia that you learned in the chapter on dates. If
    you add a number to an Oracle date, you get another Oracle date. So adding 3 to
    "1998-07-01" will yield "1998-07-04".
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several fields left to be populated that we cannot derive using Oracle
    date functions: season, fiscal period, holiday flag, season, event. Fiscal period
    depended on Levi''s choice of fiscal year. The `event` column was set aside for
    arbitrary blocks of time that were particularly interesting to the Levi''s marketing
    team, e.g., a sale period. In practice, it was not used.'
  prefs: []
  type: TYPE_NORMAL
- en: To update the `holiday_flag` field, we used two helper tables, one for "fixed"
    holidays (those which occur on the same day each year), and one for "floating"
    holidays (those which move around).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Some example holidays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'An extremely clever person who''d recently read [SQL for Smarties](http://www.amazon.com/exec/obidos/ASIN/1558605762/pgreenspun-20)
    would probably be able to come up with an SQL statement to update the `holiday_flag`
    in the `time_dimension` rows. However, there is no need to work your brain that
    hard. Recall that Oracle includes two procedural languages, Java and PL/SQL. You
    can implement the following pseudocode in the procedural language of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The product dimension The product dimension contains one row for each unique
    combination of color, style, cuffs, pleats, etc.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'To populate this dimension, we created a one-column table for each field in
    the dimension table and use a multi-table join without a WHERE clause. This generates
    the cartesian product of all the possible values for each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Notice that an Oracle sequence, `product_key_sequence`, is used to generate
    unique integer keys for each row as it is inserted into the dimension.
  prefs: []
  type: TYPE_NORMAL
- en: The promotion dimension The art of building the promotion dimension is dividing
    the world of coupons into a broad categories, e.g., "between 10 and 20 dollars".
    This categorization depended on the learning that the marketing executives did
    not care about the difference between a $3.50 and a $3.75 coupon.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The separate `coupon_state` and `coupon_range` columns allow for reporting of
    sales figures broken down into fullprice/discounted or into a bunch of rows, one
    for each range of coupon size.
  prefs: []
  type: TYPE_NORMAL
- en: The consumer dimension We did not have access to a lot of demographic data about
    our customers. We did not have a lot of history since this was a new service.
    Consequently, our consumer dimension is extremely simple. It is used to record
    whether or not a sale in the fact table was to a new or a repeat customer.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The user experience dimension If we are interested in building a report of the
    average amount of time spent contemplating a purchase versus whether the purchase
    was ultimately kept, the `user_experience_dimension` table will help.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The ship-to dimension Classically one of the most powerful dimensions in a data
    warehouse, our `ship_to_dimension` table allows us to group sales by region or
    state.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Notice that we've thrown out an awful lot of detail here. Had this been a full-scale
    product for Levi Strauss, they would probably have wanted at least extra columns
    for county, city, and zip code. These columns would allow a regional sales manager
    to look at sales within a state.
  prefs: []
  type: TYPE_NORMAL
- en: (In a data warehouse for a manufacturing wholesaler, the ship-to dimension would
    contain columns for the customer's company name, the division of the customer's
    company that received the items, the sales district of the salesperson who sold
    the order, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: The Fact Table
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The granularity of our fact table is one order. This is finer-grained than the
    canonical Walmart-style data warehouse as presented above, where a fact is the
    quantity of a particular SKU sold in one store on one day (i.e., all orders in
    one day for the same item are aggregated). We decided that we could afford this
    because the conventional wisdom in the data warehousing business in 1998 was that
    up to billion-row fact tables were manageable. Our retail price was $40 and it
    was tough to foresee a time when the factory could make more than 1,000 pants
    per day. So it did not seem extravagant to budget one row per order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the experimental nature of this project we did not delude ourselves into
    thinking that we would get it right the first time. Since we were recording one
    row per order we were able to cheat by including pointers from the data warehouse
    back into the OLTP database: `order_id` and `consumer_id`. We never had to use
    these but it was nice to know that if we couldn''t get a needed answer for the
    marketing executives the price would have been some custom SQL coding rather than
    rebuilding the entire data warehouse.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'After defining the fact table, we populated it with a single insert statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: As noted in the comment at top, most of the work here is done by PL/SQL procedures
    such as `find_product` that dig up the right row in a dimension table for this
    particular order.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding insert will load an empty data warehouse from the on-line transaction
    processing system's tables. Keeping the data warehouse up to date with what is
    happening in OLTP land requires a similar INSERT with an extra restriction WHERE
    clause limiting orders to only those order ID is larger than the maximum of the
    order IDs currently in the warehouse. This is a safe transaction to execute as
    many times per day as necessary--even two simultaneous INSERTs would not corrupt
    the data warehouse with duplicate rows because of the primary key constraint on
    `order_id`. A daily update is traditional in the data warehousing world so we
    scheduled one every 24 hours using the Oracle `dbms_job` package ([http://www.oradoc.com/ora816/server.816/a76956/jobq.htm#750](http://www.oradoc.com/ora816/server.816/a76956/jobq.htm#750)).
  prefs: []
  type: TYPE_NORMAL
- en: Sample Queries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have (1) defined a star schema, (2) populated the dimension tables, (3)
    loaded the fact table, and (4) arranged for periodic updating of the fact table.
    Now we can proceed to the interesting part of our data warehouse: getting information
    back out.'
  prefs: []
  type: TYPE_NORMAL
- en: Using only the `sales_fact` table, we can ask for
  prefs: []
  type: TYPE_NORMAL
- en: 'the total number of orders, total revenue to date, tax paid, shipping costs
    to date, the average price paid for each item sold, and the average number of
    days to ship:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: 'the average number of minutes from login to order (we exclude user sessions
    longer than 30 minutes to avoid skewing the results from people who interrupted
    their shopping session to go out to lunch or sleep for a few hours):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: 'the average number of days from first being invited to the site by email to
    the first order (excluding periods longer than 2 weeks to remove outliers):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: 'Joining against the `ship_to_dimension` table lets us ask how many pants were
    shipped to each region of the United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '| Region | Pants Sold |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| New England Region |   612 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| NY and NJ Region |   321 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Mid Atlantic Region |   318 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Western Region |   288 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Southeast Region |   282 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Southern Region |   193 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Great Lakes Region |   177 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Northwestern Region |   159 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Central Region |   134 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| North Central Region |   121 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Note: these data are based on a random subset of orders from the Levi''s site
    and we have also made manual changes to the report values. The numbers are here
    to give you an idea of what these queries do, not to provide insight into the
    Levi''s custom clothing business.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Joining against the `time_dimension`, we can ask how many pants were sold for
    each day of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '| Day of Week | Pants Sold |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Thursday |   3428 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Wednesday |   2823 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Tuesday |   2780 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Monday |   2571 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Friday |   2499 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Saturday |   1165 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Sunday |   814 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'We were able to make pants with either a "dressy" or "casual" fabric. Joining
    against the `product_dimension` table can tell us how popular each option was
    as a function of color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '| Color | Pants Sold |   % Dressy |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| dark tan |   486 |   100 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| light tan |   305 |   49 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| dark grey |   243 |   100 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| black |   225 |   97 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| navy blue |   218 |   61 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| medium tan |   209 |   0 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| olive green |   179 |   63 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Note: 100% and 0% indicate that those colors were available only in one fabric.'
  prefs: []
  type: TYPE_NORMAL
- en: Here is a good case of how the data warehouse may lead to a practical result.
    If these were the real numbers from the Levi's warehouse, what would pop out at
    the manufacturing guys is that 97% of the black pants sold were in one fabric
    style. It might not make sense to keep an inventory of casual black fabric if
    there is so little consumer demand for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Query Generation: The Commercial Closed-Source Route'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The promise of a data warehouse is not fulfilled if all users must learn SQL
    syntax and how to run SQL*PLUS. From being exposed to 10 years of advertising
    for query tools, we decided that the state of forms-based query tools must be
    truly advanced. We thus suggested to Levi Strauss that they use Seagate Crystal
    Reports and Crystal Info to analyze their data. These packaged tools, however,
    ended up not fitting very well with what Levi's wanted to accomplish. First, constructing
    queries was not semantically simpler than coding SQL. The Crystal Reports consultant
    that we brought in said that most of his clients ended up having a programmer
    set up the report queries and the business people would simply run the report
    every day against new data. If professional programmers had to construct queries,
    it seemed just as easy just to write more admin pages using our standard Web development
    tools, which required about 15 minutes per page. Second, it was impossible to
    ensure availability of data warehouse queries to authorized users anywhere on
    the Internet. Finally there were security and social issues associated with allowing
    a SQL*Net connection from a Windows machine running Crystal Reports out through
    the Levi's firewall to our Oracle data warehouse on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Not knowing if any other commercial product would work better and not wanting
    to disappoint our customer, we extended the ArsDigita Community System with a
    data warehouse query module that runs as a Web-only tool. This is a free open-source
    system and comes with the standard ACS package that you can download from [http://www.arsdigita.com/download/](http://www.arsdigita.com/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Query Generation: The Open-Source ACS Route'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The "dw" module in the ArsDigita Community System is designed with the following
    goals:'
  prefs: []
  type: TYPE_NORMAL
- en: naive users can build simple queries by themselves
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: professional programmers can step in to help out the naive users
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a user with no skill can re-execute a saved query
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We keep one row per query in the `queries` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Unless the `query_sql` column is populated with a hand-edited query, the query
    will be built up by looking at several rows in the `query_columns` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: The `query_columns` definition appears strange at first. It specifies the name
    of a column but not a table. This module is predicated on the simplifying assumption
    that we have one enormous view, `ad_hoc_query_view`, that contains all the dimension
    tables' columns alongside the fact table's columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we create the view for the Levi''s data warehouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: At first glance, this looks like a passport to sluggish Oracle performance.
    We'll be doing a seven-way JOIN for every data warehouse query, regardless of
    whether we need information from some of the dimension tables or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this assumption as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Oracle will return the query results first...
  prefs: []
  type: TYPE_NORMAL
- en: '| ship_to_region | color | count(pants_id) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Central Region | black | 46 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Central Region | dark grey | 23 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Central Region | dark tan | 39 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| .. |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Western Region | medium tan | 223 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Western Region | navy blue | 245 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Western Region | olive green | 212 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '... and then explain how those results were obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'As you can see from the table names in bold face, Oracle was smart enough to
    examine only tables relevant to our query: `product_dimension`, because we asked
    about color; `ship_to_dimension`, because we asked about region; `sales_fact`,
    because we asked for a count of pants sold. Bottom line: Oracle did a 3-way JOIN
    instead of the 7-way JOIN specified by the view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a SQL query into `ad_hoc_query_view` from the information stored
    in `query_columns` is most easily done with a function in a procedural language
    such as Java, PL/SQL, Perl, or Tcl (here is pseudocode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'How well does this work in practice? Suppose that we were going to run regional
    advertisements. Should the models be pictured where pleated or plain front pants?
    We need to look at recent sales by region. With the ACS query tool, a user can
    use HTML forms to specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'pants_id : select and aggregate using count'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ship_to_region : select and group by'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pleat_state : select and group by'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding pseudocode turns that into
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: which is going to report sales going back to the dawn of time. If we weren't
    clever enough to anticipate the need for time windowing in our forms-based interface,
    the "hand edit the SQL" option will save us. A professional programmer can be
    grabbed for a few minutes to add
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Now we''re limiting results to the last 45 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ship_to_region | pleat_state | count(pants_id) |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Central Region | plain front | 8 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Central Region | pleated | 26 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Great Lakes Region | plain front | 14 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Great Lakes Region | pleated | 63 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Mid Atlantic Region | plain front | 56 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Mid Atlantic Region | pleated | 162 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| NY and NJ Region | plain front | 62 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| NY and NJ Region | pleated | 159 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| New England Region | plain front | 173 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| New England Region | pleated | 339 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| North Central Region | plain front | 7 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| North Central Region | pleated | 14 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Northwestern Region | plain front | 20 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Northwestern Region | pleated | 39 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Southeast Region | plain front | 51 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Southeast Region | pleated | 131 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Southern Region | plain front | 13 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Southern Region | pleated | 80 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Western Region | plain front | 68 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Western Region | pleated | 120 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'If we strain our eyes and brains a bit, we can see that plain front pants are
    very unpopular in the Great Lakes and South but more popular in New England and
    the West. It would be nicer to see percentages within region, but standard SQL
    does not make it possible to combine results to values in surrounding rows. We
    will need to refer to [the "SQL for Analysis" chapter](http://oradoc.photo.net/ora816/server.816/a76994/analysis.htm#1020)
    in the Oracle data warehousing documents to read up on extensions to SQL that
    makes this possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'We''re asked Oracle to window the results ("partition by ship_to_region") and
    compare the number of pants in each row to the sum across all the rows within
    a regional group. Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ship_to_region | pleat_state | count(pants_id) | percent_in_region |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ... |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Great Lakes Region | plain front | 14 | .181818182 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Great Lakes Region | pleated | 63 | .818181818 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ... |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| New England Region | plain front | 173 | .337890625 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| New England Region | pleated | 339 | .662109375 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ... |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'This isn''t quite what we want. The "percents" are fractions of 1 and reported
    with far too much precision. We tried inserting the Oracle built-in `round` function
    in various places of this SQL statement but all we got for our troubles was "ERROR
    at line 5: ORA-30484: missing window specification for this function". We had
    to add an extra layer of SELECT, a view-on-the-fly, to get the report that we
    wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: returns
  prefs: []
  type: TYPE_NORMAL
- en: '| ship_to_region | pleat_state | count(pants_id) | percent_in_region |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ... |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Great Lakes Region | plain front | 14 | 18 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| Great Lakes Region | pleated | 63 | 82 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ... |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| New England Region | plain front | 173 | 34 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| New England Region | pleated | 339 | 66 |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| ... |'
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: What if you're in charge of the project?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are in charge of a data warehousing project, you need to assemble the
    necessary tools. Do not be daunted by this prospect. The entire Levi Strauss system
    described above was implemented in three days by two programmers.
  prefs: []
  type: TYPE_NORMAL
- en: The first tool that you need is intelligence and thought. If you pick the right
    dimensions and put the required data into them, your data warehouse will be useful.
    If you don't get your dimensions right, you won't even be able to ask the interesting
    questions. If you're not smart or thoughtful, probably the best thing to do is
    find a boutique consulting firm with expertise in building data warehouses for
    your industry. Get them to lay out the initial star schema. They won't get it
    right but it should be close enough to live with for a few months. If you can't
    find an expert, [The Data Warehouse Toolkit](http://www.amazon.com/exec/obidos/ASIN/0471153370/pgreenspun-20)
    (Ralph Kimball 1996) contains example schemata for 10 different kinds of businesses.
  prefs: []
  type: TYPE_NORMAL
- en: You will need some place to store your data and query parts back out. Since
    you are using SQL your only choice is a relational database management system.
    There are specialty vendors that have historically made RDBMSes with enhanced
    features for data warehousing, such as the ability to compute a value based on
    information from the current row compared to information from a previously output
    row of the report. This gets away from the strict unordered set-theoretic way
    of looking at the world that E.F. Codd sketched in 1970 but has proven to be useful.
    Starting with version 8.1.6, Oracle has added most of the useful third-party features
    into their standard product. Thus all but the very smallest and very largest modern
    data warehouses tend to be built using Oracle (see [the "SQL for Analysis" chapter](http://oradoc.photo.net/ora816/server.816/a76994/analysis.htm#1020)
    in the [Oracle8i Data Warehousing Guide](http://oradoc.photo.net/ora816/server.816/a76994/toc.htm)
    volume of the Oracle documentation).
  prefs: []
  type: TYPE_NORMAL
- en: Oracle contains two features that may enable you to construct and use your data
    warehouse without investing in separate hardware. First is the optimistic locking
    system that Oracle has employed since the late 1980s. If someone is doing a complex
    query it will not affect transactions that need to update the same tables. Essentially
    each query runs in its own snapshot of the database as it existed when the query
    was started. The second Oracle feature is *materialized views* or *summaries*.
    It is possible to instruct the database to keep a summary of sales by quarter,
    for example. If someone asks for a query involving quarterly sales, the small
    summary table will be consulted instead of the comprehensive sales table. This
    could be 100 to 1000 times faster.
  prefs: []
  type: TYPE_NORMAL
- en: One typical goal of a data warehousing project is to provide a unified view
    of a company's disparate information systems. The only way to do this is to extract
    data from all of these information systems and clean up those data for consistency
    and accuracy. This is purportedly a challenging task when RDBMSes from different
    vendors are involved, though it might not seem so on the surface. After all, every
    RDBMS comes with a C library. You could write a C program to perform queries on
    the Brand X database and do inserts on the Brand Y database. Perl and Tcl have
    convenient facilities for transforming text strings and there are db connectivity
    interfaces from these scripting languages to DBMS C libraries. So you could write
    a Perl script. Most databases within a firm are accessible via the Web, at least
    within a company's internal network. Oracle includes a Java virtual machine and
    Java libraries to fetch Web pages and parse XML. So you could write a Java or
    PL/SQL program running inside your data warehouse Oracle installation to grab
    the foreign information and bring it back (see the chapter on foreign and legacy
    data).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't like to program or have a particularly knotty connectivity problem
    involving an old mainframe, various companies make software that can help. For
    high-end mainframe stuff, Oracle Corporation itself offers some useful layered
    products. For low-end "more-convenient-than-Perl" stuff, Data Junction ([www.datajunction.com](http://www.datajunction.com))
    is useful.
  prefs: []
  type: TYPE_NORMAL
- en: Given an already-built data warehouse, there are a variety of useful query tools.
    The theory is that if you've organized your data model well enough, a non-technical
    user will be able to navigate around via a graphic user interface or a Web browser.
    The best known query tool is Crystal Reports ([www.seagatesoftware.com](http://www.seagatesoftware.com)),
    which we tried to use in the Levi Strauss example. See [http://www.arsdigita.com/doc/dw](http://www.arsdigita.com/doc/dw)
    for details on the free open-source ArsDigita Community System data warehouse
    query module.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a bottom line to all of this? If you can think sufficiently clearly
    about your organization and its business to construct the correct dimensions and
    program SQL reasonably well, you will be successful with the raw RDBMS alone.
    Extra software tools can potentially make the project a bit less painful or a
    bit shorter but they won't be of critical importance.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The construction of data warehouses is a guild-like activity. Most of the expert
    knowledge is contained within firms that specialize not in data warehousing but
    in data warehousing for a particular kind of company. For example, there are firms
    that do nothing but build data warehouses for supermarkets. There are firms that
    do nothing but build data warehouses for department stores. Part of what keeps
    this a tight guild is the poor quality of textbooks and journal articles on the
    subject. Most of the books on data warehousing are written by and for people who
    do not know SQL. The books focus on (1) stuff that you can buy from a vendor,
    (2) stuff that you can do from a graphical user interface after the data warehouse
    is complete, and (3) how to navigate around a large organization to get all the
    other suits to agree to give you their data, their money, and a luxurious schedule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only worthwhile introductory book that we''ve found on data warehousing
    in general is Ralph Kimball''s [The Data Warehouse Toolkit](http://www.amazon.com/exec/obidos/ASIN/0471153370/pgreenspun-20).
    Kimball is also the author of an inspiring book on clickstream data warehousing:
    [The Data Webhouse Toolkit](http://www.amazon.com/exec/obidos/ASIN/0471376809/pgreenspun-20).
    The latter book is good if you are interested in applying classical dimensional
    data warehousing techniques to user activity analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: It isn't exactly a book and it isn't great for beginners but the [Oracle8i Data
    Warehousing Guide](http://oradoc.photo.net/ora816/server.816/a76994/toc.htm) volume
    of the official Oracle server documentation is extremely useful.
  prefs: []
  type: TYPE_NORMAL
- en: Data on consumer purchasing behavior are available from A.C. Nielsen ([www.acnielsen.com](http://www.acnielsen.com/)),
    Information Resources Incorporated (IRI; [www.infores.com](http://www.infores.com)),
    and a bunch of other companies listed in [http://dir.yahoo.com/Business_and_Economy/Business_to_Business/Marketing_and_Advertising/Market_Research/](http://dir.yahoo.com/Business_and_Economy/Business_to_Business/Marketing_and_Advertising/Market_Research/).
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Oracle8i Data Warehousing Guide](http://oradoc.photo.net/ora816/server.816/a76994/toc.htm),
    particularly the [the "SQL for Analysis" chapter](http://oradoc.photo.net/ora816/server.816/a76994/analysis.htm#1020)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ROLLUP examples from the Oracle Application Developer''s Guide: [http://www.oradoc.com/keyword/rollup](http://www.oradoc.com/keyword/rollup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next: [Foreign and Legacy Data](foreign-and-legacy-data.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[philg@mit.edu](http://philip.greenspun.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Reader's Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I really like that Walmart/Sybase example, because Walmart is actually running
    the largest commercial data warehouse in the world including 2 years of detail
    data with tens of billions of detail rows. Of course, it's not using an OLTP system
    like Sybase/Oracle, it's a decision support database, Teradata.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Dieter Noeth](/shared/community-member?user_id=243422), May 14, 2003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I would dispute that: http://www.wintercorp.com/vldb/2003_TopTen_Survey/TopTenWinners.asp
    Shows that France Telecom has the largest DSS system in Oracle. Walmart is not
    in the top-ten list, and surprise, surprise, the squashed competitor Kmart is.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [what ever](/shared/community-member?user_id=257822), January 7, 2004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Your comments about Sybase are naive and incorrect. Perhaps you had a bad run
    dealing with Sybase support, not sure if I can influence it otherwise. Sybase
    IQ for years now has been the bane some of the World's Largest data warehouses.
    Query performance and scalability are notably the highlights of all Sybase IQ
    implementations. Sybase customer, comScore Networks, received the Grand Prize
    in the 2003 Winter Corporation TopTen Program for Largest Database Size and Most
    Rows/Records for Microsoft Windows-based systems using Sybase IQ, the highly scalable
    analytics engine. Other Winter Corporation TopTen award-winning Sybase customers
    in UNIX categories include Nielsen Media Research and Korean-based customers Health
    Insurance Review Agency (HIRA), LG Card, Samsung Card and Chohung Bank. http://www.sybase.be/belgium/press/20031111-ipg-IQwintercorp.jsp
    I appreciate that you have given an opportunity to comment on this page.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Subraya Pai](/shared/community-member?user_id=260919), May 9, 2004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Crystal Reports is not the reporting tool usually choosen for ad-hoc querying
    of datawarehouses, so maybe that's the reason your end customers weren't very
    happy about it. Tools better suited to this task are BusinessObjects (who also
    aquired CrystalReports a couple of month ago), Brio (aquired by Hyperion about
    1 year ago), Microstrategy, Oracle Discoverer and Cognos. All of them allow you
    to build metadata about the datamodel of the datawarehouse and present the end
    user with the world in terms known to them (no criptic database table column names,
    predefined filter conditions and so on). For the end-user it's really only a matter
    of dragging and dropping the "objects" in their report and "pressing" a button.
    The tool will the generate the proper SQL, query the database (some of them even
    rewrite the query if you have aggregate tables, allow you to "join" in the report
    query results from different queries and databases or take a stored procedure
    as the data source) allow you to do simple computations (excel-like) on the result
    set etc.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Regards, Georg
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [Georg Breazu](/shared/community-member?user_id=262174), November 15, 2004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this article considered as a good article in data warehousing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I want to say that there is a query language called multidimensional Expression
    MDX .It is now the standard query language for OLAP.it is like Sql but with more
    capabilities in Grouping and more functions to facilitate OLAP operations.The
    most common function are ROLLUP and CUBE>>>>>>>>>>>>>>>>>>>>>>>>>>>etc. thanks
    to all.....
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [drtech dr](/shared/community-member?user_id=301615), December 22, 2008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: good n useful article..tnx for sharing..
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: -- [mitesh trivedi](/shared/community-member?user_id=320535), February 9, 2010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Add a comment](/comments/add?page_id=3594)'
  prefs: []
  type: TYPE_NORMAL
- en: Related Links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Optimize Data Warehouse](http://www.dwoptimize.com/2007/06/components-of-data-warehouse.html)-
    Optimize performance and usability of large data warehouses using parallelism,
    partitions, and aggregate summaries across the complete application stack comprising
    of ETL, databases, and reporting.   (contributed by [Jag Singh](/shared/community-member?user_id=282093))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DBMS 2 on data warehousing](http://www.dbms2.com/category/analytics-technologies/data-warehouse/)-
    Data warehouse technology, developments, and trends, from what is now the industry-leading
    source of database management news and analysis.   (contributed by [Curt Monash](/shared/community-member?user_id=333315))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Add a link](/links/add?page_id=3594)'
  prefs: []
  type: TYPE_NORMAL
