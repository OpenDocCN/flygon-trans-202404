- en: InductionProof by Induction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Export Basics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Proof by Induction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We proved in the last chapter that 0 is a neutral element
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: for + on the left, using an easy argument based on
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplification.  We also observed that proving the fact that it is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: also a neutral element on the *right*...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '... can''t be done in the same simple way.  Just applying'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reflexivity doesn't work, since the n in n + 0 is an arbitrary
  prefs: []
  type: TYPE_NORMAL
- en: unknown number, so the match in the definition of + can't be
  prefs: []
  type: TYPE_NORMAL
- en: simplified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And reasoning by cases using destruct n doesn't get us much
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'further: the branch of the case analysis where we assume n = 0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: goes through fine, but in the branch where n = S n' for some n' we
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get stuck in exactly the same way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We could use destruct n' to get one step further, but,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: since n can be arbitrarily large, if we just go on like this
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: we'll never finish.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To prove interesting facts about numbers, lists, and other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: inductively defined sets, we usually need a more powerful
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'reasoning principle: *induction*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recall (from high school, a discrete math course, etc.) the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*principle of induction over natural numbers*: If P(n) is some'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proposition involving a natural number n and we want to show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'that P holds for all numbers n, we can reason like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: show that P(O) holds;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: show that, for any n', if P(n') holds, then so does P(S n');
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: conclude that P(n) holds for all n.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Coq, the steps are the same: we begin with the goal of proving'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P(n) for all n and break it down (by applying the induction
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'tactic) into two separate subgoals: one where we must show P(O)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and another where we must show P(n') → P(S n').  Here's how
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'this works for the theorem at hand:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Like destruct, the induction tactic takes an as...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: clause that specifies the names of the variables to be introduced
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the subgoals.  Since there are two subgoals, the as... clause
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: has two parts, separated by |.  (Strictly speaking, we can omit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the as... clause and Coq will choose names for us.  In practice,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: this is a bad idea, as Coq's automatic choices tend to be
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: confusing.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first subgoal, n is replaced by 0.  No new variables
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are introduced (so the first part of the as... is empty), and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: the goal becomes 0 + 0 = 0, which follows by simplification.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the second subgoal, n is replaced by S n', and the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assumption n' + 0 = n' is added to the context with the name
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IHn' (i.e., the Induction Hypothesis for n').  These two names
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: are specified in the second part of the as... clause.  The goal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in this case becomes (S n') + 0 = S n', which simplifies to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: S (n' + 0) = S n', which in turn follows from IHn'.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: (The use of the intros tactic in these proofs is actually
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: redundant.  When applied to a goal that contains quantified
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: variables, the induction tactic will automatically move them
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: into the context as needed.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, recommended (basic_induction)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove the following using induction. You might need previously
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: proven results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (double_plus)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following function, which doubles its argument:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use induction to prove this simple fact about double:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (evenb_S)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One inconveninent aspect of our definition of evenb n is the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: recursive call on n - 2. This makes proofs about evenb n
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: harder when done by induction on n, since we may need an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: induction hypothesis about n - 2. The following lemma gives an
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: alternative characterization of evenb (S n) that works better
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'with induction:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 starM (destruct_induction)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Briefly explain the difference between the tactics destruct
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: and induction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* FILL IN HERE *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem mult_0_plus'' : ∀n m : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: (0 + n) * m = n * m.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m.
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (H: 0 + n = n). { reflexivity. }'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → H.
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_rearrange_firsttry : ∀n m p q : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: (n + m) + (p + q) = (m + n) + (p + q).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m p q.
  prefs: []
  type: TYPE_NORMAL
- en: (* We just need to swap (n + m) for (m + n)... seems      like plus_comm should do the trick! *)
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → plus_comm.
  prefs: []
  type: TYPE_NORMAL
- en: (* Doesn't work...Coq rewrote the wrong plus! *)
  prefs: []
  type: TYPE_NORMAL
- en: Abort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_rearrange : ∀n m p q : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: (n + m) + (p + q) = (m + n) + (p + q).
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m p q.
  prefs: []
  type: TYPE_NORMAL
- en: 'assert (H: n + m = m + n).'
  prefs: []
  type: TYPE_NORMAL
- en: '{ rewrite → plus_comm. reflexivity. }'
  prefs: []
  type: TYPE_NORMAL
- en: rewrite → H. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_assoc'' : ∀n m p : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: n + (m + p) = (n + m) + p.
  prefs: []
  type: TYPE_NORMAL
- en: Proof. intros n m p. induction n as [| n' IHn']. reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite → IHn'. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Theorem plus_assoc'''' : ∀n m p : nat,'
  prefs: []
  type: TYPE_NORMAL
- en: n + (m + p) = (n + m) + p.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs: []
  type: TYPE_NORMAL
- en: intros n m p. induction n as [| n' IHn'].
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = 0 *)'
  prefs: []
  type: TYPE_NORMAL
- en: reflexivity.
  prefs: []
  type: TYPE_NORMAL
- en: '- (* n = S n'' *)'
  prefs: []
  type: TYPE_NORMAL
- en: simpl. rewrite → IHn'. reflexivity. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: n + (m + p) = (n + m) + p.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Proof*: By induction on n.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: First, suppose n = 0. We must show
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Next, suppose n = S n', where
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: (S n') + (m + p) = ((S n') + m) + p.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: By the definition of +, this follows from
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: More Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, recommended (mult_comm)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use assert to help prove this theorem.  You shouldn't need to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use induction on plus_swap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now prove commutativity of multiplication.  (You will probably
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: need to define and prove a separate subsidiary theorem to be used
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: in the proof of this one.  You may find that plus_swap comes in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: handy.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, optional (more_exercises)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Take a piece of paper.  For each of the following theorems, first
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*think* about whether (a) it can be proved using only'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: simplification and rewriting, (b) it also requires case
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: analysis (destruct), or (c) it also requires induction.  Write
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: down your prediction.  Then fill in the proof.  (There is no need
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: to turn in your piece of paper; this is just to encourage you to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: reflect before you hack!)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (beq_nat_refl)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove the following theorem.  (Putting the true on the left-hand
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: side of the equality may look odd, but this is how the theorem is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: stated in the Coq standard library, so we follow suit.  Rewriting
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: works equally well in either direction, so we will have no problem
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: using the theorem no matter which way we state it.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars, optional (plus_swap'')'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The replace tactic allows you to specify a particular subterm to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'rewrite and what you want it rewritten to: replace (t) with (u)'
  prefs: []
  type: TYPE_NORMAL
- en: replaces (all copies of) expression t in the goal by expression
  prefs: []
  type: TYPE_NORMAL
- en: u, and generates t = u as an additional subgoal. This is often
  prefs: []
  type: TYPE_NORMAL
- en: useful when a plain rewrite acts on the wrong part of the goal.
  prefs: []
  type: TYPE_NORMAL
- en: Use the replace tactic to do a proof of plus_swap', just like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: plus_swap but without needing assert (n + m = m + n).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 3 stars, recommendedM (binary_commute)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall the incr and bin_to_nat functions that you
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: wrote for the binary exercise in the [Basics](Basics.html) chapter.  Prove
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'that the following diagram commutes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: (* FILL IN HERE *)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
