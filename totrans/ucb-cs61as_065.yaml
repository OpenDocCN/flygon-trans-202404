- en: Sequences as Conventional Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequences as Abstractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore more into the concept of abstraction. One major benefit of using
    abstraction is that it helps us clean up code and increase readability. Some of
    the functions that we write for sequences can be generalized and abstracted using
    Higher Order Functions. This idea can be summarized by the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a recurring pattern in our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract each element in the pattern using HOFs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redefine our code with using the abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here are two example functions that will help demonstrate this idea.
  prefs: []
  type: TYPE_NORMAL
- en: '`sum-odd-squares` takes in a tree containing numbers and adds together the
    square of each **odd** element in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`even-fibs` takes in a number `n`, and returns a list of even fibonacci numbers
    up to and including `n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From a first glance at the two functions, we might say "These two functions
    have nothing in common!". Sure, the functions look completely different but they
    do share the same logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2be0131620e5880b328720c924f164fb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step in our idea was to find a recurring pattern in our code. From
    how we''ve described recursion in previous lessons, you might dissect `sum-odd-squares`
    and `even-fibs` by base cases and recursive calls. Now, let''s see what each function
    does from a different perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sum-odd-squares`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**enumerates** the leaves of a tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**filters** out the nodes with even data, leaving only odd-valued nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**maps** the function `square` onto each of the remaining nodes, and finally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**accumulates** the results by adding them together, starting with 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`even-fibs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**enumerates** the integers from 0 to `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**maps** the function `fib` onto each integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**filters** out the odd numbers, leaving only even Fibonacci numbers, and finally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**accumulates** the results using `cons`, starting with the empty list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What pattern do we see here? What at first seemed like two very different functions
    can now be summarized into four major parts: enumeration, filtering, accumulation,
    and computation. This is great, because now we can use HOFs to abstract our code.
    This leads us to step two of our abstraction idea. But before that, let''s go
    over some HOFs.'
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We went over the `map` HOF in Lesson 4\. You may want to [go back](http://localhost:8000/textbook/representing-sequences.html#sub3)
    for a quick refresher.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`filter` takes in two arguments, `predicate` and `sequence`, and returns the
    sequence with only the elements of that sequence that satisfy `predicate`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: What do the following expressions return?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Accumulate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`accumulate` takes in an operation `op`, a starting value `initial`, and a
    `sequence`. Starting from `initial`, `accumulate` uses `op` to combine all the
    values in `sequence` into one. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how we define `accumulate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'How this HOF works could be a little confusing, so here let''s write out the
    evaluation steps explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(accumulate + 0 (list 1 2 3 4 5))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive steps will proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (accumulate + 0 (list 2 3 4 5)))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (+ 2 (accumulate + 0 (list 3 4 5))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (+ 2 (+ 3 (accumulate + 0 (list 4 5)))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (+ 2 (+ 3 (+ 4 (accumulate + 0 (list 5))))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (accumulate + 0 (list)))))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 0)))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (+ 2 (+ 3 (+ 4 5))))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (+ 2 (+ 3 9)))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 (+ 2 12))`'
  prefs: []
  type: TYPE_NORMAL
- en: '`(+ 1 14)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`15`'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What does `enumerate` do? `enumerate` makes a sequence/list of elements. Our
    definition of `filter`, `map`, and `accumulate` are designed for sequences but
    recall that one of our functions, `sum-odd-squares` is called on trees. Instead
    of making several versions of accumulate, map, and filter, we can differentiate
    them by just having different `enumerate` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate for Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerate will return a list given a lower and upper range.
  prefs: []
  type: TYPE_NORMAL
- en: '`(enumerate-interval 0 5)` returns `(0 1 2 3 4 5)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(enumerate-interval 10 13)` returns `(10 11 12 13)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can define enumerate (for lists) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Enumerate for Trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our tree-version of enumerate, we need a function that accepts a tree, and
    returns a list with all of the leaves, so that it is compatible with the rest
    of our HOFs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Putting Everything Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we reach our final step in our abstraction idea. With all of the helper
    functions we have defined, we can define a more modular, readable, and compact
    version of `sum-odd-squares` and `even-fibs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What did we do here? We find all the leaves in the tree (**enumerate**), keep
    everything that is odd (**filter**), square everything left (**map**), and add
    up the results (**accumulate**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly we can define `even-fibs` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What happened this time? We make a list from 0 to `n` (**enumerate**), find
    the Fibonacci number for all of them (**map**), keep everything that is even (**filter**),
    and put them together into a list (**accumulate**).
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sequences provide a strong foundation for abstraction with different combinations
    of `map`, `filter`, `accumulate` and `enumerate`. Even functions that may look
    to have different structures like the ones we used here as an example, we may
    be able to break them down using similar process signals.
  prefs: []
  type: TYPE_NORMAL
