- en: Chapter 4\. Procedures and Variable Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Procedures and variable bindings are the fundamental building blocks of Scheme
    programs. This chapter describes the small set of syntactic forms whose primary
    purpose is to create procedures and manipulate variable bindings. It begins with
    the two most fundamental building blocks of Scheme programs: variable references
    and `lambda` expressions, and continues with descriptions of the variable binding
    and assignment forms such as `define`, `letrec`, `let-values`, and `set!`.'
  prefs: []
  type: TYPE_NORMAL
- en: Various other forms that bind or assign variables for which the binding or assignment
    is not the primary purpose (such as named `let`) are found in Chapter [5](control.html#g96).
  prefs: []
  type: TYPE_NORMAL
- en: Section 4.1\. Variable References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `*variable*`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the value of `*variable*`'
  prefs: []
  type: TYPE_NORMAL
- en: Any identifier appearing as an expression in a program is a variable if a visible
    variable binding for the identifier exists, e.g., the identifier appears within
    the scope of a binding created by `define`, `lambda`, `let`, or some other variable-binding
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: '`list ![<graphic>](ch2_0.gif) #<procedure>'
  prefs: []
  type: TYPE_NORMAL
- en: (define x 'a)
  prefs: []
  type: TYPE_NORMAL
- en: (list x x) ![<graphic>](ch2_0.gif) (a a)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 'b])
  prefs: []
  type: TYPE_NORMAL
- en: (list x x)) ![<graphic>](ch2_0.gif) (b b)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([let 'let]) let) ![<graphic>](ch2_0.gif) let`
  prefs: []
  type: TYPE_NORMAL
- en: It is a syntax violation for an identifier reference to appear within a `library`
    form or top-level program if it is not bound as a variable, keyword, record name,
    or other entity. Since the scope of the definitions in a `library`, top-level
    program, `lambda`, or other local body is the entire body, it is not necessary
    for the definition of a variable to appear before its first reference appears,
    as long as the reference is not actually evaluated until the definition has been
    completed. So, for example, the reference to `g` within the definition of `f`
    below
  prefs: []
  type: TYPE_NORMAL
- en: '`(define f'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (g x)))
  prefs: []
  type: TYPE_NORMAL
- en: (define g
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x)))`
  prefs: []
  type: TYPE_NORMAL
- en: is okay, but the reference to `g` in the definition of `q` below is not.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define q (g 3))'
  prefs: []
  type: TYPE_NORMAL
- en: (define g
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x)))`
  prefs: []
  type: TYPE_NORMAL
- en: Section 4.2\. Lambda
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(lambda *formals* *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a procedure'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: The `lambda` syntactic form is used to create procedures. Any operation that
    creates a procedure or establishes local variable bindings is ultimately defined
    in terms of `lambda` or `case-lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: The variables in `*formals*` are the formal parameters of the procedure, and
    the sequence of subforms `*body[1]* *body[2]* ...` is its body.
  prefs: []
  type: TYPE_NORMAL
- en: The body may begin with a sequence of definitions, in which case the bindings
    created by the definitions are local to the body. If definitions are present,
    the keyword bindings are used and discarded while expanding the body, and the
    body is expanded into a `letrec*` expression formed from the variable definitions
    and the remaining expressions, as described on page [292](syntax.html#body-expansion).
    The remainder of this description of `lambda` assumes that this transformation
    has taken place, if necessary, so that the body is a sequence of expressions without
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: When the procedure is created, the bindings of all variables occurring free
    within the body, excluding the formal parameters, are retained with the procedure.
    Subsequently, whenever the procedure is applied to a sequence of actual parameters,
    the formal parameters are bound to the actual parameters, the retained bindings
    are restored, and the body is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Upon application, the formal parameters defined by `*formals*` are bound to
    the actual parameters as follows.
  prefs: []
  type: TYPE_NORMAL
- en: If `*formals*` is a proper list of variables, e.g., `(x y z)`, each variable
    is bound to the corresponding actual parameter. An exception with condition type
    `&assertion` is raised if too few or too many actual parameters are supplied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `*formals*` is a single variable (not in a list), e.g., `z`, it is bound
    to a list of the actual parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `*formals*` is an improper list of variables terminated by a variable, e.g.,
    `(x y . z)`, each variable but the last is bound to the corresponding actual parameter.
    The last variable is bound to a list of the remaining actual parameters. An exception
    with condition type `&assertion` is raised if too few actual parameters are supplied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the body is evaluated, the expressions in the body are evaluated in sequence,
    and the procedure returns the values of the last expression.
  prefs: []
  type: TYPE_NORMAL
- en: Procedures do not have a printed representation in the usual sense. Scheme systems
    print procedures in different ways; this book uses the notation `#<procedure>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (x) (+ x 3)) ![<graphic>](ch2_0.gif) #<procedure>'
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x) (+ x 3)) 7) ![<graphic>](ch2_0.gif) 10
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x y) (* x (+ x y))) 7 13) ![<graphic>](ch2_0.gif) 140
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (f x) (f x x)) + 11) ![<graphic>](ch2_0.gif) 22
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda () (+ 3 4))) ![<graphic>](ch2_0.gif) 7
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x . y) (list x y))
  prefs: []
  type: TYPE_NORMAL
- en: 28 37) ![<graphic>](ch2_0.gif) (28 (37))
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x . y) (list x y))
  prefs: []
  type: TYPE_NORMAL
- en: 28 37 47 28) ![<graphic>](ch2_0.gif) (28 (37 47 28))
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x y . z) (list x y z))
  prefs: []
  type: TYPE_NORMAL
- en: 1 2 3 4) ![<graphic>](ch2_0.gif) (1 2 (3 4))
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda x x) 7 13) ![<graphic>](ch2_0.gif) (7 13)`
  prefs: []
  type: TYPE_NORMAL
- en: Section 4.3\. Case-Lambda
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Scheme `lambda` expression always produces a procedure with a fixed number
    of arguments or with an indefinite number of arguments greater than or equal to
    a certain number. In particular,
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (*var[1]* ... *var[n]*) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: accepts exactly `*n*` arguments,
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda *r* *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: accepts zero or more arguments, and
  prefs: []
  type: TYPE_NORMAL
- en: '`(lambda (*var[1]* ... *var[n]* . *r*) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: accepts `*n*` or more arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '`lambda` cannot directly produce, however, a procedure that accepts, say, either
    two or three arguments. In particular, procedures that accept optional arguments
    are not supported directly by `lambda`. The latter form of `lambda` shown above
    can be used, in conjunction with length checks and compositions of `car` and `cdr`,
    to implement procedures with optional arguments, though at the cost of clarity
    and efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: The `case-lambda` syntactic form directly supports procedures with optional
    arguments as well as procedures with fixed or indefinite numbers of arguments.
    `case-lambda` is based on the `lambda*` syntactic form introduced in the article
    "A New Approach to Procedures with Variable Arity" [[11](bibliography.html#g229)].
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(case-lambda *clause* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a procedure'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs control)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: A `case-lambda` expression consists of a set of clauses, each resembling a `lambda`
    expression. Each `*clause*` has the form below.
  prefs: []
  type: TYPE_NORMAL
- en: '`[*formals* *body[1]* *body[2]* ...]`'
  prefs: []
  type: TYPE_NORMAL
- en: The formal parameters of a clause are defined by `*formals*` in the same manner
    as for a `lambda` expression. The number of arguments accepted by the procedure
    value of a `case-lambda` expression is determined by the numbers of arguments
    accepted by the individual clauses.
  prefs: []
  type: TYPE_NORMAL
- en: When a procedure created with `case-lambda` is invoked, the clauses are considered
    in order. The first clause that accepts the given number of actual parameters
    is selected, the formal parameters defined by its `*formals*` are bound to the
    corresponding actual parameters, and the body is evaluated as described for `lambda`
    above. If `*formals*` in a clause is a proper list of identifiers, then the clause
    accepts exactly as many actual parameters as there are formal parameters (identifiers)
    in `*formals*`. As with a `lambda` `*formals*`, a `case-lambda` clause `*formals*`
    may be a single identifier, in which case the clause accepts any number of arguments,
    or an improper list of identifiers terminated by an identifier, in which case
    the clause accepts any number of arguments greater than or equal to the number
    of formal parameters excluding the terminating identifier. If no clause accepts
    the number of actual parameters supplied, an exception with condition type `&assertion`
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: The following definition for `make-list` uses `case-lambda` to support an optional
    fill parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define make-list'
  prefs: []
  type: TYPE_NORMAL
- en: (case-lambda
  prefs: []
  type: TYPE_NORMAL
- en: '[(n) (make-list n #f)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(n x)'
  prefs: []
  type: TYPE_NORMAL
- en: (do ([n n (- n 1)] [ls '() (cons x ls)])
  prefs: []
  type: TYPE_NORMAL
- en: ((zero? n) ls))]))`
  prefs: []
  type: TYPE_NORMAL
- en: 'The `substring` procedure may be extended with `case-lambda` to accept either
    no `*end*` index, in which case it defaults to the end of the string, or no `*start*`
    and `*end*` indices, in which case `substring` is equivalent to `string-copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define substring1'
  prefs: []
  type: TYPE_NORMAL
- en: (case-lambda
  prefs: []
  type: TYPE_NORMAL
- en: '[(s) (substring1 s 0 (string-length s))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(s start) (substring1 s start (string-length s))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(s start end) (substring s start end)]))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to default the `*start*` index rather than the `*end*`
    index when only one index is supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define substring2'
  prefs: []
  type: TYPE_NORMAL
- en: (case-lambda
  prefs: []
  type: TYPE_NORMAL
- en: '[(s) (substring2 s 0 (string-length s))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(s end) (substring2 s 0 end)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(s start end) (substring s start end)]))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even possible to require that both or neither of the `*start*` and `*end*`
    indices be supplied, simply by leaving out the middle clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define substring3'
  prefs: []
  type: TYPE_NORMAL
- en: (case-lambda
  prefs: []
  type: TYPE_NORMAL
- en: '[(s) (substring3 s 0 (string-length s))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[(s start end) (substring s start end)]))`'
  prefs: []
  type: TYPE_NORMAL
- en: Section 4.4\. Local Binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(let ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the final body expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let` establishes local variable bindings. Each variable `*var*` is bound to
    the value of the corresponding expression `*expr*`. The body of the `let`, in
    which the variables are bound, is the sequence of subforms `*body[1]* *body[2]* ...`
    and is processed and evaluated like a `lambda` body.'
  prefs: []
  type: TYPE_NORMAL
- en: The forms `let`, `let*`, `letrec`, and `letrec*` (the others are described after
    `let`) are similar but serve slightly different purposes. With `let`, in contrast
    with `let*`, `letrec`, and `letrec*`, the expressions `*expr* ...` are all outside
    the scope of the variables `*var* ...`. Also, in contrast with `let*` and `letrec*`,
    no ordering is implied for the evaluation of the expressions `*expr* ...`. They
    may be evaluated from left to right, from right to left, or in any other order
    at the discretion of the implementation. Use `let` whenever the values are independent
    of the variables and the order of evaluation is unimportant.
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ([x (* 3.0 3.0)] [y (* 4.0 4.0)])'
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt (+ x y))) ![<graphic>](ch2_0.gif) 5.0
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 'a] [y '(b c)])
  prefs: []
  type: TYPE_NORMAL
- en: (cons x y)) ![<graphic>](ch2_0.gif) (a b c)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 0] [y 1])
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x y] [y x])
  prefs: []
  type: TYPE_NORMAL
- en: (list x y))) ![<graphic>](ch2_0.gif) (1 0)`
  prefs: []
  type: TYPE_NORMAL
- en: The following definition of `let` shows the typical derivation of `let` from
    `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax let'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x e) ...) b1 b2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: ((lambda (x ...) b1 b2 ...) e ...)]))`
  prefs: []
  type: TYPE_NORMAL
- en: Another form of `let`, *named* `let`, is described in Section [5.4](control.html#g100),
    and a definition of the full `let` can be found on page [312](syntax.html#defn:let).
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(let* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the final body expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let*` is similar to `let` except that the expressions `*expr* ...` are evaluated
    in sequence from left to right, and each of these expressions is within the scope
    of the variables to the left. Use `let*` when there is a linear dependency among
    the values or when the order of evaluation is important.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let* ([x (* 5.0 5.0)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[y (- x (* 4.0 4.0))])'
  prefs: []
  type: TYPE_NORMAL
- en: (sqrt y)) ![<graphic>](ch2_0.gif) 3.0
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 0] [y 1])
  prefs: []
  type: TYPE_NORMAL
- en: (let* ([x y] [y x])
  prefs: []
  type: TYPE_NORMAL
- en: (list x y))) ![<graphic>](ch2_0.gif) (1 1)`
  prefs: []
  type: TYPE_NORMAL
- en: Any `let*` expression may be converted to a set of nested `let` expressions.
    The following definition of `let*` demonstrates the typical transformation.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax let*'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ () e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let () e1 e2 ...)]
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ((x1 v1))
  prefs: []
  type: TYPE_NORMAL
- en: (let* ((x2 v2) ...) e1 e2 ...))]))`
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the final body expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`letrec` is similar to `let` and `let*`, except that all of the expressions
    `*expr* ...` are within the scope of all of the variables `*var* ...`. `letrec`
    allows the definition of mutually recursive procedures.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ([sum (lambda (x)'
  prefs: []
  type: TYPE_NORMAL
- en: (if (zero? x)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (+ x (sum (- x 1)))))])
  prefs: []
  type: TYPE_NORMAL
- en: (sum 5)) ![<graphic>](ch2_0.gif) 15`
  prefs: []
  type: TYPE_NORMAL
- en: The order of evaluation of the expressions `*expr* ...` is unspecified, so a
    program must not evaluate a reference to any of the variables bound by the `letrec`
    expression before all of the values have been computed. (Occurrence of a variable
    within a `lambda` expression does not count as a reference, unless the resulting
    procedure is applied before all of the values have been computed.) If this restriction
    is violated, an exception with condition type `&assertion` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: An `*expr*` should not return more than once. That is, it should not return
    both normally and via the invocation of a continuation obtained during its evaluation,
    and it should not return twice via two invocations of such a continuation. Implementations
    are not required to detect a violation of this restriction, but if they do, an
    exception with condition type `&assertion` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Choose `letrec` over `let` or `let*` when there is a circular dependency among
    the variables and their values and when the order of evaluation is unimportant.
    Choose `letrec*` over `letrec` when there is a circular dependency and the bindings
    need to be evaluated from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: A `letrec` expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: may be expressed in terms of `let` and `set!` as
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ((*var* #f) ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (let ((*temp* *expr*) ...)
  prefs: []
  type: TYPE_NORMAL
- en: (set! *var* *temp*) ...
  prefs: []
  type: TYPE_NORMAL
- en: (let () *body[1]* *body[2]* ...)))`
  prefs: []
  type: TYPE_NORMAL
- en: where `*temp* ...` are fresh variables, i.e., ones that do not already appear
    in the `letrec` expression, one for each `(*var* *expr*)` pair. The outer `let`
    expression establishes the variable bindings. The initial value given each variable
    is unimportant, so any value suffices in place of `#f`. The bindings are established
    first so that `*expr* ...` may contain occurrences of the variables, i.e., so
    that the expressions are computed within the scope of the variables. The middle
    `let` evaluates the values and binds them to the temporary variables, and the
    `set!` expressions assign each variable to the corresponding value. The inner
    `let` is present in case the body contains internal definitions.
  prefs: []
  type: TYPE_NORMAL
- en: A definition of `letrec` that uses this transformation is shown on page [310](syntax.html#defn:letrec).
  prefs: []
  type: TYPE_NORMAL
- en: This transformation does not enforce the restriction that the `*expr*` expressions
    must not evaluate any references of or assignments to the variables. More elaborate
    transformations that enforce this restriction and actually produce more efficient
    code are possible [[31](bibliography.html#g249)].
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(letrec* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the final body expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`letrec*` is similar to `letrec`, except that `letrec*` evaluates `*expr* ...`
    in sequence from left to right. While programs must still not evaluate a reference
    to any `*var*` before the corresponding `*expr*` has been evaluated, references
    to `*var*` may be evaluated any time thereafter, including during the evaluation
    of the `*expr*` of any subsequent binding.'
  prefs: []
  type: TYPE_NORMAL
- en: A `letrec*` expression of the form
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec* ((*var* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: may be expressed in terms of `let` and `set!` as
  prefs: []
  type: TYPE_NORMAL
- en: '`(let ((*var* #f) ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (set! *var* *expr*) ...
  prefs: []
  type: TYPE_NORMAL
- en: (let () *body[1]* *body[2]* ...))`
  prefs: []
  type: TYPE_NORMAL
- en: The outer `let` expression creates the bindings, each assignment evaluates an
    expression and immediately sets the corresponding variable to its value, in sequence,
    and the inner let evaluates the body. `let` is used in the latter case rather
    than `begin` since the body may include internal definitions as well as expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`(letrec* ([sum (lambda (x)'
  prefs: []
  type: TYPE_NORMAL
- en: (if (zero? x)
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: (+ x (sum (- x 1)))))]
  prefs: []
  type: TYPE_NORMAL
- en: '[f (lambda () (cons n n-sum))]'
  prefs: []
  type: TYPE_NORMAL
- en: '[n 15]'
  prefs: []
  type: TYPE_NORMAL
- en: '[n-sum (sum n)])'
  prefs: []
  type: TYPE_NORMAL
- en: (f)) ![<graphic>](ch2_0.gif) (15 . 120)
  prefs: []
  type: TYPE_NORMAL
- en: (letrec* ([f (lambda () (lambda () g))]
  prefs: []
  type: TYPE_NORMAL
- en: '[g (f)])'
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (g) g)) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (letrec* ([g (f)]
  prefs: []
  type: TYPE_NORMAL
- en: '[f (lambda () (lambda () g))])'
  prefs: []
  type: TYPE_NORMAL
- en: (eq? (g) g)) ![<graphic>](ch2_0.gif) *exception: attempt to reference undefined variable f*`
  prefs: []
  type: TYPE_NORMAL
- en: Section 4.5\. Multiple Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(let-values ((*formals* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(let*-values ((*formals* *expr*) ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the values of the final body expression'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`let-values` is a convenient way to receive multiple values and bind them to
    variables. It is structured like `let` but permits an arbitrary formals list (like
    `lambda`) on each left-hand side. `let*-values` is similar but performs the bindings
    in left-to-right order, as with `let*`. An exception with condition type `&assertion`
    is raised if the number of values returned by an `*expr*` is not appropriate for
    the corresponding `*formals*`, as described in the entry for `lambda` above. A
    definition of `let-values` is given on page [310](syntax.html#fullletvalues).'
  prefs: []
  type: TYPE_NORMAL
- en: '`(let-values ([(a b) (values 1 2)] [c (values 1 2 3)])'
  prefs: []
  type: TYPE_NORMAL
- en: (list a b c)) ![<graphic>](ch2_0.gif) (1 2 (1 2 3))
  prefs: []
  type: TYPE_NORMAL
- en: (let*-values ([(a b) (values 1 2)] [(a b) (values b a)])
  prefs: []
  type: TYPE_NORMAL
- en: (list a b)) ![<graphic>](ch2_0.gif) (2 1)`
  prefs: []
  type: TYPE_NORMAL
- en: Section 4.6\. Variable Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(define *var* *expr*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(define *var*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(define (*var[0]* *var[1]* ...) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(define (*var[0]* . *var[r]*) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax**: `(define (*var[0]* *var[1]* *var[2]* ... . *var[r]*) *body[1]* *body[2]* ...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: In the first form, `define` creates a new binding of `*var*` to the value of
    `*expr*`. The `*expr*` should not return more than once. That is, it should not
    return both normally and via the invocation of a continuation obtained during
    its evaluation, and it should not return twice via two invocations of such a continuation.
    Implementations are not required to detect a violation of this restriction, but
    if they do, an exception with condition type `&assertion` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: The second form is equivalent to `(define *var* *unspecified*)`, where `*unspecified*`
    is some unspecified value. The remaining are shorthand forms for binding variables
    to procedures; they are identical to the following definition in terms of `lambda`.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define *var*'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda *formals*
  prefs: []
  type: TYPE_NORMAL
- en: '*body[1]* *body[2]* ...))`'
  prefs: []
  type: TYPE_NORMAL
- en: where `*formals*` is `(*var[1]* ...)`, `*var[r]*`, or `(*var[1]* *var[2]* ... . *var[r]*)`
    for the third, fourth, and fifth `define` formats.
  prefs: []
  type: TYPE_NORMAL
- en: Definitions may appear at the front of a `library` body, anywhere among the
    forms of a top-level-program body, and at the front of a `lambda` or `case-lambda`
    body or the body of any form derived from `lambda`, e.g., `let`, or `letrec*`.
    Any body that begins with a sequence of definitions is transformed during macro
    expansion into a `letrec*` expression as described on page [292](syntax.html#body-expansion).
  prefs: []
  type: TYPE_NORMAL
- en: Syntax definitions may appear along with variable definitions wherever variable
    definitions may appear; see Chapter [8](syntax.html#g133).
  prefs: []
  type: TYPE_NORMAL
- en: '`(define x 3)'
  prefs: []
  type: TYPE_NORMAL
- en: x ![<graphic>](ch2_0.gif) 3
  prefs: []
  type: TYPE_NORMAL
- en: (define f
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  prefs: []
  type: TYPE_NORMAL
- en: (* (+ x y) 2)))
  prefs: []
  type: TYPE_NORMAL
- en: (f 5 4) ![<graphic>](ch2_0.gif) 18
  prefs: []
  type: TYPE_NORMAL
- en: (define (sum-of-squares x y)
  prefs: []
  type: TYPE_NORMAL
- en: (+ (* x x) (* y y)))
  prefs: []
  type: TYPE_NORMAL
- en: (sum-of-squares 3 4) ![<graphic>](ch2_0.gif) 25
  prefs: []
  type: TYPE_NORMAL
- en: (define f
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (+ x 1)))
  prefs: []
  type: TYPE_NORMAL
- en: (let ([x 2])
  prefs: []
  type: TYPE_NORMAL
- en: (define f
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (y)
  prefs: []
  type: TYPE_NORMAL
- en: (+ y x)))
  prefs: []
  type: TYPE_NORMAL
- en: (f 3)) ![<graphic>](ch2_0.gif) 5
  prefs: []
  type: TYPE_NORMAL
- en: (f 3) ![<graphic>](ch2_0.gif) 4`
  prefs: []
  type: TYPE_NORMAL
- en: A set of definitions may be grouped by enclosing them in a `begin` form. Definitions
    grouped in this manner may appear wherever ordinary variable and syntax definitions
    may appear. They are treated as if written separately, i.e., without the enclosing
    `begin` form. This feature allows syntactic extensions to expand into groups of
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-syntax multi-define-syntax'
  prefs: []
  type: TYPE_NORMAL
- en: (syntax-rules ()
  prefs: []
  type: TYPE_NORMAL
- en: '[(_ (var expr) ...)'
  prefs: []
  type: TYPE_NORMAL
- en: (begin
  prefs: []
  type: TYPE_NORMAL
- en: (define-syntax var expr)
  prefs: []
  type: TYPE_NORMAL
- en: '...)]))'
  prefs: []
  type: TYPE_NORMAL
- en: (let ()
  prefs: []
  type: TYPE_NORMAL
- en: (define plus
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x y)
  prefs: []
  type: TYPE_NORMAL
- en: (if (zero? x)
  prefs: []
  type: TYPE_NORMAL
- en: y
  prefs: []
  type: TYPE_NORMAL
- en: (plus (sub1 x) (add1 y)))))
  prefs: []
  type: TYPE_NORMAL
- en: (multi-define-syntax
  prefs: []
  type: TYPE_NORMAL
- en: (add1 (syntax-rules () [(_ e) (+ e 1)]))
  prefs: []
  type: TYPE_NORMAL
- en: (sub1 (syntax-rules () [(_ e) (- e 1)])))
  prefs: []
  type: TYPE_NORMAL
- en: (plus 7 8)) ![<graphic>](ch2_0.gif) 15`
  prefs: []
  type: TYPE_NORMAL
- en: Many implementations support an interactive "top level" in which variable and
    other definitions may be entered interactively or loaded from files. The behavior
    of these top-level definitions is outside the scope of the Revised⁶ Report, but
    as long as top-level variables are defined before any references or assignments
    to them are evaluated, the behavior is consistent across most implementations.
    So, for example, the reference to `g` in the top-level definition of `f` below
    is okay if `*g*` is not already defined, and `g` is assumed to name a variable
    to be defined at some later point.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define f'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (g x)))`
  prefs: []
  type: TYPE_NORMAL
- en: If this is then followed by a definition of `g` before `f` is evaluated, the
    assumption that `g` would be defined as a variable is proven correct, and a call
    to `f` works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define g'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (+ x x)))
  prefs: []
  type: TYPE_NORMAL
- en: (f 3) ![<graphic>](ch2_0.gif) 6`
  prefs: []
  type: TYPE_NORMAL
- en: If `g` were defined instead as the keyword for a syntactic extension, the assumption
    that `g` would be bound as a variable is proven false, and if `f` is not redefined
    before it is invoked, the implementation is likely to raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Section 4.7\. Assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**syntax**: `(set! *var* *expr*)`'
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** unspecified'
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs base)`, `(rnrs)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`set!` does not establish a new binding for `*var*` but rather alters the value
    of an existing binding. It first evaluates `*expr*`, then assigns `*var*` to the
    value of `*expr*`. Any subsequent reference to `*var*` within the scope of the
    altered binding evaluates to the new value.'
  prefs: []
  type: TYPE_NORMAL
- en: Assignments are not employed as frequently in Scheme as in most other languages,
    but they are useful for implementing state changes.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define flip-flop'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([state #f])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda ()
  prefs: []
  type: TYPE_NORMAL
- en: (set! state (not state))
  prefs: []
  type: TYPE_NORMAL
- en: state)))
  prefs: []
  type: TYPE_NORMAL
- en: (flip-flop) ![<graphic>](ch2_0.gif) #t
  prefs: []
  type: TYPE_NORMAL
- en: (flip-flop) ![<graphic>](ch2_0.gif) #f
  prefs: []
  type: TYPE_NORMAL
- en: (flip-flop) ![<graphic>](ch2_0.gif) #t`
  prefs: []
  type: TYPE_NORMAL
- en: Assignments are also useful for caching values. The example below uses a technique
    called *memoization*, in which a procedure records the values associated with
    old input values so it need not recompute them, to implement a fast version of
    the otherwise exponential doubly recursive definition of the Fibonacci function
    (see page [69](further.html#fibonacci)).
  prefs: []
  type: TYPE_NORMAL
- en: '`(define memoize'
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (proc)
  prefs: []
  type: TYPE_NORMAL
- en: (let ([cache '()])
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  prefs: []
  type: TYPE_NORMAL
- en: (cond
  prefs: []
  type: TYPE_NORMAL
- en: '[(assq x cache) => cdr]'
  prefs: []
  type: TYPE_NORMAL
- en: '[else'
  prefs: []
  type: TYPE_NORMAL
- en: (let ([ans (proc x)])
  prefs: []
  type: TYPE_NORMAL
- en: (set! cache (cons (cons x ans) cache))
  prefs: []
  type: TYPE_NORMAL
- en: ans)])))))
  prefs: []
  type: TYPE_NORMAL
- en: (define fibonacci
  prefs: []
  type: TYPE_NORMAL
- en: (memoize
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (n)
  prefs: []
  type: TYPE_NORMAL
- en: (if (< n 2)
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))
  prefs: []
  type: TYPE_NORMAL
- en: (fibonacci 100) ![<graphic>](ch2_0.gif) 573147844013817084101`
  prefs: []
  type: TYPE_NORMAL
