- en: 'Recitation 3: Higher-order Functions, Anonymous Functions, Currying, Side effects,
    Printing and Exceptions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recitation covers:'
  prefs: []
  type: TYPE_NORMAL
- en: higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: side-effects and printing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are values just like any other value in OCaml. What does that mean
    exactly? This means that we can pass functions around as arguments to other functions,
    that we can store functions in data structures, that we can return functions as
    a result from other functions. The full implication of this will not hit you until
    later, but believe us, it will.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at why it is useful to have higher-order functions. The first reason
    is that it allows you to write more general code, hence more reusable code. As
    a running example, consider functions *double* and *square* on integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now come up with a function to quadruple a number. We could do it directly,
    but for utterly twisted motives decide to use the function *double* above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Straightforward enough. What about a function to raise an integer to the fourth
    power?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an obvious similarity between these two functions: what they do is
    apply a given function twice to a value. By passing in the function to another
    function `twice` as an argument, we can abstract this functionality and thus reuse
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have exploited the similarity between these two functions to save work. 
    This can be very helpful.  If someone comes up with an improved (or corrected)
    version of `twice`, then every function that uses it profits from the improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `twice` is a so-called *higher-order function*: it is a function
    from functions to other values. Notice the type of `twice` is `((int -> int) *
    int) -> int`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid polluting the top-level namespace, it can be useful to define the
    function locally to pass in as an argument. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For clarity in the evaluation example we''re about to do next, let''s rewrite
    that using an alternative syntax for functions that we saw last week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens when we evaluate an expression that uses a higher-order function?
    We use the same rules as earlier: when a function is applied (called), we replace
    the call with the body of the function, with the argument variables (actually,
    variables appearing in the argument pattern) bound to the corresponding actual
    values. For example, `fourth 3` evaluates as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The "alternative syntax" we just used for functions turns out to be even more
    broadly useful. You might notice that it seems silly to define and name a function
    simply to pass it in as an argument to another function. After all, all we really
    care about is that `twice` gets a function that doubles its argument.  Fortunately,
    OCaml provides a better solution — anonymous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We introduce a new expression denoting "a function that expects an argument
    of a certain type and returns the value of a certain expression":'
  prefs: []
  type: TYPE_NORMAL
- en: '*e* ::= ...  |  `fun` `(`*x* : *t*`) ->` *e*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fun` expression creates an **anonymous function**: a function without
    a name. The argument type can be omitted; OCaml will infer it. The return type
    of an anonymous function is not declared and is inferred automatically. What is
    the type of `fun (y : int) -> y = 3` ?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer:** `int -> bool`'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: has the same effect as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In fact, the declaration without `fun` is just **syntactic sugar** for the more
    tedious long definition. (This isn't true for recursive functions, however.)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anonymous functions are useful for creating functions to pass as arguments
    to other functions, but are also useful for writing functions that return other
    functions. Let us rewrite the `twice` function to take a function as an argument
    and return a new function that applies the original function twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes a function `f` (of type `int -> int`) as an argument, and
    returns the value `fun (x : int) -> f (f x)`, which is a function which when applied
    to an argument applies `f` twice to that argument. Thus, we can write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: and trying to evaluate `fourth 3` does indeed result in `81`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions that return other functions are so common in functional programming
    that OCaml provides a special syntax for them.  For example, we could write the
    twice function above as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The "second argument" `x` here is not an argument to `twice`, but rather an
    argument to `twice f`.  The function `twice` takes only one argument, namely a
    function `f`, and returns *another* function that takes an argument `x` and returns
    an `int`.  The distinction here is critical.
  prefs: []
  type: TYPE_NORMAL
- en: This device is called *currying* after the logician H. B. Curry. At this point
    you may be worried about the efficiency of returning an intermediate function
    when you're just going to pass all the arguments at once anyway. Run a test if
    you want (you should find out how to do this), but rest assured that curried functions
    are entirely normal in functional languages, so there is no speed penalty worth
    worrying about.
  prefs: []
  type: TYPE_NORMAL
- en: The type of twice is `(int -> int) -> int -> int`.  The `->` operator is right
    associative, so this is equivalent to `(int -> int) -> (int -> int)`.  Notice
    that if we had left out the parentheses on the type of `f`, we would no longer
    long have a function that took in another function as an argument, since `int
    -> int -> int -> int` is equivalent to `int -> (int -> (int -> int))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are more examples of useful higher-order functions that we will leave
    you to ponder (and try out at home):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until now, we have only shown you pure functional programming.  But in certain
    cases, imperative programming is unavoidable.  One such case is printing a value
    to the screen.  By now you may have found it difficult to debug your OCaml code
    without any way to display intermediate values on the screen.  OCaml provides
    the function `print_string : string -> unit` to print a string to the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Printing to the screen is called a *side-effect* because it alters the state
    of the computer.  Until now we have been writing functions that do not change
    any state but merely compute some value.  Later on we will show you more examples
    of side-effects, but printing will suffice for now.
  prefs: []
  type: TYPE_NORMAL
- en: Because of OCaml's type system, `print_string` is not overloaded like Java's
    `System.out.println`.  To print an `int`, `float`, `bool`, etc, you must first
    convert it to a string.  Fortunately, there are built-in functions to do this
    conversion. For example, `string_of_int` converts an `int` to a `string`.  So
    to print 3, we can write `print_string (string_of_int 3)`.  The parentheses are
    needed here bacause OCaml evaluates expressions left to right.
  prefs: []
  type: TYPE_NORMAL
- en: So how can you put print statements in your code?  There are two ways.  The
    first is with a `let` expression. These can be placed inside other `let` expressions,
    allowing you to print intermediate values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There is a second way as well.  For this we introduce new syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '*e* ::= ...  |  `(`*e*[1]`;` ... `;`*e[n]* `)`'
  prefs: []
  type: TYPE_NORMAL
- en: This expression tells OCaml to evaluate expressions *e*[1],...,*e[n]* in order
    and return the result of evaluating *e[n]*.  So we could write our example as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To handle errors, OCaml provides built in exceptions, much like Java.  To declare
    an exception named `Error`, you write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then to throw the exception, we use the `raise` keyword.  An example using the
    square root function is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The type of an exception matches the code in which the exception is thrown. 
    So for example, in the `sqrt1` function, the type of `Error` will be `float` since
    the expression must evaluate to a real.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions can also carry values.  An example is the built-in exception `Failure`,
    defined as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To raise this exception, we write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can also catch exceptions by use of the `try-with` keywords.  It is important
    not to abuse this capability.  Excessive use of exceptions can lead to unreadable
    spaghetti code.  For this class, it will probably never be necessary to handle
    an exception.  Exceptions should only be raised in truly exceptional cases, that
    is, when some unrecoverable damage has been done.  If you can avoid an exception
    by checking bounds or using options, this is far preferable.  Refer to the OCaml
    style guide for more examples and info on how to use exceptions properly.
  prefs: []
  type: TYPE_NORMAL
