["```\ntype alias Click = (Time.Time, (Int,Int))\ntype alias State = List Click \n```", "```\ninitState = []\nupstate   = (::) \n```", "```\nview (w,h) clicks =\n  let str = case clicks of\n              []   -> T.asText \"No clicks yet\"\n              p::_ -> T.asText p\n  in\n    C.collage w h [C.toForm str] \n```", "```\ntime : Signal Time.Time\ntime = Signal.foldp (+) 0 (Time.fps 10) \n```", "```\nclicks : Signal Click\nclicks =\n  let onClick = Signal.sampleOn Mouse.clicks in\n  (,) <~ onClick time ~ onClick Mouse.position \n```", "```\nstate : Signal State\nstate = Signal.foldp upstate initState clicks\n\nmain =\n  view <~ Window.dimensions ~ state \n```", "```\ntimestamp : Signal a -> Signal (Time.Time, a)\ntimestamp sig =\n  (,) <~ Signal.sampleOn sig time ~ sig\n\nclicks : Signal Click\nclicks = timestamp (Signal.sampleOn Mouse.clicks Mouse.position) \n```", "```\nview (w,h) clicks =\n\n  let str     = case clicks of\n                  []   -> T.asText \"No clicks yet\"\n                  p::_ -> T.asText p\n      circ    = C.filled Color.darkBlue (C.circle 20)\n      (fw,fh) = (toFloat w, toFloat h)\n      (dx,dy) = (-fw/2, fh/2)\n      dots =\n        clicks |> List.map (\\(_,(x,y)) ->\n          circ |> C.move (toFloat x + dx, toFloat (-y) + dy))\n  in\n\n    C.collage w h (dots ++ [C.toForm str]) \n```", "```\ntype alias State = (Time.Time, List Click)\n\ninitState = (0, []) \n```", "```\nupstate (t,xy) (_,clicks) = (t, (t,xy)::clicks) \n```", "```\nview (w,h) (now,clicks) =\n\n  let str     = case clicks of {[] -> T.asText \"...\"; p::_ -> T.asText p}\n      circ    = C.filled Color.darkBlue (C.circle 20)\n      (fw,fh) = (toFloat w, toFloat h)\n      (dx,dy) = (-fw/2, fh/2)\n      tfade   = 2 * Time.second\n      dots =\n        clicks |> List.concatMap (\\(t,(x,y)) -> if\n          | (now-t) > tfade -> []\n          | otherwise ->\n              [circ |> C.move (toFloat x + dx, toFloat (-y) + dy)]\n        )\n  in\n\n    C.collage w h (dots ++ [C.toForm str]) \n```", "```\nSignal.merge : Signal a -> Signal a -> Signal a \n```", "```\ntype Update = NewTime Time.Time | NewClick Click\n\nupstate u (_,clicks) = case u of\n  NewTime t       -> (t, clicks)\n  NewClick (t,xy) -> (t, (t,xy)::clicks) \n```", "```\npruneOld now clicks = case clicks of\n  [] -> []\n  (t,xy) :: clicks' -> if\n    | (now-t) > tfade -> []\n    | otherwise       -> (t,xy) :: pruneOld now clicks'\n\nupstate u (_,clicks) = case u of\n  NewTime t       -> (t, pruneOld t clicks)\n  NewClick (t,xy) -> (t, (t,xy) :: pruneOld t clicks) \n```", "```\nstate = Signal.foldp upstate initState\n          (Signal.merge (NewTime  <~ time)\n                        (NewClick <~ clicks)) \n```", "```\nsetAlpha : Float -> Color.Color -> Color.Color\nsetAlpha a c =\n  let rgb = Color.toRgb c in\n  Color.rgba rgb.red rgb.green rgb.blue a\n\nview (w,h) (now,clicks) =\n\n  let\n      (fw,fh) = (toFloat w, toFloat h)\n      (dx,dy) = (-fw/2, fh/2)\n      color a = setAlpha a Color.darkBlue\n      rad pct = 20 + 100 * pct\n      circ pct = C.filled (color (1-pct)) (C.circle (rad pct))\n      dots =\n        clicks |> List.map (\\(t,(x,y)) ->\n          let pct = (now-t) / tfade in\n          circ pct |> C.move (toFloat x + dx, toFloat (-y) + dy))\n  in\n\n    C.collage w h dots \n```", "```\ntime = Signal.foldp (+) 0 (Time.fps 40) \n```"]