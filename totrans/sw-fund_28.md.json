["```\n\n    The has_type relation of the STLC defines what it means for a\n    term to belong to a type (in some context).  But it doesn't, by\n    itself, tell us how to *check* whether or not a term is well\n    typed.\n\n    Fortunately, the rules defining has_type are *syntax directed*\n    \u2014 that is, for every syntactic form of the language, there is\n    just one rule that can be used to give a type to terms of that\n    form.  This makes it straightforward to translate the typing rules\n    into clauses of a typechecking *function* that takes a term and a\n    context and either returns the term's type or else signals that\n    the term is not typable.\n\n```", "```\n\n# Comparing Types\n\n    First, we need a function to compare two types for equality...\n\n```", "```\n\n    ... and we need to establish the usual two-way connection between\n    the boolean result returned by beq_ty and the logical\n    proposition that its inputs are equal.\n\n```", "```\n\n# The Typechecker\n\n    The typechecker works by walking over the structure of the given\n    term, returning either Some T or None.  Each time we make a\n    recursive call to find out the types of the subterms, we need to\n    pattern-match on the results to make sure that they are not\n    None.  Also, in the tapp case, we use pattern matching to\n    extract the left- and right-hand sides of the function's arrow\n    type (and fail if the type of the function is not TArrow T[11] T[12]\n    for some T[1] and T[2]).\n\n```", "```\n\n# Properties\n\n    To verify that this typechecking algorithm is correct, we show\n    that it is *sound* and *complete* for the original has_type\n    relation \u2014 that is, type_check and has_type define the same\n    partial function.\n\n```", "```\n\n# Exercises\n\n#### Exercise: 5 stars (typechecker_extensions)\n\n    In this exercise we'll extend the typechecker to deal with the\n    extended features discussed in chapter [MoreStlc](MoreStlc.html).  Your job\n    is to fill in the omitted cases in the following.\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 5 stars, optional (stlc_step_function)\n\n    Above, we showed how to write a typechecking function and prove it\n    sound and complete for the typing relation.  Do the same for the\n    operational semantics \u2014 i.e., write a function stepf of type\n    tm \u2192 option tm and prove that it is sound and complete with\n    respect to step from chapter [MoreStlc](MoreStlc.html).\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 5 stars, optional (stlc_impl)\n\n    Using the Imp parser described in the [ImpParser](ImpParser.html) chapter as\n    a guide, build a parser for extended Stlc programs.  Combine it\n    with the typechecking and stepping functions from above to yield a\n    complete typechecker and interpreter for this language.\n\n```", "```\n\n    \u2610 \n\n```"]