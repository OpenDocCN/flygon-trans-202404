- en: Homework 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type the following command at the terminal to copy the template file to the
    current directory (note the period at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Or you can download the template [here](http://inst.eecs.berkeley.edu/~cs61as/templates/hw3.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: Autograder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working on the lab computers, the `grader` command will run the autograder.
    If you are working on your own personal machine, you should download [grader.rkt](http://inst.eecs.berkeley.edu/~cs61as/autograder/grader.rkt)
    and the [HW 3 tests](http://inst.eecs.berkeley.edu/~cs61as/autograder/tests/hw3-tests.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Invariant for Fast Exponentiation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the `fast-expt` procedure from earlier in this lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Design a procedure that evolves an iterative exponentiation process that uses
    successive squaring and uses a logarithmic number of steps, as does `fast-expt`.
  prefs: []
  type: TYPE_NORMAL
- en: '(Hint: Using the observation that (*b*^(*n*/2))² = (*b*²)^(*n*/2), keep, along
    with the exponent *n* and the base *b*, an additional state variable *a*, and
    define the state transformation in such a way that the product *a b^n* is unchanged
    from state to state. At the beginning of the process *a* is taken to be 1, and
    the answer is given by the value of *a* at the end of the process. In general,
    the technique of defining an invariant quantity that remains unchanged from state
    to state is a powerful way to think about the design of iterative algorithms.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Golden Ratio (Optional)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Read the subsection on [finding fixed points of functions](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_Temp_106)
    in SICP, and do [Exercise 1.35](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%25_thm_1.35).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: `cont-frac`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Part 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An infinite *continued* fraction is an expression of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax]f=\frac{N_1}{D_1+\frac{N_2}{D_2+\frac{N_3}{D_3+\cdots}}}[/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, one can show that
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax]\frac{1}{\phi}=\frac{1}{1+\frac{1}{1+\frac{1}{1+\cdots}}}[/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: 'where [mathjaxinline]\phi=\frac{1+\sqrt{5}}{2}[/mathjaxinline] is the golden
    ratio. One way to approximate an infinite continued fraction is to truncate the
    expansion after a given number of terms. Such a truncation—a so-called *[mathjaxinline]k[/mathjaxinline]-term
    finite continued fraction*—has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax]\frac{N_1}{D_1+\frac{N_2}{\ddots+\frac{N_k}{D_k}}}[/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that `n` and `d` are procedures of one argument (the term index [mathjaxinline]i[/mathjaxinline])
    that return the [mathjaxinline]N[/mathjaxinline] and [mathjaxinline]D[/mathjaxinline]
    of the [mathjaxinline]i[/mathjaxinline]-th term of the continued fraction. Define
    a procedure `cont-frac` such that evaluating `(cont-frac n d k)` computes the
    value of the [mathjaxinline]k[/mathjaxinline]-term finite continued fraction.
    Check your procedure by approximating [mathjaxinline]\frac{1}{\phi}[/mathjaxinline]
    using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: for successive values of `k`. How large must you make `k` in order to get an
    approximation that is accurate to 4 decimal places?
  prefs: []
  type: TYPE_NORMAL
- en: Part 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your `cont-frac` procedure generates a recursive process, write one that
    generates an iterative process. If it generates an iterative process, write one
    that generates a recursive process.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1737, Swiss mathematician Leonhard Euler showed that
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax] e - 2=\frac{N_1}{D_1+\frac{N_2}{D_2+\frac{N_3}{D_3+\cdots}}} [/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: for the parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[mathjax] \begin{cases} N_i = 1\\ D_i = 1,2,1,1,4,1,1,6,1,1,8,\cdots \end{cases}
    [/mathjax]'
  prefs: []
  type: TYPE_NORMAL
- en: where [mathjaxinline]e[/mathjaxinline] is the base of natural logarithms. Write
    a program that uses your `cont-frac` procedure to approximate [mathjaxinline]e[/mathjaxinline]
    using Euler's expansion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: `next-perf`'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *perfect number* is defined as a number equal to the sum of all its factors
    less than itself. For example, the first perfect number is 6, because its factors
    are 1, 2, 3, and 6, and 1+2+3=6\. The second perfect number is 28, because 1+2+4+7+14=28\.
    What is the third perfect number?
  prefs: []
  type: TYPE_NORMAL
- en: Write a procedure `(next-perf n)` that tests consecutive integers starting with
    `n` until a perfect number is found. Then you can evaluate `(next-perf 29)` to
    solve the problem. Note that your procedure should be able to handle any non-negative
    integer input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: you’ll need a `sum-of-factors` subprocedure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: If you run this program when the system is heavily loaded, it may take
    half an hour to compute the answer! Try tracing helper procedures to make sure
    your program is on track, or start by computing `(next-perf 1)` and see if you
    get 6.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Interchanging Base Cases'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the definition of `count-change` program from earlier in this lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (define (cc amount kinds-of-coins) (cond [(= amount 0) 1] [(or (< amount 0)
    (empty? kinds-of-coins)) 0] [else (+ (cc amount (bf kinds-of-coins)) (cc (- amount
    (first kinds-of-coins)) kinds-of-coins))] ))
  prefs: []
  type: TYPE_NORMAL
- en: Explain the effect of interchanging the order in which the base cases in the
    `cc` procedure are checked.
  prefs: []
  type: TYPE_NORMAL
- en: That is, describe completely the set of arguments for which the original `cc`
    procedure would return a different value or behave differently from a `cc` procedure
    coded as given below, and explain how the returned values would differ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 6: Invariant for Exponentiation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the iterative exponentiation procedure from earlier in this lesson:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Give an algebraic formula relating the values of the parameters `b`, `n`, `counter`,
    and `product` of the iterative exponentiation procedure defined above.
  prefs: []
  type: TYPE_NORMAL
- en: (The kind of answer we're looking for is "the sum of `b`, `n`, and `counter`
    times `product` is always equal to 37.")
  prefs: []
  type: TYPE_NORMAL
- en: Submit Your Homework!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For instructions, see [this guide](../submit.html). It covers basic terminal
    commands and assignment submission.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any trouble submitting, do not hesitate to ask a TA!
  prefs: []
  type: TYPE_NORMAL
