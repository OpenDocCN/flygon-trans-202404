["```\nfn main() {\n    println!(\"Hello, world!\");\n} \n```", "```\nfn main() {\n    println!(\"{}, {}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{0}, {1}!\", \"Hello\", \"world\"); // Hello, world!\n    println!(\"{greeting}, {name}!\", greeting=\"Hello\", name=\"world\"); // Hello, world!\n\n    println!(\"{:?}\", [1,2,3]); // [1, 2, 3]\n    println!(\"{:#?}\", [1,2,3]);\n    /*\n        [\n            1,\n            2,\n            3\n        ]\n    */\n\n    // \ud83d\udd0e format! macro is used to store the formatted STRING\n    let x = format!(\"{}, {}!\", \"Hello\", \"world\");\n    println!(\"{}\", x); // Hello, world!\n} \n```", "```\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs \n```", "```\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 lib.rs \n```", "```\n.\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 benches\n\u2502   \u2514\u2500\u2500 large-input.rs\n\u251c\u2500\u2500 examples\n\u2502   \u2514\u2500\u2500 simple.rs\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 bin\n\u2502   \u2502   \u2514\u2500\u2500 another_executable.rs\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u2514\u2500\u2500 main.rs\n\u2514\u2500\u2500 tests\n    \u2514\u2500\u2500 some-integration-tests.rs \n```", "```\n// Line comments\n/* Block comments */ \n```", "```\n/// Line comments; document the next item\n/** Block comments; document the next item */\n\n//! Line comments; document the enclosing item\n/*! Block comments; document the enclosing item !*/ \n```", "```\n/// This module contains tests\nmod test {\n    // ...\n}\n\nmod test {\n    //! This module contains tests\n\n    // ...\n} \n```", "```\n/// Foo\n#[doc=\"Foo\"]\n\n//! Foo\n#![doc=\"Foo\"] \n```", "```\nlet a = true;\nlet b: bool = true;\n\nlet (x, y) = (1, 2);\n\nlet mut z = 5;\nz = 6; \n```", "```\nconst N: i32 = 5; \n```", "```\nstatic N: i32 = 5; \n```", "```\n//Hello world function\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n//Function with arguments \nfn print_sum(a: i8, b: i8) {\n    println!(\"sum is: {}\", a + b);\n}\n\n//Returning\nfn plus_one(a: i32) -> i32 {\n    a + 1 //no ; means an expression, return a+1\n}\n\nfn plus_two(a: i32) -> i32 {\n    return a + 2; //return a+2 but bad practice, \n    //should use only on conditional returnes, except it's last expression \n}\n\n// \u2b50\ufe0f Function pointers, Usage as a Data Type\nlet b = plus_one;\nlet c = b(5); //6\n\nlet b: fn(i32) -> i32 = plus_one; //same, with type inference\nlet c = b(5); //6 \n```", "```\nlet x = true;\nlet y: bool = false;\n\n// \u2b50\ufe0f no TRUE, FALSE, 1, 0 \n```", "```\nlet x = 'x';\nlet y = '\ud83d\ude0e';\n\n// \u2b50\ufe0f no \"x\", only single quotes\n//because of Unicode support, char is not a single byte, but four. \n```", "```\nlet a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3\nlet mut b = [1, 2, 3];\n\nlet c: [int; 3] = [1, 2, 3]; //[Type; NO of elements]\n\nlet d: [\"my value\"; 3]; //[\"my value\", \"my value\", \"my value\"];\n\nlet e: [i32; 0] = []; //empty array\n\nprintln!(\"{:?}\", a); //[1, 2, 3]\nprintln!(\"{:#?}\", a);\n//  [\n//      1,\n//      2,\n//      3\n//  ] \n```", "```\nlet a = (1, 1.5, true, 'a', \"Hello, world!\");\n// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = \"Hello, world!\"\n\nlet b: (i32, f64) = (1, 1.5);\n\nlet (c, d) = b; // c = 1, d = 1.5\nlet (e, _, _, _, f) = a; //e = 1, f = \"Hello, world!\", _ indicates not interested of that item\n\nlet g = (0,); //single-element tuple\n\nlet h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)\n\nprintln!(\"{:?}\", a); //(1, 1.5, true, 'a', \"Hello, world!\") \n```", "```\nlet a: [i32; 4] = [1, 2, 3, 4];//Parent Array\n\nlet b: &[i32] = &a; //Slicing whole array\nlet c = &a[0..4]; // From 0th position to 4th(excluding)\nlet d = &a[..]; //Slicing whole array\n\nlet e = &a[1..3]; //[2, 3]\nlet e = &a[1..]; //[2, 3, 4]\nlet e = &a[..3]; //[1, 2, 3] \n```", "```\nlet a = \"Hello, world.\"; //a: &'static str\nlet b: &str = \"\u3053\u3093\u306b\u3061\u306f, \u4e16\u754c!\"; \n```", "```\nfn plus_one(a: i32) -> i32 {\n    a + 1\n}\n\nlet b: fn(i32) -> i32 = plus_one;\nlet c = b(5); //6 \n```", "```\nlet a = 5;\nlet b = a + 1; //6\nlet c = a - 1; //4\nlet d = a * 2; //10\nlet e = a / 2; // \u2b50\ufe0f 2 not 2.5\nlet f = a % 2; //1\n\nlet g = 5.0 / 2.0; //2.5 \n```", "```\nlet a = 1;\nlet b = 2;\n\nlet c = a == b; //false\nlet d = a != b; //true\nlet e = a < b; //true\nlet f = a > b; //false\nlet g = a <= a; //true\nlet h = a >= a; //true\n\n// \ud83d\udd0e\nlet i = true > false; //true\nlet j = 'a' > 'A'; //true \n```", "```\nlet a = true;\nlet b = false;\n\nlet c = !a; //false\nlet d = a && b; //false\nlet e = a || b; //true \n```", "```\nlet a = !-2; //1\nlet b = !-1; //0\nlet c = !0; //-1\nlet d = !1; //-2 \n```", "```\nlet a = 1;\nlet b = 2;\n\nlet c = a & b; //0  (01 && 10 -> 00)\nlet d = a | b; //3  (01 || 10 -> 11)\nlet e = a ^ b; //3  (01 != 10 -> 11)\nlet f = a << b; //4  (add 2 positions to the end -> '01'+'00' -> 100)\nlet g = a >> a; //0  (remove 2 positions from the end -> o\u03361\u0336 -> 0) \n```", "```\nlet mut a = 2;\n\na += 5; //2 + 5 = 7\na -= 2; //7 - 2 = 5\na *= 5; //5 * 5 = 25\na /= 2; //25 / 2 = 12 not 12.5\na %= 5; //12 % 5 = 2\n\na &= 2; //10 && 10 -> 10 -> 2\na |= 5; //010 || 101 -> 111 -> 7\na ^= 2; //111 != 010 -> 101 -> 5\na <<= 1; //'101'+'0' -> 1010 -> 10\na >>= 2; //101\u03360\u0336 -> 10 -> 2 \n```", "```\nlet a = 15;\nlet b = (a as f64) / 2.0; //7.5 \n```", "```\n// Simplest Example\nlet team_size = 7;\nif team_size < 5 {\n    println!(\"Small\");\n} else if team_size < 10 {\n    println!(\"Medium\");\n} else {\n    println!(\"Large\");\n}\n\n// partially refactored code\nlet team_size = 7;\nlet team_size_in_text;\nif team_size < 5 {\n    team_size_in_text = \"Small\";\n} else if team_size < 10 {\n    team_size_in_text = \"Medium\";\n} else {\n    team_size_in_text = \"Large\";\n}\nprintln!(\"Current team size : {}\", team_size_in_text);\n\n//optimistic code\nlet team_size = 7;\nlet team_size_in_text = if team_size < 5 {\n    \"Small\" //\u2b50\ufe0fno ;\n} else if team_size < 10 {\n    \"Medium\"\n} else {\n    \"Large\"\n};\nprintln!(\"Current team size : {}\", team_size_in_text);\n\nlet is_below_eighteen = if team_size < 18 { true } else { false }; \n```", "```\nlet tshirt_width = 20;\nlet tshirt_size = match tshirt_width {\n    16 => \"S\", // check 16\n    17 | 18 => \"M\", // check 17 and 18\n    19 ... 21 => \"L\", // check from 19 to 21 (19,20,21)\n    22 => \"XL\",\n    _ => \"Not Available\",\n};\nprintln!(\"{}\", tshirt_size); // L\n\nlet is_allowed = false;\nlet list_type = match is_allowed {\n    true => \"Full\",\n    false => \"Restricted\"\n    // no default/ _ condition can be skipped \n    // Because data type of is_allowed is boolean and all possibilities checked on conditions \n};\nprintln!(\"{}\", list_type); // Restricted\n\nlet marks_paper_a: u8 = 25;\nlet marks_paper_b: u8 = 30;\nlet output = match (marks_paper_a, marks_paper_b) {\n    (50, 50) => \"Full marks for both papers\",\n    (50, _) => \"Full marks for paper A\",\n    (_, 50) => \"Full marks for paper B\",\n    (x, y) if x > 25 && y > 25 => \"Good\",\n    (_, _) => \"Work hard\"\n};\nprintln!(\"{}\", output); // Work hard \n```", "```\nlet mut a = 1;\nwhile a <= 10 { \n    println!(\"Current value : {}\", a);\n    a += 1; //no ++ or -- on Rust\n}\n\n// Usage of break and continue\nlet mut b = 0;\nwhile b < 5 {\n    if b == 0 { \n        println!(\"Skip value : {}\", b);\n        b += 1;\n        continue;\n    } else if b == 2 {\n        println!(\"Break At : {}\", b);\n        break;\n    }\n    println!(\"Current value : {}\", b);\n    b += 1;\n}\n\n// Outer break\nlet mut c1 = 1;\n'outer_while: while c1 < 6 { //set label outer_while\n    let mut c2 = 1;\n    'inner_while: while c2 < 6 { \n        println!(\"Current Value : [{}][{}]\", c1, c2);\n        if c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while\n        c2 += 1;\n    }\n    c1 += 1;\n} \n```", "```\nloop {\n    println!(\"Loop forever!\");\n}\n\n// Usage of break and continue\nlet mut a = 0;\nloop {\n    if a == 0 {\n        println!(\"Skip Value : {}\", a);\n        a += 1;\n        continue;\n    } else if a == 2 {\n        println!(\"Break At : {}\", a);\n        break;\n    }\n    println!(\"Current Value : {}\", a);\n    a += 1;\n}\n\n// Outer break\nlet mut b1 = 1;\n'outer_loop: loop { //set label outer_loop\n  let mut b2 = 1;\n  'inner_loop: loop {\n    println!(\"Current Value : [{}][{}]\", b1, b2);\n    if b1 == 2 && b2 == 2 {\n        break 'outer_loop; // kill outer_loop\n    } else if b2 == 5 {\n        break;\n    }\n    b2 += 1;\n  }\n  b1 += 1;\n} \n```", "```\nfor a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)\n  println!(\"Current value : {}\", a);\n}\n\n// Usage of break and continue\nfor b in 0..6 {\n  if b == 0 {\n    println!(\"Skip Value : {}\", b);\n    continue;\n  } else if b == 2 {\n    println!(\"Break At : {}\", b);\n    break;\n  }\n  println!(\"Current value : {}\", b);\n}\n\n// Outer break\n'outer_for: for c1 in 1..6 { //set label outer_for\n  'inner_for: for c2 in 1..6 {\n    println!(\"Current Value : [{}][{}]\", c1, c2);\n    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for\n  }\n}\n\n// Working with arrays/vectors\nlet group : [&str; 4] = [\"Mark\", \"Larry\", \"Bill\", \"Steve\"];\n\nfor n in 0..group.len() { //group.len() = 4 -> 0..4 \ud83d\udc4e check group.len()on each iteration\n  println!(\"Current Person : {}\", group[n]);\n}\n\nfor person in group.iter() { //\ud83d\udc4d group.iter() turn the array into a simple iterator\n  println!(\"Current Person : {}\", person);\n} \n```", "```\n//Creating vectors - 2 ways\nlet mut a = Vec::new(); //1.with new() keyword\nlet mut b = vec![]; //2.using the vec! macro\n\n//Creating with data types\nlet mut a2: Vec<i32> = Vec::new();\nlet mut b2: Vec<i32> = vec![];\nlet mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type\n\n//Creating with data\nlet mut b4 = vec![1, 2, 3];\nlet mut b5: Vec<i32> = vec![1, 2, 3];\nlet mut b6  = vec![1i32, 2, 3];\nlet mut b7 = vec![0; 10]; //ten zeroes\n\n//Accessing and changing exsisting data\nlet mut c = vec![5, 4, 3, 2, 1];\nc[0] = 1;\nc[1] = 2;\n//c[6] = 2; can't assign values this way, index out of bounds\nprintln!(\"{:?}\", c); //[1, 2, 3, 2, 1]\n\n//push and pop\nlet mut d: Vec<i32> = Vec::new();\nd.push(1); //[1] : Add an element to the end\nd.push(2); //[1, 2]\nd.pop(); //[1] : : Remove an element from the end\n\n// \ud83d\udd0e Capacity and reallocation\nlet mut e: Vec<i32> = Vec::with_capacity(10);\nprintln!(\"Length: {}, Capacity : {}\", e.len(), e.capacity()); //Length: 0, Capacity : 10\n\n// These are all done without reallocating...\nfor i in 0..10 {\n    e.push(i);\n}\n// ...but this may make the vector reallocate\ne.push(11); \n```", "```\nlet mut v = vec![1, 2, 3, 4, 5];\n\nfor i in &v {\n    println!(\"A reference to {}\", i);\n}\n\nfor i in &mut v {\n    println!(\"A mutable reference to {}\", i);\n}\n\nfor i in v {\n    println!(\"Take ownership of the vector and its element {}\", i);\n} \n```", "```\n// Struct Declaration\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8\n}\n\nfn main() {\n  // creating an instance\n  let black = Color {red: 0, green: 0, blue: 0};\n\n  // accessing it's fields, using dot notation\n  println!(\"Black = rgb({}, {}, {})\", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)\n\n  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability\n  let mut link_color = Color {red: 0,green: 0,blue: 255};\n  link_color.blue = 238;\n  println!(\"Link Color = rgb({}, {}, {})\", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)\n\n  // copy elements from another instance\n  let blue = Color {blue: 255, .. link_color};\n  println!(\"Blue = rgb({}, {}, {})\", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)\n\n  // destructure the instance using a `let` binding, this will not destruct blue instance\n  let Color {red: r, green: g, blue: b} = blue;\n  println!(\"Blue = rgb({}, {}, {})\", r, g, b); //Blue = rgb(0, 0, 255)\n\n  // creating an instance via functions & accessing it's fields\n  let midnightblue = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)\n\n  // destructure the instance using a `let` binding\n  let Color {red: r, green: g, blue: b} = get_midnightblue_color();\n  println!(\"Midnight Blue = rgb({}, {}, {})\", r, g, b); //Midnight Blue = rgb(25, 25, 112)\n}\n\nfn get_midnightblue_color() -> Color {\n    Color {red: 25, green: 25, blue: 112}\n} \n```", "```\nstruct Color (u8, u8, u8);\nstruct Kilometers(i32);\n\nfn main() {\n  // creating an instance\n  let black = Color (0, 0, 0);\n\n  // destructure the instance using a `let` binding, this will not destruct black instance\n  let Color (r, g, b) = black;\n  println!(\"Black = rgb({}, {}, {})\", r, g, b); //black = rgb(0, 0, 0);\n\n  //newtype pattern\n  let distance = Kilometers(20);\n  // destructure the instance using a `let` binding\n  let Kilometers(distance_in_km) = distance;\n  println!(\"The distance: {} km\", distance_in_km); //The distance: 20 km\n} \n```", "```\nstruct Electron;\n\nfn main() {\n  let x = Electron;\n} \n```", "```\nenum Day {\n    Sunday,\n    Monday, \n    Tuesday, \n    Wednesday, \n    Thursday,\n    Friday,\n    Saturday\n}\n\n// Day is the enum\n// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants \n```", "```\nenum FlashMessage {\n  Success, //a unit variant\n  Warning{ category: i32, message: String }, //a struct variant\n  Error(String) //a tuple variant\n}\n\nfn main() {\n  let mut form_status = FlashMessage::Success;\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Warning {category: 2, message: String::from(\"Field X is required\")};\n  print_flash_message(form_status);\n\n  form_status = FlashMessage::Error(String::from(\"Connection Error\"));\n  print_flash_message(form_status);\n}\n\nfn print_flash_message(m : FlashMessage) {\n  // pattern matching with enum\n  match m {\n    FlashMessage::Success => \n      println!(\"Form Submitted correctly\"),\n    FlashMessage::Warning {category, message} => //Destructure, should use same field names\n      println!(\"Warning : {} - {}\", category, message),\n    FlashMessage::Error(msg) => \n      println!(\"Error : {}\", msg)\n  }\n} \n```", "```\n// generalizing functions\n//-----------------------\nfn takes_anything<T>(x: T) { // x has type T, T is a generic type\n}\n\nfn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type\n}\n\nfn takes_two_things<T, U>(x: T, y: U) { // multiple types\n}\n\n// generalizing structs\n//---------------------\nstruct Point<T> {\n  x: T,\n  y: T,\n}\n\nfn main() {\n  let point_a = Point { x: 0, y: 0 }; // T is a int type\n  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type\n}\n\n// \ud83d\udd0e When addding an implementation for a generic struct, the type parameters should be declared after the impl as well\n// impl<T> Point<T> {\n\n// generalizing enums\n//-------------------\nenum Option<T> {\n    Some(T),\n    None,\n}\n\nenum Result<T, E> {\n    Ok(T),\n    Err(E),\n} \n```", "```\n// 01 - - - - - - - - - - - - - - - - - - - - - -\nfn getIdByUsername(username: &str) -> Option<usize> {\n    //if username can be found in the system, set userId\n        return Some(userId);\n    //else\n        None\n}\n\n//\ud83d\udcad So on above function, instead of setting return type as usize\n// set return type as Option<usize>\n//Instead of return userId, return Some(userId)\n// else None (\ud83d\udca1remember? last return statement no need return keyword and ending ;)\n\n// 02 - - - - - - - - - - - - - - - - - - - - - -\nstruct Task {\n    title: String,\n    assignee: Option<Person>,\n}\n\n//\ud83d\udcad Instead of assignee: Person, we use Option<Person>\n//Because the task has not been assigned to a specific person\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n//when using Option types as return types on functions\n// we can use pattern matching to catch the relevant return type(Some/None) when calling them\n\nfn main() {\n    let username = \"anonymous\"\n    match getIdByUsername(username) {\n        None => println!(\"User not found\"),\n        Some(i) => println!(\"User Id: {}\", i)\n    }\n} \n```", "```\n// - - - - - - - - - - - - - - - - - - - - - -\nfn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {\n  //if the file is not found on the system, return error\n    return Err(\"File can not be found!\")\n  //else, count and return the word count \n    //let mut word_count: u32; ....\n    Ok(word_count)\n}\n\n//\ud83d\udcad on above function, \n// instead panic(break) the app, when a file can not be found; return Err(something)\n// or when it could get the relevant data; return Ok(data)\n\n// - - - - - - - - - - - - - - - - - - - - - - -\n// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it\n\nfn main() {\n    let mut file_name = \"file_a\";\n    match get_word_count_from_file(file_name) {\n        Ok(i) => println!(\"Word Count: {}\", i),\n        Err(e) => println!(\"Error: {}\", e)\n    }\n} \n```", "```\n// 01 -----------------------------------------\n// Adding methoids directly; without using traits\n\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_1 = Player {\n        first_name: \"Rafael\".to_string(),\n        last_name: \"Nadal\".to_string(),\n    };\n\n    println!(\"Player 01: {}\", player_1.full_name());\n}\n\n// 02 -----------------------------------------\n// Adding methoids by implementing traits\n\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\ntrait FullName {\n    fn full_name(&self) -> String;\n}\n\nimpl FullName for Player {\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_2 = Player {\n        first_name: \"Roger\".to_string(),\n        last_name: \"Federer\".to_string(),\n    };\n\n    println!(\"Player 02: {}\", player_2.full_name());\n}\n\n// 03 -----------------------------------------\n// a trait with default implementations of methods\n\ntrait Foo {\n    fn bar(&self);\n    fn baz(&self) { println!(\"We called baz.\"); }\n}\n\n// --------------------------------------------\n// \u2b50\ufe0f In case 01, implementation must appear in the same crate as the self type\n\n// \ud83d\udca1 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.\n// Same way existing traits can be implemented for new types you are creating.\n// But we can not implement existing traits into existing types\n\n// \ud83d\udd0e Other than functions, traits can contain constants and types\n\n// \ud83d\udd0e Traits also supprot generics; should specify after the trait name like generic functions\n\ntrait From<T> {\n    fn from(T) -> Self;\n}\n    impl From<u8> for u16 { \n        //... \n    }\n    impl From<u8> for u32{\n        //...\n    } \n```", "```\nstruct Player {\n    first_name: String,\n    last_name: String,\n}\n\nimpl Player {\n    fn new(first_name: String, last_name: String) -> Player {\n        Player {\n            first_name : first_name,\n            last_name : last_name,\n        }\n    }\n\n    fn full_name(&self) -> String {\n        format!(\"{} {}\", self.first_name, self.last_name)\n    }\n}\n\nfn main() {\n    let player_name = Player::new(\"Serena\".to_string(), \"Williams\".to_string()).full_name();\n    println!(\"Player: {}\", player_name);\n}\n\n// we have used :: notation for `new()` and . notation for `full_name()`\n\n// \ud83d\udd0e Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name() \n// calls, we can use a single statement with Method Chaining. \n// ex. player.add_points(2).get_point_count(); \n```", "```\ntrait Person {\n    fn full_name(&self) -> String;\n}\n\n    trait Employee : Person { //Employee inherit from person trait\n      fn job_title(&self) -> String;\n    }\n\n    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits\n      fn additional_tax(&self) -> f64;\n    } \n```", "```\ntrait GetSound {\n    fn get_sound(&self) -> String;\n}\n\nstruct Cat {\n    sound: String,\n}\n    impl GetSound for Cat {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nstruct Bell {\n    sound: String,\n}\n    impl GetSound for Bell {\n        fn get_sound(&self) -> String {\n            self.sound.clone()\n        }\n    }\n\nfn make_sound<T: GetSound>(t: &T) {\n    println!(\"{}!\", t.get_sound())\n}\n\nfn main() {\n    let kitty = Cat { sound: \"Meow\".to_string() };\n    let the_bell = Bell { sound: \"Ding Dong\".to_string() };\n\n    make_sound(&kitty); // Meow!\n    make_sound(&the_bell); // Ding Dong!\n} \n```", "```\nfn main() {\n    let a = [1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // [1, 2, 3] [1, 2, 3]\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = a;\n    println!(\"{:?} {:?}\", a, b); // Error; use of moved value: `a`\n} \n```", "```\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n                   //  \u205d\n  // some code     //  \u205d\n  // some code     //  \u205d\n}                  //  &mut borrow of a ends here\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  let b = &mut a;  //  &mut borrow of a starts here\n  // some code\n\n  println!(\"{:?}\", a); // trying to access a as a shared borrow, so giving error\n}                  //  &mut borrow of a ends here\n\nfn main() {\n  let mut a = vec![1, 2, 3];\n  {\n    let b = &mut a;  //  &mut borrow of a starts here\n    // any other code\n  }                  //  &mut borrow of a ends here\n\n  println!(\"{:?}\", a); // allow to borrow a as a shared borrow\n} \n```", "```\nfn main() {\n    let a = [1, 2, 3];\n    let b = &a;\n    println!(\"{:?} {}\", a, b[0]); // [1, 2, 3] 1\n}\n\nfn main() {\n    let a = vec![1, 2, 3];\n    let b = get_first_element(&a);\n\n    println!(\"{:?} {}\", a, b); // [1, 2, 3] 1\n}\n\nfn get_first_element(a: &Vec<i32>) -> i32 {\n    a[0]\n} \n```", "```\nfn main() {\n    let mut a = [1, 2, 3];\n    let b = &mut a;\n    b[0] = 4;\n    println!(\"{:?}\", b); // [4, 2, 3]\n}\n\nfn main() {\n    let mut a = [1, 2, 3];\n    {\n        let b = &mut a;\n        b[0] = 4;\n    }\n\n    println!(\"{:?}\", a); // [4, 2, 3]\n}\n\nfn main() {\n    let mut a = vec![1, 2, 3];\n    let b = change_and_get_first_element(&mut a);\n\n    println!(\"{:?} {}\", a, b); // [4, 2, 3] 4\n}\n\nfn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {\n    a[0] = 4;\n    a[0]\n} \n```", "```\n// no inputs, return a reference\nfn function<'a>() -> &'a str {} \n\n// single input\nfn function<'a>(x: &'a str) {}\n\n// single input and output, both has same lifetime\n// output should live at least as long as input exists\nfn function<'a>(x: &'a str) -> &'a str {}\n\n// multiple inputs, only one input and the output share same lifetime\n// output should live at least as long as y exists\nfn function<'a>(x: i32, y: &'a str) -> &'a str {}\n\n// multiple inputs. both inputs and the output share same lifetime\n// output should live at least as long as x and y exist\nfn function<'a>(x: &'a str, y: &'a str) -> &'a str {}\n\n// multiple inputs. inputs can have diffent lifetimes \ud83d\udd0e\n// output should live at least as long as x exists\nfn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {} \n```", "```\n// single element\n// data of x should live at least as long as Struct exists\nstruct Struct<'a> { \n    x: &'a str \n}\n\n// multiple elements\n// data of x and y should live at least as long as Struct exists\nstruct Struct<'a> { \n    x: &'a str,\n    y: &'a str \n}\n\n// variant with single element\n// data of the variant should live at least as long as Enum exists\nenum Enum<'a> { \n    Variant(&'a Type)\n} \n```", "```\nstruct Struct<'a> { \n    x: &'a str \n}\n    impl<'a> Struct<'a> { \n        fn function<'a>(&self) -> &'a str {\n            self.x \n        }\n    }\n\nstruct Struct<'a> { \n    x: &'a str,\n    y: &'a str\n}\n    impl<'a> Struct<'a> { \n        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it\n          Struct {\n              x : x,\n              y : y\n          }\n        }\n    }\n\n// \ud83d\udd0e\nimpl<'a> Trait<'a> for Type\nimpl<'a> Trait for Type<'a> \n```", "```\n// \ud83d\udd0e\nfn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)\nstruct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }\nenum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }\nimpl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } } \n```", "```\nfn triple(x: &u64) -> u64 { //only one input parameter passes by reference\n    x * 3\n}\n\nfn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference\n    if x > 5 { y } else { \"invalid inputs\" }\n}\n\nstruct Player<'a> { \n    id: u8,\n    name: &'a str\n}\n    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.\n        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference\n            Player {\n                id : id,\n                name : name\n            }\n        }\n\n        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference\n            format!(\"{}: {}\", self.id, self.name)\n        }\n    }\n\nfn main() {\n    let player1 = Player::new(1, \"Serena Williams\");\n    let player1_heading_text = player1.heading_text()\n    println!(\"{}\", player1_heading_text);\n} \n```", "```\nfn greeting<'a>() -> &'a str {\n  \"Hi!\"\n}\n\nfn fullname<'a>(fname: &'a str, lname: &'a str) -> String {\n  format!(\"{} {}\", fname, lname)\n}\n\nstruct Person<'a> { \n    fname: &'a str,\n    lname: &'a str\n}\n  impl<'a> Person<'a> {\n      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it\n          Person {\n              fname : fname,\n              lname : lname\n          }\n      }\n\n      fn fullname(&self) -> String {\n          format!(\"{} {}\", self.fname , self.lname)\n      }\n  }\n\nfn main() {\n    let player = Person::new(\"Serena\", \"Williams\");\n    let player_fullname = player.fullname();\n\n    println!(\"Player: {}\", player_fullname);\n} \n```"]