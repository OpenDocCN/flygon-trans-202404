- en: Lazy Evaluation and GeneratorsTA DAH YOU'RE DONE!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy Evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sorry for this bit of a jump in topics. You're skipping this from Lesson 12,
    so we'll do a quick intro here.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation is the implementation of normal order evaluation as opposed
    to applicative order evaluation. As a review, in Lesson 1, where we began our
    discussion of models of evaluation, we noted that Scheme is an applicative-order
    language, namely, that all the arguments to Scheme procedures are evaluated when
    the procedure is applied. In contrast, normal-order languages delay evaluation
    of procedure arguments until the actual argument values are needed. Delaying evaluation
    of procedure arguments until the last possible moment (e.g., until they are required
    by a primitive operation) is called lazy evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Python is similar to Scheme. When you define a procedure and call it with arguments.
    All arguments are evaluated before the body is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the procedure
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating `try(0, 1/0)` will trigger a division by zero error because the arguments
    are both evaluated first.
  prefs: []
  type: TYPE_NORMAL
- en: In Lazy Evaluation, an error would not occur. Evaluating the expression would
    return 1, because the argument `1/0` would never be evaluated as it is never used
    in a primitive procedure nor returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`if` is a lazy procedure when used directly. If you were to try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: See that True gets returned since we never need to evaluate 1/0 so we never
    error! All this is possible because `if` is handled as a special form in the evaluation
    process (think mc-eval from lesson 11). For us to get this behavior in every procedure
    call, we would have to change how eval and apply work in Python. Instead of immediately
    evaluating the arguments to a procedure application before passing it to apply,
    we only do so if it is returned or used primitively.
  prefs: []
  type: TYPE_NORMAL
- en: If you have an interest in a deeper understanding of lazy evaluation implemented
    in an interpreter, please read the original lesson 12 [content](http://www.cs61as.org/textbook/an-interpreter-with-lazy-evaluation.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to dabble with an implementation of lazy evaluation wrappers in
    Python, see the lazy.py module on this [website](http://blitiri.com.ar/p/python/).
  prefs: []
  type: TYPE_NORMAL
- en: Range and Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've been using `range()` in `for` loops but we haven't thought much how it
    works. Range is an immutable sequence that is lazy. Behind the scenes, elements
    in a sequence created by range aren't created until they are required. Don't believe
    me? Try `print(range(4))` and `print([0, 1, 2, 3])`.
  prefs: []
  type: TYPE_NORMAL
- en: We can create similar sequences to `range()` through the use of generators.
    In Python, generators are functions than create sequences by computing and `yield`ing
    the next value as needed. They are analogous to streams from Scheme and are a
    lazy sequence as opposed to lists which are eager sequences (eager to enumerate).
  prefs: []
  type: TYPE_NORMAL
- en: Generators are [iterable](https://docs.python.org/3/tutorial/classes.html#iterators)
    so you can use them in for loops, just like how we use range(). You can also call
    `next(generator)` on any generator procedure to get subsequent elements. Generators,
    however, cannot be iterated over multiple times. Once you've used up the sequence,
    it's gone. If you try to call `next()` on a used up generator you'll get a `StopIteration`
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to ponder why we'd want generators. [Why not just always use lists?](https://www.google.com/search?q=when+to+use+generators+in+python)
  prefs: []
  type: TYPE_NORMAL
- en: '`yield` is how we create procedures that are generators as opposed to functions.
    You''ll use `yield` instead of `return`. Now for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try printing each element using a for loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try calling next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Aha! The `StopIteration` error!
  prefs: []
  type: TYPE_NORMAL
- en: And now an infinite generator! Go ahead and try to `print` it and `next` through
    a call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Homework Problem 10: Growing Pains (Exponentially)**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a generator `gen_exp()` that takes a number n and generates (for eternity)
    the exponential of n to the n to the n starting at n.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example the first few elements of `gen_exp(2)` should be 2, (2^2), ((2^2)^
    2), (((2^2)^ 2) ^ 2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TA DAH YOU'RE DONE!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More cool things! You should look into if you liked learning Python.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Importing Modules](https://docs.python.org/3/tutorial/modules.html) like the
    [math module... so awesome](https://docs.python.org/3/library/math.html). See
    [this link](https://docs.python.org/3/library/index.html) for an extensive directory
    of module libraries that come packaged with Python 3.5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Turtle Graphics](https://docs.python.org/3/library/turtle.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Science-y math-y stuff](http://www.scipy.org/) which is already installed
    with an Anaconda distribuition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
