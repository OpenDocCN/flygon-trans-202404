- en: Racket-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the source code for the Racket-1 interpreter into your current directory
    by typing the following into your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can download the code [here](http://inst.eecs.berkeley.edu/~cs61as/library/racket1.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start Racket-1, type the following in Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Familiarize yourself with Racket-1 by evaluating some expressions. Try typing
    regular Racket expressions and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that you can''t do everything in Racket-1 that you can do
    in normal Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: You have all the Racket primitives for arithmetic and list manipulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have `lambda` but not higher-order functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have `define`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To stop the Racket-1 interpreter and return to Racket, just evaluate an illegal
    expression, such as `()`.
  prefs: []
  type: TYPE_NORMAL
- en: What Is an Interpreter?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to run a program on a computer, something in the computer must understand
    the intentions of the code, perform the necessary computations, and then return
    the results. This thing acts as a mediator between the programmer's ideas and
    the hardware that computes them. One such mediator is an **interpreter**.
  prefs: []
  type: TYPE_NORMAL
- en: '`racket` is an interpreter for Racket. It translates Racket source code into
    instructions that the computer, then tells the computer to execute them. It has
    the ability to read input and display output.'
  prefs: []
  type: TYPE_NORMAL
- en: Racket-1 is also an interpreter. It works for a purely functional subset of
    Racket. The fact that Racket-1 is written *in* Racket is interesting but unimportant.
    We could also write Racket-1 in another language, like Python, but what really
    matters to us as users is what the interpreter *does*, not what its source code
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: We'll talk more about interpreters in just a few lessons. For now, let's discuss
    how Racket-1 works.
  prefs: []
  type: TYPE_NORMAL
- en: How Does Racket-1 Work?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**racket-1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'racket-1 follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To evaluate a combination:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the subexpressions of the combination
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the procedure that is the value of the leftmost subexpression (the operator)
    to the arguments that are the values of the other subexpressions (the operands).
    To apply a compound procedure to arguments, evaluate the body of the procedure
    with each formal parameter replaced by the corresponding argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(SICP: [1.1.3](http://mitpress.mit.edu/sicp/full- text/book/book-Z-H-10.html#%_sec_1.1.3),
    [1.1.5](http://mitpress.mit.edu/sicp /full-text/book/book-Z-H-10.html#%_sec_1.1.5))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What happens here? Given the rules, walk through the evaluation by hand.
  prefs: []
  type: TYPE_NORMAL
- en: '**Read-Eval-Print Loop**'
  prefs: []
  type: TYPE_NORMAL
- en: An interpreter needs a loop that allows it to do all the things it does. Every
    time you type a command, racket-1 parses and executes your input, returns the
    output, and then waits for another command. This is called a Read-Eval-Print loop
    (REPL).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is all of racket-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three lines simply print the prompt "Racket-1: ". The fourth line
    is the important one. Here, input is read, parsed and sent to eval-1 to be evaluated.
    After eval-1 takes care of executing the code, its result is printed. Finally,
    racket-1 calls itself to restart the process, to display another "Racket-1: "
    and take another command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eval-1**'
  prefs: []
  type: TYPE_NORMAL
- en: Eval-1 is in charge of returning the result of whatever computation it was passed
    as exp. It is composed of a cond, with a clause for everything it can interpret
    and compute. Note that it is in Eval-1 where special forms are caught and handled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Apply-1**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply-1 is called by eval-1 when it is time to apply a procedure to its arguments.
    Apply-1 takes care of two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: racket-1 primatives. In this context, a primative is a non-user-defined procedures.
    All Racket procedures are Racket-1 primatives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lambda functions, or user defined procedures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Mutual Recursion (in racket-1)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![eval](/static/eval.png)'
  prefs: []
  type: TYPE_IMG
- en: Practice with Racket-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay, so even though you just finished staring at the code, you probably don't
    completely understand all of it yet. Let's go through a few exercises to better
    acquaint you with the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manually trace through (in detail) how racket-1 handles the following procedure
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In particular, walk through all of the functions that racket-1 must call to
    evaluate this expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try inventing higher-order procedures; since you don''t have define you''ll
    have to use the Y-combinator trick, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since all the Racket primitives are automatically available in racket-1, you
    might think you could use Racket''s primitive map function. Try these examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Explain the results.
  prefs: []
  type: TYPE_NORMAL
- en: Modify the interpreter to add the `and` special form. Test your work. Be sure
    that as soon as a false value is computed, your `and` returns `#f` without evaluating
    any further arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
