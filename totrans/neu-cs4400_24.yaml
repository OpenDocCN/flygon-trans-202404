- en: Implementing First Class FunctionsTuesday, January 24th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PLAI §6](plai.pdf#chapter.6 "First-Class Functions") (uses some stuff from
    [PLAI §5](plai.pdf#chapter.5 "Deferring Substitution"), which we do later)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a simple plan, but it is directly related to how functions are going
    to be used in our language. We know that `{call {fun {x} E1} E2}` is equivalent
    to a `with` expression, but the new thing here is that we do allow writing just
    the `{fun ...}` expression by itself, and therefore we need to have some meaning
    for it. The meaning, or the value of this expression, should roughly be “an expression
    that needs a value to be plugged in for `x`”. In other words, our language will
    have these new kinds of values that contain an expression to be evaluated later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three basic approaches that classify programming languages in relation
    to how the deal with functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First order: functions are not real values. They cannot be used or returned
    as values by other functions. This means that they cannot be stored in data structures.
    This is what most “conventional” languages used to have in the past. (You will
    be implementing such a language in homework 4.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An example of such a language is the Beginner Student language that is used
    in HtDP, where the language is intentionally first-order to help students write
    correct code (at the early stages where using a function as a value is usually
    an error). It’s hard to find practical modern languages that fall in this category.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Higher order: functions can receive and return other functions as values. This
    is what you get with C and modern Fortran.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First class: functions are values with all the rights of other values. In particular,
    they can be supplied to other functions, returned from functions, stored in data
    structures, and new functions can be created at run-time. (And most modern languages
    have first class functions.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last category is the most interesting one. Back in the old days, complex
    expressions were not first-class in that they could not be freely composed. This
    is still the case in machine-code: as we’ve seen earlier, to compute an expression
    such as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'you have to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In other words, every intermediate value needs to have its own name. But with
    proper (“high-level”) programming languages (at least most of them…) you can just
    write the original expression, with no names for these values.
  prefs: []
  type: TYPE_NORMAL
- en: With first-class functions something similar happens — it is possible to have
    complex expressions that consume and return functions, and they do not need to
    be named.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we get with our `fun` expression (if we can make it work) is exactly this:
    it generates a function, and you can choose to either bind it to a name, or not.
    The important thing is that the value exists independently of a name.'
  prefs: []
  type: TYPE_NORMAL
- en: This has a major effect on the “personality” of a programming language as we
    will see. In fact, just adding this feature will make our language much more advanced
    than languages with just higher-order or first-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
