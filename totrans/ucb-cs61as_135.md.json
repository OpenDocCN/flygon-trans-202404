["```\ncp ~cs61as/lib/analyze.scm . \n```", "```\n(define (fact num) \n  (if (= num 0)\n      1\n      (* num (fact (- num 1))))) \n```", "```\neval (fact 3) \n  self-evaluating? ==> #f \n  variable? ==> #f\n  quoted? ==> #f \n  assignment? definition?\n  if? ==> #f\n  lambda? ==> #f\n  begin? ==> #f\n  cond? ==> #f \n  application? ==> #t \n  eval fact\n    self-evaluating? ==> #f\n    variable? ==> #t\n    lookup-variable-value ==> <procedure fact> \n    list-of-values (3)\n      eval3 ==> 3\n    apply <procedure fact> (3)\n      eval (if (= num 0) ...) \n      self-evaluating? ==> #f \n      variable? ==> #f \n      quoted? ==> #f \n      assignment? ==> #f \n      definition? ==> #f\n      if? ==> #t \n        eval-if (if (= num 0) ...) \n          if-predicate ==> (= num 0)\n            eval (= num 0)\n            self-evaluating? ==> #f\n            ...\n          if-alternative ==> (* num (fact (- num 1)))  \n            eval (* num (fact (- num 1)))\n              self-evaluating? ==> #f\n              ...\n              list-of-values (num (fact (- num 1)))\n                ...\n                eval (fact (- num 1))\n                  ...\n                  apply <procedure fact> (2)\n                    eval (if (= num 0) ...) \n```", "```\n(eval exp env) ==> value \n```", "```\n1\\. (analyze exp) ==> exp-procedure \n2\\. (exp-procedure env) ==> value \n```", "```\n(define (eval exp env)\n  ((analyze exp) env)) \n```", "```\n(define (analyze exp)\n  (cond\n    ((self-evaluating? exp)\n      (analyze-self-eval exp)) \n    ((variable? exp)\n      (analyze-var exp)) \n    ...\n    ((foo? exp) (analyze-foo exp)) \n    ...)) \n```", "```\n(define (eval-if exp env)\n  (if (true? (eval (if-predicate exp) env))\n      (eval (if-consequent exp) env) \n      (eval (if-alternative exp) env))) \n```", "```\n(define (analyze-if exp) \n  (lambda (env)\n    (if (true? (eval (if-predicate exp) env)) \n        (eval (if-consequent exp) env)\n        (eval (if-alternative exp) env)))) \n```", "```\n((analyze-if some-if-expression) some-environment) \n```", "```\n(eval-if some-if-expression some-environment) \n```", "```\n(define (analyze-if exp)\n  (let ((pproc (analyze (if-predicate exp)))\n        (cproc (analyze (if-consequent exp)))\n        (aproc (analyze (if-alternative exp)))) \n    (lambda (env)\n      (if (true? (pproc env)) \n          (cproc env)\n          (aproc env))))) \n```", "```\n(define (eval-lambda exp env) (list \u2019procedure exp env)) \n```", "```\n(if A B C) \n```", "```\n(lambda (env)\n  (if (A-execution-procedure env)\n      (B-execution-procedure env) \n      (C-execution-procedure env))) \n```", "```\n (define factorial\n    (lambda (n)\n      (if (= n 1)\n          1\n          (* (factorial (- n 1)) n))))\n  (factorial 2) ;; low argument, so that the example is not too long))) \n```", "```\n (eval d env)\n  ((analyze d) env)\n  ((analyze-definition d) env) \n```", "```\nvar := value \n```", "```\n(analyze-lambda '(lambda (n) ...)') \n```", "```\nanalyzed-body := (analyze (lambda-body '(lambda (n) (if ...))'))\n\n(analyze-if '(if (= n 1)\n                 1\n                 (* (factorial (- n 1)) n))') \n```", "```\n if-pred := (analyze '(= n 1)')\n  ; this is the execution procedure: (lambda (env)\n  ;                                    (execute-application (analyzed/= env)\n\n  if-true := (analyze '1')\n  ; this is the execution procedure: (lambda (env) 1)\n\n  if-false := (analyze '(* (factorial (- n 1)) n)')\n  ; this is too long to write out, but it's\n  ; kind of like if-pred\n\n  ;;this is the execution procedure we return:\n  ;;let's call this execution procedure 'analyzed-fact-if'\n  (lambda (env)\n    (if (true? (if-pred env))\n        (if-true env)\n        (if-false env))) \n```", "```\n analyzed-body := analyzed-fact-if\n  (analyze-lambda '(lambda (n) ...)')\n     => (lambda (env) (make-procedure '(n) analyzed-body env')) \n```", "```\n (eval '(factorial 2) env') ; env has factorial definition\n\n  ((analyze '(factorial 2)') env)\n\n  ((analyze-application '(factorial 2)') env)\n\n  ((lambda (env) (execute-application ...)) env)\n\n  ((procedure-body {internal factorial value})\n   (extend-environment ...)) ; extend-environment is same as old eval\n\n  ;; let's call the extended environment, env2\n  (analyzed-body env2) ; analyzed-body from definition above\n\n ((lambda (env)\n   (if (true? (if-pred env))\n       (if-true env)\n       (if-false env)))\n  env2)\n\n (if (true? (if-pred env2)) ; (= n 0)\n     (if-true env2)   ; 1\n     (if-false env2)) ; (* (factorial (- n 1)) n) \n```", "```\n (analyzed-factorial {result of calling analyzed (- n 1)})\n\n  (analyzed-body env3)\n  ;env3 := env2 extended with n := (- {previous n} 1) = (- 2 1) = 1\n\n  (if (true? (if-pred env3)) ; (= n 0)\n      (if-true env3)   ; 1\n      (if-false env3)) ; (* (factorial (- n 1)) n) \n```", "```\n (if (true? (if-pred env4)) ; (= n 0)\n      (if-true env4) ; 1\n      (if-false env4)) ; (* (factorial (- n 1)) n) \n```"]