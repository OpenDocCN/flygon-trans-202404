["```\n*e* ::= *c* | (*op*) | *x* | (*e1*, ..., *en*) | *C* *e* | *e1 e2*\n    | fun *x* -> *e* | let *x* = *e1* in *e2* \n    | match *e0* with *p1* -> *e1* | ... | *pn* -> *en*\n    | let rec *f x* = *e1* in *e2*\n\n```", "```\n*v* ::= *c* | (*op*) | *x* | (*v1*, ..., *vn*) | *C* *v*\n    | << f, fun *x* -> *e*, *env* >>\n\n```", "```\nenv :: c --> c\nenv :: (op) --> (op)\n\n```", "```\nif env(x) = v \nthen env :: x --> v\n\n```", "```\nif env :: e --> v\nthen env :: C e --> C v\n\n```", "```\nif env :: en --> vn\nand ...\nand env :: e2 --> v2\nand env :: e1 --> v1\nthen env :: (e1,...,en) --> (v1,...,vn)\n\n```", "```\nif env :: e1 --> v1\nand env + {x=v1} :: e2 --> v2\nthen env :: (let x = e1 in e2) --> v2\n\n```", "```\nIf env + {f=<< f, fun x -> e1, env >>} :: e2 --> v2\nthen env :: (let rec f x = e1 in e2) --> v2\n\n```", "```\nif env :: e0 --> v0\nand pi is the first pattern to match v0\nand that match produces bindings b\nand env+b :: ei --> vi\nthen env :: (match e0 with p1 -> e1 | ... | pn -> en) --> vi\n\n```", "```\nenv :: (fun x -> e) --> << fun x -> e, env >>\n\n```", "```\nif env :: e2 --> v2\nand env :: e1 --> << fun x-> e, env' >>\nand env' + {x=v2} :: e --> v\nthen env :: (e1 e2) --> v\n\n```", "```\nif env :: e2 --> v2\nand env :: e1 --> << f, fun x-> e, env' >>\nand env' + {x=v2, f=<< f, fun x-> e, env' >>} :: e --> v\nthen env :: (e1 e2) --> v\n\n```", "```\nand env :: e1 --> v1\nand env :: e --> (op)\nthen env :: ((op) e1) --> \"op\" e1\n(* where \"op\" means the primitive operator built-in to OCaml *)\n\n```", "```\nlet d = 2 in\nlet f = fun x -> x + d in\nlet d = 1 in\nf 2\n-->\n4\n\n```", "```\nlet rec fact n = if n = 0 then 1 else n * (fact (n-1)) \nin fact 1\n-->\n1\n\n```", "```\nlet rec filter = fun f -> fun xs ->\n  (match xs with\n     [] -> []\n   | x::xs' -> if f x then x::(filter f xs') else filter f xs') in\nlet all_gt = fun n -> fun xs -> filter (fun x -> x > n) xs in\nall_gt 1 [1;2]\n-->\n[2]\n\n```"]