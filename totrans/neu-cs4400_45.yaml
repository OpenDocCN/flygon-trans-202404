- en: The Core of `make-recursive`Tuesday, February 14th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in Racket, being able to express recursive functions is a fundamental property
    of the language. It means that we can have loops in our language, and that’s the
    essence of making a language powerful enough to be TM-equivalent — able to express
    undecidable problems, where we don’t know whether there is an answer or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core of what makes this possible is the expression that we have seen in
    our derivation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'which reduces to itself, and therefore has no value: trying to evaluate it
    gets stuck in an infinite loop. (This expression is often called “Omega”.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the key for creating a loop — we use it to make recursion possible.
    Looking at our final `make-recursive` definition and ignoring for a moment the
    “protection” that we need against being stuck prematurely in an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'we can see that this is almost the same as the Omega expression — the only
    difference is that application of `f`. Indeed, this expression (the result of
    (make-recursive F) for some `F`) reduces in a similar way to Omega:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'which means that the actual value of this expression is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This definition would be sufficient if we had a lazy language, but to get things
    working in a strict one we need to bring back the protection. This makes things
    a little different — if we use `(protect f)` to be a shorthand for the protection
    trick,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'then we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: which makes the (make-recursive F) evaluation reduce to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: and this is still the same result (as long as `F` is a single-argument function).
  prefs: []
  type: TYPE_NORMAL
- en: (Note that `protect` cannot be implemented as a plain function!)
  prefs: []
  type: TYPE_NORMAL
