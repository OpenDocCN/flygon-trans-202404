- en: Module 0x3 | Network Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Module 0x3 | Network Kung Fu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IP Address Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In network programming, we always perform some operations on IP addresses. Following
    are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating network prefix of an IP address from IP address and subnet mask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the host part of an IP address from IP address and subnet mask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the number of hosts in a subnet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether an IP address belongs to a subnet or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting subnet mask from dot-decimal notation to integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby provides class(IPAddr) for basic operations on IP address that can be used
    to perform all operations mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Calculating network prefix of an IP address from IP address and subnet mask.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple mask method call will give us the network prefix part of IP address.
    It is simply a bitwise mask of IP address with subnet mask.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the host part of an IP address from IP address and subnet mask.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: calculating the host part is not as trivial as the network part of the IP address.
    We first calculate the complement of subnet mask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subnet(24) : 11111111.11111111.11111111.00000000'
  prefs: []
  type: TYPE_NORMAL
- en: 'neg_subnet(24) : 00000000.00000000.00000000.11111111'
  prefs: []
  type: TYPE_NORMAL
- en: we used negation(~) and mask method to calculate complement of subnet mask then
    simply performed a bitwise AND between the IP and complement of subnet
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the number of hosts in a subnet.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used to_range method to create a range of all the IPs then count method to
    count the IPs in range. We reduced the number by two to exclude the gateway and
    broadcast IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Check whether an IP address belong to a subnet or not.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`===` is an alias of include? which returns true if ip address belongs to the
    range otherwise it returns false.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Converting subnet mask from dot-decimal notation to integer.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We treated subnet mask as ip address and converted it into an integer by using
    `to_i` then used `to_s(2)` to convert the integer into binary form. Once we had
    the binary we counted the number of occurrence of digit 1 with `count("1")`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Converting IP to another formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IP Decimal to Dotted notation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: IP Dotted notation to Decimal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This part has been pretty quoted from [IP address Operations in Ruby](http://www.brownfort.com/2014/09/ip-operations-ruby/)
    topic
  prefs: []
  type: TYPE_NORMAL
- en: IP Geolocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: you may need to know more information about IP location due attack investigation
    or any other reason.
  prefs: []
  type: TYPE_NORMAL
- en: GeoIP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The special thing about geoip lib is that it's an API for offline database you
    download from [www.maxmind.com](http://www.maxmind.com). There are few free databases
    from MaxMind whoever you can have a subscription database version though.
  prefs: []
  type: TYPE_NORMAL
- en: Download one of the free GeoLite country, city or ASN databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GeoLiteCountry](geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GeoLiteCity](geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GeoIPASNum](geolite.maxmind.com/download/geoip/database/asnum/GeoIPASNum.dat.gz)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Install geoip gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[RubyDoc | IPAddr](http://ruby-doc.org/stdlib-1.9.3/libdoc/ipaddr/rdoc/IPAddr.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby Socket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby Socket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lightweight Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ruby Socket Class Hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To know the socket hierarchy in ruby here a simple tree explains it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: I'll verbosely mention some of `Socket::Constants` here since I didn't find
    an obvious reference listing it except [Programming Ruby1.9 *The Pragmatic Programmers'
    Guide*](http://media.pragprog.com/titles/ruby3/app_socket.pdf); Otherwise you've
    to `ri Socket::Constants` from command line which is a good way to get the description
    of each constant.
  prefs: []
  type: TYPE_NORMAL
- en: Socket Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SOCK_RAW
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOCK_PACKET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOCK_STREAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOCK_DRAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOCK_RDM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOCK_SEQPACKET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address Families(Socket Domains)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AF_APPLETALK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_ATM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_AX25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_CCITT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_CHAOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_CNT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_COIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_DATAKIT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_DEC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_DLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_E164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_ECMA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_HYLINK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_IMPLINK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_INET(IPv4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_INET6(IPv6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_IPX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_ISDN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_ISO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_LAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_LINK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_LOCAL(UNIX)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_MAX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_NATM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_NDRV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_NETBIOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_NETGRAPH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_NS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_OSI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_PACKET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_PPP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_PUP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_ROUTE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_SIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_SNA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_SYSTEM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_UNIX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AF_UNSPEC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPPROTO_SCTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPPROTO_TCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPPROTO_UDP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol Families
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PF_APPLETALK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_ATM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_AX25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_CCITT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_CHAOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_CNT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_COIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_DATAKIT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_DEC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_DLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_ECMA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_HYLINK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_IMPLINK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_INET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_INET6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_IPX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_ISDN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_ISO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_KEY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_LAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_LINK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_LOCAL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_MAX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_NATM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_NDRV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_NETBIOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_NETGRAPH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_NS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_OSI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_PACKET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_PIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_PPP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_PUP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_ROUTE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_RTIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_SIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_SNA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_SYSTEM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_UNIX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_UNSPEC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PF_XTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SO_ACCEPTCONN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_ACCEPTFILTER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_ALLZONES
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_ATTACH_FILTER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_BINDTODEVICE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_BINTIME
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_BROADCAST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_DEBUG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_DETACH_FILTER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_DONTROUTE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_DONTTRUNC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_ERROR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_KEEPALIVE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_LINGER
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_MAC_EXEMPT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_NKE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_NOSIGPIPE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_NO_CHECK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_NREAD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_OOBINLINE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_PASSCRED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_PEERCRED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_PEERNAME
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_PRIORITY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_RCVBUF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_RCVLOWAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_RCVTIMEO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_RECVUCRED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_REUSEADDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_REUSEPORT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_SECURITY_AUTHENTICATION
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_SECURITY_ENCRYPTION_NETWORK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_SECURITY_ENCRYPTION_TRANSPORT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_SNDBUF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_SNDLOWAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_SNDTIMEO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_TIMESTAMP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_TIMESTAMPNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_TYPE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_USELOOPBACK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_WANTMORE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SO_WANTOOBFLAG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Socket Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**domain(Address\/Protocol Families):** like AF_INET, PF_PACKET, etc'
  prefs: []
  type: TYPE_NORMAL
- en: '**socktype:** like SOCK_RAW, SOCK_STREAM'
  prefs: []
  type: TYPE_NORMAL
- en: '**protocol:** by default, it''s `0`m it should be a protocol defined (we''ll
    manipulate that later)'
  prefs: []
  type: TYPE_NORMAL
- en: TCP Socket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Server\/Client life cycle**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: General Socket usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Get List of local IPaddreses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Get Hostname
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: TCP Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we'll represent an absolute TCP server. This server will access connect
    from one client and send a message to it once connected then close the client
    and server connection
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:** if you want to list on unused and random port, set to port 0, ruby
    will find vacancy port then use it. ex.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: TCP Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can put timeout/time interval for current connection in-case the server's
    response get delayed and the socket is still open.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are some alternatives for `puts` and `gets` methods.You can see the difference
    and its classes using method method in Pry interpreter console
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: UDP Socket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UDP Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: UDP Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There alternative for sending and receiving too, figure it out, [RubyDoc](http://ruby-doc.org/stdlib-2.0.0/libdoc/socket/rdoc/UDPSocket.html).
  prefs: []
  type: TYPE_NORMAL
- en: GServer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GServer standard library implements a generic server, featuring thread pool
    management, simple logging, and multi-server management. Any kind of application-level
    server can be implemented using this class:'
  prefs: []
  type: TYPE_NORMAL
- en: It accepts multiple simultaneous connections from clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several services (i.e. one service per TCP port)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: can be run simultaneously,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: can be stopped at any time through the class method `GServer.stop(port)`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All the threading issues are handled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All events are optionally logged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very basic GServer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: SSL/TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSL/TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with SSL/TLS connections is a very important job and it comes in tow
    shapes. **(1)** Secure HTTP connection. **(2)** Secure Socket. To reduce the redundancy,
    I'll deal with both in this section, instead of putting the http part under Web
    Kung Fu section.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validate HTTPS Certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**validate_https_cert.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Validate Secure Socket Certificate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**validate_socket_cert.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Putting all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ssl_validator.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: SSID Finder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSID Finder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s good to know how you play with a lower level of Ruby socket and see how
    powerful it''s. As I''ve experienced, it''s a matter of your knowledge about the
    protocol you''re about to play with. I''ve tried to achieve this mission using
    `Packetfu` gem, but it''s not protocol aware, yet. So I fired-up my Wireshark(filter:
    `wlan.fc.type_subtype == 0x08`) and start inspecting the wireless beacon structure
    and checked how to go even deeper with Ruby socket to lower level socket not just
    playing with TCP and UDP sockets.'
  prefs: []
  type: TYPE_NORMAL
- en: The main task was
  prefs: []
  type: TYPE_NORMAL
- en: Go very low level socket(Layer 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive every single packet no matter what protocol is it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive packets as raw to process it as far as I learn from wireshark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I went through all mentioned references below and also I had a look at `/usr/include/linux/if_ether.h`
    which gave me an idea about `ETH_P_ALL` meaning and more. In addition, `man socket`
    was really helpful to me.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** The Network card interface must be set in monitoring mode, to do
    so (using airmon-ng)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**References** - *very useful!*'
  prefs: []
  type: TYPE_NORMAL
- en: '[raw_socket.rb](https://gist.github.com/k-sone/8036832#file-raw_sock-rb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[wifi_sniffer.rb](https://gist.github.com/amejiarosario/5420854)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[packetter.rb](https://github.com/lrks/packetter/blob/master/ruby/packetter.rb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Another git](https://gist.github.com/sam113101/aad031bcc50746956a29)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Programming Ruby1.9](http://media.pragprog.com/titles/ruby3/app_socket.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rubydocs - class Socket](http://docs.ruby-lang.org/en/2.3.0/Socket.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linux Kernel Networking – advanced topics (5)](http://www.haifux.org/lectures/217/netLec5.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PF_PACKET Protocol Family](http://curioushq.blogspot.com/2011/05/pfpacket-protocol-family.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Ruby Raw Socket for Windows](http://curioushq.blogspot.com/2011/05/ruby-raw-socket-for-windows.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dealing with FTP is something needed in many cases, Let's see how easy is that
    in Ruby with AIO example.
  prefs: []
  type: TYPE_NORMAL
- en: FTP Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Yep, it's simple as that, easy and familiar.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP:** You can do it all above way using pure socket library, it''s really
    easy. You may try to do it.'
  prefs: []
  type: TYPE_NORMAL
- en: FTP Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install ftpd gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we'll show some SSH using ruby. We'll need to install net-ssh gem for that.
  prefs: []
  type: TYPE_NORMAL
- en: Install net-ssh gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Simple SSH command execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a very basic SSH client which sends and executes commands on a remote
    system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: SSH Client with PTY shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here a simple SSH client which give you an interactive PTY
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: SSH brute force
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ssh-bf.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: SSH Tunneling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forward SSH Tunnel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Run ssh-ftunnel.rb on the **SSH Server**
  prefs: []
  type: TYPE_NORMAL
- en: '**ssh-ftunnel.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now connect to the **SSH Server** on port 3333 via your RDP client, you'll be
    prompt for the **WebServer**'s RDP log-in screen
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Reverse SSH Tunnel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Run ssh-rtunnel.rb on the **SSH Server**
  prefs: []
  type: TYPE_NORMAL
- en: '**ssh-rtunnel.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now SSH from the **SSH Server** to **localhost** on the localhost's SSH port
    then connect from your localhost to your localhost on port 3333 via your RDP client,
    you'll be prompt for the **WebServer**'s RDP log-in screen
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Copy files via SSH (SCP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install scp gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upload file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Download file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[More SSH examples](http://ruby.about.com/sitesearch.htm?q=ruby+ssh&boost=3&SUName=ruby)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Capistranorb.com](http://capistranorb.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Net:SSH old docs with example](http://net-ssh.github.io/ssh/v1/chapter-6.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending Email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**sendmail.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Reading Email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**readmail.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[More useful mail operation example | alvinalexander.com](http://alvinalexander.com/search/node/ruby%20mail)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMTP Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SMTP Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting with SMTP is easy and since the protocol is straight forward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Your turn**, there are other commands that can be used such as `EXPN`, `RCPT`.
    Enhance the above script to include all these commands to avoid restricted commands
    that might you face. Tweet your code and output to **@Rubyfu**.'
  prefs: []
  type: TYPE_NORMAL
- en: Network Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network ping sweeping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: required net-ping gem
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Port Scanner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you got what we've represented in [Ruby Socket](module_0x3__network_kung_fu/ruby_socket.md)
    section, then here we wrapping up and do some application depends on it. **scanner.rb**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As far as you understand how to use nmap and how basically it works, you'll
    find this lib is easy to use. You can do most of nmap functionality
  prefs: []
  type: TYPE_NORMAL
- en: Basic Scan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ruby-nmap gem is a Ruby interface to nmap, the exploration tool and security
    / port scanner.
  prefs: []
  type: TYPE_NORMAL
- en: Provides a Ruby interface for running nmap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a Parser for enumerating nmap XML scan files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: let's see how it dose work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: SYN Scan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: each option like `nmap.syn_scan` or `nmap.xml` is considered as a *Task*. [Documentation](http://www.rubydoc.info/gems/ruby-nmap/frames
    "Official doc") shows the list of [scan tasks/options](http://www.rubydoc.info/gems/ruby-nmap/Nmap/Task)
    that are supported by the lib.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive scan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Parsing nmap XML scan file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I made an aggressive scan on `scanme.nmap.org`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: I quoted the code from official documentation ([https://github.com/sophsec/ruby-nmap](https://github.com/sophsec/ruby-nmap))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/ronin-ruby/ronin-scanners](https://github.com/ronin-ruby/ronin-scanners)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS lookup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Forward DNS lookup (Host to IP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Returns array of all IPs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: or use `Resolv.getaddress` to get one address only
  prefs: []
  type: TYPE_NORMAL
- en: Reverse DNS lookup (IP to Host)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Returns array of all hostnames, if PTR is assigned
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: or use `Resolv.name` to get one name only
  prefs: []
  type: TYPE_NORMAL
- en: DNS Data Exfiltration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DNS out-band connection is usually allowed in local networks, which is the major
    benefits of using DNS to transfer data to external server.
  prefs: []
  type: TYPE_NORMAL
- en: '**dnsteal.rb**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Run it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[dnsteal.py](https://github.com/m57/dnsteal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In ruby script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Forward DNS lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main usage is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from response above, there are 5 sections
  prefs: []
  type: TYPE_NORMAL
- en: '**Header section:** DNS lookup headers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Question section:** DNS question,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Answer section:** Array of the exact lookup answer (base on lookup type.
    ex. A, NS, MX , etc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authority section:** Array of authority nameserver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional section:** Array array of nameserver lookup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since its all are objects, we can call each section like that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: A record
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because the *A* record is the default, we can do like above example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: or in one line to get exact **`answer`**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: will return an array with all IPs assigned to this domain
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: MX lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: returns an array
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: All lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: returns
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: for list of types, please refer to the [gem docs](http://www.rubydoc.info/gems/net-dns/Net/DNS/RR/Types)
  prefs: []
  type: TYPE_NORMAL
- en: Reverse DNS lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If you want to specify the nameserver(s) to use, it support an array of nameserver
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: or update the object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://searchsignals.com/tutorials/reverse-dns-lookup/](http://searchsignals.com/tutorials/reverse-dns-lookup/)'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SNMP Enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Install ruby-snmp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Get Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Miss configure an SNMP service would gives an attacker a huge mount of information.
    Let's to see you we can interact with the server to retrieve some info.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: the OID names are case sensitive'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we get luck and we get the private/management string of SNMP. At this
    moment we might be able to apply changes on the system, router, switches configurations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Packet Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packet manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll try to do variant implementations using the awesome lib,
    PacketFu^([1](#fn_1)).
  prefs: []
  type: TYPE_NORMAL
- en: PacketFu - The packet manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PacketFu Features**'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating TCP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating UDP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating ICMP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet Capturing - Support TCPdump style^([2](#fn_2))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and write PCAP files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PacketFu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before installing packetfu gem you'll need to install `ruby-dev` and `libpcap-dev`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: then install packetfu and pcaprub(required for packet reading and writing from
    network interfaces)
  prefs: []
  type: TYPE_NORMAL
- en: Install packetfu & pcaprub gems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Basic Usage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Get your interface information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Get MAC address of a remote host
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Read Pcap file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Building TCP Syn packet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Simple TCPdump
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lets see how we can
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Simple IDS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a simple IDS will print source and destination of any communication
    has "hacked" payload
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Now try to Netcat any open port then send hacked
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¹. [PacketFu Homepage](https://github.com/packetfu/packetfu) [↩](#reffn_1 "Jump
    back to footnote [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ². [TCPdump Cheat sheet](http://packetlife.net/media/library/12/tcpdump.pdf)
    [↩](#reffn_2 "Jump back to footnote [2] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ARP Spoofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ARP Spoofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know, ARP Spoofing attack in the core of MitM attacks. In this part we'll
    know how to write simple and effective ARP spoofer tool to use it in later spoofing
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have 3 machines in this scenario as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Here the list of IP and MAC addresses of each of theme in the following table^([1](#fn_1))
  prefs: []
  type: TYPE_NORMAL
- en: '| Host/Info | IP Address | MAC Address |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Attacker | 192.168.0.100 | 3C:77:E6:68:66:E9 |'
  prefs: []
  type: TYPE_TB
- en: '| Victim | 192.168.0.21 | 00:0C:29:38:1D:61 |'
  prefs: []
  type: TYPE_TB
- en: '| Router | 192.168.0.1 | 00:50:7F:E6:96:20 |'
  prefs: []
  type: TYPE_TB
- en: To know our/attacker's interface information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: returns a hash
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: So you can extract these information like any hash `info[:iface]`, `info[:ip_saddr]`,
    `info[:eth_saddr]`, etc..
  prefs: []
  type: TYPE_NORMAL
- en: '**Building victim''s ARP packet**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '**Building router packet**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '**Run ARP Spoofing attack**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Source^([2](#fn_2))
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping all together and run as `root`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: Don''t forget to enable packet forwarding on your system to allow victim
    to browse internet.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`echo "1" > /proc/sys/net/ipv4/ip_forward`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Returns, time to wiresharking ;)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¹. Create table the easy way - [Table Generator](http://www.tablesgenerator.com/markdown_tables)
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '². Source: [DNS Spoofing Using PacketFu](http://crushbeercrushcode.org/2012/10/ruby-dns-spoofing-using-packetfu/)
    [↩](#reffn_2 "Jump back to footnote [2] in the text.")'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: DNS Spooging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS Spoofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing our attack through [ARP Spoofing](module_0x4__network_kung_fu/arp_spoofing.md),
    we want to change the victim's DNS request to whatever destination we like.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Keep the ARP spoof attack running
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The same IPs of ARP spoof attack
  prefs: []
  type: TYPE_NORMAL
- en: '| Host | IP Address |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Attacker | 192.168.0.100 |'
  prefs: []
  type: TYPE_TB
- en: '| Victim | 192.168.0.21 |'
  prefs: []
  type: TYPE_TB
- en: '| Router | 192.168.0.1 |'
  prefs: []
  type: TYPE_TB
- en: Now we cant intercept DNS Query packet coming from victim's machine. Since PacketFu
    supports filters in capturing (to reduce mount of captured packets) we'll use
    `udp and port 53 and host` filter, then we'll inspect the captured packet to ensure
    that it's a query then find the requested domain. [**Download DNS packet**](../files/module03/dns_spoofing_dns-req_res.pcap.pcapng).
  prefs: []
  type: TYPE_NORMAL
- en: From Wireshark, if we take a deeper look at the DNS query payload in `Domain
    Name System (query)`, we can see its been presented in hexadecimal format.
  prefs: []
  type: TYPE_NORMAL
- en: '| ![](dns_spoofing_wireshark1.png) |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Figure 1.** DNS query Payload |'
  prefs: []
  type: TYPE_TB
- en: Let's to anatomize our payload
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The First 2 bytes is the **Transaction ID** and we don''t care about it for
    now. (Our case: `\xe7\x1d`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next 2 bytes is the **Flags**^([3](#fn_3)). (We need: `\x01\x00` = \x10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, in **Queries** section which contains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The **Queries** starts at *13 byte* of the payload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The 13th byte specifies the length of the domain name *before* the *very first
    dot* (without last dot com or whatever the top domain is). (Our case: `\x07`)
    **Try:**`[%w{ 74 77 69 74 74 65 72 }.join].pack("H*")`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice The domain name of "twitter.com" equals `\x07` but "www.twitter.com"
    equals `\x03` the same consideration for subdomains
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each dot after first dot will be replaced with the length of the followed characters
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**e.g.** www.google.co.uk'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: First length (**www**) => will be replaced with `\x03`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: First dot(**.google**) => will be replaced with `\x06`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Second dot(**.co**) => will be replaced with `\x02`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Third dot(**.uk**) => will be replaced with `\x02`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The very end of the domain name string is terminated by a `\x00`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next 2 bytes refers to the **type of the query**^([4](#fn_4)). (Our case:
    `\x00\x01`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Now what?!**'
  prefs: []
  type: TYPE_NORMAL
- en: We need to start capturing/sniffing on specific interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to enable promiscuous mode on our interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to capture UDP packets on port 53 only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need parse/analyze the valid UDP packets only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to make sure this packet is a DNS query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to get the queried/requested domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to know the domain length
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to get the FQDN
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a DNS response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the requested domain with any domain we want
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re inject the packet into victim connection and send
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'll divide our tasks then wrap it up in one script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Till now we successfully finished [ARP Spoofing](module_0x3__network_kung_fu/arp_spoofing.md)
    then DNS capturing but still we need to replace/spoof the original response to
    our domain. e.g. attacker.zone, now we have to build a DNS response instead of
    spoofed to be sent. So what we need?
  prefs: []
  type: TYPE_NORMAL
- en: taking the IP we are going to redirect the user to (the spoofing_ip)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: converting it into hex using the `to_i` and `pack` methods.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From there we create a new UDP packet using the data contained in `@ourInfo`
    (IP and MAC) and fill in the normal UDP fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I take most of this information straight from the DNS Query packet.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is to create the DNS Response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the best way to understand the code here is to look at a DNS header and then
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: take the bit map of the HEX values and apply them to the header.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This will let you see what flags are being set.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From here, we just calculate the checksum for the UDP packet and send it out
    to the target's machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| ![Wireshark](dns_spoofing_wireshark2.png) |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Figure 2.** DNS Response Payload |'
  prefs: []
  type: TYPE_TB
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping up
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[https://github.com/SilverFoxx/Spoofa/blob/master/spoofa](https://github.com/SilverFoxx/Spoofa/blob/master/spoofa)'
  prefs: []
  type: TYPE_NORMAL
- en: Sources^([1](#fn_1)) ^([2](#fn_2)) - The code has been modified and fixed
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¹. [DNS Spoofing Using PacketFu](http://crushbeercrushcode.org/2012/10/ruby-dns-spoofing-using-packetfu/)
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ². [Manipulating The Network with PacketFu](http://tuftsdev.github.io/DefenseOfTheDarkArts/assignments/manipulatingthenetworkwithpacketfu-110314111058-phpapp01.pdf)
    [↩](#reffn_2 "Jump back to footnote [2] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ³. [DNS Header Flags](http://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-12)
    [↩](#reffn_3 "Jump back to footnote [3] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Bit | Flag | Description | Reference |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bit 5 | AA | Authoritative Answer | [RFC1035] |'
  prefs: []
  type: TYPE_TB
- en: '| bit 6 | TC | Truncated Response | [RFC1035] |'
  prefs: []
  type: TYPE_TB
- en: '| bit 7 | RD | Recursion Desired | [RFC1035] |'
  prefs: []
  type: TYPE_TB
- en: '| bit 8 | RA | Recursion Allowed | [RFC1035] |'
  prefs: []
  type: TYPE_TB
- en: '| bit 9 |  | Reserved |  |'
  prefs: []
  type: TYPE_TB
- en: '| bit 10 | AD | Authentic Data | [RFC4035] |'
  prefs: []
  type: TYPE_TB
- en: '| bit 11 | CD | Checking Disabled | [RFC4035] |'
  prefs: []
  type: TYPE_TB
- en: ⁴. [DNS Lookups Types](http://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4)
    [↩](#reffn_4 "Jump back to footnote [4] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '| Type | Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| A | 1 | IP Address |'
  prefs: []
  type: TYPE_TB
- en: '| NS | 2 | Name Server |'
  prefs: []
  type: TYPE_TB
- en: '| CNAME | 5 | Alias of a domain name |'
  prefs: []
  type: TYPE_TB
- en: '| PTR | 12 | Reverse DNS Lookup using the IP Address |'
  prefs: []
  type: TYPE_TB
- en: '| HINFO | 13 | Host Information |'
  prefs: []
  type: TYPE_TB
- en: '| MX | 15 | MX Record |'
  prefs: []
  type: TYPE_TB
- en: '| AXFR | 252 | Request for Zone Transfer |'
  prefs: []
  type: TYPE_TB
- en: '| ANY | 255 | Request for All Records |'
  prefs: []
  type: TYPE_TB
- en: MiTM Attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Man in the Middle Attack (MiTM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Example of a more elaborate MiTM attack using ARP Poisoning with PacketFU and
    socket using source code in this book as base.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Source: [Ruby-MiTM](https://github.com/ChrisFernandez/ruby-mitm "Ruby-mitm")
    and Rubyfu [ARP Spoofing topic](arp_spoofing.html).'
  prefs: []
  type: TYPE_NORMAL
