- en: 'Chapter 25: Numerical Integration'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第25章：数值积分
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: We can easily set up a spreadsheet to evaluate a given integrand f at a large
    number of points in the range from a to b, and to form Riemann sums. A symmetric
    way to do this is the "trapezoid rule" that approximates the area in a strip by
    the area in the trapezoid with the same height at either end of the given interval.
    We explore this rule and more accurate extrapolations. The first of these is called
    Simpson's rule.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地设置一个电子表格来评估给定积分f在从a到b的大量点，并形成黎曼和。一个对称的做法是“梯形法则”，它通过在给定区间的两端具有相同高度的梯形的面积来近似条带中的面积。我们探讨了这个规则和更准确的外推。其中一个被称为辛普森法则。
- en: Topics
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主题
- en: 25.1  [The Trapezoid Rule](section01.html)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 25.1  [梯形法则](section01.html)
- en: 25.2  [Simpson's Rule](section02.html)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 25.2  [辛普森法则](section02.html)
- en: 25.3  [Extrapolations and Better Approximations](section03.html)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 25.3  [外推和更好的逼近](section03.html)
- en: 25.4  [Numerical Evaluation of Line Integrals](section04.html)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 25.4  [线积分的数值评估](section04.html)
- en: 25.5  [Doing Flux (Surface) Integrals on a Spreadsheet](section05.html)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 25.5  [在电子表格上执行通量（表面）积分](section05.html)
- en: 25.1 The Trapezoid Rule
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.1 梯形法则
- en: The problem we face is that of finding **the area between a curve described
    by the equation y = f(x) and the x-axis in a finite interval [a, b].**
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的问题是在有限区间[a, b]内找到**由方程y = f(x)描述的曲线与x轴之间的面积。**
- en: We use the approach that we have used to define the integral. When f is continuous
    in the interval, we divide it into N subintervals, each of width ![](../Images/4f5e0b41767718ffa879967219fe65b6.jpg)which
    we will call d, (we assume b > a) and evaluate f at the endpoints of each of these
    intervals, a + jd for j from 0 to N.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用了定义积分的方法。当f在区间内连续时，我们将其分成N个子区间，每个宽度为![](../Images/4f5e0b41767718ffa879967219fe65b6.jpg)，我们将其称为d，（我们假设b
    > a），并评估f在每个区间的端点，从a + jd到N为止。
- en: '**When f is only piecewise continuous, you should first break the interval
    into subintervals in which f is continuous and proceed as we discuss in each of
    these.**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**当f只有分段连续时，您应该先将区间分成f连续的子区间，然后按照我们在每个区间中讨论的方式继续。**'
- en: The **trapezoid rule** consists in approximating the area of each subinterval
    by its width d multiplied by the average of the values of f at its endpoints.
    For the j-th interval this is
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**梯形法则**包括将每个子区间的面积近似为其宽度d乘以其端点处f值的平均值。对于第j个区间，这是'
- en: '![](../Images/6648654172847e6ea1270787aa215e61.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6648654172847e6ea1270787aa215e61.jpg)'
- en: '**We now address the questions: why do this?**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们来回答这个问题：为什么要这样做？**'
- en: '**Is it better to use this trapezoid rule than say, to choose a point x'' at
    random in the j-th interval and compute d * f(x'') as the contribution to the
    area from that interval?**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**是否比起选择一个随机点x''在第j个区间中计算d * f(x'')作为该区间对面积的贡献来说，使用这个梯形法则更好？**'
- en: To get a partial answer to this question, consider **one interval of width d
    and center at x[j]** and for convenience we set x[j] = 0.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要对这个问题得到部分答案，请考虑**一个宽度为d、中心在x[j]处的区间**，为了方便起见，我们将x[j]设为0。
- en: Then the interval begins at ![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)
    and ends at ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后区间开始于![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)，并在![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)结束。
- en: Suppose now we can expand our integrand f in a power series about x, with results
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们可以在x周围用幂级数展开我们的被积函数f，结果是
- en: f(x) = f(0) + ax + bx² + cx³ + ex⁴ + ...
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: f(x) = f(0) + ax + bx² + cx³ + ex⁴ + ...
- en: The actual area under this function in this interval will be
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个区间内这个函数的实际面积将是
- en: '![](../Images/f9151ce4cb269d9a2f8183a488f19fc6.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f9151ce4cb269d9a2f8183a488f19fc6.jpg)'
- en: '(Here the factor ![](../Images/5b814ed740e82e673036174062ff3be2.jpg) arises
    as follows: there are identical contributions from the endpoints ![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)
    and ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg) which are each ![](../Images/e5ba4c26d7cbeaf2bf5f2468145e60f6.jpg).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: （这里的因子![](../Images/5b814ed740e82e673036174062ff3be2.jpg)的产生如下：端点![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)和![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)各有相同的贡献，每个为![](../Images/e5ba4c26d7cbeaf2bf5f2468145e60f6.jpg)。）
- en: The factor ![](../Images/e3e9eee02c13276a499f8bf4cdff843d.jpg) comes about similarly.
    **Notice that the ax and other odd power terms in f do not contribute at all here
    because they are odd and their contributions cancel out.)**
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因子![](../Images/e3e9eee02c13276a499f8bf4cdff843d.jpg)的产生方式类似。**请注意，在这里ax和其他奇数次幂项在这里根本不贡献，因为它们是奇数的，它们的贡献会相互抵消。）**
- en: '**The trapezoid rule that we have described, on the other hand, gives the following
    proposed answer for this area**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '**![](../Images/88abfe0f331102022e506bdd6597bedb.jpg)**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**The contribution from f(0) is exactly right, that from b is a factor of three
    too large, and that from e is a factor of 5 too large.**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Notice that any estimation here that is symmetric about 0 will get the odd
    (a, c, ...) terms right.**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In particular we could use the **"midpoint rule"** which approximates the area
    as f(0)d, and this gets the a, c, ... contributions right but gets nothing at
    all from the b, e, ... terms.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The symmetry which causes the a and c terms to cancel out is the great advantage
    that the trapezoid rule possesses here and it shares it with the midpoint rule.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Consider what happens if we decrease d by a factor of 2** (or any other factor
    z). Because of this symmetry, **the error in the trapezoid rule or the midpoint
    rule goes down by a factor of 2³ for each interval, but now there are two intervals
    where only one was before.**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: This error must therefore be **doubled to have a comparison over the original
    interval,** and **the actual error in either the trapezoid rule or the midpoint
    rule goes down by a factor of 4 in any one interval from the b term,** and even
    more from the e and further terms.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**25.1 Set up a spreadsheet that divides a given interval a to b into N equal
    subintervals, evaluates a given function, say sin x at each of the N + 1 interval
    endpoints, and calculates the Trapezoid rule evaluation of the resulting integral.**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**25.2 Make a spreadsheet with the capability of computing this evaluation
    for N = 1, 2, 4, 8, 16, and 32 simultaneously. (You can put them next to each
    other by starting with 32 and entering the instruction =if(mod(j,2^k)=0,2*prev
    column entry,0), with j the index of the subinterval end and k the column index.
    Each increase in k by 1 will decrease the number of trapezoid intervals by a factor
    of 2.)**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 25.2 Simpson's Rule
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the notation of the last section the actual area under the function f in
    the interval between ![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg) and ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)
    will be
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/46d24ee2f1f51a82a25641688c627ddb.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: The trapezoid rule that we have described, on the other hand, gives the following
    proposed answer for this area
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/feefa1f2cab42840444bd64e0c87a9ac.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: while the "midpoint rule" approximates the area as f(0)d.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: This means that **if we mix two parts of the midpoint rule and one part of the
    trapezoid rule, we will get the quadratic b term exactly right,** and the leading
    term in the error will come from the e term which will be on the order of d⁴.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '**The rule for approsimating integrals just described is called Simpson''s
    rule, and it takes the following form in the interval between ![](../Images/b9c249e945dc0581feee41673a53efff.jpg)
    and ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg)**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82d8946f8b4bfdd190c0d18427130604.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/82d8946f8b4bfdd190c0d18427130604.jpg)'
- en: '**Notice that in this formula f is evaluated at intervals ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg)
    apart**. If we give the parameter ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)
    a new name here, calling it h, the Simpson''s rule formula in terms of h becomes'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意，在这个公式中，f 在间隔为 ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg) 的位置进行评估**。如果我们在这里给参数
    ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg) 一个新名称，称之为 h，那么辛普森法则的公式变为'
- en: '![](../Images/8f193f222b265837f197ed6e1aed3ef7.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8f193f222b265837f197ed6e1aed3ef7.jpg)'
- en: and it represents an approximation to the area under the curve defined by f
    in the interval from -h to h; an approximation whose error is of fourth order
    in h.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表了对由 f 在从 -h 到 h 的区间内定义的曲线下面积的逼近；一个其误差与 h 的四次方成正比的逼近。
- en: It is worthwhile noticing what these various rules look like when applied to
    a number of small subintervals in a row.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当应用于一系列小子间隔时，这些各种规则的外观是什么样子的。
- en: The trapezoid rule gives equal weight d to evaluations at all intermediate points,
    since each is the left end and the right end of one subinterval and it **gets
    ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg) weight from each end.**
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 梯形法则给予所有中间点的评估相等的权重 d，因为每个点都是一个子间隔的左端点和右端点，它**从每个端点获得 ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg)
    的权重。**
- en: The end two evaluations on the other hand are ends of only one subinterval each,
    and **these get weight ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg).**
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，最后两个评估只是一个子间隔的末端，**这些获得权重为 ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg)。**
- en: The midpoint rule gives equal weight to the odd numbered evaluations of d or
    2h.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 中点法则给予奇数次评估 d 或 2h 相等的权重。
- en: '**Simpson''s rule gives weights that form the pattern 1 4 2 4 2 ... 4 1 multiplied
    by ![](../Images/aed297b225b0463bf3774b5df7565b91.jpg), since the midpoints get
    weight ![](../Images/49e792c28a53f3732fb9053c86698bc7.jpg) and the trapezoid rule
    divided by 3 accounts for the rest.**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**辛普森法则给出的权重形成模式 1 4 2 4 2 ... 4 1 乘以 ![](../Images/aed297b225b0463bf3774b5df7565b91.jpg)，因为中点获得权重
    ![](../Images/49e792c28a53f3732fb9053c86698bc7.jpg)，而梯形法则除以 3 解释了其余部分。**'
- en: '|  | endpointa | midpoint first intervala + h | end first intervala + 2h |
    midpoint second intervala + 3h | end second intervala + 4h | etc. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  | 端点a | 第一个间隔的中点a + h | 第一个间隔的末端a + 2h | 第二个间隔的中点a + 3h | 第二个间隔的末端a + 4h
    | 等。 |'
- en: '| Trapezoid rule terms | hf(a) | 0 | 2hf(a + 2h) | 0 | 2hf(a + 4h) | etc. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 梯形法则项 | hf(a) | 0 | 2hf(a + 2h) | 0 | 2hf(a + 4h) | 等。 |'
- en: '| Midpoint rule terms | 0 | 2hf(a + h) | 0 | 2hf(a + 3h) | 0 | etc. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 中点法则项 | 0 | 2hf(a + h) | 0 | 2hf(a + 3h) | 0 | 等。 |'
- en: '| Simpson''s rule terms | ![](../Images/4082a090b51e10b925a3d3896a92c83e.jpg)
    | ![](../Images/891358600490512a6a809d0ee14ec4d8.jpg) | ![](../Images/818cf85ac94e6b33825d80a7e0fed1f9.jpg)
    | ![](../Images/5a98c1d838f19c240545a5fbe3788bce.jpg) | ![](https://ocw.mit.edu/ans7870/18/18.013a/textbook/HTML/chapter25/equations/sections_eqn22.gif)
    | etc. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 辛普森法则项 | ![](../Images/4082a090b51e10b925a3d3896a92c83e.jpg) | ![](../Images/891358600490512a6a809d0ee14ec4d8.jpg)
    | ![](../Images/818cf85ac94e6b33825d80a7e0fed1f9.jpg) | ![](../Images/5a98c1d838f19c240545a5fbe3788bce.jpg)
    | ![](https://ocw.mit.edu/ans7870/18/18.013a/textbook/HTML/chapter25/equations/sections_eqn22.gif)
    | 等。 |'
- en: Notice that the leading term in the power series for f that produces an error
    in Simpson's rule is the ex⁴ term, and **that produces an error which goes down
    by a factor of 16 if we divide our intervals in half.**
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在为 f 生成辛普森法则中产生误差的幂级数中，主导项是 ex⁴ 项，**如果我们将间隔减半，这将导致误差减少 16 倍。**
- en: <applet code="NumericalIntegration" codebase="../applets/" archive="numericalIntegration.jar,mk_lib.jar,parser_math.jar,jcbwt363.jar"
    width="760" height="450"></applet>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <applet code="NumericalIntegration" codebase="../applets/" archive="numericalIntegration.jar,mk_lib.jar,parser_math.jar,jcbwt363.jar"
    width="760" height="450"></applet>
- en: 25.3 Extrapolations and Better Approximations
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.3 外推和更好的逼近
- en: We saw when discussing numerical differentiation that when we have a sequence
    of numbers which are approximations to a number A **whose errors decrease by a
    given factor r from term to term,** we can extrapolate the sequence to get a more
    rapidly converging one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论数值微分时看到，当我们有一系列数字，这些数字是对一个数字 A 的逼近，**其误差从项到项按给定因子 r 减少时，我们可以外推这个序列，以获得一个更快收敛的序列。**
- en: 'The general extrapolation rule is: **to get rid of errors that decrease by
    a factor of z, take the current result times z minus the previous result and divide
    this difference by z - 1.**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的外推规则是：**为了消除按因子 z 减少的误差，将当前结果乘以 z 减去前一个结果，然后将此差异除以 z - 1。**
- en: Here for example, if we look at the answers provided by the trapezoid rule for
    values 16d, 8d, 4d, 2d, d, say, we get a sequence of approximate answers whose
    errors can be expected to decrease by a factor of roughly 4 each time. If we denote
    these answers as ![](../Images/e08122572eec913bfccd5015394f7d24.jpg) and look
    at the sequence ![](../Images/ebd8418ce531aeefec773ee80fea5c02.jpg), (for j =
    2 to 5) the terms in A that go down as a factor of 4 will cancel out in each B
    and we will be left with the higher order terms only.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们查看梯形法则提供的答案，对于值16d、8d、4d、2d、d，我们得到一个近似答案序列，其误差可以预期每次减少大约4倍。如果我们将这些答案表示为![](../Images/e08122572eec913bfccd5015394f7d24.jpg)，并查看序列![](../Images/ebd8418ce531aeefec773ee80fea5c02.jpg)，（对于
    j = 2 到 5），那么在每个 B 中下降为 4 倍的 A 项将在每个 B 中抵消掉，我们只会留下更高阶的项。
- en: If we apply this procedure here to the trapezoid rule, we get the Simpson's
    rule approximations previously defined.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里将这个过程应用于梯形法则，我们得到了先前定义的辛普森法则近似。
- en: '**Exercise 25.3** **Verify this statement.**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 25.3** **验证这个说法。**'
- en: But we know that the leading terms in Simpson's rule decrease by a factor of
    16 each time and we can play the same game with them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们知道辛普森法则中领先的项每次减少16倍，我们可以用同样的方法来玩它们。
- en: We can form ![](../Images/0b0d3341080eeec5116b7b5b7989ade6.jpg) defined by ![](../Images/1acae4732e6866813275d4e027298de9.jpg),
    for j = 3 to 5, and get a "Super Simpson's rule approximation", the leading terms
    in which (in the power series expansion) decrease by 64 from term to term.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以形成![](../Images/0b0d3341080eeec5116b7b5b7989ade6.jpg)，由![](../Images/1acae4732e6866813275d4e027298de9.jpg)定义，对于j
    = 3到5，并得到一个“超级辛普森法则近似”，其中（在幂级数展开中）领先的项每次减少64。
- en: 'Well we can keep this up twice more: and get ![](../Images/cd5a0d718bac703f1813aa6ba5f8960f.jpg)
    for j = 4 and 5, and ![](../Images/89983ffa875559ed30822e5928ca5d57.jpg), and
    this is about the best we can do as an approximation with 16 intervals.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再继续这样做两次：得到对于j = 4和5的![](../Images/cd5a0d718bac703f1813aa6ba5f8960f.jpg)，以及![](../Images/89983ffa875559ed30822e5928ca5d57.jpg)，这大约是我们用16个区间进行近似的最好的结果。
- en: '**Exercises:**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：**'
- en: '**25.4 Use the results of Exercise 25.2 which give the A''s to compute the
    B''s to E''s. Compare their accuracy on an integral whose value you know. (For
    example sin x from x = 0 to 1.)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**25.4 使用练习 25.2 的结果来计算 A 到 E。在你知道值的积分上比较它们的准确性。（例如 sin x 从 x = 0 到 1。）**'
- en: Please be aware that these methods while very good are particularly effective
    on sin x.**
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然这些方法非常好，但在sin x上特别有效。**
- en: '**25.5 Can you find a function for which this approach to integrating is lousy?
    What might you do to improve it?**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**25.5 你能找到一个这种积分方法很糟糕的函数吗？你可以怎么改进它？**'
- en: 25.4 Numerical Evaluation of Line Integrals
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.4 线积分的数值评估
- en: Suppose we confront a line integral, which is an integral along a path in some
    Euclidean space, of a vector field **v**![](../Images/942a415c6b0fa1fa8b2f7d2d2c8c225a.jpg)**ds**
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们面对一条线积分，这是沿着欧几里得空间中某条路径的积分，其中向量场**v**为![](../Images/942a415c6b0fa1fa8b2f7d2d2c8c225a.jpg)**ds**。
- en: '![](../Images/61f9cc97bb28e966f6fe6341b3c2bc02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/61f9cc97bb28e966f6fe6341b3c2bc02.jpg)'
- en: We can set up a spreadsheet to evaluate such an integral with very little difficulty.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个电子表格来评估这样的积分，而几乎没有困难。
- en: In this section we describe how this can be done, and attempt to goad you into
    doing one yourself on a spreadsheet.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了如何实现这一点，并试图怂恿你自己在电子表格上做一些类似的事情。
- en: By the way, once you have such a thing, you can modify the path or the integrand
    or your grid size with a tiny amount of effort, and so can use your product to
    evaluate any line integral you ever encounter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，一旦你拥有这样的东西，你就可以用极少的努力修改路径、被积函数或者网格大小，因此可以使用你的产品来评估你所遇到的任何线积分。
- en: A line integral is more complicated than an ordinary integral primarily in that
    you have to deal with a path as well as an integrand, while for an ordinary integrand
    the path is an interval of the real line which is completely characterized by
    two numbers, its endpoints, and you need only deal with the integrand.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 线积分与普通积分相比更复杂，主要是因为你不仅需要处理被积函数，还需要处理路径，而对于普通的被积函数，路径是实线的一个区间，由其两个端点完全确定，你只需要处理被积函数。
- en: What we do depends on how the path C on which the integral is to be evaluated
    is defined.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的取决于积分的路径 C 如何定义。
- en: The easiest case, which we address here, occurs when we are given C as a **parametrized
    curve.**
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '最简单的情况，我们在这里解决的是当我们把 C 给出作为一个**参数曲线**时发生的情况。 '
- en: This means that we have a parameter, let us call it t, and have formulae for
    each coordinate, x, y, z,..., as functions of t, and an interval of t values defines
    the curve.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们有一个参数，让我们称之为 t，并且对于每个坐标 x、y、z 等，我们有 t 的函数形式，并且 t 值的区间定义了曲线。
- en: Our plan is to break up the t interval into many small pieces, and at the boundaries
    of these pieces calculate x(t), y(t), z(t), and v[x](x(t), y(t), ...), v[y](x(t),
    y(t), ...), ...
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划是将 t 区间分成许多小片段，并在这些片段的边界处计算 x(t)、y(t)、z(t) 和 v[x](x(t), y(t), ...)、v[y](x(t),
    y(t), ...)、...。
- en: In words, we will devote a column to the calculation of each of x, y and z (in
    three dimensions); and to each component of the vector field **v**, evaluated
    at (x(t), y(t), z(t)). Then we use a column to describe the contribution to the
    integral from one subinterval, say between t and t + d.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们将为 x、y 和 z（在三维空间中）的每个计算分配一列；并且为矢量场 **v** 在点 (x(t), y(t), z(t)) 处的每个分量进行计算。然后，我们使用一列来描述来自一个子区间（比如
    t 到 t + d 之间）的积分贡献。
- en: '**And what do we use to estimate that contribution?**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们用什么来估计这个贡献？**'
- en: t is the change in x(t) over that interval multiplied by the average value of
    v[x] over the endpoints of the interval plus the same thing in y and in z. We
    write down only the x contribution here, which is
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: t 是 x(t) 在该区间内的变化乘以该区间端点上 v[x] 的平均值，再加上 y 和 z 上相同的情况。我们只在这里写下 x 的贡献，即
- en: '![](../Images/a153ad247f43744e8c9e8488ec629302.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a153ad247f43744e8c9e8488ec629302.jpg)'
- en: In the last column we add up these contributions over the various intervals,
    and that is our integral. This is the trapezoid rule for line integrals.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一列，我们将这些贡献加起来，覆盖各个区间，这就是我们的积分。这是线积分的梯形法则。
- en: '**Once this is done, how do we change the path?** Alter the x(t), y(t) and
    z(t) columns to use different functions of t.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**一旦完成了这个步骤，我们如何改变路径？** 修改 x(t)、y(t) 和 z(t) 列，以使用不同的 t 函数。'
- en: '**How do we change the integrand, v?** Change its columns.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何改变被积函数 v？** 改变它的列。'
- en: '**How do we change the interval size parameter d?** Just change it.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们如何改变区间大小参数 d？** 只需改变它。'
- en: '**Exactly how do we do this?**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们究竟要如何做到这一点？**'
- en: I like to leave the top five or so rows for notes and data entry.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把前五行留给注释和数据输入。
- en: In B2 I would put the starting t value and in B3 the value for d.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 B2 中，我会放入起始 t 值，在 B3 中放入 d 的值。
- en: In the top row I would give a verbal description of the curve and vector field.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶行，我会给出对曲线和矢量场的文字描述。
- en: So I would start the computation in row 6.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我会从第 6 行开始计算。
- en: Here is what I would put in the t column, column A
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我会放在 t 列（A 列）的内容。
- en: A6=B2
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: A6=B2
- en: A7=A6+B3
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: A7=A6+B3
- en: A8=2*A7-A6
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: A8=2*A7-A6
- en: And I would copy A8 down the sheet into A9-A1005\. (or further if you like)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我会把 A8 复制到 A9-A1005（或者更远，如果你愿意）。
- en: In the x, y and z columns put
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x、y 和 z 列中放入
- en: B6=x(A6) (you must put in what this function is of course)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: B6=x(A6)（当然，你必须放入这个函数是什么）
- en: C6= y(A6)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: C6= y(A6)
- en: D6=z(A6)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: D6=z(A6)
- en: And copy these down to B7-B1005, etc.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 并将这些复制到 B7-B1005，等等。
- en: In the **v** columns put the values for the components of **v**
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **v** 列中，放入 **v** 的各个分量的值
- en: E6=v[x](B6,C6,D6)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: E6=v[x](B6,C6,D6)
- en: F6=v[y](B6,C6,D6)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: F6=v[y](B6,C6,D6)
- en: G6=v[z](B6,C6,D6)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: G6=v[z](B6,C6,D6)
- en: And copy these down.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其复制下去。
- en: Next set
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来设置
- en: H6=(B7-B6)*(E(7)+E(6))/2
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: H6=(B7-B6)*(E(7)+E(6))/2
- en: And copy this into the I6 and J6 places, and down the sheet.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其复制到 I6 和 J6 的位置，并向下延伸。
- en: Set
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置
- en: K6=H6+I6+J6
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: K6=H6+I6+J6
- en: And
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 并且
- en: L7=L6+K6
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: L7=L6+K6
- en: And copy these down, **and you are done.**
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 并将这些复制下去，**你就完成了**。
- en: If the final t value occurs in Ak, then the integrand answer will be in Lk.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最终的 t 值出现在 Ak，则积分答案将在 Lk 中。
- en: You can adjust d and can extrapolate exactly as for ordinary integrals.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整 d，并且可以像普通积分一样进行外推。
- en: The method used here is the path integral version of the trapezoid rule.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的方法是梯形法则的路径积分版本。
- en: With a little guile you can extrapolate this to get a path integral version
    of Simpson's rule, and extrapolate that as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点诡计，你可以推断出这一点积分版本的辛普森法则，并且也可以推断出它。
- en: You can check on accuracy by doing the integral for one d value and for 2d and
    4d as well (make sure you adjust the endpoint suitably, to check on your accuracy).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对一个 d 值、2d 值和 4d 值进行积分来检查准确性（确保适当调整端点，以检查准确性）。
- en: Without extrapolation the differences in answers should go down by a factor
    of 4 when you decrease d by a factor of two; taking ![](../Images/31ae4dcbda598a1ae3e4f53057763b4a.jpg)
    of the finer result less ![](../Images/a5ac7d89e8de036eb98a1a6e004b07a3.jpg) or
    the coarser one should improve the result to Simpson.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有外推的情况下，当你将d减小一半时，答案的差异应该减少4倍；用细分的结果的![](../Images/31ae4dcbda598a1ae3e4f53057763b4a.jpg)
    减去较粗糙的结果的![](../Images/a5ac7d89e8de036eb98a1a6e004b07a3.jpg) 或较粗糙的结果应该会改善到Simpson的结果。
- en: And so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 依此类推。
- en: 25.5 Doing Flux (Surface) Integrals on a Spreadsheet
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 25.5 在电子表格上进行通量（表面）积分
- en: When a surface S is described in parametric form, that is, you are given functions
    x(s, t), y(s, t) and z(s, t), and a region of values for s and t, you can use
    a spreadsheet to obtain the flux integral of any spreadsheet definable vector
    function **w** (that is the dot product of **w** with the normal to the surface)
    over it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当表面S以参数形式描述时，也就是说，给定函数x(s, t)，y(s, t)和z(s, t)，以及s和t的值域，你可以使用电子表格来计算任何可定义在电子表格上的向量函数**w**（即与表面法线的点积）的通量积分。
- en: You can do so by exploiting the ability of the spreadsheet to copy a single
    instruction to a large array of locations in two dimensions, row and column.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用电子表格的能力，在二维的大范围位置复制单个指令，行和列。
- en: Let us suppose you want to integrate over s first and then t, and you will integrate
    from t[1] to t[2], and from s[1](t) to s[2](t). Suppose you want to break each
    range into N, N = 100 pieces.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要先对s进行积分，然后再对t进行积分，你将从t[1]到t[2]进行积分，并从s[1](t)到s[2](t)进行积分。假设你想将每个范围分成N，N
    = 100个片段。
- en: 'The plan for this is as follows: you set up arrays of s values, t values and
    then x, y and z values and then w[x], w[y] and w[z] values, and finally an array
    for the integral; each of these arrays will be N + 1 by N + 1 in size, but can
    be constructed by constructing at most 3 or 4 entries. The rest is all copying.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计划如下：你设置s值、t值的数组，然后是x、y和z值，然后是w[x]、w[y]和w[z]值的数组，最后是一个积分的数组；这些数组中的每一个都将是N
    + 1乘以N + 1的大小，但最多只需要构造3或4个条目。其余的都是复制。
- en: Set up an array of t values, assigning t[1] to the first row that you use in
    the first column, and (previous + (t[2] - t[1]) / N) in the next row beneath it,
    and (2 * previous - (previous to previous)) beneath that. Copy that into the next
    98 rows. Then set the next column entry to "= entry to left" ; copy that into
    the next 98 columns and rows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个t值的数组，将t[1]分配给第一列中使用的第一行，然后在其下一行中将(previous + (t[2] - t[1]) / N)，以及在(previous
    to previous)之下的(2 * previous - (previous to previous))。将其复制到接下来的98行。然后将下一列的条目设置为“=左侧条目”，将其复制到接下来的98列和行。
- en: This should give a single constant t value in each row, but different ones in
    each column.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在每一行中给出一个单一的恒定t值，但在每一列中给出不同的值。
- en: Next set up two columns that compute s[1](t) and s[2](t) for each t value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来设置两列来计算每个t值的s[1](t)和s[2](t)。
- en: Set up an array of s values by putting = s[1] in the first column, first row
    = entry to left + (s[2](t[0]) - s[1](t[0])) / N (use dollar signs on the N) in
    the next column, and = (2 * left - leftleft) in the next column.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在第一列中放置=s[1]、第一行中的s[1] + (s[2](t[0]) - s[1](t[0])) / N（在N上使用美元符号）以及下一列中的(2
    * 左侧 - 左侧左侧)来设置一个s值的数组。
- en: Then copy this down 98 rows, and copy the third column 98 rows across.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这个复制到98行，并将第三列复制到98行。
- en: Set up the x, y, z and w[x], w[y] and w[z] arrays again of the same size, by
    putting x(s[0](t[0]), t[0]) in the top left entry of the x array, and copying
    it into the entire array. This can be done similarly for the other 5 arrays.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次设置相同大小的x、y、z和w[x]、w[y]和w[z]数组，方法是将x(s[0](t[0]), t[0])放在x数组的左上角条目中，并将其复制到整个数组中。其他5个数组也可以类似地完成。
- en: To compute the integral you can add up the contribution from each "pair of intervals"
    ds and dt, that is
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算积分，你可以将每个“区间对”ds和dt的贡献相加，即
- en: w[x] * (dy[s]dz[t] - dy[t]dz[s]) + w[y] * (dz[s]dx[t] - dz[t]dx[s]) + w[z] *
    (dx[s]dy[t] - dx[t]dy[s])
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: w[x] * (dy[s]dz[t] - dy[t]dz[s]) + w[y] * (dz[s]dx[t] - dz[t]dx[s]) + w[z] *
    (dx[s]dy[t] - dx[t]dy[s])
- en: To compute this for every 2x2 rectangle in the arrays again you need only compute
    it for the top left one and copy again to a 100 by 100 array.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要再次计算每个2x2矩形中的积分，你只需要计算顶部左侧的一个，然后再次复制到一个100乘100的数组中。
- en: This can be done in one step or once for each term. The integral will be the
    sum of this over the entire array.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以一次完成或每个项都完成一次。积分将是整个数组上的这些的总和。
- en: What do you do to get w[x] or dy[s] or dz[t] for a pair of intervals?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一对区间，你需要做什么来获得w[x]或dy[s]或dz[t]？
- en: Suppose the interval corners are (s, t), (s + d, t), (s, t + d') and (s + d,
    t + d').
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设区间的角落是（s，t），（s + d，t），（s，t + d'）和（s + d，t + d'）。
- en: Then the analogue of the trapezoid rule in two dimensions gives
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，二维中梯形法则的类比给出
- en: '![](../Images/d696f80f2d6ce3a78987628d749c738c.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d696f80f2d6ce3a78987628d749c738c.jpg)'
- en: Though it is messy to create this last array, it really only has to be done
    in one square and copied, and also only has to be done once, and can be reused
    with different integrals, if the other arrays have the same start points.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管创建这个最后一个数组很混乱，但实际上只需要在一个正方形中完成并复制，而且只需要完成一次，并且可以在其他数组具有相同起始点的情况下重复使用。
- en: Notice that to change the domain for s and t you need only change the first
    two arrays; to change the parametrization you need only change the x, y and z
    arrays, and to change the vector **w** whose flux integral you are computing you
    need only change its three arrays.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要更改s和t的域，只需更改前两个数组；要更改参数化，只需更改x、y和z数组，要更改计算其通量积分的向量**w**，只需更改其三个数组。
- en: You can get integrals over subsets of the surface by taking different sums over
    the last array.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对最后一个数组进行不同的求和，可以获得对表面子集的积分。
- en: Here is an example
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子
- en: t[1] =1, t[2] = 2, s[1] = t², s[2] = t³,
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: t[1] =1，t[2] = 2，s[1] = t²，s[2] = t³，
- en: '![](../Images/56c616fd7da8005f030f20f69b69c6d6.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/56c616fd7da8005f030f20f69b69c6d6.jpg)'
- en: '![](../Images/b3090b8b16d274171ecb7ff72c700a6f.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b3090b8b16d274171ecb7ff72c700a6f.jpg)'
- en: Notice that changing t[1], t[2], s[1], s[2], x, y, z, w[x], w[y] or w[z] each
    require changing only one entry, and then copying it into the entire corresponding
    array. (Or wherever appropriate. In the case of t[1] and t[2] you need copy nothing,
    and for s[1] and s[2] that is a column.)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，更改t[1]、t[2]、s[1]、s[2]、x、y、z、w[x]、w[y]或w[z]每次只需要更改一个条目，然后将其复制到整个相应的数组中。（或在适当的地方。对于t[1]和t[2]，您无需复制任何内容，对于s[1]和s[2]，那是一列。）
- en: 'It is quite easy to extrapolate these results: you can change N to 50 and sum
    over the top left quarter of the last array, and change N to 25 and sum over the
    top left quarter of that array.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易推断这些结果：您可以将N更改为50，并对最后一个数组的左上角进行求和，将N更改为25，并对该数组的左上角进行求和。
- en: The results for this integral are 132.2450414 for N = 100, 132.1941481 for N
    = 50, and 131.9909671 for N = 25.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此积分的结果为N = 100时为132.2450414，N = 50时为132.1941481，N = 25时为131.9909671。
- en: The difference between these is roughly 4 times smaller between 50 and 100 than
    it is between 25 and 50\. Multiplying the better by ![](../Images/31ae4dcbda598a1ae3e4f53057763b4a.jpg)
    and subtracting the worse multiplied by ![](../Images/a5ac7d89e8de036eb98a1a6e004b07a3.jpg)
    gives 132.262006 and 132.261875\. Extrapolating assuming that the remaining error
    goes down by a factor of 16 gives an estimate of 132.2620145, which is probably
    accurate to 6 decimal places.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在50和100之间，这些之间的差异大约是25和50之间的4倍。将更好的乘以![](../Images/31ae4dcbda598a1ae3e4f53057763b4a.jpg)，减去更差的乘以![](../Images/a5ac7d89e8de036eb98a1a6e004b07a3.jpg)得到132.262006和132.261875。假设剩余误差按16的倍数下降，给出132.2620145的估计，这可能准确到6位小数。
- en: This can be verified by enlarging the arrays and trying N = 200, something which
    requires only copying, and forming one new sum.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过扩大数组并尝试N = 200来验证，这只需要复制，并形成一个新的总和。
- en: '**Exercises:**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：**'
- en: '**25.6 Create the spreadsheet just described and verify or disprove the claims
    above.**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**25.6 创建刚才描述的电子表格，并验证或证伪上述说法。**'
- en: '**25.7 What is the best estimate you can get for the integral described?**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**25.7 您能得到描述的积分的最佳估计是什么？**'
- en: '**25.8 Change s and t to go from 0 to ![](../Images/0e42b2bc5fad4aa5017f2e8e7fd0d0e4.jpg)
    and 2![](../Images/0e42b2bc5fad4aa5017f2e8e7fd0d0e4.jpg), make x, y and z equal
    what they are in spherical coordinates, and let w be the vector (x, y, 0). Find
    the integral by this approach to some reasonable accuracy.**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**25.8 将s和t更改为从0到![](../Images/0e42b2bc5fad4aa5017f2e8e7fd0d0e4.jpg)和2![](../Images/0e42b2bc5fad4aa5017f2e8e7fd0d0e4.jpg)，使x、y和z等于球坐标中的值，并让w为向量（x，y，0）。通过这种方法找到积分的合理精度。**'
