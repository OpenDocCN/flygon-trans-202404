- en: 'Chapter 25: Numerical Integration'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can easily set up a spreadsheet to evaluate a given integrand f at a large
    number of points in the range from a to b, and to form Riemann sums. A symmetric
    way to do this is the "trapezoid rule" that approximates the area in a strip by
    the area in the trapezoid with the same height at either end of the given interval.
    We explore this rule and more accurate extrapolations. The first of these is called
    Simpson's rule.
  prefs: []
  type: TYPE_NORMAL
- en: Topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 25.1  [The Trapezoid Rule](section01.html)
  prefs: []
  type: TYPE_NORMAL
- en: 25.2  [Simpson's Rule](section02.html)
  prefs: []
  type: TYPE_NORMAL
- en: 25.3  [Extrapolations and Better Approximations](section03.html)
  prefs: []
  type: TYPE_NORMAL
- en: 25.4  [Numerical Evaluation of Line Integrals](section04.html)
  prefs: []
  type: TYPE_NORMAL
- en: 25.5  [Doing Flux (Surface) Integrals on a Spreadsheet](section05.html)
  prefs: []
  type: TYPE_NORMAL
- en: 25.1 The Trapezoid Rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem we face is that of finding **the area between a curve described
    by the equation y = f(x) and the x-axis in a finite interval [a, b].**
  prefs: []
  type: TYPE_NORMAL
- en: We use the approach that we have used to define the integral. When f is continuous
    in the interval, we divide it into N subintervals, each of width ![](../Images/4f5e0b41767718ffa879967219fe65b6.jpg)which
    we will call d, (we assume b > a) and evaluate f at the endpoints of each of these
    intervals, a + jd for j from 0 to N.
  prefs: []
  type: TYPE_NORMAL
- en: '**When f is only piecewise continuous, you should first break the interval
    into subintervals in which f is continuous and proceed as we discuss in each of
    these.**'
  prefs: []
  type: TYPE_NORMAL
- en: The **trapezoid rule** consists in approximating the area of each subinterval
    by its width d multiplied by the average of the values of f at its endpoints.
    For the j-th interval this is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6648654172847e6ea1270787aa215e61.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**We now address the questions: why do this?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Is it better to use this trapezoid rule than say, to choose a point x'' at
    random in the j-th interval and compute d * f(x'') as the contribution to the
    area from that interval?**'
  prefs: []
  type: TYPE_NORMAL
- en: To get a partial answer to this question, consider **one interval of width d
    and center at x[j]** and for convenience we set x[j] = 0.
  prefs: []
  type: TYPE_NORMAL
- en: Then the interval begins at ![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)
    and ends at ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Suppose now we can expand our integrand f in a power series about x, with results
  prefs: []
  type: TYPE_NORMAL
- en: f(x) = f(0) + ax + bx² + cx³ + ex⁴ + ...
  prefs: []
  type: TYPE_NORMAL
- en: The actual area under this function in this interval will be
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f9151ce4cb269d9a2f8183a488f19fc6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '(Here the factor ![](../Images/5b814ed740e82e673036174062ff3be2.jpg) arises
    as follows: there are identical contributions from the endpoints ![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)
    and ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg) which are each ![](../Images/e5ba4c26d7cbeaf2bf5f2468145e60f6.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: The factor ![](../Images/e3e9eee02c13276a499f8bf4cdff843d.jpg) comes about similarly.
    **Notice that the ax and other odd power terms in f do not contribute at all here
    because they are odd and their contributions cancel out.)**
  prefs: []
  type: TYPE_NORMAL
- en: '**The trapezoid rule that we have described, on the other hand, gives the following
    proposed answer for this area**'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](../Images/88abfe0f331102022e506bdd6597bedb.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The contribution from f(0) is exactly right, that from b is a factor of three
    too large, and that from e is a factor of 5 too large.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Notice that any estimation here that is symmetric about 0 will get the odd
    (a, c, ...) terms right.**'
  prefs: []
  type: TYPE_NORMAL
- en: In particular we could use the **"midpoint rule"** which approximates the area
    as f(0)d, and this gets the a, c, ... contributions right but gets nothing at
    all from the b, e, ... terms.
  prefs: []
  type: TYPE_NORMAL
- en: The symmetry which causes the a and c terms to cancel out is the great advantage
    that the trapezoid rule possesses here and it shares it with the midpoint rule.
  prefs: []
  type: TYPE_NORMAL
- en: '**Consider what happens if we decrease d by a factor of 2** (or any other factor
    z). Because of this symmetry, **the error in the trapezoid rule or the midpoint
    rule goes down by a factor of 2³ for each interval, but now there are two intervals
    where only one was before.**'
  prefs: []
  type: TYPE_NORMAL
- en: This error must therefore be **doubled to have a comparison over the original
    interval,** and **the actual error in either the trapezoid rule or the midpoint
    rule goes down by a factor of 4 in any one interval from the b term,** and even
    more from the e and further terms.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**25.1 Set up a spreadsheet that divides a given interval a to b into N equal
    subintervals, evaluates a given function, say sin x at each of the N + 1 interval
    endpoints, and calculates the Trapezoid rule evaluation of the resulting integral.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**25.2 Make a spreadsheet with the capability of computing this evaluation
    for N = 1, 2, 4, 8, 16, and 32 simultaneously. (You can put them next to each
    other by starting with 32 and entering the instruction =if(mod(j,2^k)=0,2*prev
    column entry,0), with j the index of the subinterval end and k the column index.
    Each increase in k by 1 will decrease the number of trapezoid intervals by a factor
    of 2.)**'
  prefs: []
  type: TYPE_NORMAL
- en: 25.2 Simpson's Rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the notation of the last section the actual area under the function f in
    the interval between ![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg) and ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)
    will be
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/46d24ee2f1f51a82a25641688c627ddb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The trapezoid rule that we have described, on the other hand, gives the following
    proposed answer for this area
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/feefa1f2cab42840444bd64e0c87a9ac.jpg)'
  prefs: []
  type: TYPE_IMG
- en: while the "midpoint rule" approximates the area as f(0)d.
  prefs: []
  type: TYPE_NORMAL
- en: This means that **if we mix two parts of the midpoint rule and one part of the
    trapezoid rule, we will get the quadratic b term exactly right,** and the leading
    term in the error will come from the e term which will be on the order of d⁴.
  prefs: []
  type: TYPE_NORMAL
- en: '**The rule for approsimating integrals just described is called Simpson''s
    rule, and it takes the following form in the interval between ![](../Images/b9c249e945dc0581feee41673a53efff.jpg)
    and ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/82d8946f8b4bfdd190c0d18427130604.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Notice that in this formula f is evaluated at intervals ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg)
    apart**. If we give the parameter ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)
    a new name here, calling it h, the Simpson''s rule formula in terms of h becomes'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8f193f222b265837f197ed6e1aed3ef7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and it represents an approximation to the area under the curve defined by f
    in the interval from -h to h; an approximation whose error is of fourth order
    in h.
  prefs: []
  type: TYPE_NORMAL
- en: It is worthwhile noticing what these various rules look like when applied to
    a number of small subintervals in a row.
  prefs: []
  type: TYPE_NORMAL
- en: The trapezoid rule gives equal weight d to evaluations at all intermediate points,
    since each is the left end and the right end of one subinterval and it **gets
    ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg) weight from each end.**
  prefs: []
  type: TYPE_NORMAL
- en: The end two evaluations on the other hand are ends of only one subinterval each,
    and **these get weight ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg).**
  prefs: []
  type: TYPE_NORMAL
- en: The midpoint rule gives equal weight to the odd numbered evaluations of d or
    2h.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simpson''s rule gives weights that form the pattern 1 4 2 4 2 ... 4 1 multiplied
    by ![](../Images/aed297b225b0463bf3774b5df7565b91.jpg), since the midpoints get
    weight ![](../Images/49e792c28a53f3732fb9053c86698bc7.jpg) and the trapezoid rule
    divided by 3 accounts for the rest.**'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | endpointa | midpoint first intervala + h | end first intervala + 2h |
    midpoint second intervala + 3h | end second intervala + 4h | etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Trapezoid rule terms | hf(a) | 0 | 2hf(a + 2h) | 0 | 2hf(a + 4h) | etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Midpoint rule terms | 0 | 2hf(a + h) | 0 | 2hf(a + 3h) | 0 | etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Simpson''s rule terms | ![](../Images/4082a090b51e10b925a3d3896a92c83e.jpg)
    | ![](../Images/891358600490512a6a809d0ee14ec4d8.jpg) | ![](../Images/818cf85ac94e6b33825d80a7e0fed1f9.jpg)
    | ![](../Images/5a98c1d838f19c240545a5fbe3788bce.jpg) | ![](https://ocw.mit.edu/ans7870/18/18.013a/textbook/HTML/chapter25/equations/sections_eqn22.gif)
    | etc. |'
  prefs: []
  type: TYPE_TB
- en: Notice that the leading term in the power series for f that produces an error
    in Simpson's rule is the ex⁴ term, and **that produces an error which goes down
    by a factor of 16 if we divide our intervals in half.**
  prefs: []
  type: TYPE_NORMAL
- en: <applet code="NumericalIntegration" codebase="../applets/" archive="numericalIntegration.jar,mk_lib.jar,parser_math.jar,jcbwt363.jar"
    width="760" height="450"></applet>
  prefs: []
  type: TYPE_NORMAL
- en: 25.3 Extrapolations and Better Approximations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw when discussing numerical differentiation that when we have a sequence
    of numbers which are approximations to a number A **whose errors decrease by a
    given factor r from term to term,** we can extrapolate the sequence to get a more
    rapidly converging one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general extrapolation rule is: **to get rid of errors that decrease by
    a factor of z, take the current result times z minus the previous result and divide
    this difference by z - 1.**'
  prefs: []
  type: TYPE_NORMAL
- en: Here for example, if we look at the answers provided by the trapezoid rule for
    values 16d, 8d, 4d, 2d, d, say, we get a sequence of approximate answers whose
    errors can be expected to decrease by a factor of roughly 4 each time. If we denote
    these answers as ![](../Images/e08122572eec913bfccd5015394f7d24.jpg) and look
    at the sequence ![](../Images/ebd8418ce531aeefec773ee80fea5c02.jpg), (for j =
    2 to 5) the terms in A that go down as a factor of 4 will cancel out in each B
    and we will be left with the higher order terms only.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply this procedure here to the trapezoid rule, we get the Simpson's
    rule approximations previously defined.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 25.3** **Verify this statement.**'
  prefs: []
  type: TYPE_NORMAL
- en: But we know that the leading terms in Simpson's rule decrease by a factor of
    16 each time and we can play the same game with them.
  prefs: []
  type: TYPE_NORMAL
- en: We can form ![](../Images/0b0d3341080eeec5116b7b5b7989ade6.jpg) defined by ![](../Images/1acae4732e6866813275d4e027298de9.jpg),
    for j = 3 to 5, and get a "Super Simpson's rule approximation", the leading terms
    in which (in the power series expansion) decrease by 64 from term to term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well we can keep this up twice more: and get ![](../Images/cd5a0d718bac703f1813aa6ba5f8960f.jpg)
    for j = 4 and 5, and ![](../Images/89983ffa875559ed30822e5928ca5d57.jpg), and
    this is about the best we can do as an approximation with 16 intervals.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**25.4 Use the results of Exercise 25.2 which give the A''s to compute the
    B''s to E''s. Compare their accuracy on an integral whose value you know. (For
    example sin x from x = 0 to 1.)'
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware that these methods while very good are particularly effective
    on sin x.**
  prefs: []
  type: TYPE_NORMAL
- en: '**25.5 Can you find a function for which this approach to integrating is lousy?
    What might you do to improve it?**'
  prefs: []
  type: TYPE_NORMAL
- en: 25.4 Numerical Evaluation of Line Integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we confront a line integral, which is an integral along a path in some
    Euclidean space, of a vector field **v**![](../Images/942a415c6b0fa1fa8b2f7d2d2c8c225a.jpg)**ds**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/61f9cc97bb28e966f6fe6341b3c2bc02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can set up a spreadsheet to evaluate such an integral with very little difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we describe how this can be done, and attempt to goad you into
    doing one yourself on a spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, once you have such a thing, you can modify the path or the integrand
    or your grid size with a tiny amount of effort, and so can use your product to
    evaluate any line integral you ever encounter.
  prefs: []
  type: TYPE_NORMAL
- en: A line integral is more complicated than an ordinary integral primarily in that
    you have to deal with a path as well as an integrand, while for an ordinary integrand
    the path is an interval of the real line which is completely characterized by
    two numbers, its endpoints, and you need only deal with the integrand.
  prefs: []
  type: TYPE_NORMAL
- en: What we do depends on how the path C on which the integral is to be evaluated
    is defined.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest case, which we address here, occurs when we are given C as a **parametrized
    curve.**
  prefs: []
  type: TYPE_NORMAL
- en: This means that we have a parameter, let us call it t, and have formulae for
    each coordinate, x, y, z,..., as functions of t, and an interval of t values defines
    the curve.
  prefs: []
  type: TYPE_NORMAL
- en: Our plan is to break up the t interval into many small pieces, and at the boundaries
    of these pieces calculate x(t), y(t), z(t), and v[x](x(t), y(t), ...), v[y](x(t),
    y(t), ...), ...
  prefs: []
  type: TYPE_NORMAL
- en: In words, we will devote a column to the calculation of each of x, y and z (in
    three dimensions); and to each component of the vector field **v**, evaluated
    at (x(t), y(t), z(t)). Then we use a column to describe the contribution to the
    integral from one subinterval, say between t and t + d.
  prefs: []
  type: TYPE_NORMAL
- en: '**And what do we use to estimate that contribution?**'
  prefs: []
  type: TYPE_NORMAL
- en: t is the change in x(t) over that interval multiplied by the average value of
    v[x] over the endpoints of the interval plus the same thing in y and in z. We
    write down only the x contribution here, which is
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a153ad247f43744e8c9e8488ec629302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the last column we add up these contributions over the various intervals,
    and that is our integral. This is the trapezoid rule for line integrals.
  prefs: []
  type: TYPE_NORMAL
- en: '**Once this is done, how do we change the path?** Alter the x(t), y(t) and
    z(t) columns to use different functions of t.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we change the integrand, v?** Change its columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '**How do we change the interval size parameter d?** Just change it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exactly how do we do this?**'
  prefs: []
  type: TYPE_NORMAL
- en: I like to leave the top five or so rows for notes and data entry.
  prefs: []
  type: TYPE_NORMAL
- en: In B2 I would put the starting t value and in B3 the value for d.
  prefs: []
  type: TYPE_NORMAL
- en: In the top row I would give a verbal description of the curve and vector field.
  prefs: []
  type: TYPE_NORMAL
- en: So I would start the computation in row 6.
  prefs: []
  type: TYPE_NORMAL
- en: Here is what I would put in the t column, column A
  prefs: []
  type: TYPE_NORMAL
- en: A6=B2
  prefs: []
  type: TYPE_NORMAL
- en: A7=A6+B3
  prefs: []
  type: TYPE_NORMAL
- en: A8=2*A7-A6
  prefs: []
  type: TYPE_NORMAL
- en: And I would copy A8 down the sheet into A9-A1005\. (or further if you like)
  prefs: []
  type: TYPE_NORMAL
- en: In the x, y and z columns put
  prefs: []
  type: TYPE_NORMAL
- en: B6=x(A6) (you must put in what this function is of course)
  prefs: []
  type: TYPE_NORMAL
- en: C6= y(A6)
  prefs: []
  type: TYPE_NORMAL
- en: D6=z(A6)
  prefs: []
  type: TYPE_NORMAL
- en: And copy these down to B7-B1005, etc.
  prefs: []
  type: TYPE_NORMAL
- en: In the **v** columns put the values for the components of **v**
  prefs: []
  type: TYPE_NORMAL
- en: E6=v[x](B6,C6,D6)
  prefs: []
  type: TYPE_NORMAL
- en: F6=v[y](B6,C6,D6)
  prefs: []
  type: TYPE_NORMAL
- en: G6=v[z](B6,C6,D6)
  prefs: []
  type: TYPE_NORMAL
- en: And copy these down.
  prefs: []
  type: TYPE_NORMAL
- en: Next set
  prefs: []
  type: TYPE_NORMAL
- en: H6=(B7-B6)*(E(7)+E(6))/2
  prefs: []
  type: TYPE_NORMAL
- en: And copy this into the I6 and J6 places, and down the sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs: []
  type: TYPE_NORMAL
- en: K6=H6+I6+J6
  prefs: []
  type: TYPE_NORMAL
- en: And
  prefs: []
  type: TYPE_NORMAL
- en: L7=L6+K6
  prefs: []
  type: TYPE_NORMAL
- en: And copy these down, **and you are done.**
  prefs: []
  type: TYPE_NORMAL
- en: If the final t value occurs in Ak, then the integrand answer will be in Lk.
  prefs: []
  type: TYPE_NORMAL
- en: You can adjust d and can extrapolate exactly as for ordinary integrals.
  prefs: []
  type: TYPE_NORMAL
- en: The method used here is the path integral version of the trapezoid rule.
  prefs: []
  type: TYPE_NORMAL
- en: With a little guile you can extrapolate this to get a path integral version
    of Simpson's rule, and extrapolate that as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can check on accuracy by doing the integral for one d value and for 2d and
    4d as well (make sure you adjust the endpoint suitably, to check on your accuracy).
  prefs: []
  type: TYPE_NORMAL
- en: Without extrapolation the differences in answers should go down by a factor
    of 4 when you decrease d by a factor of two; taking ![](../Images/31ae4dcbda598a1ae3e4f53057763b4a.jpg)
    of the finer result less ![](../Images/a5ac7d89e8de036eb98a1a6e004b07a3.jpg) or
    the coarser one should improve the result to Simpson.
  prefs: []
  type: TYPE_NORMAL
- en: And so on.
  prefs: []
  type: TYPE_NORMAL
- en: 25.5 Doing Flux (Surface) Integrals on a Spreadsheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a surface S is described in parametric form, that is, you are given functions
    x(s, t), y(s, t) and z(s, t), and a region of values for s and t, you can use
    a spreadsheet to obtain the flux integral of any spreadsheet definable vector
    function **w** (that is the dot product of **w** with the normal to the surface)
    over it.
  prefs: []
  type: TYPE_NORMAL
- en: You can do so by exploiting the ability of the spreadsheet to copy a single
    instruction to a large array of locations in two dimensions, row and column.
  prefs: []
  type: TYPE_NORMAL
- en: Let us suppose you want to integrate over s first and then t, and you will integrate
    from t[1] to t[2], and from s[1](t) to s[2](t). Suppose you want to break each
    range into N, N = 100 pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plan for this is as follows: you set up arrays of s values, t values and
    then x, y and z values and then w[x], w[y] and w[z] values, and finally an array
    for the integral; each of these arrays will be N + 1 by N + 1 in size, but can
    be constructed by constructing at most 3 or 4 entries. The rest is all copying.'
  prefs: []
  type: TYPE_NORMAL
- en: Set up an array of t values, assigning t[1] to the first row that you use in
    the first column, and (previous + (t[2] - t[1]) / N) in the next row beneath it,
    and (2 * previous - (previous to previous)) beneath that. Copy that into the next
    98 rows. Then set the next column entry to "= entry to left" ; copy that into
    the next 98 columns and rows.
  prefs: []
  type: TYPE_NORMAL
- en: This should give a single constant t value in each row, but different ones in
    each column.
  prefs: []
  type: TYPE_NORMAL
- en: Next set up two columns that compute s[1](t) and s[2](t) for each t value.
  prefs: []
  type: TYPE_NORMAL
- en: Set up an array of s values by putting = s[1] in the first column, first row
    = entry to left + (s[2](t[0]) - s[1](t[0])) / N (use dollar signs on the N) in
    the next column, and = (2 * left - leftleft) in the next column.
  prefs: []
  type: TYPE_NORMAL
- en: Then copy this down 98 rows, and copy the third column 98 rows across.
  prefs: []
  type: TYPE_NORMAL
- en: Set up the x, y, z and w[x], w[y] and w[z] arrays again of the same size, by
    putting x(s[0](t[0]), t[0]) in the top left entry of the x array, and copying
    it into the entire array. This can be done similarly for the other 5 arrays.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the integral you can add up the contribution from each "pair of intervals"
    ds and dt, that is
  prefs: []
  type: TYPE_NORMAL
- en: w[x] * (dy[s]dz[t] - dy[t]dz[s]) + w[y] * (dz[s]dx[t] - dz[t]dx[s]) + w[z] *
    (dx[s]dy[t] - dx[t]dy[s])
  prefs: []
  type: TYPE_NORMAL
- en: To compute this for every 2x2 rectangle in the arrays again you need only compute
    it for the top left one and copy again to a 100 by 100 array.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done in one step or once for each term. The integral will be the
    sum of this over the entire array.
  prefs: []
  type: TYPE_NORMAL
- en: What do you do to get w[x] or dy[s] or dz[t] for a pair of intervals?
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the interval corners are (s, t), (s + d, t), (s, t + d') and (s + d,
    t + d').
  prefs: []
  type: TYPE_NORMAL
- en: Then the analogue of the trapezoid rule in two dimensions gives
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d696f80f2d6ce3a78987628d749c738c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Though it is messy to create this last array, it really only has to be done
    in one square and copied, and also only has to be done once, and can be reused
    with different integrals, if the other arrays have the same start points.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that to change the domain for s and t you need only change the first
    two arrays; to change the parametrization you need only change the x, y and z
    arrays, and to change the vector **w** whose flux integral you are computing you
    need only change its three arrays.
  prefs: []
  type: TYPE_NORMAL
- en: You can get integrals over subsets of the surface by taking different sums over
    the last array.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example
  prefs: []
  type: TYPE_NORMAL
- en: t[1] =1, t[2] = 2, s[1] = t², s[2] = t³,
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/56c616fd7da8005f030f20f69b69c6d6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../Images/b3090b8b16d274171ecb7ff72c700a6f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that changing t[1], t[2], s[1], s[2], x, y, z, w[x], w[y] or w[z] each
    require changing only one entry, and then copying it into the entire corresponding
    array. (Or wherever appropriate. In the case of t[1] and t[2] you need copy nothing,
    and for s[1] and s[2] that is a column.)
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite easy to extrapolate these results: you can change N to 50 and sum
    over the top left quarter of the last array, and change N to 25 and sum over the
    top left quarter of that array.'
  prefs: []
  type: TYPE_NORMAL
- en: The results for this integral are 132.2450414 for N = 100, 132.1941481 for N
    = 50, and 131.9909671 for N = 25.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between these is roughly 4 times smaller between 50 and 100 than
    it is between 25 and 50\. Multiplying the better by ![](../Images/31ae4dcbda598a1ae3e4f53057763b4a.jpg)
    and subtracting the worse multiplied by ![](../Images/a5ac7d89e8de036eb98a1a6e004b07a3.jpg)
    gives 132.262006 and 132.261875\. Extrapolating assuming that the remaining error
    goes down by a factor of 16 gives an estimate of 132.2620145, which is probably
    accurate to 6 decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: This can be verified by enlarging the arrays and trying N = 200, something which
    requires only copying, and forming one new sum.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**25.6 Create the spreadsheet just described and verify or disprove the claims
    above.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**25.7 What is the best estimate you can get for the integral described?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**25.8 Change s and t to go from 0 to ![](../Images/0e42b2bc5fad4aa5017f2e8e7fd0d0e4.jpg)
    and 2![](../Images/0e42b2bc5fad4aa5017f2e8e7fd0d0e4.jpg), make x, y and z equal
    what they are in spherical coordinates, and let w be the vector (x, y, 0). Find
    the integral by this approach to some reasonable accuracy.**'
  prefs: []
  type: TYPE_NORMAL
