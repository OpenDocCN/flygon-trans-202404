["```\n/**\n * This immutable data type represents a tweet from Twitter.\n */\npublic class Tweet {\n\n    public String author;\n    public String text;\n    public Date timestamp;\n\n    /**\n     * Make a Tweet.\n     * @param author    Twitter user who wrote the tweet\n     * @param text      text of the tweet\n     * @param timestamp date/time when the tweet was sent\n     */\n    public Tweet(String author, String text, Date timestamp) {\n        this.author = author;\n        this.text = text;\n        this.timestamp = timestamp;\n    }\n}\n```", "```\nTweet t = new Tweet(\"justinbieber\", \n                    \"Thanks to all those beliebers out there inspiring me every day\", \n                    new Date());\nt.author = \"rbmllr\";\n```", "```\npublic class Tweet {\n\n    private final String author;\n    private final String text;\n    private final Date timestamp;\n\n    public Tweet(String author, String text, Date timestamp) {\n        this.author = author;\n        this.text = text;\n        this.timestamp = timestamp;\n    }\n\n    /** @return Twitter user who wrote the tweet */\n    public String getAuthor() {\n        return author;\n    }\n\n    /** @return text of the tweet */\n    public String getText() {\n        return text;\n    }\n\n    /** @return date/time when the tweet was sent */\n    public Date getTimestamp() {\n        return timestamp;\n    }\n\n}\n```", "```\n/** @return a tweet that retweets t, one hour later*/\npublic static Tweet retweetLater(Tweet t) {\n    Date d = t.getTimestamp();\n    d.setHours(d.getHours()+1);\n    return new Tweet(\"rbmllr\", t.getText(), d);\n}\n```", "```\npublic Date getTimestamp() {\n    return new Date(timestamp.getTime());\n}\n```", "```\n/** @return a list of 24 inspiring tweets, one per hour today */\npublic static List<Tweet> tweetEveryHourToday () {\n    List<Tweet> list = new ArrayList<Tweet>(); \n    Date date = new Date();\n    for (int i = 0; i < 24; i++) {\n        date.setHours(i);\n        list.add(new Tweet(\"rbmllr\", \"keep it up! you can do it\", date));\n    } \n    return list;\n}\n```", "```\npublic Tweet(String author, String text, Date timestamp) {\n    this.author = author;\n    this.text = text;\n    this.timestamp = new Date(timestamp.getTime());\n}\n```", "```\n/**\n * Make a Tweet.\n * @param author    Twitter user who wrote the tweet\n * @param text      text of the tweet\n * @param timestamp date/time when the tweet was sent. Caller must never \n *                   mutate this Date object again!\n */\npublic Tweet(String author, String text, Date timestamp) {\n```", "```\n /** Represents an immutable right triangle. */\n      class RightTriangle {\n/*A*/     private double[] sides;\n\n          // sides[0] and sides[1] are the two legs,\n          // and sides[2] is the hypotenuse, so declare it to avoid having a\n          // magic number in the code:\n/*B*/     public static final int HYPOTENUSE = 2;\n\n          /** Make a right triangle.\n           * @param legA, legB  the two legs of the triangle\n           * @param hypotenuse    the hypotenuse of the triangle.\n *C*       *        Requires hypotenuse^2 = legA^2 + legB^2 \n           *           (within the error tolerance of double arithmetic)\n           */\n          public RightTriangle(double legA, double legB, double hypotenuse) {\n/*D*/         this.sides = new double[] { legA, legB, hypotenuse };\n          }\n\n          /** Get all the sides of the triangle.\n           *  @return three-element array with the triangle's side lengths\n           */\n          public double[] getAllSides() {\n/*E*/         return sides;\n          }\n\n          /** @return length of the triangle's hypotenuse */ \n          public double getHypotenuse() {\n              return sides[HYPOTENUSE];\n          }\n\n          /** @param factor to multiply the sides by\n           *  @return a triangle made from this triangle by \n           *  multiplying all side lengths by factor.\n           */\n          public RightTriangle scale(double factor) {\n              return new RightTriangle(sides[0]*factor, sides[1]*factor, sides[2]*factor);\n          }\n\n          /** @return a regular triangle made from this triangle.\n           *  A regular right triangle is one in which\n           *  both legs have the same length.\n           */\n          public RightTriangle regularize() {\n              double bigLeg = Math.max(side[0], side[1]);\n              return new RightTriangle (bigLeg, bigLeg, side[2]);\n          }\n\n      }\n```", "```\npublic class CharSet {\n    private String s;\n    ...\n}\n```", "```\npublic class CharSet {\n    private String s;\n    // Rep invariant:\n    //   s contains no repeated characters\n    // Abstraction Function:\n    //   represents the set of characters found in s\n    ...\n}\n```", "```\npublic class CharSet {\n    private String s;\n    // Rep invariant:\n    //   s[0] <= s[1] <= ... <= s[s.length()-1]\n    // Abstraction Function:\n    //   represents the set of characters found in s\n    ...\n}\n```", "```\npublic class CharSet {\n    private String s;\n    // Rep invariant:\n    //   s.length is even\n    //   s[0] <= s[1] <= ... <= s[s.length()-1]\n    // Abstraction Function:\n    //   represents the union of the ranges\n    //   {s[i]...s[i+1]} for each adjacent pair of characters \n    //   in s\n    ...\n}\n```", "```\nclass C {\n    private String s;\n    private String t;\n    ...\n}\n```", "```\npublic class CharSet {\n    private String s;\n    ...\n}\n```", "```\n// AF: represents the set of characters found in s\n// RI: s[0] < s[1] < ... < s[s.length()-1]\n```", "```\n// AF: represents the union of the ranges {s[i]...s[i+1]} for each adjacent pair of characters in s\n// RI: s.length is even, and s[0] < s[1] < ... < s[s.length()-1]\n```", "```\n// AF: represents the set of characters found in s\n// RI: s contains no character more than once\n```", "```\n// AF: represents the set of characters found in s\n// RI: true\n```", "```\npublic void add(char c) {\n    s = s + c;\n}\n```", "```\npublic void remove(char c) {\n    int position = s.indexOf(c);\n    if (position >= 0) {\n        s = s.substring(0, position) + s.substring(position+1, s.length());\n    }\n}\n```", "```\npublic boolean contains(char c) {\n    for (int i = 0; i < s.length(); i += 2) {\n        char low = s.charAt(i);\n        char high = s.charAt(i+1);\n        if (low <= c && c <= high) {\n            return true;\n        }\n    }\n    return false;\n}\n```", "```\npublic class RatNum {\n\n    private final int numer;\n    private final int denom;\n\n    // Rep invariant:\n    //   denom > 0\n    //   numer/denom is in reduced form\n\n    // Abstraction Function:\n    //   represents the rational number numer / denom\n\n    /** Make a new RatNum == n.\n     *  @param n value */\n    public RatNum(int n) {\n        numer = n;\n        denom = 1;\n        checkRep();\n    }\n\n    /** Make a new RatNum == (n / d).\n     *  @param n numerator\n     *  @param d denominator\n     *  @throws ArithmeticException if d == 0 */\n    public RatNum(int n, int d) throws ArithmeticException {\n        // reduce ratio to lowest terms\n        int g = gcd(n, d);\n        n = n / g;\n        d = d / g;\n\n        // make denominator positive\n        if (d < 0) {\n            numer = -n;\n            denom = -d;\n        } else {\n            numer = n;\n            denom = d;\n        }\n        checkRep();\n    }\n}\n```", "```\n// Check that the rep invariant is true\n// *** Warning: this does nothing unless you turn on assertion checking\n// by passing -enableassertions to Java\nprivate void checkRep() {\n    assert denom > 0;\n    assert gcd(numer, denom) == 1;\n}\n```", "```\nclass CharSet {\n    String s;\n}\n```", "```\nprivate void checkRep() {\n    assert s.length() % 2 == 0;\n    ...\n}\n```", "```\n// Immutable type representing a tweet.\npublic class Tweet {\n\n    private final String author;\n    private final String text;\n    private final Date timestamp;\n\n    // Rep invariant:\n    //   author is a Twitter username (a nonempty string of letters, digits, underscores)\n    //   text.length <= 140\n    // Abstraction Function:\n    //   represents a tweet posted by author, with content text, at time timestamp \n    // Safety from rep exposure:\n    //   All fields are private;\n    //   author and text are Strings, so are guaranteed immutable;\n    //   timestamp is a mutable Date, so Tweet() constructor and getTimestamp() \n    //        make defensive copies to avoid sharing the rep's Date object with clients.\n\n    // Operations (specs and method bodies omitted to save space)\n    public Tweet(String author, String text, Date timestamp) { ... }\n    public String getAuthor() { ... }\n    public String getText() { ... }\n    public Date getTimestamp() { ... }\n}\n```", "```\n// Immutable type representing a rational number.\npublic class RatNum {\n    private final int numer;\n    private final int denom;\n\n    // Rep invariant:\n    //   denom > 0\n    //   numer/denom is in reduced form, i.e. gcd(|numer|,denom) = 1\n    // Abstraction Function:\n    //   represents the rational number numer / denom\n    // Safety from rep exposure:\n    //   All fields are private, and all types in the rep are immutable.\n\n    // Operations (specs and method bodies omitted to save space)\n    public RatNum(int n) { ... }\n    public RatNum(int n, int d) throws ArithmeticException { ... }\n    ...\n}\n```", "```\n// Mutable type representing Twitter users' followers.\npublic class FollowGraph {\n    private final Map<String,Set<String>> followersOf;\n\n    // Rep invariant:\n    //    all Strings in followersOf are Twitter usernames\n    //           (i.e., nonempty strings of letters, digits, underscores)\n    //    no user follows themselves, i.e. x is not in followersOf.get(x)\n    // Abstraction function:\n    //    represents the follower graph where Twitter user x is followed by user y\n    //       if and only if followersOf.get(x).contains(y)\n    // Safety from rep exposure:\n    //    All fields are private, and ..???..\n\n    // Operations (specs and method bodies omitted to save space)\n    public FollowGraph() { ... }\n    public void addFollower(String user, String follower) { ... }\n    public void removeFollower(String user, String follower) { ... }\n    public Set<String> getFollowers(String user) { ... }\n}\n```", "```\n/** Represents an immutable right triangle. */\nclass RightTriangle {\n    private double[] sides;\n    // RI: ???\n    // AF: ???\n\n    // sides[0] and sides[1] are the two legs,\n    // and sides[2] is the hypotenuse, so declare it to avoid having a\n    // magic number in the code:\n    public static final int HYPOTENUSE = 2;\n\n    /** Make a right triangle.\n     * @param legA, legB  the two legs of the triangle\n     * @param hypotenuse    the hypotenuse of the triangle.\n     *        Requires hypotenuse^2 = legA^2 + legB^2 \n     *           (within the error tolerance of double arithmetic)\n     */\n    public RightTriangle(double legA, double legB, double hypotenuse) {\n        this.sides = new double[] { legA, legB, hypotenuse };\n    }\n\n    /** Get all the sides of the triangle.\n     *  @return three-element array with the triangle's side lengths\n     */\n    public double[] getAllSides() {\n        return sides;\n    }\n\n    /** @return length of the triangle's hypotenuse */ \n    public double getHypotenuse() {\n        return sides[HYPOTENUSE];\n    }\n\n    /** @param factor to multiply the sides by\n     *  @return a triangle made from this triangle by \n     *  multiplying all side lengths by factor.\n     */\n    public RightTriangle scale(double factor) {\n        return new RightTriangle (sides[0]*factor, sides[1]*factor, sides[2]*factor);\n    }\n\n    /** @return a regular triangle made from this triangle.\n     *  A regular right triangle is one in which\n     *  both legs have the same length.\n     */\n    public RightTriangle regularize() {\n        double bigLeg = Math.max(side[0], side[1]);\n        return new RightTriangle (bigLeg, bigLeg, side[2]);\n    }\n\n}\n```", "```\n/** \n * @param set1 is a sorted set of characters with no repeats\n * @param set2 is likewise\n * @return characters that appear in one set but not the other,\n *  in sorted order with no repeats \n */\nstatic String exclusiveOr(String set1, String set2);\n```", "```\n/** @return characters that appear in one set but not the other */\nstatic SortedSet<Character> exclusiveOr(SortedSet<Character>  set1, SortedSet<Character> set2);\n```", "```\n/**\n * Find tweets written by a particular user.\n * \n * @param tweets a list of tweets with distinct timestamps, not modified by this method.\n * @param username Twitter username (a nonempty sequence of letters, digits, and underscore)\n * @return all and only the tweets in the list whose author is username,\n *         in the same order as in the input list.\n */\npublic static List<Tweet> writtenBy(List<Tweet> tweets, String username) { ... }\n```"]