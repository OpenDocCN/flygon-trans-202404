["```\nlet list0 = List.empty\n// list0 = []\n\nlet list1 = List.singleton \"hello\"\n// list1 = [\"hello\"] \n```", "```\nlet repl = List.replicate 3 \"hello\"\n// val repl : string list = [\"hello\"; \"hello\"; \"hello\"]\n\nlet arrCreate = Array.create 3 \"hello\"\n// val arrCreate : string [] = [|\"hello\"; \"hello\"; \"hello\"|]\n\nlet intArr0 : int[] = Array.zeroCreate 3\n// val intArr0 : int [] = [|0; 0; 0|]\n\nlet stringArr0 : string[] = Array.zeroCreate 3\n// val stringArr0 : string [] = [|null; null; null|] \n```", "```\n// using list initializer\nlet listInit1 = List.init 5 (fun i-> i*i)\n// val listInit1 : int list = [0; 1; 4; 9; 16]\n\n// using list comprehension\nlet listInit2 = [for i in [1..5] do yield i*i]\n// val listInit2 : int list = [1; 4; 9; 16; 25]\n\n// literal \nlet listInit3 = [1; 4; 9; 16; 25]\n// val listInit3 : int list = [1; 4; 9; 16; 25]\n\nlet arrayInit3 = [|1; 4; 9; 16; 25|]\n// val arrayInit3 : int [] = [|1; 4; 9; 16; 25|] \n```", "```\n// literal with +2 increment\nlet listOdd= [1..2..10]\n// val listOdd : int list = [1; 3; 5; 7; 9] \n```", "```\n// using list comprehension\nlet listFunny = [\n    for i in [2..3] do \n        yield i\n        yield i*i\n        yield i*i*i\n        ]\n// val listFunny : int list = [2; 4; 8; 3; 9; 27] \n```", "```\nlet primesUpTo n = \n   let rec sieve l  = \n      match l with \n      | [] -> []\n      | p::xs -> \n            p :: sieve [for x in xs do if (x % p) > 0 then yield x]\n   [2..n] |> sieve \n\nprimesUpTo 20\n// [2; 3; 5; 7; 11; 13; 17; 19] \n```", "```\nlet rec listCounter n = [\n    if n <= 10 then\n        yield n\n        yield! listCounter (n+2)\n    ]\n\nlistCounter 3\n// val it : int list = [3; 5; 7; 9]\nlistCounter 4\n// val it : int list = [4; 6; 8; 10] \n```", "```\n// generator version\nlet seqOfSquares = Seq.initInfinite (fun i -> i*i)\nlet firstTenSquares = seqOfSquares |> Seq.take 10\n\nfirstTenSquares |> List.ofSeq // [0; 1; 4; 9; 16; 25; 36; 49; 64; 81]\n\n// recursive version\nlet seqOfSquares_v2 = \n    let rec loop n = seq {\n        yield n * n\n        yield! loop (n+1)\n        }\n    loop 1\nlet firstTenSquares_v2 = seqOfSquares_v2 |> Seq.take 10 \n```", "```\nlet getInputFromConsole lineNo =\n    let text = System.Console.ReadLine()\n    if System.String.IsNullOrEmpty(text) then\n        None\n    else\n        // return value and new threaded state\n        // \"text\" will be in the generated sequence\n        Some (text,lineNo+1)\n\nlet listUnfold = List.unfold getInputFromConsole 1 \n```", "```\nlet fibonacciUnfolder max (f1,f2)  =\n    if f1 > max then\n        None\n    else\n        // return value and new threaded state\n        let fNext = f1 + f2\n        let newState = (f2,fNext)\n        // f1 will be in the generated sequence\n        Some (f1,newState)\n\nlet fibonacci max = List.unfold (fibonacciUnfolder max) (1,1)\nfibonacci 100\n// int list = [1; 1; 2; 3; 5; 8; 13; 21; 34; 55; 89] \n```", "```\nlet head = [1;2;3] |> List.head\n// val head : int = 1\n\nlet badHead : int = [] |> List.head\n// System.ArgumentException: The input list was empty.\n\nlet goodHeadOpt = \n    [1;2;3] |> List.tryHead \n// val goodHeadOpt : int option = Some 1\n\nlet badHeadOpt : int option = \n    [] |> List.tryHead \n// val badHeadOpt : int option = None \n\nlet goodItemOpt = \n    [1;2;3] |> List.tryItem 2\n// val goodItemOpt : int option = Some 3\n\nlet badItemOpt = \n    [1;2;3] |> List.tryItem 99\n// val badItemOpt : int option = None \n```", "```\n// Don't do this!\nlet helloBad = \n    let list = [\"a\";\"b\";\"c\"]\n    let listSize = List.length list\n    [ for i in [0..listSize-1] do\n        let element = list |> List.item i\n        yield \"hello \" + element \n    ]\n// val helloBad : string list = [\"hello a\"; \"hello b\"; \"hello c\"] \n```", "```\nlet helloGood = \n    let list = [\"a\";\"b\";\"c\"]\n    list |> List.map (fun element -> \"hello \" + element)\n// val helloGood : string list = [\"hello a\"; \"hello b\"; \"hello c\"] \n```", "```\nlet listOfTuples = [ (1,\"a\"); (2,\"b\"); (3,\"b\"); (4,\"a\"); ]\n\nlistOfTuples |> List.find ( fun (x,y) -> y = \"b\")\n// (2, \"b\")\n\nlistOfTuples |> List.findBack ( fun (x,y) -> y = \"b\")\n// (3, \"b\")\n\nlistOfTuples |> List.findIndex ( fun (x,y) -> y = \"b\")\n// 1\n\nlistOfTuples |> List.findIndexBack ( fun (x,y) -> y = \"b\")\n// 2\n\nlistOfTuples |> List.find ( fun (x,y) -> y = \"c\")\n// KeyNotFoundException \n```", "```\nlistOfTuples |> List.pick ( fun (x,y) -> if y = \"b\" then Some (x,y) else None)\n// (2, \"b\") \n```", "```\n// string -> int option\nlet tryInt str = \n    match System.Int32.TryParse(str) with\n    | true, i -> Some i\n    | false, _ -> None \n```", "```\nlet firstValidNumber = \n    [\"a\";\"2\";\"three\"]\n    // map the input\n    |> List.map tryInt \n    // find the first Some\n    |> List.find (fun opt -> opt.IsSome)\n    // get the data from the option\n    |> Option.get\n// val firstValidNumber : int = 2 \n```", "```\nlet firstValidNumber = \n    [\"a\";\"2\";\"three\"]\n    |> List.pick tryInt \n```", "```\n[1..10] |> List.take 3    \n// [1; 2; 3]\n\n[1..10] |> List.takeWhile (fun i -> i < 3)    \n// [1; 2]\n\n[1..10] |> List.truncate 4\n// [1; 2; 3; 4]\n\n[1..2] |> List.take 3    \n// System.InvalidOperationException: The input sequence has an insufficient number of elements.\n\n[1..2] |> List.takeWhile (fun i -> i < 3)  \n// [1; 2]\n\n[1..2] |> List.truncate 4\n// [1; 2]   // no error! \n```", "```\n[1..10] |> List.skip 3    \n// [4; 5; 6; 7; 8; 9; 10]\n\n[1..10] |> List.skipWhile (fun i -> i < 3)    \n// [3; 4; 5; 6; 7; 8; 9; 10]\n\n[1..10] |> List.tail\n// [2; 3; 4; 5; 6; 7; 8; 9; 10]\n\n[1..2] |> List.skip 3    \n// System.ArgumentException: The index is outside the legal range.\n\n[1..2] |> List.skipWhile (fun i -> i < 3)  \n// []\n\n[1] |> List.tail |> List.tail\n// System.ArgumentException: The input list was empty. \n```", "```\n[1..10] |> List.filter (fun i -> i%2 = 0) // even\n// [2; 4; 6; 8; 10]\n\n[1..10] |> List.where (fun i -> i%2 = 0) // even\n// [2; 4; 6; 8; 10]\n\n[1..10] |> List.except [3;4;5]\n// [1; 2; 6; 7; 8; 9; 10] \n```", "```\nArray.sub [|1..10|] 3 5\n// [|4; 5; 6; 7; 8|]\n\n[1..10].[3..5] \n// [4; 5; 6]\n\n[1..10].[3..] \n// [4; 5; 6; 7; 8; 9; 10]\n\n[1..10].[..5] \n// [1; 2; 3; 4; 5; 6] \n```", "```\n[1;1;1;2;3;3] |> List.distinct\n// [1; 2; 3]\n\n[ (1,\"a\"); (1,\"b\"); (1,\"c\"); (2,\"d\")] |> List.distinctBy fst\n// [(1, \"a\"); (2, \"d\")] \n```", "```\n// string -> int option\nlet tryInt str = \n    match System.Int32.TryParse(str) with\n    | true, i -> Some i\n    | false, _ -> None \n```", "```\nlet allValidNumbers = \n    [\"a\";\"2\";\"three\"; \"4\"]\n    // map the input\n    |> List.map tryInt \n    // include only the \"Some\"\n    |> List.filter (fun opt -> opt.IsSome)\n    // get the data from each option\n    |> List.map Option.get\n// val allValidNumbers : int list = [2; 4] \n```", "```\nlet allValidNumbers = \n    [\"a\";\"2\";\"three\"; \"4\"]\n    |> List.choose tryInt \n```", "```\nlet reduceOptions = \n    [None; Some 1; None; Some 2]\n    |> List.choose id\n// val reduceOptions : int list = [1; 2] \n```", "```\n[1..10] |> List.chunkBySize 3\n// [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]; [10]] \n// note that the last chunk has one element\n\n[1..10] |> List.splitInto 3\n// [[1; 2; 3; 4]; [5; 6; 7]; [8; 9; 10]]\n// note that the first chunk has four elements\n\n['a'..'i'] |> List.splitAt 3\n// (['a'; 'b'; 'c'], ['d'; 'e'; 'f'; 'g'; 'h'; 'i'])\n\n['a'..'e'] |> List.pairwise\n// [('a', 'b'); ('b', 'c'); ('c', 'd'); ('d', 'e')]\n\n['a'..'e'] |> List.windowed 3\n// [['a'; 'b'; 'c']; ['b'; 'c'; 'd']; ['c'; 'd'; 'e']]\n\nlet isEven i = (i%2 = 0)\n[1..10] |> List.partition isEven \n// ([2; 4; 6; 8; 10], [1; 3; 5; 7; 9])\n\nlet firstLetter (str:string) = str.[0]\n[\"apple\"; \"alice\"; \"bob\"; \"carrot\"] |> List.groupBy firstLetter \n// [('a', [\"apple\"; \"alice\"]); ('b', [\"bob\"]); ('c', [\"carrot\"])] \n```", "```\n[1] |> List.chunkBySize 3\n// [[1]]\n\n[1] |> List.splitInto 3\n// [[1]]\n\n['a'; 'b'] |> List.splitAt 3\n// InvalidOperationException: The input sequence has an insufficient number of elements.\n\n['a'] |> List.pairwise\n// InvalidOperationException: The input sequence has an insufficient number of elements.\n\n['a'] |> List.windowed 3\n// []\n\n[1] |> List.partition isEven \n// ([], [1])\n\n[] |> List.groupBy firstLetter \n//  [] \n```", "```\n[\"a\";\"b\";\"c\"] |> List.reduce (+)     \n// \"abc\" \n```", "```\n\"a\" + \"b\" + \"c\" \n```", "```\n[2;3;4] |> List.reduce (*)     \n// is same as\n2 * 3 * 4\n// Result is 24 \n```", "```\n[1;2;3;4] |> List.reduce (fun state x -> (state)*10 + x)\n\n// built up from                // state at each step\n1                               // 1\n(1)*10 + 2                      // 12 \n((1)*10 + 2)*10 + 3             // 123 \n(((1)*10 + 2)*10 + 3)*10 + 4    // 1234\n\n// Final result is 1234 \n```", "```\n[1;2;3;4] |> List.reduceBack (fun x state -> x + 10*(state))\n\n// built up from                // state at each step\n4                               // 4\n3 + 10*(4)                      // 43 \n2 + 10*(3 + 10*(4))             // 432 \n1 + 10*(2 + 10*(3 + 10*(4)))    // 4321 \n\n// Final result is 4321 \n```", "```\ntype Suit = Club | Diamond | Spade | Heart \ntype Rank = Two | Three | King | Ace\nlet cards = [ (Club,King); (Diamond,Ace); (Spade,Two); (Heart,Three); ]\n\ncards |> List.max        // (Heart, Three)\ncards |> List.maxBy snd  // (Diamond, Ace)\ncards |> List.min        // (Club, King)\ncards |> List.minBy snd  // (Spade, Two)\n\n[1..10] |> List.sum\n// 55\n\n[ (1,\"a\"); (2,\"b\") ] |> List.sumBy fst\n// 3\n\n[1..10] |> List.average\n// The type 'int' does not support the operator 'DivideByInt'\n\n[1..10] |> List.averageBy float\n// 5.5\n\n[ (1,\"a\"); (2,\"b\") ] |> List.averageBy (fst >> float)\n// 1.5\n\n[1..10] |> List.length\n// 10\n\n[ (\"a\",\"A\"); (\"b\",\"B\"); (\"a\",\"C\") ]  |> List.countBy fst\n// [(\"a\", 2); (\"b\", 1)]\n\n[ (\"a\",\"A\"); (\"b\",\"B\"); (\"a\",\"C\") ]  |> List.countBy snd\n// [(\"A\", 1); (\"B\", 1); (\"C\", 1)] \n```", "```\nlet emptyListOfInts : int list = []\n\nemptyListOfInts |> List.reduce (+)     \n// ArgumentException: The input list was empty.\n\nemptyListOfInts |> List.max\n// ArgumentException: The input sequence was empty.\n\nemptyListOfInts |> List.min\n// ArgumentException: The input sequence was empty.\n\nemptyListOfInts |> List.sum      \n// 0\n\nemptyListOfInts |> List.averageBy float\n// ArgumentException: The input sequence was empty.\n\nlet emptyListOfTuples : (int*int) list = []\nemptyListOfTuples |> List.countBy fst\n// (int * int) list = [] \n```", "```\n[1..5] |> List.rev\n// [5; 4; 3; 2; 1]\n\n[2;4;1;3;5] |> List.sort\n// [1; 2; 3; 4; 5]\n\n[2;4;1;3;5] |> List.sortDescending\n// [5; 4; 3; 2; 1]\n\n[ (\"b\",\"2\"); (\"a\",\"3\"); (\"c\",\"1\") ]  |> List.sortBy fst\n// [(\"a\", \"3\"); (\"b\", \"2\"); (\"c\", \"1\")]\n\n[ (\"b\",\"2\"); (\"a\",\"3\"); (\"c\",\"1\") ]  |> List.sortBy snd\n// [(\"c\", \"1\"); (\"b\", \"2\"); (\"a\", \"3\")]\n\n// example of a comparer\nlet tupleComparer tuple1 tuple2  =\n    if tuple1 < tuple2 then \n        -1 \n    elif tuple1 > tuple2 then \n        1 \n    else\n        0\n\n[ (\"b\",\"2\"); (\"a\",\"3\"); (\"c\",\"1\") ]  |> List.sortWith tupleComparer\n// [(\"a\", \"3\"); (\"b\", \"2\"); (\"c\", \"1\")]\n\n[1..10] |> List.permute (fun i -> (i + 3) % 10)\n// [8; 9; 10; 1; 2; 3; 4; 5; 6; 7]\n\n[1..10] |> List.permute (fun i -> 9 - i)\n// [10; 9; 8; 7; 6; 5; 4; 3; 2; 1] \n```", "```\n[1..10] |> List.contains 5\n// true\n\n[1..10] |> List.contains 42\n// false\n\n[1..10] |> List.exists (fun i -> i > 3 && i < 5)\n// true\n\n[1..10] |> List.exists (fun i -> i > 5 && i < 3)\n// false\n\n[1..10] |> List.forall (fun i -> i > 0)\n// true\n\n[1..10] |> List.forall (fun i -> i > 5)\n// false\n\n[1..10] |> List.isEmpty\n// false \n```", "```\nlet add1 x = x + 1\n\n// map as a list transformer\n[1..5] |> List.map add1\n// [2; 3; 4; 5; 6]\n\n// the list being mapped over can contain anything!\nlet times2 x = x * 2\n[ add1; times2] |> List.map (fun f -> f 5)\n// [6; 10] \n```", "```\nlet add1ToEachElement = List.map add1\n// \"add1ToEachElement\" transforms lists to lists rather than ints to ints\n// val add1ToEachElement : (int list -> int list)\n\n// now use it\n[1..5] |> add1ToEachElement \n// [2; 3; 4; 5; 6] \n```", "```\n[2..5] |> List.collect (fun x -> [x; x*x; x*x*x] )\n// [2; 4; 8; 3; 9; 27; 4; 16; 64; 5; 25; 125]\n\n// using \"id\" with collect\nlet list1 = [1..3]\nlet list2 = [4..6]\n[list1; list2] |> List.collect id\n// [1; 2; 3; 4; 5; 6] \n```", "```\nopen System.Text.RegularExpressions\n\nlet matches = \n    let pattern = \"\\d\\d\\d\"\n    let matchCollection = Regex.Matches(\"123 456 789\",pattern)\n    matchCollection\n    |> Seq.map (fun m -> m.Value)     // ERROR\n    // ERROR: The type 'MatchCollection' is not compatible with the type 'seq<'a>'\n    |> Seq.toList \n```", "```\nlet matches = \n    let pattern = \"\\d\\d\\d\"\n    let matchCollection = Regex.Matches(\"123 456 789\",pattern)\n    matchCollection\n    |> Seq.cast<Match> \n    |> Seq.map (fun m -> m.Value)\n    |> Seq.toList\n// output = [\"123\"; \"456\"; \"789\"] \n```", "```\n[1..3] |> List.iter (fun i -> printfn \"i is %i\" i)\n(*\ni is 1\ni is 2\ni is 3\n*)\n\n// or using partial application\n[1..3] |> List.iter (printfn \"i is %i\")\n\n// or using a for loop\nfor i = 1 to 3 do\n    printfn \"i is %i\" i\n\n// or using a for-in loop\nfor i in [1..3] do\n    printfn \"i is %i\" i \n```", "```\n[1..3] |> List.iter (fun i -> i + 1)\n//                               ~~~\n// ERROR error FS0001: The type 'unit' does not match the type 'int'\n\n// a for-loop expression *must* return unit\nfor i in [1..3] do\n     i + 1  // ERROR\n     // This expression should have type 'unit', \n     // but has type 'int'. Use 'ignore' ... \n```", "```\n[1..3] |> List.iter (fun i -> i + 1 |> ignore)\n\nfor i in [1..3] do\n     i + 1 |> ignore \n```", "```\n[\"a\";\"b\";\"c\"] |> List.fold (+) \"hello: \"    \n// \"hello: abc\"\n// \"hello: \" + \"a\" + \"b\" + \"c\"\n\n[1;2;3] |> List.fold (+) 10    \n// 16\n// 10 + 1 + 2 + 3 \n```", "```\n[1;2;3;4] |> List.fold (fun state x -> (state)*10 + x) 0\n                                // state at each step\n1                               // 1\n(1)*10 + 2                      // 12 \n((1)*10 + 2)*10 + 3             // 123 \n(((1)*10 + 2)*10 + 3)*10 + 4    // 1234\n// Final result is 1234 \n```", "```\nList.foldBack (fun x state -> x + 10*(state)) [1;2;3;4] 0\n                                // state at each step \n4                               // 4\n3 + 10*(4)                      // 43 \n2 + 10*(3 + 10*(4))             // 432 \n1 + 10*(2 + 10*(3 + 10*(4)))    // 4321 \n// Final result is 4321 \n```", "```\nlet iterativeSum list = \n    let mutable total = 0\n    for e in list do\n        total <- total + e\n    total // return sum \n```", "```\nlet rec recursiveSum list = \n    match list with\n    | [] -> \n        0\n    | head::tail -> \n        head + (recursiveSum tail) \n```", "```\nlet rec mapToString list = \n    match list with\n    | [] -> \n        []\n    | head::tail -> \n        head.ToString() :: (mapToString tail)\n\n[1..3] |> mapToString \n// [\"1\"; \"2\"; \"3\"] \n```", "```\nlet foldToString list = \n    let folder head state = \n        head.ToString() :: state\n    List.foldBack folder list []\n\n[1..3] |> foldToString \n// [\"1\"; \"2\"; \"3\"] \n```", "```\n// inline version of \"foldToString\"\n[1..3] \n|> List.fold (fun state head -> head.ToString() :: state) []\n|> List.rev\n// [\"1\"; \"2\"; \"3\"] \n```", "```\n/// map a function \"f\" over all elements\nlet myMap f list = \n    // helper function\n    let folder state head =\n        f head :: state\n\n    // main flow\n    list\n    |> List.fold folder []\n    |> List.rev\n\n[1..3] |> myMap (fun x -> x + 2)\n// [3; 4; 5] \n```", "```\n/// return a new list of elements for which \"pred\" is true\nlet myFilter pred list = \n    // helper function\n    let folder state head =\n        if pred head then \n            head :: state\n        else\n            state\n\n    // main flow\n    list\n    |> List.fold folder []\n    |> List.rev\n\nlet isOdd n = (n%2=1)\n[1..5] |> myFilter isOdd \n// [1; 3; 5] \n```", "```\n[1;2;3;4] |> List.fold (fun state x -> (state)*10 + x) 0\n                                // state at each step\n1                               // 1\n(1)*10 + 2                      // 12 \n((1)*10 + 2)*10 + 3             // 123 \n(((1)*10 + 2)*10 + 3)*10 + 4    // 1234\n// Final result is 1234 \n```", "```\n[1;2;3;4] |> List.scan (fun state x -> (state)*10 + x) 0\n// accumulates from left ===> [0; 1; 12; 123; 1234] \n```", "```\nList.scanBack (fun x state -> (state)*10 + x) [1;2;3;4] 0\n// [4321; 432; 43; 4; 0]  <=== accumulates from right \n```", "```\n// start by splitting the text into words\nlet text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor.\"\nlet words = text.Split(' ')\n// [|\"Lorem\"; \"ipsum\"; \"dolor\"; \"sit\"; ... ]\n\n// accumulate a series of fragments\nlet fragments = words |> Seq.scan (fun frag word -> frag + \" \" + word) \"\"\n(*\n\" Lorem\" \n\" Lorem ipsum\" \n\" Lorem ipsum dolor\"\n\" Lorem ipsum dolor sit\" \n\" Lorem ipsum dolor sit amet,\"\netc\n*)\n\n// get the longest fragment under 50\nlet longestFragUnder50 = \n    fragments \n    |> Seq.takeWhile (fun s -> s.Length <= 50) \n    |> Seq.last \n\n// trim off the first blank\nlet longestFragUnder50Trimmed = \n    longestFragUnder50 |> (fun s -> s.[1..])\n\n// The result is:\n//   \"Lorem ipsum dolor sit amet, consectetur\" \n```", "```\n// the whole thing as a function\nlet truncText max (text:string) = \n    if text.Length <= max then\n        text\n    else\n        text.Split(' ')\n        |> Seq.scan (fun frag word -> frag + \" \" + word) \"\"\n        |> Seq.takeWhile (fun s -> s.Length <= max-3) \n        |> Seq.last \n        |> (fun s -> s.[1..] + \"...\")\n\n\"a small headline\" |> truncText 50\n// \"a small headline\"\n\ntext |> truncText 50\n// \"Lorem ipsum dolor sit amet, consectetur...\" \n```", "```\nlet add1 x = x + 1\n\n// add1 using map\n[1..5] |> List.map (add1)   \n// Result => [2; 3; 4; 5; 6]\n\n// sum using fold\n[1..5] |> List.fold (fun state x -> state + x) 0   \n// Result => 15\n\n// map and sum using mapFold\n[1..5] |> List.mapFold (fun state x -> add1 x, (state + x)) 0   \n// Result => ([2; 3; 4; 5; 6], 15) \n```", "```\n['a'..'c'] |> List.mapi (fun index ch -> sprintf \"the %ith element is '%c'\" index ch)\n// [\"the 0th element is 'a'\"; \"the 1th element is 'b'\"; \"the 2th element is 'c'\"]\n\n// with partial application\n['a'..'c'] |> List.mapi (sprintf \"the %ith element is '%c'\")\n// [\"the 0th element is 'a'\"; \"the 1th element is 'b'\"; \"the 2th element is 'c'\"]\n\n['a'..'c'] |> List.iteri (printfn \"the %ith element is '%c'\")\n(*\nthe 0th element is 'a'\nthe 1th element is 'b'\nthe 2th element is 'c'\n*) \n```", "```\n['a'..'c'] |> List.mapi (fun index ch -> (index, ch) )\n// [(0, 'a'); (1, 'b'); (2, 'c')]\n\n// \"indexed\" is a shorter version of above\n['a'..'c'] |> List.indexed\n// [(0, 'a'); (1, 'b'); (2, 'c')] \n```", "```\n[1..5] |> List.toArray      // [|1; 2; 3; 4; 5|]\n[1..5] |> Array.ofList      // [|1; 2; 3; 4; 5|]\n// etc \n```", "```\nlet uncachedSeq = seq {\n    for i = 1 to 3 do\n        printfn \"Calculating %i\" i\n        yield i\n    }\n\n// iterate twice \nuncachedSeq |> Seq.iter ignore\nuncachedSeq |> Seq.iter ignore \n```", "```\nCalculating 1\nCalculating 2\nCalculating 3\nCalculating 1\nCalculating 2\nCalculating 3 \n```", "```\nlet cachedSeq = uncachedSeq |> Seq.cache\n\n// iterate twice \ncachedSeq |> Seq.iter ignore\ncachedSeq |> Seq.iter ignore \n```", "```\nCalculating 1\nCalculating 2\nCalculating 3 \n```", "```\n// print the underlying type of the sequence\nlet printUnderlyingType (s:seq<_>) =\n    let typeName = s.GetType().Name \n    printfn \"%s\" typeName \n\n[|1;2;3|] |> printUnderlyingType \n// Int32[]\n\n[|1;2;3|] |> Seq.readonly |> printUnderlyingType \n// mkSeq@589   // a temporary type \n```", "```\nlet makeNumbers max =\n    [ for i = 1 to max do\n        printfn \"Evaluating %d.\" i\n        yield i ]\n\nlet eagerList = \n    printfn \"Started creating eagerList\" \n    let list = makeNumbers 5\n    printfn \"Finished creating eagerList\" \n    list\n\nlet delayedSeq = \n    printfn \"Started creating delayedSeq\" \n    let list = Seq.delay (fun () -> makeNumbers 5 |> Seq.ofList)\n    printfn \"Finished creating delayedSeq\" \n    list \n```", "```\nStarted creating eagerList\nEvaluating 1.\nEvaluating 2.\nEvaluating 3.\nEvaluating 4.\nEvaluating 5.\nFinished creating eagerList\n\nStarted creating delayedSeq\nFinished creating delayedSeq \n```", "```\neagerList |> Seq.take 3  // list already created\ndelayedSeq |> Seq.take 3 // list creation triggered \n```", "```\nlet embeddedList = seq {\n    printfn \"Started creating embeddedList\" \n    yield! makeNumbers 5 \n    printfn \"Finished creating embeddedList\" \n    } \n```", "```\nlet intList1 = [2;3;4]\nlet intList2 = [5;6;7]\n\nList.map2 (fun i1 i2 -> i1 + i2) intList1 intList2 \n//  [7; 9; 11]\n\n// TIP use the ||> operator to pipe a tuple as two arguments\n(intList1,intList2) ||> List.map2 (fun i1 i2 -> i1 + i2) \n//  [7; 9; 11]\n\n(intList1,intList2) ||> List.mapi2 (fun index i1 i2 -> index,i1 + i2) \n // [(0, 7); (1, 9); (2, 11)]\n\n(intList1,intList2) ||> List.iter2 (printf \"i1=%i i2=%i; \") \n// i1=2 i2=5; i1=3 i2=6; i1=4 i2=7;\n\n(intList1,intList2) ||> List.iteri2 (printf \"index=%i i1=%i i2=%i; \") \n// index=0 i1=2 i2=5; index=1 i1=3 i2=6; index=2 i1=4 i2=7;\n\n(intList1,intList2) ||> List.forall2 (fun i1 i2 -> i1 < i2)  \n// true\n\n(intList1,intList2) ||> List.exists2 (fun i1 i2 -> i1+10 > i2)  \n// true\n\n(intList1,intList2) ||> List.fold2 (fun state i1 i2 -> (10*state) + i1 + i2) 0 \n// 801 = 234 + 567\n\nList.foldBack2 (fun i1 i2 state -> i1 + i2 + (10*state)) intList1 intList2 0 \n// 1197 = 432 + 765\n\n(intList1,intList2) ||> List.compareWith (fun i1 i2 -> i1.CompareTo(i2))  \n// -1\n\n(intList1,intList2) ||> List.append\n// [2; 3; 4; 5; 6; 7]\n\n[intList1;intList2] |> List.concat\n// [2; 3; 4; 5; 6; 7]\n\n(intList1,intList2) ||> List.zip\n// [(2, 5); (3, 6); (4, 7)] \n```", "```\n/// Apply a function to each element in a pair\n/// If either result passes, include that pair in the result\nlet filterOr2 filterPredicate list1 list2 =\n    let pass e = filterPredicate e \n    let folder e1 e2 state =    \n        if (pass e1) || (pass e2) then\n            (e1,e2)::state\n        else\n            state\n    List.foldBack2 folder list1 list2 ([])\n\n/// Apply a function to each element in a pair\n/// Only if both results pass, include that pair in the result\nlet filterAnd2 filterPredicate list1 list2 =\n    let pass e = filterPredicate e \n    let folder e1 e2 state =     \n        if (pass e1) && (pass e2) then\n            (e1,e2)::state\n        else\n            state\n    List.foldBack2 folder list1 list2 []\n\n// test it\nlet startsWithA (s:string) = (s.[0] = 'A')\nlet strList1 = [\"A1\"; \"A3\"]\nlet strList2 = [\"A2\"; \"B1\"]\n\n(strList1, strList2) ||> filterOr2 startsWithA \n// [(\"A1\", \"A2\"); (\"A3\", \"B1\")]\n(strList1, strList2) ||> filterAnd2 startsWithA \n// [(\"A1\", \"A2\")] \n```", "```\nlet (<*>) fList xList = \n    List.map2 (fun f x -> f x) fList xList \n\nlet (<!>) = List.map\n\nlet addFourParams x y z w = \n    x + y + z + w\n\n// lift \"addFourParams\" to List world and pass lists as parameters rather than ints\naddFourParams <!> [1;2;3] <*> [1;2;3] <*> [1;2;3] <*> [1;2;3] \n// Result = [4; 8; 12] \n```", "```\nList.append [1;2;3] [4;5;6]\n// [1; 2; 3; 4; 5; 6]\n\n[1;2;3] @ [4;5;6]\n// [1; 2; 3; 4; 5; 6]\n\nList.concat [ [1]; [2;3]; [4;5;6] ]\n// [1; 2; 3; 4; 5; 6]\n\nList.zip [1;2] [10;20] \n// [(1, 10); (2, 20)]\n\nList.zip3 [1;2] [10;20] [100;200]\n// [(1, 10, 100); (2, 20, 200)]\n\nList.unzip [(1, 10); (2, 20)]\n// ([1; 2], [10; 20])\n\nList.unzip3 [(1, 10, 100); (2, 20, 200)]\n// ([1; 2], [10; 20], [100; 200]) \n```", "```\nList.zip [1;2] [10] \n// ArgumentException: The lists had different lengths. \n```", "```\n// a disposable database connection\nlet DbConnection() = \n    printfn \"Opening connection\"\n    { new System.IDisposable with\n        member this.Dispose() =\n            printfn \"Disposing connection\" }\n\n// read some records from the database\nlet readNCustomersFromDb dbConnection n =\n    let makeCustomer i = \n        sprintf \"Customer %i\" i\n\n    seq {\n        for i = 1 to n do\n            let customer = makeCustomer i\n            printfn \"Loading %s from db\" customer \n            yield customer \n        } \n\n// show some records on the screen\nlet showCustomersinUI customers = \n    customers |> Seq.iter (printfn \"Showing %s in UI\") \n```", "```\nlet readCustomersFromDb() =\n    use dbConnection = DbConnection()\n    let results = readNCustomersFromDb dbConnection 2\n    results\n\nlet customers = readCustomersFromDb()\ncustomers |> showCustomersinUI \n```", "```\nOpening connection\nDisposing connection\nLoading Customer 1 from db  // error! connection closed!\nShowing Customer 1 in UI\nLoading Customer 2 from db\nShowing Customer 2 in UI \n```", "```\nlet readCustomersFromDb() =\n    use dbConnection = DbConnection()\n    let results = readNCustomersFromDb dbConnection 2\n    results |> List.ofSeq\n    // Convert to list while connection is open\n\nlet customers = readCustomersFromDb()\ncustomers |> showCustomersinUI \n```", "```\nOpening connection\nLoading Customer 1 from db\nLoading Customer 2 from db\nDisposing connection\nShowing Customer 1 in UI\nShowing Customer 2 in UI \n```", "```\nlet readCustomersFromDb() =\n    seq {\n        // put disposable inside the sequence\n        use dbConnection = DbConnection()\n        yield! readNCustomersFromDb dbConnection 2\n        } \n\nlet customers = readCustomersFromDb()\ncustomers |> showCustomersinUI \n```", "```\nOpening connection\nLoading Customer 1 from db\nShowing Customer 1 in UI\nLoading Customer 2 from db\nShowing Customer 2 in UI\nDisposing connection \n```"]