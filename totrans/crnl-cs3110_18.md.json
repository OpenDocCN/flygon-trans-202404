["```\n  module type REF =\n    sig\n      type 'a ref\n\n      (* ref(x) creates a new ref containing x *)\n      val ref : 'a -> 'a ref\n\n     (* !x is the contents of the ref cell x *)\n      val (!) : 'a ref -> 'a\n\n      (* Effects: x := y updates the contents of x\n       * so it contains y. *)\n      val (:=) : 'a ref -> 'a -> unit\n    end\n```", "```\n    let x : int ref = ref 3 in\n    let y : int = !x in\n        (x := !x + 1);\n        y + !x\n    end\n```", "```\n    module type MUTABLE_STACK =\n      sig\n        (* An 'a mstack is a mutable stack of 'a elements *)\n        type 'a mstack\n\n        (* empty () is a new empty stack *)\n        val empty : unit -> 'a mstack\n\n        (* Effects: push m x pushes x onto m *)\n        val push : 'a mstack -> 'a -> unit\n\n        (* pop m is the head of m.\n         * Effects: pops the head off the stack. *)\n         val pop : 'a mstack -> 'a option\n    end\n\n    module Mutable_Stack : MUTABLE_STACK =\n      struct\n        (* A mutable stack is a reference\n         * to the list of values, with the top\n         * of the stack at the head. *)\n        type 'a mstack = ('a list) ref\n\n        let empty () : 'a mstack = ref []\n\n        let push (s: 'a mstack) (x: 'a) : unit =\n          s := x::(!s)\n\n        let pop (s: 'a mstack) : 'a option =\n          match (!s) with\n            [] -> None\n          | hd::tl -> (s := tl); Some hd\n    end\n\n```", "```\n  module type ARRAY =\n    sig\n      (* Overview: an 'a array is a mutable fixed-length sequence of\n       * elements of type 'a. *)\n      type 'a array\n\n      (* make n x is a new array of length n whose elements are\n       * all equal to x. *)\n      val make : int -> 'a -> 'a array\n\n      (* of_list lst is a new array containing the values in lst *)\n      val of_list : 'a list -> 'a array\n\n      (* normally indicates an out-of-bounds array index *)\n      exception Invalid_argument of string \n\n      (* get a i is the ith element in a. If i is\n       * out of bounds, raise Invalid_argument \"index out of bounds\" *)\n      val get : 'a array -> int -> 'a\n\n      (* set a i x\n       * Effects: Set the ith element of a to x\n       * Raise Invalid_argument if i is not a legal index into a *)\n      val set : 'a array -> int -> 'a -> unit\n\n      (* length a is the length of a *)\n      val length : 'a array -> int\n\n      ...\n    end\n```", "```\n# let a = ref 2;;\nval a : int ref = {contents = 2}\n# let b = ref 2;;\nval b : int ref = {contents = 2}\n# let c = a;;\n# a = b;;\n- : bool = true\n# a == b;;\n- : bool = false\n# a = c;;\n- : bool = true\n# a == c;;\n- : bool = true\n\n```", "```\nlet x = ref 0 in\nlet y = x in\n    x := 1;\n    !y\n\n```", "```\n\u00a0What does this evaluate to? We can use the model about to figure it out:\n```", "```\nlet x = ref 0 in\nlet y = x in\n    x := 1; !y\nMemory: (empty)\n-->\nlet x = *loc1* in\nlet y = x in\n    x := 1; !y\nMemory: (loc1 = 0)\n-->   (substitute *loc1* for x)\nlet y = *loc1* in\n    *loc1* := 1; !y\nMemory: (loc1 = 0)\n-->   (substitute *loc1* for y)\n*loc1* := 1; !*loc1* Memory: (loc1 = 0)--> !*loc1* Memory: (loc1 = 1)\n--> 1\nMemory: (loc1 = 1)\n```"]