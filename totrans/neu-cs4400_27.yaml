- en: Introducing Racket’s `lambda`Tuesday, January 31st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`fun` & `lambda` difference between lambda and simple values not being able
    to do recursive functions with `let` let* as a derived form let with lambda in
    Racket –> can be a derived form how `if` can be used to implement `and` and `or`
    as derived forms'
  prefs: []
  type: TYPE_NORMAL
- en: Newtonian syntax vs. a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t be fooled into making a bogus connection between Racket’s syntax, and
    its `unique` powers… The fact is that it is not the only language that has this
    capability. For example, this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Can be written in JavaScript like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In Perl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In Ruby:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: etc. Even [Java has lambda expressions](http://www.drdobbs.com/jvm/lambda-expressions-in-java-8/240166764),
    and recently [C++ added them too](http://www.cprogramming.com/c++11/c++11-lambda-closures.html).
  prefs: []
  type: TYPE_NORMAL
