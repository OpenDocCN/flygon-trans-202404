["```\n{with {x 1}\u00a0 {fun {y}\u00a0 \u00a0 {+ x y}}}\n```", "```\n{fun {y} {+ 1 y}}\n```", "```\n{with {f {with {x 1} {fun {y} {+ x y}}}}\u00a0 {with {x 2}\u00a0 \u00a0 {call f 3}}}\n```", "```\n{with {x 1}\u00a0 {fun {y}\u00a0 \u00a0 {+ x y}}}\n```", "```\n{fun {y} {+ x y}}\n```", "```\n- formal argument(s):\u00a0 \u00a0 {y}- body:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {+ x y}- pending substitutions: [1/x]\n```", "```\neval(N,sc)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = Neval({+ E1 E2},sc)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,sc) + eval(E2,sc)eval({- E1 E2},sc)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,sc) - eval(E2,sc)eval({* E1 E2},sc)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,sc) * eval(E2,sc)eval({/ E1 E2},sc)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,sc) / eval(E2,sc)eval(x,sc)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = lookup(x,sc)eval({with {x E1} E2},sc) = eval(E2,extend(x,eval(E1,sc),sc))eval({fun {x} E},sc)\u00a0 \u00a0 \u00a0 = <{fun {x} E}, sc>eval({call E1 E2},sc1)\u00a0 \u00a0 \u00a0 \u00a0  = eval(Ef,extend(x,eval(E2,sc1),sc2))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  if eval(E1,sc1) = <{fun {x} Ef}, sc2>\u00a0 \u00a0 \u00a0 \u00a0  = error!\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 otherwise\n```", "```\neval(N,env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = Neval({+ E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) + eval(E2,env)eval({- E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) - eval(E2,env)eval({* E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) * eval(E2,env)eval({/ E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) / eval(E2,env)eval(x,env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = lookup(x,env)eval({with {x E1} E2},env) = eval(E2,extend(x,eval(E1,env),env))eval({fun {x} E},env)\u00a0 \u00a0 \u00a0 = <{fun {x} E}, env>eval({call E1 E2},env1)\u00a0 \u00a0 \u00a0 \u00a0  = eval(Ef,extend(x,eval(E2, env1),env2))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  if eval(E1,env1) = <{fun {x} Ef}, env2>\u00a0 \u00a0 \u00a0 \u00a0  = error!\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 otherwise\n```", "```\n1\\. f := evaluate E1 in env12\\. if f is not a <{fun ...},...> closure then error!3\\. x := evaluate E2 in env14\\. new_env := extend env_of(f) by mapping arg_of(f) to x5\\. evaluate (and return) body_of(f) in new_env\n```", "```\n;; a type for environments:(define-type ENV = (Listof (List Symbol VAL)))\n```", "```\n(define-type ENV\u00a0 [EmptyEnv]\u00a0 [Extend Symbol VAL ENV])\n```", "```\n(: lookup : Symbol ENV -> VAL);; lookup a symbol in an environment, return its value or throw an;; error if it isn't bound(define (lookup name env)\u00a0 (cases env\u00a0 \u00a0 [(EmptyEnv) (error 'lookup \"no binding for ~s\" name)]\u00a0 \u00a0 [(Extend id val rest-env)\u00a0 \u00a0  (if (eq? id name) val (lookup name rest-env))]))\n```", "```\n(define-type VAL\u00a0 [NumV Number]\u00a0 [FunV Symbol FLANG ENV]) ; arg-name, body, scope\n```", "```\n(: eval : FLANG ENV -> VAL);; evaluates FLANG expressions by reducing them to values(define (eval expr env)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) (NumV n)]\u00a0 \u00a0 [(Add l r) (arith-op + (eval l env) (eval r env))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l env) (eval r env))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l env) (eval r env))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l env) (eval r env))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Extend bound-id (eval named-expr env) env))]\u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 [(Fun bound-id bound-body)\u00a0 \u00a0  (FunV bound-id bound-body env)]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  (let ([fval (eval fun-expr env)])\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(FunV bound-id bound-body f-env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Extend bound-id (eval arg-expr env) f-env))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"`call' expects a function, got: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]))\n```", "```\n[\u25b6](flang-env.rkt \"flang-env.rkt\");; The Flang interpreter, using environments#lang pl#|The grammar:\u00a0 <FLANG> ::= <num>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { + <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { - <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { * <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { / <FLANG> <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { with { <id> <FLANG> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | <id>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { fun { <id> } <FLANG> }\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 | { call <FLANG> <FLANG> }Evaluation rules:\u00a0 eval(N,env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = N\u00a0 eval({+ E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) + eval(E2,env)\u00a0 eval({- E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) - eval(E2,env)\u00a0 eval({* E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) * eval(E2,env)\u00a0 eval({/ E1 E2},env)\u00a0 \u00a0 \u00a0 \u00a0 = eval(E1,env) / eval(E2,env)\u00a0 eval(x,env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 = lookup(x,env)\u00a0 eval({with {x E1} E2},env) = eval(E2,extend(x,eval(E1,env),env))\u00a0 eval({fun {x} E},env)\u00a0 \u00a0 \u00a0 = <{fun {x} E}, env>\u00a0 eval({call E1 E2},env1)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  = eval(Ef,extend(x,eval(E2,env1),env2))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  if eval(E1,env1) = <{fun {x} Ef}, env2>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  = error!\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 otherwise|#(define-type FLANG\u00a0 [Num\u00a0 Number]\u00a0 [Add\u00a0 FLANG FLANG]\u00a0 [Sub\u00a0 FLANG FLANG]\u00a0 [Mul\u00a0 FLANG FLANG]\u00a0 [Div\u00a0 FLANG FLANG]\u00a0 [Id\u00a0  Symbol]\u00a0 [With Symbol FLANG FLANG]\u00a0 [Fun\u00a0 Symbol FLANG]\u00a0 [Call FLANG FLANG])(: parse-sexpr : Sexpr -> FLANG);; parses s-expressions into FLANGs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n)\u00a0 \u00a0 (Num n)]\u00a0 \u00a0 [(symbol: name) (Id name)]\u00a0 \u00a0 [(cons 'with more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'with (list (symbol: name) named) body)\u00a0 \u00a0 \u00a0 \u00a0 (With name (parse-sexpr named) (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `with' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(cons 'fun more)\u00a0 \u00a0  (match sexpr\u00a0 \u00a0 \u00a0  [(list 'fun (list (symbol: name)) body)\u00a0 \u00a0 \u00a0 \u00a0 (Fun name (parse-sexpr body))]\u00a0 \u00a0 \u00a0  [else (error 'parse-sexpr \"bad `fun' syntax in ~s\" sexpr)])]\u00a0 \u00a0 [(list '+ lhs rhs) (Add (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '- lhs rhs) (Sub (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '* lhs rhs) (Mul (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list '/ lhs rhs) (Div (parse-sexpr lhs) (parse-sexpr rhs))]\u00a0 \u00a0 [(list 'call fun arg)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Call (parse-sexpr fun) (parse-sexpr arg))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))(: parse : String -> FLANG);; parses a string containing a FLANG expression to a FLANG AST(define (parse str)\u00a0 (parse-sexpr (string->sexpr str)));; Types for environments, values, and a lookup function(define-type ENV\u00a0 [EmptyEnv]\u00a0 [Extend Symbol VAL ENV])(define-type VAL\u00a0 [NumV Number]\u00a0 [FunV Symbol FLANG ENV])(: lookup : Symbol ENV -> VAL);; lookup a symbol in an environment, return its value or throw an;; error if it isn't bound(define (lookup name env)\u00a0 (cases env\u00a0 \u00a0 [(EmptyEnv) (error 'lookup \"no binding for ~s\" name)]\u00a0 \u00a0 [(Extend id val rest-env)\u00a0 \u00a0  (if (eq? id name) val (lookup name rest-env))]))(: NumV->number : VAL -> Number);; convert a FLANG runtime numeric value to a Racket one(define (NumV->number val)\u00a0 (cases val\u00a0 \u00a0 [(NumV n) n]\u00a0 \u00a0 [else (error 'arith-op \"expected a number, got: ~s\" val)]))(: arith-op : (Number Number -> Number) VAL VAL -> VAL);; gets a Racket numeric binary operator, and uses it within a NumV;; wrapper(define (arith-op op val1 val2)\u00a0 (NumV (op (NumV->number val1) (NumV->number val2))))(: eval : FLANG ENV -> VAL);; evaluates FLANG expressions by reducing them to values(define (eval expr env)\u00a0 (cases expr\u00a0 \u00a0 [(Num n) (NumV n)]\u00a0 \u00a0 [(Add l r) (arith-op + (eval l env) (eval r env))]\u00a0 \u00a0 [(Sub l r) (arith-op - (eval l env) (eval r env))]\u00a0 \u00a0 [(Mul l r) (arith-op * (eval l env) (eval r env))]\u00a0 \u00a0 [(Div l r) (arith-op / (eval l env) (eval r env))]\u00a0 \u00a0 [(With bound-id named-expr bound-body)\u00a0 \u00a0  (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (Extend bound-id (eval named-expr env) env))]\u00a0 \u00a0 [(Id name) (lookup name env)]\u00a0 \u00a0 [(Fun bound-id bound-body)\u00a0 \u00a0  (FunV bound-id bound-body env)]\u00a0 \u00a0 [(Call fun-expr arg-expr)\u00a0 \u00a0  (let ([fval (eval fun-expr env)])\u00a0 \u00a0 \u00a0  (cases fval\u00a0 \u00a0 \u00a0 \u00a0  [(FunV bound-id bound-body f-env)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (eval bound-body\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 (Extend bound-id (eval arg-expr env) f-env))]\u00a0 \u00a0 \u00a0 \u00a0  [else (error 'eval \"`call' expects a function, got: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 fval)]))]))(: run : String -> Number);; evaluate a FLANG program contained in a string(define (run str)\u00a0 (let ([result (eval (parse str) (EmptyEnv))])\u00a0 \u00a0 (cases result\u00a0 \u00a0 \u00a0 [(NumV n) n]\u00a0 \u00a0 \u00a0 [else (error 'run \"evaluation returned a non-number: ~s\"\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  result)])));; tests(test (run \"{call {fun {x} {+ x 1}} 4}\")\u00a0 \u00a0 \u00a0 => 5)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add3 1}}\")\u00a0 \u00a0 \u00a0 => 4)(test (run \"{with {add3 {fun {x} {+ x 3}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {add1 {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call add1 {call add3 x}}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{with {identity {fun {x} x}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {foo {fun {x} {+ x 1}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call {call identity foo} 123}}}\")\u00a0 \u00a0 \u00a0 => 124)(test (run \"{with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {f {fun {y} {+ x y}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {with {x 5}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {call f 4}}}}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{call {with {x 3}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {y} {+ x y}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 4}\")\u00a0 \u00a0 \u00a0 => 7)(test (run \"{call {call {fun {x} {call x 1}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {fun {x} {fun {y} {+ x y}}}}\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 123}\")\u00a0 \u00a0 \u00a0 => 124)\n```"]