- en: HoareAsLogicHoare Logic as a Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Require Import Imp.
  prefs: []
  type: TYPE_NORMAL
- en: Require Import Hoare.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inductive hoare_proof : Assertion → com → Assertion → Type :='
  prefs: []
  type: TYPE_NORMAL
- en: '| H_Skip : ∀P,'
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P (SKIP) P
  prefs: []
  type: TYPE_NORMAL
- en: '| H_Asgn : ∀Q V a,'
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof (assn_sub V a Q) (V ::= a) Q
  prefs: []
  type: TYPE_NORMAL
- en: '| H_Seq  : ∀P c Q d R,'
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P c Q → hoare_proof Q d R → hoare_proof P (c;;d) R
  prefs: []
  type: TYPE_NORMAL
- en: '| H_If : ∀P Q b c[1] c[2],'
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof (fun st ⇒ P st ∧ bassn b st) c[1] Q →
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof (fun st ⇒ P st ∧ ~(bassn b st)) c[2] Q →
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P (IFB b THEN c[1] ELSE c[2] FI) Q
  prefs: []
  type: TYPE_NORMAL
- en: '| H_While : ∀P b c,'
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof (fun st ⇒ P st ∧ bassn b st) c P →
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P (WHILE b DO c END) (fun st ⇒ P st ∧ ¬ (bassn b st))
  prefs: []
  type: TYPE_NORMAL
- en: '| H_Consequence  : ∀(P Q P'' Q'' : Assertion) c,'
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P' c Q' →
  prefs: []
  type: TYPE_NORMAL
- en: (∀st, P st → P' st) →
  prefs: []
  type: TYPE_NORMAL
- en: (∀st, Q' st → Q st) →
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P c Q.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Lemma H_Consequence_pre : ∀(P Q P'': Assertion) c,'
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P' c Q →
  prefs: []
  type: TYPE_NORMAL
- en: (∀st, P st → P' st) →
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P c Q.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros. eapply [H_Consequence](HoareAsLogic.html#H_Consequence).
  prefs: []
  type: TYPE_NORMAL
- en: apply X. apply H. intros. apply H[0]. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lemma H_Consequence_post  : ∀(P Q Q'' : Assertion) c,'
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P c Q' →
  prefs: []
  type: TYPE_NORMAL
- en: (∀st, Q' st → Q st) →
  prefs: []
  type: TYPE_NORMAL
- en: hoare_proof P c Q.
  prefs: []
  type: TYPE_NORMAL
- en: Proof.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: intros. eapply [H_Consequence](HoareAsLogic.html#H_Consequence).
  prefs: []
  type: TYPE_NORMAL
- en: apply X. intros. apply H[0]. apply H. Qed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '{{assn_sub X (X+1) (assn_sub X (X+2) (X=3))}}'
  prefs: []
  type: TYPE_NORMAL
- en: X::=X+1 ;; X::=X+2
  prefs: []
  type: TYPE_NORMAL
- en: '{{X=3}}.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use Coq's tactics to help us construct the proof object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exercise: 2 stars (hoare_proof_sound)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prove that such proof objects represent true claims.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also use Coq's reasoning facilities to prove metatheorems
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: about Hoare Logic.  For example, here are the analogs of two
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: theorems we saw in chapter [Hoare](Hoare.html) — this time expressed in terms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: of the syntax of Hoare Logic derivations (provability) rather than
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: directly in terms of the semantics of Hoare triples.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first one says that, for every P and c, the assertion
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{{P}} c {{True}} is *provable* in Hoare Logic.  Note that the'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'proof is more complex than the semantic proof in Hoare: we'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: actually need to perform an induction over the structure of the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: command c.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can show that {{False}} c {{Q}} is provable for
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: any c and Q.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As a last step, we can show that the set of hoare_proof axioms
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: is sufficient to prove any true fact about (partial) correctness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: More precisely, any semantic Hoare triple that we can prove can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: also be proved from these axioms.  Such a set of axioms is said to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'be *relatively complete*.  Our proof is inspired by this one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://www.ps.uni-saarland.de/courses/sem-ws[11]/script/Hoare.html](http://www.ps.uni-saarland.de/courses/sem-ws<sub>11</sub>/script/Hoare.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To carry out the proof, we need to invent some intermediate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assertions using a technical device known as *weakest preconditions*.  Given
    a command c and a desired postcondition
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assertion Q, the weakest precondition wp c Q is an assertion
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: P such that {{P}} c {{Q}} holds, and moreover, for any other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: assertion P', if {{P'}} c {{Q}} holds then P' → P.  We can
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'more directly define this as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise: 1 star (wp_is_precondition)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 1 star (wp_is_weakest)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The following utility lemma will also be useful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise: 5 stars (hoare_proof_complete)'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Complete the proof of the theorem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: ☐
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we might hope that our axiomatic Hoare logic is
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*decidable*; that is, that there is an (terminating) algorithm (a'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*decision procedure*) that can determine whether or not a given'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hoare triple is valid (derivable).  But such a decision procedure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cannot exist!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consider the triple {{True}} c {{False}}. This triple is valid
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if and only if c is non-terminating.  So any algorithm that
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: could determine validity of arbitrary triples could solve the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Halting Problem.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, the triple {{True} SKIP {{P}} is valid if and only if
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ∀ s, P s is valid, where P is an arbitrary assertion of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coq's logic. But it is known that there can be no decision
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: procedure for this logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Overall, this axiomatic style of presentation gives a clearer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: picture of what it means to "give a proof in Hoare logic."
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, it is not entirely satisfactory from the point of view of
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'writing down such proofs in practice: it is quite verbose.  The'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: section of chapter [Hoare2](Hoare2.html) on formalizing decorated programs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: shows how we can do even better.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
