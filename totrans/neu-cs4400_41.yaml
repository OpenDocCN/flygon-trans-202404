- en: Types of EvaluatorsTuesday, February 14th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we did just now is implement lexical environments and closures in the language
    we implement using lexical environments and closures in our own language (Racket)!
  prefs: []
  type: TYPE_NORMAL
- en: This is another example of embedding a feature of the host language in the implemented
    language, an issue that we have already discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many examples of this, even when the two languages involved are different.
    For example, if we have this bit in the C implementation of Racket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'then the special semantics of evaluating a Racket `and` form is being inherited
    from C’s special treatment of `&&`. You can see this by the fact that if there
    is a bug in the C compiler, then it will propagate to the resulting Racket implementation
    too. A different solution is to not use `&&` at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and we can say that this is even better since it evaluates the second expression
    in tail position. But in this case we don’t really get that benefit, since C itself
    is not doing tail-call optimization as a standard feature (though some compilers
    do so under some circumstances).
  prefs: []
  type: TYPE_NORMAL
- en: We have seen a few different implementations of evaluators that are quite different
    in flavor. They suggest the following taxonomy.
  prefs: []
  type: TYPE_NORMAL
- en: A ***syntactic evaluator*** is one that uses its own language to represent only
    expressions of the evaluated language, implementing all the corresponding behavior
    explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ***meta evaluator*** is an evaluator that uses language features of its own
    language to directly implement behavior of the evaluated language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While our substitution-based FLANG evaluator was close to being a syntactic
    evaluator, we haven’t written any purely syntactic evaluators so far: we still
    relied on things like Racket arithmetics etc. The most recent evaluator that we
    have studied, is distinctly a meta evaluator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a good match between the evaluated language and the implementation language,
    writing a meta evaluator can be very easy. With a bad match, though, it can be
    very hard. With a syntactic evaluator, implementing each semantic feature will
    be somewhat hard, but in return you don’t have to worry as much about how well
    the implementation and the evaluated languages match up. In particular, if there
    is a particularly strong mismatch between the implementation and the evaluated
    language, it may take less effort to write a syntactic evaluator than a meta evaluator.
    As an exercise, we can build upon our latest evaluator to remove the encapsulation
    of the evaluator’s response in the VAL type. The resulting evaluator is shown
    below. This is a true meta evaluator: it uses Racket closures to implement FLANG
    closures, Racket function application for FLANG function application, Racket numbers
    for FLANG numbers, and Racket arithmetic for FLANG arithmetic. In fact, ignoring
    some small syntactic differences between Racket and FLANG, this latest evaluator
    can be classified as something more specific than a meta evaluator:'
  prefs: []
  type: TYPE_NORMAL
- en: A ***meta-circular evaluator*** is a meta evaluator in which the implementation
    and the evaluated languages are the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Put differently, the trivial nature of the evaluator clues us in to the deep
    connection between the two languages, whatever their syntactic differences may
    be.)
  prefs: []
  type: TYPE_NORMAL
