- en: Algebraic type sizes and domain modelling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Algebraic type sizes and domain modelling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we'll look at how to calculate the "size", or cardinality, of
    an algebraic type, and see how this knowledge can help us with design decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I'm going to define the "size" of a type by thinking of it as a set, and counting
    the number of possible elements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there are two possible booleans, so the size of the `Boolean` type
    is two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there a type with size one? Yes -- the `unit` type only has one value: `()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Is there a type with size zero? That is, is there a type that has no values
    at all? Not in F#, but in Haskell there is. It is called `Void`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about a type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is its size? There are three possible values, so the size is three.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about a type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, four.
  prefs: []
  type: TYPE_NORMAL
- en: I think you get the idea!
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the size of compound types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at calculating the sizes of compound types now. If you remember
    from the [understanding F# types](understanding-fsharp-types.html) series, there
    are two kinds of algebraic types: "product" types such as [tuples](tuples.html)
    and records, and "sum" types, called [discriminated unions](discriminated-unions.html)
    in F#.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that we have a `Speed` as well as a `Direction`, and
    we combine them into a record type called `Velocity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What is the size of `Velocity`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s every possible value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are eight possible values, one for every possible combination of the two
    `Speed` values and the four `Direction` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can generalize this into a rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RULE: The size of a product type is the *product* of the sizes of the component
    types.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is, given a record type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The size is calculated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And similarly for a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The size is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Sum types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sum types can be analyzed the same way. Given a type `Movement` defined like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write out and count all the possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, five in all. Which just happens to be `size(Direction) + 1`. Here''s another
    fun one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can write out and count all the possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are three possible values in the `YouSay` case, and three possible values
    in the `ISay` case, making six in all.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we can make a general rule.
  prefs: []
  type: TYPE_NORMAL
- en: '**RULE: The size of a sum or union type is the *sum* of the sizes of the component
    types.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is, given a union type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The size is calculated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Working with generic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens if we throw generic types into the mix?
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, what is the size of a type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Well, the first thing to say is that `Optional<'a>` is not a *type* but a *type
    constructor*. `Optional<string>` is a type. `Optional<int>` is a type, but `Optional<'a>`
    isn't.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, we can still calculate its size by noting that `size(Optional<string>)`
    is just `size(string) + 1`, `size(Optional<int>)` is just `size(int) + 1`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for a type with two generics like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'we can say that its size can be calculated using the size of the generic components
    (using the "sum rule" above):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Recursive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about a recursive type? Let's look at the simplest one, a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A linked list is either empty, or it has a cell with a tuple: a head and a
    tail. The head is an `''a` and the tail is another list. Here''s the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the size, let''s assign some names to the various components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s play with this formula a bit. We start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'and let''s substitute the last S with the formula to get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we clean this up, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: (where `N^2` means "N squared")
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s substitute the last S with the formula again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'and clean up again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see where this is going! The formula for `S` can be expanded out indefinitely
    to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we interpret this? Well, we can say that a list is a union of the following
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: an empty list(size = 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a one element list (size = N)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a two element list (size = N x N)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a three element list (size = N x N x N)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And this formula has captured that.
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, you can calculate `S` directly using the formula `S = 1/(1-N)`,
    which means that a list of `Direction` (size=4) has size "-1/3". Hmmm, that's
    strange! It reminds me of [this "-1/12" video](https://www.youtube.com/watch?v=w-I6XTVZXww).
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the size of functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about functions? Can they be sized?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, all we need to do is write down every possible implementation and count
    them. Easy!
  prefs: []
  type: TYPE_NORMAL
- en: For example, say that we have a function `SuitColor` that maps a card `Suit`
    to a `Color`, red or black.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'One implementation would be to return red, no matter what suit was provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another implementation would be to return red for all suits except `Club`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact we can write down all 16 possible implementations of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to think of it is that we can define a record type where each value
    represents a particular implementation: which color do we return for a `Heart`
    input, which color do we return for a `Spade` input, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type definition for the implementations of `SuitColor` would therefore
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What is the size of this record type?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four `size(Color)` here. In other words, there is one `size(Color)`
    for every input, so we could write this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, then, given a function type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of the function is `size(output type)` to the power of `size(input
    type)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Lets codify that into a rule too:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RULE: The size of a function type is `size(output type)` to the power of
    `size(input type)`.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All right, that is all very interesting, but is it *useful*?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I think it is. I think that understanding sizes of types like this helps
    us design conversions from one type to another, which is something we do a lot
    of!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have a union type and a record type, both representing a
    yes/no answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How can we map between them?
  prefs: []
  type: TYPE_NORMAL
- en: 'They both have size=2, so we should be able to map each value in one type to
    the other, and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is what you might call a "lossless" conversion. If you round-trip the conversion,
    you can recover the original value. Mathematicians would call this an *isomorphism*
    (from the Greek "equal shape").
  prefs: []
  type: TYPE_NORMAL
- en: What about another example? Here's a type with three cases, yes, no, and maybe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Can we losslessly convert this to this type?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Well, what is the size of an `option`? One plus the size of the inner type,
    which in this case is a `bool`. So `size(YesNoOption)` is also three.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the conversion functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'So we can make a rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RULE: If two types have the same size, you can create a pair of lossless
    conversion functions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try it out. Here''s a `Nibble` type and a `TwoNibbles` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Can we convert `TwoNibbles` to a `byte` and back?
  prefs: []
  type: TYPE_NORMAL
- en: The size of `Nibble` is `2 x 2 x 2 x 2` = 16 (using the product size rule),
    and the size of `TwoNibbles` is size(Nibble) x size(Nibble), or `16 x 16`, which
    is 256.
  prefs: []
  type: TYPE_NORMAL
- en: So yes, we can convert from `TwoNibbles` to a `byte` and back.
  prefs: []
  type: TYPE_NORMAL
- en: Lossy conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens if the types are different sizes?
  prefs: []
  type: TYPE_NORMAL
- en: If the target type is "larger" than the source type, then you can always map
    without loss, but if the target type is "smaller" than the source type, you have
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `int` type is smaller than the `string` type. You can convert
    an `int` to a `string` accurately, but you can't convert a `string` to an `int`
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you *do* want to map a string to an int, then some of the non-integer strings
    will have to be mapped to a special, non-integer value in the target type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](type-size-1.png)'
  prefs: []
  type: TYPE_IMG
- en: In other words we know from the sizes that the target type can't just be an
    `int` type, it must be an `int + 1` type. In other words, an Option type!
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the `Int32.TryParse` function in the BCL returns two values,
    a success/failure `bool` and the parsed result as an `int`. In other words, a
    tuple `bool * int`.
  prefs: []
  type: TYPE_NORMAL
- en: The size of that tuple is `2 x int`, many more values that are really needed.
    Option types ftw!
  prefs: []
  type: TYPE_NORMAL
- en: Now let's say we are converting from a `string` to a `Direction`. Some strings
    are valid, but most of them are not. But this time, instead of having one invalid
    case, let's also say that we want to distinguish between empty inputs, inputs
    that are too long, and other invalid inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](type-size-2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can''t model the target with an Option any more, so let''s design a custom
    type that contains all seven cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: But this design mixes up successful conversions and failed conversions. Why
    not separate them?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What is the size of `StringToDirection_V2`?
  prefs: []
  type: TYPE_NORMAL
- en: There are 4 choices of `Direction` in the `Success` case, and three choices
    of `ConversionFailure` in the `Failure` case, so the total size is seven, just
    as in the first version.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, both of these designs are *equivalent* and we can use either
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I prefer version 2, but if we had version 1 in our legacy code,
    the good news is that we can losslessly convert from version 1 to version 2 and
    back again. Which in turn means that we can safely refactor to version 2 if we
    need to.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the core domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowing that different types can be losslessly converted allows you to tweak
    your domain designs as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'can be losslessly converted to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'or this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a real example:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a website where some users are registered and some are not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all users, you have a session id
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For registered users only, you have extra information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could model that requirement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'or alternatively, we can pull the common `SessionId` up to a higher level like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Which is better? In one sense, they are both the "same", but obviously the best
    design depends on the usage pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If you care more about the type of user than the session id, then version 1
    is better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are constantly looking at the session id without caring about the type
    of user, then version 2 is better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nice thing about knowing that they are isomorphic is that you can define
    *both* types if you like, use them in different contexts, and losslessly map between
    them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing with the outside world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have all these nice domain types like `Direction` or `WebsiteUser` but at
    some point we need to interface with the outside world -- store them in a database,
    receive them as JSON, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that the outside world does not have a nice type system! Everything
    tends to be primitives: strings, ints and bools.'
  prefs: []
  type: TYPE_NORMAL
- en: Going from our domain to the outside world means going from types with a "small"
    set of values to types with a "large" set of values, which we can do straightforwardly.
    But coming in from the outside world into our domain means going from a "large"
    set of values to a "small" set of values, which requires validation and error
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a domain type might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The values are constrained: max 50 chars for the name, a validated email, an
    age which is between 1 and 129\.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the DTO type might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The values are unconstrained: any string for the name, a unvalidated email,
    an age that can be any of 2^32 different values, including negative ones.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that we *cannot* create a `CustomerDTO` to `DomainCustomer` mapping.
    We *have* to have at least one other value (`DomainCustomer + 1`) to map the invalid
    inputs onto, and preferably more to document the various errors.
  prefs: []
  type: TYPE_NORMAL
- en: This leads naturally to the `Success/Failure` model as described in my [functional
    error handling](http://fsharpforfunandprofit.com/rop/) talk,
  prefs: []
  type: TYPE_NORMAL
- en: The final version of the mapping would then be from a `CustomerDTO` to a `SuccessFailure<DomainCustomer>`
    or similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that leads to the final rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RULE: Trust no one. If you import data from an external source, be sure to
    handle invalid input.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we take this rule seriously, it has some knock on effects, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Never try to deserialize directly to a domain type (e.g. no ORMs), only to DTO
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always validate every record you read from a database or other "trusted" source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might think that having everything wrapped in a `Success/Failure` type can
    get annoying, and this is true (!), but there are ways to make this easier. See
    [this post](elevated-world-5.html#asynclist) for example.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "algebra" of algebraic data types is well known. There is a good recent
    summary in ["The algebra (and calculus!) of algebraic data types"](https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types)
    and a [series by Chris Taylor](https://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/).
  prefs: []
  type: TYPE_NORMAL
- en: 'And after I wrote this, I was pointed to two similar posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[One by Tomas Petricek](http://tomasp.net/blog/types-and-math.aspx/) with almost
    the same content!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[One by Bartosz Milewski](http://bartoszmilewski.com/2015/01/13/simple-algebraic-data-types/)
    in his series on category theory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As some of those posts mention, you can do strange things with these type formulas,
    such as differentiate them!
  prefs: []
  type: TYPE_NORMAL
- en: If you like academic papers, you can read the original discussion of derivatives
    in ["The Derivative of a Regular Type is its Type of One-Hole Contexts"](http://strictlypositive.org/diff.pdf)(PDF)
    by Conor McBride from 2001, and a follow up in ["Differentiating Data Structures"](http://www.cs.nott.ac.uk/~txa/publ/jpartial.pdf)(PDF)
    [Abbott, Altenkirch, Ghani, and McBride, 2005].
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This might not be the most exciting topic in the world, but I've found this
    approach both interesting and useful, and I wanted to share it with you.
  prefs: []
  type: TYPE_NORMAL
- en: Let me know what you think. Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
