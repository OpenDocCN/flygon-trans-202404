- en: The "Expressions and syntax" Series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “表达式和语法”系列
- en: In this series of posts we'll look at how functions and values are combined
    into expressions, and the different kinds of expressions that are available in
    F#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一系列的文章中，我们将看看如何将函数和值组合成表达式，以及 F# 中可用的不同类型的表达式。
- en: '[Expressions and syntax: Introduction](expressions-intro.html). How to code
    in F#.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表达式和语法：介绍](expressions-intro.html)。如何在 F# 中编码。'
- en: '[Expressions vs. statements](expressions-vs-statements.html). Why expressions
    are safer and make better building blocks.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[表达式 vs. 语句](expressions-vs-statements.html)。为什么表达式更安全，更好地构建块。'
- en: '[Overview of F# expressions](understanding-fsharp-expressions.html). Control
    flows, lets, dos, and more.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F# 表达式概述](understanding-fsharp-expressions.html)。控制流、let、do 等等。'
- en: '[Binding with let, use, and do](let-use-do.html). How to use them.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 let、use 和 do 进行绑定](let-use-do.html)。如何使用它们。'
- en: '[F# syntax: indentation and verbosity](fsharp-syntax.html). Understanding the
    offside rule.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[F# 语法：缩进和冗长](fsharp-syntax.html)。理解挤压规则。'
- en: '[Parameter and value naming conventions](naming-conventions.html). a, f, x
    and friends.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[参数和值的命名约定](naming-conventions.html)。a、f、x 等等。'
- en: '[Control flow expressions](control-flow-expressions.html). And how to avoid
    using them.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[控制流表达式](control-flow-expressions.html)。以及如何避免使用它们。'
- en: '[Exceptions](exceptions.html). Syntax for throwing and catching.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[异常](exceptions.html)。抛出和捕获的语法。'
- en: '[Match expressions](match-expression.html). The workhorse of F#.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[匹配表达式](match-expression.html)。F# 的主力军。'
- en: '[Formatted text using printf](printf.html). Tips and techniques for printing
    and logging.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 printf 格式化文本](printf.html)。打印和记录的技巧和技术。'
- en: '[Worked example: Parsing command line arguments](pattern-matching-command-line.html).
    Pattern matching in practice.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：解析命令行参数](pattern-matching-command-line.html)。实践中的模式匹配。'
- en: '[Worked example: Roman numerals](roman-numerals.html). More pattern matching
    in practice.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例：罗马数字](roman-numerals.html)。更多实践中的模式匹配。'
- en: 'Expressions and syntax: Introduction'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式和语法：介绍
- en: 'Expressions and syntax: Introduction'
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式和语法：介绍
- en: '*NOTE: Before reading this series, I suggest that you read the ["thinking functionally"](thinking-functionally.html)
    series as a prerequisite.*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：在阅读这个系列之前，我建议您先阅读["函数式思维"](thinking-functionally.html)系列作为先决条件。*'
- en: In this series we'll look at how functions and values are combined into expressions,
    and the different kinds of expressions that are available in F#.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系列中，我们将看看如何将函数和值组合成表达式，以及 F# 中可用的不同类型的表达式。
- en: We'll also look at some other basic topics, such as `let` bindings, F# syntax,
    pattern matching, and outputting text with `printf`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看一些其他基本主题，比如`let`绑定、F# 语法、模式匹配以及使用`printf`输出文本。
- en: This series is not meant to be exhaustive or definitive. Much of the syntax
    and usage of F# should be obvious from the examples, and the MSDN documentation
    has all the details if you need them. Rather we will just focus on explaining
    some of the essential areas that might be confusing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系列不打算是穷尽或决定性的。从示例中，F# 的大部分语法和用法应该是明显的，如果需要，MSDN 文档中有所有细节。我们只是专注于解释一些可能令人困惑的基本领域。
- en: So, we'll start with some general tips, talk about how `let` bindings work,
    and explain the indentation rules.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将从一些一般的技巧开始，讨论`let`绑定的工作原理，并解释缩进规则。
- en: After that, the next few posts will cover `match..with` expressions, the imperative
    control flow expressions, and exception expressions. Computation expressions and
    object-oriented expressions will be left to later series.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，接下来的几篇文章将涵盖`match..with`表达式、命令式控制流表达式和异常表达式。计算表达式和面向对象表达式将留到后续系列。
- en: Finally, we'll finish with some worked examples that use pattern matching as
    an integral part of their design.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将以一些使用模式匹配作为设计的一个组成部分的实践示例结束。
- en: Expressions vs. statements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式 vs. 语句
- en: Expressions vs. statements
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式 vs. 语句
- en: In programming language terminology, an "expression" is a combination of values
    and functions that are combined and interpreted by the compiler to create a new
    value, as opposed to a "statement" which is just a standalone unit of execution
    and doesn't return anything. One way to think of this is that the purpose of an
    expression is to create a value (with some possible side-effects), while the sole
    purpose of a statement is to have side-effects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程语言术语中，“表达式”是值和函数的组合，由编译器解释和组合以创建一个新值，而不是“语句”，它只是一个独立的执行单元，不返回任何内容。一个思考这个问题的方式是，表达式的目的是创建一个值（可能带有一些副作用），而语句的唯一目的是产生副作用。
- en: C# and most imperative languages make a distinction between expressions and
    statements and have rules about where each kind can be used. But as should be
    apparent, a truly pure functional language cannot support statements at all, because
    in a truly pure language, there would be no side-effects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: C# 和大多数命令式语言区分表达式和语句，并且有关于每种类型在哪里可以使用的规则。但正如显而易见的那样，一个真正纯粹的函数式语言根本不支持语句，因为在一个真正纯粹的语言中，不会有副作用。
- en: Even though F# is not pure, it does follow the same principle. In F# everything
    is an expression. Not just values and functions, but also control flows (such
    as if-then-else and loops), pattern matching, and so on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 F# 不是纯的，它也遵循相同的原则。在 F# 中，一切都是表达式。不仅仅是值和函数，还有控制流（如 if-then-else 和循环），模式匹配等等。
- en: There are some subtle benefits to using expressions over statements. First,
    unlike statements, smaller expressions can be combined (or "composed") into larger
    expressions. So if everything is an expression, then everything is also composable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表达式而不是语句有一些微妙的好处。首先，与语句不同，较小的表达式可以组合（或“组成”）成较大的表达式。因此，如果一切都是表达式，那么一切也是可组合的。
- en: Second, a series of statements always implies a specific order of evaluation,
    which means that a statement cannot be understood without looking at prior statements.
    But with pure expressions, the subexpressions do not have any implied order of
    execution or dependencies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，一系列语句总是暗示着特定的评估顺序，这意味着一个语句在没有查看前面语句的情况下是无法理解的。但对于纯表达式来说，子表达式没有任何暗示的执行顺序或依赖关系。
- en: So in the expression `a+b`, if both the '`a`' and '`b`' parts are pure, then
    the '`a`' part can be isolated, understood, tested and evaluated on its own, as
    can the '`b`' part.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在表达式`a+b`中，如果'`a`'和'`b`'部分都是纯的，那么'`a`'部分可以被隔离出来，独立理解，测试和评估，'`b`'部分也可以。
- en: This "isolatibility" of expressions is another beneficial aspect of functional
    programming.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表达式的“隔离性”是函数式编程的另一个有益方面。
- en: Note that the F# interactive window also relies on everything being an expression.
    It would be much harder to use a C# interactive window.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，F# 交互式窗口也依赖于一切都是表达式。使用 C# 交互式窗口会更加困难。
- en: Expressions are safer and more compact
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式更安全，更紧凑
- en: Using expressions consistently leads to code that is both safer and more compact.
    Let's see what I mean by this.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一致使用表达式会导致代码更安全，更紧凑。让我们看看我是什么意思。
- en: 'First, let''s look at a statement based approach. Statements don''t return
    values, so you have to use temporary variables that are assigned to from within
    statement bodies. Here are some examples using a C-like language (OK, C#) rather
    than F#:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看基于语句的方法。语句不返回值，所以你必须使用临时变量，这些变量是从语句体内赋值的。这里有一些使用类似 C 语言（好吧，C#）而不是 F#
    的示例：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Because the "if-then" is a statement, the `result` variable must be defined
    *outside* the statement and but assigned to *inside* the statement, which leads
    to some issues:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为"if-then"是一个语句，所以`result`变量必须*在*语句外定义，但在*语句内*赋值，这导致了一些问题：
- en: The `result` variable has to be set up outside the statement itself. What initial
    value should it be set to?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result`变量必须在语句本身之外设置。它应该被设置为什么初始值呢？'
- en: What if I forget to assign to the `result` variable in the `if` statement? The
    purpose of the "if "statement is purely to have side effects (the assignment to
    the variables). This means that the statements are potentially buggy, because
    it would be easy to forget to do an assignment in one branch. And because the
    assignment was just a side effect, the compiler could not offer any warning. Since
    the `result` variable has already been defined in scope, I could easily use it,
    unaware that it was invalid.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我忘记在`if`语句中为`result`变量赋值会怎么样？"if"语句的目的纯粹是产生副作用（对变量的赋值）。这意味着这些语句可能存在bug，因为在一个分支中忘记做赋值是很容易的。而且由于赋值只是一个副作用，编译器无法提供任何警告。由于`result`变量已在范围内定义，我可以很容易地使用它，却不知道它是无效的。
- en: What is the value of the `result` variable in the "else" case? In this case,
    I haven't specified a value. Did I forget? Is this a potential bug?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“else”情况下`result`变量的值是什么？在这种情况下，我没有指定一个值。我是不是忘记了？这是一个潜在的 bug 吗？
- en: Finally, the reliance on side-effects to get things done means that the statements
    are not easily usable in another context (for example, extracted for refactoring,
    or parallelizing) because they have a dependency on a variable that is not part
    of the statement itself.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，依赖副作用来完成任务意味着这些语句在另一个上下文中（例如，提取以进行重构或并行化）不容易使用，因为它们依赖于不属于语句本身的变量。
- en: 'Note: the code above will not compile in C# because the compiler will complain
    if you use an unassigned local variable like this. But having to define *some*
    default value for `result` before it is even used is still a problem.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：上面的代码在 C# 中不会编译，因为编译器会抱怨如果像这样使用未赋值的本地变量。但在甚至使用 `result` 之前就必须定义 *某个* 默认值仍然是一个问题。
- en: 'For comparison, here is the same code, rewritten in an expression-oriented
    style:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，这里是以表达式为导向的风格重写的相同代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the expression-oriented version, none of the earlier issues even apply!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在以表达式为导向的版本中，甚至没有早期问题适用！
- en: The `result` variable is declared at the same time that it is assigned. No variables
    have to be set up "outside" the expression and there is no worry about what initial
    value they should be set to.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`result` 变量在分配的同时声明。不需要在表达式之外设置变量，也不用担心它们应该设置为什么初始值。'
- en: The "else" is explicitly handled. There is no chance of forgetting to do an
    assignment in one of the branches.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “else”被明确处理。不会忘记在其中一个分支中进行赋值。
- en: And I cannot possibly forget to assign to `result`, because then the variable
    would not even exist!
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而且我绝对不会忘记给 `result` 赋值，因为那样变量甚至都不存在！
- en: 'In F#, the two examples would be written as:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，这两个示例将被写成：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The "`mutable`" keyword is considered a code smell in F#, and is discouraged
    except in certain special cases. It should be avoided at all cost while you are
    learning!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，“`mutable`”关键字被认为是一种代码异味，并且除了某些特殊情况外，不鼓励使用。在学习过程中应尽量避免使用！
- en: In the expression based version, the mutable variable has been eliminated and
    there is no reassignment anywhere.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于表达式的版本中，可变变量已被消除，且没有任何重新赋值。
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once we have the `if` statement converted into an expression, it is now trivial
    to refactor it and move the entire subexpression to a different context without
    introducing errors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将 `if` 语句转换为表达式，现在可以轻松地重构它，并将整个子表达式移动到不同的上下文中而不会引入错误。
- en: 'Here''s the refactored version in C#:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 C# 中重构后的版本：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And in F#:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在 F# 中：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Statements vs. expressions for loops
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句与表达式用于循环
- en: Going back to C# again, here is a similar example of statements vs. expressions
    using a loop statement
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次回到 C#，这里是使用循环语句的语句与表达式的类似示例
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I''ve used an old-style "for" statement, where the index variables are declared
    outside the loop. Many of the issues discussed earlier apply to the loop index
    "`i`" and the max value "`length`", such as: can they be used outside the loop?
    And what happens if they are not assigned to?'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了旧式的“for”语句，其中索引变量在循环外声明。许多早期讨论的问题适用于循环索引“`i`”和最大值“`length`”，例如：它们是否可以在循环外使用？如果它们没有被赋值会发生什么？
- en: 'A more modern version of a for-loop addresses these issues by declaring and
    assigning the loop variables in the "for" loop itself, and by requiring the "`sum`"
    variable to be initialized:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更现代化的 for 循环版本通过在“for”循环中声明和赋值循环变量，并要求初始化“`sum`”变量来解决这些问题：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This more modern version follows the general principle of combining the declaration
    of a local variable with its first assignment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更现代化的版本遵循了将本地变量的声明与其第一次赋值结合的一般原则。
- en: 'But of course, we can keep improving by using a `foreach` loop instead of a
    `for` loop:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以继续改进，使用 `foreach` 循环而不是 `for` 循环：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each time, not only are we condensing the code, but we are reducing the likelihood
    of errors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 每次，我们不仅在简化代码，还在减少错误的可能性。
- en: 'But taking that principle to its logical conclusion leads to a completely expression
    based approach! Here''s how it might be done using LINQ:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，将这一原则推向其逻辑结论会导致完全基于表达式的方法！以下是使用 LINQ 可能完成的方式：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that I could have used LINQ's built-in "sum" function, but I used `Aggregate`
    in order to show how the sum logic embedded in a statement can be converted into
    a lambda and used as part of an expression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我本可以使用 LINQ 的内置“sum”函数，但我使用 `Aggregate` 是为了展示嵌入语句中的求和逻辑如何转换为 lambda 并作为表达式的一部分使用。
- en: In the next post, we'll look at the various kinds of expressions in F#.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一篇文章中，我们将看看 F# 中各种类型的表达式。
- en: Overview of F# expressions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 表达式概述
- en: Overview of F# expressions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 表达式概述
- en: In this post we'll look at the different kinds of expressions that are available
    in F# and some general tips for using them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将介绍 F# 中可用的不同类型的表达式以及一些使用它们的一般提示。
- en: Is everything really an expression?
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一切真的都是表达式吗？
- en: You might be wondering how "everything is an expression" actually works in practice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你正在想如何在实践中实现 “一切都是一个表达式”。
- en: 'Let''s start with some basic expression examples that should be familiar:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本的表达式示例开始，这些应该是耳熟能详的：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: No problems there. Those are obviously expressions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 没有问题。那些显然是表达式。
- en: But here are some more complex things which are *also* expressions. That is,
    each of these returns a value that can be used for something else.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下还有一些更复杂的东西，也是*表达式*。也就是说，每个都返回一个可用于其他目的的值。
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In other languages, these might be statements, but in F# they really do return
    values, as you can see by binding a value to the result:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，这些可能是语句，但在 F# 中它们确实返回值，正如您可以通过将值绑定到结果来看到的那样：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What kinds of expressions are there?
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有哪些类型的表达式？
- en: There are lots of diffent kinds of expressions in F#, about 50 currently. Most
    of them are trivial and obvious, such as literals, operators, function application,
    "dotting into", and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中有很多不同类型的表达式，目前大约有 50 种。其中大多数都是琐碎和显而易见的，比如字面常量、运算符、函数应用、“点进”等等。
- en: 'The more interesting and high-level ones can be grouped as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣和高级的表达式可以分为以下几类：
- en: Lambda expressions
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: '"Control flow" expressions, including:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"控制流" 表达式，包括：'
- en: The match expression (with the `match..with` syntax)
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: match 表达式（使用 `match..with` 语法）
- en: Expressions related to imperative control flow, such as if-then-else, loops
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与命令式控制流相关的表达式，如 if-then-else、循环
- en: Exception-related expressions
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常相关的表达式
- en: '"let" and "use" expressions'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"let" 和 "use" 表达式'
- en: Computation expressions such as `async {..}`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async {..}` 这样的计算表达式'
- en: Expressions related to object-oriented code, including casts, interfaces, etc
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与面向对象代码相关的表达式，包括强制转换、接口等
- en: We have already discussed lambdas in the ["thinking functionally"](thinking-functionally.html)
    series, and as noted earlier, computation expressions and object-oriented expressions
    will be left to later series.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 ["思考函数式"](thinking-functionally.html) 系列中讨论了 lambda，并且正如前面所指出的，计算表达式和面向对象表达式将留给以后的系列。
- en: So, in upcoming posts in this series, we will focus on "control flow" expressions
    and "let" expressions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本系列的即将发布的帖子中，我们将重点讨论“控制流”表达式和“let”表达式。
- en: '"Control flow" expressions'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '"控制流" 表达式'
- en: In imperative languages, control flow expressions like if-then-else, for-in-do,
    and match-with are normally implemented as statements with side-effects, In F#,
    they are all implemented as just another type of expression.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式语言中，诸如 if-then-else、for-in-do 和 match-with 这样的控制流表达式通常被实现为具有副作用的语句，在 F#
    中，它们都被实现为另一种类型的表达式。
- en: In fact, it is not even helpful to think of "control flow" in a functional language;
    the concept doesn't really exist. Better to just think of the program as a giant
    expression containing sub-expressions, some of which are evaluated and some of
    which are not. If you can get your head around this way of thinking, you have
    a good start on thinking functionally.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在函数式语言中甚至认为 “控制流” 并不是很有帮助；这个概念并不存在。最好的做法是把程序看作是一个包含子表达式的巨大表达式，其中一些被评估，而另一些则没有。如果您能理解这种思维方式，那么您就已经有了一个良好的开始，开始思考函数式。
- en: 'There will be some upcoming posts on these different types of control flow
    expressions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不同类型的控制流表达式将会在接下来的帖子中讨论：
- en: '[The match expression](match-expression)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[match 表达式](match-expression)'
- en: '[Imperative control flow: if-then-else and for loops](control-flow-expressions)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[命令式控制流：if-then-else 和 for 循环](control-flow-expressions)'
- en: '[Exceptions](exceptions)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[异常](exceptions)'
- en: '"let" bindings as expressions'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “let” 绑定作为表达式
- en: 'What about `let x=something`? In the examples above we saw:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那么 `let x=something` 呢？在上面的示例中我们看到了：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How can "`let`" be an expression? The reason will be discussed in the next post
    on ["let", "use" and "do"](let-use-do).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “let” 怎么可能是一个表达式？原因将在下一篇文章中讨论 ["let"，"use" 和 "do"](let-use-do)。
- en: General tips for using expressions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表达式的一般提示
- en: But before we cover the important expression types in details, here are some
    tips for using expressions in general.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们详细介绍重要表达式类型之前，以下是一些使用表达式的一般提示。
- en: Multiple expressions on one line
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一行上的多个表达式
- en: Normally, each expression is put on a new line. But you can use a semicolon
    to separate expressions on one line if you need to. Along with its use as a separator
    for list and record elements, this is one of the few times where a semicolon is
    used in F#.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个表达式都放在新行上。但如果需要，您可以使用分号将一个行上的表达式分隔开来。除了在 F# 中用作列表和记录元素的分隔符之外，这是分号在 F# 中使用的几个时候之一。
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The rule about requiring unit values until the last expression still applies,
    of course:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最后一个表达式还是需要单位值的规则当然仍然适用：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Understanding expression evaluation order
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解表达式评估顺序
- en: In F#, expressions are evaluated from the "inside out" -- that is, as soon as
    a complete subexpression is "seen", it is evaluated.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，表达式是从 "内部向外" 评估的 -- 也就是说，一旦一个完整的子表达式被 "看到"，它就会被评估。
- en: Have a look at the following code and try to guess what will happen, then evaluate
    the code and see.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的代码，并尝试猜测会发生什么，然后评估代码并查看结果。
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What happens is that both "true" and "false" are printed, even though the test
    function will never actually evaluate the "else" branch. Why? Because the `(printfn
    "false")` expression is evaluated immediately, regardless of how the test function
    will be using it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是 "true" 和 "false" 都被打印出来，即使测试函数实际上永远不会评估 "else" 分支。为什么？因为 `(printfn "false")`
    表达式会立即被评估，而不管测试函数如何使用它。
- en: This style of evaluation is called "eager". It has the advantage that it is
    easy to understand, but it does mean that it can be inefficient on occasion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种评估风格称为 "急切"。它的优点是易于理解，但这意味着在某些情况下可能效率低下。
- en: The alternative style of evaluation is called "lazy", whereby expressions are
    only evaluated when they are needed. The Haskell language follows this approach,
    so a similar example in Haskell would only print "true".
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种评估风格称为 "惰性"，即只有在需要时才评估表达式。Haskell 语言遵循这种方法，因此在 Haskell 中的类似示例只会打印 "true"。
- en: 'In F#, there are a number of techniques to force expressions *not* to be evaluated
    immediately. The simplest it to wrap it in a function that only gets evaluated
    on demand:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，有许多技术可强制表达式*不*立即进行评估。最简单的方法是将其包装在仅在需要时才被评估的函数中：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The problem with this is that now the "true" function might be evaluated twice
    by mistake, when we only wanted to evaluate it once!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的问题是现在 "true" 函数可能会被错误地评估两次，而我们只想评估一次！
- en: So, the preferred way for expressions not to be evaluated immediately is to
    use the `Lazy<>` wrapper.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，表达式不立即被评估的首选方法是使用 `Lazy<>` 包装器。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The final result value `f` is also a lazy value, and can be passed around without
    being evaluated until you are finally ready to get the result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果值 `f` 也是一个惰性值，可以在最终准备好获取结果之前传递而不进行评估。
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you never need the result, and never call `Force()`, then the wrapped value
    will never be evaluated.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从不需要结果，并且从不调用 `Force()`，那么包装的值将永远不会被评估。
- en: There will much more on laziness in an upcoming series on performance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的性能系列中，惰性会有更多的讨论。
- en: Binding with let, use, and do
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 let、use 和 do 进行绑定
- en: Binding with let, use, and do
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 let、use 和 do 进行绑定
- en: As we've have already seen, there are no "variables" in F#. Instead there are
    values.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的那样，在 F# 中没有 "变量"。相反，有值。
- en: And we have also seen that keywords such as `let`, `use`, and `do` act as *bindings*
    -- associating an identifier with a value or function expression.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了 `let`、`use` 和 `do` 等关键字作为*绑定*，将标识符与值或函数表达式关联起来。
- en: In this post we'll look at these bindings in more detail.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将更详细地查看这些绑定。
- en: '"let" bindings'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"let" 绑定'
- en: 'The `let` binding is straightforward, it has the general form:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`let` 绑定很简单，它的一般形式如下：'
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But there are two uses of `let` that are subtly different. One is to define
    a named expression at a the top level of a module*, and the other is to define
    a local name used in the context of some expression. This is somewhat analogous
    to the difference between "top level" method names and "local" variable names
    in C#.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 `let` 有两种略微不同的用法。一种是在模块的顶层定义一个命名表达式，另一种是在某个表达式的上下文中定义一个局部名称。这在某种程度上类似于 C#
    中 "顶层" 方法名称和 "局部" 变量名称之间的区别。
- en: '[* and in a later series, when we talk about OO features, classes can have
    top level let bindings too.]'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[* 并在以后的系列中，当我们谈论 OO 特性时，类也可以有顶级的 let 绑定。]'
- en: 'Here''s an example of both types:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两种类型的示例：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The top level name is a *definition*, which is part of the module, and you can
    access it with a fully qualified name such as `MyModule.topLevelName`. It's the
    equivalent of a class method, in a sense.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层名称是*定义*，它是模块的一部分，你可以使用完全限定的名称访问它，例如`MyModule.topLevelName`。在某种意义上，它相当于一个类方法。
- en: But the nested names are completely inaccessible to anyone -- they are only
    valid within the context of the top level name binding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但是嵌套的名称对任何人都是完全不可访问的--它们只在顶层名称绑定的上下文中有效。
- en: Patterns in "let" bindings
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '"let"绑定中的模式'
- en: We have already seen examples of how bindings can use patterns directly
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了绑定如何直接使用模式的示例
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And in function definitions the binding includes parameters as well:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，绑定还包括参数：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The details of the various pattern bindings depends on the type being bound,
    and will be discussed further in later posts on pattern matching.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 各种模式绑定的细节取决于要绑定的类型，并将在以后关于模式匹配的帖子中进一步讨论。
- en: Nested "let" bindings as expressions
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套的"let"绑定作为表达式
- en: We have emphasized that an expression is composed from smaller expressions.
    But what about a nested `let`?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调过表达式是由较小的表达式组成的。但是嵌套的`let`怎么样呢？
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How can "`let`" be an expression? What does it return?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '"`let`"如何成为一个表达式？它返回什么？'
- en: 'The answer that a nested "let" can never be used in isolation -- it must always
    be part of a larger code block, so that it can be interpreted as:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的"let"永远不能单独使用--它必须始终是一个更大的代码块的一部分，以便它可以被解释为：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That is, every time you see the symbol "nestedName" in the second expression
    (called the *body expression*), substitute it with the first expression.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，每当你在第二个表达式（称为*主体表达式*）中看到符号"nestedName"时，就用第一个表达式替换它。
- en: 'So for example, the expression:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，表达式：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'really means:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 真正意味着：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When the substitutions are performed, the last line becomes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行替换时，最后一行变为：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In a sense, the nested names are just "macros" or "placeholders" that disappear
    when the expression is compiled. And therefore you should be able to see that
    the nested `let`s have no effect on the expression as whole. So, for example,
    the type of an expression containing nested `let`s is just the type of the final
    body expression.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，嵌套的名称只是在表达式编译时消失的"宏"或"占位符"。因此，你应该能够看到嵌套的`let`对整个表达式没有影响。因此，例如，包含嵌套`let`的表达式的类型仅仅是最终主体表达式的类型。
- en: 'If you understand how nested `let` bindings work, then certain errors become
    understandable. For example, if there is nothing for a nested "let" to be "in",
    the entire expression is not complete. In the example below, there is nothing
    following the let line, which is an error:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解嵌套的`let`绑定是如何工作的，那么某些错误就会变得可以理解。例如，如果没有东西让嵌套的"let"去"in"，整个表达式就不完整。在下面的示例中，let行后面没有任何内容，这是一个错误：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And you cannot have multiple expression results, because you cannot have multiple
    body expressions. Anything evaluated before the final body expression must be
    a "`do`" expression (see below), and return `unit`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能有多个表达式结果，因为你不能有多个主体表达式。在最终主体表达式之前评估的任何内容必须是一个"`do`"表达式（见下文），并返回`unit`。
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In a case like this, you must pipe the results into "ignore".
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你必须将结果管道传递到"ignore"。
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '"use" bindings'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"use"绑定'
- en: The `use` keyword serves the same purpose as `let` -- it binds the result of
    an expression to a named value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`use`关键字的作用与`let`相同--它将表达式的结果绑定到一个命名值上。'
- en: The key difference is that is also *automatically disposes* the value when it
    goes out of scope.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关键区别在于在它超出范围时也*自动处置*该值。
- en: Obviously, this means that `use` only applies in nested situations. You cannot
    have a top level `use` and the compiler will warn you if you try.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这意味着`use`仅适用于嵌套情况。你不能有一个顶级的`use`，如果你尝试，编译器会警告你。
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To see how a proper `use` binding works, first let's create a helper function
    that creates an `IDisposable` on the fly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解正确的`use`绑定如何工作，首先让我们创建一个动态创建`IDisposable`的辅助函数。
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let''s test it with a nested `use` binding:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一个嵌套的`use`绑定来测试它：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can see that "done" is printed, and then immediately after that, `myResource`
    goes out of scope, its `Dispose` is called, and "hello disposed" is also printed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到打印了"done"，然后立即在此之后，`myResource`超出范围，它的`Dispose`被调用，并且还打印了"hello disposed"。
- en: On the other hand, if we test it using the regular `let` binding, we don't get
    the same effect.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们使用常规的`let`绑定进行测试，我们就不会得到相同的效果。
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, we see that "done" is printed, but `Dispose` is never called.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们看到打印了"done"，但是`Dispose`从未被调用。
- en: '"Use" only works with IDisposables'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '"Use"仅适用于IDisposables'
- en: 'Note that "use" bindings only work with types that implement `IDisposable`,
    and the compiler will complain otherwise:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“use”绑定仅适用于实现`IDisposable`接口的类型，否则编译器会报错：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Don't return "use'd" values
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要返回“use'd”值
- en: It is important to realize that the value is disposed as soon as it goes out
    of scope *in the expression where it was declared*. If you attempt to return the
    value for use by another function, the return value will be invalid.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，值在*声明它的表达式*范围之外时会被处理。如果尝试将值返回给另一个函数使用，返回值将无效。
- en: 'The following example shows how *not* to do it:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何*不*做：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you need to work with a disposable "outside" the function that created it,
    probably the best way is to use a callback.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在创建它的函数之外使用可处置对象，可能最好的方法是使用回调。
- en: 'The function then would work as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后该函数将按以下方式工作：
- en: create the disposable.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可处置对象。
- en: evaluate the callback with the disposable
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估回调函数与可处置对象
- en: call `Dispose` on the disposable
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可处置对象上调用`Dispose`
- en: 'Here''s an example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This approach guarantees that the same function that creates the disposable
    also disposes of it and there is no chance of a leak.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法保证了创建可处置对象的函数也会处理释放，不会出现泄漏的机会。
- en: Another possible way is to *not* use a `use` binding on creation, but use a
    `let` binding instead, and make the caller responsible for disposing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的方式是在创建时*不*使用`use`绑定，而是使用`let`绑定，让调用者负责处理释放。
- en: 'Here''s an example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Personally, I don't like this approach, because it is not symmetrical and separates
    the create from the dispose, which could lead to resource leaks.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我不喜欢这种方法，因为它不对称并将创建与释放分开，这可能导致资源泄漏。
- en: The "using" function
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '"using"函数'
- en: The preferred approach to sharing a disposable, shown above, used a callback
    function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 共享可处置对象的首选方法，如上所示，使用回调函数。
- en: 'There is a built-in `using` function that works in the same way. It takes two
    parameters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个内置的`using`函数，工作方式相同。它接受两个参数：
- en: the first is an expression that creates the resource
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是创建资源的表达式
- en: the second is a function that uses the resource, taking it as a parameter
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是使用资源的函数，将其作为参数传递
- en: 'Here''s our earlier example rewritten with the `using` function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们之前的示例重写，使用`using`函数：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In practice, the `using` function is not used that often, because it is so easy
    to make your own custom version of it, as we saw earlier.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`using`函数并不经常使用，因为很容易自定义自己的版本，就像我们之前看到的那样。
- en: Misusing "use"
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 误用"use"
- en: One trick in F# is to appropriate the `use` keyword to do any kind of "stop"
    or "revert" functionality automatically.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: F#中的一个技巧是使用`use`关键字来自动执行任何类型的“停止”或“还原”功能。
- en: 'The way to do this is:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的方法是：
- en: Create an [extension method](type-extensions) for some type
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为某种类型创建一个[扩展方法](type-extensions)
- en: In that method, start the behavior you want but then return an `IDisposable`
    that stops the behavior.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在该方法中，启动所需的行为，然后返回一个停止行为的`IDisposable`。
- en: For example, here is an extension method that starts a timer and then returns
    an `IDisposable` that stops it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个启动计时器然后返回一个停止它的`IDisposable`的扩展方法。
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So now in the calling code, we create the timer and bind it with `use`. When
    the timer value goes out of scope, it will stop automatically!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在调用代码中，我们创建计时器并与`use`绑定。当计时器值超出范围时，它将自动停止！
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This same approach can be used for other common pairs of operations, such as:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也可以用于其他常见的操作对，例如：
- en: opening/connecting and then closing/disconnecting a resource (which is what
    `IDisposable` is supposed to be used for anyway, but your target type might not
    have implemented it)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开/连接然后关闭/断开资源（这正是`IDisposable`应该用于的方式，但您的目标类型可能尚未实现它）
- en: registering and then deregistering an event handler (instead of using `WeakReference`)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册然后注销事件处理程序（而不是使用`WeakReference`）
- en: in a UI, showing a splash screen at the start of a block of code, and then automatically
    closing it at the end of the block
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI中，在一段代码块开始时显示一个启动屏幕，然后在代码块结束时自动关闭它
- en: I wouldn't recommend this approach generally, because it does hide what is going
    on, but on occasion it can be quite useful.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下我不推荐这种方法，因为它隐藏了正在进行的操作，但在某些情况下可能非常有用。
- en: '"do" bindings'
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '"do"绑定'
- en: Sometimes we might want to execute code independently of a function or value
    definition. This can be useful in module initialization, class initialization
    and so on.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能希望执行与函数或值定义无关的代码。这在模块初始化、类初始化等情况下很有用。
- en: That is, rather than having "`let x = do something`" we just the "`do something`"
    on its own. This is analogous to a statement in an imperative language.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，而不是有 "`let x = do something`"，我们只是单独使用 "`do something`"。这类似于命令式语言中的语句。
- en: 'You can do this by prefixing the code with "`do`":'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在代码前面加上"`do`"来实现这一点：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In many situations, the `do` keyword can be omitted:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可以省略 `do` 关键字：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: But in both cases, the expression must return unit. If it does not, you will
    get a compiler error.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这两种情况下，表达式必须返回 unit。如果不是，你将会得到一个编译器错误。
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As always, you can force a non-unit result to be discarded by piping the results
    into "`ignore`".
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，你可以通过将结果传输到 "`ignore`" 来强制将非 unit 结果丢弃。
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You will also see the "`do`" keyword used in loops in the same way.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会在循环中看到 "`do`" 关键字以相同的方式使用。
- en: Note that although you can sometimes omit it, it is considered good practice
    to always have an explicit "`do`", as it acts as documentation that you do not
    want a result, only the side-effects.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管有时可以省略它，但始终有一个显式的 "`do`" 被认为是一种良好的实践，因为它作为文档说明，表明你不需要一个结果，只需要副作用。
- en: '"do" for module initialization'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块初始化用的 "do"
- en: Just like `let`, `do` can be used both in a nested context, and at the top level
    in a module or class.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `let` 一样，`do` 可以在嵌套上下文和模块或类的顶层都可以使用。
- en: When used at the module level, the `do` expression is evaluated once only, when
    the module is first loaded.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当在模块级别使用时，`do` 表达式仅在模块首次加载时被评估一次。
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is somewhat analogous to a static class constructor in C#, except that
    if there are multiple modules, the order of initialization is fixed and they are
    initialized in order of declaration.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这在某种程度上类似于 C# 中的静态类构造函数，不同之处在于如果有多个模块，初始化顺序是固定的，并且它们按声明顺序初始化。
- en: let! and use! and do!
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: let! 和 use! 和 do!
- en: When you see `let!`, `use!` and `do!` (that is, with exclamation marks) and
    they are part of a curly brace `{..}` block, then they are being used as part
    of a "computation expression". The exact meaning of `let!`, `use!` and `do!` in
    this context depends on the computation expression itself. Understanding computation
    expressions in general will have to wait for a later series.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到 `let!`、`use!` 和 `do!`（即带感叹号的情况）并且它们是作为花括号 `{..}` 块的一部分时，那么它们被用作"计算表达式"的一部分。`let!`、`use!`
    和 `do!` 在这种上下文中的确切含义取决于计算表达式本身。理解一般计算表达式的含义将等待以后的系列文章。
- en: The most common type of computation expression you will run into are *asynchronous
    workflows*, indicated by a `async{..}` block. In this context, it means they are
    being used to wait for an async operation to finish, and only then bind to the
    result value.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到的最常见的计算表达式类型是 *异步工作流*，用 `async{..}` 块表示。在这种情况下，它意味着它们被用于等待异步操作完成，然后绑定到结果值。
- en: 'Here are some examples we saw earlier in [a post from the "why use F#?" series](concurrency-async-and-parallel):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在 [“为什么使用 F#？”系列中](concurrency-async-and-parallel)看到的一些示例：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Attributes on let and do bindings
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 `let` 和 `do` 绑定的属性
- en: If they are at the top-level in a module, `let` and `do` bindings can have attributes.
    F# attributes use the syntax `[<MyAttribute>]`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们在模块的顶层，则 `let` 和 `do` 绑定可以有属性。F# 属性使用语法 `[<MyAttribute>]`。
- en: 'Here are some examples in C# and then the same code in F#:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在 C# 中的示例，然后是相同的代码在 F# 中：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s have a brief look at three attribute examples:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看看三个属性示例：
- en: The EntryPoint attribute used to indicate the "main" function.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于指示 "main" 函数的 EntryPoint 属性。
- en: The various AssemblyInfo attributes.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种 AssemblyInfo 属性。
- en: The DllImport attribute for interacting with unmanaged code.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与非托管代码交互的 DllImport 属性。
- en: The EntryPoint attribute
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入口点属性
- en: The special `EntryPoint` attribute is used to mark the entry point of a standalone
    app, just as in C#, the `static void Main` method is.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊的 `EntryPoint` 属性用于标记独立应用程序的入口点，就像在 C# 中一样，`static void Main` 方法一样。
- en: 'Here''s the familiar C# version:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是熟悉的 C# 版本：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And here''s the F# equivalent:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 F# 的等效语法：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Just as in C#, the args are an array of strings. But unlike C#, where the static
    `Main` method can be `void`, the F# function *must* return an int.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 C# 中一样，args 是一个字符串数组。但与 C# 不同的是，静态 `Main` 方法可以是 `void`，而 F# 函数 *必须* 返回一个
    int。
- en: 'Also, a big gotcha is that the function that has this attribute must be the
    very last function in the last file in the project! Otherwise you get this error:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，一个大的陷阱是具有此属性的函数必须是项目中最后一个文件中的最后一个函数！否则，您会收到此错误：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Why is the F# compiler so fussy? In C#, the class can go anywhere.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 F# 编译器如此挑剔？在 C# 中，类可以放在任何地方。
- en: 'One analogy that might help is this: in some sense, the whole application is
    a single huge expression bound to `main`, where `main` is an expression that contains
    subexpressions that contain other subexpressions.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能有所帮助的类比是：在某种意义上，整个应用程序是一个绑定到 `main` 的单个巨大表达式，其中 `main` 是一个包含包含其他子表达式的子表达式的表达式。
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now in F# projects, there are no forward references allowed. That is, expressions
    that refer to other expressions must be declared after them. And so logically,
    the highest, most top-level function of them all, `main`, must come last of all.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 F# 项目中，不允许有前向引用。也就是说，引用其他表达式的表达式必须在它们之后声明。因此，逻辑上，最高级别的函数 `main` 必须放在所有函数的最后。
- en: The AssemblyInfo attributes
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AssemblyInfo 属性
- en: In a C# project, there is an `AssemblyInfo.cs` file that contains all the assembly
    level attributes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 C# 项目中，有一个名为 `AssemblyInfo.cs` 的文件，其中包含所有程序集级别的属性。
- en: In F#, the equivalent way to do this is with a dummy module which contains a
    `do` expression annotated with these attributes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，执行此操作的等效方式是使用一个包含带有这些属性注释的 `do` 表达式的虚拟模块。
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The DllImport attribute
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DllImport 属性
- en: Another occasionally useful attribute is the `DllImport` attribute. Here's a
    C# example.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个偶尔有用的属性是 `DllImport` 属性。这里是一个 C# 示例。
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It works the same way in F# as in C#. One thing to note is that the `extern
    declaration ...` puts the types before the parameters, C-style.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它在 F# 中的工作方式与在 C# 中相同。需要注意的一点是，`extern declaration ...` 将类型放在参数之前，类似于 C 语言风格。
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Interop with unmanaged code is a big topic which will need its own series.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与非托管代码的互操作是一个需要专门讨论的重要主题。
- en: 'F# syntax: indentation and verbosity'
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 语法：缩进和冗长
- en: 'F# syntax: indentation and verbosity'
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 语法：缩进和冗长
- en: The syntax for F# is mostly straightforward. But there are a few rules that
    you should understand if you want to avoid common indentation errors. If you are
    familiar with a language like Python that also is whitespace sensitive, be aware
    that that the rules for indentation in F# are subtly different.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的语法大部分是直接的。但是，如果您想避免常见的缩进错误，您应该了解一些规则。如果您熟悉像 Python 这样的对空格敏感的语言，请注意 F# 中缩进的规则略有不同。
- en: Indentation and the "offside" rule
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进和“offside”规则
- en: In soccer, the offside rule says that in some situations, a player cannot be
    "ahead" of the ball when they should be behind or level with it. The "offside
    line" is the line the player must not cross. F# uses the same term to describe
    the line at which indentation must start. As with soccer, the trick to avoiding
    a penalty is to know where the line is and not get ahead of it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在足球中，越位规则规定在某些情况下，球员不能在应该在球后或与球平齐时“超越”球。"越位线"是球员不能越过的线。F# 使用相同的术语来描述缩进必须开始的线。与足球一样，避免被罚的诀窍是知道线在哪里，并且不要超越它。
- en: Generally, once an offside line has been set, all the expressions must align
    with the line.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦设置了 offside 行，所有表达式都必须与该行对齐。
- en: '[PRE58]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Various tokens can trigger new offside lines to be created. For example, when
    the F# sees the "`=`" used in a let expression, a new offside line is created
    at the position of the very next symbol or word encountered.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 各种标记可以触发创建新 offside 行。例如，当 F# 看到在 let 表达式中使用 "`=`" 时，将在遇到的下一个符号或单词的位置创建一个新的
    offside 行。
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Other tokens have the same behavior, including parentheses, "`then`", "`else`",
    "`try`", "`finally`" and "`do`", and "`->`" in match clauses.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标记具有相同的行为，包括括号、"`then`"、"`else`"、"`try`"、"`finally`"和"`do`"，以及匹配子句中的"`->`"。
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The offside lines can be nested, and are pushed and popped as you would expect:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: offside 行可以嵌套，并按照您的预期进行推送和弹出：
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'New offside lines can never go forward further than the previous line on the
    stack:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 offside 行永远不能向前超过堆栈上前一行的位置：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Special cases
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊情况
- en: There are number of special cases which have been created to make code formatting
    more flexible. Many of them will seem natural, such as aligning the start of each
    part of an `if-then-else` expression or a `try-catch` expression. There are some
    non-obvious ones, however.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 已经创建了许多特殊情况，以使代码格式更加灵活。其中许多看起来很自然，比如对齐 `if-then-else` 表达式或 `try-catch` 表达式的每个部分的开头。然而，也有一些不明��的情况。
- en: 'Infix operators such as "+", "|>" and ">>" are allowed to be outside the line
    by their length plus one space:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 中缀运算符，如"+", "|>" 和 ">>"，允许在行外以其长度加一空格的方式出现：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If an infix operator starts a line, that line does not have to be strict about
    the alignment:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中缀运算符在行首出现，那么该行不必严格对齐：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If a "`fun`" keyword starts an expression, the "fun" does *not* start a new
    offside line:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“fun”关键字开始一个表达式，那么“fun”*不*会开始一个新的偏移行：
- en: '[PRE65]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Finding out more
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解更多信息
- en: There are many more details as to how indentation works, but the examples above
    should cover most of the common cases. If you want to know more, the complete
    language spec for F# is available from Microsoft as a [downloadable PDF](http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.pdf),
    and is well worth reading.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有关缩进工作方式的更多细节，但上面的示例应该涵盖了大多数常见情况。如果你想了解更多，F#的完整语言规范可从微软作为[可下载的PDF](http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.pdf)获取，并且值得一读。
- en: '"Verbose" syntax'
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “冗长”语法
- en: 'By default, F# uses indentation to indicate block structure -- this is called
    "light" syntax. There is an alternative syntax that does not use indentation;
    it is called "verbose" syntax. With verbose syntax, you are not required to use
    indentation, and whitespace is not significant, but the downside is that you are
    required to use many more keywords, including things like:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，F#使用缩进来指示块结构--这被称为“轻量”语法。还有一种不使用缩进的替代语法，称为“冗长”语法。使用冗长语法时，你不需要使用缩进，空格不重要，但缺点是你需要使用更多的关键字，包括诸如：
- en: '"`in`" keywords after every "let" and "do" binding'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个“let”和“do”绑定后的“in”关键字
- en: '"`begin`"/"`end`" keywords for code blocks such as if-then-else'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块（如if-then-else）的“begin”/“end”关键字
- en: '"`done`" keywords at the end of loops'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环结束时的“done”关键字
- en: keywords at the beginning and end of type definitions
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型定义的开头和结尾的关键字
- en: 'Here is an example of verbose syntax with wacky indentation that would not
    otherwise be acceptable:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有古怪缩进的冗长语法示例，否则是不可接受的：
- en: '[PRE66]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Verbose syntax is always available, even in "light" mode, and is occasionally
    useful. For example, when you want to embed "let" into a one line expression:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在“轻量”模式下，冗长的语法始终可用，并且偶尔很有用。例如，当你想将“let”嵌入到一行表达式中时：
- en: '[PRE67]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Other cases when you might want to use verbose syntax are:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能需要使用冗长语法的情况包括：
- en: when outputting generated code
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输出生成的代码时
- en: to be compatible with OCaml
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了与OCaml兼容
- en: if you are visually impaired or blind and use a screen reader
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你视力受损或盲人并使用屏幕阅读器
- en: or just to gain some insight into the abstract syntax tree used by the F# parser
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者只是为了对F#解析器使用的抽象语法树有一些了解
- en: Other than these cases, verbose syntax is rarely used in practice.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些情况外，冗长语法在实践中很少使用。
- en: Parameter and value naming conventions
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数和值的命名约定
- en: Parameter and value naming conventions
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数和值的命名约定
- en: If you are coming to F# from an imperative language such as C#, then you might
    find a lot of the names shorter and more cryptic than you are used to.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从诸如C#之类的命令式语言转向F#，那么你可能会发现很多名称比你习惯的更短更神秘。
- en: In C# and Java, the best practice is to have long descriptive identifiers. In
    functional languages, the function names themselves can be descriptive, but the
    local identifiers inside a function tend to be quite short, and piping and composition
    is used a lot to get everything on a minimal number of lines.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#和Java中，最佳实践是使用长的描述性标识符。在函数式语言中，函数名称本身可以是描述性的，但函数内部的本地标识符往往非常简短，并且经常使用管道和组合来使所有内容尽可能少地占用行数。
- en: For example, here is a crude implementation of a prime number sieve with very
    descriptive names for the local values.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个使用非常描述性名称的素数筛的粗糙实现��
- en: '[PRE68]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is the same implementation, with terser, idiomatic names and more compact
    code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同的实现，使用更简洁、惯用的名称和更紧凑的代码：
- en: '[PRE69]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The cryptic names are not always better, of course, but if the function is kept
    to a few lines and the operations used are standard, then this is a fairly common
    idiom.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，神秘的名称并不总是更好，但如果函数保持在几行内并且使用的操作是标准的，那么这是一个相当常见的习惯用法。
- en: 'The common naming conventions are as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的命名约定如下：
- en: '"a", "b", "c" etc., are types'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"a", "b", "c"等是类型'
- en: '"f", "g", "h" etc., are functions'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"f", "g", "h"等是函数'
- en: '"x", "y", "z" etc., are arguments to the functions'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"x", "y", "z"等是函数的参数'
- en: Lists are indicated by adding an "s" suffix, so that "`xs`" is a list of `x`'s,
    "`fs`" is a list of functions, and so on. It is extremely common to see "`x::xs`"
    meaning the head (first element) and tail (the remaining elements) of a list.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表通过添加 "s" 后缀来表示，因此 "`xs`" 是 `x` 的列表，"`fs`" 是函数的列表，等等。极其常见的是 "`x::xs`" 表示列表的头（第一个元素）和尾部（剩余元素）。
- en: '"*" is used whenever you don''t care about the value. So "`x::*`" means that
    you don''t care about the rest of the list, and "`let f _ = something`" means
    you don''t care about the argument to`f`.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"*" 在你不关心值的时候使用。因此，"`x::*`" 表示你不关心列表的其余部分，"`let f _ = something`" 表示你不关心`f`的参数。'
- en: 'Another reason for the short names is that often, they cannot be assigned to
    anything meaningful. For example, the definition of the pipe operator is:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用简短名称的原因是，通常它们不能分配给任何有意义的内容。例如，管道运算符的定义是：
- en: '[PRE70]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We don't know what `f` and `x` are going to be, `f` could be any function and
    `x` could be any value. Making this explicit does not make the code any more understandable.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道 `f` 和 `x` 将会是什么，`f` 可能是任何函数，`x` 可能是任何值。明确这一点并不会使代码更加易懂。
- en: '[PRE71]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The style used on this site
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在本网站上使用的风格
- en: On this site I will use both styles. For the introductory series, when most
    of the concepts are new, I will use a very descriptive style, with intermediate
    values and long names. But in more advanced series, the style will become terser.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个网站上，我会同时使用两种风格。对于介绍性系列，当大多数概念都是新的时，我会使用非常描述性的风格，包括中间值和长名称。但在更高级的系列中，风格会变得更加简洁。
- en: Control flow expressions
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流表达式
- en: Control flow expressions
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流表达式
- en: 'In this post, we''ll look at the control flow expressions, namely:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将看看控制流表达式，即：
- en: if-then-else
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if-then-else
- en: for x in collection (which is the same as foreach in C#)
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于集合中的每个 x（与 C# 中的 foreach 相同）
- en: for x = start to end
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 x 从开始到结束
- en: while-do
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: while-do
- en: These control flow expressions are no doubt very familiar to you. But they are
    very "imperative" rather than functional.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制流表达式无疑对你来说非常熟悉。但它们非常 "命令式" 而不是函数式。
- en: So I would strongly recommend that you do not use them if at all possible, especially
    when you are learning to think functionally. If you do use them as a crutch, you
    will find it much harder to break away from imperative thinking.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我强烈建议你尽可能不要使用它们，特别是当你正在学习函数式思维时。如果你把它们当作救命稻草使用，你会发现要摆脱命令式思维会更加困难。
- en: To help you do this, I will start each section with examples of how to avoid
    using them by using more idiomatic constructs instead. If you do need to use them,
    there are some "gotchas" that you need to be aware of.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你做到这一点，我将每个部分的开头都以更为惯用的结构示例来避免使用它们。如果你确实需要使用它们，那么你需要注意一些可能出现的问题。
- en: If-then-else
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: If-then-else
- en: How to avoid using if-then-else
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何避免使用 if-then-else
- en: The best way to avoid `if-then-else` is to use "match" instead. You can match
    on a boolean, which is similar to the classic then/else branches. But much, much
    better, is to avoid the equality test and actually match on the thing itself,
    as shown in the last implementation below.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `if-then-else` 的最佳方法是使用 "match"。你可以匹配一个布尔值，这类似于经典的 then/else 分支。但更好的做法是避免相等性测试，实际上匹配物体本身，如下面的最后一个实现所示。
- en: '[PRE72]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Part of the reason why direct matching is better is that the equality test throws
    away useful information that you often need to retrieve again.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 直接匹配更好的部分原因是相等性测试丢弃了通常需要重新获取的有用信息。
- en: This is demonstrated by the next scenario, where we want to get the first element
    of a list in order to print it. Obviously, we must be careful not to attempt this
    for an empty list.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这由下一个场景来展示，我们想要获取列表的第一个元素以便打印它。显然，我们必须小心，不要尝试对空列表进行这样的操作。
- en: The first implementation does a test for empty and then a *second* operation
    to get the first element. A much better approach is to match and extract the element
    in one single step, as shown in the second implementation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种实现进行了空测试，然后进行了第 *二* 次操作以获取第一个元素。更好的方法是一次匹配并提取元素，如下所示的第二种实现。
- en: '[PRE73]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The second implementation is not only easier to understand, it is more efficient.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种实现不仅更容易理解，而且更有效率。
- en: If the boolean test is complicated, it can still be done with match by using
    extra "`when`" clauses (called "guards"). Compare the first and second implementations
    below to see the difference.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔测试很复杂，仍然可以通过使用额外的 "`when`" 子句（称为 "guards"）来使用 match 来完成。比较下面的第一和第二种实现以查看差异。
- en: '[PRE74]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Again, the second implementation is easier to understand and also more efficient.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，第二个实现更容易理解，而且更高效。
- en: 'The moral of the tale is: if you find yourself using if-then-else or matching
    on booleans, consider refactoring your code.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的寓意是：如果你发现自己在使用if-then-else或匹配布尔值，请考虑重构你的代码。
- en: How to use if-then-else
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用if-then-else
- en: 'If you do need to use if-then-else, be aware that even though the syntax looks
    familiar, there is a catch that you must be aware of: "`if-then-else`" is an *expression*,
    not a *statement*, and as with every expression in F#, it must return a value
    of a particular type.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要使用if-then-else，请注意即使语法看起来很熟悉，但你必须注意一个要点：“`if-then-else`”是一个*表达式*，而不是一个*语句*，与F#中的每个表达式一样，它必须返回特定类型的值。
- en: Here are two examples where the return type is a string.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个返回类型为字符串的示例。
- en: '[PRE75]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: But as a consequence, both branches must return the same type! If this is not
    true, then the expression as a whole cannot return a consistent type and the compiler
    will complain.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 但作为一个结果，两个分支必须返回相同的类型！如果这不成立，那么整个表达式就无法返回一致的类型，编译器会报错。
- en: 'Here is an example of different types in each branch:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在每个分支中具有不同类型的示例：
- en: '[PRE76]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The "else" clause is optional, but if it is absent, the "else" clause is assumed
    to return unit, which means that the "then" clause must also return unit. You
    will get a complaint from the compiler if you make this mistake.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: “else”子句是可选的，但如果它不存在，则假定“else”子句返回单位，这意味着“then”子句也必须返回单位。如果你犯了这个错误，编译器会投诉你。
- en: '[PRE77]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: If the "then" clause returns unit, then the compiler will be happy.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“then”子句返回单位，则编译器将会满意。
- en: '[PRE78]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that there is no way to return early in a branch. The return value is the
    entire expression. In other words, the if-then-else expression is more closely
    related to the C# ternary if operator (<if expr="" class="hljs-class">?<then expr=""
    class="hljs-class">:<else expr="" class="hljs-class">) than to the C# if-then-else
    statement.</else></then></if>
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有办法在分支中提前返回。返回值是整个表达式。换句话说，if-then-else表达式与C#中的三元if运算符（<if expr="" class="hljs-class">?<then
    expr="" class="hljs-class">:<else expr="" class="hljs-class">）更接近</else></then></if>，而不是C#中的if-then-else语句。
- en: if-then-else for one liners
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于一行代码的if-then-else
- en: One of the places where if-then-else can be genuinely useful is to create simple
    one-liners for passing into other functions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: if-then-else真正有用的一个地方是创建简单的一行代码，以传递到其他函数中。
- en: '[PRE79]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Returning functions
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回函数
- en: 'Don''t forget that an if-then-else expression can return any value, including
    function values. For example:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，if-then-else表达式可以返回任何值，包括函数值。例如：
- en: '[PRE80]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Of course, both functions must have the same type, meaning that they must have
    the same function signature.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，两个函数必须具有相同的类型，这意味着它们必须具有相同的函数签名。
- en: Loops
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: How to avoid using loops
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何避免使用循环
- en: The best way to avoid loops is to use the built in list and sequence functions
    instead. Almost anything you want to do can be done without using explicit loops.
    And often, as a side benefit, you can avoid mutable values as well. Here are some
    examples to start with, and for more details please read the upcoming series devoted
    to list and sequence operations.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 避免循环的最佳方法是使用内置的列表和序列函数。几乎所有你想做的事情都可以不使用显式循环来完成。而且通常，作为副作用，你也可以避免可变值。以下是一些示例供参考，更多细节请阅读专门介绍列表和序列操作的系列文章。
- en: 'Example: Printing something 10 times:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：打印10次某个内容：
- en: '[PRE81]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Example: Summing a list:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：求列表的总和：
- en: '[PRE82]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Example: Generating and printing a sequence of random numbers:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：生成并打印一系列随机数：
- en: '[PRE83]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As with if-then-else, there is a moral; if you find yourself using loops and
    mutables, please consider refactoring your code to avoid them.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 与if-then-else一样，有一个寓意；如果你发现自己在使用循环和可变值，请考虑重构你的代码以避免它们。
- en: The three types of loops
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 三种类型的循环
- en: If you want to use loops, then there are three types of loop expressions to
    choose from, which are similar to those in C#.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用循环，那么有三种类型的循环表达式可供选择，它们与C#中的类似。
- en: '`for-in-do`. This has the form `for x in enumerable do something`. It is the
    same as the `foreach` loop in C#, and is the form most commonly seen in F#.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-in-do`。其形式为`for x in enumerable do something`。它与C#中的`foreach`循环相同，并且是F#中最常见的形式。'
- en: '`for-to-do`. This has the form `for x = start to finish do something`. It is
    the same as the standard `for (i=start; i<end; i++)` loops in C#.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for-to-do`。其形式为`for x = start to finish do something`。它与C#中的标准`for (i=start;
    i<end; i++)`循环相同。'
- en: '`while-do`. This has the form `while test do something`. It is the same as
    the `while` loop in C#. Note that there is no `do-while` equivalent in F#.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while-do`。它的形式是 `while test do something`。这与 C# 中的 `while` 循环相同。请注意，F# 中没有
    `do-while` 的等价物。'
- en: I won't go into any more detail than this, as the usage is straightforward.
    If you have trouble, check the [MSDN documentation](http://msdn.microsoft.com/en-us/library/dd233227.aspx).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会再详细介绍了，因为用法很简单。如果有困难，请查看 [MSDN 文档](http://msdn.microsoft.com/en-us/library/dd233227.aspx)。
- en: How to use loops
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用循环
- en: As with if-then-else expressions, the loop expressions look familiar, but there
    are some catches again.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 if-then-else 表达式一样，循环表达式看起来很熟悉，但是又有一些地方需要注意。
- en: All looping expressions always return unit for the whole expression, so there
    is no way to return a value from inside a loop.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的循环表达式总是为整个表达式返回 unit，因此没有办法从循环内部返回一个值。
- en: As with all "do" bindings, the expression inside the loop must return unit as
    well.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像所有的 "do" 绑定一样，循环内部的表达式也必须返回 unit。
- en: There is no equivalent of "break" and "continue" (this can generally done better
    using sequences anyway)
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有 "break" 和 "continue" 的等价物（这通常可以使用序列更好地完成）
- en: Here's an example of the unit constraint. The expression in the loop should
    be unit, not int, so the compiler will complain.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 unit 约束的例子。循环中的表达式应该是 unit，而不是 int，所以编译器会报错。
- en: '[PRE84]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Loops for one liners
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一行代码的循环
- en: One of the places where loops are used in practice is as list and sequence generators.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，循环在实践中用作列表和序列生成器的地方之一。
- en: '[PRE85]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Summary
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'I''ll repeat what I said at the top of the post: do avoid using imperative
    control flow when you are learning to think functionally. And understand the exceptions
    that prove the rule; the one-liners whose use is acceptable.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我会重申我在帖子开头说的话：在学习函数式思维时，尽量避免使用命令式控制流。并且要理解证明规则的异常；那些使用是可以接受的一行代码。
- en: Exceptions
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Exceptions
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Just like other .NET languages, F# supports throwing and catching exceptions.
    As with the control flow expressions, the syntax will feel familiar, but again
    there are a few catches that you should know about.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他 .NET 语言一样，F# 支持抛出和捕获异常。与控制流表达式一样，语法会让人觉得很熟悉，但是再次提醒您，有一些地方需要注意。
- en: Defining your own exceptions
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自己的异常
- en: 'When raising/throwing exceptions, you can use the standard system ones such
    as `InvalidOperationException`, or you can define your own exception types using
    the simple syntax shown below, where the "content" of the exception is any F#
    type:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在引发/抛出异常时，您可以使用标准的系统异常，比如 `InvalidOperationException`，或者您可以使用下面所示的简单语法来定义自己的异常类型，其中异常的
    "内容" 是任何 F# 类型：
- en: '[PRE86]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: That's it! Defining new exception classes is a lot easier than in C#!
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！定义新的异常类比在 C# 中要容易得多！
- en: Throwing exceptions
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: There are three basic ways to throw an exception
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种基本的抛出异常的方法
- en: Using one of the built in functions, such as "invalidArg"
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其中一个内置函数，比如 "invalidArg"
- en: Using one of the standard .NET exception classes
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其中一个标准 .NET 异常类
- en: Using your own custom exception types
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您自己的自定义异常类型
- en: 'Throwing exceptions, method 1: using one of the built in functions'
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常，方法 1：使用内置函数之一
- en: 'There are four useful exception keywords built into F#:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: F# 内置了四个有用的异常关键字：
- en: '`failwith` throws a generic `System.Exception`'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`failwith` 抛出一个通用的 `System.Exception`'
- en: '`invalidArg` throws an `ArgumentException`'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidArg` 抛出一个 `ArgumentException`'
- en: '`nullArg` throws a `NullArgumentException`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nullArg` 抛出一个 `NullArgumentException`'
- en: '`invalidOp` throws an `InvalidOperationException`'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalidOp` 抛出一个 `InvalidOperationException`'
- en: 'These four probably cover most of the exceptions you would regularly throw.
    Here is how they are used:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种情况可能涵盖了您经常抛出的大多数异常。这是它们的用法：
- en: '[PRE87]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'By the way, there''s a very useful variant of `failwith` called `failwithf`
    that includes `printf` style formatting, so that you can make custom messages
    easily:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，有一个非常有用的 `failwith` 的变体叫做 `failwithf`，它包含 `printf` 风格的格式化，这样您就可以轻松地制作自定义消息：
- en: '[PRE88]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Throwing exceptions, method 2: using one of the standard .NET exception classes'
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常，方法 2：使用其中一个标准 .NET 异常类
- en: 'You can `raise` any .NET exception explicitly:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以显式 `raise` 任何 .NET 异常： '
- en: '[PRE89]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Throwing exceptions, method 3: using your own F# exception types'
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抛出异常，方法 3：使用您自己的 F# 异常类型
- en: Finally, you can use your own types, as defined earlier.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用之前定义的自定义类型。
- en: '[PRE90]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: And that's pretty much it for throwing exceptions.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 至于抛出异常，基本就是这样了。
- en: What effect does raising an exception have on the function type?
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常对函数类型有什么影响？
- en: We said earlier that both branches of an if-then-else expression must return
    the same type. But how can raising an exception work with this constraint?
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，if-then-else表达式的两个分支必须返回相同的类型。但是，如何在这种约束下引发异常呢？
- en: The answer is that any code that raises exceptions is ignored for the purposes
    of determining expression types. This means that the function signature will be
    based on the normal case only, not the exception case.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，任何引发异常的代码在确定表达式类型时都将被忽略。这意味着函数签名将基于正常情况而不是异常情况。
- en: For example, in the code below, the exceptions are ignored, and the overall
    function has signature `bool->int`, as you would expect.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的代码中，异常被忽略了，整个函数的签名是`bool->int`，正如你所预期的那样。
- en: '[PRE91]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Question: what do you think the function signature will be if both branches
    raise exceptions?'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：如果两个分支都引发异常，你认为函数签名会是什么？
- en: '[PRE92]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Try it and see!
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看吧！
- en: Catching exceptions
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获异常
- en: Exceptions are caught using a try-catch block, as in other languages. F# calls
    it `try-with` instead, and testing for each type of exception uses the standard
    pattern matching syntax.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是使用`try-catch`块捕获的，就像其他语言一样。F#将其称为`try-with`，并使用标准的模式匹配语法测试每种类型的异常。
- en: '[PRE93]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If the exception to catch was thrown with `failwith` (e.g. a System.Exception)
    or a custom F# exception, you can match using the simple tag approach shown above.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要捕获的异常是使用`failwith`（例如System.Exception）或自定义的F#异常引发的，则可以使用上面显示的简单标记方法进行匹配。
- en: 'On the other hand, to catch a specific .NET exception class, you have to match
    using the more complicated syntax:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，要捕获特定的.NET异常类，您必须使用更复杂的语法进行匹配：
- en: '[PRE94]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Again, as with if-then-else and the loops, the try-with block is an expression
    that returns a value. This means that all branches of the `try-with` expression
    *must* return the same type.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，与if-then-else和循环一样，`try-with`块是一个返回值的表达式。这意味着`try-with`表达式的所有分支*必须*返回相同的类型。
- en: 'Consider this example:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE95]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'When we try to evaluate it, we get an error:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试评估它时，我们会得到一个错误：
- en: '[PRE96]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The reason is that the "`with`" branch is of type `unit`, while the "`try`"
    branch is of type `int`. So the two branches are of incompatible types.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是"`with`"分支的类型是`unit`，而"`try`"分支的类型是`int`。因此，这两个分支的类型不兼容。
- en: To fix this, we need to make the "`with`" branch also return type `int`. We
    can do this easily using the semicolon trick to chain expressions on one line.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个问题，我们需要使"`with`"分支也返回类型`int`。我们可以使用分号技巧轻松地将表达式链接在一行上。
- en: '[PRE97]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now that the `try-with` expression has a defined type, the whole function can
    be assigned a type, namely `int -> int -> int`, as expected.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`try-with`表达式具有了定义的类型，整个函数可以分配一个类型，即`int -> int -> int`，正如预期的那样。
- en: As before, if any branch throws an exception, it doesn't count when types are
    being determined.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，如果任何分支抛出异常，在确定类型时不计数。
- en: Rethrowing exceptions
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新抛出异常
- en: If needed, you can call the "`reraise()`" function in a catch handler to propagate
    the same exception up the call chain. This is the same as the C# `throw` keyword.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，在catch处理程序中可以调用"`reraise()`"函数将相同的异常传播到调用链上。这与C#的`throw`关键字相同。
- en: '[PRE98]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Try-finally
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Try-finally`'
- en: Another familiar expression is `try-finally`. As you might expect, the "finally"
    clause will be called no matter what.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个熟悉的表达式是`try-finally`。正如你所期望的那样，“finally”子句将被调用，无论发生什么情况。
- en: '[PRE99]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The return type of the try-finally expression as a whole is always the same
    as return type of the "try" clause on its own. The "finally" clause has no effect
    on the type of the expression as a whole. So in the above example, the whole expression
    has type `string`.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-finally`表达式作为整体的返回类型始终与其自身的“try”子句的返回类型相同。“finally”子句对整个表达式的类型没有影响。因此，在上面的例子中，整个表达式的类型是`string`。'
- en: The "finally" clause must always return unit, so any non-unit values will be
    flagged by the compiler.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: “finally”子句必须始终返回`unit`，因此任何非`unit`值都将被编译器标记。
- en: '[PRE100]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Combining try-with and try-finally
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合`try-with`和`try-finally`
- en: The try-with and the try-finally expressions are distinct and cannot be combined
    directly into a single expression. Instead, you will have to nest them as circumstances
    require.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-with`和`try-finally`表达式是不同的，不能直接组合成单个表达式。相反，您将不得不根据需要嵌套它们。'
- en: '[PRE101]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Should functions throw exceptions or return error structures?
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数应该抛出异常还是返回错误结构？
- en: When you are designing a function, should you throw exceptions, or return structures
    which encode the error? This section will discuss two different approaches.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计一个函数时，你应该抛出异常，还是返回编码错误的结构体？本节将讨论两种不同的方法。
- en: The pair of functions approach
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数对方法
- en: 'One approach is to provide two functions: one which assumes everything works
    and throws an exception otherwise and a second "tryXXX" function that returns
    a missing value if something goes wrong.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是提供两个函数：一个假设一切正常并在出现问题时抛出异常，另一个 "tryXXX" 函数在出现问题时返回一个缺失值。
- en: 'For example, we might want to design two distinct library functions for division,
    one that doesn''t handle exceptions and one that does:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能想要为除法设计两个不同的库函数，一个处理异常，另一个不处理：
- en: '[PRE102]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note the use of `Some` and `None` Option types in the `tryDivide` code to signal
    to the client whether the value is valid.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `tryDivide` 代码中使用 `Some` 和 `None` 选项类型来向客户端信号值是否有效。
- en: With the first function, the client code must handle the exception explicitly.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个函数，客户端代码必须明确处理异常。
- en: '[PRE103]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Note that there is no constraint that forces the client to do this, so this
    approach can be a source of errors.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并没有强制客户端这样做的约束，因此这种方法可能是错误的源头。
- en: With the second function the client code is simpler, and the client is constrained
    to handle both the normal case and the error case.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个函数，客户端代码更简单，客户端被限制处理正常情况和错误情况。
- en: '[PRE104]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This "normal vs. try" approach is very common in the .NET BCL, and also occurs
    in a few cases in the F# libraries too. For example, in the `List` module:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 "正常 vs. 尝试" 方法在 .NET BCL 中非常常见，在 F# 库中也有一些情况。例如，在 `List` 模块中：
- en: '`List.find` will throw a `KeyNotFoundException` if the key is not found'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果键未找到，`List.find` 将抛出 `KeyNotFoundException`。
- en: But `List.tryFind` will return an Option type, with `None` if the key is not
    found
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是 `List.tryFind` 将返回一个选项类型，如果键未找到，则为 `None`。
- en: 'If you are going to use this approach, do have a naming convention. For example:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要使用这种方法，请使用一种命名约定。例如：
- en: '"doSomethingExn" for functions that expect clients to catch exceptions.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于那些期望客户端捕获异常的函数，使用"doSomethingExn"。
- en: '"tryDoSomething" for functions that handle normal exceptions for you.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于那些为你处理正常异常的函数，使用"tryDoSomething"。
- en: Note that I prefer to have an "Exn" suffix on "doSomething" rather than no suffix
    at all. It makes it clear that you expect clients to catch exceptions even in
    normal cases.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我更喜欢在 "doSomething" 上使用 "Exn" 后缀，而不是根本没有后缀。这清楚地表明你期望客户端即使在正常情况下也会捕获异常。
- en: The overall problem with this approach is that you have to do extra work to
    create pairs of functions, and you reduce the safety of the system by relying
    on the client to catch exceptions if they use the unsafe version of the function.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的整体问题在于你必须额外工作来创建函数对，并且通过依赖客户端来捕获异常来降低系统的安全性，如果他们使用函数的不安全版本。
- en: The error-code-based approach
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于错误码的方法
- en: '"Writing good error-code-based code is hard, but writing good exception-based
    code is really hard." [*Raymond Chen*](http://blogs.msdn.com/b/oldnewthing/archive/2005/01/14/352949.aspx)'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"编写良好的基于错误码的代码很困难，但编写良好的基于异常的代码真的很困难。" [*雷蒙德·陈*](http://blogs.msdn.com/b/oldnewthing/archive/2005/01/14/352949.aspx)'
- en: In the functional world, returning error codes (or rather error *types*) is
    generally preferred to throwing exceptions, and so a standard hybrid approach
    is to encode the common cases (the ones that you would expect a user to care about)
    into a error type, but leave the very unusual exceptions alone.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式世界中，返回错误码（或者更确切地说是错误*类型*）通常优先于抛出异常，因此一个标准的混合方法是将常见情况（你期望用户关心的情况）编码为错误类型，但是保留非常罕见的异常。
- en: 'Often, the simplest approach is just to use the option type: `Some` for success
    and `None` for errors. If the error case is obvious, as in `tryDivide` or `tryParse`,
    there is no need to be explicit with more detailed error cases.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最简单的方法就是使用选项类型：`Some` 表示成功，`None` 表示错误。如果错误情况很明显，如 `tryDivide` 或 `tryParse`
    中，就没有必要对更详细的错误情况进行显式处理。
- en: But sometimes there is more than one possible error, and each should be handled
    differently. In this case, a union type with a case for each error is useful.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时会有多个可能的错误，并且每个错误应该有不同的处理方法。在这种情况下，使用每个错误一个案例的联合类型是有用的。
- en: In the following example, we want to execute a SqlCommand. Three very common
    error cases are login errors, constraint errors and foreign key errors, so we
    build them into the result structure. All other errors are raised as exceptions.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The client is then forced to handle the common cases, while uncommon exceptions
    will be caught by a handler higher up the call chain.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Unlike a traditional error code approach, the caller of the function does not
    have to handle any errors immediately, and can simply pass the structure around
    until it gets to someone who knows how to handle it, as shown below:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: On the other hand, unlike C#, the result of a expression cannot be accidentally
    thrown away. So if a function returns an error result, the caller must handle
    it (unless it really wants to be badly behaved and send it to `ignore`)
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Match expressions
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Match expressions
  id: totrans-512
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is ubiquitous in F#. It is used for binding values to expressions
    with `let`, and in function parameters, and for branching using the `match..with`
    syntax.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: We have briefly covered binding values to expressions in a [post in the "why
    use F#?" series](conciseness-pattern-matching), and it will be covered many times
    as we [investigate types](overview-of-types-in-fsharp).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: So in this post, we'll cover the `match..with` syntax and its use for control
    flow.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: What is a match expression?
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen `match..with` expressions a number of times. And we know
    that it has the form:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If you squint at it just right, it looks a bit like a series of lambda expressions:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Where each lambda expression has exactly one parameter:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: So one way of thinking about `match..with` is that it is a choice between a
    set of lambda expressions. But how to make the choice?
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: This is where the patterns come in. The choice is made based on whether the
    "match with" value can be matched with the parameter of the lambda expression.
    The first lambda whose parameter can be made to match the input value "wins"!
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: So for example, if the param is the wildcard `_`, it will always match, and
    if first, always win.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Order is important!
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Looking at the following example:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We can see that there are three lambda expressions to match, in this order:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: So, the `1` pattern gets tried first, then then the `2` pattern, and finally,
    the `_` pattern.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we changed the order to put the wildcard first, it would
    be tried first and always win immediately:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In this case, the F# compiler helpfully warns us that the other rules will never
    be matched.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: So this is one major difference between a "`switch`" or "`case`" statement compared
    with a `match..with`. In a `match..with`, **the order is important**.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Formatting a match expression
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since F# is sensitive to indentation, you might be wondering how best to format
    this expression, as there are quite a few moving parts.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: The [post on F# syntax](fsharp-syntax) gives an overview of how alignment works,
    but for `match..with` expressions, here are some specific guidelines.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '**Guideline 1: The alignment of the `| expression` clauses should be directly
    under the `match`**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**指南 1：`| expression`子句的对齐应直接位于`match`下面**'
- en: This guideline is straightforward.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指南很简单。
- en: '[PRE116]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '**Guideline 2: The `match..with` should be on a new line**'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**指南 2：`match..with`应该在新行上**'
- en: 'The `match..with` can be on the same line or a new line, but using a new line
    keeps the indenting consistent, independent of the lengths of the names:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '`match..with`可以在同一行或新行上，但使用新行可以保持缩进的一致性，独立于名称的长度：'
- en: '[PRE117]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '**Guideline 3: The expression after the arrow `->` should be on a new line**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**指南 3：箭头`->`后的表达式应该在新行上**'
- en: Again, the result expression can be on the same line as the arrow, but using
    a new line again keeps the indenting consistent and helps to separate the match
    pattern from the result expression.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，结果表达式可以在同一行上，但是再次使用新行可以保持缩进的一致性，并有助于将匹配模式与结果表达式分开。
- en: '[PRE118]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Of course, when all the patterns are very compact, a common sense exception
    can be made:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有模式非常紧凑时，当然可以做一个常识性的例外：
- en: '[PRE119]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: match..with is an expression
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: match..with是一个表达式
- en: It is important to realize that `match..with` is not really a "control flow"
    construct. The "control" does not "flow" down the branches, but instead, the whole
    thing is an expression that gets evaluated at some point, just like any other
    expression. The end result in practice might be the same, but it is a conceptual
    difference that can be important.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到`match..with`实际上不是一个“控制流”构造。 “控制”不“流”到分支中，而是整个事情是一个在某些时刻被评估的表达式，就像任何其他表达式一样。实际上的最终结果可能是相同的，但这是一个重要的概念上的差异。
- en: One consequence of it being an expression is that all branches *must* evaluate
    to the *same* type -- we have already seen this same behavior with if-then-else
    expressions and for loops.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的一个后果是所有分支*必须*评估为*相同*类型--我们已经看到了这种与if-then-else表达式和for循环相同的行为。
- en: '[PRE120]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: You cannot mix and match the types in the expression.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能在表达式中混合和匹配类型。
- en: You can use match expressions anywhere
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您可以在任何地方使用匹配表达式
- en: Since they are normal expressions, match expressions can appear anywhere an
    expression can be used.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是普通表达式，匹配表达式可以出现在任何表达式可以使用的地方。
- en: 'For example, here''s a nested match expression:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个嵌套的匹配表达式：
- en: '[PRE121]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'And here''s a match expression embedded in a lambda:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个嵌入到lambda中的匹配表达式：
- en: '[PRE122]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Exhaustive matching
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全面匹配
- en: Another consequence of being an expression is that there must always be *some*
    branch that matches. The expression as a whole must evaluate to *something*!
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个作为表达式的后果是必须总是有*一些*分支匹配。整个表达式必须评估为*某些东西*！
- en: That is, the valuable concept of "exhaustive matching" comes from the "everything-is-an-expression"
    nature of F#. In a statement oriented language, there would be no requirement
    for this to happen.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，“全面匹配”的宝贵概念来自于F#的“一切都是表达式”的本质。在语句导向的语言中，不需要这样做。
- en: 'Here''s an example of an incomplete match:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不完整匹配的示例：
- en: '[PRE123]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The compiler will warn you if it thinks there is a missing branch. And if you
    deliberately ignore the warning, then you will get a nasty runtime error (`MatchFailureException`)
    when none of the patterns match.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器认为有一个缺失的分支，它会警告您。如果您故意忽略警告，那么当没有一个模式匹配时，您将收到一个讨厌的运行时错误（`MatchFailureException`）。
- en: Exhaustive matching is not perfect
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完全匹配并不完美
- en: The algorithm for checking that all possible matches are listed is good but
    not always perfect. Occasionally it will complain that you have not matched every
    possible case, when you know that you have. In this case, you may need to add
    an extra case just to keep the compiler happy.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 检查所有可能匹配是否已列出的算法很好但并不总是完美。偶尔它会抱怨你没有匹配到每种可能的情况，而你知道你已经匹配了。在这种情况下，您可能需要添加一个额外的情况，只是为了让编译器高兴。
- en: Using (and avoiding) the wildcard match
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用（和避免）通配符匹配
- en: 'One way to guarantee that you always match all cases is to put the wildcard
    parameter as the last match:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 保证始终匹配所有情况的一种方法是将通配符参数放在最后一个匹配中：
- en: '[PRE124]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: You see this pattern frequently, and I have used it a lot in these examples.
    It's the equivalent of having a catch-all `default` in a switch statement.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常看到这种模式，我在这些例子中也经常使用它。这相当于在switch语句中有一个全捕获的`default`。
- en: 'But if you want to get the full benefits of exhaustive pattern matching, I
    would encourage you *not* to use wildcards, and try to match all the cases explicitly
    if you can. This is particularly true if you are matching on the cases of a union
    type:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: By being always explicit in this way, you can trap any error caused by adding
    a new case to the union. If you had a wildcard match, you would never know.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: If you can't have *every* case be explicit, you might try to document your boundary
    conditions as much as possible, and assert an runtime error for the wildcard case.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Types of patterns
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lots of different ways of matching patterns, which we'll look at next.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the various patterns, see the [MSDN documentation](http://msdn.microsoft.com/en-us/library/dd547125%28v=vs.110%29).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Binding to values
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic pattern is to bind to a value as part of the match:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '*By the way, I have deliberately left this pattern (and others in this post)
    as incomplete. As an exercise, make them complete without using the wildcard.*'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the values that are bound *must* be distinct for
    each pattern. So you can''t do something like this:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Instead, you have to do something like this:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This second option can also be rewritten using "guards" (`when` clauses) instead.
    Guards will be discussed shortly.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: AND and OR
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can combine multiple patterns on one line, with OR logic and AND logic:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The OR logic is particularly common when matching a large number of union cases:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Matching on lists
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lists can be matched explicitly in the form `[x;y;z]` or in the "cons" form
    `head::tail`:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: A similar syntax is available for matching arrays exactly `[|x;y;z|]`.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that sequences (aka `IEnumerables`) can *not*
    be matched on this way directly, because they are "lazy" and meant to be accessed
    one element at a time. Lists and arrays, on the other hand, are fully available
    to be matched on.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: Of these patterns, the most common one is the "cons" pattern, often used in
    conjunction with recursion to loop through the elements of the list.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of looping through lists using recursion:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The second example shows how we can carry state from one iteration of the loop
    to the next using a special "accumulator" parameter (called `sumSoFar` in this
    example). This is a very common pattern.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Matching on tuples, records and unions
  id: totrans-605
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pattern matching is available for all the built-in F# types. More details in
    the [series on types](overview-of-types-in-fsharp).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Matching the whole and the part with the "as" keyword
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want to match the individual components of the value *and* also
    the whole thing. You can use the `as` keyword for this.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Matching on subtypes
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can match on subtypes, using the `:?` operator, which gives you a crude
    polymorphism:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This only works to find subclasses of a parent class (in this case, Object).
    The overall type of the expression has the parent class as input.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Note that in some cases, you may need to "box" the value.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The message tells you the problem: "runtime type tests are not allowed on some
    types". The answer is to "box" the value which forces it into a reference type,
    and then you can type check it:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: In my opinion, matching and dispatching on types is a code smell, just as it
    is in object-oriented programming. It is occasionally necessary, but used carelessly
    is an indication of poor design.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: In a good object oriented design, the correct approach would be to use [polymorphism
    to replace the subtype tests](http://sourcemaking.com/refactoring/replace-conditional-with-polymorphism),
    along with techniques such as [double dispatch](http://www.c2.com/cgi/wiki?DoubleDispatchExample).
    So if you are doing this kind of OO in F#, you should probably use those same
    techniques.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Matching on multiple values
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the patterns we've looked at so far do pattern matching on a *single* value.
    How can you do it for two or more?
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer is: you can''t. Matches are only allowed on single values.'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: But wait a minute -- could we combine two values into a *single* tuple on the
    fly and match on that? Yes, we can!
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: And indeed, this trick will work whenever you want to match on a set of values
    -- just group them all into a single tuple.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Guards, or the "when" clause
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes pattern matching is just not enough, as we saw in this example:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Pattern matching is based on patterns only -- it can't use functions or other
    kinds of conditional tests.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: But there *is* a way to do the equality test as part of the pattern match --
    using an additional `when` clause to the left of the function arrow. These clauses
    are known as "guards".
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the same logic written using a guard instead:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This is nicer, because we have integrated the test into the pattern proper,
    rather than using a test after the match has been done.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'Guards can be used for all sorts of things that pure patterns can''t be used
    for, such as:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: comparing the bound values
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: testing object properties
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: doing other kinds of matching, such as regular expressions
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: conditionals derived from functions
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at some examples of these:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Using active patterns instead of guards
  id: totrans-643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Guards are great for one-off matches. But if there are certain guards that you
    use over and over, consider using active patterns instead.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the email example above could be rewritten as follows:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: You can see other examples of active patterns in a [previous post](convenience-active-patterns).
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: The "function" keyword
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples so far, we''ve seen a lot of this:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: In the special case of function definitions we can simplify this dramatically
    by using the `function` keyword.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: As you can see, the `aValue` parameter has completely disappeared, along with
    the `match..with`.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: This keyword is *not* the same as the `fun` keyword for standard lambdas, rather
    it combines `fun` and `match..with` in a single step.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: 'The `function` keyword works anywhere a function definition or lambda can be
    used, such as nested matches:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'or lambdas passed to a higher order function:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: A minor drawback of `function` compared with `match..with` is that you can't
    see the original input value and have to rely on value bindings in the pattern.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling with try..with
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [previous post](exceptions), we looked at catching exceptions with the
    `try..with` expression.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The `try..with` expression implements pattern matching in the same way as `match..with`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: So in the above example we see the use of matching on a custom pattern
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '`| Failure msg` is an example of matching on (what looks like) an active pattern'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| :? System.InvalidOperationException as ex` is an example of matching on
    the subtype (with the use of `as` as well).'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because the `try..with` expression implements full pattern matching, we can
    also use guards as well, if needed to add extra conditional logic:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Wrapping match expressions with functions
  id: totrans-669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Match expressions are very useful, but can lead to complex code if not used
    carefully.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: The main problem is that match expressions doesn't compose very well. That is,
    it is hard to chain `match..with` expressions and build simple ones into complex
    ones.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: The best way of avoiding this is to wrap `match..with` expressions into functions,
    which can then be composed nicely.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Here's a simple example. The `match x with 42` is wrapped in a `isAnswerToEverything`
    function.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Library functions to replace explicit matching
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most built-in F# types have such functions already available.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: For example, instead of using recursion to loop through lists, you should try
    to use the functions in the `List` module, which will do almost everything you
    need.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the function we wrote earlier:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: can be rewritten using the `List` module in at least three different ways!
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Similarly, the Option type (discussed at length in [this post](the-option-type))
    has an associated `Option` module with many useful functions.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a function that does a match on `Some` vs `None` can be replaced
    with `Option.map`:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Creating "fold" functions to hide matching logic
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, if you create your own types which need to be frequently matched, it
    is good practice to create a corresponding generic "fold" function that wraps
    it nicely.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is a type for defining temperature.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Chances are, we will matching these cases a lot, so let's create a generic function
    that will do the matching for us.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'All `fold` functions follow this same general pattern:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: there is one function for each case in the union structure (or clause in the
    match pattern)
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: finally, the actual value to match on comes last. (Why? See the post on ["designing
    functions for partial application"](partial-application))
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have our fold function, we can use it in different contexts.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by testing for a fever. We need a function for testing degrees F
    for fever and another one for testing degrees C for fever.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: And then we combine them both using the fold function.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: And now we can test.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: For a completely different use, let's write a temperature conversion utility.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: Again we start by writing the functions for each case, and then combine them.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Note that the conversion functions wrap the converted values in a new `TemperatureType`,
    so the `convert` function has the signature:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: And now we can test.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: We can even call convert twice in a row, and we should get back the same temperature
    that we started with!
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: There will be much more discussion on folds in the upcoming series on recursion
    and recursive types.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: Formatted text using printf
  id: totrans-710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Formatted text using printf
  id: totrans-711
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we'll take a small detour and look at how to create formatted
    text. The printing and formatting functions are technically library functions,
    but in practice they as used as if they were part of the core language.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: 'F# supports two distinct styles of formatting text:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: The standard .NET technique of ["composite formatting"](http://msdn.microsoft.com/en-us/library/txafckwd.aspx)
    as seen in `String.Format`, `Console.WriteLine` and other places.
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C-style technique of using `printf` and the [associated family of functions](http://msdn.microsoft.com/en-us/library/ee370560)
    such as `printfn`, `sprintf` and so on.
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String.Format vs printf
  id: totrans-716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composite formatting technique is available in all .NET languages, and you
    are probably familiar with it from C#.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The `printf` technique, on the other hand, is based on the C-style format strings:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: As you have seen, the `printf` technique is very common in F#, while `String.Format`,
    `Console.Write` and so on, are rarely used.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is `printf` preferred and considered idiomatic for F#? The reasons are:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: It is statically type checked.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a well-behaved F# function and so supports partial application, etc.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports native F# types.
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: printf is statically type checked
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike `String.Format`, `printf` is *statically type checked*, both for the
    types of the parameters, and the number.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are two snippets using `printf` that will fail to compile:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The equivalent code using composite formatting will compile fine but either
    work incorrectly but silently, or give a runtime error:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: printf supports partial application
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The .NET formatting functions require all parameters to be passed in *at the
    same time*.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: But `printf` is a standard, well-behaved F# function, and so supports [partial
    application](partial-application).
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: And of course, `printf` can be used for function parameters anywhere a standard
    function can be used.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'This also includes the higher order functions for lists, etc:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: printf supports native F# types
  id: totrans-741
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For non-primitive types, the .NET formatting functions only support using `ToString()`,
    but `printf` supports native F# types using the `%A` specifier:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: As you can see, tuple types have a nice `ToString()` but other user defined
    types don't, so if you want to use them with the .NET formatting functions, you
    will have to override the `ToString()` method explicitly.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: printf gotchas
  id: totrans-745
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of "gotchas" to be aware of when using `printf`.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: First, if there are *too few* parameters, rather than too many, the compiler
    will *not* complain immediately, but might give cryptic errors later.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The reason, of course, is that this is not an error at all; `printf` is just
    being partially applied! See the [discussion of partial application](partial-application)
    if you are not clear of why this happens.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that the "format strings" are not actually strings.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'In the .NET formatting model, the formatting strings are normal strings, so
    you can pass them around, store them in resource files, and so on. Which means
    that the following code works fine:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'On the other hand, the "format strings" that are the first argument to `printf`
    are not really strings at all, but something called a `TextWriterFormat`. Which
    means that the following code does **not** work:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The compiler does some magic behind the scenes to convert the string constant
    `"A string: %s"` into the appropriate TextWriterFormat. The TextWriterFormat is
    the key component that "knows" the type of the format string, such as `string->unit`
    or `string->int->unit`, which in turn allows `printf` to be typesafe.'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: If you want to emulate the compiler, you can create your own TextWriterFormat
    value from a string using the `Printf.TextWriterFormat` type in the `Microsoft.FSharp.Core.Printf`
    module.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'If the format string is "inline", the compiler can deduce the type for you
    during binding:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: But if the format string is truly dynamic (e.g. stored in a resource or created
    on the fly), the compiler cannot deduce the type for you, and you must explicitly
    provide it with the constructor.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, my first format string has a single string parameter and
    returns a unit, so I have to specify `string->unit` as the format type. And in
    the second case, I have to specify `string->int->unit` as the format type.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: I won't go into detail on exactly how `printf and`TextWriterFormat` work together
    right now -- just be aware that is not just a matter of simple format strings
    being passed around.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's worth noting that `printf` and family are *not* thread-safe, while
    `Console.Write` and family *are*.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: How to specify a format
  id: totrans-764
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "%" format specifications are quite similar to those used in C, but with
    some special customizations for F#.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: As with C, the characters immediately following the `%` have a specific meaning,
    as shown below.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: We'll discuss each of these attributes in more detail below.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: Formatting for dummies
  id: totrans-769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most commonly used format specifiers are:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '`%s` for strings'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%b` for bools'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%i` for ints'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%f` for floats'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%A` for pretty-printing tuples, records and union types'
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%O` for other objects, using `ToString()`'
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These six will probably meet most of your basic needs.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: Escaping %
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `%` character on its own will cause an error. To escape it, just double
    it up:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Controlling width and alignment
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When formatting fixed width columns and tables, you need to have control of
    the alignment and width.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: You can do that with the "width" and "flags" options.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '`%5s`, `%5i`. A number sets the width of the value'
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%*s`, `%*i`. A star sets the width of the value dynamically (from an extra
    parameter just before the param to format)'
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%-s`, `%-i`. A hyphen left justifies the value.'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of these in use:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Formatting integers
  id: totrans-789
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some special options for basic integer types:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '`%i` or `%d` for signed ints'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%u` for unsigned ints'
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%x` and `%X` for lowercase and uppercase hex'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%o` for octal'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The specifiers do not enforce any type safety within the integer types. As you
    can see from the examples above, you can pass a signed int to an unsigned specifier
    without problems. What is different is how it is formatted. The unsigned specifiers
    treat the int as unsigned no matter how it is actually typed.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Note that `BigInteger` is *not* a basic integer type, so you must format it
    with `%A` or `%O`.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'You can control the formatting of signs and zero padding using the flags:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '`%0i` pads with zeros'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%+i` shows a plus sign'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`% i` shows a blank in place of a plus sign'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Formatting floats and decimals
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For floating point types, there are also some special options:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '`%f` for standard format'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%e` or `%E` for exponential format'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%g` or `%G` for the more compact of `f` and `e`.'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%M` for decimals'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The decimal type can be used with the floating point specifiers, but you might
    lose some precision. The `%M` specifier can be used to ensure that no precision
    is lost. You can see the difference with this example:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'You can control the precision of floats using a precision specification, such
    as `%.2f` and `%.4f`. For the `%f` and `%e` specifiers, the precision affects
    the number of digits after the decimal point, while for `%g` it is the number
    of digits in total. Here''s an example:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: The alignment and width flags work for floats and decimals as well.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Custom formatting functions
  id: totrans-820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two special format specifiers that allow to you pass in a function
    rather than just a simple value.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '`%t` expects a function that outputs some text with no input'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%a` expects a function that outputs some text from a given input'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of using `%t`:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Obviously, since the callback function takes no parameters, it will probably
    be a closure that does reference some other value. Here''s an example that prints
    random numbers:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: For the `%a` specifier, the callback function takes an extra parameter. That
    is, when using the `%a` specifier, you must pass in both a function and a value
    to format.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of custom formatting a tuple:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Date formatting
  id: totrans-831
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no special format specifiers for dates in F#.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to format dates, you have a couple of options:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: Use `ToString` to convert the date into a string, and then use the `%s` specifier
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a custom callback function with the `%a` specifier as described above
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the two approaches in use:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Which approach is better?
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: The `ToString` with `%s` is easier to test and use, but it will be less efficient
    than writing directly to a TextWriter.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: The printf family of functions
  id: totrans-840
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of variants of `printf` functions. Here is a quick guide:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '| F# function | C# equivalent | Comment |'
  id: totrans-842
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-843
  prefs: []
  type: TYPE_TB
- en: '| `printf` and `printfn` | `Console.Write` and `Console.WriteLine` | Functions
    starting with "print" write to standard out. |'
  id: totrans-844
  prefs: []
  type: TYPE_TB
- en: '| `eprintf` and `eprintfn` | `Console.Error.Write` and `Console.Error.WriteLine`
    | Functions starting with "eprint" write to standard error. |'
  id: totrans-845
  prefs: []
  type: TYPE_TB
- en: '| `fprintf` and `fprintfn` | `TextWriter.Write` and `TextWriter.WriteLine`
    | Functions starting with "fprint" write to a TextWriter. |'
  id: totrans-846
  prefs: []
  type: TYPE_TB
- en: '| `sprintf` | `String.Format` | Functions starting with "sprint" return a string.
    |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
- en: '| `bprintf` | `StringBuilder.AppendFormat` | Functions starting with "bprint"
    write to a StringBuilder. |'
  id: totrans-848
  prefs: []
  type: TYPE_TB
- en: '| `kprintf`, `kfprintf`, `ksprintf` and `kbprintf` | No equivalent | Functions
    that accept a continuation. See next section for a discussion. |'
  id: totrans-849
  prefs: []
  type: TYPE_TB
- en: '*All of these except `bprintf` and the `kXXX` family are automatically available
    (via [Microsoft.FSharp.Core.ExtraTopLevelOperators](http://msdn.microsoft.com/en-us/library/ee370230)).
    But if you need to access them using a module, they are in the [`Printf` module](http://msdn.microsoft.com/en-us/library/ee370560).*'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: The usage of these should be obvious (except for the `kXXX` family, of which
    more below).
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: A particularly useful technique is to use partial application to "bake in" a
    TextWriter or StringBuilder.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using a StringBuilder:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'And here is an example using a TextWriter:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: More on partially applying printf
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in both cases above, we had to pass a format parameter when creating
    the partial application.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we had to do:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'rather than the point-free version:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: This stops the compiler complaining about an incorrect type. The reason why
    is non-obvious. We briefly mentioned the `TextWriterFormat` above as the first
    parameter to `printf`. It turns out that `printf` is not actually a particular
    function, like `String.Format`, but rather a generic function that has to be parameterized
    with a TextWriterFormat (or the similar StringFormat) in order to become "real".
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: So, to be safe, it is best to always pair a `printf` with a format parameter,
    rather than being overly aggressive with the partial application.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: The kprintf functions
  id: totrans-865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The four `kXXX` functions are similar to their cousins, except that they take
    an extra parameter -- a continuation. That is, a function to be called immediately
    after the formatting has been done.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple snippet:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Why would you want this? A number of reasons:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: You can pass the result to another function that does something useful, such
    as a logging framework
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can do things such as flushing the TextWriter
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can raise an event
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at a sample that uses a external logging framework plus custom events.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create a simple logging class along the lines of log4net or System.Diagnostics.Trace.
    In practice, this would be replaced by a real third-party library.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Next in my application code, I do the following:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the logging framework. I've hard-coded the factory method
    here, but you could also use an IoC container.
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create helper functions called `logInfo` and `logError` that call the logging
    framework, and in the case of `logError`, show a popup message as well.
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Finally, when we run the `test` function, we should get the message written
    to the console, and also see the popup message:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: You could also create an object-oriented version of the helper methods by creating
    a "FormattingLogger" wrapper class around the logging library, as shown below.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: The object-oriented approach, although more familiar, is not automatically better!
    The pros and cons of OO methods vs. pure functions are discussed [here](type-extensions.html#downsides-of-methods).
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: 'Worked example: Parsing command line arguments'
  id: totrans-885
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Worked example: Parsing command line arguments'
  id: totrans-886
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen how the match expression works, let's look at some examples
    in practice. But first, a word about the design approach.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: Application design in F#
  id: totrans-888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that a generic function takes input and emits output. But in a sense,
    that approach applies at *any* level of functional code, even at the top level.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we can say that a functional *application* takes input, transforms
    it, and emits output:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '![](function_transform1.png)'
  id: totrans-891
  prefs: []
  type: TYPE_IMG
- en: Now ideally, the transformations work within the pure type-safe world that we
    create to model the domain, but unfortunately, the real world is untyped! That
    is, the input is likely to be simple strings or bytes, and the output also.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: How can we work with this? The obvious solution is to have a separate stage
    to convert the input to our pure internal model, and then another separate stage
    to convert from the internal model to the output.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '![](function_transform2.png)'
  id: totrans-894
  prefs: []
  type: TYPE_IMG
- en: In this way, we can hide the messiness of the real world from the core of the
    application. This "keep your model pure" approach is similar to the ["Hexagonal
    Architecture"](http://alistair.cockburn.us/Hexagonal+architecture) concept in
    the large, or the MVC pattern in the small.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: In this post and the [next](roman-numerals), we'll see some simple examples
    of this.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: parsing a command line'
  id: totrans-897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about the match expression in general in the [previous post](match-expression),
    so let's look at a real example where it is useful, namely parsing a command line.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: We'll design and implement two slightly different versions, one with a basic
    internal model, and second one with some improvements.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  id: totrans-900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s say that we have three commandline options: "verbose", "subdirectories",
    and "orderby". "Verbose" and "subdirectories" are flags, while "orderby" has two
    choices: "by size" and "by name".'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: So the command line params would look like
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: First version
  id: totrans-904
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the design rule above, we can see that:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: the input will be an array (or list) of strings, one for each argument.
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the internal model will be a set of types that model the (tiny) domain.
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the output is out of scope in this example.
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So we'll start by first creating the internal model of the parameters, and then
    look at how we can parse the input into types used in the internal model.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a first stab at the model:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Ok, that looks alright. Now let's parse the arguments.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: The parsing logic is very similar to the `loopAndSum` example in the previous
    post.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: We create a recursive loop on the list of arguments.
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time through the loop, we parse one argument.
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The options parsed so far are passed into each loop as a parameter (the "accumulator"
    pattern).
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: This code is straightforward, I hope.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: Each match consist of a `option::restOfList` pattern. If the option is matched,
    a new `optionsSoFar` value is created and the loop repeats with the remaining
    list, until the list becomes empty, at which point we can exit the loop and return
    the `optionsSoFar` value as the final result.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two special cases:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: Matching the "orderBy" option creates a submatch pattern that looks at the first
    item in the rest of the list and if not found, complains about a missing second
    parameter.
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The very last match on the main `match..with` is not a wildcard, but a "bind
    to value". Just like a wildcard, this will always succeed, but because we havd
    bound to the value, it allows us to print the offending unmatched argument.
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that for printing errors, we use `eprintf` rather than `printf`. This will
    write to STDERR rather than STDOUT.
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So now let''s test this:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Oops! That didn''t work -- we need to pass in an initial `optionsSoFar` argument!
    Lets try again:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Check that the output is what you would expect.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: 'And we should also check the error cases:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: You should see the error messages in these cases now.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish this implementation, let's fix something annoying. We are passing
    in these default options every time -- can we get rid of them?
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very common situation: you have a recursive function that takes a
    "accumulator" parameter, but you don''t want to be passing initial values all
    the time.'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple: just create another function that calls the recursive
    function with the defaults.'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, this second one is the "public" one and the recursive one is hidden,
    so we will rewrite the code as follows:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: Rename `parseCommandLine` to `parseCommandLineRec`. There are other naming conventions
    you could use as well, such as `parseCommandLine'` with a tick mark, or `innerParseCommandLine`.
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new `parseCommandLine` that calls `parseCommandLineRec` with the defaults
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: In this case the helper function can stand on its own. But if you really want
    to hide it, you can put it as a nested subfunction in the defintion of `parseCommandLine`
    itself.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: In this case, I think it would just make things more complicated, so I have
    kept them separate.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is all the code at once, wrapped in a module:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Second version
  id: totrans-944
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our initial model we used bool and string to represent the possible values.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'There are two problems with this:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '**It doesn''t *really* represent the domain.** For example, can `orderby` really
    be *any* string? Would my code break if I set it to "ABC"?'
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The values are not self documenting.** For example, the verbose value is
    a bool. We only know that the bool represents the "verbose" option because of
    the *context* (the field named `verbose`) it is found in. If we passed that bool
    around, and took it out of context, we would not know what it represented. I''m
    sure we have all seen C# functions with many boolean parameters like this:'
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: Because the bool doesn't represent anything at the domain level, it is very
    easy to make mistakes.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: The solution to both these problems is to be as specific as possible when defining
    the domain, typically by creating lots of very specific types.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s a new version of `CommandLineOptions`:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'A couple of things to notice:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: There are no bools or strings anywhere.
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names are quite explicit. This acts as documentation when a value is taken
    in isolation, but also means that the name is unique, which helps type inference,
    which in turn helps you avoid explicit type annotations.
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have made the changes to the domain, it is easy to fix up the parsing
    logic.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is all the revised code, wrapped in a "v2" module:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Using fold instead of recursion?
  id: totrans-961
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said in the previous post that it is good to avoid recursion where possible
    and use the built in functions in the `List` module like `map` and `fold`.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: So can we take this advice here and fix up this code to do this?
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, not easily. The problem is that the list functions generally
    work on one element at a time, while the "orderby" option requires a "lookahead"
    argument as well.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: To make this work with something like `fold`, we need to create a "parse mode"
    flag to indicate whether we are in lookahead mode or not. This is possible, but
    I think it just adds extra complexity compared to the straightforward recursive
    version above.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: And in a real-world situation, anything more complicated than this would be
    a signal that you need to switch to a proper parsing system such as [FParsec](http://www.quanttec.com/fparsec/).
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: 'However, just to show you it can be done with `fold`:'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: By the way, can you see a subtle change of behavior in this version?
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: In the previous versions, if there was no parameter to the "orderBy" option,
    the recursive loop would still parse it next time. But in the 'fold' version,
    this token is swallowed and lost.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this, compare the two implementations:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: To fix this would be even more work. Again this argues for the second implementation
    as the easiest to debug and maintain.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-974
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post we've seen how to apply pattern matching to a real-world example.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we've seen how easy it is to create a properly designed internal
    model for even the smallest domain. And that this internal model provides more
    type safety and documentation than using primitive types such as string and bool.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we'll do even more pattern matching!
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: 'Worked example: Roman numerals'
  id: totrans-978
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Worked example: Roman numerals'
  id: totrans-979
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Last time](pattern-matching-command-line) we looked at parsing a command line.
    This time we''ll we''ll look at another pattern matching example, this time using
    Roman numerals.'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: As before, we will try to have a "pure" internal model with separate stages
    to convert the input to the internal model, and then another separate stage to
    convert from the internal model to the output.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '![](function_transform2.png)'
  id: totrans-982
  prefs: []
  type: TYPE_IMG
- en: Requirements
  id: totrans-983
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the requirements:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-985
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: First version
  id: totrans-986
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before we'll start by first creating the internal model, and then look at
    how we can parse the input into the internal model.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: Here's a first stab at the model. We'll treat a `RomanNumeral` as a list of
    `RomanDigits`.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: No, stop right there! A `RomanDigit` is not just *any* digit, it has to be taken
    from a limited set.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: Also `RomanNumeral` should not just be a [type alias](type-abbreviations) for
    a list of digits. It would be better if it was its own special type as well. We
    can do this by creating a [single case union type](discriminated-unions).
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a much better version:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Output: Converting a numeral to an int'
  id: totrans-994
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's do the output logic, converting a Roman numeral to an int.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: 'The digit conversion is easy:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Note that we're using the `function` keyword instead of the `match..with` expression.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: To convert a list of digits, we'll use a recursive loop again. There is a special
    case when we need to look ahead to the next digit, and if it is larger than the
    current one, then use their difference.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-1000
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '*Note that the "less than" operation did not have to be defined. The types
    are automatically sorted by their order of declaration.*'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can convert the `RomanNumeral` type itself by unpacking the contents
    into a list and calling `digitsToInt`.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: That takes care of the output.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: Converting a string to an Roman Numeral'
  id: totrans-1005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's do the input logic, converting a string to our internal model.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: First, let's handle a single character conversion. It seems straightforward.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: The compiler doesn't like that! What happens if we get some other character?
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: This is a great example of how [exhaustive pattern matching](correctness-exhaustive-pattern-matching)
    can force you to think about missing requirements.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: So, what should be done for bad input. How about printing an error message?
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try again and add a case to handle all other characters:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: The compiler doesn't like that either! The normal cases return a valid `RomanDigit`
    but the error case returns `unit`. As we saw in the [earlier post](pattern-matching),
    every branch *must* return the same type.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: How can we fix this? We could throw an exception, but that seems a bit excessive.
    If we think about it some more, there's no way that `charToRomanDigit` can *always*
    return a valid `RomanDigit`. Sometimes it can, and sometimes it can't. In other
    words, we need to use something like an option type here.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: But on further consideration, we might also want the caller to know what the
    bad char was. So we need to create our own little variant on the option type to
    hold both cases.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the fixed up version:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Note that I have removed the error message. Since the bad char is being returned,
    the caller can print its own message for the `BadChar` case.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should check the function signature to make sure it is what we expect:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: That looks good.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can we convert a string into these digits? We convert the string to
    a char array, convert that into a list, and then do a final conversion using `charToRomanDigit`.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'But the compiler complains again with "FS0072: Lookup on object of indeterminate
    type",'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: That typically happens when you use a method rather than a function. Any object
    could implement `.ToCharArray()` so the type inference cannot tell what type is
    meant.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the solution is just to use an explicit type annotation on the
    parameter -- our first so far!
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'But look at the signature:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: It still has the pesky `ParsedChar` in it rather than `RomanDigits`. How do
    we want to proceed? Answer, let's pass the buck again and let someone else deal
    with it!
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '"Passing the buck" in this case is actually a good design principle. This function
    doesn''t know what its clients might want to do -- some might want to ignore errors,
    while others might want to fail fast. So just pass back the information and let
    them decide.'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the client is the top level function that creates a `RomanNumeral`
    type. Here''s our first attempt:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: The compiler is not happy -- the `RomanNumeral` constructor requires a list
    of `RomanDigits`, but the `toRomanDigitList` is giving us a list of `ParsedChars`
    instead.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: Now we finally *do* have to commit to an error handling policy. Let's choose
    to ignore bad chars, but print out errors when they occur. We'll use the `List.choose`
    function for this. It's similar to `List.map`, but in addition has a filter built
    into it. Elements that are valid (`Some something`) are returned, but elements
    that are `None` are filtered out.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: 'Our choose function should thus do the following:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: For valid digits return `Some digit`
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the invalid `BadChars`, print the error message and return `None`.
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we do this, the output of `List.choose` will be a list of `RomanDigits`,
    exactly as needed as the input to the `RomanNumeral` constructor.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is everything put together:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Let's test!
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Ok, everything is good so far. Let's move on to validation.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: Validation rules
  id: totrans-1046
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The validation rules were not listed in the requirements, so let''s put down
    our best guess based on what we know about Roman numerals:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: Five in a row of any digit is not allowed
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some digits are allowed in runs of up to 4\. They are I,X,C, and M. The others
    (V,L,D) can only appear singly.
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some lower digits can come before a higher digit, but only if they appear singly.
    E.g. "IX" is ok but "IIIX" is not.
  id: totrans-1050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But this is only for pairs of digits. Three ascending numbers in a row is invalid.
    E.g. "IX" is ok but "IXC" is not.
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single digit with no runs is always allowed
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can convert these requirements into a pattern matching function as follows:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-1054
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '*Again, note that "equality" and "less than" did not need to be defined.*'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 'And let''s test the validation:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Finally, we add a top level function to test validity of the `RomanNumeral`
    type itself.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The entire code for the first version
  id: totrans-1060
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s all the code in one module:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Second version
  id: totrans-1063
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code works, but there is something that's bugging me about it. The validation
    logic seems very complicated. Surely the Romans didn't have to think about all
    of this?
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: 'And also, I can think of examples that should fail validation, but pass, such
    as "VIV":'
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-1066
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: We could try to tighten up our validation rules, but let's try another tack.
    Complicated logic is often a sign that you don't quite understand the domain properly.
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: In other words -- could we change the internal model to make everything simpler?
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: What about if we stopped trying to map letters to digits, and created a domain
    that mapped how the Romans thought it. In this model "I", "II", "III", "IV" and
    so on would each be a separate digit.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: Let's run with it and see what happens.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: Here's the new types for the domain. I now have a digit type for every possible
    digit. The `RomanNumeral` type stays the same.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'Output: second version'
  id: totrans-1073
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, converting a single `RomanDigit` to an integer is the same as before,
    but with more cases:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Calculating the sum of the digits is now trivial. No special cases needed:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Finally, the top level function is identical:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'Input: second version'
  id: totrans-1080
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the input parsing, we'll keep the `ParsedChar` type. But this time, we have
    to match 1,2,3, or 4 chars at a time. That means we can't just pull off one character
    like we did in the first version -- we have to match in the main loop. This means
    the loop now has to be recursive.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: Also, we want to convert IIII into a single `IIII` digit rather than 4 separate
    `I` digits, so we put the longest matches at the front.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Well, this is much longer than the first version, but otherwise basically the
    same.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: The top level functions are unchanged.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-1086
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'Validation: second version'
  id: totrans-1087
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let's see how the new domain model affects the validation rules. Now,
    the rules are *much* simpler. In fact, there is only one.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: Each digit must be smaller than the preceding digit
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Alas, after all that, we still didn't fix the bad case that triggered the rewrite!
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: There is a not-too-complicated fix for this, but I think it's time to leave
    it alone now!
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: The entire code for the second version
  id: totrans-1094
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s all the code in one module for the second version:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Comparing the two versions
  id: totrans-1097
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which version did you like better? The second one is more longwinded because
    it has many more cases, but on the other hand, the actual logic is the same or
    simpler in all areas, with no special cases. And as a result, the total number
    of lines of code is about the same for both versions.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: Overall, I prefer the second implementation because of the lack of special cases.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: As a fun experiment, try writing the same code in C# or your favorite imperative
    language!
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: Making it object-oriented
  id: totrans-1101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s see how we might make this object oriented. We don''t care
    about the helper functions, so we probably just need three methods:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: A static constructor
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to convert to a int
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to convert to a string
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here they are:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '*Note: you can ignore the compiler warning about deprecated overrides.*'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this in an object oriented way now:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Summary
  id: totrans-1111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post we've seen lots and lots of pattern matching!
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: But again, as with the last post, what's equally important is that we've seen
    how easy it is to create a properly designed internal model for very trivial domains.
    And again, our internal model used no primitive types -- there is no excuse not
    to create lots of little types in order to represent the domain better. For example,
    the `ParsedChar` type -- would you have bothered to create that in C#?
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: And as should be clear, the choice of an internal model can make a lot of difference
    to the complexity of the design. But if and when we do refactor, the compiler
    will almost always warn us if we have forgotten something.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
