- en: The "Expressions and syntax" Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this series of posts we'll look at how functions and values are combined
    into expressions, and the different kinds of expressions that are available in
    F#.
  prefs: []
  type: TYPE_NORMAL
- en: '[Expressions and syntax: Introduction](expressions-intro.html). How to code
    in F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Expressions vs. statements](expressions-vs-statements.html). Why expressions
    are safer and make better building blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Overview of F# expressions](understanding-fsharp-expressions.html). Control
    flows, lets, dos, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Binding with let, use, and do](let-use-do.html). How to use them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[F# syntax: indentation and verbosity](fsharp-syntax.html). Understanding the
    offside rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parameter and value naming conventions](naming-conventions.html). a, f, x
    and friends.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Control flow expressions](control-flow-expressions.html). And how to avoid
    using them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exceptions](exceptions.html). Syntax for throwing and catching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Match expressions](match-expression.html). The workhorse of F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Formatted text using printf](printf.html). Tips and techniques for printing
    and logging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Worked example: Parsing command line arguments](pattern-matching-command-line.html).
    Pattern matching in practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Worked example: Roman numerals](roman-numerals.html). More pattern matching
    in practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Expressions and syntax: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Expressions and syntax: Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*NOTE: Before reading this series, I suggest that you read the ["thinking functionally"](thinking-functionally.html)
    series as a prerequisite.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this series we'll look at how functions and values are combined into expressions,
    and the different kinds of expressions that are available in F#.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at some other basic topics, such as `let` bindings, F# syntax,
    pattern matching, and outputting text with `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: This series is not meant to be exhaustive or definitive. Much of the syntax
    and usage of F# should be obvious from the examples, and the MSDN documentation
    has all the details if you need them. Rather we will just focus on explaining
    some of the essential areas that might be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: So, we'll start with some general tips, talk about how `let` bindings work,
    and explain the indentation rules.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the next few posts will cover `match..with` expressions, the imperative
    control flow expressions, and exception expressions. Computation expressions and
    object-oriented expressions will be left to later series.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll finish with some worked examples that use pattern matching as
    an integral part of their design.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions vs. statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expressions vs. statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming language terminology, an "expression" is a combination of values
    and functions that are combined and interpreted by the compiler to create a new
    value, as opposed to a "statement" which is just a standalone unit of execution
    and doesn't return anything. One way to think of this is that the purpose of an
    expression is to create a value (with some possible side-effects), while the sole
    purpose of a statement is to have side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: C# and most imperative languages make a distinction between expressions and
    statements and have rules about where each kind can be used. But as should be
    apparent, a truly pure functional language cannot support statements at all, because
    in a truly pure language, there would be no side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: Even though F# is not pure, it does follow the same principle. In F# everything
    is an expression. Not just values and functions, but also control flows (such
    as if-then-else and loops), pattern matching, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are some subtle benefits to using expressions over statements. First,
    unlike statements, smaller expressions can be combined (or "composed") into larger
    expressions. So if everything is an expression, then everything is also composable.
  prefs: []
  type: TYPE_NORMAL
- en: Second, a series of statements always implies a specific order of evaluation,
    which means that a statement cannot be understood without looking at prior statements.
    But with pure expressions, the subexpressions do not have any implied order of
    execution or dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: So in the expression `a+b`, if both the '`a`' and '`b`' parts are pure, then
    the '`a`' part can be isolated, understood, tested and evaluated on its own, as
    can the '`b`' part.
  prefs: []
  type: TYPE_NORMAL
- en: This "isolatibility" of expressions is another beneficial aspect of functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the F# interactive window also relies on everything being an expression.
    It would be much harder to use a C# interactive window.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions are safer and more compact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using expressions consistently leads to code that is both safer and more compact.
    Let's see what I mean by this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at a statement based approach. Statements don''t return
    values, so you have to use temporary variables that are assigned to from within
    statement bodies. Here are some examples using a C-like language (OK, C#) rather
    than F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the "if-then" is a statement, the `result` variable must be defined
    *outside* the statement and but assigned to *inside* the statement, which leads
    to some issues:'
  prefs: []
  type: TYPE_NORMAL
- en: The `result` variable has to be set up outside the statement itself. What initial
    value should it be set to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if I forget to assign to the `result` variable in the `if` statement? The
    purpose of the "if "statement is purely to have side effects (the assignment to
    the variables). This means that the statements are potentially buggy, because
    it would be easy to forget to do an assignment in one branch. And because the
    assignment was just a side effect, the compiler could not offer any warning. Since
    the `result` variable has already been defined in scope, I could easily use it,
    unaware that it was invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the value of the `result` variable in the "else" case? In this case,
    I haven't specified a value. Did I forget? Is this a potential bug?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the reliance on side-effects to get things done means that the statements
    are not easily usable in another context (for example, extracted for refactoring,
    or parallelizing) because they have a dependency on a variable that is not part
    of the statement itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: the code above will not compile in C# because the compiler will complain
    if you use an unassigned local variable like this. But having to define *some*
    default value for `result` before it is even used is still a problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For comparison, here is the same code, rewritten in an expression-oriented
    style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the expression-oriented version, none of the earlier issues even apply!
  prefs: []
  type: TYPE_NORMAL
- en: The `result` variable is declared at the same time that it is assigned. No variables
    have to be set up "outside" the expression and there is no worry about what initial
    value they should be set to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The "else" is explicitly handled. There is no chance of forgetting to do an
    assignment in one of the branches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And I cannot possibly forget to assign to `result`, because then the variable
    would not even exist!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In F#, the two examples would be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The "`mutable`" keyword is considered a code smell in F#, and is discouraged
    except in certain special cases. It should be avoided at all cost while you are
    learning!
  prefs: []
  type: TYPE_NORMAL
- en: In the expression based version, the mutable variable has been eliminated and
    there is no reassignment anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the `if` statement converted into an expression, it is now trivial
    to refactor it and move the entire subexpression to a different context without
    introducing errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the refactored version in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Statements vs. expressions for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Going back to C# again, here is a similar example of statements vs. expressions
    using a loop statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve used an old-style "for" statement, where the index variables are declared
    outside the loop. Many of the issues discussed earlier apply to the loop index
    "`i`" and the max value "`length`", such as: can they be used outside the loop?
    And what happens if they are not assigned to?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A more modern version of a for-loop addresses these issues by declaring and
    assigning the loop variables in the "for" loop itself, and by requiring the "`sum`"
    variable to be initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This more modern version follows the general principle of combining the declaration
    of a local variable with its first assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'But of course, we can keep improving by using a `foreach` loop instead of a
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each time, not only are we condensing the code, but we are reducing the likelihood
    of errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'But taking that principle to its logical conclusion leads to a completely expression
    based approach! Here''s how it might be done using LINQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that I could have used LINQ's built-in "sum" function, but I used `Aggregate`
    in order to show how the sum logic embedded in a statement can be converted into
    a lambda and used as part of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: In the next post, we'll look at the various kinds of expressions in F#.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of F# expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview of F# expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post we'll look at the different kinds of expressions that are available
    in F# and some general tips for using them.
  prefs: []
  type: TYPE_NORMAL
- en: Is everything really an expression?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be wondering how "everything is an expression" actually works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some basic expression examples that should be familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: No problems there. Those are obviously expressions.
  prefs: []
  type: TYPE_NORMAL
- en: But here are some more complex things which are *also* expressions. That is,
    each of these returns a value that can be used for something else.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In other languages, these might be statements, but in F# they really do return
    values, as you can see by binding a value to the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What kinds of expressions are there?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lots of diffent kinds of expressions in F#, about 50 currently. Most
    of them are trivial and obvious, such as literals, operators, function application,
    "dotting into", and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The more interesting and high-level ones can be grouped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Control flow" expressions, including:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The match expression (with the `match..with` syntax)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions related to imperative control flow, such as if-then-else, loops
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception-related expressions
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '"let" and "use" expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computation expressions such as `async {..}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions related to object-oriented code, including casts, interfaces, etc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already discussed lambdas in the ["thinking functionally"](thinking-functionally.html)
    series, and as noted earlier, computation expressions and object-oriented expressions
    will be left to later series.
  prefs: []
  type: TYPE_NORMAL
- en: So, in upcoming posts in this series, we will focus on "control flow" expressions
    and "let" expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '"Control flow" expressions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In imperative languages, control flow expressions like if-then-else, for-in-do,
    and match-with are normally implemented as statements with side-effects, In F#,
    they are all implemented as just another type of expression.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, it is not even helpful to think of "control flow" in a functional language;
    the concept doesn't really exist. Better to just think of the program as a giant
    expression containing sub-expressions, some of which are evaluated and some of
    which are not. If you can get your head around this way of thinking, you have
    a good start on thinking functionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'There will be some upcoming posts on these different types of control flow
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The match expression](match-expression)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Imperative control flow: if-then-else and for loops](control-flow-expressions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Exceptions](exceptions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"let" bindings as expressions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What about `let x=something`? In the examples above we saw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How can "`let`" be an expression? The reason will be discussed in the next post
    on ["let", "use" and "do"](let-use-do).
  prefs: []
  type: TYPE_NORMAL
- en: General tips for using expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But before we cover the important expression types in details, here are some
    tips for using expressions in general.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple expressions on one line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, each expression is put on a new line. But you can use a semicolon
    to separate expressions on one line if you need to. Along with its use as a separator
    for list and record elements, this is one of the few times where a semicolon is
    used in F#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The rule about requiring unit values until the last expression still applies,
    of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Understanding expression evaluation order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In F#, expressions are evaluated from the "inside out" -- that is, as soon as
    a complete subexpression is "seen", it is evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the following code and try to guess what will happen, then evaluate
    the code and see.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What happens is that both "true" and "false" are printed, even though the test
    function will never actually evaluate the "else" branch. Why? Because the `(printfn
    "false")` expression is evaluated immediately, regardless of how the test function
    will be using it.
  prefs: []
  type: TYPE_NORMAL
- en: This style of evaluation is called "eager". It has the advantage that it is
    easy to understand, but it does mean that it can be inefficient on occasion.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative style of evaluation is called "lazy", whereby expressions are
    only evaluated when they are needed. The Haskell language follows this approach,
    so a similar example in Haskell would only print "true".
  prefs: []
  type: TYPE_NORMAL
- en: 'In F#, there are a number of techniques to force expressions *not* to be evaluated
    immediately. The simplest it to wrap it in a function that only gets evaluated
    on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this is that now the "true" function might be evaluated twice
    by mistake, when we only wanted to evaluate it once!
  prefs: []
  type: TYPE_NORMAL
- en: So, the preferred way for expressions not to be evaluated immediately is to
    use the `Lazy<>` wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The final result value `f` is also a lazy value, and can be passed around without
    being evaluated until you are finally ready to get the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you never need the result, and never call `Force()`, then the wrapped value
    will never be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: There will much more on laziness in an upcoming series on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Binding with let, use, and do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Binding with let, use, and do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've have already seen, there are no "variables" in F#. Instead there are
    values.
  prefs: []
  type: TYPE_NORMAL
- en: And we have also seen that keywords such as `let`, `use`, and `do` act as *bindings*
    -- associating an identifier with a value or function expression.
  prefs: []
  type: TYPE_NORMAL
- en: In this post we'll look at these bindings in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '"let" bindings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `let` binding is straightforward, it has the general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: But there are two uses of `let` that are subtly different. One is to define
    a named expression at a the top level of a module*, and the other is to define
    a local name used in the context of some expression. This is somewhat analogous
    to the difference between "top level" method names and "local" variable names
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: '[* and in a later series, when we talk about OO features, classes can have
    top level let bindings too.]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of both types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The top level name is a *definition*, which is part of the module, and you can
    access it with a fully qualified name such as `MyModule.topLevelName`. It's the
    equivalent of a class method, in a sense.
  prefs: []
  type: TYPE_NORMAL
- en: But the nested names are completely inaccessible to anyone -- they are only
    valid within the context of the top level name binding.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns in "let" bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already seen examples of how bindings can use patterns directly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And in function definitions the binding includes parameters as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The details of the various pattern bindings depends on the type being bound,
    and will be discussed further in later posts on pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Nested "let" bindings as expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have emphasized that an expression is composed from smaller expressions.
    But what about a nested `let`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How can "`let`" be an expression? What does it return?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer that a nested "let" can never be used in isolation -- it must always
    be part of a larger code block, so that it can be interpreted as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That is, every time you see the symbol "nestedName" in the second expression
    (called the *body expression*), substitute it with the first expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for example, the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'really means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When the substitutions are performed, the last line becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In a sense, the nested names are just "macros" or "placeholders" that disappear
    when the expression is compiled. And therefore you should be able to see that
    the nested `let`s have no effect on the expression as whole. So, for example,
    the type of an expression containing nested `let`s is just the type of the final
    body expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you understand how nested `let` bindings work, then certain errors become
    understandable. For example, if there is nothing for a nested "let" to be "in",
    the entire expression is not complete. In the example below, there is nothing
    following the let line, which is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And you cannot have multiple expression results, because you cannot have multiple
    body expressions. Anything evaluated before the final body expression must be
    a "`do`" expression (see below), and return `unit`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In a case like this, you must pipe the results into "ignore".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '"use" bindings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `use` keyword serves the same purpose as `let` -- it binds the result of
    an expression to a named value.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference is that is also *automatically disposes* the value when it
    goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this means that `use` only applies in nested situations. You cannot
    have a top level `use` and the compiler will warn you if you try.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To see how a proper `use` binding works, first let's create a helper function
    that creates an `IDisposable` on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s test it with a nested `use` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can see that "done" is printed, and then immediately after that, `myResource`
    goes out of scope, its `Dispose` is called, and "hello disposed" is also printed.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if we test it using the regular `let` binding, we don't get
    the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we see that "done" is printed, but `Dispose` is never called.
  prefs: []
  type: TYPE_NORMAL
- en: '"Use" only works with IDisposables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that "use" bindings only work with types that implement `IDisposable`,
    and the compiler will complain otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Don't return "use'd" values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to realize that the value is disposed as soon as it goes out
    of scope *in the expression where it was declared*. If you attempt to return the
    value for use by another function, the return value will be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how *not* to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you need to work with a disposable "outside" the function that created it,
    probably the best way is to use a callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function then would work as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: create the disposable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: evaluate the callback with the disposable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: call `Dispose` on the disposable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This approach guarantees that the same function that creates the disposable
    also disposes of it and there is no chance of a leak.
  prefs: []
  type: TYPE_NORMAL
- en: Another possible way is to *not* use a `use` binding on creation, but use a
    `let` binding instead, and make the caller responsible for disposing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Personally, I don't like this approach, because it is not symmetrical and separates
    the create from the dispose, which could lead to resource leaks.
  prefs: []
  type: TYPE_NORMAL
- en: The "using" function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preferred approach to sharing a disposable, shown above, used a callback
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a built-in `using` function that works in the same way. It takes two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: the first is an expression that creates the resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the second is a function that uses the resource, taking it as a parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s our earlier example rewritten with the `using` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In practice, the `using` function is not used that often, because it is so easy
    to make your own custom version of it, as we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Misusing "use"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One trick in F# is to appropriate the `use` keyword to do any kind of "stop"
    or "revert" functionality automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do this is:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an [extension method](type-extensions) for some type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In that method, start the behavior you want but then return an `IDisposable`
    that stops the behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, here is an extension method that starts a timer and then returns
    an `IDisposable` that stops it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So now in the calling code, we create the timer and bind it with `use`. When
    the timer value goes out of scope, it will stop automatically!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This same approach can be used for other common pairs of operations, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: opening/connecting and then closing/disconnecting a resource (which is what
    `IDisposable` is supposed to be used for anyway, but your target type might not
    have implemented it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: registering and then deregistering an event handler (instead of using `WeakReference`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in a UI, showing a splash screen at the start of a block of code, and then automatically
    closing it at the end of the block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I wouldn't recommend this approach generally, because it does hide what is going
    on, but on occasion it can be quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: '"do" bindings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes we might want to execute code independently of a function or value
    definition. This can be useful in module initialization, class initialization
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: That is, rather than having "`let x = do something`" we just the "`do something`"
    on its own. This is analogous to a statement in an imperative language.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this by prefixing the code with "`do`":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In many situations, the `do` keyword can be omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: But in both cases, the expression must return unit. If it does not, you will
    get a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As always, you can force a non-unit result to be discarded by piping the results
    into "`ignore`".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You will also see the "`do`" keyword used in loops in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that although you can sometimes omit it, it is considered good practice
    to always have an explicit "`do`", as it acts as documentation that you do not
    want a result, only the side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: '"do" for module initialization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like `let`, `do` can be used both in a nested context, and at the top level
    in a module or class.
  prefs: []
  type: TYPE_NORMAL
- en: When used at the module level, the `do` expression is evaluated once only, when
    the module is first loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is somewhat analogous to a static class constructor in C#, except that
    if there are multiple modules, the order of initialization is fixed and they are
    initialized in order of declaration.
  prefs: []
  type: TYPE_NORMAL
- en: let! and use! and do!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you see `let!`, `use!` and `do!` (that is, with exclamation marks) and
    they are part of a curly brace `{..}` block, then they are being used as part
    of a "computation expression". The exact meaning of `let!`, `use!` and `do!` in
    this context depends on the computation expression itself. Understanding computation
    expressions in general will have to wait for a later series.
  prefs: []
  type: TYPE_NORMAL
- en: The most common type of computation expression you will run into are *asynchronous
    workflows*, indicated by a `async{..}` block. In this context, it means they are
    being used to wait for an async operation to finish, and only then bind to the
    result value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples we saw earlier in [a post from the "why use F#?" series](concurrency-async-and-parallel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Attributes on let and do bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If they are at the top-level in a module, `let` and `do` bindings can have attributes.
    F# attributes use the syntax `[<MyAttribute>]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples in C# and then the same code in F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a brief look at three attribute examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The EntryPoint attribute used to indicate the "main" function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various AssemblyInfo attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DllImport attribute for interacting with unmanaged code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The EntryPoint attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The special `EntryPoint` attribute is used to mark the entry point of a standalone
    app, just as in C#, the `static void Main` method is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the familiar C# version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the F# equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Just as in C#, the args are an array of strings. But unlike C#, where the static
    `Main` method can be `void`, the F# function *must* return an int.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, a big gotcha is that the function that has this attribute must be the
    very last function in the last file in the project! Otherwise you get this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Why is the F# compiler so fussy? In C#, the class can go anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'One analogy that might help is this: in some sense, the whole application is
    a single huge expression bound to `main`, where `main` is an expression that contains
    subexpressions that contain other subexpressions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now in F# projects, there are no forward references allowed. That is, expressions
    that refer to other expressions must be declared after them. And so logically,
    the highest, most top-level function of them all, `main`, must come last of all.
  prefs: []
  type: TYPE_NORMAL
- en: The AssemblyInfo attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a C# project, there is an `AssemblyInfo.cs` file that contains all the assembly
    level attributes.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, the equivalent way to do this is with a dummy module which contains a
    `do` expression annotated with these attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The DllImport attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another occasionally useful attribute is the `DllImport` attribute. Here's a
    C# example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It works the same way in F# as in C#. One thing to note is that the `extern
    declaration ...` puts the types before the parameters, C-style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Interop with unmanaged code is a big topic which will need its own series.
  prefs: []
  type: TYPE_NORMAL
- en: 'F# syntax: indentation and verbosity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'F# syntax: indentation and verbosity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntax for F# is mostly straightforward. But there are a few rules that
    you should understand if you want to avoid common indentation errors. If you are
    familiar with a language like Python that also is whitespace sensitive, be aware
    that that the rules for indentation in F# are subtly different.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation and the "offside" rule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In soccer, the offside rule says that in some situations, a player cannot be
    "ahead" of the ball when they should be behind or level with it. The "offside
    line" is the line the player must not cross. F# uses the same term to describe
    the line at which indentation must start. As with soccer, the trick to avoiding
    a penalty is to know where the line is and not get ahead of it.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, once an offside line has been set, all the expressions must align
    with the line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Various tokens can trigger new offside lines to be created. For example, when
    the F# sees the "`=`" used in a let expression, a new offside line is created
    at the position of the very next symbol or word encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Other tokens have the same behavior, including parentheses, "`then`", "`else`",
    "`try`", "`finally`" and "`do`", and "`->`" in match clauses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The offside lines can be nested, and are pushed and popped as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'New offside lines can never go forward further than the previous line on the
    stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Special cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are number of special cases which have been created to make code formatting
    more flexible. Many of them will seem natural, such as aligning the start of each
    part of an `if-then-else` expression or a `try-catch` expression. There are some
    non-obvious ones, however.
  prefs: []
  type: TYPE_NORMAL
- en: 'Infix operators such as "+", "|>" and ">>" are allowed to be outside the line
    by their length plus one space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If an infix operator starts a line, that line does not have to be strict about
    the alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If a "`fun`" keyword starts an expression, the "fun" does *not* start a new
    offside line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Finding out more
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many more details as to how indentation works, but the examples above
    should cover most of the common cases. If you want to know more, the complete
    language spec for F# is available from Microsoft as a [downloadable PDF](http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.pdf),
    and is well worth reading.
  prefs: []
  type: TYPE_NORMAL
- en: '"Verbose" syntax'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, F# uses indentation to indicate block structure -- this is called
    "light" syntax. There is an alternative syntax that does not use indentation;
    it is called "verbose" syntax. With verbose syntax, you are not required to use
    indentation, and whitespace is not significant, but the downside is that you are
    required to use many more keywords, including things like:'
  prefs: []
  type: TYPE_NORMAL
- en: '"`in`" keywords after every "let" and "do" binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"`begin`"/"`end`" keywords for code blocks such as if-then-else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"`done`" keywords at the end of loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: keywords at the beginning and end of type definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of verbose syntax with wacky indentation that would not
    otherwise be acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Verbose syntax is always available, even in "light" mode, and is occasionally
    useful. For example, when you want to embed "let" into a one line expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Other cases when you might want to use verbose syntax are:'
  prefs: []
  type: TYPE_NORMAL
- en: when outputting generated code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to be compatible with OCaml
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you are visually impaired or blind and use a screen reader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: or just to gain some insight into the abstract syntax tree used by the F# parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than these cases, verbose syntax is rarely used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter and value naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameter and value naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are coming to F# from an imperative language such as C#, then you might
    find a lot of the names shorter and more cryptic than you are used to.
  prefs: []
  type: TYPE_NORMAL
- en: In C# and Java, the best practice is to have long descriptive identifiers. In
    functional languages, the function names themselves can be descriptive, but the
    local identifiers inside a function tend to be quite short, and piping and composition
    is used a lot to get everything on a minimal number of lines.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is a crude implementation of a prime number sieve with very
    descriptive names for the local values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the same implementation, with terser, idiomatic names and more compact
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The cryptic names are not always better, of course, but if the function is kept
    to a few lines and the operations used are standard, then this is a fairly common
    idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common naming conventions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"a", "b", "c" etc., are types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"f", "g", "h" etc., are functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"x", "y", "z" etc., are arguments to the functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists are indicated by adding an "s" suffix, so that "`xs`" is a list of `x`'s,
    "`fs`" is a list of functions, and so on. It is extremely common to see "`x::xs`"
    meaning the head (first element) and tail (the remaining elements) of a list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"*" is used whenever you don''t care about the value. So "`x::*`" means that
    you don''t care about the rest of the list, and "`let f _ = something`" means
    you don''t care about the argument to`f`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another reason for the short names is that often, they cannot be assigned to
    anything meaningful. For example, the definition of the pipe operator is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We don't know what `f` and `x` are going to be, `f` could be any function and
    `x` could be any value. Making this explicit does not make the code any more understandable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The style used on this site
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On this site I will use both styles. For the introductory series, when most
    of the concepts are new, I will use a very descriptive style, with intermediate
    values and long names. But in more advanced series, the style will become terser.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control flow expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this post, we''ll look at the control flow expressions, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: if-then-else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for x in collection (which is the same as foreach in C#)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for x = start to end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: while-do
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These control flow expressions are no doubt very familiar to you. But they are
    very "imperative" rather than functional.
  prefs: []
  type: TYPE_NORMAL
- en: So I would strongly recommend that you do not use them if at all possible, especially
    when you are learning to think functionally. If you do use them as a crutch, you
    will find it much harder to break away from imperative thinking.
  prefs: []
  type: TYPE_NORMAL
- en: To help you do this, I will start each section with examples of how to avoid
    using them by using more idiomatic constructs instead. If you do need to use them,
    there are some "gotchas" that you need to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: If-then-else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to avoid using if-then-else
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to avoid `if-then-else` is to use "match" instead. You can match
    on a boolean, which is similar to the classic then/else branches. But much, much
    better, is to avoid the equality test and actually match on the thing itself,
    as shown in the last implementation below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Part of the reason why direct matching is better is that the equality test throws
    away useful information that you often need to retrieve again.
  prefs: []
  type: TYPE_NORMAL
- en: This is demonstrated by the next scenario, where we want to get the first element
    of a list in order to print it. Obviously, we must be careful not to attempt this
    for an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: The first implementation does a test for empty and then a *second* operation
    to get the first element. A much better approach is to match and extract the element
    in one single step, as shown in the second implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The second implementation is not only easier to understand, it is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: If the boolean test is complicated, it can still be done with match by using
    extra "`when`" clauses (called "guards"). Compare the first and second implementations
    below to see the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Again, the second implementation is easier to understand and also more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'The moral of the tale is: if you find yourself using if-then-else or matching
    on booleans, consider refactoring your code.'
  prefs: []
  type: TYPE_NORMAL
- en: How to use if-then-else
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you do need to use if-then-else, be aware that even though the syntax looks
    familiar, there is a catch that you must be aware of: "`if-then-else`" is an *expression*,
    not a *statement*, and as with every expression in F#, it must return a value
    of a particular type.'
  prefs: []
  type: TYPE_NORMAL
- en: Here are two examples where the return type is a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: But as a consequence, both branches must return the same type! If this is not
    true, then the expression as a whole cannot return a consistent type and the compiler
    will complain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of different types in each branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The "else" clause is optional, but if it is absent, the "else" clause is assumed
    to return unit, which means that the "then" clause must also return unit. You
    will get a complaint from the compiler if you make this mistake.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: If the "then" clause returns unit, then the compiler will be happy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no way to return early in a branch. The return value is the
    entire expression. In other words, the if-then-else expression is more closely
    related to the C# ternary if operator (<if expr="" class="hljs-class">?<then expr=""
    class="hljs-class">:<else expr="" class="hljs-class">) than to the C# if-then-else
    statement.</else></then></if>
  prefs: []
  type: TYPE_NORMAL
- en: if-then-else for one liners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the places where if-then-else can be genuinely useful is to create simple
    one-liners for passing into other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Returning functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Don''t forget that an if-then-else expression can return any value, including
    function values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Of course, both functions must have the same type, meaning that they must have
    the same function signature.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to avoid using loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to avoid loops is to use the built in list and sequence functions
    instead. Almost anything you want to do can be done without using explicit loops.
    And often, as a side benefit, you can avoid mutable values as well. Here are some
    examples to start with, and for more details please read the upcoming series devoted
    to list and sequence operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Printing something 10 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Summing a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Generating and printing a sequence of random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As with if-then-else, there is a moral; if you find yourself using loops and
    mutables, please consider refactoring your code to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: The three types of loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to use loops, then there are three types of loop expressions to
    choose from, which are similar to those in C#.
  prefs: []
  type: TYPE_NORMAL
- en: '`for-in-do`. This has the form `for x in enumerable do something`. It is the
    same as the `foreach` loop in C#, and is the form most commonly seen in F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for-to-do`. This has the form `for x = start to finish do something`. It is
    the same as the standard `for (i=start; i<end; i++)` loops in C#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while-do`. This has the form `while test do something`. It is the same as
    the `while` loop in C#. Note that there is no `do-while` equivalent in F#.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I won't go into any more detail than this, as the usage is straightforward.
    If you have trouble, check the [MSDN documentation](http://msdn.microsoft.com/en-us/library/dd233227.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: How to use loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with if-then-else expressions, the loop expressions look familiar, but there
    are some catches again.
  prefs: []
  type: TYPE_NORMAL
- en: All looping expressions always return unit for the whole expression, so there
    is no way to return a value from inside a loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with all "do" bindings, the expression inside the loop must return unit as
    well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no equivalent of "break" and "continue" (this can generally done better
    using sequences anyway)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here's an example of the unit constraint. The expression in the loop should
    be unit, not int, so the compiler will complain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Loops for one liners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the places where loops are used in practice is as list and sequence generators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I''ll repeat what I said at the top of the post: do avoid using imperative
    control flow when you are learning to think functionally. And understand the exceptions
    that prove the rule; the one-liners whose use is acceptable.'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like other .NET languages, F# supports throwing and catching exceptions.
    As with the control flow expressions, the syntax will feel familiar, but again
    there are a few catches that you should know about.
  prefs: []
  type: TYPE_NORMAL
- en: Defining your own exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When raising/throwing exceptions, you can use the standard system ones such
    as `InvalidOperationException`, or you can define your own exception types using
    the simple syntax shown below, where the "content" of the exception is any F#
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Defining new exception classes is a lot easier than in C#!
  prefs: []
  type: TYPE_NORMAL
- en: Throwing exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three basic ways to throw an exception
  prefs: []
  type: TYPE_NORMAL
- en: Using one of the built in functions, such as "invalidArg"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using one of the standard .NET exception classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using your own custom exception types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throwing exceptions, method 1: using one of the built in functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are four useful exception keywords built into F#:'
  prefs: []
  type: TYPE_NORMAL
- en: '`failwith` throws a generic `System.Exception`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalidArg` throws an `ArgumentException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullArg` throws a `NullArgumentException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalidOp` throws an `InvalidOperationException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These four probably cover most of the exceptions you would regularly throw.
    Here is how they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, there''s a very useful variant of `failwith` called `failwithf`
    that includes `printf` style formatting, so that you can make custom messages
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Throwing exceptions, method 2: using one of the standard .NET exception classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can `raise` any .NET exception explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Throwing exceptions, method 3: using your own F# exception types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, you can use your own types, as defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: And that's pretty much it for throwing exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: What effect does raising an exception have on the function type?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said earlier that both branches of an if-then-else expression must return
    the same type. But how can raising an exception work with this constraint?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that any code that raises exceptions is ignored for the purposes
    of determining expression types. This means that the function signature will be
    based on the normal case only, not the exception case.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the code below, the exceptions are ignored, and the overall
    function has signature `bool->int`, as you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Question: what do you think the function signature will be if both branches
    raise exceptions?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Try it and see!
  prefs: []
  type: TYPE_NORMAL
- en: Catching exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exceptions are caught using a try-catch block, as in other languages. F# calls
    it `try-with` instead, and testing for each type of exception uses the standard
    pattern matching syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: If the exception to catch was thrown with `failwith` (e.g. a System.Exception)
    or a custom F# exception, you can match using the simple tag approach shown above.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, to catch a specific .NET exception class, you have to match
    using the more complicated syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Again, as with if-then-else and the loops, the try-with block is an expression
    that returns a value. This means that all branches of the `try-with` expression
    *must* return the same type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to evaluate it, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that the "`with`" branch is of type `unit`, while the "`try`"
    branch is of type `int`. So the two branches are of incompatible types.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we need to make the "`with`" branch also return type `int`. We
    can do this easily using the semicolon trick to chain expressions on one line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `try-with` expression has a defined type, the whole function can
    be assigned a type, namely `int -> int -> int`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: As before, if any branch throws an exception, it doesn't count when types are
    being determined.
  prefs: []
  type: TYPE_NORMAL
- en: Rethrowing exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If needed, you can call the "`reraise()`" function in a catch handler to propagate
    the same exception up the call chain. This is the same as the C# `throw` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Try-finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another familiar expression is `try-finally`. As you might expect, the "finally"
    clause will be called no matter what.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The return type of the try-finally expression as a whole is always the same
    as return type of the "try" clause on its own. The "finally" clause has no effect
    on the type of the expression as a whole. So in the above example, the whole expression
    has type `string`.
  prefs: []
  type: TYPE_NORMAL
- en: The "finally" clause must always return unit, so any non-unit values will be
    flagged by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Combining try-with and try-finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The try-with and the try-finally expressions are distinct and cannot be combined
    directly into a single expression. Instead, you will have to nest them as circumstances
    require.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Should functions throw exceptions or return error structures?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are designing a function, should you throw exceptions, or return structures
    which encode the error? This section will discuss two different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The pair of functions approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One approach is to provide two functions: one which assumes everything works
    and throws an exception otherwise and a second "tryXXX" function that returns
    a missing value if something goes wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might want to design two distinct library functions for division,
    one that doesn''t handle exceptions and one that does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `Some` and `None` Option types in the `tryDivide` code to signal
    to the client whether the value is valid.
  prefs: []
  type: TYPE_NORMAL
- en: With the first function, the client code must handle the exception explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no constraint that forces the client to do this, so this
    approach can be a source of errors.
  prefs: []
  type: TYPE_NORMAL
- en: With the second function the client code is simpler, and the client is constrained
    to handle both the normal case and the error case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This "normal vs. try" approach is very common in the .NET BCL, and also occurs
    in a few cases in the F# libraries too. For example, in the `List` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List.find` will throw a `KeyNotFoundException` if the key is not found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But `List.tryFind` will return an Option type, with `None` if the key is not
    found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are going to use this approach, do have a naming convention. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '"doSomethingExn" for functions that expect clients to catch exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"tryDoSomething" for functions that handle normal exceptions for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that I prefer to have an "Exn" suffix on "doSomething" rather than no suffix
    at all. It makes it clear that you expect clients to catch exceptions even in
    normal cases.
  prefs: []
  type: TYPE_NORMAL
- en: The overall problem with this approach is that you have to do extra work to
    create pairs of functions, and you reduce the safety of the system by relying
    on the client to catch exceptions if they use the unsafe version of the function.
  prefs: []
  type: TYPE_NORMAL
- en: The error-code-based approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"Writing good error-code-based code is hard, but writing good exception-based
    code is really hard." [*Raymond Chen*](http://blogs.msdn.com/b/oldnewthing/archive/2005/01/14/352949.aspx)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the functional world, returning error codes (or rather error *types*) is
    generally preferred to throwing exceptions, and so a standard hybrid approach
    is to encode the common cases (the ones that you would expect a user to care about)
    into a error type, but leave the very unusual exceptions alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, the simplest approach is just to use the option type: `Some` for success
    and `None` for errors. If the error case is obvious, as in `tryDivide` or `tryParse`,
    there is no need to be explicit with more detailed error cases.'
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes there is more than one possible error, and each should be handled
    differently. In this case, a union type with a case for each error is useful.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we want to execute a SqlCommand. Three very common
    error cases are login errors, constraint errors and foreign key errors, so we
    build them into the result structure. All other errors are raised as exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The client is then forced to handle the common cases, while uncommon exceptions
    will be caught by a handler higher up the call chain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike a traditional error code approach, the caller of the function does not
    have to handle any errors immediately, and can simply pass the structure around
    until it gets to someone who knows how to handle it, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, unlike C#, the result of a expression cannot be accidentally
    thrown away. So if a function returns an error result, the caller must handle
    it (unless it really wants to be badly behaved and send it to `ignore`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Match expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Match expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching is ubiquitous in F#. It is used for binding values to expressions
    with `let`, and in function parameters, and for branching using the `match..with`
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We have briefly covered binding values to expressions in a [post in the "why
    use F#?" series](conciseness-pattern-matching), and it will be covered many times
    as we [investigate types](overview-of-types-in-fsharp).
  prefs: []
  type: TYPE_NORMAL
- en: So in this post, we'll cover the `match..with` syntax and its use for control
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: What is a match expression?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen `match..with` expressions a number of times. And we know
    that it has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'If you squint at it just right, it looks a bit like a series of lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Where each lambda expression has exactly one parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: So one way of thinking about `match..with` is that it is a choice between a
    set of lambda expressions. But how to make the choice?
  prefs: []
  type: TYPE_NORMAL
- en: This is where the patterns come in. The choice is made based on whether the
    "match with" value can be matched with the parameter of the lambda expression.
    The first lambda whose parameter can be made to match the input value "wins"!
  prefs: []
  type: TYPE_NORMAL
- en: So for example, if the param is the wildcard `_`, it will always match, and
    if first, always win.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Order is important!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Looking at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there are three lambda expressions to match, in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: So, the `1` pattern gets tried first, then then the `2` pattern, and finally,
    the `_` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we changed the order to put the wildcard first, it would
    be tried first and always win immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the F# compiler helpfully warns us that the other rules will never
    be matched.
  prefs: []
  type: TYPE_NORMAL
- en: So this is one major difference between a "`switch`" or "`case`" statement compared
    with a `match..with`. In a `match..with`, **the order is important**.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting a match expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since F# is sensitive to indentation, you might be wondering how best to format
    this expression, as there are quite a few moving parts.
  prefs: []
  type: TYPE_NORMAL
- en: The [post on F# syntax](fsharp-syntax) gives an overview of how alignment works,
    but for `match..with` expressions, here are some specific guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Guideline 1: The alignment of the `| expression` clauses should be directly
    under the `match`**'
  prefs: []
  type: TYPE_NORMAL
- en: This guideline is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '**Guideline 2: The `match..with` should be on a new line**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `match..with` can be on the same line or a new line, but using a new line
    keeps the indenting consistent, independent of the lengths of the names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '**Guideline 3: The expression after the arrow `->` should be on a new line**'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the result expression can be on the same line as the arrow, but using
    a new line again keeps the indenting consistent and helps to separate the match
    pattern from the result expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, when all the patterns are very compact, a common sense exception
    can be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: match..with is an expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is important to realize that `match..with` is not really a "control flow"
    construct. The "control" does not "flow" down the branches, but instead, the whole
    thing is an expression that gets evaluated at some point, just like any other
    expression. The end result in practice might be the same, but it is a conceptual
    difference that can be important.
  prefs: []
  type: TYPE_NORMAL
- en: One consequence of it being an expression is that all branches *must* evaluate
    to the *same* type -- we have already seen this same behavior with if-then-else
    expressions and for loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: You cannot mix and match the types in the expression.
  prefs: []
  type: TYPE_NORMAL
- en: You can use match expressions anywhere
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since they are normal expressions, match expressions can appear anywhere an
    expression can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s a nested match expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a match expression embedded in a lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Exhaustive matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another consequence of being an expression is that there must always be *some*
    branch that matches. The expression as a whole must evaluate to *something*!
  prefs: []
  type: TYPE_NORMAL
- en: That is, the valuable concept of "exhaustive matching" comes from the "everything-is-an-expression"
    nature of F#. In a statement oriented language, there would be no requirement
    for this to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of an incomplete match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will warn you if it thinks there is a missing branch. And if you
    deliberately ignore the warning, then you will get a nasty runtime error (`MatchFailureException`)
    when none of the patterns match.
  prefs: []
  type: TYPE_NORMAL
- en: Exhaustive matching is not perfect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The algorithm for checking that all possible matches are listed is good but
    not always perfect. Occasionally it will complain that you have not matched every
    possible case, when you know that you have. In this case, you may need to add
    an extra case just to keep the compiler happy.
  prefs: []
  type: TYPE_NORMAL
- en: Using (and avoiding) the wildcard match
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One way to guarantee that you always match all cases is to put the wildcard
    parameter as the last match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: You see this pattern frequently, and I have used it a lot in these examples.
    It's the equivalent of having a catch-all `default` in a switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you want to get the full benefits of exhaustive pattern matching, I
    would encourage you *not* to use wildcards, and try to match all the cases explicitly
    if you can. This is particularly true if you are matching on the cases of a union
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: By being always explicit in this way, you can trap any error caused by adding
    a new case to the union. If you had a wildcard match, you would never know.
  prefs: []
  type: TYPE_NORMAL
- en: If you can't have *every* case be explicit, you might try to document your boundary
    conditions as much as possible, and assert an runtime error for the wildcard case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Types of patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are lots of different ways of matching patterns, which we'll look at next.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the various patterns, see the [MSDN documentation](http://msdn.microsoft.com/en-us/library/dd547125%28v=vs.110%29).
  prefs: []
  type: TYPE_NORMAL
- en: Binding to values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic pattern is to bind to a value as part of the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '*By the way, I have deliberately left this pattern (and others in this post)
    as incomplete. As an exercise, make them complete without using the wildcard.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the values that are bound *must* be distinct for
    each pattern. So you can''t do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you have to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: This second option can also be rewritten using "guards" (`when` clauses) instead.
    Guards will be discussed shortly.
  prefs: []
  type: TYPE_NORMAL
- en: AND and OR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can combine multiple patterns on one line, with OR logic and AND logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The OR logic is particularly common when matching a large number of union cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Matching on lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lists can be matched explicitly in the form `[x;y;z]` or in the "cons" form
    `head::tail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: A similar syntax is available for matching arrays exactly `[|x;y;z|]`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that sequences (aka `IEnumerables`) can *not*
    be matched on this way directly, because they are "lazy" and meant to be accessed
    one element at a time. Lists and arrays, on the other hand, are fully available
    to be matched on.
  prefs: []
  type: TYPE_NORMAL
- en: Of these patterns, the most common one is the "cons" pattern, often used in
    conjunction with recursion to loop through the elements of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of looping through lists using recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The second example shows how we can carry state from one iteration of the loop
    to the next using a special "accumulator" parameter (called `sumSoFar` in this
    example). This is a very common pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Matching on tuples, records and unions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pattern matching is available for all the built-in F# types. More details in
    the [series on types](overview-of-types-in-fsharp).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Matching the whole and the part with the "as" keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want to match the individual components of the value *and* also
    the whole thing. You can use the `as` keyword for this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Matching on subtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can match on subtypes, using the `:?` operator, which gives you a crude
    polymorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: This only works to find subclasses of a parent class (in this case, Object).
    The overall type of the expression has the parent class as input.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in some cases, you may need to "box" the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The message tells you the problem: "runtime type tests are not allowed on some
    types". The answer is to "box" the value which forces it into a reference type,
    and then you can type check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: In my opinion, matching and dispatching on types is a code smell, just as it
    is in object-oriented programming. It is occasionally necessary, but used carelessly
    is an indication of poor design.
  prefs: []
  type: TYPE_NORMAL
- en: In a good object oriented design, the correct approach would be to use [polymorphism
    to replace the subtype tests](http://sourcemaking.com/refactoring/replace-conditional-with-polymorphism),
    along with techniques such as [double dispatch](http://www.c2.com/cgi/wiki?DoubleDispatchExample).
    So if you are doing this kind of OO in F#, you should probably use those same
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Matching on multiple values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the patterns we've looked at so far do pattern matching on a *single* value.
    How can you do it for two or more?
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer is: you can''t. Matches are only allowed on single values.'
  prefs: []
  type: TYPE_NORMAL
- en: But wait a minute -- could we combine two values into a *single* tuple on the
    fly and match on that? Yes, we can!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: And indeed, this trick will work whenever you want to match on a set of values
    -- just group them all into a single tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Guards, or the "when" clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes pattern matching is just not enough, as we saw in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching is based on patterns only -- it can't use functions or other
    kinds of conditional tests.
  prefs: []
  type: TYPE_NORMAL
- en: But there *is* a way to do the equality test as part of the pattern match --
    using an additional `when` clause to the left of the function arrow. These clauses
    are known as "guards".
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the same logic written using a guard instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This is nicer, because we have integrated the test into the pattern proper,
    rather than using a test after the match has been done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Guards can be used for all sorts of things that pure patterns can''t be used
    for, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: comparing the bound values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: testing object properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: doing other kinds of matching, such as regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: conditionals derived from functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at some examples of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Using active patterns instead of guards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Guards are great for one-off matches. But if there are certain guards that you
    use over and over, consider using active patterns instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the email example above could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: You can see other examples of active patterns in a [previous post](convenience-active-patterns).
  prefs: []
  type: TYPE_NORMAL
- en: The "function" keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the examples so far, we''ve seen a lot of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: In the special case of function definitions we can simplify this dramatically
    by using the `function` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `aValue` parameter has completely disappeared, along with
    the `match..with`.
  prefs: []
  type: TYPE_NORMAL
- en: This keyword is *not* the same as the `fun` keyword for standard lambdas, rather
    it combines `fun` and `match..with` in a single step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `function` keyword works anywhere a function definition or lambda can be
    used, such as nested matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'or lambdas passed to a higher order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: A minor drawback of `function` compared with `match..with` is that you can't
    see the original input value and have to rely on value bindings in the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling with try..with
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [previous post](exceptions), we looked at catching exceptions with the
    `try..with` expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The `try..with` expression implements pattern matching in the same way as `match..with`.
  prefs: []
  type: TYPE_NORMAL
- en: So in the above example we see the use of matching on a custom pattern
  prefs: []
  type: TYPE_NORMAL
- en: '`| Failure msg` is an example of matching on (what looks like) an active pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`| :? System.InvalidOperationException as ex` is an example of matching on
    the subtype (with the use of `as` as well).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because the `try..with` expression implements full pattern matching, we can
    also use guards as well, if needed to add extra conditional logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping match expressions with functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Match expressions are very useful, but can lead to complex code if not used
    carefully.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem is that match expressions doesn't compose very well. That is,
    it is hard to chain `match..with` expressions and build simple ones into complex
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: The best way of avoiding this is to wrap `match..with` expressions into functions,
    which can then be composed nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a simple example. The `match x with 42` is wrapped in a `isAnswerToEverything`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Library functions to replace explicit matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most built-in F# types have such functions already available.
  prefs: []
  type: TYPE_NORMAL
- en: For example, instead of using recursion to loop through lists, you should try
    to use the functions in the `List` module, which will do almost everything you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, the function we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: can be rewritten using the `List` module in at least three different ways!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the Option type (discussed at length in [this post](the-option-type))
    has an associated `Option` module with many useful functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a function that does a match on `Some` vs `None` can be replaced
    with `Option.map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Creating "fold" functions to hide matching logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, if you create your own types which need to be frequently matched, it
    is good practice to create a corresponding generic "fold" function that wraps
    it nicely.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is a type for defining temperature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Chances are, we will matching these cases a lot, so let's create a generic function
    that will do the matching for us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'All `fold` functions follow this same general pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: there is one function for each case in the union structure (or clause in the
    match pattern)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: finally, the actual value to match on comes last. (Why? See the post on ["designing
    functions for partial application"](partial-application))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have our fold function, we can use it in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by testing for a fever. We need a function for testing degrees F
    for fever and another one for testing degrees C for fever.
  prefs: []
  type: TYPE_NORMAL
- en: And then we combine them both using the fold function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: And now we can test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: For a completely different use, let's write a temperature conversion utility.
  prefs: []
  type: TYPE_NORMAL
- en: Again we start by writing the functions for each case, and then combine them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the conversion functions wrap the converted values in a new `TemperatureType`,
    so the `convert` function has the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: And now we can test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: We can even call convert twice in a row, and we should get back the same temperature
    that we started with!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: There will be much more discussion on folds in the upcoming series on recursion
    and recursive types.
  prefs: []
  type: TYPE_NORMAL
- en: Formatted text using printf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Formatted text using printf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this post, we'll take a small detour and look at how to create formatted
    text. The printing and formatting functions are technically library functions,
    but in practice they as used as if they were part of the core language.
  prefs: []
  type: TYPE_NORMAL
- en: 'F# supports two distinct styles of formatting text:'
  prefs: []
  type: TYPE_NORMAL
- en: The standard .NET technique of ["composite formatting"](http://msdn.microsoft.com/en-us/library/txafckwd.aspx)
    as seen in `String.Format`, `Console.WriteLine` and other places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C-style technique of using `printf` and the [associated family of functions](http://msdn.microsoft.com/en-us/library/ee370560)
    such as `printfn`, `sprintf` and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String.Format vs printf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composite formatting technique is available in all .NET languages, and you
    are probably familiar with it from C#.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printf` technique, on the other hand, is based on the C-style format strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: As you have seen, the `printf` technique is very common in F#, while `String.Format`,
    `Console.Write` and so on, are rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why is `printf` preferred and considered idiomatic for F#? The reasons are:'
  prefs: []
  type: TYPE_NORMAL
- en: It is statically type checked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a well-behaved F# function and so supports partial application, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports native F# types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: printf is statically type checked
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike `String.Format`, `printf` is *statically type checked*, both for the
    types of the parameters, and the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here are two snippets using `printf` that will fail to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent code using composite formatting will compile fine but either
    work incorrectly but silently, or give a runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: printf supports partial application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The .NET formatting functions require all parameters to be passed in *at the
    same time*.
  prefs: []
  type: TYPE_NORMAL
- en: But `printf` is a standard, well-behaved F# function, and so supports [partial
    application](partial-application).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: And of course, `printf` can be used for function parameters anywhere a standard
    function can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'This also includes the higher order functions for lists, etc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: printf supports native F# types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For non-primitive types, the .NET formatting functions only support using `ToString()`,
    but `printf` supports native F# types using the `%A` specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, tuple types have a nice `ToString()` but other user defined
    types don't, so if you want to use them with the .NET formatting functions, you
    will have to override the `ToString()` method explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: printf gotchas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of "gotchas" to be aware of when using `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: First, if there are *too few* parameters, rather than too many, the compiler
    will *not* complain immediately, but might give cryptic errors later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The reason, of course, is that this is not an error at all; `printf` is just
    being partially applied! See the [discussion of partial application](partial-application)
    if you are not clear of why this happens.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that the "format strings" are not actually strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the .NET formatting model, the formatting strings are normal strings, so
    you can pass them around, store them in resource files, and so on. Which means
    that the following code works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the "format strings" that are the first argument to `printf`
    are not really strings at all, but something called a `TextWriterFormat`. Which
    means that the following code does **not** work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler does some magic behind the scenes to convert the string constant
    `"A string: %s"` into the appropriate TextWriterFormat. The TextWriterFormat is
    the key component that "knows" the type of the format string, such as `string->unit`
    or `string->int->unit`, which in turn allows `printf` to be typesafe.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to emulate the compiler, you can create your own TextWriterFormat
    value from a string using the `Printf.TextWriterFormat` type in the `Microsoft.FSharp.Core.Printf`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the format string is "inline", the compiler can deduce the type for you
    during binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: But if the format string is truly dynamic (e.g. stored in a resource or created
    on the fly), the compiler cannot deduce the type for you, and you must explicitly
    provide it with the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, my first format string has a single string parameter and
    returns a unit, so I have to specify `string->unit` as the format type. And in
    the second case, I have to specify `string->int->unit` as the format type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: I won't go into detail on exactly how `printf and`TextWriterFormat` work together
    right now -- just be aware that is not just a matter of simple format strings
    being passed around.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it's worth noting that `printf` and family are *not* thread-safe, while
    `Console.Write` and family *are*.
  prefs: []
  type: TYPE_NORMAL
- en: How to specify a format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The "%" format specifications are quite similar to those used in C, but with
    some special customizations for F#.
  prefs: []
  type: TYPE_NORMAL
- en: As with C, the characters immediately following the `%` have a specific meaning,
    as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: We'll discuss each of these attributes in more detail below.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting for dummies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most commonly used format specifiers are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%s` for strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%b` for bools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%i` for ints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%f` for floats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%A` for pretty-printing tuples, records and union types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%O` for other objects, using `ToString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These six will probably meet most of your basic needs.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping %
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `%` character on its own will cause an error. To escape it, just double
    it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Controlling width and alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When formatting fixed width columns and tables, you need to have control of
    the alignment and width.
  prefs: []
  type: TYPE_NORMAL
- en: You can do that with the "width" and "flags" options.
  prefs: []
  type: TYPE_NORMAL
- en: '`%5s`, `%5i`. A number sets the width of the value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%*s`, `%*i`. A star sets the width of the value dynamically (from an extra
    parameter just before the param to format)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%-s`, `%-i`. A hyphen left justifies the value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of these in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Formatting integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are some special options for basic integer types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%i` or `%d` for signed ints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%u` for unsigned ints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%x` and `%X` for lowercase and uppercase hex'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%o` for octal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The specifiers do not enforce any type safety within the integer types. As you
    can see from the examples above, you can pass a signed int to an unsigned specifier
    without problems. What is different is how it is formatted. The unsigned specifiers
    treat the int as unsigned no matter how it is actually typed.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `BigInteger` is *not* a basic integer type, so you must format it
    with `%A` or `%O`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control the formatting of signs and zero padding using the flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%0i` pads with zeros'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%+i` shows a plus sign'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`% i` shows a blank in place of a plus sign'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Formatting floats and decimals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For floating point types, there are also some special options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%f` for standard format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%e` or `%E` for exponential format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%g` or `%G` for the more compact of `f` and `e`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%M` for decimals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The decimal type can be used with the floating point specifiers, but you might
    lose some precision. The `%M` specifier can be used to ensure that no precision
    is lost. You can see the difference with this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control the precision of floats using a precision specification, such
    as `%.2f` and `%.4f`. For the `%f` and `%e` specifiers, the precision affects
    the number of digits after the decimal point, while for `%g` it is the number
    of digits in total. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: The alignment and width flags work for floats and decimals as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Custom formatting functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two special format specifiers that allow to you pass in a function
    rather than just a simple value.
  prefs: []
  type: TYPE_NORMAL
- en: '`%t` expects a function that outputs some text with no input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%a` expects a function that outputs some text from a given input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of using `%t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, since the callback function takes no parameters, it will probably
    be a closure that does reference some other value. Here''s an example that prints
    random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: For the `%a` specifier, the callback function takes an extra parameter. That
    is, when using the `%a` specifier, you must pass in both a function and a value
    to format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of custom formatting a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Date formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are no special format specifiers for dates in F#.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to format dates, you have a couple of options:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `ToString` to convert the date into a string, and then use the `%s` specifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a custom callback function with the `%a` specifier as described above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the two approaches in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Which approach is better?
  prefs: []
  type: TYPE_NORMAL
- en: The `ToString` with `%s` is easier to test and use, but it will be less efficient
    than writing directly to a TextWriter.
  prefs: []
  type: TYPE_NORMAL
- en: The printf family of functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of variants of `printf` functions. Here is a quick guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '| F# function | C# equivalent | Comment |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `printf` and `printfn` | `Console.Write` and `Console.WriteLine` | Functions
    starting with "print" write to standard out. |'
  prefs: []
  type: TYPE_TB
- en: '| `eprintf` and `eprintfn` | `Console.Error.Write` and `Console.Error.WriteLine`
    | Functions starting with "eprint" write to standard error. |'
  prefs: []
  type: TYPE_TB
- en: '| `fprintf` and `fprintfn` | `TextWriter.Write` and `TextWriter.WriteLine`
    | Functions starting with "fprint" write to a TextWriter. |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf` | `String.Format` | Functions starting with "sprint" return a string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bprintf` | `StringBuilder.AppendFormat` | Functions starting with "bprint"
    write to a StringBuilder. |'
  prefs: []
  type: TYPE_TB
- en: '| `kprintf`, `kfprintf`, `ksprintf` and `kbprintf` | No equivalent | Functions
    that accept a continuation. See next section for a discussion. |'
  prefs: []
  type: TYPE_TB
- en: '*All of these except `bprintf` and the `kXXX` family are automatically available
    (via [Microsoft.FSharp.Core.ExtraTopLevelOperators](http://msdn.microsoft.com/en-us/library/ee370230)).
    But if you need to access them using a module, they are in the [`Printf` module](http://msdn.microsoft.com/en-us/library/ee370560).*'
  prefs: []
  type: TYPE_NORMAL
- en: The usage of these should be obvious (except for the `kXXX` family, of which
    more below).
  prefs: []
  type: TYPE_NORMAL
- en: A particularly useful technique is to use partial application to "bake in" a
    TextWriter or StringBuilder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using a StringBuilder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an example using a TextWriter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: More on partially applying printf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in both cases above, we had to pass a format parameter when creating
    the partial application.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, we had to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'rather than the point-free version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: This stops the compiler complaining about an incorrect type. The reason why
    is non-obvious. We briefly mentioned the `TextWriterFormat` above as the first
    parameter to `printf`. It turns out that `printf` is not actually a particular
    function, like `String.Format`, but rather a generic function that has to be parameterized
    with a TextWriterFormat (or the similar StringFormat) in order to become "real".
  prefs: []
  type: TYPE_NORMAL
- en: So, to be safe, it is best to always pair a `printf` with a format parameter,
    rather than being overly aggressive with the partial application.
  prefs: []
  type: TYPE_NORMAL
- en: The kprintf functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The four `kXXX` functions are similar to their cousins, except that they take
    an extra parameter -- a continuation. That is, a function to be called immediately
    after the formatting has been done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Why would you want this? A number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You can pass the result to another function that does something useful, such
    as a logging framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can do things such as flushing the TextWriter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can raise an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at a sample that uses a external logging framework plus custom events.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create a simple logging class along the lines of log4net or System.Diagnostics.Trace.
    In practice, this would be replaced by a real third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Next in my application code, I do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the logging framework. I've hard-coded the factory method
    here, but you could also use an IoC container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create helper functions called `logInfo` and `logError` that call the logging
    framework, and in the case of `logError`, show a popup message as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when we run the `test` function, we should get the message written
    to the console, and also see the popup message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: You could also create an object-oriented version of the helper methods by creating
    a "FormattingLogger" wrapper class around the logging library, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: The object-oriented approach, although more familiar, is not automatically better!
    The pros and cons of OO methods vs. pure functions are discussed [here](type-extensions.html#downsides-of-methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'Worked example: Parsing command line arguments'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Worked example: Parsing command line arguments'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen how the match expression works, let's look at some examples
    in practice. But first, a word about the design approach.
  prefs: []
  type: TYPE_NORMAL
- en: Application design in F#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that a generic function takes input and emits output. But in a sense,
    that approach applies at *any* level of functional code, even at the top level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we can say that a functional *application* takes input, transforms
    it, and emits output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](function_transform1.png)'
  prefs: []
  type: TYPE_IMG
- en: Now ideally, the transformations work within the pure type-safe world that we
    create to model the domain, but unfortunately, the real world is untyped! That
    is, the input is likely to be simple strings or bytes, and the output also.
  prefs: []
  type: TYPE_NORMAL
- en: How can we work with this? The obvious solution is to have a separate stage
    to convert the input to our pure internal model, and then another separate stage
    to convert from the internal model to the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](function_transform2.png)'
  prefs: []
  type: TYPE_IMG
- en: In this way, we can hide the messiness of the real world from the core of the
    application. This "keep your model pure" approach is similar to the ["Hexagonal
    Architecture"](http://alistair.cockburn.us/Hexagonal+architecture) concept in
    the large, or the MVC pattern in the small.
  prefs: []
  type: TYPE_NORMAL
- en: In this post and the [next](roman-numerals), we'll see some simple examples
    of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: parsing a command line'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about the match expression in general in the [previous post](match-expression),
    so let's look at a real example where it is useful, namely parsing a command line.
  prefs: []
  type: TYPE_NORMAL
- en: We'll design and implement two slightly different versions, one with a basic
    internal model, and second one with some improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s say that we have three commandline options: "verbose", "subdirectories",
    and "orderby". "Verbose" and "subdirectories" are flags, while "orderby" has two
    choices: "by size" and "by name".'
  prefs: []
  type: TYPE_NORMAL
- en: So the command line params would look like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: First version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the design rule above, we can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: the input will be an array (or list) of strings, one for each argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the internal model will be a set of types that model the (tiny) domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the output is out of scope in this example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So we'll start by first creating the internal model of the parameters, and then
    look at how we can parse the input into types used in the internal model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a first stab at the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Ok, that looks alright. Now let's parse the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The parsing logic is very similar to the `loopAndSum` example in the previous
    post.
  prefs: []
  type: TYPE_NORMAL
- en: We create a recursive loop on the list of arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time through the loop, we parse one argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The options parsed so far are passed into each loop as a parameter (the "accumulator"
    pattern).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: This code is straightforward, I hope.
  prefs: []
  type: TYPE_NORMAL
- en: Each match consist of a `option::restOfList` pattern. If the option is matched,
    a new `optionsSoFar` value is created and the loop repeats with the remaining
    list, until the list becomes empty, at which point we can exit the loop and return
    the `optionsSoFar` value as the final result.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two special cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Matching the "orderBy" option creates a submatch pattern that looks at the first
    item in the rest of the list and if not found, complains about a missing second
    parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The very last match on the main `match..with` is not a wildcard, but a "bind
    to value". Just like a wildcard, this will always succeed, but because we havd
    bound to the value, it allows us to print the offending unmatched argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that for printing errors, we use `eprintf` rather than `printf`. This will
    write to STDERR rather than STDOUT.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So now let''s test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! That didn''t work -- we need to pass in an initial `optionsSoFar` argument!
    Lets try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Check that the output is what you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we should also check the error cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: You should see the error messages in these cases now.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish this implementation, let's fix something annoying. We are passing
    in these default options every time -- can we get rid of them?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very common situation: you have a recursive function that takes a
    "accumulator" parameter, but you don''t want to be passing initial values all
    the time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple: just create another function that calls the recursive
    function with the defaults.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, this second one is the "public" one and the recursive one is hidden,
    so we will rewrite the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename `parseCommandLine` to `parseCommandLineRec`. There are other naming conventions
    you could use as well, such as `parseCommandLine'` with a tick mark, or `innerParseCommandLine`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new `parseCommandLine` that calls `parseCommandLineRec` with the defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: In this case the helper function can stand on its own. But if you really want
    to hide it, you can put it as a nested subfunction in the defintion of `parseCommandLine`
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I think it would just make things more complicated, so I have
    kept them separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is all the code at once, wrapped in a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Second version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our initial model we used bool and string to represent the possible values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two problems with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It doesn''t *really* represent the domain.** For example, can `orderby` really
    be *any* string? Would my code break if I set it to "ABC"?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The values are not self documenting.** For example, the verbose value is
    a bool. We only know that the bool represents the "verbose" option because of
    the *context* (the field named `verbose`) it is found in. If we passed that bool
    around, and took it out of context, we would not know what it represented. I''m
    sure we have all seen C# functions with many boolean parameters like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Because the bool doesn't represent anything at the domain level, it is very
    easy to make mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to both these problems is to be as specific as possible when defining
    the domain, typically by creating lots of very specific types.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here''s a new version of `CommandLineOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of things to notice:'
  prefs: []
  type: TYPE_NORMAL
- en: There are no bools or strings anywhere.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names are quite explicit. This acts as documentation when a value is taken
    in isolation, but also means that the name is unique, which helps type inference,
    which in turn helps you avoid explicit type annotations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have made the changes to the domain, it is easy to fix up the parsing
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is all the revised code, wrapped in a "v2" module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Using fold instead of recursion?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We said in the previous post that it is good to avoid recursion where possible
    and use the built in functions in the `List` module like `map` and `fold`.
  prefs: []
  type: TYPE_NORMAL
- en: So can we take this advice here and fix up this code to do this?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, not easily. The problem is that the list functions generally
    work on one element at a time, while the "orderby" option requires a "lookahead"
    argument as well.
  prefs: []
  type: TYPE_NORMAL
- en: To make this work with something like `fold`, we need to create a "parse mode"
    flag to indicate whether we are in lookahead mode or not. This is possible, but
    I think it just adds extra complexity compared to the straightforward recursive
    version above.
  prefs: []
  type: TYPE_NORMAL
- en: And in a real-world situation, anything more complicated than this would be
    a signal that you need to switch to a proper parsing system such as [FParsec](http://www.quanttec.com/fparsec/).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, just to show you it can be done with `fold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: By the way, can you see a subtle change of behavior in this version?
  prefs: []
  type: TYPE_NORMAL
- en: In the previous versions, if there was no parameter to the "orderBy" option,
    the recursive loop would still parse it next time. But in the 'fold' version,
    this token is swallowed and lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this, compare the two implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: To fix this would be even more work. Again this argues for the second implementation
    as the easiest to debug and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post we've seen how to apply pattern matching to a real-world example.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we've seen how easy it is to create a properly designed internal
    model for even the smallest domain. And that this internal model provides more
    type safety and documentation than using primitive types such as string and bool.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we'll do even more pattern matching!
  prefs: []
  type: TYPE_NORMAL
- en: 'Worked example: Roman numerals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Worked example: Roman numerals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Last time](pattern-matching-command-line) we looked at parsing a command line.
    This time we''ll we''ll look at another pattern matching example, this time using
    Roman numerals.'
  prefs: []
  type: TYPE_NORMAL
- en: As before, we will try to have a "pure" internal model with separate stages
    to convert the input to the internal model, and then another separate stage to
    convert from the internal model to the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![](function_transform2.png)'
  prefs: []
  type: TYPE_IMG
- en: Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: First version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before we'll start by first creating the internal model, and then look at
    how we can parse the input into the internal model.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a first stab at the model. We'll treat a `RomanNumeral` as a list of
    `RomanDigits`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: No, stop right there! A `RomanDigit` is not just *any* digit, it has to be taken
    from a limited set.
  prefs: []
  type: TYPE_NORMAL
- en: Also `RomanNumeral` should not just be a [type alias](type-abbreviations) for
    a list of digits. It would be better if it was its own special type as well. We
    can do this by creating a [single case union type](discriminated-unions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a much better version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'Output: Converting a numeral to an int'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's do the output logic, converting a Roman numeral to an int.
  prefs: []
  type: TYPE_NORMAL
- en: 'The digit conversion is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're using the `function` keyword instead of the `match..with` expression.
  prefs: []
  type: TYPE_NORMAL
- en: To convert a list of digits, we'll use a recursive loop again. There is a special
    case when we need to look ahead to the next digit, and if it is larger than the
    current one, then use their difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '*Note that the "less than" operation did not have to be defined. The types
    are automatically sorted by their order of declaration.*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can convert the `RomanNumeral` type itself by unpacking the contents
    into a list and calling `digitsToInt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: That takes care of the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input: Converting a string to an Roman Numeral'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's do the input logic, converting a string to our internal model.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's handle a single character conversion. It seems straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: The compiler doesn't like that! What happens if we get some other character?
  prefs: []
  type: TYPE_NORMAL
- en: This is a great example of how [exhaustive pattern matching](correctness-exhaustive-pattern-matching)
    can force you to think about missing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: So, what should be done for bad input. How about printing an error message?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try again and add a case to handle all other characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: The compiler doesn't like that either! The normal cases return a valid `RomanDigit`
    but the error case returns `unit`. As we saw in the [earlier post](pattern-matching),
    every branch *must* return the same type.
  prefs: []
  type: TYPE_NORMAL
- en: How can we fix this? We could throw an exception, but that seems a bit excessive.
    If we think about it some more, there's no way that `charToRomanDigit` can *always*
    return a valid `RomanDigit`. Sometimes it can, and sometimes it can't. In other
    words, we need to use something like an option type here.
  prefs: []
  type: TYPE_NORMAL
- en: But on further consideration, we might also want the caller to know what the
    bad char was. So we need to create our own little variant on the option type to
    hold both cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the fixed up version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Note that I have removed the error message. Since the bad char is being returned,
    the caller can print its own message for the `BadChar` case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we should check the function signature to make sure it is what we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: That looks good.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how can we convert a string into these digits? We convert the string to
    a char array, convert that into a list, and then do a final conversion using `charToRomanDigit`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'But the compiler complains again with "FS0072: Lookup on object of indeterminate
    type",'
  prefs: []
  type: TYPE_NORMAL
- en: That typically happens when you use a method rather than a function. Any object
    could implement `.ToCharArray()` so the type inference cannot tell what type is
    meant.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the solution is just to use an explicit type annotation on the
    parameter -- our first so far!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'But look at the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: It still has the pesky `ParsedChar` in it rather than `RomanDigits`. How do
    we want to proceed? Answer, let's pass the buck again and let someone else deal
    with it!
  prefs: []
  type: TYPE_NORMAL
- en: '"Passing the buck" in this case is actually a good design principle. This function
    doesn''t know what its clients might want to do -- some might want to ignore errors,
    while others might want to fail fast. So just pass back the information and let
    them decide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the client is the top level function that creates a `RomanNumeral`
    type. Here''s our first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: The compiler is not happy -- the `RomanNumeral` constructor requires a list
    of `RomanDigits`, but the `toRomanDigitList` is giving us a list of `ParsedChars`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Now we finally *do* have to commit to an error handling policy. Let's choose
    to ignore bad chars, but print out errors when they occur. We'll use the `List.choose`
    function for this. It's similar to `List.map`, but in addition has a filter built
    into it. Elements that are valid (`Some something`) are returned, but elements
    that are `None` are filtered out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our choose function should thus do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For valid digits return `Some digit`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the invalid `BadChars`, print the error message and return `None`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we do this, the output of `List.choose` will be a list of `RomanDigits`,
    exactly as needed as the input to the `RomanNumeral` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is everything put together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Let's test!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Ok, everything is good so far. Let's move on to validation.
  prefs: []
  type: TYPE_NORMAL
- en: Validation rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The validation rules were not listed in the requirements, so let''s put down
    our best guess based on what we know about Roman numerals:'
  prefs: []
  type: TYPE_NORMAL
- en: Five in a row of any digit is not allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some digits are allowed in runs of up to 4\. They are I,X,C, and M. The others
    (V,L,D) can only appear singly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some lower digits can come before a higher digit, but only if they appear singly.
    E.g. "IX" is ok but "IIIX" is not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But this is only for pairs of digits. Three ascending numbers in a row is invalid.
    E.g. "IX" is ok but "IXC" is not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single digit with no runs is always allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can convert these requirements into a pattern matching function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '*Again, note that "equality" and "less than" did not need to be defined.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'And let''s test the validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we add a top level function to test validity of the `RomanNumeral`
    type itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: The entire code for the first version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s all the code in one module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Second version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code works, but there is something that's bugging me about it. The validation
    logic seems very complicated. Surely the Romans didn't have to think about all
    of this?
  prefs: []
  type: TYPE_NORMAL
- en: 'And also, I can think of examples that should fail validation, but pass, such
    as "VIV":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: We could try to tighten up our validation rules, but let's try another tack.
    Complicated logic is often a sign that you don't quite understand the domain properly.
  prefs: []
  type: TYPE_NORMAL
- en: In other words -- could we change the internal model to make everything simpler?
  prefs: []
  type: TYPE_NORMAL
- en: What about if we stopped trying to map letters to digits, and created a domain
    that mapped how the Romans thought it. In this model "I", "II", "III", "IV" and
    so on would each be a separate digit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run with it and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the new types for the domain. I now have a digit type for every possible
    digit. The `RomanNumeral` type stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Output: second version'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, converting a single `RomanDigit` to an integer is the same as before,
    but with more cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the sum of the digits is now trivial. No special cases needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the top level function is identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'Input: second version'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the input parsing, we'll keep the `ParsedChar` type. But this time, we have
    to match 1,2,3, or 4 chars at a time. That means we can't just pull off one character
    like we did in the first version -- we have to match in the main loop. This means
    the loop now has to be recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we want to convert IIII into a single `IIII` digit rather than 4 separate
    `I` digits, so we put the longest matches at the front.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Well, this is much longer than the first version, but otherwise basically the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: The top level functions are unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'Validation: second version'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let's see how the new domain model affects the validation rules. Now,
    the rules are *much* simpler. In fact, there is only one.
  prefs: []
  type: TYPE_NORMAL
- en: Each digit must be smaller than the preceding digit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Alas, after all that, we still didn't fix the bad case that triggered the rewrite!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: There is a not-too-complicated fix for this, but I think it's time to leave
    it alone now!
  prefs: []
  type: TYPE_NORMAL
- en: The entire code for the second version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s all the code in one module for the second version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Comparing the two versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which version did you like better? The second one is more longwinded because
    it has many more cases, but on the other hand, the actual logic is the same or
    simpler in all areas, with no special cases. And as a result, the total number
    of lines of code is about the same for both versions.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, I prefer the second implementation because of the lack of special cases.
  prefs: []
  type: TYPE_NORMAL
- en: As a fun experiment, try writing the same code in C# or your favorite imperative
    language!
  prefs: []
  type: TYPE_NORMAL
- en: Making it object-oriented
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s see how we might make this object oriented. We don''t care
    about the helper functions, so we probably just need three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: A static constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to convert to a int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to convert to a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: you can ignore the compiler warning about deprecated overrides.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use this in an object oriented way now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this post we've seen lots and lots of pattern matching!
  prefs: []
  type: TYPE_NORMAL
- en: But again, as with the last post, what's equally important is that we've seen
    how easy it is to create a properly designed internal model for very trivial domains.
    And again, our internal model used no primitive types -- there is no excuse not
    to create lots of little types in order to represent the domain better. For example,
    the `ParsedChar` type -- would you have bothered to create that in C#?
  prefs: []
  type: TYPE_NORMAL
- en: And as should be clear, the choice of an internal model can make a lot of difference
    to the complexity of the design. But if and when we do refactor, the compiler
    will almost always warn us if we have forgotten something.
  prefs: []
  type: TYPE_NORMAL
