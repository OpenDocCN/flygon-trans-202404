- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can imagine that as our program grows larger and larger in OOP, you will
    define more objects and classes. Some of the classes will share similar characteristics.
    For example, you might have a `box` class, a `safety-deposit-box` class, and a
    `locked-box` class. They all need to know similar methods like adding items to
    it and removing items from it. It will be redundant to recode it for every single
    box-like class. What we want is to define a generic class (like a `box` class)
    that knows the general methods like `open`ing and then let the more specific classes
    (like the `safe-deposit-box` class) **inherit** from the general `box` class.
  prefs: []
  type: TYPE_NORMAL
- en: Parents and Children
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we want to create a `checking-account` class. Checking accounts are
    just like regular bank accounts, except that you can write checks as well as withdrawing
    money in person. But you're charged ten cents every time you write a check.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: One way to implement a `checking-account` is to copy all of the code we have
    for the `account` class but then if we need to make a change in our `account`
    then we need to remember to change our `checking-account.`
  prefs: []
  type: TYPE_NORMAL
- en: 'It is very common in object-oriented programming that one class will be a specialization
    of another: the new class will have all the methods of the old, plus some extras,
    just as in this bank account example. To describe this situation we use the metaphor
    of a family of object classes. The original class is the parent and the specialized
    version is the child class. We say that the child inherits the methods of the
    parent. (The names subclass for child and superclass for parent are also sometimes
    used.)'
  prefs: []
  type: TYPE_NORMAL
- en: Parents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s how we create a subclass of the account class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This example introduces the parent clause in `define-class`. In this case, the
    parent is the `account` class. Note that because the `account` class needs one
    instantiation variable, we need to provide that argument as well (hence the `(account
    init-balance)`).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we send a message to a `checking-account` object, where does the corresponding
    method come from? If a method of that name is defined in the `checking-account`
    class, it is used; otherwise, the OOP system looks for a method in the parent
    account class. If the parent doesn't have that method, we will look at the parent's
    parent, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: These questions follow our class definitions for `account` and `checking-account`
    above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Which one of these will return an error?
  prefs: []
  type: TYPE_NORMAL
- en: The 'self' Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What should `write-check` do? It should reduce the account's balance by the
    specified amount and additional fee. We already know how to reduce our balance,
    it's just the `withdraw` method! To call a method that we already defined from
    the body of another method, we use the **self**, hence the `(ask self 'withdraw
    (+ amount 0.10))`. Each object has a local state variable `self` whose value is
    the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods defined in a certain class only have access to the local state variables
    de fined in the same class. For example, a method de fined in the `checking-account`
    class can't refer to the `balance` variable de fined in the `account` class; likewise,
    a method in the `account` class can't refer to the `init-balance` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This rule corresponds to the usual Scheme rule about scope of variables: each
    variable is only available within the block in which it''s defi ned. (Not every
    OOP implementation works like this, by the way.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: Classes are wonderful! They keep objects organized. Inheritance is wonderful!
    They keep classes organized. Be aware about the states that a child has and which
    ones are updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What does the following expression return?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What does the following expression return?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we now have the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We added a new method, show-balance to the class. What will (ask jeffrey 'show-balance)
    return?
  prefs: []
  type: TYPE_NORMAL
- en: Takeaways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several takeaways from this subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: Some classes will be a more 'specialized' or 'specific' version of another class.
    In these cases, we want to make the specific class a 'child' of the 'parent' class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A child class inherits all methods of the parent class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep track of what variable is actually in scope in your class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to learn what kinds of variables a class can have.
  prefs: []
  type: TYPE_NORMAL
