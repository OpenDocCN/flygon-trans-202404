- en: Booleans and Predicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Booleans: True and False'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Booleans** are formally defined as a binary variable that has only two possible
    values: "true" and "false". These are extremely useful when expressing *conditionals*,
    or instructions for choosing an action based on the results of a test. A logical
    example of this would be: If we''re out of milk, then go to the store. Else, add
    milk to our cereal and enjoy.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to test whether or not we are out of milk, we'll need to use booleans.
    Racket's "true" is represented by `#t` or `true`, while "false" is represented
    by `#f` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function that, when called, returns either `true` or `false` is called a **predicate**.
    For example, `even?` is a predicate used to test whether a number is even.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Predicates will NEVER return a value other than `#t` or `#f`. Below is a list
    of some useful predefined predicates in Racket. This list is in no way comprehensive,
    and you will definitely discover many more predicates in future lesson.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Racket has the standard mathematical operators that you will need to compare
    numerical values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<` will return `#t` if the first argument is less than the second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>` will return `#t` if the first argument is greater than the second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=` will return `#t` if the two arguments are equal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=` will return `#t` if the first argument is less than or equal to the second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=` will return `#t` if the first argument is greater than or equal to the
    second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WARNING:** These predicates will only work on **numbers**. Using these to
    compare words, sentences, or any other type of value will produce errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`member?`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`member?`, when given a letter and a word, returns `#t` if the word contains
    the letter, and `#f` otherwise. When `member?` is given a word and a sentence,
    it returns `#t` if the sentence contains the word, and `#f` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`empty?`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The predicate `empty?` takes in one argument of any type and returns `#t` if
    the argument is the empty word `""` or the empty sentence `'()`, and `#f` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`equal?`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`equal?` takes in two arguments of any type and returns `#t` if they are the
    same, and `#f` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Type Checkers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Racket also provides predicates that check whether a value is of a particular
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number?` checks if a value is a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`word?` checks if a value is a word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sentence?` checks if a value is a sentence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean?` checks if a value is a boolean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compound Procedures as Predicates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can most definitely create your own predicates, since they are in fact
    procedures. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`vowel?` checks whether its argument letter is a vowel.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Your Understanding**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** This is Exercise 2 on your Homework.'
  prefs: []
  type: TYPE_NORMAL
- en: Write a predicate called `teen?` that takes in a number as its argument and
    returns `#t` if the number is between 13 and 19, inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Everything That Isn't False is True
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When evaluating whether or not an expression is true or false, it is important
    to remember that anything is considered true unless it is false. This means that
    all numbers, words, sentences, and procedures are true, even `""`, `''()`, and
    `0`. Here are some counter-intuitive examples to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also use logical operations in Racket.
  prefs: []
  type: TYPE_NORMAL
- en: '`and`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`and` is a predicate that any number of arguments of any type. It returns the
    last element if everything was not false, and returns `#f` otherwise. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`or`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`or` is a predicate that takes any number of arguments of any type. It and
    returns the first true element, and returns `#f` otherwise. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`not`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`not` takes a single argument of any type simply negates the argument that
    it takes in. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`nand`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`nand` is equivalent to `(not (and ...`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`nor`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`nor` is, you guessed it, equivalent to `(not (or ...`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`xor`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`xor` takes two arguments of any type and, if exactly one (no more or less)
    of its arguments is not `#f`, return that argument. Otherwise, return `#f`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
