- en: 'Reading 14: Recursion'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After today’s class, you should:'
  prefs: []
  type: TYPE_NORMAL
- en: be able to decompose a recursive problem into recursive steps and base cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: know when and how to use helper methods in recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: understand the advantages and disadvantages of recursion vs. iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In today’s class, we’re going to talk about how to implement a method, once
    you already have a specification. We’ll focus on one particular technique, *recursion*.
    Recursion is not appropriate for every problem, but it’s an important tool in
    your software development toolbox, and one that many people scratch their heads
    over. We want you to be comfortable and competent with recursion, because you
    will encounter it over and over. (That’s a joke, but it’s also true.)
  prefs: []
  type: TYPE_NORMAL
- en: Since you’ve taken 6.01, recursion is not completely new to you, and you have
    seen and written recursive functions like factorial and fibonacci before. Today’s
    class will delve more deeply into recursion than you may have gone before. Comfort
    with recursive implementations will be necessary for upcoming classes.
  prefs: []
  type: TYPE_NORMAL
- en: A recursive function is defined in terms of *base cases* and *recursive steps*.
  prefs: []
  type: TYPE_NORMAL
- en: In a base case, we compute the result immediately given the inputs to the function
    call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a recursive step, we compute the result with the help of one or more *recursive
    calls* to this same function, but with the inputs somehow reduced in size or complexity,
    closer to a base case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider writing a function to compute factorial. We can define factorial in
    two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Product | Recurrence relation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ![](../Images/2e97a3ae0804063338d29a036f5f195e.jpg)  (where the empty product
    equals'
  prefs: []
  type: TYPE_NORMAL
- en: multiplicative identity *1*) | ![](../Images/fe973412b7b35a397b0fc00c31f4f314.jpg)
    |
  prefs: []
  type: TYPE_NORMAL
- en: 'which leads to two different implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Iterative | Recursive |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recursive implementation on the right, the base case is *n = 0*, where
    we compute and return the result immediately: *0!* is defined to be *1*. The recursive
    step is *n > 0*, where we compute the result with the help of a recursive call
    to obtain *(n-1)!*, then complete the computation by multiplying by *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: To visualize the execution of a recursive function, it is helpful to diagram
    the *call stack* of currently-executing functions as the computation proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the recursive implementation of `factorial` in a main method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At each step, with time moving left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '| starts in `main` | calls `factorial(3)` | calls `factorial(2)` | calls `factorial(1)`
    | calls `factorial(0)` | returns to `factorial(1)` | returns to `factorial(2)`
    | returns to `factorial(3)` | returns to `main` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| main | factorialn = 3  mainx | factorialn = 2  factorialn = 3'
  prefs: []
  type: TYPE_NORMAL
- en: mainx | factorialn = 1  factorialn = 2
  prefs: []
  type: TYPE_NORMAL
- en: factorialn = 3
  prefs: []
  type: TYPE_NORMAL
- en: mainx | factorialn = 0 returns 1factorialn = 1
  prefs: []
  type: TYPE_NORMAL
- en: factorialn = 2
  prefs: []
  type: TYPE_NORMAL
- en: factorialn = 3
  prefs: []
  type: TYPE_NORMAL
- en: mainx | factorialn = 1 returns 1factorialn = 2
  prefs: []
  type: TYPE_NORMAL
- en: factorialn = 3
  prefs: []
  type: TYPE_NORMAL
- en: mainx | factorialn = 2 returns 2factorialn = 3
  prefs: []
  type: TYPE_NORMAL
- en: mainx | factorialn = 3 returns 6mainx | mainx = 6 |
  prefs: []
  type: TYPE_NORMAL
- en: In the diagram, we can see how the stack grows as `main` calls `factorial` and
    `factorial` then calls *itself*, until `factorial(0)` does not make a recursive
    call. Then the call stack unwinds, each call to `factorial` returning its answer
    to the caller, until `factorial(3)` returns to `main`.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an [**interactive visualization of `factorial`**](http://www.pythontutor.com/visualize.html#code=public+class+Factorial+%7B%0A++++public+static+void+main(String%5B%5D+args)+%7B%0A++++++++long+x+%3D+factorial(3)%3B%0A++++%7D%0A++++public+static+long+factorial(int+n)+%7B%0A++++++++if+(n+%3D%3D+0)+%7B%0A++++++++++++return+1%3B%0A++++++++%7D+else+%7B%0A++++++++++++return+n+*+factorial(n-1)%3B%0A++++++++%7D%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=0).
    You can step through the computation to see the recursion in action. New stack
    frames grow down instead of up in this visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve probably seen factorial before, because it’s a common example for recursive
    functions. Another common example is the Fibonacci series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Fibonacci is interesting because it has multiple base cases: n=0 and n=1\.
    You can look at an [**interactive visualization of Fibonacci**](http://www.pythontutor.com/visualize.html#code=public+class+Fibonacci+%7B%0A++++public+static+void+main(String%5B%5D+args)+%7B%0A++++++++int+x+%3D+fibonacci(3)%3B%0A++++%7D%0A++++public+static+int+fibonacci(int+n)+%7B%0A++++++++if+(n+%3D%3D+0+%7C%7C+n+%3D%3D+1)+%7B%0A++++++++++++return+1%3B%0A++++++++%7D+else+%7B%0A++++++++++++return+fibonacci(n-1)+%2B+fibonacci(n-2)%3B%0A++++++++%7D%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=0).
    Notice that where factorial’s stack steadily grows to a maximum depth and then
    shrinks back to the answer, Fibonacci’s stack grows and shrinks repeatedly over
    the course of the computation.'
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recursive factorial
  prefs: []
  type: TYPE_NORMAL
- en: Consider this recursive implementation of the factorial function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For `factorial(3)`, how many times will the base case `return 1` be executed?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Fibonacci
  prefs: []
  type: TYPE_NORMAL
- en: Consider this recursive implementation of the Fibonacci sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For `fibonacci(3)`, how many times will the base case `return 1` be executed?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Right Decomposition for a Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding the right way to decompose a problem, such as a method implementation,
    is important. Good decompositions are simple, short, easy to understand, safe
    from bugs, and ready for change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion is an elegant and simple decomposition for some problems. Suppose
    we want to implement this specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For example, `subsequences("abc")` might return `"abc,ab,bc,ac,a,b,c,"`. Note
    the trailing comma preceding the empty subsequence, which is also a valid subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: This problem lends itself to an elegant recursive decomposition. Take the first
    letter of the word. We can form one set of subsequences that *include* that letter,
    and another set of subsequences that exclude that letter, and those two sets completely
    cover the set of possible subsequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: subsequences("c")(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: subsequences("gc")(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Structure of Recursive Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A recursive implementation always has two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base case**, which is the simplest, smallest instance of the problem, that
    can’t be decomposed any further. Base cases often correspond to emptiness – the
    empty string, the empty list, the empty set, the empty tree, zero, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**recursive step**, which **decomposes** a larger instance of the problem into
    one or more simpler or smaller instances that can be solved by recursive calls,
    and then **recombines** the results of those subproblems to produce the solution
    to the original problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important for the recursive step to transform the problem instance into
    something smaller, otherwise the recursion may never end. If every recursive step
    shrinks the problem, and the base case lies at the bottom, then the recursion
    is guaranteed to be finite.
  prefs: []
  type: TYPE_NORMAL
- en: A recursive implementation may have more than one base case, or more than one
    recursive step. For example, the Fibonacci function has two base cases, n=0 and
    n=1.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recursive structure
  prefs: []
  type: TYPE_NORMAL
- en: Recursive methods have a base case and a recursive step. What other concepts
    from computer science also have (the equivalent of) a base case and a recursive
    step?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Helper Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recursive implementation we just saw for `subsequences()` is one possible
    recursive decomposition of the problem. We took a solution to a subproblem – the
    subsequences of the remainder of the string after removing the first character
    – and used it to construct solutions to the original problem, by taking each subsequence
    and adding the first character or omitting it. This is in a sense a *direct* recursive
    implementation, where we are using the existing specification of the recursive
    method to solve the subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it’s useful to require a stronger (or different) specification
    for the recursive steps, to make the recursive decomposition simpler or more elegant.
    In this case, what if we built up a partial subsequence using the initial letters
    of the word, and used the recursive calls to *complete* that partial subsequence
    using the remaining letters of the word? For example, suppose the original word
    is “orange”. We’ll both select “o” to be in the partial subsequence, and recursively
    extend it with all subsequences of “range”; and we’ll skip “o”, use “” as the
    partial subsequence, and again recursively extend it with all subsequences of
    “range”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this approach, our code now looks much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This `subsequencesAfter` method is called a **helper method**. It satisfies
    a different spec from the original `subsequences`, because it has a new parameter
    `partialSubsequence`. This parameter fills a similar role that a local variable
    would in an iterative implementation. It holds temporary state during the evolution
    of the computation. The recursive calls steadily extend this partial subsequence,
    selecting or ignoring each letter in the word, until finally reaching the end
    of the word (the base case), at which point the partial subsequence is returned
    as the only result. Then the recursion backtracks and fills in other possible
    subsequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish the implementation, we need to implement the original `subsequences`
    spec, which gets the ball rolling by calling the helper method with an initial
    value for the partial subsequence parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Don’t expose the helper method to your clients.** Your decision to decompose
    the recursion this way instead of another way is entirely implementation-specific.
    In particular, if you discover that you need temporary variables like `partialSubsequence`
    in your recursion, don’t change the original spec of your method, and don’t force
    your clients to correctly initialize those parameters. That exposes your implementation
    to the client and reduces your ability to change it in the future. Use a private
    helper function for the recursion, and have your public method call it with the
    correct initializations, as shown above.'
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unhelpful 1
  prefs: []
  type: TYPE_NORMAL
- en: 'Louis Reasoner doesn’t want to use a helper method, so he tries to implement
    `subsequences()` by storing `partialSubsequence` as a static variable instead
    of a parameter. Here is his implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we call `subsequencesLouis("c")` followed by `subsequencesLouis("a")`.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Unhelpful 2
  prefs: []
  type: TYPE_NORMAL
- en: 'Louis fixes that problem by making partialSubsequence public:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Alyssa P. Hacker throws up her hands when she sees what Louis did. Which of
    these statements are true about his code?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Unhelpful 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Louis gives in to Alyssa’s strenuous arguments, hides his static variable again,
    and takes care of initializing it properly before starting the recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately a static variable is simply a bad idea in recursion. Louis’s
    solution is still broken. To illustrate, let’s trace through the call `subsequences("xy")`.
    You can step through an [**interactive visualization of this version**](http://www.pythontutor.com/java.html#code=public+class+Subsequences+%7B%0A++++%0A++++public+static+String+subsequences%28String+word%29+%7B%0A++++++++partialSubsequence+%3D+%22%22%3B%0A++++++++return+subsequencesLouis%28word%29%3B%0A++++%7D%0A++++%0A++++private+static+String+partialSubsequence+%3D+%22%22%3B%0A++++%0A++++public+static+String+subsequencesLouis%28String+word%29+%7B%0A++++++++if+%28word.isEmpty%28%29%29+%7B%0A++++++++++++//+base+case%0A++++++++++++return+partialSubsequence%3B%0A++++++++%7D+else+%7B%0A++++++++++++//+recursive+step%0A++++++++++++String+withoutFirstLetter+%3D+subsequencesLouis%28word.substring%281%29%29%3B%0A++++++++++++partialSubsequence+%2B%3D+word.charAt%280%29%3B%0A++++++++++++String+withFirstLetter+%3D+subsequencesLouis%28word.substring%281%29%29%3B%0A++++++++++++return+withoutFirstLetter+%2B+%22,%22+%2B+withFirstLetter%3B%0A++++++++%7D%0A++++%7D%0A++++%0A++++public+static+void+main%28String%5B%5D+args%29+%7B%0A++++++++String+result+%3D+subsequences%28%22xy%22%29%3B%0A++++%7D%0A%7D&mode=display&origin=opt-frontend.js&cumulative=false&heapPrimitives=false&textReferences=false&py=java&rawInputLstJSON=%5B%5D&curInstr=4)
    to see what happens. It will produce these recursive calls to `subsequencesLouis()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When each of these calls **starts**, what is the value of the static variable
    partialSubsequence?
  prefs: []
  type: TYPE_NORMAL
- en: '`subsequencesLouis("xy")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`subsequencesLouis("y")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`subsequencesLouis("")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`subsequencesLouis("")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`subsequencesLouis("y")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`subsequencesLouis("")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>yx</option></select>(missing
    answer)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`subsequencesLouis("")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <select class="form-control"><option>empty string</option>,<option>x</option>,<option>y</option>,<option>xy</option>,<option>xyy</option>,<option>yx</option>,<option>yxy</option></select>(missing
    answer)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the Right Recursive Subproblem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at another example. Suppose we want to convert an integer to a string
    representation with a given base, following this spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For example, `stringValue(16, 10)` should return `"16"`, and `stringValue(16,
    2)` should return `"10000"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s develop a recursive implementation of this method. One recursive step
    here is straightforward: we can handle negative integers simply by recursively
    calling for the representation of the corresponding positive integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the recursive subproblem can be smaller or simpler in more subtle
    ways than just the value of a numeric parameter or the size of a string or list
    parameter. We have still effectively reduced the problem by reducing it to positive
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next question is, given that we have a positive n, say n=829 in base 10,
    how should we decompose it into a recursive subproblem? Thinking about the number
    as we would write it down on paper, we could either start with 8 (the leftmost
    or highest-order digit), or 9 (the rightmost, lower-order digit). Starting at
    the left end seems natural, because that’s the direction we write, but it’s harder
    in this case, because we would need to first find the number of digits in the
    number to figure out how to extract the leftmost digit. Instead, a better way
    to decompose n is to take its remainder modulo base (which gives the *rightmost*
    digit) and also divide by base (which gives the subproblem, the remaining higher-order
    digits):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Think about several ways to break down the problem, and try to write the
    recursive steps.** You want to find the one that produces the simplest, most natural
    recursive step.'
  prefs: []
  type: TYPE_NORMAL
- en: It remains to figure out what the base case is, and include an if statement
    that distinguishes the base case from this recursive step.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Implementing stringValue
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the recursive implementation of `stringValue()` with the recursive
    steps brought together but with the base case still missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Which of the following can be substituted for the `BASE CONDITION` and `BASE
    CASE` to make the code correct?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Calling stringValue
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the code is completed with one of the base cases identified in the
    previous problem, what does `stringValue(170, 16)` do?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Problems vs. Recursive Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples we’ve seen so far have been cases where the problem structure lends
    itself naturally to a recursive definition. Factorial is easy to define in terms
    of smaller subproblems. Having a *recursive problem* like this is one cue that
    you should pull a recursive solution out of your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another cue is when the data you are operating on is inherently recursive in
    structure. We’ll see many examples of recursive data a few classes from now, but
    for now let’s look at the recursive data found in every laptop computer: its filesystem.
    A filesystem consists of named *files*. Some files are *folders*, which can contain
    other files. So a filesystem is recursive: folders contain other folders which
    contain other folders, until finally at the bottom of the recursion are plain
    (non-folder) files.'
  prefs: []
  type: TYPE_NORMAL
- en: The Java library represents the file system using [`java.io.File`](http://docs.oracle.com/javase/8/docs/api/index.html?java/io/File.html).
    This is a recursive data type, in the sense that `f.getParentFile()` returns the
    parent folder of a file `f`, which is a `File` object as well, and `f.listFiles()`
    returns the files contained by `f`, which is an array of other `File` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For recursive data, it’s natural to write recursive implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Recent versions of Java have added a new API, [`java.nio.Files`](http://docs.oracle.com/javase/8/docs/api/index.html?java/nio/file/Files.html)
    and [`java.nio.Path`](http://docs.oracle.com/javase/8/docs/api/index.html?java/nio/file/Path.html),
    which offer a cleaner separation between the filesystem and the pathnames used
    to name files in it. But the data structure is still fundamentally recursive.
  prefs: []
  type: TYPE_NORMAL
- en: Reentrant Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursion – a method calling itself – is a special case of a general phenomenon
    in programming called **reentrancy**. Reentrant code can be safely re-entered,
    meaning that it can be called again *even while a call to it is underway.* Reentrant
    code keeps its state entirely in parameters and local variables, and doesn’t use
    static variables or global variables, and doesn’t share aliases to mutable objects
    with other parts of the program, or other calls to itself.
  prefs: []
  type: TYPE_NORMAL
- en: Direct recursion is one way that reentrancy can happen. We’ve seen many examples
    of that during this reading. The `factorial()` method is designed so that `factorial(n-1)`
    can be called even though `factorial(n)` hasn’t yet finished working.
  prefs: []
  type: TYPE_NORMAL
- en: Mutual recursion between two or more functions is another way this can happen
    – A calls B, which calls A again. Direct mutual recursion is virtually always
    intentional and designed by the programmer. But unexpected mutual recursion can
    lead to bugs.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about concurrency later in the course, reentrancy will come up
    again, since in a concurrent program, a method may be called at the same time
    by different parts of the program that are running concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: It’s good to design your code to be reentrant as much as possible. Reentrant
    code is safer from bugs and can be used in more situations, like concurrency,
    callbacks, or mutual recursion.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Recursion Rather Than Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve seen two common reasons for using recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is naturally recursive (e.g. Fibonacci)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data is naturally recursive (e.g. filesystem)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another reason to use recursion is to take more advantage of immutability. In
    an ideal recursive implementation, all variables are final, all data is immutable,
    and the recursive methods are all pure functions in the sense that they do not
    mutate anything. The behavior of a method can be understood simply as a relationship
    between its parameters and its return value, with no side effects on any other
    part of the program. This kind of paradigm is called *functional programming*,
    and it is far easier to reason about than *imperative programming* with loops
    and variables.
  prefs: []
  type: TYPE_NORMAL
- en: In iterative implementations, by contrast, you inevitably have non-final variables
    or mutable objects that are modified during the course of the iteration. Reasoning
    about the program then requires thinking about snapshots of the program state
    at various points in time, rather than thinking about pure input/output behavior.
  prefs: []
  type: TYPE_NORMAL
- en: One downside of recursion is that it may take more space than an iterative solution.
    Building up a stack of recursive calls consumes memory temporarily, and the stack
    is limited in size, which may become a limit on the size of the problem that your
    recursive implementation can solve.
  prefs: []
  type: TYPE_NORMAL
- en: Common Mistakes in Recursive Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are two common ways that a recursive implementation can go wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: The base case is missing entirely, or the problem needs more than one base case
    but not all the base cases are covered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recursive step doesn’t reduce to a smaller subproblem, so the recursion
    doesn’t converge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for these when you’re debugging.
  prefs: []
  type: TYPE_NORMAL
- en: On the bright side, what would be an infinite loop in an iterative implementation
    usually becomes a `StackOverflowError` in a recursive implementation. A buggy
    recursive program fails faster.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: subsequences("123456")
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the implementation of `subsequences()` from the start of this reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For `subsequences("123456")`, how deep does its recursive call stack get? How
    many recursive calls to `subsequences()` can be active at the same time?
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw these ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: recursive problems and recursive data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: comparing alternative decompositions of a recursive problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using helper methods to strengthen a recursive step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: recursion vs. iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The topics of today’s reading connect to our three key properties of good software
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs.** Recursive code is simpler and often uses immutable variables
    and immutable objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand.** Recursive implementations for naturally recursive problems
    and recursive data are often shorter and easier to understand than iterative solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change.** Recursive code is also naturally reentrant, which makes
    it safer from bugs and ready to use in more situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
