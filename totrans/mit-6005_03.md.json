["```\n/**\n * @param val another BigIntger\n * @return a BigInteger whose value is (this * val).\n */\npublic BigInteger multiply(BigInteger val)\n```", "```\nBigInteger a = ...;\nBigInteger b = ...;\nBigInteger ab = a.multiply(b);\n```", "```\n/**\n * @param a  an argument\n * @param b  another argument\n * @return the larger of a and b.\n */\npublic static int max(int a, int b)\n```", "```\n/**\n * Reverses the end of a string.\n *\n *                          012345                     012345\n * For example: reverseEnd(\"Hello, world\", 5) returns \"Hellodlrow ,\"\n *                               <----->                    <----->\n *\n * With start == 0, reverses the entire text.\n * With start == text.length(), reverses nothing.\n *\n * @param text    non-null String that will have its end reversed\n * @param start   the index at which the remainder of the input is reversed,\n *                requires 0 <= start <= text.length()\n * @return input text with the substring from start to the end of the string reversed\n */\npublic static String reverseEnd(String text, int start)\n```", "```\n/**\n * Sort a list of integers in nondecreasing order.  Modifies the list so that \n * values.get(i) <= values.get(i+1) for all 0<=i<values.length()-1\n */\npublic static void sort(List<Integer> values) {\n    // choose a good algorithm for the size of the list\n    if (values.length() < 10) {\n        radixSort(values);\n    } else if (values.length() < 1000*1000*1000) {\n        quickSort(values);\n    } else {\n        mergeSort(values);\n    }\n}\n```", "```\n/**\n * Reverses the end of a string.\n *\n * For example:\n *   reverseEnd(\"Hello, world\", 5)\n *   returns \"Hellodlrow ,\"\n *\n * With start == 0, reverses the entire text.\n * With start == text.length(), reverses nothing.\n *\n * @param text    non-null String that will have\n *                its end reversed\n * @param start   the index at which the\n *                remainder of the input is\n *                reversed, requires 0 <=\n *                start <= text.length()\n * @return input text with the substring from\n *               start to the end of the string\n *               reversed\n */\nstatic String reverseEnd(String text, int start)\n```", "```\n/*\n * Testing strategy\n *\n * Partition the inputs as follows:\n * text.length(): 0, 1, > 1\n * start:         0, 1, 1 < start < text.length(),\n *                text.length() - 1, text.length()\n * text.length()-start: 0, 1, even > 1, odd > 1\n *\n * Include even- and odd-length reversals because\n * only odd has a middle element that doesn't move.\n *\n * Exhaustive Cartesian coverage of partitions.\n */\n```", "```\n// covers test.length() = 0,\n//        start = 0 = text.length(),\n//        text.length()-start = 0\n@Test public void testEmpty() {\n    assertEquals(\"\", reverseEnd(\"\", 0));\n}\n\n// ... other test cases ...\n```", "```\npublic class Hailstone {\n  public static void main(String[] args) {\n    int n = 3;\n    while (n != 1) {\n        if (n % 2 == 0) {\n            n = n / 2;\n        } else {\n            n = 3 * n + 1;\n        }\n    }\n  }\n}\n```", "```\n/** @return the contents of the web page downloaded from url \n */\npublic static String getWebPage(URL url) {...}\n\n/** @return the words in string s, in the order they appear, \n *          where a word is a contiguous sequence of \n *          non-whitespace and non-punctuation characters \n */\npublic static List<String> extractWords(String s) { ... }\n```", "```\n/** @return an index mapping a word to the set of URLs \n *          containing that word, for all webpages in the input set \n */\npublic static Map<String, Set<URL>> makeIndex(Set<URL> urls) { \n    ...\n    for (URL url : urls) {\n        String page = getWebPage(url);\n        List<String> words = extractWords(page);\n        ...\n    }\n    ...\n} \n```"]