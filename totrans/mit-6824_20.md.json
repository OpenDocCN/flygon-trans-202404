["```\nschedule(u1 user, u2 user, t time):\n    ok1 = reserve(u1, t)    # reserve for the 1st user\n    ok2 = reserve(u2, t)    # reserve for the 2nd user\n\n    # Tricky: if the 1st reserve succeeded and the 2nd didn't => trouble\n    # We'd like to deal with this in the following way:\n\n    if ok1 and ok2\n        commit\n    else\n        abort\n\n    # One bad way to make this work is to let the servers chit-chat and\n    # make sure they both committed.\n    # At no stage in a transaction like this can the servers finish\n    #   - S1: I'll do it if you do it\n    #   - S2: I'll do it if you do it\n    #   - S1: I'll do it if you do it\n    #   - S2: I'll do it if you do it\n    # (sounds like the two generals problem?) \n```", "```\nreserve(u user, t time):\n    if u[t] = free          # if user's calendar is free at time t\n        tent[t] = taken     # ...then tenatively schedule\ncommit:\n    copy tent[t] to u[t]\nabort:\n    discard tent[t] \n```", "```\nclient           TC      A       B\n    \\-------------------->\n    \\---------------------------->\n                         |       |\n    <--------------------/       |\n    <----------------------------/\n                    ------------\n    ----- GO ----> |            |\n                 | |            |\n    <------------/ |            |\n                    ------------ \n```", "```\nclient          TC          A           B\n                    .\n                    .\n                    .\n    ---- GO ---->                             --\\\n                   prepare                      |\n                ------------>                   |\n                ------------------------>       | Phase 1\n                   yes/no   |           |       |\n                <-----------/           |       |\n                <-----------------------/     --/\n\n                   commit/abort\n                ------------>                 --\\\n                ------------------------>       | Phase 2\n    commit/abort                                |\n  <-------------                              --/ \n```", "```\nT1:\n    addToBal(x, 1)\n    addToBal(y, -1)\n\n    # Need this to be a transaction to implement a transfer correctly\n\nT2:\n    tmp1 = getBal(x)\n    tmp2 = getBal(y)\n\n    print(tmp1, tmp2)\n\n    # We cannot have the execution of T1 interleave with the execution of\n    # T2\\. T2 had better see both addToBal calls or no addToBal calls from T1 \n```", "```\n6.824 2015 Lecture 20: Two-Phase Commmit\n\nTopics:\n  distributed commit, two-phase commit\n  distributed transactions\n  Argus -- language for distributed programming\n\nDistributed commit:\n  A bunch of computers are cooperating on some task, e.g. bank transfer\n  Each computer has a different role, e.g. src and dst bank account\n  Want to ensure atomicity: all execute, or none execute\n    \"distributed transaction\"\n  Challenges: crashes and network failures\n\nExample:\n  calendar system, each user has a calendar\n  want to schedule meetings with multiple participants\n  one server holds calendars of users A-M, another server holds N-Z\n  [diagram: client, two servers]\n  sched(u1, u2, t):\n    begin_transaction\n      ok1 = reserve(u1, t)\n      ok2 = reserve(u2, t)\n      if ok1 and ok2:\n        commit\n      else\n        abort\n    end_transaction\n  the reserve() calls are RPCs to the two calendar servers\n  We want both to reserve, or both not to reserve.\n  What if 1st reserve() returns true, and then:\n    2nd reserve() returns false (time not available)\n    2nd reserve() doesn't return (lost RPC msg, u2's server crashes)\n    2nd reserve() returns but then crashes\n    client fails before 2nd reserve()\n  We need a \"distributed commit protocol\"\n\nIdea: tentative changes, later commit or undo (abort)\n  reserve_handler(u, t):\n    if u[t] is free:\n      temp_u[t] = taken -- A TEMPORARY VERSION\n      return true\n    else:\n      return false\n  commit_handler():\n    copy temp_u[t] to real u[t]\n  abort_handler():\n    discard temp_u[t]\n\nIdea: single entity decides whether to commit\n  to prevent any chance of disagreement\n  let's call it the Transaction Coordinator (TC)\n  [time diagram: client, TC, A, B]\n  client sends RPCs to A, B\n  on end_transaction, client sends \"go\" to TC\n  TC/A/B execute distributed commit protocol...\n  TC reports \"commit\" or \"abort\" to client\n\nWe want two properties for distributed commit protocol:\n  TC, A, and B start in state \"unknown\"\n    each can move to state \"abort\" or \"commit\"\n    but then each never changes mind\n  Correctness:\n    if any commit, none abort\n    if any abort, none commit\n  Performance:\n    (since doing nothing is correct...)\n    if no failures, and A and B can commit, then commit.\n    if failures, come to some conclusion ASAP.\n\nWe're going to develop a protocol called \"two-phase commit\"\n  Used by distributed databases for multi-server transactions\n  And by Spanner and Argus\n\nTwo-phase commit without failures:\n  [time diagram: client, TC, A, B]\n  client sends reserve() RPCs to A, B\n  client sends \"go\" to TC\n  TC sends \"prepare\" messages to A and B.\n  A and B respond, saying whether they're willing to commit.\n    Respond \"yes\" if haven't crashed, timed out, &c.\n  If both say \"yes\", TC sends \"commit\" messages.\n  If either says \"no\", TC sends \"abort\" messages.\n  A/B \"decide to commit\" if they get a commit message.\n    I.e. they actually modify the user's calendar.\n\nWhy is this correct so far?\n  Neither can commit unless they both agreed.\n  Crucial that neither changes mind after responding to prepare\n    Not even if failure\n\nWhat about failures?\n  Network broken/lossy\n  Server crashes\n  Both visible as timeout when expecting a message.\n\nWhere do hosts wait for messages?\n  1) TC waits for yes/no.\n  2) A and B wait for prepare and commit/abort.\n\nTermination protocol summary:\n  TC t/o for yes/no -> abort\n  B t/o for prepare, -> abort\n  B t/o for commit/abort, B voted no -> abort\n  B t/o for commit/abort, B voted yes -> block\n\nTC timeout while waiting for yes/no from A/B.\n  TC has not sent any \"commit\" messages.\n  So TC can safely abort, and send \"abort\" messages.\n\nA/B timeout while waiting for prepare from TC\n  have not yet responded to prepare\n  so can abort\n  respond \"no\" to future prepare\n\nA/B timeout while waiting for commit/abort from TC.\n  Let's talk about just B (A is symmetric).\n  If B voted \"no\", it can unilaterally abort.\n  So what if B voted \"yes\"?\n  Can B unilaterally decide to abort?\n    No! TC might have gotten \"yes\" from both,\n    and sent out \"commit\" to A, but crashed before sending to B.\n    So then A would commit and B would abort: incorrect.\n  B can't unilaterally commit, either:\n    A might have voted \"no\".\n\nIf B voted \"yes\", it must \"block\": wait for TC decision.\n\nWhat if B crashes and restarts?\n  If B sent \"yes\" before crash, B must remember!\n    --- this is today's question\n  Can't change to \"no\" (and thus abort) after restart\n  Since TC may have seen previous yes and told A to commit\n  Thus:\n    B must remember on disk before saying \"yes\", including modified data.\n    B reboots, disk says \"yes\" but no \"commit\", must ask TC.\n    If TC says \"commit\", copy modified data to real data.\n\nWhat if TC crashes and restarts?\n  If TC might have sent \"commit\" or \"abort\" before crash, TC must remember!\n    And repeat that if anyone asks (i.e. if A/B/client didn't get msg).\n    Thus TC must write \"commit\" to disk before sending commit msgs.\n  Can't change mind since A/B/client have already acted.\n\nThis protocol is called \"two-phase commit\".\n  What properties does it have?\n  * All hosts that decide reach the same decision.\n  * No commit unless everyone says \"yes\".\n  * TC failure can make servers block until repair.\n\nWhat about concurrent transactions?\n  We realy want atomic distributed transactions,\n    not just single atomic commit.\n  x and y are bank balances\n  x and y start out as $10\n  T1 is doing a transfer of $1 from x to y\n  T1:\n    add(x, 1)  -- server A\n    add(y, -1) -- server B\n  T2:\n    tmp1 = get(x)\n    tmp2 = get(y)\n    print tmp1, tmp2\n\nProblem:\n  what if T2 runs between the two add() RPCs?\n  then T2 will print 11, 10\n  money will have been created!\n  T2 should print 10,10 or 9,11\n\nThe traditional approach is to provide \"serializability\"\n  results should be as if transactions ran one at a time in some order\n  either T1, then T2; or T2, then T1\n\nWhy serializability?\n  it allows transaction code to ignore the possibility of concurrency\n  just write the transaction to take system from one legal state to another\n  internally, the transaction can temporarily violate invariants\n    but serializability guarantess no-one will notice\n\nOne way to implement serializabilty is with \"two-phase locking\"\n  this is what Argus does\n  each database record has a lock\n  the lock is stored at the server that stores the record\n    no need for a central lock server\n  each use of a record automatically acquires the record's lock\n    thus add() handler implicitly acquires lock when it uses record x or y\n  locks are held until *after* commit or abort \n\nWhy hold locks until after commit/abort?\n  why not release as soon as done with the record?\n  e.g. why not have T2 release x's lock after first get()?\n    T1 could then execute between T2's get()s\n    T2 would print 10,9\n    but that is not a serializable execution: neither T1;T2 nor T2;T1\n\n2PC perspective\n  Used in sharded DBs when a transaction uses data on multiple shards\n  But it has a bad reputation:\n    slow because of multiple phases / message exchanges\n    locks are held over the prepare/commit exchanges\n    TC crash can cause indefinite blocking, with locks held\n  Thus usually used only in a single small domain\n    E.g. not between banks, not between airlines, not over wide area\n\nPaxos and two-phase commit solve different problems!\n  Use Paxos to high availability by replicating\n    i.e. to be able to operate when some servers are crashed\n    the servers must have identical state\n  Use 2PC when each participant does something different\n    And *all* of them must do their part\n  2PC does not help availability\n    since all servers must be up to get anything done\n  Paxos does not ensure that all servers do something\n    since only a majority have to be alive\n\nWhat if you want high availability *and* distributed commit?\n  [diagram]\n  Each \"server\" should be a Paxos-replicated service\n  And the TC should be Paxos-replicated\n  Run two-phase commit where each participant is a replicated service\n  Then you can tolerate failures and still make progress\n  This is what Spanner does (for update transactions)\n\nCase study: Argus\n\nArgus's big ideas:\n  Language support for distributed programs\n    Very cool: language abstracts away ugly parts of distrib systems\n    Aimed at different servers doing different jobs, cooperating\n  Easy fault tolerance:\n    Transactional updates\n    So crash results in entire transaction un-done, not partial update\n  Easy persistence (\"stable\"):\n    Ordinary variables automatically persisted to disk\n    Automatic crash recovery\n  Easy concurrency:\n    Implicit locking of language objects\n  Easy RPC model:\n    Method calls transparently turned into RPCs\n    RPC failure largely hidden via transactions, two-phase commit\n\nWe've seen the fundamental problem before\n  What to do if *part* of a distributed computation crashes?\n  IVY/Treadmarks had no answer\n  MR/Spark could re-execute *part* of computation, for big data\n\nPicture\n  \"guardian\" is like an RPC server\n    has state (variables) and handlers\n  \"handler\" is an RPC handler\n    reads and writes local variables\n  \"action\" is a distributed atomic transaction\n  action on A\n    A RPC to B\n      B RPC to C\n    A RPC to D\n  A finishes action\n    prepare msgs to B, C, D\n    commit msgs to B, C, D\n\nThe style is to send RPC to where the data is\n  Not to fetch the data\n  Argus is not a storage system\n\nLook at bank example\n  page 309 (and 306): bank transfer\n\nPoints to notice\n  stable keyword (programmer never writes to disk &c)\n  atomic keyword (programmer almost never locks/unlocks)\n  enter topaction (in transfer)\n  coenter (in transfer)\n  RPCs are hidden (e.g. f.withdraw())\n  RPC error handling hidden (just aborts)\n\nwhat if deposit account doesn't exist?\n  but f.withdraw(from) has already been called?\n  how to un-do?\n  what's the guardian state when withdraw() handler returns?\n    lock, temporary version, just in memory\n\nwhat if an audit runs during a transfer?\n  how does the audit not see the tentative new balances?\n\nif a guardian crashes and reboots, what happens to its locks?\n  can it just forget about pre-crash locks?\n\nsubactions\n  each RPC is actually a sub-action\n  the RPC can fail or abort w/o aborting surrounding action\n  this lets actions e.g. try one server, then another\n  if RPC reply lost, subaction will abort, undo\n    much cleaner than e.g. Go RPC\n\nis Argus's implicit locking the right thing?\n  very convenient!\n  don't have to worry about forgetting to lock!\n  (though deadlocks are easy)\n  databases work (and worked) this way; it's a sucessful idea\n\nis transactions + RPC + 2PC a good design point?\n  programmability pro:\n    very easy to get nice fault tolerance semantics\n  performance con:\n    lots of msgs and disk writes\n    2PC and 2PL hold locks for a while, block if failure\n\nis Argus's language integration the right thing?\n  i.e. persisting and locking language objects\n  it looks very convenient (and it is)\n  but it turns out to be even more valuable have relational tables\n    people like queries/joins/&c over tables, rows, columns\n    that is, people like a storage abstraction!\n  maybe there is a better language-based scheme waiting to be found \n```"]