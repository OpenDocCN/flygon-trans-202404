- en: Thrashing and Working Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lecture Notes for CS 140
  prefs: []
  type: TYPE_NORMAL
- en: Spring 2014
  prefs: []
  type: TYPE_NORMAL
- en: John Ousterhout
  prefs: []
  type: TYPE_NORMAL
- en: 'Readings for this topic from *Operating Systems: Principles and Practice*:
    Section 9.7.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, if a thread takes a page fault and must wait for the page to be read
    from disk, the operating system runs a different thread while the I/O is occurring.
    Thus page faults are "free"?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if memory gets overcommitted?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose the pages being actively used by the current threads don't all fit in
    physical memory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each page fault causes one of the active pages to be moved to disk, so another
    page fault will occur soon.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The system will spend all its time reading and writing pages, and won't get
    much work done.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This situation is called *thrashing*; it was a serious problem in early demand
    paging systems.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to deal with thrashing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a single process is too large for memory, there is nothing the OS can do.
    That process will simply thrash.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the problem arises because of the sum of several processes:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure out how much memory each process needs to prevent thrashing. This is
    called its *working set*.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Only allow a few processes to execute at a time, such that their working sets
    fit in memory.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Page fault frequency*: one technique for computing working sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At any given time, each process is allocated a fixed number of physical page
    frames (assumes per-process replacement).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor the rate at which page faults are occurring for each process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the rate gets too high for a process, assume that its memory is overcommitted;
    increase the size of its memory pool.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the rate gets too low for a process, assume that its memory pool can be reduced
    in size.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling with working sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the sum of all working sets of all processes exceeds the size of memory,
    then stop running some of the processes for a while.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Divide processes into two groups: active and inactive:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a process is active its entire working set must always be in memory: never
    execute a thread whose working set is not resident.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When a process becomes inactive, its working set can migrate to disk.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads from inactive processes are never scheduled for execution.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection of active processes is called the *balance set*.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The system must have a mechanism for gradually moving processes into and out
    of the balance set.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As working sets change, the balance set must be adjusted.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'None of these solutions is very good:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a process becomes inactive, it has to stay inactive for a long time (many
    seconds), which results in poor response for the user.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling the balance set is tricky.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In practice, today''s operating systems don''t worry much about thrashing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With personal computers, users can notice thrashing and handle it themselves:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, just buy more memory
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, manage balance set by hand
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory is cheap enough that there's no point in operating a machine in in a
    range where memory is even slightly overcommitted; better to just buy more memory.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thrashing was a bigger issue for timesharing machines with dozens or hundreds
    of users:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Why should I stop my processes just so you can make progress?
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: System had to handle thrashing automatically.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
