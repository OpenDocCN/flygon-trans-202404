["```\n\n```", "```\n\n    In a machine-checked proof, every single detail has to be\n    justified.  This can result in huge proof scripts. Fortunately,\n    Coq comes with a proof-search mechanism and with several decision\n    procedures that enable the system to automatically synthesize\n    simple pieces of proof. Automation is very powerful when set up\n    appropriately. The purpose of this chapter is to explain the\n    basics of working of automation.\n\n    The chapter is organized in two parts. The first part focuses on a\n    general mechanism called \"proof search.\" In short, proof search\n    consists in naively trying to apply lemmas and assumptions in all\n    possible ways. The second part describes \"decision procedures\",\n    which are tactics that are very good at solving proof obligations\n    that fall in some particular fragment of the logic of Coq.\n\n    Many of the examples used in this chapter consist of small lemmas\n    that have been made up to illustrate particular aspects of automation.\n    These examples are completely independent from the rest of the Software\n    Foundations course. This chapter also contains some bigger examples\n    which are used to explain how to use automation in realistic proofs.\n    These examples are taken from other chapters of the course (mostly\n    from STLC), and the proofs that we present make use of the tactics\n    from the library LibTactics.v, which is presented in the chapter\n    UseTactics.\n\n```", "```\n\n# Basic Features of Proof Search\n\n    The idea of proof search is to replace a sequence of tactics\n    applying lemmas and assumptions with a call to a single tactic,\n    for example auto. This form of proof automation saves a lot of\n    effort. It typically leads to much shorter proof scripts, and to\n    scripts that are typically more robust to change.  If one makes a\n    little change to a definition, a proof that exploits automation\n    probably won't need to be modified at all. Of course, using too\n    much automation is a bad idea.  When a proof script no longer\n    records the main arguments of a proof, it becomes difficult to fix\n    it when it gets broken after a change in a definition. Overall, a\n    reasonable use of automation is generally a big win, as it saves a\n    lot of time both in building proof scripts and in subsequently\n    maintaining those proof scripts.\n\n```", "```\n\n## Basics\n\n    The tactic auto is able to solve a goal that can be proved\n    using a sequence of intros, apply, assumption, and reflexivity.\n    Two examples follow. The first one shows the ability for\n    auto to call reflexivity at any time. In fact, calling\n    reflexivity is always the first thing that auto tries to do.\n\n```", "```\n\n    The second example illustrates a proof where a sequence of\n    two calls to apply are needed. The goal is to prove that\n    if Q n implies P n for any n and if Q n holds for any n,\n    then P 2 holds.\n\n```", "```\n\n    If we are interested to see which proof auto came up with,\n    one possibility is to look at the generated proof-term,\n    using the command:\n\n    Print solving_by_apply. \n\n    The proof term is:\n\n    fun (P Q : nat \u2192 Prop) (H : \u2200 n : nat, Q n \u2192 P n) (H[0] : \u2200 n : nat, Q n) \u21d2 H 2 (H[0] 2) \n\n    This essentially means that auto applied the hypothesis H\n   (the first one), and then applied the hypothesis H[0] (the\n   second one).\n\n    The tactic auto can invoke apply but not eapply. So, auto\n    cannot exploit lemmas whose instantiation cannot be directly\n    deduced from the proof goal. To exploit such lemmas, one needs to\n    invoke the tactic eauto, which is able to call eapply.\n\n    In the following example, the first hypothesis asserts that P n\n    is true when Q m is true for some m, and the goal is to prove\n    that Q 1 implies P 2.  This implication follows direction from\n    the hypothesis by instantiating m as the value 1.  The\n    following proof script shows that eauto successfully solves the\n    goal, whereas auto is not able to do so.\n\n```", "```\n\n## Conjunctions\n\n    So far, we've seen that eauto is stronger than auto in the\n    sense that it can deal with eapply. In the same way, we are going\n    to see how jauto and iauto are stronger than auto and eauto\n    in the sense that they provide better support for conjunctions. \n\n    The tactics auto and eauto can prove a goal of the form\n    F \u2227 F', where F and F' are two propositions, as soon as\n    both F and F' can be proved in the current context.\n    An example follows.\n\n```", "```\n\n    However, when an assumption is a conjunction, auto and eauto\n    are not able to exploit this conjunction. It can be quite\n    surprising at first that eauto can prove very complex goals but\n    that it fails to prove that F \u2227 F' implies F. The tactics\n    iauto and jauto are able to decompose conjunctions from the context.\n    Here is an example.\n\n```", "```\n\n    The tactic jauto is implemented by first calling a\n    pre-processing tactic called jauto_set, and then calling\n    eauto. So, to understand how jauto works, one can directly\n    call the tactic jauto_set.\n\n```", "```\n\n    Next is a more involved goal that can be solved by iauto and\n    jauto.\n\n```", "```\n\n    The strategy of iauto and jauto is to run a global analysis of\n    the top-level conjunctions, and then call eauto.  For this\n    reason, those tactics are not good at dealing with conjunctions\n    that occur as the conclusion of some universally quantified\n    hypothesis. The following example illustrates a general weakness\n    of Coq proof search mechanisms.\n\n```", "```\n\n    This situation is slightly disappointing, since automation is\n    able to prove the following goal, which is very similar. The\n    only difference is that the universal quantification has been\n    distributed over the conjunction.\n\n```", "```\n\n## Disjunctions\n\n    The tactics auto and eauto can handle disjunctions that\n    occur in the goal.\n\n```", "```\n\n    However, only iauto is able to automate reasoning on the\n    disjunctions that appear in the context. For example, iauto can\n    prove that F \u2228 F' entails F' \u2228 F.\n\n```", "```\n\n    More generally, iauto can deal with complex combinations of\n    conjunctions, disjunctions, and negations. Here is an example.\n\n```", "```\n\n    However, the ability of iauto to automatically perform a case\n    analysis on disjunctions comes with a downside: iauto may be\n    very slow. If the context involves several hypotheses with\n    disjunctions, iauto typically generates an exponential number of\n    subgoals on which eauto is called. One major advantage of jauto\n    compared with iauto is that it never spends time performing this\n    kind of case analyses.\n\n```", "```\nLemma solving_exists_goal : \u2200(f : nat\u2192Prop),\n\u00a0\u00a0f 2 \u2192 \u2203x, f x.\nProof.\n\u00a0\u00a0auto. (*\u00a0observe\u00a0that\u00a0auto\u00a0does\u00a0not\u00a0deal\u00a0with\u00a0existentials,\u00a0*)\n\u00a0\u00a0eauto. (*\u00a0whereas\u00a0eauto,\u00a0iauto\u00a0and\u00a0jauto\u00a0solve\u00a0the\u00a0goal\u00a0*)\nQed.\n\n```", "```\nLemma solving_exists_hyp : \u2200(f g : nat\u2192Prop),\n\u00a0\u00a0(\u2200x, f x \u2192 g x) \u2192\n\u00a0\u00a0(\u2203a, f a) \u2192\n\u00a0\u00a0(\u2203a, g a).\nProof.\n\u00a0\u00a0auto. eauto. iauto. (*\u00a0All\u00a0of\u00a0these\u00a0tactics\u00a0fail,\u00a0*)\n\u00a0\u00a0jauto. (*\u00a0whereas\u00a0jauto\u00a0succeeds.\u00a0*)\n\u00a0\u00a0(*\u00a0For\u00a0the\u00a0details,\u00a0run\u00a0intros. jauto_set. eauto\u00a0*)\nQed.\n\n```", "```\nLemma negation_study_1 : \u2200(P : nat\u2192Prop),\n\u00a0\u00a0P 0 \u2192 (\u2200x, \u00ac P x) \u2192 False.\nProof.\n\u00a0\u00a0intros P H[0] HX.\n\u00a0\u00a0eauto. (*\u00a0It\u00a0fails\u00a0to\u00a0see\u00a0that\u00a0HX\u00a0applies\u00a0*)\n\u00a0\u00a0unfold not in *. eauto.\nQed.\n\n```", "```\nLemma negation_study_2 : \u2200(P : nat\u2192Prop),\n\u00a0\u00a0P 0 \u2192 (\u2200x, \u00ac P x) \u2192 False.\nProof. jauto. (*\u00a0or\u00a0iauto\u00a0*) Qed.\n\n```", "```\n\n## Equalities\n\n    Coq's proof-search feature is not good at exploiting equalities.\n    It can do very basic operations, like exploiting reflexivity\n    and symmetry, but that's about it. Here is a simple example\n    that auto can solve, by first calling symmetry and then\n    applying the hypothesis.\n\n```", "```\n\n    To automate more advanced reasoning on equalities, one should\n    rather try to use the tactic congruence, which is presented at\n    the end of this chapter in the \"Decision Procedures\" section.\n\n```", "```\n\n## Search Depth\n\n    The tactic auto works as follows.  It first tries to call\n    reflexivity and assumption. If one of these calls solves the\n    goal, the job is done. Otherwise auto tries to apply the most\n    recently introduced assumption that can be applied to the goal\n    without producing and error. This application produces\n    subgoals. There are two possible cases. If the sugboals produced\n    can be solved by a recursive call to auto, then the job is done.\n    Otherwise, if this application produces at least one subgoal that\n    auto cannot solve, then auto starts over by trying to apply\n    the second most recently introduced assumption. It continues in a\n    similar fashion until it finds a proof or until no assumption\n    remains to be tried.\n\n    It is very important to have a clear idea of the backtracking\n    process involved in the execution of the auto tactic; otherwise\n    its behavior can be quite puzzling. For example, auto is not\n    able to solve the following triviality.\n\n```", "```\n\n    The reason auto fails to solve the goal is because there are\n    too many conjunctions. If there had been only five of them, auto\n    would have successfully solved the proof, but six is too many.\n    The tactic auto limits the number of lemmas and hypotheses\n    that can be applied in a proof, so as to ensure that the proof\n    search eventually terminates. By default, the maximal number\n    of steps is five. One can specify a different bound, writing\n    for example auto 6 to search for a proof involving at most\n    six steps. For example, auto 6 would solve the previous lemma.\n    (Similarly, one can invoke eauto 6 or intuition eauto 6.)\n    The argument n of auto n is called the \"search depth.\"\n    The tactic auto is simply defined as a shorthand for auto 5.\n\n    The behavior of auto n can be summarized as follows. It first\n    tries to solve the goal using reflexivity and assumption. If\n    this fails, it tries to apply a hypothesis (or a lemma that has\n    been registered in the hint database), and this application\n    produces a number of sugoals. The tactic auto (n-1) is then\n    called on each of those subgoals. If all the subgoals are solved,\n    the job is completed, otherwise auto n tries to apply a\n    different hypothesis.\n\n    During the process, auto n calls auto (n-1), which in turn\n    might call auto (n-2), and so on. The tactic auto 0 only\n    tries reflexivity and assumption, and does not try to apply\n    any lemma. Overall, this means that when the maximal number of\n    steps allowed has been exceeded, the auto tactic stops searching\n    and backtracks to try and investigate other paths. \n\n    The following lemma admits a unique proof that involves exactly\n    three steps. So, auto n proves this goal iff n is greater than\n    three.\n\n```", "```\n\n    We can generalize the example by introducing an assumption\n    asserting that P k is derivable from P (k-1) for all k,\n    and keep the assumption P 0. The tactic auto, which is the\n    same as auto 5, is able to derive P k for all values of k\n    less than 5\\. For example, it can prove P 4.\n\n```", "```\n\n    However, to prove P 5, one needs to call at least auto 6.\n\n```", "```\n\n    Because auto looks for proofs at a limited depth, there are\n    cases where auto can prove a goal F and can prove a goal\n    F' but cannot prove F \u2227 F'. In the following example,\n    auto can prove P 4 but it is not able to prove P 4 \u2227 P 4,\n    because the splitting of the conjunction consumes one proof step.\n    To prove the conjunction, one needs to increase the search depth,\n    using at least auto 6.\n\n```", "```\n\n## Backtracking\n\n    In the previous section, we have considered proofs where\n    at each step there was a unique assumption that auto\n    could apply. In general, auto can have several choices\n    at every step. The strategy of auto consists of trying all\n    of the possibilities (using a depth-first search exploration).\n\n    To illustrate how automation works, we are going to extend the\n    previous example with an additional assumption asserting that\n    P k is also derivable from P (k+1). Adding this hypothesis\n    offers a new possibility that auto could consider at every step.\n\n    There exists a special command that one can use for tracing\n    all the steps that proof-search considers. To view such a\n    trace, one should write debug eauto. (For some reason, the\n    command debug auto does not exist, so we have to use the\n    command debug eauto instead.)\n\n```", "```\n\n    The output message produced by debug eauto is as follows.\n\n```", "```\n\n    The depth indicates the value of n with which eauto n is\n    called. The tactics shown in the message indicate that the first\n    thing that eauto has tried to do is to apply H[2]. The effect of\n    applying H[2] is to replace the goal P 2 with the goal P 1.\n    Then, again, H[2] has been applied, changing the goal P 1 into\n    P 0. At that point, the goal was exactly the hypothesis H[1].\n\n    It seems that eauto was quite lucky there, as it never even\n    tried to use the hypothesis H[3] at any time. The reason is that\n    auto always tried to use the H[2] first. So, let's permute\n    the hypotheses H[2] and H[3] and see what happens.\n\n```", "```\n\n    This time, the output message suggests that the proof search\n    investigates many possibilities. If we print the proof term:\n\n    Print working_of_auto_2. \n\n    we observe that the proof term refers to H[3]. Thus the proof\n    is not the simplest one, since only H[2] and H[1] are needed.\n\n    In turns out that the proof goes through the proof obligation P 3, \n    even though it is not required to do so. The following tree drawing\n    describes all the goals that eauto has been going through.\n\n```", "```\n\n    The first few lines read as follows. To prove P 2, eauto 5\n    has first tried to apply H[3], producing the subgoal P 3.\n    To solve it, eauto 4 has tried again to apply H[3], producing\n    the goal P 4. Similarly, the search goes through P 5, P 6\n    and P 7. When reaching P 7, the tactic eauto 0 is called\n    but as it is not allowed to try and apply any lemma, it fails.\n    So, we come back to the goal P 6, and try this time to apply\n    hypothesis H[2], producing the subgoal P 5. Here again,\n    eauto 0 fails to solve this goal.\n\n    The process goes on and on, until backtracking to P 3 and trying\n    to apply H[3] three times in a row, going through P 2 and P 1\n    and P 0. This search tree explains why eauto came up with a\n    proof term starting with an application of H[3].\n\n```", "```\nHint Resolve Le.le_refl.\n\n```", "```\n\n## Integration of Automation in Tactics\n\n    The library \"LibTactics\" introduces a convenient feature for\n    invoking automation after calling a tactic. In short, it suffices\n    to add the symbol star (*) to the name of a tactic. For example,\n    apply* H is equivalent to apply H; auto_star, where auto_star\n    is a tactic that can be defined as needed.\n\n    The definition of auto_star, which determines the meaning of the\n    star symbol, can be modified whenever needed. Simply write:\n\n```", "```\nLtac auto_star ::= try solve [ jauto ].\n\n```", "```\nLtac auto_tilde ::= auto.\n\n```", "```\n\n# Examples of Use of Automation\n\n    Let's see how to use proof search in practice on the main theorems\n    of the \"Software Foundations\" course, proving in particular\n    results such as determinism, preservation and progress.\n\n```", "```\nModule DeterministicImp.\n\u00a0\u00a0Require Import Imp.\n\n```", "```\nTheorem ceval_deterministic: \u2200c st st[1] st[2],\n\u00a0\u00a0c / st \u21d3 st[1] \u2192\n\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0intros c st st[1] st[2] E[1] E[2].\n\u00a0\u00a0generalize dependent st[2].\n\u00a0\u00a0(induction E[1]); intros st[2] E[2]; inversion E[2]; subst.\n\u00a0\u00a0- (*\u00a0E_Skip\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a0E_Ass\u00a0*) reflexivity.\n\u00a0\u00a0- (*\u00a0E_Seq\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1].\n\u00a0\u00a0\u00a0\u00a0{ (*\u00a0Proof\u00a0of\u00a0assertion\u00a0*) apply IHE1_1; assumption. }\n\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0apply IHE1_2. assumption.\n\u00a0\u00a0(*\u00a0E_IfTrue\u00a0*)\n\u00a0\u00a0- (*\u00a0b[1]\u00a0reduces\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply IHE1. assumption.\n\u00a0\u00a0- (*\u00a0b[1]\u00a0reduces\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[5]. inversion H[5].\n\u00a0\u00a0(*\u00a0E_IfFalse\u00a0*)\n\u00a0\u00a0- (*\u00a0b[1]\u00a0reduces\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[5]. inversion H[5].\n\u00a0\u00a0- (*\u00a0b[1]\u00a0reduces\u00a0to\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply IHE1. assumption.\n\u00a0\u00a0(*\u00a0E_WhileEnd\u00a0*)\n\u00a0\u00a0- (*\u00a0b[1]\u00a0reduces\u00a0to\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0reflexivity.\n\u00a0\u00a0- (*\u00a0b[1]\u00a0reduces\u00a0to\u00a0false\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[2]. inversion H[2].\n\u00a0\u00a0(*\u00a0E_WhileLoop\u00a0*)\n\u00a0\u00a0- (*\u00a0b[1]\u00a0reduces\u00a0to\u00a0true\u00a0(contradiction)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite H in H[4]. inversion H[4].\n\u00a0\u00a0- (*\u00a0b[1]\u00a0reduces\u00a0to\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0assert (st' = st'0) as EQ[1].\n\u00a0\u00a0\u00a0\u00a0{ (*\u00a0Proof\u00a0of\u00a0assertion\u00a0*) apply IHE1_1; assumption. }\n\u00a0\u00a0\u00a0\u00a0subst st'0.\n\u00a0\u00a0\u00a0\u00a0apply IHE1_2. assumption.\nQed.\n\n```", "```\nTheorem ceval_deterministic': \u2200c st st[1] st[2],\n\u00a0\u00a0c / st \u21d3 st[1] \u2192\n\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\nAdmitted.\n\n```", "```\nTheorem ceval_deterministic'': \u2200c st st[1] st[2],\n\u00a0\u00a0c / st \u21d3 st[1] \u2192\n\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0introv E[1] E[2]. gen st[2].\n\u00a0\u00a0induction E[1]; intros; inverts E[2]; tryfalse.\n\u00a0\u00a0- auto.\n\u00a0\u00a0- auto.\n\u00a0\u00a0- assert (st' = st'0). auto. subst. auto.\n\u00a0\u00a0- auto.\n\u00a0\u00a0- auto.\n\u00a0\u00a0- auto.\n\u00a0\u00a0- assert (st' = st'0). auto. subst. auto.\nQed.\n\n```", "```\nTheorem ceval_deterministic''': \u2200c st st[1] st[2],\n\u00a0\u00a0c / st \u21d3 st[1] \u2192\n\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0(*\u00a0Let's\u00a0replay\u00a0the\u00a0proof\u00a0up\u00a0to\u00a0the\u00a0assert\u00a0tactic.\u00a0*)\n\u00a0\u00a0introv E[1] E[2]. gen st[2].\n\u00a0\u00a0induction E[1]; intros; inverts E[2]; tryfalse.\n\u00a0\u00a0- auto.\n\u00a0\u00a0- auto.\n\u00a0\u00a0(*\u00a0We\u00a0duplicate\u00a0the\u00a0goal\u00a0for\u00a0comparing\u00a0different\u00a0proofs.\u00a0*)\n\u00a0\u00a0- dup 4.\n\n\u00a0\u00a0(*\u00a0The\u00a0old\u00a0proof:\u00a0*)\n\u00a0\u00a0+ assert (st' = st'0). apply IHE1_1. apply H[1].\n\u00a0\u00a0\u00a0\u00a0(*\u00a0produces\u00a0H: st' = st'0.\u00a0*) skip.\n\n\u00a0\u00a0(*\u00a0The\u00a0new\u00a0proof,\u00a0without\u00a0automation:\u00a0*)\n\u00a0\u00a0+ forwards: IHE1_1. apply H[1].\n\u00a0\u00a0\u00a0\u00a0(*\u00a0produces\u00a0H: st' = st'0.\u00a0*) skip.\n\n\u00a0\u00a0(*\u00a0The\u00a0new\u00a0proof,\u00a0with\u00a0automation:\u00a0*)\n\u00a0\u00a0+ forwards: IHE1_1. eauto.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0produces\u00a0H: st' = st'0.\u00a0*) skip.\n\n\u00a0\u00a0(*\u00a0The\u00a0new\u00a0proof,\u00a0with\u00a0integrated\u00a0automation:\u00a0*)\n\u00a0\u00a0+ forwards*: IHE1_1.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0produces\u00a0H: st' = st'0.\u00a0*) skip.\n\nAbort.\n\n```", "```\nTheorem ceval_deterministic'''': \u2200c st st[1] st[2],\n\u00a0\u00a0c / st \u21d3 st[1]  \u2192\n\u00a0\u00a0c / st \u21d3 st[2] \u2192\n\u00a0\u00a0st[1] = st[2].\nProof.\n\u00a0\u00a0introv E[1] E[2]. gen st[2].\n\u00a0\u00a0induction E[1]; intros; inverts* E[2]; tryfalse.\n\u00a0\u00a0- forwards*: IHE1_1. subst*.\n\u00a0\u00a0- forwards*: IHE1_1. subst*.\nQed.\n\nEnd DeterministicImp.\n\n```", "```\nModule PreservationProgressStlc.\n\u00a0\u00a0Require Import StlcProp.\n\u00a0\u00a0Import STLC.\n\u00a0\u00a0Import STLCProp.\n\n```", "```\nTheorem preservation : \u2200t t' T,\n\u00a0\u00a0has_type empty t T  \u2192\n\u00a0\u00a0t \u21d2 t'  \u2192\n\u00a0\u00a0has_type empty t' T.\nProof with eauto.\n\u00a0\u00a0remember (@empty ty) as \u0393.\n\u00a0\u00a0intros t t' T HT. generalize dependent t'.\n\u00a0\u00a0(induction HT); intros t' HE; subst \u0393.\n\u00a0\u00a0- (*\u00a0T_Var\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion HE.\n\u00a0\u00a0- (*\u00a0T_Abs\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion HE.\n\u00a0\u00a0- (*\u00a0T_App\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion HE; subst...\n\u00a0\u00a0\u00a0\u00a0(*\u00a0The\u00a0ST_App1\u00a0and\u00a0ST_App2\u00a0cases\u00a0are\u00a0immediate\u00a0by\u00a0induction,\u00a0and \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0auto\u00a0takes\u00a0care\u00a0of\u00a0them\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0ST_AppAbs\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply substitution_preserves_typing with T[11]...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion HT[1]...\n\u00a0\u00a0- (*\u00a0T_True\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion HE.\n\u00a0\u00a0- (*\u00a0T_False\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion HE.\n\u00a0\u00a0- (*\u00a0T_If\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion HE; subst...\nQed.\n\n```", "```\nTheorem preservation' : \u2200t t' T,\n\u00a0\u00a0has_type empty t T  \u2192\n\u00a0\u00a0t \u21d2 t'  \u2192\n\u00a0\u00a0has_type empty t' T.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\nAdmitted.\n\n```", "```\nTheorem progress : \u2200t T,\n\u00a0\u00a0has_type empty t T \u2192\n\u00a0\u00a0value t \u2228 \u2203t', t \u21d2 t'.\nProof with eauto.\n\u00a0\u00a0intros t T Ht.\n\u00a0\u00a0remember (@empty ty) as \u0393.\n\u00a0\u00a0(induction Ht); subst \u0393...\n\u00a0\u00a0- (*\u00a0T_Var\u00a0*)\n\u00a0\u00a0\u00a0\u00a0inversion H.\n\u00a0\u00a0- (*\u00a0T_App\u00a0*)\n\u00a0\u00a0\u00a0\u00a0right. destruct IHHt1...\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0t[1]\u00a0is\u00a0a\u00a0value\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct IHHt2...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0t[2]\u00a0is\u00a0a\u00a0value\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion H; subst; try solve_by_invert.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2203([x[0]:=t[2]]t)...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* (*\u00a0t[2]\u00a0steps\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct H[0] as [t[2]' Hstp]. \u2203(tapp t[1] t[2]')...\n\u00a0\u00a0\u00a0\u00a0+ (*\u00a0t[1]\u00a0steps\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct H as [t[1]' Hstp]. \u2203(tapp t[1]' t[2])...\n\u00a0\u00a0- (*\u00a0T_If\u00a0*)\n\u00a0\u00a0\u00a0\u00a0right. destruct IHHt1...\n\u00a0\u00a0\u00a0\u00a0destruct t[1]; try solve_by_invert...\n\u00a0\u00a0\u00a0\u00a0inversion H. \u2203(tif x[0] t[2] t[3])...\nQed.\n\n```", "```\nTheorem progress' : \u2200t T,\n\u00a0\u00a0has_type empty t T \u2192\n\u00a0\u00a0value t \u2228 \u2203t', t \u21d2 t'.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\nAdmitted.\n\nEnd PreservationProgressStlc.\n\n```", "```\nModule Semantics.\nRequire Import Smallstep.\n\n```", "```\nTheorem multistep__eval : \u2200t v,\n\u00a0\u00a0normal_form_of t v \u2192 \u2203n, v = C n \u2227 t \u21d3 n.\nProof.\n\u00a0\u00a0intros t v Hnorm.\n\u00a0\u00a0unfold normal_form_of in Hnorm.\n\u00a0\u00a0inversion Hnorm as [Hs Hnf]; clear Hnorm.\n\u00a0\u00a0rewrite nf_same_as_value in Hnf. inversion Hnf. clear Hnf.\n\u00a0\u00a0\u2203n. split. reflexivity.\n\u00a0\u00a0induction Hs; subst.\n\u00a0\u00a0- (*\u00a0multi_refl\u00a0*)\n\u00a0\u00a0\u00a0\u00a0apply E_Const.\n\u00a0\u00a0- (*\u00a0multi_step\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply step__eval. eassumption. apply IHHs. reflexivity.\nQed.\n\n```", "```\nTheorem multistep_eval_ind : \u2200t v,\n\u00a0\u00a0t \u21d2* v \u2192 \u2200n, C n = v \u2192 t \u21d3 n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\nAdmitted.\n\n```", "```\nTheorem multistep__eval' : \u2200t v,\n\u00a0\u00a0normal_form_of t v \u2192 \u2203n, v = C n \u2227 t \u21d3 n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\nAdmitted.\n\n```", "```\nRequire Import Program.\n\n```", "```\nTheorem multistep__eval'' : \u2200t v,\n\u00a0\u00a0normal_form_of t v \u2192 \u2203n, v = C n \u2227 t \u21d3 n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\nAdmitted.\n\nEnd Semantics.\n\n```", "```\nModule PreservationProgressReferences.\n\u00a0\u00a0Require Import Coq.omega.Omega.\n\u00a0\u00a0Require Import References.\n\u00a0\u00a0Import STLCRef.\n\u00a0\u00a0Hint Resolve store_weakening extends_refl.\n\n```", "```\nTheorem preservation : \u2200ST t t' T st st',\n\u00a0\u00a0has_type empty ST t T \u2192\n\u00a0\u00a0store_well_typed ST st \u2192\n\u00a0\u00a0t / st \u21d2 t' / st' \u2192\n\u00a0\u00a0\u2203ST',\n\u00a0\u00a0\u00a0\u00a0(extends ST' ST \u2227\n\u00a0\u00a0\u00a0\u00a0\u00a0has_type empty ST' t' T \u2227\n\u00a0\u00a0\u00a0\u00a0\u00a0store_well_typed ST' st').\nProof.\n\u00a0\u00a0(*\u00a0old:\u00a0Proof. with eauto using store_weakening, extends_refl. \u00a0\u00a0\u00a0\u00a0\u00a0new:\u00a0Proof.,\u00a0and\u00a0the\u00a0two\u00a0lemmas\u00a0are\u00a0registered\u00a0as\u00a0hints \u00a0\u00a0\u00a0\u00a0\u00a0before\u00a0the\u00a0proof\u00a0of\u00a0the\u00a0lemma,\u00a0possibly\u00a0inside\u00a0a\u00a0section\u00a0in \u00a0\u00a0\u00a0\u00a0\u00a0order\u00a0to\u00a0restrict\u00a0the\u00a0scope\u00a0of\u00a0the\u00a0hints.\u00a0*)\n\n\u00a0\u00a0remember (@empty ty) as \u0393. introv Ht. gen t'.\n\u00a0\u00a0(induction Ht); introv HST Hstep;\n\u00a0\u00a0\u00a0\u00a0(*\u00a0old:\u00a0subst; try solve_by_invert; inversion Hstep; subst; try (eauto using store_weakening, extends_refl) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new:\u00a0subst \u0393; inverts Hstep; eauto. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0We\u00a0want\u00a0to\u00a0be\u00a0more\u00a0precise\u00a0on\u00a0what\u00a0exactly\u00a0we\u00a0substitute, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0and\u00a0we\u00a0do\u00a0not\u00a0want\u00a0to\u00a0call\u00a0try solve_by_invert\u00a0which \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0is\u00a0way\u00a0to\u00a0slow.\u00a0*)\n\u00a0\u00a0\u00a0subst \u0393; inverts Hstep; eauto.\n\n\u00a0\u00a0(*\u00a0T_App\u00a0*)\n\u00a0\u00a0- (*\u00a0ST_AppAbs\u00a0*)\n\u00a0\u00a0(*\u00a0old: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exists\u00a0ST.\u00a0inversion\u00a0Ht[1];\u00a0subst. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0split;\u00a0try\u00a0split...\u00a0eapply\u00a0substitution_preserves_typing...\u00a0*)\n\u00a0\u00a0(*\u00a0new:\u00a0we\u00a0use\u00a0inverts\u00a0in\u00a0place\u00a0of\u00a0inversion\u00a0and\u00a0splits\u00a0to \u00a0\u00a0\u00a0\u00a0\u00a0split\u00a0the\u00a0conjunction,\u00a0and\u00a0applys*\u00a0in\u00a0place\u00a0of\u00a0eapply...\u00a0*)\n\u00a0\u00a0\u2203ST. inverts Ht[1]. splits*. applys* substitution_preserves_typing.\n\n\u00a0\u00a0- (*\u00a0ST_App1\u00a0*)\n\u00a0\u00a0(*\u00a0old: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply\u00a0IHHt1\u00a0in\u00a0H[0]... \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion\u00a0H[0]\u00a0as\u00a0ST' [Hext [Hty Hsty]]. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exists\u00a0ST'...\u00a0*)\n\u00a0\u00a0(*\u00a0new:\u00a0The\u00a0tactic\u00a0eapply IHHt1 in H[0]...\u00a0applies\u00a0IHHt1\u00a0to\u00a0H[0]. \u00a0\u00a0\u00a0\u00a0\u00a0But\u00a0H[0]\u00a0is\u00a0only\u00a0thing\u00a0that\u00a0IHHt1\u00a0could\u00a0be\u00a0applied\u00a0to,\u00a0so \u00a0\u00a0\u00a0\u00a0\u00a0there\u00a0eauto\u00a0can\u00a0figure\u00a0this\u00a0out\u00a0on\u00a0its\u00a0own.\u00a0The\u00a0tactic \u00a0\u00a0\u00a0\u00a0\u00a0forwards\u00a0is\u00a0used\u00a0to\u00a0instantiate\u00a0all\u00a0the\u00a0arguments\u00a0of\u00a0IHHt1, \u00a0\u00a0\u00a0\u00a0\u00a0producing\u00a0existential\u00a0variables\u00a0and\u00a0subgoals\u00a0when\u00a0needed.\u00a0*)\n\u00a0\u00a0forwards: IHHt1. eauto. eauto. eauto.\n\u00a0\u00a0(*\u00a0At\u00a0this\u00a0point,\u00a0we\u00a0need\u00a0to\u00a0decompose\u00a0the\u00a0hypothesis\u00a0H\u00a0that\u00a0has \u00a0\u00a0\u00a0\u00a0\u00a0just\u00a0been\u00a0created\u00a0by\u00a0forwards.\u00a0This\u00a0is\u00a0done\u00a0by\u00a0the\u00a0first\u00a0part \u00a0\u00a0\u00a0\u00a0\u00a0of\u00a0the\u00a0preprocessing\u00a0phase\u00a0of\u00a0jauto.\u00a0*)\n\u00a0\u00a0jauto_set_hyps; intros.\n\u00a0\u00a0(*\u00a0It\u00a0remains\u00a0to\u00a0decompose\u00a0the\u00a0goal,\u00a0which\u00a0is\u00a0done\u00a0by\u00a0the\u00a0second \u00a0\u00a0\u00a0\u00a0\u00a0part\u00a0of\u00a0the\u00a0preprocessing\u00a0phase\u00a0of\u00a0jauto.\u00a0*)\n\u00a0\u00a0jauto_set_goal; intros.\n\u00a0\u00a0(*\u00a0All\u00a0the\u00a0subgoals\u00a0produced\u00a0can\u00a0then\u00a0be\u00a0solved\u00a0by\u00a0eauto.\u00a0*)\n\u00a0\u00a0eauto. eauto. eauto.\n\n\u00a0\u00a0-(* ST_App2 *)\n\u00a0\u00a0(*\u00a0old: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply\u00a0IHHt2\u00a0in\u00a0H[5]... \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion\u00a0H[5]\u00a0as\u00a0ST' [Hext [Hty Hsty]]. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exists\u00a0ST'...\u00a0*)\n\u00a0\u00a0(*\u00a0new:\u00a0this\u00a0time,\u00a0we\u00a0need\u00a0to\u00a0call\u00a0forwards\u00a0on\u00a0IHHt2, \u00a0\u00a0\u00a0\u00a0\u00a0and\u00a0we\u00a0call\u00a0jauto\u00a0right\u00a0away,\u00a0by\u00a0writing\u00a0forwards*, \u00a0\u00a0\u00a0\u00a0\u00a0proving\u00a0the\u00a0goal\u00a0in\u00a0a\u00a0single\u00a0tactic!\u00a0*)\n\u00a0\u00a0forwards*: IHHt2.\n\n\u00a0\u00a0(*\u00a0The\u00a0same\u00a0trick\u00a0works\u00a0for\u00a0many\u00a0of\u00a0the\u00a0other\u00a0subgoals.\u00a0*)\n\u00a0\u00a0- forwards*: IHHt.\n\u00a0\u00a0- forwards*: IHHt.\n\u00a0\u00a0- forwards*: IHHt1.\n\u00a0\u00a0- forwards*: IHHt2.\n\u00a0\u00a0- forwards*: IHHt1.\n\n\u00a0\u00a0- (*\u00a0T_Ref\u00a0*)\n\u00a0\u00a0+ (*\u00a0ST_RefValue\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0old: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exists\u00a0(ST\u00a0++\u00a0T[1]::nil). \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion\u00a0HST;\u00a0subst. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0split. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply\u00a0extends_app. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0split. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0replace\u00a0(TRef\u00a0T[1]) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0with\u00a0(TRef\u00a0(store_Tlookup\u00a0(length\u00a0st)\u00a0(ST\u00a0++\u00a0T[1]::nil))). \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply\u00a0T_Loc. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite\u00a0<-\u00a0H.\u00a0rewrite\u00a0app_length,\u00a0plus_comm.\u00a0simpl.\u00a0omega. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unfold\u00a0store_Tlookup.\u00a0rewrite\u00a0<-\u00a0H.\u00a0rewrite\u00a0app_nth2;\u00a0try\u00a0omega. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite\u00a0minus_diag.\u00a0simpl.\u00a0reflexivity. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply\u00a0store_well_typed_app;\u00a0assumption.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0new:\u00a0In\u00a0this\u00a0proof\u00a0case,\u00a0we\u00a0need\u00a0to\u00a0perform\u00a0an\u00a0inversion \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0without\u00a0removing\u00a0the\u00a0hypothesis.\u00a0The\u00a0tactic\u00a0inverts keep \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0serves\u00a0exactly\u00a0this\u00a0purpose.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u2203(ST ++ T[1]::nil). inverts keep HST. splits.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0The\u00a0proof\u00a0of\u00a0the\u00a0first\u00a0subgoal\u00a0needs\u00a0no\u00a0change\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply extends_app.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0For\u00a0the\u00a0second\u00a0subgoal,\u00a0we\u00a0use\u00a0the\u00a0tactic\u00a0applys_eq\u00a0to\u00a0avoid \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0a\u00a0manual\u00a0replace\u00a0before\u00a0T_loc\u00a0can\u00a0be\u00a0applied.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0applys_eq T_Loc 1.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0To\u00a0justify\u00a0the\u00a0inequality,\u00a0there\u00a0is\u00a0no\u00a0need\u00a0to\u00a0call\u00a0rewrite \u2190 H, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0because\u00a0the\u00a0tactic\u00a0omega\u00a0is\u00a0able\u00a0to\u00a0exploit\u00a0H\u00a0on\u00a0its\u00a0own. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0So,\u00a0only\u00a0the\u00a0rewriting\u00a0of\u00a0app_length\u00a0and\u00a0the\u00a0call\u00a0to\u00a0the \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tactic\u00a0omega\u00a0remain,\u00a0with\u00a0a\u00a0call\u00a0to\u00a0simpl\u00a0to\u00a0unfold\u00a0the \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0definition\u00a0of\u00a0app.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite app_length. simpl. omega.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0The\u00a0next\u00a0proof\u00a0case\u00a0is\u00a0hard\u00a0to\u00a0polish\u00a0because\u00a0it\u00a0relies\u00a0on\u00a0the \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lemma\u00a0app_nth1\u00a0whose\u00a0statement\u00a0is\u00a0not\u00a0automation-friendly. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0We'll\u00a0come\u00a0back\u00a0to\u00a0this\u00a0proof\u00a0case\u00a0further\u00a0on.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unfold store_Tlookup. rewrite \u2190 H. rewrite* app_nth2.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Last,\u00a0we\u00a0replace\u00a0apply ..; assumption\u00a0with\u00a0apply* ..\u00a0*)\n\u00a0\u00a0\u00a0\u00a0rewrite minus_diag. simpl. reflexivity.\n\u00a0\u00a0\u00a0\u00a0apply* store_well_typed_app.\n\n\u00a0\u00a0- forwards*: IHHt.\n\n\u00a0\u00a0- (*\u00a0T_Deref\u00a0*)\n\u00a0\u00a0+ (*\u00a0ST_DerefLoc\u00a0*)\n\u00a0\u00a0(*\u00a0old: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exists\u00a0ST.\u00a0split;\u00a0try\u00a0split... \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct\u00a0HST\u00a0as\u00a0_ Hsty. \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0replace\u00a0T[11]\u00a0with\u00a0(store_Tlookup\u00a0l\u00a0ST). \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply\u00a0Hsty... \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion\u00a0Ht;\u00a0subst...\u00a0*)\n\u00a0\u00a0(*\u00a0new:\u00a0we\u00a0start\u00a0by\u00a0calling\u00a0\u2203 ST\u00a0and\u00a0splits*.\u00a0*)\n\u00a0\u00a0\u2203ST. splits*.\n\u00a0\u00a0(*\u00a0new:\u00a0we\u00a0replace\u00a0destruct HST as [_ Hsty]\u00a0by\u00a0the\u00a0following\u00a0*)\n\u00a0\u00a0lets [_ Hsty]: HST.\n\u00a0\u00a0(*\u00a0new:\u00a0then\u00a0we\u00a0use\u00a0the\u00a0tactic\u00a0applys_eq\u00a0to\u00a0avoid\u00a0the\u00a0need\u00a0to \u00a0\u00a0\u00a0\u00a0\u00a0perform\u00a0a\u00a0manual\u00a0replace\u00a0before\u00a0applying\u00a0Hsty.\u00a0*)\n\u00a0\u00a0applys_eq* Hsty 1.\n\u00a0\u00a0(*\u00a0new:\u00a0we\u00a0then\u00a0can\u00a0call\u00a0inverts\u00a0in\u00a0place\u00a0of\u00a0inversion;subst\u00a0*)\n\u00a0\u00a0inverts* Ht.\n\n\u00a0\u00a0- forwards*: IHHt.\n\n\u00a0\u00a0- (*\u00a0T_Assign\u00a0*)\n\u00a0\u00a0+ (*\u00a0ST_Assign\u00a0*)\n\u00a0\u00a0(*\u00a0old: \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0exists\u00a0ST.\u00a0split;\u00a0try\u00a0split... \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eapply\u00a0assign_pres_store_typing... \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inversion\u00a0Ht[1];\u00a0subst...\u00a0*)\n\u00a0\u00a0(*\u00a0new:\u00a0simply\u00a0using\u00a0nicer\u00a0tactics\u00a0*)\n\u00a0\u00a0\u2203ST. splits*. applys* assign_pres_store_typing. inverts* Ht[1].\n\n\u00a0\u00a0- forwards*: IHHt1.\n\u00a0\u00a0- forwards*: IHHt2.\nQed.\n\n```", "```\nLemma nth_eq_last' : \u2200(A : Type) (l : list A) (x d : A) (n : nat),\n\u00a0\u00a0n = length l \u2192 nth n (l ++ x::nil) d = x.\nProof. intros. subst. apply nth_eq_last. Qed.\n\n```", "```\nLemma preservation_ref : \u2200(st:store) (ST : store_ty) T[1],\n\u00a0\u00a0length ST = length st \u2192\n\u00a0\u00a0TRef T[1] = TRef (store_Tlookup (length st) (ST ++ T[1]::nil)).\nProof.\n\u00a0\u00a0intros. dup.\n\n\u00a0\u00a0(*\u00a0A\u00a0first\u00a0proof,\u00a0with\u00a0an\u00a0explicit\u00a0unfold\u00a0*)\n\u00a0\u00a0unfold store_Tlookup. rewrite* nth_eq_last'.\n\n\u00a0\u00a0(*\u00a0A\u00a0second\u00a0proof,\u00a0with\u00a0a\u00a0call\u00a0to\u00a0fequal\u00a0*)\n\u00a0\u00a0fequal. symmetry. apply* nth_eq_last'.\nQed.\n\n```", "```\nTheorem preservation' : \u2200ST t t' T st st',\n\u00a0\u00a0has_type empty ST t T \u2192\n\u00a0\u00a0store_well_typed ST st \u2192\n\u00a0\u00a0t / st \u21d2 t' / st' \u2192\n\u00a0\u00a0\u2203ST',\n\u00a0\u00a0\u00a0\u00a0(extends ST' ST \u2227\n\u00a0\u00a0\u00a0\u00a0\u00a0has_type empty ST' t' T \u2227\n\u00a0\u00a0\u00a0\u00a0\u00a0store_well_typed ST' st').\nProof.\n\u00a0\u00a0remember (@empty ty) as \u0393. introv Ht. gen t'.\n\u00a0\u00a0induction Ht; introv HST Hstep; subst \u0393; inverts Hstep; eauto.\n\u00a0\u00a0- \u2203ST. inverts Ht[1]. splits*. applys* substitution_preserves_typing.\n\u00a0\u00a0- forwards*: IHHt1.\n\u00a0\u00a0- forwards*: IHHt2.\n\u00a0\u00a0- forwards*: IHHt.\n\u00a0\u00a0- forwards*: IHHt.\n\u00a0\u00a0- forwards*: IHHt1.\n\u00a0\u00a0- forwards*: IHHt2.\n\u00a0\u00a0- forwards*: IHHt1.\n\u00a0\u00a0- \u2203(ST ++ T[1]::nil). inverts keep HST. splits.\n\u00a0\u00a0\u00a0\u00a0apply extends_app.\n\u00a0\u00a0\u00a0\u00a0applys_eq T_Loc 1.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite app_length. simpl. omega.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unfold store_Tlookup. rewrite* nth_eq_last'.\n\u00a0\u00a0\u00a0\u00a0apply* store_well_typed_app.\n\u00a0\u00a0- forwards*: IHHt.\n\u00a0\u00a0- \u2203ST. splits*. lets [_ Hsty]: HST.\n\u00a0\u00a0\u00a0\u00a0applys_eq* Hsty 1\\. inverts* Ht.\n\u00a0\u00a0- forwards*: IHHt.\n\u00a0\u00a0- \u2203ST. splits*. applys* assign_pres_store_typing. inverts* Ht[1].\n\u00a0\u00a0- forwards*: IHHt1.\n\u00a0\u00a0- forwards*: IHHt2.\nQed.\n\n```", "```\nTheorem progress : \u2200ST t T st,\n\u00a0\u00a0has_type empty ST t T \u2192\n\u00a0\u00a0store_well_typed ST st \u2192\n\u00a0\u00a0(value t \u2228 \u2203t', \u2203st', t / st \u21d2 t' / st').\nProof.\n\u00a0\u00a0introv Ht HST. remember (@empty ty) as \u0393.\n\u00a0\u00a0induction Ht; subst \u0393; tryfalse; try solve [left*].\n\u00a0\u00a0- right. destruct* IHHt1 as [K|].\n\u00a0\u00a0\u00a0\u00a0inverts K; inverts Ht[1].\n\u00a0\u00a0\u00a0\u00a0\u00a0destruct* IHHt2.\n\u00a0\u00a0- right. destruct* IHHt as [K|].\n\u00a0\u00a0\u00a0\u00a0inverts K; try solve [inverts Ht]. eauto.\n\u00a0\u00a0- right. destruct* IHHt as [K|].\n\u00a0\u00a0\u00a0\u00a0inverts K; try solve [inverts Ht]. eauto.\n\u00a0\u00a0- right. destruct* IHHt1 as [K|].\n\u00a0\u00a0\u00a0\u00a0inverts K; try solve [inverts Ht[1]].\n\u00a0\u00a0\u00a0\u00a0\u00a0destruct* IHHt2 as [M|].\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inverts M; try solve [inverts Ht[2]]. eauto.\n\u00a0\u00a0- right. destruct* IHHt1 as [K|].\n\u00a0\u00a0\u00a0\u00a0inverts K; try solve [inverts Ht[1]]. destruct* n.\n\u00a0\u00a0- right. destruct* IHHt.\n\u00a0\u00a0- right. destruct* IHHt as [K|].\n\u00a0\u00a0\u00a0\u00a0inverts K; inverts Ht as M.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inverts HST as N. rewrite* N in M.\n\u00a0\u00a0- right. destruct* IHHt1 as [K|].\n\u00a0\u00a0\u00a0\u00a0destruct* IHHt2.\n\u00a0\u00a0\u00a0\u00a0\u00a0inverts K; inverts Ht[1] as M.\n\u00a0\u00a0\u00a0\u00a0\u00a0inverts HST as N. rewrite* N in M.\nQed.\n\nEnd PreservationProgressReferences.\n\n```", "```\nModule SubtypingInversion.\n\u00a0\u00a0Require Import Sub.\n\n```", "```\nLemma abs_arrow : \u2200x S[1] s[2] T[1] T[2],\n\u00a0\u00a0has_type empty (tabs x S[1] s[2]) (TArrow T[1] T[2]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0subtype T[1] S[1]\n\u00a0\u00a0\u2227 has_type (update empty x S[1]) s[2] T[2].\nProof with eauto.\n\u00a0\u00a0intros x S[1] s[2] T[1] T[2] Hty.\n\u00a0\u00a0apply typing_inversion_abs in Hty.\n\u00a0\u00a0destruct Hty as [S[2] [Hsub Hty]].\n\u00a0\u00a0apply sub_inversion_arrow in Hsub.\n\u00a0\u00a0destruct Hsub as [U[1] [U[2] [Heq [Hsub1 Hsub2]]]].\n\u00a0\u00a0inversion Heq; subst...\nQed.\n\n```", "```\nLemma abs_arrow' : \u2200x S[1] s[2] T[1] T[2],\n\u00a0\u00a0has_type empty (tabs x S[1] s[2]) (TArrow T[1] T[2]) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0subtype T[1] S[1]\n\u00a0\u00a0\u2227 has_type (update empty x S[1]) s[2] T[2].\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\nAdmitted.\n\n```", "```\nLemma substitution_preserves_typing : \u2200\u0393 x U v t S,\n\u00a0\u00a0has_type (update \u0393 x U) t S \u2192\n\u00a0\u00a0has_type empty v U \u2192\n\u00a0\u00a0has_type \u0393 ([x:=v]t) S.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) admit.\nAdmitted.\n\nEnd SubtypingInversion.\n\n```", "```\n\n## Stating Lemmas in the Right Way\n\n    Due to its depth-first strategy, eauto can get exponentially\n    slower as the depth search increases, even when a short proof\n    exists. In general, to make proof search run reasonably fast, one\n    should avoid using a depth search greater than 5 or 6\\. Moreover,\n    one should try to minimize the number of applicable lemmas, and\n    usually put first the hypotheses whose proof usefully instantiates\n    the existential variables.\n\n    In fact, the ability for eauto to solve certain goals actually\n    depends on the order in which the hypotheses are stated. This point\n    is illustrated through the following example, in which P is\n    a property of natural numbers. This property is such that\n    P n holds for any n as soon as P m holds for at least one m\n    different from zero. The goal is to prove that P 2 implies P 1.\n    When the hypothesis about P is stated in the form\n    \u2200 n m, P m \u2192 m \u2260 0 \u2192 P n, then eauto works. However, with\n    \u2200 n m, m \u2260 0 \u2192 P m \u2192 P n, the tactic eauto fails.\n\n```", "```\n\n    It is very important to understand that the hypothesis \u2200 n m, P m \u2192 m \u2260 0 \u2192 P n is eauto-friendly, whereas \u2200 n m, m \u2260 0 \u2192 P m \u2192 P n really isn't.  Guessing a value of m for\n    which P m holds and then checking that m \u2260 0 holds works well\n    because there are few values of m for which P m holds. So, it\n    is likely that eauto comes up with the right one. On the other\n    hand, guessing a value of m for which m \u2260 0 and then checking\n    that P m holds does not work well, because there are many values\n    of m that satisfy m \u2260 0 but not P m.\n\n```", "```\nAxiom P : nat \u2192 Prop.\n\nDefinition myFact := \u2200x, x \u2264 3 \u2192 P x.\n\n```", "```\nLemma demo_hint_unfold_goal_1 :\n\u00a0\u00a0(\u2200x, P x) \u2192 myFact.\nProof.\n\u00a0\u00a0auto. (*\u00a0Proof\u00a0search\u00a0doesn't\u00a0know\u00a0what\u00a0to\u00a0do,\u00a0*)\n\u00a0\u00a0unfold myFact. auto. (*\u00a0unless\u00a0we\u00a0unfold\u00a0the\u00a0definition.\u00a0*)\nQed.\n\n```", "```\nHint Unfold myFact.\n\n```", "```\nLemma demo_hint_unfold_goal_2 :\n\u00a0\u00a0(\u2200x, P x) \u2192 myFact.\nProof. auto. Qed.\n\n```", "```\nLemma demo_hint_unfold_context_1 :\n\u00a0\u00a0(True \u2192 myFact) \u2192 P 3.\nProof.\n\u00a0\u00a0intros.\n\u00a0\u00a0auto. (*\u00a0fails\u00a0*)\n\u00a0\u00a0unfold myFact in *. auto. (*\u00a0succeeds\u00a0*)\nQed.\n\n```", "```\nLemma demo_hint_unfold_context_2 :\n\u00a0\u00a0myFact \u2192 P 3.\nProof. auto. Qed.\n\n```", "```\nParameter le_not_gt : \u2200x,\n\u00a0\u00a0(x \u2264 3) \u2192 \u00ac (x > 3).\n\n```", "```\nParameter gt_not_le : \u2200x,\n\u00a0\u00a0(x > 3) \u2192 \u00ac (x \u2264 3).\n\n```", "```\nParameter le_gt_false : \u2200x,\n\u00a0\u00a0(x \u2264 3) \u2192 (x > 3) \u2192 False.\n\n```", "```\nSection DemoAbsurd1.\n\n```", "```\nHint Resolve le_not_gt.\n\nLemma demo_auto_absurd_1 :\n\u00a0\u00a0(\u2203x, x \u2264 3 \u2227 x > 3) \u2192 False.\nProof.\n\u00a0\u00a0intros. jauto_set. (*\u00a0decomposes\u00a0the\u00a0assumption\u00a0*)\n\u00a0\u00a0(*\u00a0debug\u00a0*) eauto. (*\u00a0does\u00a0not\u00a0see\u00a0that\u00a0le_not_gt\u00a0could\u00a0apply\u00a0*)\n\u00a0\u00a0eapply le_not_gt. eauto. eauto.\nQed.\n\n```", "```\nHint Resolve le_gt_false.\n\nLemma demo_auto_absurd_2 :\n\u00a0\u00a0(\u2203x, x \u2264 3 \u2227 x > 3) \u2192 False.\nProof.\n\u00a0\u00a0dup.\n\n\u00a0\u00a0(*\u00a0detailed\u00a0version:\u00a0*)\n\u00a0\u00a0intros. jauto_set. (*\u00a0debug\u00a0*) eauto.\n\n\u00a0\u00a0(*\u00a0short\u00a0version:\u00a0*)\n\u00a0\u00a0jauto.\nQed.\n\n```", "```\nEnd DemoAbsurd1.\n\n```", "```\nLemma demo_false : \u2200x,\n\u00a0\u00a0(x \u2264 3) \u2192 (x > 3) \u2192 4 = 5.\nProof.\n\u00a0\u00a0intros. dup 4.\n\n\u00a0\u00a0(*\u00a0A\u00a0failed\u00a0proof:\u00a0*)\n\u00a0\u00a0- false. eapply le_gt_false.\n\u00a0\u00a0\u00a0\u00a0+ auto. (*\u00a0here,\u00a0auto\u00a0does\u00a0not\u00a0prove\u00a0?x \u2264 3\u00a0by\u00a0using\u00a0H\u00a0but \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0by\u00a0using\u00a0the\u00a0lemma\u00a0le_refl : \u2200 x, x \u2264 x.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0The\u00a0second\u00a0subgoal\u00a0becomes\u00a03 > 3,\u00a0which\u00a0is\u00a0not\u00a0provable.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ skip.\n\n\u00a0\u00a0(*\u00a0A\u00a0correct\u00a0proof:\u00a0*)\n\u00a0\u00a0- false. eapply le_gt_false.\n\u00a0\u00a0\u00a0\u00a0+ eauto. (*\u00a0here,\u00a0eauto\u00a0uses\u00a0H,\u00a0as\u00a0expected,\u00a0to\u00a0prove\u00a0?x \u2264 3\u00a0*)\n\u00a0\u00a0\u00a0\u00a0+ eauto. (*\u00a0so\u00a0the\u00a0second\u00a0subgoal\u00a0becomes\u00a0x > 3\u00a0*)\n\n\u00a0\u00a0(*\u00a0The\u00a0same\u00a0proof\u00a0using\u00a0false:\u00a0*)\n\u00a0\u00a0- false le_gt_false. eauto. eauto.\n\n\u00a0\u00a0(*\u00a0The\u00a0lemmas\u00a0le_not_gt\u00a0and\u00a0gt_not_le\u00a0work\u00a0as\u00a0well\u00a0*)\n\u00a0\u00a0- false le_not_gt. eauto. eauto.\nQed.\n\n```", "```\n\n## Automation for Transitivity Lemmas\n\n    Some lemmas should never be added as hints, because they would\n    very badly slow down proof search. The typical example is that of\n    transitivity results. This section describes the problem and\n    presents a general workaround.\n\n    Consider a subtyping relation, written subtype S T, that relates\n    two object S and T of type typ. Assume that this relation\n    has been proved reflexive and transitive. The corresponding lemmas\n    are named subtype_refl and subtype_trans.\n\n```", "```\n\n    Adding reflexivity as hint is generally a good idea,\n    so let's add reflexivity of subtyping as hint.\n\n```", "```\n\n    Adding transitivity as hint is generally a bad idea.  To\n    understand why, let's add it as hint and see what happens.\n    Because we cannot remove hints once we've added them, we are going\n    to open a \"Section,\" so as to restrict the scope of the\n    transitivity hint to that section.\n\n```", "```\n\n    Now, consider the goal \u2200 S T, subtype S T, which clearly has\n    no hope of being solved. Let's call eauto on this goal.\n\n```", "```\n\n    Note that after closing the section, the hint subtype_trans\n    is no longer active.\n\n```", "```\n\n    In the previous example, the proof search has spent a lot of time\n    trying to apply transitivity and reflexivity in every possible\n    way.  Its process can be summarized as follows. The first goal is\n    subtype S T. Since reflexivity does not apply, eauto invokes\n    transitivity, which produces two subgoals, subtype S ?X and\n    subtype ?X T. Solving the first subgoal, subtype S ?X, is\n    straightforward, it suffices to apply reflexivity. This unifies\n    ?X with S. So, the second sugoal, subtype ?X T,\n    becomes subtype S T, which is exactly what we started from...\n\n    The problem with the transitivity lemma is that it is applicable\n    to any goal concluding on a subtyping relation. Because of this,\n    eauto keeps trying to apply it even though it most often doesn't\n    help to solve the goal. So, one should never add a transitivity\n    lemma as a hint for proof search. \n\n    There is a general workaround for having automation to exploit\n    transitivity lemmas without giving up on efficiency. This workaround\n    relies on a powerful mechanism called \"external hint.\" This\n    mechanism allows to manually describe the condition under which\n    a particular lemma should be tried out during proof search.\n\n    For the case of transitivity of subtyping, we are going to tell\n    Coq to try and apply the transitivity lemma on a goal of the form\n    subtype S U only when the proof context already contains an\n    assumption either of the form subtype S T or of the form\n    subtype T U. In other words, we only apply the transitivity\n    lemma when there is some evidence that this application might\n    help.  To set up this \"external hint,\" one has to write the\n    following.\n\n```", "```\n\n    This hint declaration can be understood as follows.\n\n*   \"Hint Extern\" introduces the hint.\n\n*   The number \"1\" corresponds to a priority for proof search. It doesn't matter so much what priority is used in practice.\n\n*   The pattern subtype ?S ?U describes the kind of goal on which the pattern should apply. The question marks are used to indicate that the variables ?S and ?U should be bound to some value in the rest of the hint description.\n\n*   The construction match goal with ... end tries to recognize patterns in the goal, or in the proof context, or both.\n\n*   The first pattern is H: subtype S ?T \u22a2 _. It indices that the context should contain an hypothesis H of type subtype S ?T, where S has to be the same as in the goal, and where ?T can have any value.\n\n*   The symbol \u22a2 _ at the end of H: subtype S ?T \u22a2 _ indicates that we do not impose further condition on how the proof obligation has to look like.\n\n*   The branch \u21d2 apply (@subtype_trans S T U) that follows indicates that if the goal has the form subtype S U and if there exists an hypothesis of the form subtype S T, then we should try and apply transitivity lemma instantiated on the arguments S, T and U. (Note: the symbol @ in front of subtype_trans is only actually needed when the \"Implicit Arguments\" feature is activated.)\n\n*   The other branch, which corresponds to an hypothesis of the form H: subtype ?T U is symmetrical.\n\n    Note: the same external hint can be reused for any other transitive\n    relation, simply by renaming subtype into the name of that relation. \n\n    Let us see an example illustrating how the hint works.\n\n```", "```\n\n    We may also check that the new external hint does not suffer from the\n    complexity blow up.\n\n```", "```\n\n# Decision Procedures\n\n    A decision procedure is able to solve proof obligations whose\n    statement admits a particular form. This section describes three\n    useful decision procedures. The tactic omega handles goals\n    involving arithmetic and inequalities, but not general\n    multiplications.  The tactic ring handles goals involving\n    arithmetic, including multiplications, but does not support\n    inequalities. The tactic congruence is able to prove equalities\n    and inequalities by exploiting equalities available in the proof\n    context.\n\n```", "```\nRequire Import Omega.\n\n```", "```\nLemma omega_demo_1 : \u2200(x y : nat),\n\u00a0\u00a0(y \u2264 4) \u2192 (x + x + 1 \u2264 y) \u2192 (x \u2260 0) \u2192 (x = 1).\nProof. intros. omega. Qed.\n\n```", "```\nLemma omega_demo_2 : \u2200(x y z : nat),\n\u00a0\u00a0(x + y = z + z) \u2192 (x - y \u2264 4) \u2192 (x - z \u2264 2).\nProof. intros. omega. Qed.\n\n```", "```\nLemma omega_demo_3 : \u2200(x y : nat),\n\u00a0\u00a0(x + 5 \u2264 y) \u2192 (y - x < 3) \u2192 False.\nProof. intros. omega. Qed.\n\n```", "```\nLemma omega_demo_4 : \u2200(x y : nat) (P : Prop),\n\u00a0\u00a0(x + 5 \u2264 y) \u2192 (y - x < 3) \u2192 P.\nProof.\n\u00a0\u00a0intros.\n\u00a0\u00a0(*\u00a0Calling\u00a0omega\u00a0at\u00a0this\u00a0point\u00a0fails\u00a0with\u00a0the\u00a0message: \u00a0\u00a0\u00a0\u00a0\"Omega:\u00a0Can't\u00a0solve\u00a0a\u00a0goal\u00a0with\u00a0proposition\u00a0variables\"\u00a0*)\n\u00a0\u00a0(*\u00a0So,\u00a0one\u00a0needs\u00a0to\u00a0replace\u00a0the\u00a0goal\u00a0by\u00a0False\u00a0first.\u00a0*)\n\u00a0\u00a0false. omega.\nQed.\n\n```", "```\nModule RingDemo.\n\u00a0\u00a0Require Import ZArith.\n\u00a0\u00a0Open Scope Z_scope.\n\u00a0\u00a0(*\u00a0Arithmetic\u00a0symbols\u00a0are\u00a0now\u00a0interpreted\u00a0in\u00a0Z\u00a0*)\n\nLemma ring_demo : \u2200(x y z : Z),\n\u00a0\u00a0\u00a0\u00a0x * (y + z) - z * 3 * x\n\u00a0\u00a0= x * y - 2 * x * z.\nProof. intros. ring. Qed.\n\nEnd RingDemo.\n\n```", "```\nLemma congruence_demo_1 :\n\u00a0\u00a0\u00a0\u2200(f : nat\u2192nat\u2192nat) (g h : nat\u2192nat) (x y z : nat),\n\u00a0\u00a0\u00a0f (g x) (g y) = z \u2192\n\u00a0\u00a0\u00a02 = g x \u2192\n\u00a0\u00a0\u00a0g y = h z \u2192\n\u00a0\u00a0\u00a0f 2 (h z) = z.\nProof. intros. congruence. Qed.\n\n```", "```\nLemma congruence_demo_2 :\n\u00a0\u00a0\u00a0\u2200(f : nat\u2192nat\u2192nat) (g h : nat\u2192nat) (x y z : nat),\n\u00a0\u00a0\u00a0(\u2200a, g a = h a) \u2192\n\u00a0\u00a0\u00a0f (g x) (g y) = z \u2192\n\u00a0\u00a0\u00a0g x = 2 \u2192\n\u00a0\u00a0\u00a0f 2 (h y) = z.\nProof. congruence. Qed.\n\n```", "```\nLemma congruence_demo_4 : \u2200(f g : nat\u2192nat),\n\u00a0\u00a0(\u2200a, f a = g a) \u2192\n\u00a0\u00a0f (g (g 2)) = g (f (f 2)).\nProof. congruence. Qed.\n\n```", "```\nLemma congruence_demo_3 :\n\u00a0\u00a0\u00a0\u2200(f g h : nat\u2192nat) (x : nat),\n\u00a0\u00a0\u00a0(\u2200a, f a = h a) \u2192\n\u00a0\u00a0\u00a0g x = f x \u2192\n\u00a0\u00a0\u00a0g x \u2260 h x \u2192\n\u00a0\u00a0\u00a0False.\nProof. congruence. Qed.\n\n```", "```\n\n# Summary\n\n    Let us summarize the main automation tactics available.\n\n*   auto automatically applies reflexivity, assumption, and apply. \n\n*   eauto moreover tries eapply, and in particular can instantiate existentials in the conclusion. \n\n*   iauto extends eauto with support for negation, conjunctions, and disjunctions. However, its support for disjunction can make it exponentially slow. \n\n*   jauto extends eauto with support for negation, conjunctions, and existential at the head of hypothesis. \n\n*   congruence helps reasoning about equalities and inequalities. \n\n*   omega proves arithmetic goals with equalities and inequalities, but it does not support multiplication. \n\n*   ring proves arithmetic goals with multiplications, but does not support inequalities.\n\n    In order to set up automation appropriately, keep in mind the following\n    rule of thumbs:\n\n*   automation is all about balance: not enough automation makes proofs not very robust on change, whereas too much automation makes proofs very hard to fix when they break. \n\n*   if a lemma is not goal directed (i.e., some of its variables do not occur in its conclusion), then the premises need to be ordered in such a way that proving the first premises maximizes the chances of correctly instantiating the variables that do not occur in the conclusion. \n\n*   a lemma whose conclusion is False should only be added as a local hint, i.e., as a hint within the current section. \n\n*   a transitivity lemma should never be considered as hint; if automation of transitivity reasoning is really necessary, an Extern Hint needs to be set up. \n\n*   a definition usually needs to be accompanied with a Hint Unfold.\n\n    Becoming a master in the black art of automation certainly requires\n    some investment, however this investment will pay off very quickly.\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]