- en: Homework 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type the following into the terminal to copy the template file to the current
    directory (note the period at the end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Or you can download the template [here](http://inst.eecs.berkeley.edu/~cs61as/templates/hw4.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: Autograder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working on the lab computers, the `grader` command will run the autograder.
    If you are working on your own personal machine, you should download [grader.rkt](http://inst.eecs.berkeley.edu/~cs61as/autograder/grader.rkt)
    and the [HW 4 tests](http://inst.eecs.berkeley.edu/~cs61as/autograder/tests/hw4-tests.rkt).
  prefs: []
  type: TYPE_NORMAL
- en: Warm-up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Try and predict what the following expressions will return, then check your
    answers with the Racket interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define x (cons 4 5))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(car x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(cdr x)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(define y (cons ''hello ''goodbye))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(define z (cons x y))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(car (cdr z))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(cdr (cdr z))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(cdr (car z))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(car (cons 8 3))`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(car z)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(car 3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first few exercises refer to [SICP 2.1.4](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.4).
    See the text for details about interval arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: SICP 2.7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alyssa''s program is incomplete because she has not specified the implementation
    of the interval abstraction. Here is a definition of the interval constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Define selectors `upper-bound` and `lower-bound` to complete the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: SICP 2.8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using reasoning analogous to Alyssa's, describe how the difference of two intervals
    may be computed. Define a corresponding subtraction procedure, called `sub-interval`.
  prefs: []
  type: TYPE_NORMAL
- en: SICP 2.10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ben Bitdiddle, an expert systems programmer, looks over Alyssa's shoulder and
    comments that it is not clear what it means to divide by an interval that spans
    zero. Modify Alyssa's code to check for this condition and to signal an error
    if it occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Spans zero means that one bound is <= zero and the other is >= zero!'
  prefs: []
  type: TYPE_NORMAL
- en: SICP 2.12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Define a constructor `make-center-percent` that takes a center and a percentage
    tolerance and produces the desired interval. You must also define a selector `percent`
    that produces the percentage tolerance for a given interval. The `center` selector
    is the same as the one shown above.
  prefs: []
  type: TYPE_NORMAL
- en: SICP 2.17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Define a procedure `last-pair` that returns the list that contains only the
    last element of a given (nonempty) list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: SICP 2.20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The procedures `+`, `*`, and `list` take arbitrary numbers of arguments. One
    way to define such procedures is to use `define` with **dotted-tail notation**.
    In a procedure definition, a parameter list that has a dot before the last parameter
    name indicates that, when the procedure is called, the initial parameters (if
    any) will have as values the initial arguments, as usual, but the final parameter's
    value will be a list of any remaining arguments. For instance, given the definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: the procedure `f` can be called with two or more arguments. If we evaluate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: then in the body of `f`, `x` will be `1`, `y` will be `2`, and `z` will be the
    list `'(3 4 5 6)`. Given the definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: the procedure `g` can be called with zero or more arguments. If we evaluate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: then in the body of `g`, `w` will be the list `'(1 2 3 4 5 6)`.
  prefs: []
  type: TYPE_NORMAL
- en: Use this notation to write a procedure `same-parity` that takes one or more
    integers and returns a list of all the arguments that have the same even-odd parity
    as the first argument. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: SICP 2.22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Louis Reasoner tries to rewrite the first `square-list` procedure of Exercise
    2.21 so that it evolves an iterative process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, defining `square-list` this way produces the answer list in the
    reverse order of the one desired. Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Louis then tries to fix his bug by interchanging the arguments to `cons`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't work either. Explain.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a procedure `my-substitute` that takes three arguments: a list, an old
    word, and a new word. It should return a copy of the list, but with every occurrence
    of the old word replaced by the new word, even in sublists. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You might find the procedure `list?` useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now write `my-substitute2` that takes a list, a list of old words, and a list
    of new words; the last two lists should be the same length. It should return a
    copy of the first argument, but with each word that occurs in the second argument
    replaced by the corresponding word of the third argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Extra for Experts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do these if you want an extra challenge. These are *not* for credit.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write the procedure `cxr-function` that takes as its argument a word starting
    with c, ending with r, and having a string of letters a and/or d in between, such
    as `cdddadaadar`. It should return the corresponding function.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[SICP Ex. 2.6](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_thm_2.4).
    Besides addition, invent multiplication and exponentiation of nonnegative integers.
    If you''re really enthusiastic, see if you can invent subtraction. (Remember,
    the rule of this game is that you have only lambda as a starting point.) Read
    `~cs61as/lib/church-hint` for some suggestions.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[SICP Ex. 2.18](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_thm_2.18);
    this should take some thought, and you should make sure you get it right, but
    don''t get stuck on it for a whole hour. Note: Your solution should reverse lists,
    not sentences! That is, you should be using `cons`, `car`, and `cdr`, not `first`,
    `sentence`, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: Submit Your Homework!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For instructions, see [this guide](../submit.html). It covers basic terminal
    commands and assignment submission.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any trouble submitting, do not hesitate to ask a TA!
  prefs: []
  type: TYPE_NORMAL
