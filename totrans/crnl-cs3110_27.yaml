- en: 'Recitation 17: Verification Example, Review of Logic'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous lecture, we saw an example of verification. Today we'll look
    at another example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following recursive implementation of a function `lmax` that computes
    the maximum element of a nonempty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we handle recursive functions? We''ll use the approach of assuming that
    a recursive function satisfies its spec whenever it is called recursively. A proof
    of correctness will then ensure the **partial correctness** of the function''s
    implementation, which we can distinguish from **total correctness**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partial correctness**: whenever the function is applied with the precondition
    satisfied, and it terminates, it produces results satisfying the postcondition.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Total correctness**: the function has partial correctness, and in addition,
    it always terminates when the function is applied.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The nice thing about this approach is that we can separate the problem of proving
    that a function computes the right answer from the problem of proving that the
    function terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Correctness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s prove partial correctness. First of all, we need to understand our postcondition
    a little more precisely. What are the elements of a list? We can define a function
    that gives us the elements by induction on the list:'
  prefs: []
  type: TYPE_NORMAL
- en: elements(`[]`) = ∅
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: elements(h `::` t) = {h} ∪ elements(t)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Like an abstraction function, this function maps from the concrete domain of
    OCaml lists to a more abstract mathematical domain, that of sets.
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Assumptions | Justification |'
  prefs: []
  type: TYPE_TB
- en: '| `lmax xs` | xs ≠ [] | Consider an arbitrary call satisfying the precondition.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `match xs with []-> ...` | xs ≠ [] | Expand the function body. Now we need
    to create cases to know which way the `match` will go. Here are three exhaustive
    cases: xs = [], xs = [x], xs = x :: t. |'
  prefs: []
  type: TYPE_TB
- en: '| Case xs = [] |'
  prefs: []
  type: TYPE_TB
- en: '| `raise (Failure ...)` | xs ≠ [] | This case can''t happen according to our
    assumptions. The postcondition is vacuously satisfied. |'
  prefs: []
  type: TYPE_TB
- en: '| Case xs = [x] = x :: [] |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | xs = [x] | The result is the only element in `xs`, so elements(xs)
    = {x}, and therefore x is the maximum element in elements(xs). |'
  prefs: []
  type: TYPE_TB
- en: '| Case xs = x::t and t ≠ [] |'
  prefs: []
  type: TYPE_TB
- en: '| `max x (lmax t)` | xs = x::t t ≠ [] | Now `lmax` can be applied to t; crucially,
    t is not the empty list, so the precondition of `lmax` is satisfied. |'
  prefs: []
  type: TYPE_TB
- en: '| `max x n1` | xs = x::t t ≠ []'
  prefs: []
  type: TYPE_NORMAL
- en: n1 = maximum of elements(t) | Now we can apply the function `max`, using *its*
    spec, obtaining some value n2 that satisfies the postcondition of `max`. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `n2` | xs = x::t t ≠ []'
  prefs: []
  type: TYPE_NORMAL
- en: n1 = maximum of elements(t)
  prefs: []
  type: TYPE_NORMAL
- en: (n2 = x or
  prefs: []
  type: TYPE_NORMAL
- en: n2 = n1)
  prefs: []
  type: TYPE_NORMAL
- en: n2 ≥ x
  prefs: []
  type: TYPE_NORMAL
- en: n2 ≥ n1 | From the mathematical definition of the maximum element of a set,
    the value n1 must be an element of t and must be at least as large as any element
    of t. The specification says that n2 must be an element of xs and at least as
    large as any element of xs. We know from the definition of elements that elements(xs)
    = {x}∪elements(t). So n2 must be an element of xs because it's either x or it's
    n1, which is an element of t. Further, n2 must be at least as large as x (n2 ≥
    x). And it must be at least as large as elements(t), since it's at least as large
    as n1, which is at least as large as any element of t. Therefore n2 is the maximum
    element of xs in this case. |
  prefs: []
  type: TYPE_NORMAL
- en: '| QED |'
  prefs: []
  type: TYPE_TB
- en: Total Correctness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The key to proving total correctness is to prove that recursion cannot go on
    forever. We need to be able to map the function arguments onto a set that has
    a least element. Typically we do this by giving a **decrementing function** d(x)
    that maps the function argument x onto the natural numbers. The decrementing function
    d has two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It maps any function arguments that satisfy the precondition to a natural number
    (≥ 0):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PRE ⇒ 0 ≤ d(x)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Whenever there is a recursive call, the decrementing function applied to the
    arguments x'' of the recursive call is strictly smaller:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 ≤ d(x') < d(x).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This means that when the decrementing function is zero, there is no recursive
    call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These conditions ensure that the decrementing function keeps getting smaller
    on every recursive call, but cannot get smaller forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in `lmax` an appropriate decrementing function is: d(x) = `List.length`(x)
    − 1\. It must be nonnegative; when it is zero, the function terminates; and the
    recursive call to `lmax` is on a shorter list `t`.'
  prefs: []
  type: TYPE_NORMAL
- en: A review of propositional logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall from CS 2800 that **propositional logic** is a logic built up from simple
    symbols representing propositions about some world. For our example, we will use
    the letters A, B, C, ... as propositional symbols. For example, these symbols
    might stand for various propositions:'
  prefs: []
  type: TYPE_NORMAL
- en: A = "got 90% on the final"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B = "attended class every time"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C = "got an A in the class"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D = "x + 1 ≤ y"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E = "e ∈ s"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not the job of *propositional* logic to assign meanings to these symbols.
    However, we use statements to the meanings of D and E to talk about the correctness
    of programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a grammar for **propositions** built up from these symbols. We use
    the letters P, Q, R to represent propositions (or **formulas**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: On some browsers, on some operating systems, in some fonts, the symbol
    for conjunction (and) is rendered incorrectly as a small circle. It should look
    like an upside-down ∨. In these course notes, it will appear variously as `∧`,
    ∧, or ∧.'
  prefs: []
  type: TYPE_NORMAL
- en: The precedence of these forms decreases as we go down the list, so P ∧ Q ⇒ R
    is the same as (P ∧ Q) ⇒ R. One thing to watch out for is that ⇒ is right-associative
    (like →), so P ⇒ Q ⇒ R is the same as P ⇒ (Q ⇒ R). We will introduce parentheses
    as needed for clarity. We will use the notation for logical negation, but it is
    really just syntactic sugar for the implication P ⇒ ⊥. We also write P ⇔ Q as
    syntactic sugar for (P ⇒ Q) ∧ (Q ⇒ P), meaning that P and Q are logically equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'This grammar defines the language of propositions. With suitable propositional
    symbols, we can express various interesting statements, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: A ∧ B ⇒ C
  prefs: []
  type: TYPE_NORMAL
- en: '"If I got a 90% on the final and I attended class, I will get an A"'
  prefs: []
  type: TYPE_NORMAL
- en: ¬C ⇒ (¬A ∨ ¬B)
  prefs: []
  type: TYPE_NORMAL
- en: '"If I didn''t get an A in the class, then either I didn''t get a 90% on the
    final or I didn''t attend class"'
  prefs: []
  type: TYPE_NORMAL
- en: C ∨ ¬A ∨ ¬B
  prefs: []
  type: TYPE_NORMAL
- en: '"Either I got an A in the class, or I didn''t get a 90% on the final or I didn''t
    attend class"'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, all three of these propositions are logically equivalent, which we
    can determine without knowing about what finals and attendance mean.
  prefs: []
  type: TYPE_NORMAL
