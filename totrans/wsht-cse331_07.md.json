["```\n\n/**\n * This class represents the mathematical concept of a line segment.\n *\n * Specification fields:\n *  @specfield start-point : point  // The starting point of the line\n *  @specfield end-point   : point  // The ending point of the line\n *\n * Derived specification fields:\n *  @derivedfield length : real // length = sqrt((start-point.x - end-point.x)^2 + (start-point.y - end-point.y)^2)\n *                              // The length of the line\n *\n * Abstract Invariant:\n *  A line's start-point must be different from its end-point.\n */\npublic class Line {\n\n  /** The x-coordinate of the line's starting point */\n  private int startX;\n\n  /** The y-coordinate of the line's starting point */\n  private int startY;\n\n  /** The x-coordinate of the line's ending point */\n  private int endX;\n\n  /** The y-coordinate of the line's ending point */\n  private int endY;\n\n  // Representation Invariant:\n  //  ! (startX == endX && startY == endY)\n  //\n  // Abstraction Function:\n  //  AF(r) = a line, l, such that\n  //   l.start-point = ?r.startX, r.startY?\n  //   l.end-point = ?r.endX, r.endY?\n\n /**\n  * @requires p != null && ! p.equals(start-point)\n  * @modifies this\n  * @effects Sets end-point to p\n  */\n  public void setEndPoint(Point p) {\n    ...\n  }\n\n  ...\n\n}\n\n```", "```\n // Rep invariant is\n //    RI(r) = r.name != null && r.balance \u2265 0\n```", "```\n // Rep invariant is\n //    name != null && balance \u2265 0\n```", "```\n //    for all i, transactions[i] instanceof Trans\n\n //    suit in {Clubs,Diamonds,Hearts,Spades}\n\n //    string contains no duplicate characters\n\n //    size = number of non-null entries in array\n\n```", "```\n(1)   //    balance == sum (for all i) of transactions[i].amount\n```", "```\n(2)   //    balance == sum (for all i) of transactions[i].getAmount()\n```", "```\n(3)   //    balance == sum (for all i) of transactions.get(i).getAmount()\n```", "```\npublic class Card {\n    private int index;\n\n    // Abstraction function is\n    //    suit = S(index div 13)   where S(0)=Clubs, S(1)=Diamonds, S(2)=Hearts, S(3)=Spades\n    //    value = V(index mod 13)  where V(1)=Ace, V(2)=2, ..., V(10)=10, V(11)=Jack, V(12)=Queen,\n    //                                   V(0)=King\n   \u00a0...\n}\n```", "```\n    // Rep invariant is\n    //    0 \u2264 index \u2264 51\n\n```", "```\n/** CharSet represents a mutable set of characters. */\npublic class CharSet {\n    private StringBuffer chars;\n\n    // Abstraction function is\n    //    { chars[i] | 0 \u2264 i < chars.size }\n    ...\n\n    /** @modifies this\n     *  @effects this_post = this - {c}\n     */\n    public void remove (char c) {\n        int i = chars.indexOf(Character.toString (c));\n        if (i != -1) chars.deleteCharAt (i);\n    }\n}\n```", "```\n    //   name != null && transactions != null\n```", "```\nprivate void checkRep () {\n    if (balance < 0)\n        throw new RuntimeException (\"balance should be \u2265 0\");\n\n    if (name == null)\n        throw new RuntimeException (\"name should be non-null\");\n\n    // for all j, sum (i=0..j) transactions[i].amount >= 0\n    int sum = 0;\n    for (Trans t : transactions) {\n        sum += t.getAmount();\n        if (sum < 0)\n           throw new RuntimeException(\"balance went negative\");\n    }\n    // balance = sum (for all i) transactions[i].amount\n    if (balance != sum)\n        throw new RuntimeException (\"balance should equal sum of transactions[i].amount\");\n}\n```", "```\n    // using Java assert syntax\n   \u00a0assert balance \u2265 0 : \"balance should be \u2265 0\";\n\n    // using junit.framework.Assert (you don't have to be writing a unit test to use this class)\n    Assert.assertTrue (\"balance should be \u2265 0\", balance \u2265 0);\n\n```", "```\nclass Complex {\n  private double real;\n  private double imag;\n  ...\n}\n\n```", "```\n/**\n * Complex represents an immutable complex number.    \u2190 this is A\n */\npublic class Complex {\n  private double real;    \u2190 these fields form R\n  private double imag;\n  ...\n}\n\n```", "```\n/**\n * Complex represents an immutable complex number.\n */\npublic class Complex {\n  private double real;\n  private double imag;\n\n  // The abstraction function is\n  //      AF(r) = r.real + i * r.imag\n  ...\n}\n```", "```\n/**\n * Cons represents an immutable sequence of objects.\n */\npublic class Cons {\n  private Object first;\n  private Cons rest;\n\n  // The abstraction function is\n  //      AF(r) = [] if r = null\n  //              [r.first] : AF(r.rest) if r != null\n  ...\n}\n```", "```\n/**\n * Complex represents an immutable complex number.\n */\npublic class Complex {\n  private double real;\n  private double imag;\n\n  // The abstraction function is\n  //      real + i * imag\n  ...\n}\n\n```", "```\npublic class Line {\n    private Point start;\n    private Point end;\n\n    // Abstraction function is\n    //    AF(r) = line l such that\n    //       l.start = r.start\n    //       l.end = r.end\n    ...\n}\n\n```", "```\npublic class Line {\n    private Point start;\n    private double length;\n    private double angle;\n\n    // Abstraction function is\n    //    AF(r) = line l such that\n    //       l.start = r.start\n    //       l.end.x = r.start.x + r.length * cos(r.angle)\n    //       l.end.y = r.start.y + r.length * sin(r.angle)\n    ...\n}\n```", "```\n    // Abstraction function is\n    //       start = start\n    //       end.x = start.x + length * cos(angle)\n    //       end.y = start.y + length * sin(angle))\n\n```", "```\n/**\n * Card represents an immutable playing card.\n * @specfield suit : {Clubs,Diamonds,Hearts,Spades} // card suit\n * @specfield value : {Ace,2,...,10,Jack,Queen,King} // card rank\n */\n\n```", "```\npublic class Card {\n    private int index;\n\n    // Abstraction function is\n    //    suit = S(index div 13)   where S(0)=Clubs, S(1)=Diamonds, S(2)=Hearts, S(3)=Spades\n    //    value = V(index mod 13)  where V(1)=Ace, V(2)=2, ..., V(10)=10,\n    //                                   V(11)=Jack, V(12)=Queen, V(0)=King\n    //    (div and mod refer to the integer division and remainder operations)\n    //    for example, 3 ? Three of Clubs\n    //                 14 ? Ace of Diamonds\n   \u00a0...\n}\n\n```", "```\n/**\n * Card represents an immutable playing card.\n * @specfield suit : {Clubs,Diamonds,Hearts,Spades} // card suit\n * @specfield value : {Ace,2,...,10,Jack,Queen,King} // card rank\n */\npublic class Card {\n\n    private int index;\n\n    // Abstraction function is\n    //    suit = S(index div 13)   where S(0)=Clubs, S(1)=Diamonds, S(2)=Hearts, S(3)=Spades\n    //    value = V(index mod 13)  where V(1)=Ace, V(2)=2, ..., V(10)=10, V(11)=Jack, V(12)=Queen,\n    //                                   V(0)=King\n\n    // Rep invariant is\n    //    0 <= index <= 51\n\n    /**\n     * Check the rep invariant.\n     * @effects: nothing if this satisfies rep invariant;\n     *           otherwise throws an exception\n     */\n    private void checkRep() {\n        if (index < 0 || index > 51)\n            throw new RuntimeException (\"card index out of range\");\n    }\n\n    /**\n     * @effects makes a new playing card with given suit and value\n     */\n    public Card(CardSuit suit, CardValue value) {\n        ... // initialize Card\n        checkRep();\n    }\n\n    /**\n     * @effects returns this.suit   \u2190 \"suit\" refers to the spec field\n     */\n    public CardSuit getSuit() {\n        checkRep();\n        try {\n            CardSuit s = ... // decode suit\n            return s;\n        } finally {\n            checkRep();\n        }\n    }\n\n    /**\n     * @effects returns this.value  \u2190 \"value\" is the spec field\n     */\n    public CardValue getValue() {\n        checkRep();\n        try {\n            CardValue v = ... // decode value\n            return v;\n        } finally {\n            checkRep();\n        }\n    }\n\n    ...\n}\n\n```", "```\npublic class Stack {\n    private int[] elements;\n\n    // Abstraction function:\n    //    The Nth element from the bottom of the stack = elements[N-1]\n    //    where the 1st element is at the bottom\n\n    // Rep Invariant:\n    //    For any index i such that 0 <= i < size, elements[i] != null\n\n    // OR\n\n    // Rep Invariant:\n    //    elements never contains a null value\n}\n\n```", "```\npublic class SortedStack {\n    private int[] elements;\n\n    // Abstraction function:\n    //    The value considered 'least' in the stack = elements[size-1]\n    //    ...\n    //    The value considered 'greatest' in the stack = elements[0]\n\n    // Rep Invariant:\n    //    For any index i such that 0 <= i < size: elements[i] != null \n    //    For any index j such that 1 <= j < size: elements[j] <= elements[j-1]\n}\n\n```", "```\n// For a naive implementation with poor run-time performance:\npublic class Stack {\n    private int[] elements;\n    private int size;\n\n    // Abstraction function:\n    //    The top element of the stack = elements[0]\n    //    The second-from-the-top element of the stack = elements[1]\n    //    ...\n    //    The bottom element of the stack = elements[size-1]\n\n    // OR\n\n    // Abstraction function:\n    //    The Nth element from the top of the stack = elements[N-1]\n    //    where the 1st element is at the top\n}\n\n```", "```\n// For a tweaked implementation with great run-time performance:\npublic class Stack {\n    private int[] elements;\n    private int size;\n\n    // Abstraction function:\n    //    The top element of the stack = elements[size-1]\n    //    The second-from-the-top element of the stack = elements[size-2]\n    //    ...\n    //    The bottom element of the stack = elements[0]\n\n    // OR\n\n    // Abstraction function:\n    //    The Nth element from the bottom of the stack = elements[N-1]\n    //    where the 1st element is at the bottom\n}\n\n```", "```\n    // Abstraction function is\n    //    <[x,y],s^[for all 0<i\u2264chars.size(), chars[chars.size()-i]]> | x=front.rest,\n    //     y=back.first, s=n.toString()>\n```", "```\n        AF(r) = list l such that...\n\n        AF(r) = c_0 + c_1*x + c_2*x^2 + ...\n\n            where c_i = ...\n\n    ```", "```\n        suit = ...\n        value = ...\n    ```", "```\n     for example, 3 ? Three of Clubs\n\n    ```", "```\n     reverse(back)\n    ```", "```\n        chars contains no duplicates\n\n    ```", "```\n        for all 0\u2264i<j<chars.size, chars[i] != chars[j]\n\n    ```"]