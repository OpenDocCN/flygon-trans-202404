- en: 19Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19图
- en: '|     [19.1 Understanding Graphs](#%28part._.Understanding_.Graphs%29) |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [19.1 理解图](#%28part._.Understanding_.Graphs%29) |'
- en: '|     [19.2 Representations](#%28part._.Representations%29) |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|     [19.2 表示](#%28part._.Representations%29) |'
- en: '|       [19.2.1 Links by Name](#%28part._string-keys%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|       [19.2.1 按名称链接](#%28part._string-keys%29) |'
- en: '|       [19.2.2 Links by Indices](#%28part._.Links_by_.Indices%29) |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [19.2.2 按索引链接](#%28part._.Links_by_.Indices%29) |'
- en: '|       [19.2.3 A List of Edges](#%28part._.A_.List_of_.Edges%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [19.2.3 边的列表](#%28part._.A_.List_of_.Edges%29) |'
- en: '|       [19.2.4 Abstracting Representations](#%28part._.Abstracting_.Representations%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|       [19.2.4 抽象表示](#%28part._.Abstracting_.Representations%29) |'
- en: '|     [19.3 Measuring Complexity for Graphs](#%28part._complexity-of-graphs%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|     [19.3 测量图的复杂性](#%28part._complexity-of-graphs%29) |'
- en: '|     [19.4 Reachability](#%28part._.Reachability%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|     [19.4 可达性](#%28part._.Reachability%29) |'
- en: '|       [19.4.1 Simple Recursion](#%28part._.Simple_.Recursion%29) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [19.4.1 简单递归](#%28part._.Simple_.Recursion%29) |'
- en: '|       [19.4.2 Cleaning up the Loop](#%28part._.Cleaning_up_the_.Loop%29)
    |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|       [19.4.2 清理循环](#%28part._.Cleaning_up_the_.Loop%29) |'
- en: '|       [19.4.3 Traversal with Memory](#%28part._.Traversal_with_.Memory%29)
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|       [19.4.3 带有内存的遍历](#%28part._.Traversal_with_.Memory%29) |'
- en: '|       [19.4.4 A Better Interface](#%28part._.A_.Better_.Interface%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|       [19.4.4 更好的接口](#%28part._.A_.Better_.Interface%29) |'
- en: '|     [19.5 Depth- and Breadth-First Traversals](#%28part._dfs-bfs%29) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|     [19.5 深度和广度优先遍历](#%28part._dfs-bfs%29) |'
- en: '|     [19.6 Graphs With Weighted Edges](#%28part._.Graphs_.With_.Weighted_.Edges%29)
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|     [19.6 具有加权边的图](#%28part._.Graphs_.With_.Weighted_.Edges%29) |'
- en: '|     [19.7 Shortest (or Lightest) Paths](#%28part._.Shortest__or_.Lightest__.Paths%29)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|     [19.7 最短路径（或最轻路径）](#%28part._.Shortest__or_.Lightest__.Paths%29) |'
- en: '|     [19.8 Moravian Spanning Trees](#%28part._.Moravian_.Spanning_.Trees%29)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|     [19.8 摩拉维亚生成树](#%28part._.Moravian_.Spanning_.Trees%29) |'
- en: '|       [19.8.1 The Problem](#%28part._.The_.Problem%29) |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|       [19.8.1 问题](#%28part._.The_.Problem%29) |'
- en: '|       [19.8.2 A Greedy Solution](#%28part._.A_.Greedy_.Solution%29) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|       [19.8.2 一种贪心解决方案](#%28part._.A_.Greedy_.Solution%29) |'
- en: '|       [19.8.3 Another Greedy Solution](#%28part._.Another_.Greedy_.Solution%29)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|       [19.8.3 另一种贪心解决方案](#%28part._.Another_.Greedy_.Solution%29) |'
- en: '|       [19.8.4 A Third Solution](#%28part._.A_.Third_.Solution%29) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|       [19.8.4 第三种解决方案](#%28part._.A_.Third_.Solution%29) |'
- en: '|       [19.8.5 Checking Component Connectedness](#%28part._union-find-functional%29)
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|       [19.8.5 检查组件连通性](#%28part._union-find-functional%29) |'
- en: 'In [From Acyclicity to Cycles](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)
    we introduced a special kind of sharing: when the data become cyclic, i.e., there
    exist values such that traversing other reachable values from them eventually
    gets you back to the value at which you began. Data that have this characteristic
    are called graphs.Technically, a cycle is not necessary to be a graph; a tree
    or a DAG is also regarded as a (degenerate) graph. In this section, however, we
    are interested in graphs that have the potential for cycles.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[从无环到循环](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)中，我们介绍了一种特殊的共享方式：当数据变得循环时，即存在值，从这些值出发遍历其他可达值最终会回到开始的值。具有这种特性的数据称为图。在技术上，循环不一定是图；树或DAG也被视为（退化的）图。然而，在本节中，我们感兴趣的是具有循环潜力的图。
- en: 'Lots of very important data are graphs. For instance, the people and connections
    in social media form a graph: the people are nodes or vertices and the connections
    (such as friendships) are links or edges. They form a graph because for many people,
    if you follow their friends and then the friends of their friends, you will eventually
    get back to the person you started with. (Most simply, this happens when two people
    are each others’ friends.) The Web, similarly is a graph: the nodes are pages
    and the edges are links between pages. The Internet is a graph: the nodes are
    machines and the edges are links between machines. A transportation network is
    a graph: e.g., cities are nodes and the edges are transportation links between
    them. And so on. Therefore, it is essential to understand graphs to represent
    and process a great deal of interesting real-world data.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 许多非常重要的数据是图。例如，社交媒体中的人物和关系形成一个图：人物是节点或顶点，而连接（例如友谊）是链接或边。它们形成一个图，因为对于许多人来说，如果你关注他们的朋友，然后关注朋友的朋友，最终会回到你开始的人。
    （最简单地说，当两个人互相是朋友时，会发生这种情况。）同样，网络是一个图：节点是页面，边是页面之间的链接。互联网是一个图：节点是机器，边是机器之间的链接。交通网络是一个图：例如，城市是节点，边是它们之间的交通链接。等等。因此，理解图是表示和处理大量有趣的现实世界数据的必要条件。
- en: 'Graphs are important and interesting for not only practical but also principled
    reasons. The property that a traversal can end up where it began means that traditional
    methods of processing will no longer work: if it blindly processes every node
    it visits, it could end up in an infinite loop. Therefore, we need better structural
    recipes for our programs. In addition, graphs have a very rich structure, which
    lends itself to several interesting computations over them. We will study both
    these aspects of graphs below.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图对于不仅实际而且也是原则性的原因都很重要和有趣。遍历可以回到起点的属性意味着传统的处理方法将不再适用：如果它盲目地处理每个访问的节点，它可能会陷入无限循环。因此，我们需要更好的结构化程序配方。此外，图具有非常丰富的结构，这使得它们可以进行几种有趣的计算。我们将在下文中研究图的这两个方面。
- en: 19.1Understanding Graphs
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1理解图
- en: 'Consider again the binary trees we saw earlier [[Re-Examining Equality](Sharing_and_Equality.html#%28part._identical-eq%29)].
    Let’s now try to distort the definition of a “tree” by creating ones with cycles,
    i.e., trees with nodes that point back to themselves (in the sense of identical).
    As we saw earlier [[From Acyclicity to Cycles](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)],
    it is not completely straightforward to create such a structure, but what we saw
    earlier [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)]
    can help us here, by letting us suspend the evaluation of the cyclic link. That
    is, we have to not only use rec, we must also use a function to delay evaluation.
    In turn, we have to update the annotations on the fields. Since these are not
    going to be “trees” any more, we’ll use a name that is suggestive but not outright
    incorrect:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑我们之前见过的二叉树 [[重新审视相等性](Sharing_and_Equality.html#%28part._identical-eq%29)]。现在让我们尝试扭曲“树”的定义，通过创建具有循环的树来创建，即，具有指向自身的节点的树（就相同性而言）。正如我们之前所见
    [[从无环到循环](Sharing_and_Equality.html#%28part._acyc-to-cyc%29)]，要创建这样的结构并不完全简单，但是我们之前见到的
    [[函数生成流](func-as-data.html#%28part._streams-from-funs%29)] 可以帮助我们，在这里让我们推迟对循环链接的评估。也就是说，我们不仅要使用
    rec，我们还必须使用一个函数来延迟评估。依此类推，我们必须更新字段上的注释。由于这些不再是“树”，我们将使用一个既具有暗示性又不完全不正确的名称：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now let’s try to construct some cyclic values. Here are a few examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着构造一些循环值。以下是一些例子：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let’s try to compute the size of a BinT. Here’s the obvious program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试着计算 BinT 的大小。以下是显而易见的程序：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: (We’ll see why we call it sizeinf in a moment.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: (我们马上就会看到为什么我们把它称为 sizeinf。)
- en: Do Now!
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在该做什么了！
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What happens when we call sizeinf(tr)?
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们调用 sizeinf(tr) 时会发生什么？
- en: 'It goes into an infinite loop: hence the inf in its name.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它会进入一个无限循环：因此其名称中有 inf。
- en: 'There are two very different meanings for “size”. One is, “How many times can
    we traverse an edge?” The other is, “How many distinct nodes were constructed
    as part of the data structure?” With trees, by definition, these two are the same.
    With a DAG the former exceeds the latter but only by a finite amount. With a general
    graph, the former can exceed the latter by an infinite amount. In the case of
    a datum like tr, we can in fact traverse edges an infinite number of times. But
    the total number of constructed nodes is only one! Let’s write this as test cases
    in terms of a size function, to be defined:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“大小”有两个非常不同的含义。一个是，“我们可以遍历边缘多少次？”另一个是，“作为数据结构的一部分构造了多少个不同的节点？”对于树来说，根据定义，这两个是相同的。对于有向无环图（DAG），前者超过了后者，但只是有限量的。对于一般图，前者可以无限地超过后者。对于像
    tr 这样的数据，我们实际上可以无限次遍历边缘。但是构造的节点总数只有一个！让我们把这写成测试用例，以一个待定义的大小函数为基础：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It’s clear that we need to somehow remember what nodes we have visited previously:
    that is, we need a computation with “memory”. In principle this is easy: we just
    create an extra data structure that checks whether a node has already been counted.
    As long as we update this data structure correctly, we should be all set. Here’s
    an implementation.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们需要以某种方式记住我们以前访问过的节点：也就是说，我们需要一个带有“记忆”的计算。原则上这很容易：我们只需创建一个额外的数据结构来检查一个节点是否已经被计数。只要我们正确更新这个数据结构，我们就应该做好了准备。这里是一个实现。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The extra parameter, seen, is called an accumulator, because it “accumulates”
    the list of seen nodes.Note that this could just as well be a set; it doesn’t
    have to be a list. The support function it needs checks whether a given node has
    already been seen:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的参数 seen 被称为累加器，因为它“累积”了已见节点的列表。请注意，这也可以是一个集合；它不必是一个列表。它所需的支持函数检查给定节点是否已经被看到过：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How does this do? Well, sizect(tr) is indeed 1, but sizect(t1) is 3 and sizect(t2)
    is 7!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做如何？嗯，sizect(tr)确实是1，但sizect(t1)是3，sizect(t2)是7！
- en: Do Now!
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explain why these answers came out as they did.
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释为什么这些答案出现如此。
- en: 'The fundamental problem is that we’re not doing a very good job of remembering!
    Look at this pair of lines:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根本问题在于我们没有做好记忆！看看这一对行：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The nodes seen while traversing the left branch are effectively forgotten,
    because the only nodes we remember when traversing the right branch are those
    in ns: namely, the current node and those visited “higher up”. As a result, any
    nodes that “cross sides” are counted twice.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在遍历左分支时看到的节点实际上被遗忘了，因为在遍历右分支时我们记住的节点只有ns中的那些：即当前节点和那些访问过的“更高层”的节点。因此，任何“跨越边界”的节点都被计算了两次。
- en: The remedy for this, therefore, is to remember every node we visit. Then, when
    we have no more nodes to process, instead of returning only the size, we should
    return all the nodes visited until now. This ensures that nodes that have multiple
    paths to them are visited on only one path, not more than once. The logic for
    this is to return two values from each traversal—<wbr>the size and all the visited
    nodes—<wbr>and not just one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决这个问题的方法是记住我们访问的每个节点。然后，当我们没有更多节点要处理时，我们不仅返回大小，还应返回到目前为止访问的所有节点。这确保了具有多条路径的节点只在一条路径上被访问，而不是多次。这个逻辑是从每次遍历中返回两个值——<wbr>大小和所有访问的节点——<wbr>而不仅仅是一个。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Sure enough, this function satisfies the above tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，这个函数满足了上述测试。
- en: 19.2Representations
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.2表示
- en: The representation we’ve seen above for graphs is certainly a start towards
    creating cyclic data, but it’s not very elegant. It’s both error-prone and inelegant
    to have to write lam everywhere, and remember to apply functions to () to obtain
    the actual values. Therefore, here we explore other representations of graphs
    that are more conventional and also much simpler to manipulate.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到的图的表示方法当然是创建循环数据的一种开始，但并不十分优雅。到处写lam并记住将函数应用于()以获得实际值既容易出错又不优雅。因此，在这里我们探索其他更传统且更简单操作的图的表示方法。
- en: 'There are numerous ways to represent graphs, and the choice of representation
    depends on several factors:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多表示图的方法，选择表示方法取决于几个因素：
- en: The structure of the graph, and in particular, its density. We will discuss
    this further later ([Measuring Complexity for Graphs](#%28part._complexity-of-graphs%29)).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图的结构，特别是其密度。我们稍后会进一步讨论这一点（[衡量图的复杂性](#%28part._complexity-of-graphs%29)）。
- en: The representation in which the data are provided by external sources. Sometimes
    it may be easier to simply adapt to their representation; in particular, in some
    cases there may not even be a choice.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部来源提供数据的表示方式。有时简单地适应它们的表示可能更容易；特别是在某些情况下甚至可能没有选择。
- en: The features provided by the programming language, which make some representations
    much harder to use than others.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程语言提供的功能使得某些表示方法比其他方法更难使用。
- en: 'Previously [(part "sets")], we have explored the idea of having many different
    representations for one datatype. As we will see, this is very true of graphs
    as well. Therefore, it would be best if we could arrive at a common interface
    to process graphs, so that all later programs can be written in terms of this
    interface, without overly depending on the underlying representation.In terms
    of representations, there are three main things we need:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前[(部分“集合”)]，我们已经探讨了为一种数据类型有许多不同表示的想法。正如我们将看到的，这对图也是非常真实的。因此，最好是我们能够得到一个通用接口来处理图，这样所有后续程序都可以根据这个接口编写，而不过分依赖底层表示。在表示方面，我们需要三样主要的东西：
- en: A way to construct graphs.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种构建图的方法。
- en: A way to identify (i.e., tell apart) nodes or vertices in a graph.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种识别（即区分）图中节点或顶点的方法。
- en: Given a way to identify nodes, a way to get that node’s neighbors in the graph.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一种识别节点的方法，获取该节点在图中的邻居的方法。
- en: Any interface that satisfies these properties will suffice. For simplicity,
    we will focus on the second and third of these and not abstract over the process
    of constructing a graph.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 任何满足这些属性的接口都可以。为简单起见，我们将专注于这两个属性，而不是对构建图的过程进行抽象。
- en: Our running example will be a graph whose nodes are cities in the United States
    and edges are known direct flight connections between them, reminiscent of the
    route maps found in the back of airlines’ in-flight magazines.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的运行示例将是一个图，其节点是美国的城市，边是它们之间已知的直接航班连接，类似于航空公司机上杂志背面的路线图。
- en: 19.2.1Links by Name
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.1 按名称链接
- en: 'Here’s our first representation. We will assume that every node has a unique
    name (such a name, when used to look up information in a repository of data, is
    sometimes called a key). A node is then a key, some information about that node,
    and a list of keys that refer to other nodes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个表示。我们将假设每个节点都有一个唯一的名称（当这样的名称在数据存储库中用于查找信息时，有时被称为键）。然后，一个节点是一个键，关于该节点的一些信息，以及指向其他节点的键列表：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '(Here we’re assuming our keys are strings.)Here’s a concrete instance of such
    a graph:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: （这里我们假设我们的键是字符串。）以下是这样一个图的具体实例：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Given a key, here’s how we look up its neighbor:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个键，这是我们查找其邻居的方法：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Exercise
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert the comment in the function into an invariant about the datum. Express
    this invariant as a refinement and add it to the declaration of graphs.
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将函数中的注释转换为有关数据的不变式。将此不变式表达为一种细化，并将其添加到图的声明中。
- en: 'With this support, we can look up neighbors easily:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个支持，我们可以轻松地查找邻居：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When it comes to testing, some tests are easy to write. Others, however, might
    require describing entire nodes, which can be unwieldy, so for the purpose of
    checking our implementation it suffices to examine just a part of the result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行测试时，有些测试很容易编写。然而，其他一些测试可能需要描述整个节点，这可能很笨重，因此为了检查我们的实现，检查结果的一部分就足够了：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 19.2.2Links by Indices
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.2 按索引链接
- en: In some languages, it is common to use numbers as names. This is especially
    useful when numbers can be used to get access to an element in a constant amount
    of time (in return for having a bound on the number of elements that can be accessed).
    Here, we use a list—<wbr>which does not provide constant-time access to arbitrary
    elements—<wbr>to illustrate this concept. Most of this will look very similar
    to what we had before; we’ll comment on a key difference at the end.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，使用数字作为名称很常见。当数字可以用于在恒定时间内访问元素时（为了访问的元素数量有一个限制），这是特别有用的。在这里，我们使用一个列表—<wbr>它不提供对任意元素的恒定时间访问—<wbr>来说明这个概念。大部分内容看起来与之前的内容非常相似；我们将在最后评论一个关键的不同之处。
- en: 'First, the datatype:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，数据类型：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our graph now looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图现在看起来像这样：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'where we’re assuming indices begin at 0. To find a node:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们认为索引从0开始。要查找节点：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can then find neighbors almost as before:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们几乎可以像以前一样找到邻居：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, our tests also look similar:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的测试看起来也很相似：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Something deeper is going on here. The keyed nodes have intrinsic keys: the
    key is part of the datum itself. Thus, given just a node, we can determine its
    key. In contrast, the indexed nodes represent extrinsic keys: the keys are determined
    outside the datum, and in particular by the position in some other data structure.
    Given a node and not the entire graph, we cannot know for what its key is. Even
    given the entire graph, we can only determine its key by using identical, which
    is a rather unsatisfactory approach to recovering fundamental information. This
    highlights a weakness of using extrinsically keyed representations of information.
    (In return, extrinsically keyed representations are easier to reassemble into
    new collections of data, because there is no danger of keys clashing: there are
    no intrinsic keys to clash.)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了一些更深层次的事情。键控节点具有固有的键：键本身是数据的一部分。因此，仅仅给出一个节点，我们就可以确定其键。相比之下，索引节点表示外部键：键是在数据之外确定的，特别是由于在某些其他数据结构中的位置。给定一个节点而不是整个图，我们无法知道其键是什么。即使给出整个图，我们也只能通过使用identical来确定其键，这是一种对恢复基本信息的不太令人满意的方法。这凸显了使用外部键表示信息的弱点。（作为回报，外部键表示更容易重新组装成新的数据集合，因为不存在键冲突的危险：没有内在的键会冲突。）
- en: 19.2.3A List of Edges
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.3 边的列表
- en: 'The representations we have seen until now have given priority to nodes, making
    edges simply a part of the information in a node. We could, instead, use a representation
    that makes edges primary, and nodes simply be the entities that lie at their ends:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止看到的表示法优先考虑了节点，使边仅仅成为节点信息的一部分。相反，我们可以使用一种使边成为主要的表示法，而节点只是位于其末端的实体的表示法：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, our flight network becomes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的航班网络变为：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To obtain the set of neighbors:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取邻居的集合：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And to be sure:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '并确保： '
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, this representation makes it difficult to store complex information
    about a node without replicating it. Because nodes usually have rich information
    while the information about edges tends to be weaker, we often prefer node-centric
    representations. Of course, an alternative is to think of the node names as keys
    into some other data structure from which we can retrieve rich information about
    nodes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种表示方法使得存储节点的复杂信息变得困难，而不会复制它。因为节点通常具有丰富的信息，而边的信息倾向于较弱，我们通常更喜欢以节点为中心的表示。当然，另一种选择是将节点名称视为从中我们可以检索有关节点丰富信息的其他数据结构的键。
- en: 19.2.4Abstracting Representations
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.4抽象表示
- en: We would like a general representation that lets us abstract over the specific
    implementations. We will assume that broadly we have available a notion of Node
    that has content, a notion of Keys (whether or not intrinsic), and a way to obtain
    the neighbors—<wbr>a list of keys—<wbr>given a key and a graph. This is sufficient
    for what follows. However, we still need to choose concrete keys to write examples
    and tests. For simplicity, we’ll use string keys [[Links by Name](#%28part._string-keys%29)].
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个通用的表示方法，让我们能够抽象出特定的实现。我们假设广泛地，我们有一个节点的概念，其中包含内容，一个键的概念（无论是内在的还是外在的），以及一种根据键和图给出邻居（<wbr>键列表—<wbr>）的方法。这对于接下来的工作是足够的。然而，我们仍然需要选择具体的键来编写示例和测试。为简单起见，我们将使用字符串键[[按名称链接](#%28part._string-keys%29)]。
- en: 19.3Measuring Complexity for Graphs
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.3度量图的复杂性
- en: 'Before we begin to define algorithms over graphs, we should consider how to
    measure the size of a graph. A graph has two components: its nodes and its edges.
    Some algorithms are going to focus on nodes (e.g., visiting each of them), while
    others will focus on edges, and some will care about both. So which do we use
    as the basis for counting operations: nodes or edges?'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始定义图上的算法之前，我们应该考虑如何衡量图的大小。图有两个组成部分：节点和边。一些算法将专注于节点（例如，访问每个节点），而其他算法将专注于边，而有些算法将关注两者。那么我们用哪一个作为计数操作的基础：节点还是边？
- en: 'It would help if we can reduce these two measures to one. To see whether that’s
    possible, suppose a graph has \(k\) nodes. Then its number of edges has a wide
    range:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能将这两个度量值简化为一个就好了。为了查看是否可能，假设一个图有\(k\)个节点。然后其边的数量有很大的范围：
- en: No two nodes are connected. Then there are no edges at all.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有两个节点相连。那么就根本没有边。
- en: 'Every two nodes is connected. Then there are essentially as many edges as the
    number of pairs of nodes: approximately \(k^2\).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每两个节点都相连。然后边的数量基本上等于节点对的数量：大约\(k^2\)。
- en: In general, we call a graph with significantly fewer edges than nodes a sparse
    graph, while one with significantly more edges than nodes is called dense.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果图的边远少于节点，则称为稀疏图，而如果边远多于节点，则称为稠密图。
- en: The number of nodes can thus be significantly less or even significantly more
    than the number of edges. Were this difference a matter of constants, we could
    have ignored it; but it’s not. For sparse graphs, the number of nodes dominates
    the number of edges by a factor of \(k\) (or even infinity, if there truly are
    zero edges, but such graphs are usually not very interesting or difficult to process);
    for extremely dense graphs, too, the ratio is one of \(k\), but in the other direction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，节点的数量可能显著少于或甚至显著多于边的数量。如果这种差异是常数问题，我们可以忽略它；但事实并非如此。对于稀疏图，节点的数量比边的数量多\(k\)倍（或者甚至是无穷大，如果确实没有边，但这样的图通常不太有趣或难以处理）；对于非常稠密的图，比值也是\(k\)的一个，但是方向相反。
- en: Therefore, when we want to speak of the complexity of algorithms over graphs,
    we have to consider the sizes of both the number of nodes and edges. In a connected
    graphA graph is connected if, from every node, we can traverse edges to get to
    every other node., however, there must be at least as many edges as nodes, which
    means the number of edges dominates the number of nodes. Since we are usually
    processing connected graphs, or connected parts of graphs one at a time, we can
    bound the number of nodes by the number of edges.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们想要讨论图上算法的复杂性时，我们必须考虑节点数量和边数量的大小。在一个连通图中，如果从每个节点出发，我们可以通过边到达每个其他节点，则边的数量至少与节点的数量相同，这意味着边的数量比节点的数量多。由于我们通常处理连通图，或者一次处理图的连通部分，我们可以将节点的数量限制在边的数量内。
- en: 19.4Reachability
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.4可达性
- en: 'Many uses of graphs need to address reachability: whether we can, using edges
    in the graph, get from one node to another. For instance, a social network might
    suggest as contacts all those who are reachable from existing contacts. On the
    Internet, traffic engineers care about whether packets can get from one machine
    to another. On the Web, we care about whether all public pages on a site are reachable
    from the home page. We will study how to compute reachability using our travel
    graph as a running example.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多图的用途需要解决可达性问题：即我们是否可以通过图中的边从一个节点到达另一个节点。例如，社交网络可能会建议所有可以从现有联系人到达的联系人。在互联网上，流量工程师关心数据包是否可以从一台机器到达另一台机器。在网络上，我们关心站点上的所有公共页面是否可以从主页到达。我们将以我们的旅行图作为一个运行示例来研究如何计算可达性。
- en: 19.4.1Simple Recursion
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.1简单递归
- en: 'At its simplest, reachability is easy. We want to know whether there exists
    a pathA path is a sequence of zero or more linked edges. between a pair of nodes,
    a source and a destination. (A more sophisticated version of reachability might
    compute the actual path, but we’ll ignore this for now.) There are two possibilities:
    the source and destintion nodes are the same, or they’re not.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式下，可达性很容易。我们想知道是否存在一条路径（路径是零个或多个链接边的序列）在一对节点之间，一个源节点和一个目标节点之间。 （更复杂的可达性版本可能计算实际路径，但我们暂时忽略这一点。）有两种可能性：源节点和目标节点相同，或者它们不同。
- en: If they are the same, then clearly reachability is trivially satisfied.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们相同，那么显然可达性是显而易见的。
- en: If they are not, we have to iterate through the neighbors of the source node
    and ask whether the destination is reachable from each of those neighbors.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们不同，我们必须遍历源节点的邻居，并询问目标节点是否可以从这些邻居中的每一个到达。
- en: This translates into the following function:<graph-reach-1-main> ::=
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这转化为以下函数：<graph-reach-1-main> ::=
- en: '|   fun reach-1(src :: Key, dst :: Key, g :: Graph) -> Boolean: |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|   fun reach-1(src :: Key, dst :: Key, g :: Graph) -> Boolean: |'
- en: '|     if src == dst: |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|     if src == dst: |'
- en: '|       true |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|       true |'
- en: '|     else: |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|     else: |'
- en: '|       [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|       [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29) |'
- en: '|       loop(neighbors(src, g)) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|       loop(neighbors(src, g)) |'
- en: '|     end |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: where the loop through the neighbors of src is:<graph-reach-1-loop> ::=
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 循环通过 src 的邻居的过程是：<graph-reach-1-loop> ::=
- en: '|   fun loop(ns): |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|   fun loop(ns): |'
- en: '|     cases (List) ns: |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|     cases (List) ns: |'
- en: '|       &#124; empty => false |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; empty => false |'
- en: '|       &#124; link(f, r) => |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|       &#124; link(f, r) => |'
- en: '|         if reach-1(f, dst, g): true else: loop(r) end |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|         if reach-1(f, dst, g): true else: loop(r) end |'
- en: '|     end |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: We can test this as follows:<graph-reach-tests> ::=
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式进行测试：<graph-reach-tests> ::=
- en: '|   check: |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|   check: |'
- en: '|     reach = reach-1 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|     reach = reach-1 |'
- en: '|     reach("nwk", "nwk", kn-cities) is true |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|     reach("nwk", "nwk", kn-cities) 为 true |'
- en: '|     reach("nwk", "chi", kn-cities) is true |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|     reach("nwk", "chi", kn-cities) 为 true |'
- en: '|     reach("nwk", "wor", kn-cities) is false |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|     reach("nwk", "wor", kn-cities) 为 false |'
- en: '|     reach("nwk", "hou", kn-cities) is true |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|     reach("nwk", "hou", kn-cities) 为 true |'
- en: '|     reach("nwk", "den", kn-cities) is true |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|     reach("nwk", "den", kn-cities) 为 true |'
- en: '|     reach("nwk", "saf", kn-cities) is true |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|     reach("nwk", "saf", kn-cities) 为 true |'
- en: '|   end |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: Unfortunately, we don’t find out about how these tests fare, because some of
    them don’t complete at all. That’s because we have an infinite loop, due to the
    cyclic nature of graphs!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法了解这些测试的结果，因为其中一些根本无法完成。这是因为我们有一个无限循环，由于图的循环性质！
- en: Exercise
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the above examples leads to a cycle? Why?
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以上例子中哪一个导致了循环？为什么？
- en: 19.4.2Cleaning up the Loop
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.2清理循环
- en: Before we continue, let’s try to improve the expression of the loop. While the
    nested function above is a perfectly reasonable definition, we can use Pyret’s
    for to improve its readability.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们尝试改进循环的表达。虽然上面的嵌套函数是一个完全合理的定义，但我们可以使用 Pyret 的 for 来提高其可读性。
- en: 'The essence of the above loop is to iterate over a list of boolean values;
    if one of them is true, the entire loop evaluates to true; if they are all false,
    then we haven’t found a path to the destination node, so the loop evaluates to
    false. Thus:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述循环的本质是遍历一个布尔值列表；如果其中一个为 true，则整个循环评估为 true；如果它们全部为 false，则我们没有找到到达目标节点的路径，因此循环评估为
    false。因此：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this, we can replace the loop definition and use with:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以替换循环定义和使用为：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 19.4.3Traversal with Memory
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.3带有记忆的遍历
- en: Because we have cyclic data, we have to remember what nodes we’ve already visited
    and avoid traversing them again. Then, every time we begin traversing a new node,
    we add it to the set of nodes we’ve already started to visit so that. If we return
    to that node, because we can assume the graph has not changed in the meanwhile,
    we know that additional traversals from that node won’t make any difference to
    the outcome.This property is known as [☛ idempotence](glossary.html#%28elem._glossary-idempotence%29).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有循环数据，我们必须记住我们已经访问过的节点，并避免再次遍历它们。因此，每次我们开始遍历一个新节点时，我们将其添加到我们已经开始访问的节点集合中。如果我们返回到该节点，因为我们可以假设图在此期间没有发生变化，我们知道从该节点进行的额外遍历不会对结果产生任何影响。这种属性被称为[☛幂等性](glossary.html#%28elem._glossary-idempotence%29)。
- en: 'We therefore define a second attempt at reachability that take an extra argument:
    the set of nodes we have begun visiting (where the set is represented as a graph).
    The key difference from [<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)
    is, before we begin to traverse edges, we should check whether we’ve begun processing
    the node or not. This results in the following definition:<graph-reach-2> ::='
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了第二次尝试可达性，它需要一个额外的参数：我们已经开始访问的节点集合（其中集合表示为图）。与[<graph-reach-1-main>](#%28elem._graph-reach-1-main%29)的关键区别在于，在我们开始遍历边之前，我们应该检查是否已经开始处理该节点。这导致以下定义：<graph-reach-2>
    ::=
- en: '|   fun reach-2(src :: Key, dst :: Key, g :: Graph, visited :: List<Key>) ->
    Boolean: |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|   fun reach-2(src :: Key, dst :: Key, g :: Graph, visited :: List<Key>) ->
    Boolean: |'
- en: '|     if visited.member(src): |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|     if visited.member(src): |'
- en: '|       false |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|       false |'
- en: '|     else if src == dst: |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|     else if src == dst: |'
- en: '|       true |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|       true |'
- en: '|     else: |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|     else: |'
- en: '|       new-visited = link(src, visited) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|       new-visited = link(src, visited) |'
- en: '|       for ormap(n from neighbors(src, g)): |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|       for ormap(n from neighbors(src, g)): |'
- en: '|         reach-2(n, dst, g, new-visited) |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|         reach-2(n, dst, g, new-visited) |'
- en: '|       end |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|       end |'
- en: '|     end |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|     end |'
- en: '|   end |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|   end |'
- en: 'In particular, note the extra new conditional: if the reachability check has
    already visited this node before, there is no point traversing further from here,
    so it returns false. (There may still be other parts of the graph to explore,
    which other recursive calls will do.)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要注意额外的新条件：如果可达性检查已经访问过此节点，则从这里进一步遍历没有意义，因此返回false。（可能仍然有其他部分的图需要探索，其他递归调用会处理。）
- en: Exercise
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does it matter if the first two conditions were swapped, i.e., the beginning
    of reach-2 began with
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果前两个条件交换了会有什么影响，即，reach-2的开始是否以以下方式开始
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '? Explain concretely with examples.'
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '? 用具体示例解释。'
- en: Exercise
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We repeatedly talk about remembering the nodes that we have begun to visit,
    not the ones we’ve finished visiting. Does this distinction matter? How?
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们反复谈论我们已经开始访问的节点，而不是我们已经完成访问的节点。这种区别重要吗？为什么？
- en: 19.4.4A Better Interface
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.4更好的接口
- en: 'As the process of testing reach-2 shows, we may have a better implementation,
    but we’ve changed the function’s interface; now it has a needless extra argument,
    which is not only a nuisance but might also result in errors if we accidentally
    misuse it. Therefore, we should clean up our definition by moving the core code
    to an internal function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如测试reach-2的过程所示，我们可能有一个更好的实现，但我们改变了函数的接口；现在它有一个不必要的额外参数，这不仅是一个麻烦，而且如果我们意外地误用它，可能会导致错误。因此，我们应该通过将核心代码移动到内部函数来清理我们的定义：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have now restored the original interface while correctly implementing reachability.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经恢复了原始接口，同时正确实现了可达性。
- en: Exercise
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does this really gives us a correct implementation? In particular, does this
    address the problem that the size function above addressed? Create a test case
    that demonstrates the problem, and then fix it.
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样真的给我们一个正确的实现吗？特别是，这是否解决了上面的size函数所解决的问题？创建一个展示问题的测试用例，然后修复它。
- en: 19.5Depth- and Breadth-First Traversals
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.5深度优先和广度优先遍历
- en: It is conventional for computer science texts to call these depth- and breadth-first
    search. However, searching is just a specific purpose; traversal is a general
    task that can be used for many purposes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学文本通常将这些称为深度优先和广度优先搜索。然而，搜索只是一个特定目的；遍历是一个通用任务，可以用于许多目的。
- en: 'The reachability algorithm we have seen above has a special property. At every
    node it visits, there is usually a set of adjacent nodes at which it can continue
    the traversal. It has at least two choices: it can either visit each immediate
    neighbor first, then visit all of the neighbors’ neighbors; or it can choose a
    neighbor, recur, and visit the next immediate neighbor only after that visit is
    done. The former is known as breadth-first traversal, while the latter is depth-first
    traversal.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面看到的可达性算法有一个特殊的属性。在它访问的每个节点，通常存在一组相邻节点，它可以继续遍历。它至少有两个选择：它可以首先访问每个直接邻居，然后访问所有邻居的邻居；或者它可以选择一个邻居，进行递归，并且仅在该访问完成后才访问下一个直接邻居。前者被称为广度优先遍历，而后者被称为深度优先遍历。
- en: 'The algorithm we have designed uses a depth-first strategy: inside [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29),
    we recur on the first element of the list of neighbors before we visit the second
    neighbor, and so on. The alternative would be to have a data structure into which
    we insert all the neighbors, then pull out an element at a time such that we first
    visit all the neighbors before their neighbors, and so on. This naturally corresponds
    to a queue ([An Example: Queues from Lists](amortized-analysis.html#%28part._queue-data-structure%29)).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的算法使用深度优先策略：在 [<graph-reach-1-loop>](#%28elem._graph-reach-1-loop%29) 中，我们在访问第二个邻居之前对邻居列表的第一个元素进行递归，依此类推。另一种方法是有一个数据结构，我们将所有邻居插入其中，然后每次取出一个元素，这样我们首先访问所有邻居的邻居，依此类推。这自然对应于一个队列（[一个例子：从列表创建队列](amortized-analysis.html#%28part._queue-data-structure%29)）。
- en: Exercise
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Using a queue, implement breadth-first traversal.
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用队列，实现广度优先遍历。
- en: 'If we correctly check to ensure we don’t re-visit nodes, then both breadth-
    and depth-first traversal will properly visit the entire reachable graph without
    repetition (and hence not get into an infinite loop). Each one traverses from
    a node only once, from which it considers every single edge. Thus, if a graph
    has \(N\) nodes and \(E\) edges, then a lower-bound on the complexity of traversal
    is \(O([N, E \rightarrow N + E])\). We must also consider the cost of checking
    whether we have already visited a node before (which is a set membership problem,
    which we address elsewhere: (part "sets")). Finally, we have to consider the cost
    of maintaining the data structure that keeps track of our traversal. In the case
    of depth-first traversal, recursion—<wbr>which uses the machine’s stack—<wbr>does
    it automatically at constant overhead. In the case of breadth-first traversal,
    the program must manage the queue, which can add more than constant overhead.In
    practice, too, the stack will usually perform much better than a queue, because
    it is supported by machine hardware.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正确检查以确保不重新访问节点，那么广度优先和深度优先遍历都将正确访问整个可达图而不重复（因此不会陷入无限循环）。每个遍历从一个节点只遍历一次，从中考虑每一条边。因此，如果一个图有\(N\)个节点和\(E\)条边，那么遍历的复杂度下界为\(O([N,
    E \rightarrow N + E])\)。我们还必须考虑检查我们是否已经访问过一个节点的成本（这是一个集合成员问题，在其他地方我们会解决：（部分"sets"））。最后，我们必须考虑维护跟踪我们遍历的数据结构的成本。在深度优先遍历的情况下，递归——<wbr>使用机器的栈——<wbr>会以恒定的开销自动完成。在广度优先遍历的情况下，程序必须管理队列，这可能会增加超过常数的开销。实际上，栈通常比队列表现得更好，因为它得到了机器硬件的支持。
- en: 'This would suggest that depth-first traversal is always better than breadth-first
    traversal. However, breadth-first traversal has one very important and valuable
    property. Starting from a node \(N\), when it visits a node \(P\), count the number
    of edges taken to get to \(P\). Breadth-first traversal guarantees that there
    cannot have been a shorter path to \(P\): that is, it finds a shortest path to
    \(P\).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能暗示深度优先遍历总是比广度优先遍历更好。然而，广度优先遍历具有一个非常重要且有价值的特性。从节点\(N\)开始，当它访问节点\(P\)时，计算到达\(P\)的边的数量。广度优先遍历保证不可能有一条更短的路径到达\(P\)：也就是说，它找到了一条最短路径到\(P\)。
- en: Exercise
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why “a” rather than “the” shortest path?
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么是“a”而不是“the”最短路径？
- en: Do Now!
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Prove that breadth-first traversal finds a shortest path.
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明广度优先遍历找到最短路径。
- en: 19.6Graphs With Weighted Edges
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.6带有加权边的图
- en: 'Consider a transportation graph: we are usually interested not only in whether
    we can get from one place to another, but also in what it “costs” (where we may
    have many different cost measures: money, distance, time, units of carbon dioxide,
    etc.). On the Internet, we might care about the [☛ latency](glossary.html#%28elem._glossary-latency%29)
    or [☛ bandwidth](glossary.html#%28elem._glossary-bandwidth%29) over a link. Even
    in a social network, we might like to describe the degree of closeness of a friend.
    In short, in many graphs we are interested not only in the direction of an edge
    but also in some abstract numeric measure, which we call its weight.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个交通图：我们通常不仅关心是否可以从一个地方到达另一个地方，还关心“成本”（我们可能有许多不同的成本度量：金钱、距离、时间、二氧化碳单位等）。在互联网上，我们可能关心链接的[☛延迟](glossary.html#%28elem._glossary-latency%29)或[☛带宽](glossary.html#%28elem._glossary-bandwidth%29)。甚至在社交网络中，我们可能想描述朋友之间的亲密程度。简而言之，在许多图中，我们不仅对边的方向感兴趣，还对一些抽象的数值度量感兴趣，我们称之为权重。
- en: 'In the rest of this study, we will assume that our graph edges have weights.
    This does not invalidate what we’ve studied so far: if a node is reachable in
    an unweighted graph, it remains reachable in a weighted one. But the operations
    we are going to study below only make sense in a weighted graph.We can, however,
    always treat an unweighted graph as a weighted one by giving every edge the same,
    constant, positive weight (say one).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本研究的其余部分中，我们将假设我们的图边具有权重。这并不否定我们迄今所学的内容：如果在无权图中可达一个节点，在带权图中仍然可达。但是我们将在下面要研究的操作只在带权图中才有意义。然而，我们总是可以通过给每条边赋予相同的常量正权重（比如说一）来将无权图视为带权图。
- en: Exercise
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When treating an unweighted graph as a weighted one, why do we care that every
    edge be given a positive weight?
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当将无权图视为带权图时，为什么我们关心每条边都被赋予正权重？
- en: Exercise
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Revise the graph data definitions to account for edge weights.
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改图的数据定义以考虑边的权重。
- en: Exercise
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Weights are not the only kind of data we might record about edges. For instance,
    if the nodes in a graph represent people, the edges might be labeled with their
    relationship (“mother”, “friend”, etc.). What other kinds of data can you imagine
    recording for edges?
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 权重并不是我们可能记录关于边的唯一类型的数据。例如，如果图中的节点代表人，边可以用他们的关系标记（“母亲”，“朋友”等）。你能想象记录边的其他什么类型的数据吗？
- en: 19.7Shortest (or Lightest) Paths
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.7 最短（或最轻）路径
- en: 'Imagine planning a trip: it’s natural that you might want to get to your destination
    in the least time, or for the least money, or some other criterion that involves
    minimizing the sum of edge weights. This is known as computing the shortest path.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下规划一次旅行：你可能希望以最短的时间、最少的金钱或其他一些涉及最小化边权重总和的标准到达目的地。这被称为计算最短路径。
- en: We should immediately clarify an unfortunate terminological confusion. What
    we really want to compute is the lightest path—<wbr>the one of least weight. Unfortunately,
    computer science terminology has settled on the terminology we use here; just
    be sure to not take it literally.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该立即澄清一个不幸的术语混淆。我们真正想计算的是最轻的路径——*最小权重*的路径。不幸的是，计算机科学术语已经确定了我们在这里使用的术语；只要确保不要字面理解即可。
- en: Exercise
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct a graph and select a pair of nodes in it such that the shortest path
    from one to the other is not the lightest one, and vice versa.
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建一个图并选择其中的一对节点，使得从一个节点到另一个节点的最短路径不是最轻的，反之亦然。
- en: We have already seen ([Depth- and Breadth-First Traversals](#%28part._dfs-bfs%29))
    that breadth-first search constructs shortest paths in unweighted graphs. These
    correspond to lightest paths when there are no weights (or, equivalently, all
    weights are identical and positive). Now we have to generalize this to the case
    where the edges have weights.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到（[深度和广度优先遍历](#%28part._dfs-bfs%29)）广度优先搜索在无权图中构建最短路径。当没有权重时，这对应于最轻的路径（或者等价地，所有权重都相同且为正）。现在我们必须将此推广到边具有权重的情况。
- en: We will proceed inductively, gradually defining a function seemingly of this
    type
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步归纳地定义一个似乎是这种类型的函数。
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'that reflects the weight of the lightest path from the source node to that
    one. But let’s think about this annotation: since we’re building this up node-by-node,
    initially most nodes have no weight to report; and even at the end, a node that
    is unreachable from the source will have no weight for a lightest (or indeed,
    any) path. Rather than make up a number that pretends to reflect this situation,
    we will instead use an option type:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了从源节点到该节点的最轻路径的权重。但是让我们思考一下这个注释：因为我们是逐个节点构建这个注释的，最初大多数节点都没有权重可报告；甚至到最后，从源节点无法到达的节点也没有最轻路径的权重（或者任何路径）。我们不会编造一个假装反映这种情况的数字，而是使用一个选项类型：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When there is some value it will be the weight; otherwise the weight will be
    none.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当有一些值时，它将是权重；否则权重将为 none。
- en: Now let’s think about this inductively. What do we know initially? Well, certainly
    that the source node is at a distance of zero from itself (that must be the lightest
    path, because we can’t get any lighter). This gives us a (trivial) set of nodes
    for which we already know the lightest weight. Our goal is to grow this set of
    nodes—<wbr>modestly, by one, on each iteration—<wbr>until we either find the destination,
    or we have no more nodes to add (in which case our desination is not reachable
    from the source).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们归纳地思考一下。最初我们知道什么？嗯，当然是源节点与自身的距离为零（这必须是最轻的路径，因为我们无法再轻了）。这给了我们一组（微不足道的）节点，我们已经知道了最轻的权重。我们的目标是扩展这组节点——<wbr>逐次增加一个节点，直到我们找到目标，或者我们没有更多的节点可添加（在这种情况下，我们的目的地从源节点不可达）。
- en: Inductively, at each step we have the set of all nodes for which we know the
    lightest path (initially this is just the source node, but it does mean this set
    is never empty, which will matter in what we say next). Now consider all the edges
    adjacent to this set of nodes that lead to nodes for which we don’t already know
    the lightest path. Choose a node, \(q\), that minimizes the total weight of the
    path to it. We claim that this will in fact be the lightest path to that node.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 归纳地，每一步我们都有一组我们知道最轻路径的所有节点（最初只是源节点，但这意味着这个集合永远不会为空，在接下来我们要说的话中这一点很重要）。现在考虑所有邻接到这组节点的边，这些边通向我们还不知道最轻路径的节点。选择一个节点\(q\)，使到它的路径的总权重最小。我们声明，这实际上将是通向该节点的最轻路径。
- en: If this claim is true, then we are done. That’s because we would now add \(q\)
    to the set of nodes whose lightest weights we now know, and repeat the process
    of finding lightest outgoing edges from there. This process has thus added one
    more node. At some point we will find that there are no edges that lead outside
    the known set, at which point we can terminate.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一说法成立，那么我们就完成了。因为我们现在将\(q\)添加到我们现在已知最轻权重的节点集中，并重复从那里找到最轻的出边的过程。这个过程因此添加了一个更多的节点。在某个时候，我们将发现没有边通向已知集之外，此时我们可以终止。
- en: 'It stands to reason that terminating at this point is safe: it corresponds
    to having computed the reachable set. The only thing left is to demonstrate that
    this greedy algorithm yields a lightest path to each node.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，在这一点上终止是安全的：这对应于计算到达集的情况。唯一剩下的就是证明这个贪婪算法给每个节点都找到了最轻的路径。
- en: We will prove this by contradiction. Suppose we have the path \(s \rightarrow
    d\) from source \(s\) to node \(d\), as found by the algorithm above, but assume
    also that we have a different path that is actually lighter. At every node, when
    we added a node along the \(s \rightarrow d\) path, the algorithm would have added
    a lighter path if it existed. The fact that it did not falsifies our claim that
    a lighter path exists (there could be a different path of the same weight; this
    would be permitted by the algorithm, but it also doesn’t contradict our claim).
    Therefore the algorithm does indeed find the lightest path.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过反证法证明这一点。假设我们有路径\(s \rightarrow d\)从源\(s\)到节点\(d\)，如上述算法所找到的，但也假设我们有一条实际上更轻的不同路径。在每个节点上，当我们沿着\(s
    \rightarrow d\)路径添加一个节点时，如果存在更轻的路径，算法将会添加更轻的路径。它没有找到更轻的路径，这一事实证明了我们存在更轻路径的说法是错误的（可能存在相同权重的不同路径；这在算法中是允许的，但这也不会与我们的说法相矛盾）。因此该算法确实找到了最轻的路径。
- en: 'What remains is to determine a data structure that enables this algorithm.
    At every node, we want to know the least weight from the set of nodes for which
    we know the least weight to all their neighbors. We could achieve this by sorting,
    but this is overkill: we don’t actually need a total ordering on all these weights,
    only the lightest one. A heap [REF] gives us this.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要确定一种数据结构，使得该算法能够实现。在每个节点，我们想要知道从已知最小权重到所有邻居节点的节点集的最小权重。我们可以通过排序来实现这一点，但这有点杀鸡用牛刀：实际上，我们并不需要对所有这些权重进行完全排序，只需要知道最轻的那个。一个堆[REF]能够满足我们的需求。
- en: Exercise
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we allowed edges of weight zero? What would change in the above algorithm?
  id: totrans-235
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们允许边的权重为零会怎样？上述算法会发生什么变化？
- en: Exercise
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What if we allowed edges of negative weight? What would change in the above
    algorithm?
  id: totrans-238
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们允许负权重的边会怎样？上述算法会发生什么变化？
- en: For your reference, this algorithm is known as Dijkstra’s Algorithm.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 供您参考，此算法被称为Dijkstra的算法。
- en: 19.8Moravian Spanning Trees
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.8摩拉维亚覆盖树
- en: 'At the turn of the milennium, the US National Academy of Engineering surveyed
    its members to determine the “Greatest Engineering Achievements of the 20th Century”.
    The list contained the usual suspects: electronics, computers, the Internet, and
    so on. But a perhaps surprising idea topped the list: (rural) electrification.Read
    more about it [on their site](http://www.greatachievements.org/).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在千禧年之交，美国国家工程院调查其成员，确定“20世纪最伟大的工程成就”。列表中包含了一些常见的：电子、计算机、互联网等等。但一个也许令人惊讶的想法排在了榜首：（农村）电气化。详细了解请查看[他们的网站](http://www.greatachievements.org/)。
- en: 19.8.1The Problem
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.8.1问题
- en: To understand the history of national electrical grids, it helps to go back
    to [Moravia](http://en.wikipedia.org/wiki/Moravia) in the 1920s. Like many parts
    of the world, it was beginning to realize the benefits of electricity and intended
    to spread it around the region. A Moravian academia named Otakar Borůvka heard
    about the problem, and in a remarkable effort, described the problem abstractly,
    so that it could be understood without reference to Moravia or electrical networks.
    He modeled it as a problem about graphs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解国家电网的历史，最好回到20世纪20年代的[摩拉维亚](http://en.wikipedia.org/wiki/Moravia)。和世界上许多地方一样，这里开始意识到电力的好处，并打算将其传播到该地区。一位摩拉维亚的学者名叫奥塔卡尔·博鲁夫卡听说了这个问题，并在一次非凡的努力中，将问题抽象地描述出来，以便可以不参考摩拉维亚或电网的情况下理解。他将其建模为一个关于图的问题。
- en: 'Borůvka observed that at least initially, any solution to the problem of creating
    a network must have the following characteristics:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Borůvka观察到，至少在最初，创建网络的任何解决方案必须具有以下特征：
- en: The electrical network must reach all the towns intended to be covered by it.
    In graph terms, the solution must be spanning, meaning it must visit every node
    in the graph.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电网必须覆盖到所有预期覆盖的城镇。用图的术语来说，解决方案必须是覆盖的，也就是说，它必须访问图中的每个节点。
- en: 'Redundancy is a valuable property in any network: that way, if one set of links
    goes down, there might be another way to get a payload to its destination. When
    starting out, however, redundancy may be too expensive, especially if it comes
    at the cost of not giving someone a payload at all. Thus, the initial solution
    was best set up without loops or even redundant paths. In graph terms, the solution
    had to be a tree.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冗余是任何网络中的一种有价值的属性：这样，如果一组链接失效，可能会有另一种方式将有效负载传送到目的地。然而，在起步阶段，冗余可能太昂贵了，特别是如果以完全不给某人有效负载为代价的话。因此，最初的解决方案最好没有环路，甚至没有冗余路径。用图的术语来说，解决方案必须是一棵树。
- en: Finally, the goal was to solve this problem for the least cost possible. In
    graph terms, the graph would be weighted, and the solution had to be a minimum.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，目标是以尽可能低的成本解决这个问题。用图的术语来说，图将被加权，解决方案必须是最小的。
- en: Thus Borůvka defined the Moravian Spanning Tree (MST) problem.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Borůvka定义了摩拉维亚覆盖树（MST）问题。
- en: 19.8.2A Greedy Solution
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.8.2贪婪算法
- en: 'Borůvka had published his problem, and another Czech mathematician, [Vojtěch
    Jarník](http://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk), came across it.
    Jarník came up with a solution that should sound familiar:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 博鲁夫卡已经发表了他的问题，另一位捷克数学家[沃伊切赫·亚尔尼克](http://en.wikipedia.org/wiki/Vojt%C4%9Bch_Jarn%C3%ADk)偶然间发现了它。亚尔尼克提出的解决方案应该听起来很熟悉：
- en: Begin with a solution consisting of a single node, chosen arbitrarily. For the
    graph consisting of this one node, this solution is clearly a minimum, spanning,
    and a tree.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个任意选择的单个节点开始，构建一个解决方案。对于仅包含这一个节点的图来说，这个解决方案显然是最小的、覆盖的，也是一棵树。
- en: Of all the edges incident on nodes in the solution that connect to a node not
    already in the solution, pick the edge with the least weight.Note that we consider
    only the incident edges, not their weight added to the weight of the node to which
    they are incident.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在连接到尚未包含在解决方案中的节点的解决方案中所有边中选择具有最小权重的边。请注意，我们仅考虑相邻的边，而不考虑它们的权重加到它们相邻的节点的权重上。
- en: Add this edge to the solution. The claim is that for the new solution will be
    a tree (by construction), spanning (also by construction), and a minimum. The
    minimality follows by an argument similar to that used for Dijkstra’s Algorithm.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这条边添加到解决方案中。声明是，对于新解决方案，将是一棵树（通过构造），跨度（也通过构造），并且是最小的。最小性是通过类似于迪杰斯特拉算法使用的论据得到的。
- en: Jarník had the misfortune of publishing this work in Czech in 1930, and it went
    largely ignored. It was rediscovered by others, most notably by R.C. Prim in 1957,
    and is now generally known as Prim’s Algorithm, though calling it Jarník’s Algorithm
    would attribute credit in the right place.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 雅尔尼克不幸的是在 1930 年用捷克语发表了这项工作，并且它基本上被忽视了。它被其他人重新发现，特别是在 1957 年被 R.C. 普林重新发现，现在通常称为普林姆算法，尽管称其为雅尔尼克算法将把功劳归于正确的地方。
- en: Implementing this algorithm is pretty easy. At each point, we need to know the
    lightest edge incident on the current solution tree. Finding the lightest edge
    takes time linear in the number of these edges, but the very lightest one may
    create a cycle. We therefore need to efficiently check for whether adding an edge
    would create a cycle, a problem we will return to multiple times ([Checking Component
    Connectedness](#%28part._union-find-functional%29)). Assuming we can do that effectively,
    we then want to add the lightest edge and iterate. Even given an efficient solution
    for checking cyclicity, this would seem to require an operation linear in the
    number of edges for each node. With better representations we can improve on this
    complexity, but let’s look at other ideas first.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个算法相当容易。在每个点，我们需要知道与当前解决方案树相邻的最轻的边。找到最轻的边需要与这些边的数量成正比的时间，但是最轻的边可能会创建一个循环。因此，我们需要有效地检查添加边是否会创建循环，这是一个我们将多次返回的问题（[检查组件连通性](#%28part._union-find-functional%29)）。假设我们可以有效地解决这个问题，然后我们想要添加最轻的边并进行迭代。即使考虑到一个有效的检查循环性的解决方案，这似乎也需要对每个节点进行与边数成正比的操作。通过更好的表示，我们可以改进这种复杂性，但是让我们首先看看其他想法。
- en: 19.8.3Another Greedy Solution
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一个贪婪解决方案
- en: Recall that Jarník presented his algorithm in 1930, when computers didn’t exist,
    and Prim his in 1957, when they were very much in their infancy. Programming computers
    to track heaps was a non-trivial problem, and many algorithms were implemented
    by hand, where keeping track of a complex data structure without making errors
    was harder still. There was need for a solution that was required less manual
    bookkeeping (literally speaking).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，雅尔尼克是在 1930 年提出他的算法的，那时计算机还不存在，普林姆是在 1957 年提出他的算法的，那时计算机正处于发展初期。编程跟踪堆是一个非常棘手的问题，许多算法是手工实现的，其中对复杂数据结构进行跟踪而不出错更加困难。需要一种需要较少手工簿记（从字面上讲）的解决方案。
- en: In 1956, [Joseph Kruskal](http://en.wikipedia.org/wiki/Joseph_Kruskal) presented
    such a solution. His idea was elegantly simple. The Jarník algorithm suffers from
    the problem that each time the tree grows, we have to revise the content of the
    heap, which is already a messy structure to track. Kruskal noted the following.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1956 年，[Joseph Kruskal](http://en.wikipedia.org/wiki/Joseph_Kruskal) 提出了这样一个解决方案。他的想法非常简洁。雅尔尼克算法遭受的问题是每次树增长时，我们都必须修订堆的内容，这已经是一个混乱的结构要跟踪。克鲁斯卡尔指出了以下事实。
- en: 'To obtain a minimum solution, surely we want to include one of the edges of
    least weight in the graph. Because if not, we can take an otherwise minimal solution,
    add this edge, and remove one other edge; the graph would still be just as connected,
    but the overall weight would be no more and, if the removed edge were heavier,
    would be less.Note the careful wording: there may be many edges of the same least
    weight, so adding one of them may remove another, and therefore not produce a
    lighter tree; but the key point is that it certainly will not produce a heavier
    one. By the same argument we can add the next lightest edge, and the next lightest,
    and so on. The only time we cannot add the next lightest edge is when it would
    create a cycle (that problem again!).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得最小解，我们肯定希望在图中包含一条最小权重的边。因为如果不包括，我们可以取一个否则是最小解，加上这条边，再移除另一条边；图仍然保持连接，但总体权重不会增加，而且如果移除的边更重，那么总体权重会减少。注意仔细的措辞：可能有许多权重相同的边，因此添加其中一条可能会移除另一条，因此不能产生更轻的树；但关键是它肯定不会产生更重的树。通过相同的论证，我们可以添加下一个最轻的边，以此类推。唯一不能添加下一个最轻的边的情况是当它会创建一个循环（再次出现这个问题！）。
- en: Therefore, Kruskal’s algorithm is utterly straightforward. We first sort all
    the edges, ordered by ascending weight. We then take each edge in ascending weight
    order and add it to the solution provided it will not create a cycle. When we
    have thus processed all the edges, we will have a solution that is a tree (by
    construction), spanning (because every connected vertex must be the endpoint of
    some edge), and of minimum weight (by the argument above). The complexity is that
    of sorting (which is \([e \rightarrow e \log e]\) where \(e\) is the size of the
    edge set. We then iterate over each element in \(e\), which takes time linear
    in the size of that set—<wbr>modulo the time to check for cycles. This algorithm
    is also easy to implement on paper, because we sort all the edges once, then keep
    checking them off in order, crossing out the ones that create cycles—<wbr>with
    no dynamic updating of the list needed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，克鲁斯卡尔算法是非常直观的。我们首先对所有边按升序权重排序。然后，按照升序权重顺序取每条边，并将其添加到解决方案中，只要它不会创建循环。当我们处理完所有边时，我们将得到一个树形解决方案（通过构造），跨度（因为每个连接的顶点必须是某条边的端点），并且具有最小权重（根据上述论证）。复杂度是排序的复杂度（这是\([e
    \rightarrow e \log e]\)，其中\(e\)是边集的大小）。然后我们对\(e\)中的每个元素进行迭代，这需要与该集合大小成线性关系的时间，除了检查循环所需的时间。这个算法也很容易在纸上实现，因为我们只需要一次对所有边排序，然后按顺序检查它们，划掉创建循环的边—<wbr>不需要对列表进行动态更新。
- en: 19.8.4A Third Solution
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.8.4第三种解决方案
- en: 'Both the Jarník and Kruskal solutions have one flaw: they require a centralized
    data structure (the priority heap, or the sorted list) to incrementally build
    the solution. As parallel computers became available, and graph problems grew
    large, computer scientists looked for solutions that could be implemented more
    efficiently in parallel—<wbr>which typically meant avoiding any centralized points
    of synchronization, such as these centralized data structures.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 雅尼克和克鲁斯卡尔的解决方案都有一个缺陷：它们需要一个集中的数据结构（优先堆或排序列表）来逐步构建解决方案。随着并行计算机的出现，以及图问题的规模增大，计算机科学家开始寻找可以更高效地在并行环境中实现的解决方案—<wbr>这通常意味着避免任何集中的同步点，例如这些集中的数据结构。
- en: In 1965, M. Sollin constructed an algorithm that met these needs beautifully.
    In this algorithm, instead of constructing a single solution, we grow multiple
    solution components (potentially in parallel if we so wish). Each node starts
    out as a solution component (as it was at the first step of Jarník’s Algorithm).
    Each node considers the edges incident to it, and picks the lightest one that
    connects to a different component (that problem again!). If such an edge can be
    found, the edge becomes part of the solution, and the two components combine to
    become a single component. The entire process repeats.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 1965年，M. Sollin构建了一个完美满足这些需求的算法。在这个算法中，我们不是构建单个解决方案，而是增长多个解决方案组件（如果愿意，可能是并行的）。每个节点最初都作为一个解决方案组件（就像雅尼克算法的第一步）。每个节点考虑与其相连的边，并选择连接到不同组件的最轻的边（再次出现这个问题！）。如果可以找到这样的边，则该边成为解决方案的一部分，并且两个组件合并为一个单一的组件。整个过程重复进行。
- en: Because every node begins as part of the solution, this algorithm naturally
    spans. Because it checks for cycles and avoids them, it naturally forms a tree.Note
    that avoiding cycles yields a DAG and is not automatically guaranteed to yield
    a tree. We have been a bit lax about this difference throughout this section.
    Finally, minimality follows through similar reasoning as we used in the case of
    Jarník’s Algorithm, which we have essentially run in parallel, once from each
    node, until the parallel solution components join up to produce a global solution.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个节点都作为解的一部分开始，这个算法自然地跨越。因为它检查循环并避免它们，它自然地形成一棵树。注意，避免循环会产生一个有向无环图，并不会自动保证产生一棵树。在本节中，我们对这个区别有些放松。最后，最小性通过类似的推理得到，就像我们在贾尔尼克算法的情况下使用的那样，我们基本上是并行运行的，每次从每个节点开始，直到并行解决方案组件汇聚起来产生一个全局解决方案。
- en: 'Of course, maintaining the data for this algorithm by hand is a nightmare.
    Therefore, it would be no surprise that this algorithm was coined in the digital
    age. The real surprise, therefore, is that it was not: it was originally created
    by [Otakar Borůvka](http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka) himself.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，手动维护这个算法的数据是一场噩梦。因此，这个算法是在数字时代创造出来的不足为奇。因此，真正的惊喜是，它原来不是这样的：它最初是由[Otakar Borůvka](http://en.wikipedia.org/wiki/Otakar_Bor%C5%AFvka)本人创建的。
- en: 'Borůvka, you see, had figured it all out. He’d not only understood the problem,
    he had:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，博鲁夫卡已经搞清楚了一切。他不仅理解了问题，他还：
- en: pinpointed the real problem lying underneath the electrification problem so
    it could be viewed in a context-independent way,
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定了电气化问题下面的真正问题，以便可以从与上下文无关的方式来看待它，
- en: created a descriptive language of graph theory to define it precisely, and
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个描述性的图论语言来精确定义它，
- en: even solved the problem in addition to defining it.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至解决了问题，而不仅仅是定义它。
- en: He’d just come up with a solution so complex to implement by hand that Jarník
    had in essence de-parallelized it so it could be done sequentially. And thus this
    algorithm lay unnoticed until it was reinvented ([several times, actually](http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm))
    by Sollin in time for parallel computing folks to notice a need for it. But now
    we can just call this Borůvka’s Algorithm, which is only fitting.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 他只是想出了一个解决方案，以至于Jarník本质上已经将其解除了并行化，以便可以按顺序执行。因此，直到被Sollin重新发现（[实际上，多次重新发现](http://en.wikipedia.org/wiki/Bor%C5%AFvka's_algorithm)）以适应并行计算人员的需求，这个算法才被注意到。但现在我们只需要称呼这个为博鲁夫卡算法，这是理所当然的。
- en: As you might have guessed by now, this problem is indeed called the MST in other
    textbooks, but “M” stands not for Moravia but for “Minimum”. But given Borůvka’s
    forgotten place in history, I prefer the more whimsical name.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经猜到了，这个问题在其他教科书中确实被称为最小生成树（MST），但“M”不是指摩拉维亚，而是指“最小”。但考虑到博鲁夫卡在历史上的被忽视地位，我更喜欢更古怪的名字。
- en: 19.8.5Checking Component Connectedness
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查组件连接性
- en: As we’ve seen, we need to be able to efficiently tell whether two nodes are
    in the same component. One way to do this is to conduct a depth-first traversal
    (or breadth-first traversal) starting from the first node and checking whether
    we ever visit the second one. (Using one of these traversal strategies ensures
    that we terminate in the presence of loops.) Unfortunately, this takes a linear
    amount of time (in the size of the graph) for every pair of nodes—<wbr>and depending
    on the graph and choice of node, we might do this for every node in the graph
    on every edge addition! So we’d clearly like to do this better.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们需要能够有效地确定两个节点是否在同一个组件中。一种方法是从第一个节点开始进行深度优先遍历（或广度优先遍历），然后检查我们是否曾经访问过第二个节点。（使用这些遍历策略之一可以确保在存在循环时终止。）不幸的是，这对每对节点需要花费线性的时间（与图的大小成比例）-并且根据图的情况和节点的选择，我们可能会对图中的每个节点在每次边添加时都这样做！所以我们显然希望做得更好。
- en: 'It is helpful to reduce this problem from graph connectivity to a more general
    one: of disjoint-set structure (colloquially known as union-find for reasons that
    will soon be clear). If we think of each connected component as a set, then we’re
    asking whether two nodes are in the same set. But casting it as a set membership
    problem makes it applicable in several other applications as well.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个问题从图连接性简化为更一般的问题很有帮助：不相交集结构（俗称并查集，原因很快就会清楚）。如果我们把每个连通分量看作一个集合，那么我们正在询问两个节点是否在同一个集合中。但将其转化为一个集合成员问题使得它在其他几个应用中也适用。
- en: The setup is as follows. For arbitrary values, we want the ability to think
    of them as elements in a set. We are interested in two operations. One is obviously
    union, which merges two sets into one. The other would seem to be something like
    is-in-same-set that takes two elements and determines whether they’re in the same
    set. Over time, however, it has proven useful to instead define the operator find
    that, given an element, “names” the set (more on this in a moment) that the element
    belongs to. To check whether two elements are in the same set, we then have to
    get the “set name” for each element, and check whether these names are the same.
    This certainly sounds more roundabout, but this means we have a primitive that
    may be useful in other contexts, and from which we can easily implement is-in-same-set.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 设置如下。对于任意值，我们希望能够将它们视为集合中的元素。我们感兴趣的是两个操作。一个显然是并集，它将两个集合合并为一个。另一个看起来像是is-in-same-set，它接受两个元素并确定它们是否在同一个集合中。然而，随着时间的推移，实际上定义了一个更有用的操作，即find运算符，它给定一个元素，“命名”了元素所属的集合（稍后再说）。要检查两个元素是否在同一个集合中，我们需要获取每个元素的“集合名称”，并检查这些名称是否相同。这听起来固然有些绕弯，但这意味着我们有了一个在其他情况下可能有用的原始操作，并且我们可以很容易地从中实现is-in-same-set。
- en: 'Now the question is, how do we name sets? The real question we should ask is,
    what operations do we care to perform on these names? All we care about is, given
    two names, they represent the same set precisely when the names are the same.
    Therefore, we could construct a new string, or number, or something else, but
    we have another option: simply pick some element of the set to represent it, i.e.,
    to serve as its name. Thus we will associate each set element with an indicator
    of the “set name” for that element; if there isn’t one, then its name is itself
    (the none case of parent):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，我们如何命名集合？我们真正应该问的问题是，我们关心对这些名称执行什么操作？我们关心的只是，给定两个名称，当且仅当这两个名称相同时，它们确实代表相同的集合。因此，我们可以构造一个新的字符串、或者数字，或者其他东西，但我们还有另一个选择：简单地选择集合的某个元素来代表它，即，作为它的名称。因此，我们将每个集合元素与该元素的“集合名称”指示符关联起来；如果没有，则它的名称就是它自己（父对象的none情况）：
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will assume we have some equality predicate for checking when two elements
    are the same, which we do by comparing their value parts, ignoring their parent
    values:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设我们有一些相等谓词，用于检查两个元素何时相同，我们通过比较它们的值部分来执行此操作，忽略它们的父值：
- en: '[PRE29]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Do Now!
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手做！
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why do we check only the value parts?
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么我们只检查值部分？
- en: We will assume that for a given set, we always return the same representative
    element. (Otherwise, equality will fail even though we have the same set.) Thus:We’ve
    used the name fynd because find is already defined to mean something else in Pyret.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设对于给定的集合，我们始终返回相同的代表元素。（否则，即使我们有相同的集合，相等性也会失败。）因此：我们使用了名称fynd，因为在Pyret中，find已经被定义为表示其他意义。
- en: '[PRE30]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'where Sets is the list of all elements:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其中Sets是所有元素的列表：
- en: '[PRE31]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'How do we find the representative element for a set? We first find it using
    is-same-element; when we do, we check the element’s parent field. If it is none,
    that means this very element names its set; this can happen either because the
    element is a singleton set (we’ll initialize all elements with none), or it’s
    the name for some larger set. Either way, we’re done. Otherwise, we have to recursively
    find the parent:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找到集合的代表元素？我们首先使用is-same-element找到它；当我们这样做时，我们检查元素的父字段。如果它是none，那么这意味着这个元素就是它的集合的名称；这可能是因为元素是一个单例集合（我们将所有元素初始化为none），或者它是一些较大集合的名称。无论哪种情况，我们都完成了。否则，我们必须递归地找到父对象：
- en: '[PRE32]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Exercise
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is this recursive in the nested cases?
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么这在嵌套情况下是递归的？
- en: 'What’s left is to implement union. For this, we find the representative elements
    of the two sets we’re trying to union; if they are the same, then the two sets
    are already in a union; otherwise, we have to update the data structure:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并查集的剩余部分就是要实现并。为此，我们找到两个要并的集合的代表元素；如果它们相同，那么这两个集合已经在一个并集中；否则，我们必须更新数据结构：
- en: '[PRE33]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To update, we arbitrarily choose one of the set names to be the name of the
    new compound set. We then have to update the parent of the other set’s name element
    to be this one:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新，我们任意选择一个集合名称作为新复合集合的名称。然后，我们必须将另一个集合的名称元素的父对象更新为此集合的名称：
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here are some tests to illustrate this working:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些测试来说明这个工作原理：
- en: '[PRE35]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Unfortunately, this implementation suffers from two major problems:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种实现遇到了两个主要问题：
- en: First, because we are performing functional updates, the value of the parent
    reference keeps “changing”, but these changes are not visible to older copies
    of the “same” value. An element from different stages of unioning has different
    parent references, even though it is arguably the same element throughout. This
    is a place where functional programming hurts.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，因为我们正在执行函数式更新，父引用的值保持“变化”，但这些变化对于“相同”值的旧副本是不可见的。来自不同联合阶段的元素具有不同的父引用，尽管在整个过程中它们可能是相同的元素。这是函数式编程带来问题的地方。
- en: Relatedly, the performance of this implementation is quite bad. fynd recursively
    traverses parents to find the set’s name, but the elements traversed are not updated
    to record this new name. We certainly could update them by reconstructing the
    set afresh each time, but that complicates the implementation and, as we will
    soon see, we can do much better.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关的是，这个实现的性能非常糟糕。fynd 递归地遍历父级以找到集合的名称，但遍历的元素没有更新以记录这个新名称。我们当然可以每次重新构建集合来更新它们，但这会使实现变得复杂，并且，正如我们很快会看到的，我们可以做得更好。
- en: 'The bottom line is that pure functional programming is not a great fit with
    this problem. We need a better implementation strategy: [Disjoint Sets Redux](Algorithms_That_Exploit_State.html#%28part._union-find%29).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 底线是，纯函数式编程与这个问题并不是很匹配。我们需要一个更好的实现策略：[不相交集合重访](Algorithms_That_Exploit_State.html#%28part._union-find%29)。
