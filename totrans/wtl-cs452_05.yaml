- en: Lecture 5 - Tasks & Kernels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pubilc Service Annoucements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due date for assignment 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partners
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel of a Real-time Operating System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is a task?
  prefs: []
  type: TYPE_NORMAL
- en: A set of instructions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Current state, which is changed by executing instructions, which includes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: values of its variables, which are automatic variables maintained on the stack
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: contents of its registers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: other processor state such as the PSR
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: processor mode
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: condition codes
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: etc.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: its run state and other things maintained by the kernel
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two tasks can use the same set of instructions, but
  prefs: []
  type: TYPE_NORMAL
- en: every task has its own state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, no static variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel keeps track of every task's state
  prefs: []
  type: TYPE_NORMAL
- en: In essence, servicing a request amounts to changing the state of one or more
    tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel maintains a task descriptor (TD) for each created task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is, to create a task the kernel must allocate a TD and initialize it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TD normally contains
  prefs: []
  type: TYPE_NORMAL
- en: The task's stack pointer, which points to a private stack, in the memory of
    the task, containing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PC
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: other registers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: local variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: all ready to be reloaded whenever the task next runs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Possibly the return value for when the task is next activated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Possibly something to support a Destroy primitive
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task's state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Links to queues on which the task is located
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The kernel uses these to find the task when it is ervicing a request
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible states of the task
  prefs: []
  type: TYPE_NORMAL
- en: 'Active: running or about to run'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a single processor system only one task can ever be active.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: But we would like to generalize smoothly to more than one processor.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ready: can run if scheduled'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Need a queue used by the scheduler when deciding which task should be the next
    active task
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blocked: waiting for something to happen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Need several queues, one for each thing that could happen
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Zombie
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Undead, won't execute instructions, but retains its resources.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The kernel is just a function like any other, but which runs forever.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Where is the OS?
  prefs: []
  type: TYPE_NORMAL
- en: requests come from running user tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in essence system calls
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: one type of request creates a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There needs to be a first task that gets everything going
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: All the interesting stuff inside done by the kernel is hidden inside `getNextRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What's inside `activate( active )`?
  prefs: []
  type: TYPE_NORMAL
- en: transfer of control to the active task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: execution to completion of the active task
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`to completion'' means until the active task sends a request to the kernel'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: transfer of control back to the kernel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: getting the request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hard part to get right is `transfer of control'
  prefs: []
  type: TYPE_NORMAL
- en: which we call a context switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming a context switch requires you to know the processor architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ARM 920T
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is it?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two modes of labelling
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By architecture (now up to v7)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Architecture | InstructionSet | ThumbInstructions? | MultiplyInstruction
    | DSPInstructions | Comments |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv1 | 1 | no | no | no | Obsolete |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv2 | 2 | no | no | no | Obsolete |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv3 | 3 | no | no | no |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv3M | 3 | no | yes | no |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv4 | 4 | no | yes | no |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv4T | 4 | yes | yes | no | This is the one in the box. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv5 | 5 | no | yes | no | Has `CLZ` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv5T | 5 | yes | yes | no |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARMv5TE | 5 | yes | yes | yes |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Thumb instructions are 16 bit, and accelerated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: They use the full 32 bits of the registers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve code density (less memory needed).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They effectively double the size of the instruction cache (fewer time-consuming
    cache misses).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By processor core
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ProcessorCore | ARMISA | ThumbISA | Comments |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARM7TDMI | v4T | v1 | Most of the ARM7xx processors |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARM9TDMI | v4T | v1 | ARM[920&#124;922&#124;940]T: 920T is the one in the
    box.`T'' means includes thumb instructions`DMI'' means direct memory interface
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| StrongARM | v4 | n/a | Intel SA-110\. Found in Compaq versions of IPAQ. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARM9E | v5TE | v2 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| ARM10E | v5TE | v2 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| XScale | v5TE | v2 | Manufactured by Intel. HP versions of IPAQ. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 16 32-bit registers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: r15, pc, special in the architecture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: r14, lr, special in the architecture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: r13, sp, special in the architecture
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: r12, ip, used by the compiler as a scratch register
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: r11, fp, used by the compiler as the frame pointer
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: r10, sl
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: r4 to r9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: r0 to r3, used by the compiler as scratch registers, for function arguments
    and return value
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: partially separate register sets different modes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: link register (`lr`), program counter (`pc`) are special, but not very special
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Processor modes. In the table below `special' means that the mode has ia separate
    copy of the registers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| M[4:0] | Mode | Registers accessible |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10000 | User | `r0-r15 cpsr` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10001 | FIQ (Fast interrupt processing) | `r0-r7, r15` `r8_fiq-r14_fiq``cpsr`,
    spsr_fiq |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10010 | IRQ (Interrupt processing) | `r0-r12, r15` `r13_`irq`,r14_`irq`cpsr`,
    `spsr_`irq |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10011 | Supervisor | `r0-r12, r15` `r13_`svc`,r14_`svc`cpsr`, `sprs_`svc
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 10111 | Abort | `r0-r12, r15` `r13_`abt`,r14_`abt`cpsr`, `spsr`_abt |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11011 | Undefined | `r0-r12, r15` `r13_`und`,r14_`und`cpsr`, `spsr_`und |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 11111 | System | `r0-r15``cpsr` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Program status register, which you will find in two places CPSR and SPSR
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Bit | Mnemonic | Meaning |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 31 | N | Negative |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 30 | Z | Zero |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 29 | C | Carry |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 28 | V | Overflow |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 8-27 | DNM | Does not matter in v4 |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 7 | I | Interrupts disabled |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 6 | F | Fast interrupts disabled |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 5 | T | Thumb execution |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 4 | M4 | Five processor mode bits |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 3 | M3 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 2 | M2 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 1 | M1 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| 0 | M0 |  |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Exceptions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| ExceptionType | ModesCalled from | Mode atCompletion | InstructionAddress
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Reset | hardware | supervisor | `0x00` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Undefined instruction | any | undefined | `0x04` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Software interrupt | any | supervisor | `0x08` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Prefetch abort | any | abort | `0x0c` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Data abort | any | abort | `0x10` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Ordinary interrupt | any | IRQ | `0x18` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Fast interrupt | any | FIQ | `0x1c` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: You are concerned right now with Reset and Software Interrupt.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The first instruction executed by the CPU after reset is the one at location
    `0x00000000`. Usually it is
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: which you will normally find in addresses `0x00` to `0x1c`. Just executing an
    instruction, rather than having an address that is specially processed saves transistors,
    which is good.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: RedBoot puts entry points of RedBoot into addresses `0x20` to `0x3c.`This makes
    it possible to jump to any location in the 32 bit address space.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Note endianness of RedBoot output when examining these locations.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Three data types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'word: 32 bits, word-aligned'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'half-word: 16 bits, half-word-aligned'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'byte: 8 bits'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: General Comments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: each instruction is exactly one word
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: load and store RISC architecture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: rich set of addressing modes, based on barrel shifting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: allows you to keep any partial computation it makes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Context Switch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Step-by-step
  prefs: []
  type: TYPE_NORMAL
- en: Function Call (gcc calling conventions)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the role of the index pointer (ip), link register (lr) and stack pointer
    (sp).
  prefs: []
  type: TYPE_NORMAL
- en: The final instruction could be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: is a `NOP`.
  prefs: []
  type: TYPE_NORMAL
- en: Software Interrupt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The software interrupt instruction ( SWI{cond} <immed_24> ). What happens when
    it is executed?
  prefs: []
  type: TYPE_NORMAL
- en: r14_svc <- address of the following instruction. This is where the kernel will
    return to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SPSR_svc <- CPSR. This saves the mode, condition codes, etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CPSR[0:4] <- 0b10011\. Supervisor mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CPSR[5] <- 0\. ARM (not Thumb) state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CPSR[7] <- 1\. Normal interrupts disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PC <- 0x08
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CPU ignores the 24-bit immediate value, which can be used by the programmer
    as an argument identifying the system call, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: is a `NOP`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is above kernel entry?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you put swi in a wrapper or stub what happens before and after it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request had arguments, how would you get them into the kernel?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hint. How does `gcc` pass arguments into a function?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It might be important that there are two link registers. Which two link registers?
    Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In practice it isn't important. Why not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: Try this first on paper drawing the stack, registers, etc after each instruction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try coding in baby steps, which is usually a good idea in assembly language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try reading [this](../../pdf/context.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bill Cowan''s lecture notes for CS452 in s12](index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s Spring 2012 CS452 page](../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s CS452 page](../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s teaching page](../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bill Cowan''s home page](../../../../index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
