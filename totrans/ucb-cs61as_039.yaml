- en: HOFs - Procedures as Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **higher order function** (**HOF**) is a function that does one or both of
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes a function as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a function as its output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we jump in, let's have a quick refresher.
  prefs: []
  type: TYPE_NORMAL
- en: The Substitution Model Revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should already be very familiar with defining functions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function definition, the parameter of `f` is `x`, which is fed into
    the body as an argument to the built-in procedure `plus1`. If we bring back our
    substitution model from Lesson 1, we can say that a call to `f`, say, `(f 5)`,
    would be evaluated with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The argument `5` is substituted into the body of `f` and we call `plus1` on
    `5` to get `6`. Alright, that was too easy. But what if, instead of using `x`
    as an argument to the function in the body, we use it as the *function*?
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Higher Order Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Do you see how `g` is in front? Hmm. What happens if we call `(f 5)` this time?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Whoops. Looks like we need to feed `f` a procedure instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We could also feed `f` a lambda function!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Would you look at that! We just defined a function, `f`, that takes a procedure,
    `g`, as its argument and applies `g` to `2`. There it is, your first higher order
    function. Play around and see if you can define your own procedures that take
    other procedures as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Uses of Passing Functions as Arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've seen how functions can be passed around, let's actually explore
    how this can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These three functions compute the sum of the doubles, squares, and cubes of
    all integers between a and b, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `(sum-squares 5 8)` computes 5² + 6² + 7² + 8².
  prefs: []
  type: TYPE_NORMAL
- en: Defining all three of these functions seems a bit redundant. Do you see how
    these three functions are nearly identical in definition, except for the underlined
    portions of the code? It's time to build some abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: We know that for each of the three functions, we apply some operation to every
    element between `a` and `b`. So instead of having a specific function for each
    operation, let's abstract it away and put it in the function parameters!
  prefs: []
  type: TYPE_NORMAL
- en: 'So instead of having a specialized `sum-[op]` function for every possible operator,
    we''ll just have a general function called `sum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've underlined the major differences in the code above. In this definition
    of `sum`, we apply some input function `fn` to each number between `a` and `b`,
    as you can see in the recursive call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'and this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'and this too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Having only written one procedure, `sum`, we get the functionality of all three
    procedures above. What a deal!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like, the initial three procedures can be redefined using `sum` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In your homework, we will take the abstraction of `sum` even further with an
    extremely useful and well-known HOF called `accumulate`. **Make sure you understand
    how `accumulate` works, as you will need it in future exercises!**
  prefs: []
  type: TYPE_NORMAL
