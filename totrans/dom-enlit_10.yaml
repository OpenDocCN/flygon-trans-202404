- en: Chapter 5 - Element Node Geometry & Scrolling Geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5.1 Element node size, offsets, and scrolling overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DOM nodes are parsed and [painted](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#Painting)
    into visual shapes when viewing html documents in a web browser. Nodes, mostly
    element nodes, have a corresponding visual representation made viewable/visual
    by browsers. To inspect and in some cases manipulate the visual representation
    and gemometry of nodes programatically a set of API's exists and are specified
    in the [CSSOM View Module](http://www.w3.org/TR/cssom-view/). A subset of methods
    and properties found in this specification provide an API to determine the geometry
    (i.e. size & position using offset) of element nodes as well as hooks for manipulating
    scrollable nodes and getting values of scrolled nodes. This chapter breaks down
    these methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the properties (excluding *scrollLeft* & *scrollTop*) from the CSSOM
    View Module specification are read only and calculated each time they are accessed.
    In other words, the values are live
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Getting an elements *offsetTop* and *offsetLeft* values relative to the
    *offsetParent*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the properties *offsetTop* and *offsetLeft* we can get the offset pixel
    value of an element node from the *offsetParent*. These element node properties
    give us the distance in pixels from an elements outside top and left border to
    the inside top and left border of the *offsetParent*. The value of the *offsetParent*
    is determined by searching the nearest ancestor elements for an element that has
    a CSS position value not equal to static. If none are found then the *<body>*
    element or what some refer to as the "document" (as opposed to the browser viewport)
    is the *offsetParent* value. If during the ancestral search a *<td>*, *<th>*,
    or *<table>* element with a CSS position value of static is found then this becomes
    the value of *offsetParent*.
  prefs: []
  type: TYPE_NORMAL
- en: Lets verify that *offsetTop* and *offsetLeft* provide the values one might expect.
    The properties *offsetLeft* and *offsetTop* in the code below tell us that the
    *<div>* with an *id* of *red* is 60px's from the top and left of the *offsetParent*
    (i.e. the *<body>* element in this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/dj5h9](http://jsfiddle.net/domenlightenment/dj5h9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Examine the following image showing what the code visually show in browser to
    help aid your understanding of how the *offsetLeft* and *offsetTop* values are
    deteremined. The red *<div>* shown in the image is exactly 60 pixels from the
    *offsetParent*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c4sec2.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice I am measuring from the outside border of the red *<div>* element to
    the inside border of the *offsetParent* (i.e. *<body>*).
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned If I was to change the blue *<div>* in the above code
    to have a position of absolute this would alter the value of the *offsetParent*.
    In the code below, absolutely positioning the blue *<div>* will cause the values
    returned from *offsetLeft* and *offsetTop* to report an offset (i.e. 25px's).
    This is because the offset parent is now the blue *<div>* and not the *<body>*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/ft2ZQ](http://jsfiddle.net/domenlightenment/ft2ZQ)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The image of the browser view shown below clarifies the new measurements returned
    from *offsetLeft* and *offsetTop* when the *offsetParent* is the blue *<div>*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c4sec2b.png)'
  prefs: []
  type: TYPE_IMG
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the browsers break the outside border to inside border measurement when
    the *offsetParent* is the *<body>* and the *<body>* or *<html>* element has a
    visible margin, padding, or border value.
  prefs: []
  type: TYPE_NORMAL
- en: The *offsetParent*, *offsetTop*, and *offsetLeft* are extensions to the *HTMLelement*
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Getting an elements top, right, bottom and left border edge offset relative
    to the viewport using *getBoundingClientRect()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the *getBoundingClientRect()* method we can get the position of an elements
    outside border edges as its painted in the browser viewport relative to the top
    and left edge of the viewport. This means the left and right edge are measured
    from the outside border edge of an element to the left edge of the viewport. And
    the top and bottom edges are measured from the outside border edge of an element
    to the top edge of the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: In the code below I create a 50px X 50px *<div>* with a 10px border and 100px
    margin. To get the distance in pixels from each border edge of the *<div>* I call
    the *getBoundingClientRect()* method on the *<div>* which returns an object containing
    a *top*, *right*, *bottom*, and *left* property.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/A3RN9](http://jsfiddle.net/domenlightenment/A3RN9)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The image below shows the browser rendered view of the above code with some
    added measurement indicators to show exactly how *getBoudingClientRect()* is calculated.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c4sec3.png)'
  prefs: []
  type: TYPE_IMG
- en: The *top* outside border edge of the *<div>* element is 100px from the top edge
    of the viewport. The *right* outside border edge of the element *<div>* is 170px
    from the left edge of the viewport. The *bottom* outside border edge of the element
    *<div>* is 170px from the top edge of the viewport. And the *left* outside border
    edge of the element *<div>* is 100px from the left edge of the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Getting an elements size (border + padding + content) in the viewport
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *getBoundingClientRect()* returns an object with a top, right, bottom, and
    left property/value but also with a height and width property/value. The *height*
    and *width* properties indicate the size of the element where the total size is
    derived by adding the content of the div, its padding, and borders together.
  prefs: []
  type: TYPE_NORMAL
- en: In the code below I get the size of the *<div>* element in the DOM using *getBoundingClientRect()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/PuXmL](http://jsfiddle.net/domenlightenment/PuXmL)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The exact same size values can also be found using from the *offsetHeight* and
    *offsetWidth* properties. In the code below I leverage these properties to get
    the same exact height and width values provided by *getBoundingClientRect()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/MSzL3](http://jsfiddle.net/domenlightenment/MSzL3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**## 5.5 Getting an elements size (padding + content) in the viewport excluding
    borders'
  prefs: []
  type: TYPE_NORMAL
- en: The *clientWidth* and *clientHeight* properties return a total size of an element
    by adding together the content of the element and its padding excluding the border
    sizes. In the code below I use these two properties to get the height and width
    of an element including padding but excluding borders.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/bSrSb](http://jsfiddle.net/domenlightenment/bSrSb)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**## 5.6 Getting topmost element in viewport at a specific point using *elementFromPoint()*'
  prefs: []
  type: TYPE_NORMAL
- en: Using *elementFromPoint()* it's possible to get a reference to the topmost element
    in an html document at a specific point in the document. In the code example below
    I simply ask what is the topmost element 50 pixels from the top and left of the
    viewport. Since we have two *<div*>'s at that location the topmost (or if there
    is no z-index set the last one in document order) div is selected and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/8ksS5](http://jsfiddle.net/domenlightenment/8ksS5)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 5.7 Getting the size of the element being scrolled using *scrollHeight* and
    *scrollWidth*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *scrollHeight* and *scrollWidth* properties simply give you the height and
    width of the node being scrolled. For example, open any HTML document that scrolls
    in a web browser and access these properties on the *<html>* (e.g. *document.documentElement.scrollWidth*)
    or *<body>* (e.g. *document.body.scrollWidth*) and you will get the total size
    of the HTML document being scrolled. Since we can apply, using CSS (i.e overflow:scroll),
    to elements lets look at a simpler code example. In the code below I make a *<div>*
    scroll a *<p>* element that is 1000px's x 1000px's. Accessing the *scrollHeight*
    and *scrollWidth* properties on the *<div>* will tell us that the element being
    scroll is 1000px's x 1000px's.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/9sZtZ](http://jsfiddle.net/domenlightenment/9sZtZ)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to know the height and width of the node inside a scrollable area
    when the node is smaller than the viewport of the scrollable area don't use *scrollHeight*
    and *scrollWidth* as this will give you the size of the viewport. If the node
    being scrolled is smaller than the scroll area then use *clientHeight* and *clientWidth*
    to determine the size of the node contained in the scrollable area.
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Getting & Setting pixels scrolled from the top and left using *scrollTop*
    and *scrollLeft*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *scrollTop* and *scrollLeft* properties are read-write properties that return
    the pixels to the left or top that are not currently viewable in the scrollable
    viewport due to scrolling. In the code below I setup a *<div>* that scrolls a
    *<p>* element.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/DqZYH](http://jsfiddle.net/domenlightenment/DqZYH)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I programatically scroll the *<div>* by setting the *scrollTop* and *scrollLeft*
    to 750\. Then I get the current value of *scrollTop* and *scrollLeft*, which of
    course since we just set the value to 750 will return a value of 750\. The 750
    reports the number of pixels scroll and indicates 750 px's to the left and top
    are not viewable in the viewport. If it helps just think of these properties as
    the pixel measurements of the content that is not shown in the viewport to the
    left or top.
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Scrolling an element into view using *scrollIntoView()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By selecting a node contained inside a node that is scrollable we can tell the
    selected node to scroll into view using the *scrollIntoView()* method. In the
    code below I select the fifth *<p>* element contained in the scrolling *<div>*
    and call *scrollIntoView()* on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/SyeFZ](http://jsfiddle.net/domenlightenment/SyeFZ)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By passing the *scrollIntoView()* method a parameter of *true* I am telling
    the method to scroll to the top of the element being scrolled too. The *true*
    parameter is however not needed as this is the default action performed by the
    method. If you want to scroll align to the bottom of the element pass a parameter
    of *false* to the *scrollIntoView()* method.****
  prefs: []
  type: TYPE_NORMAL
