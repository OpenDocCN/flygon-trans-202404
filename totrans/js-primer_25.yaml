- en: 関数とthis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/function-this/](https://jsprimer.net/basic/function-this/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: この章では`this`という特殊な動作をするキーワードについて見ていきます。 基本的にはメソッドの中で利用しますが、`this`は読み取り専用のグローバル変数のようなものでどこにでも書けます。
    加えて、`this`の参照先（評価結果）は条件によって異なります。
  prefs: []
  type: TYPE_NORMAL
- en: '`this`の参照先は主に次の条件によって変化します。'
  prefs: []
  type: TYPE_NORMAL
- en: 実行コンテキストにおける`this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: コンストラクタにおける`this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 関数とメソッドにおける`this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow Functionにおける`this`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: コンストラクタにおける`this`は、次の章である「[クラス](../class/)」で扱います。 この章ではさまざまな条件での`this`について扱いますが、`this`が実際に使われるのはメソッドにおいてです。
    そのため、あらゆる条件下での`this`の動きをすべて覚える必要はありません。
  prefs: []
  type: TYPE_NORMAL
- en: この章では、さまざまな条件下で変わる`this`の参照先と関数やArrow Functionとの関係を見ていきます。 また、実際にどのような状況で問題が発生するかを知り、`this`の動きを予測可能にするにはどのようにするかを見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#execution-context-this)*実行コンテキストと`this`*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*最初に「[JavaScriptとは](../introduction/)」の章において、JavaScriptには実行コンテキストとして"Script"と"Module"があるという話をしました。
    どの実行コンテキストでJavaScriptのコードを評価するかは、実行環境によってやり方が異なります。 この章では、ブラウザの`script`要素と`type`属性を使い、それぞれの実行コンテキストを明示しながら`this`の動きを見ていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: トップレベル（もっとも外側のスコープ）にある`this`は、実行コンテキストによって値が異なります。 実行コンテキストの違いは意識しにくい部分であり、トップレベルで`this`を使うと混乱を生むことになります。
    そのため、コードのトップレベルにおいては`this`を使うべきではありませんが、それぞれの実行コンテキストにおける動作を紹介します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#script-this)*スクリプトにおける`this`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*実行コンテキストが"Script"である場合、トップレベルのスコープに書かれた`this`はグローバルオブジェクトを参照します。 グローバルオブジェクトは、実行環境ごとに異なるものが定義されています。
    ブラウザのグローバルオブジェクトは`window`オブジェクト、Node.jsのグローバルオブジェクトは`global`オブジェクトとなります。'
  prefs: []
  type: TYPE_NORMAL
- en: ブラウザでは、`script`要素の`type`属性を指定していない場合は、実行コンテキストが"Script"として実行されます。 この`script`要素の直下に書いた`this`はグローバルオブジェクトである`window`オブジェクトとなります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[](#module-this)*モジュールにおける`this`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*実行コンテキストが"Module"である場合、そのトップレベルのスコープに書かれた`this`は常に`undefined`となります。'
  prefs: []
  type: TYPE_NORMAL
- en: ブラウザで、`script`要素に`type="module"`属性がついた場合は、実行コンテキストが"Module"として実行されます。 この`script`要素の直下に書いた`this`は`undefined`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: このように、トップレベルのスコープの`this`は実行コンテキストによって`undefined`となる場合があります。
  prefs: []
  type: TYPE_NORMAL
- en: 単純にグローバルオブジェクトを参照したい場合は、`this`ではなく`globalThis`を使います。 `globalThis`は実行環境のグローバルオブジェクトを参照するためにES2020で導入されました。
  prefs: []
  type: TYPE_NORMAL
- en: 実行環境のグローバルオブジェクトは、ブラウザでは`window`、Node.jsでは`global`のように名前が異なります。 そのため同じコードで、異なるグローバルオブジェクトを参照するには、コード上で分岐する必要がありました。
    ES2020ではこの問題を解決するために、実行環境のグローバルオブジェクトを参照する`globalThis`が導入されました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[](#function-and-method-this)*関数とメソッドにおける`this`*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '***関数**を定義する方法として、`function`キーワードによる関数宣言と関数式、Arrow Functionなどがあります。 `this`が参照先を決めるルールは、Arrow
    Functionとそれ以外の関数定義の方法で異なります。'
  prefs: []
  type: TYPE_NORMAL
- en: そのため、まずは関数定義の種類について振り返ってから、それぞれの`this`について見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#type-of-function)*関数の種類*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*「[関数と宣言](../function-declaration/)」の章で詳しく紹介していますが、関数の定義方法と呼び出し方について改めて振り返ってみましょう。
    **関数**を定義する場合には、次の3つの方法を利用します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: それぞれ定義した関数は`関数名()`と書くことで呼び出せます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[](#type-of-method)*メソッドの種類*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptではオブジェクトのプロパティが関数である場合にそれを**メソッド**と呼びます。 一般的にはメソッドも含めたものを**関数**と言い、関数宣言などとプロパティである関数を区別する場合に**メソッド**と呼びます。'
  prefs: []
  type: TYPE_NORMAL
- en: メソッドを定義する場合には、オブジェクトのプロパティに関数式を定義するだけです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: これに加えてメソッドには短縮記法があります。 オブジェクトリテラルの中で `メソッド名(){ /*メソッドの処理*/ }`と書くことで、メソッドを定義できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: これらのメソッドは、`オブジェクト名.メソッド名()`と書くことで呼び出せます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 関数定義とメソッドの定義についてまとめると、次のようになります。
  prefs: []
  type: TYPE_NORMAL
- en: '| 名前 | 関数 | メソッド |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 関数宣言(`function fn(){}`) | ✔ | x |'
  prefs: []
  type: TYPE_TB
- en: '| 関数式(`const fn = function(){}`) | ✔ | ✔ |'
  prefs: []
  type: TYPE_TB
- en: '| Arrow Function(`const fn = () => {}`) | ✔ | ✔ |'
  prefs: []
  type: TYPE_TB
- en: '| メソッドの短縮記法(`const obj = { method(){} }`) | x | ✔ |'
  prefs: []
  type: TYPE_TB
- en: 最初に書いたように`this`の挙動は、Arrow Functionの関数定義とそれ以外（`function`キーワードやメソッドの短縮記法）の関数定義で異なります。
    そのため、まずは**Arrow Function以外**の関数やメソッドにおける`this`を見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#function-without-arrow-function-this)*Arrow Function以外の関数における`this`*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Arrow Function以外の関数（メソッドも含む）における`this`は、実行時に決まる値となります。 言い方を変えると`this`は関数に渡される暗黙的な引数のようなもので、その渡される値は関数を実行するときに決まります。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードは疑似的なものです。 関数の中に書かれた`this`は、関数の呼び出し元から暗黙的に渡される値を参照することになります。 このルールはArrow
    Function以外の関数やメソッドで共通した仕組みとなります。Arrow Functionで定義した関数やメソッドはこのルールとは別の仕組みとなります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 関数における`this`の基本的な参照先（暗黙的に関数に渡す`this`の値）は**ベースオブジェクト**となります。 ベースオブジェクトとは「メソッドを呼ぶ際に、そのメソッドのドット演算子またはブラケット演算子のひとつ左にあるオブジェクト」のことを言います。
    ベースオブジェクトがない場合の`this`は`undefined`となります。
  prefs: []
  type: TYPE_NORMAL
- en: たとえば、`fn()`のように関数を呼び出したとき、この`fn`関数呼び出しのベースオブジェクトはないため、`this`は`undefined`となります。
    一方、`obj.method()`のようにメソッドを呼び出したとき、この`obj.method`メソッド呼び出しのベースオブジェクトは`obj`オブジェクトとなり、`this`は`obj`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`this`は関数の定義ではなく呼び出し方で参照する値が異なります。これは、後述する「`this`が問題となるパターン」で詳しく紹介します。 Arrow
    Function以外の関数では、関数の定義だけを見て`this`の値が何かということは決定できない点に注意が必要です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#function-declaration-expression-this)*関数宣言や関数式における`this`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*まずは、関数宣言や関数式の場合を見ていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次の例では、関数宣言で関数`fn1`、関数式で関数`fn2`を定義し、それぞれの関数内で`this`を返します。 定義したそれぞれの関数を`fn1()`と`fn2()`のようにただの関数として呼び出しています。
    このとき、ベースオブジェクトはないため、`this`は`undefined`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: これは、関数の中に関数を定義して呼び出す場合も同じです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: この書籍では注釈がないコードはstrict modeとして扱いますが、コード例に`"use strict";`と改めてstrict modeを明示しています（詳細は「[JavaScriptとは](../introduction/)」の[strict
    mode](../introduction/#strict-mode)を参照）。 なぜなら、strict modeではない状況で`this`が`undefined`の場合は、`this`がグローバルオブジェクトを参照するように変換される問題があるためです。
  prefs: []
  type: TYPE_NORMAL
- en: strict modeは、このような意図しにくい動作を防止するために導入されています。 しかしながら、strict modeのメソッド以外の関数における`this`は`undefined`となるため使い道がありません。
    そのため、メソッド以外で`this`を使う必要はありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#method-this)*メソッド呼び出しにおける`this`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*次に、メソッドの場合を見ていきます。 メソッドの場合は、そのメソッドが何かしらのオブジェクトに所属しています。 なぜなら、JavaScriptではオブジェクトのプロパティとして指定される関数のことをメソッドと呼ぶためです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次の例では`method1`と`method2`はそれぞれメソッドとして呼び出されています。 このとき、それぞれのベースオブジェクトは`obj`となり、`this`は`obj`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: これを利用すれば、メソッドの中から同じオブジェクトに所属する別のプロパティを`this`で参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: このようにメソッドが所属するオブジェクトのプロパティを、`オブジェクト名.プロパティ名`の代わりに`this.プロパティ名`で参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: オブジェクトは何重にもネストできますが、`this`はベースオブジェクトを参照するというルールは同じです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードを見てみると、ネストしたオブジェクトにおいてメソッド内の`this`がベースオブジェクトである`obj3`を参照していることがわかります。 このときのベースオブジェクトはドットでつないだ一番左の`obj1`ではなく、メソッドから見てひとつ左の`obj3`となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[](#this-problem)*`this`が問題となるパターン*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`this`はその関数（メソッドも含む）呼び出しのベースオブジェクトを参照することがわかりました。 `this`は所属するオブジェクトを直接書く代わりとして利用できますが、一方`this`にはいろいろな問題があります。'
  prefs: []
  type: TYPE_NORMAL
- en: この問題の原因は`this`がどの値を参照するかは関数の呼び出し時に決まるという性質に由来します。 この`this`の性質が問題となるパターンの代表的な2つの例とそれぞれの対策について見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#assign-this-function)*問題: `this`を含むメソッドを変数に代入した場合*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptではメソッドとして定義したものが、後からただの関数として呼び出されることがあります。 なぜなら、メソッドは関数を値に持つプロパティのことで、プロパティは変数に代入し直すことができるためです。'
  prefs: []
  type: TYPE_NORMAL
- en: そのため、メソッドとして定義した関数も、別の変数に代入してただの関数として呼び出されることがあります。 この場合には、メソッドとして定義した関数であっても、実行時にはただの関数であるためベースオブジェクトが変わっています。
    これは`this`が定義した時点ではなく実行したときに決まるという性質そのものです。
  prefs: []
  type: TYPE_NORMAL
- en: 具体的に、`this`が実行時に変わる例を見ていきます。 次の例では、`person.sayName`メソッドを変数`say`に代入してから実行しています。
    このときの`say`関数（`sayName`メソッドを参照）のベースオブジェクトはありません。 そのため、`this`は`undefined`となり、`undefined.fullName`は参照できずに例外を投げます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 結果的には、次のようなコードが実行されているのと同じです。 次のコードでは、`undefined.fullName`を参照しようとして例外が発生しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: このように、Arrow Function以外の関数において、`this`は定義したときではなく実行したときに決定されます。 そのため、関数に`this`を含んでいる場合、その関数は意図した呼ばれ方がされないと間違った結果が発生するという問題があります。
  prefs: []
  type: TYPE_NORMAL
- en: この問題の対処法としては大きく分けて2つあります。
  prefs: []
  type: TYPE_NORMAL
- en: 1つはメソッドとして定義されている関数はメソッドとして呼ぶということです。 メソッドをわざわざただの関数として呼ばなければそもそもこの問題は発生しません。
  prefs: []
  type: TYPE_NORMAL
- en: もう1つは、`this`の値を指定して関数を呼べるメソッドで関数を実行する方法です。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#call-apply-bind)*対処法: call、apply、bindメソッド*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*関数やメソッドの`this`を明示的に指定して関数を実行する方法もあります。 `Function`（関数オブジェクト）には`call`、`apply`、`bind`といった明示的に`this`を指定して関数を実行するメソッドが用意されています。'
  prefs: []
  type: TYPE_NORMAL
- en: '`call`メソッドは第一引数に`this`としたい値を指定し、残りの引数には呼び出す関数の引数を指定します。 暗黙的に渡される`this`の値を明示的に渡せるメソッドと言えます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 次の例では`this`に`person`オブジェクトを指定した状態で`say`関数を呼び出しています。 `call`メソッドの第二引数で指定した値が、`say`関数の仮引数`message`に入ります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`apply`メソッドは第一引数に`this`とする値を指定し、第二引数に関数の引数を配列として渡します。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 次の例では`this`に`person`オブジェクトを指定した状態で`say`関数を呼び出しています。 `apply`メソッドの第二引数で指定した配列は、自動的に展開されて`say`関数の仮引数`message`に入ります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`call`メソッドと`apply`メソッドの違いは、関数の引数への値の渡し方が異なるだけです。 また、どちらのメソッドも`this`の値が不要な場合は`null`を渡すのが一般的です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 最後に`bind`メソッドについてです。 名前のとおり`this`の値を束縛（bind）した新しい関数を作成します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 次の例では`this`を`person`オブジェクトに束縛した`say`関数をラップした関数を作っています。 `bind`メソッドの第二引数以降に値を渡すことで、束縛した関数の引数も束縛できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: この`bind`メソッドをただの関数で表現すると次のように書けます。 `bind`は`this`や引数を束縛した関数を作るメソッドだということがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: このように`call`、`apply`、`bind`メソッドを使うことで`this`を明示的に指定した状態で関数を呼び出せます。 しかし、毎回関数を呼び出すたびにこれらのメソッドを使うのは、関数を呼び出すための関数が必要になってしまい手間がかかります。
    そのため、基本的には「メソッドとして定義されている関数はメソッドとして呼ぶこと」でこの問題を回避するほうがよいでしょう。 その中で、どうしても`this`を固定したい場合には`call`、`apply`、`bind`メソッドを利用します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#callback-and-this)*問題: コールバック関数と`this`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*コールバック関数の中で`this`を参照すると問題となる場合があります。 この問題は、メソッドの中でArrayの`map`メソッドなどのコールバック関数を扱う場合に発生しやすいです。'
  prefs: []
  type: TYPE_NORMAL
- en: 具体的に、コールバック関数における`this`が問題となっている例を見てみましょう。 次のコードでは`prefixArray`メソッドの中で`map`メソッドを使っています。
    このとき、`map`メソッドのコールバック関数の中で、`Prefixer`オブジェクトを参照するつもりで`this`を参照しています。
  prefs: []
  type: TYPE_NORMAL
- en: しかし、このコールバック関数における`this`は`undefined`となり、`undefined.prefix`は参照できないためTypeErrorの例外が発生します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: なぜコールバック関数の中の`this`が`undefined`となるのかを見ていきます。 Arrayの`map`メソッドにはコールバック関数として、その場で定義した無名関数を渡していることに注目してください。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: このとき、Arrayの`map`メソッドに渡しているコールバック関数は`callback()`のようにただの関数として呼び出されます。 つまり、コールバック関数として呼び出すとき、この関数にはベースオブジェクトはありません。
    そのため`callback`関数の`this`は`undefined`となります。
  prefs: []
  type: TYPE_NORMAL
- en: 先ほどの例では無名関数をコールバック関数として直接メソッドに渡していますが、一度`callback`変数に入れてから渡しても結果は同じです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[](#substitute-this)*対処法: `this`を一時変数へ代入する*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*コールバック関数内での`this`の参照先が変わる問題への対処法として、`this`を別の変数に代入し、その`this`の参照先を保持するという方法があります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`this`は関数の呼び出し元で変化し、その参照先は呼び出し元におけるベースオブジェクトです。 `prefixArray`メソッドの呼び出しにおいては、`this`は`Prefixer`オブジェクトです。
    しかし、コールバック関数は改めて関数として呼び出されるため`this`が`undefined`となってしまうのが問題でした。'
  prefs: []
  type: TYPE_NORMAL
- en: そのため、最初の`prefixArray`メソッド呼び出しにおける`this`の参照先を一時変数として保存することでこの問題を回避できます。 次のコードでは、`prefixArray`メソッドの`this`を`that`変数に保持しています。
    コールバック関数からは`this`の代わりに`that`変数を参照することで、コールバック関数からも`prefixArray`メソッド呼び出しと同じ`this`を参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: もちろんFunctionの`call`メソッドなどで明示的に`this`を渡して関数を呼び出すこともできます。 また、Arrayの`map`メソッドなどは`this`となる値を引数として渡せる仕組みを持っています。
    そのため、次のように第二引数に`this`となる値を渡すことでも解決できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: しかし、これらの解決方法はコールバック関数において`this`が変わることを意識して書く必要があります。 そもそもメソッド呼び出しとその中でのコールバック関数における`this`が変わってしまうのが問題でした。
    ES2015では`this`を変えずにコールバック関数を定義する方法として、Arrow Functionが導入されました。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#arrow-function-callback)*対処法: Arrow Functionでコールバック関数を扱う*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*通常の関数やメソッドは呼び出し時に暗黙的に`this`の値を受け取り、関数内の`this`はその値を参照します。 一方、Arrow Functionはこの暗黙的な`this`の値を受け取りません。
    そのためArrow Function内の`this`は、スコープチェーンの仕組みと同様に外側の関数（この場合は`prefixArray`メソッド）を探索します。
    これにより、Arrow Functionで定義したコールバック関数は呼び出し方には関係なく、常に外側の関数の`this`をそのまま利用します。'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow Functionを使うことで、先ほどのコードは次のように書けます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: このように、Arrow Functionでのコールバック関数における`this`は簡潔です。 コールバック関数内での`this`の対処法として`this`を代入する方法を紹介しましたが、
    ES2015からはArrow Functionを使うのがもっとも簡潔です。
  prefs: []
  type: TYPE_NORMAL
- en: このArrow Functionと`this`の関係についてより詳しく見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#arrow-function-this)*Arrow Functionと`this`*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Arrow Functionで定義された関数やメソッドにおける`this`がどの値を参照するかは関数の定義時（静的）に決まります。 一方、Arrow
    Functionではない関数においては、`this`は呼び出し元に依存するため関数の実行時（動的）に決まります。'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow Functionとそれ以外の関数で大きく違うことは、Arrow Functionは`this`を暗黙的な引数として受けつけないということです。
    そのため、Arrow Function内には`this`が定義されていません。このときの`this`は外側のスコープ（関数）の`this`を参照します。
  prefs: []
  type: TYPE_NORMAL
- en: これは、変数におけるスコープチェーンの仕組みと同様で、そのスコープに`this`が定義されていない場合には外側のスコープを探索します。 そのため、Arrow
    Function内の`this`の参照で、常に外側のスコープ（関数）へと`this`の定義を探索しに行きます（詳細は[スコープチェーン](../function-scope/##scope-chain%7D)を参照）。
    また、`this`はECMAScriptのキーワードであるため、ユーザーは`this`という変数を定義できません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: これにより、通常の変数のように`this`がどの値を参照するかは静的（定義時）に決定されます（詳細は[静的スコープ](../function-scope/#static-scope)を参照）。
    つまり、Arrow Functionにおける`this`は「Arrow Function自身の外側のスコープに定義されたもっとも近い関数の`this`の値」となります。
  prefs: []
  type: TYPE_NORMAL
- en: 具体的なArrow Functionにおける`this`の動きを見ていきましょう。
  prefs: []
  type: TYPE_NORMAL
- en: まずは、関数式のArrow Functionを見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: 次の例では、関数式で定義したArrow Functionの中の`this`をコンソールに出力しています。 このとき、`fn`の外側には関数がないため、「自身より外側のスコープに定義されたもっとも近い関数」の条件にあてはまるものはありません。
    このときの`this`はトップレベルに書かれた`this`と同じ値になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: トップレベルに書かれた`this`の値は[実行コンテキスト](#execution-context-this)によって異なることを紹介しました。 `this`の値は、実行コンテキストが"Script"ならばグローバルオブジェクトとなり、"Module"ならば`undefined`となります。
  prefs: []
  type: TYPE_NORMAL
- en: 次の例のように、Arrow Functionを包むように通常の関数が定義されている場合はどうでしょうか。 Arrow Functionにおける`this`は「自身の外側のスコープにあるもっとも近い関数の`this`の値」となるのは同じです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: つまり、このArrow Functionにおける`this`は`outer`関数で`this`を参照した場合と同じ値になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[](#method-callback-arrow-function)*メソッドとコールバック関数とArrow Function*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*メソッド内におけるコールバック関数はArrow Functionをより活用できるパターンです。 `function`キーワードでコールバック関数を定義すると、`this`の値はコールバック関数の呼ばれ方を意識する必要があります。
    なぜなら、`function`キーワードで定義した関数における`this`は呼び出し方によって変わるためです。'
  prefs: []
  type: TYPE_NORMAL
- en: コールバック関数側から見ると、どのように呼ばれるかによって変わってしまう`this`を使うことはできません。 そのため、コールバック関数の外側のスコープで`this`を一時変数に代入し、それを使うという回避方法を取っていました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 一方、Arrow Functionでコールバック関数を定義した場合は、1つ外側の関数の`this`を参照します。 このときのArrow Functionで定義したコールバック関数における`this`は呼び出し方によって変化しません。
    そのため、`this`を一時変数に代入するなどの回避方法は必要ありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: このArrow Functionにおける`this`は呼び出し方の影響を受けません。 つまり、コールバック関数がどのように呼ばれるかという実装についてを考えることなく`this`を扱えます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[](#not-bind-arrow-function)*Arrow Functionは`this`をbindできない*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Arrow Functionで定義した関数では`call`、`apply`、`bind`を使った`this`の指定は単に無視されます。 これは、Arrow
    Functionは`this`を持てないためです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のようにArrow Functionで定義した関数に対して`call`で`this`を指定しても、`this`の参照先が代わっていないことがわかります。
    同様に`apply`や`bind`メソッドを使った場合も`this`の参照先は変わりません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 最初に述べたように`function`キーワードで定義した関数では呼び出し時に、ベースオブジェクトが`this`の値として暗黙的な引数のように渡されます。
    一方、Arrow Functionの関数は呼び出し時に`this`を受け取らず、`this`の参照先は定義時に静的に決定されます。
  prefs: []
  type: TYPE_NORMAL
- en: また、`this`が変わらないのはあくまでArrow Functionで定義した関数だけで、Arrow Functionの`this`が参照する「自身の外側のスコープにあるもっとも近い関数の`this`の値」は`call`メソッドで変更できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[](#conclusion)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`this`は状況によって異なる値を参照する性質を持ったキーワードであることを紹介しました。 その`this`の評価結果をまとめると次の表のようになります。'
  prefs: []
  type: TYPE_NORMAL
- en: '| 実行コンテキスト | strict mode | コード | `this`の評価結果 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Script | ＊ | `this` | globalThis |'
  prefs: []
  type: TYPE_TB
- en: '| Script | ＊ | `const fn = () => this` | globalThis |'
  prefs: []
  type: TYPE_TB
- en: '| Script | NO | `const fn = function(){ return this; }` | globalThis |'
  prefs: []
  type: TYPE_TB
- en: '| Script | YES | `const fn = function(){ return this; }` | undefined |'
  prefs: []
  type: TYPE_TB
- en: '| Script | ＊ | `const obj = { method: () => { return this; } }` | globalThis
    |'
  prefs: []
  type: TYPE_TB
- en: '| Module | YES | `this` | undefined |'
  prefs: []
  type: TYPE_TB
- en: '| Module | YES | `const fn = () => this` | undefined |'
  prefs: []
  type: TYPE_TB
- en: '| Module | YES | `const fn = function(){ return this; }` | undefined |'
  prefs: []
  type: TYPE_TB
- en: '| Module | YES | `const obj = { method: () => { return this; } }` | undefined
    |'
  prefs: []
  type: TYPE_TB
- en: '| ＊ | ＊ | `const obj = { method(){ return this; } }` | `obj` |'
  prefs: []
  type: TYPE_TB
- en: '| ＊ | ＊ | `const obj = { method: function(){ return this; } }` | `obj` |'
  prefs: []
  type: TYPE_TB
- en: ＊はどの場合でも`this`の評価結果に影響しないということを示しています。
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 実際にブラウザで実行した結果は[What is `this` value in JavaScript](https://azu.github.io/what-is-this/)というサイトで確認できます。
  prefs: []
  type: TYPE_NORMAL
- en: '`this`はオブジェクト指向プログラミングの文脈でJavaScriptに導入されました。 メソッド以外においても`this`は評価できますが、実行コンテキストやstrict
    modeなどによって結果が異なり、混乱の元となります。 そのため、メソッドではない通常の関数においては`this`を使うべきではありません。^([1](#fn_1))'
  prefs: []
  type: TYPE_NORMAL
- en: また、メソッドにおいても`this`は呼び出し方によって異なる値となり、それにより発生する問題と対処法について紹介しました。 コールバック関数における`this`はArrow
    Functionを使うことでわかりやすく解決できます。 この背景にはArrow Functionで定義した関数は`this`を持たないという性質があります。
  prefs: []
  type: TYPE_NORMAL
- en: ¹. ES2015の仕様編集者であるAllen Wirfs-Brock氏もただの関数においては`this`を使うべきではないと述べている。[https://twitter.com/awbjs/status/938272440085446657](https://twitter.com/awbjs/status/938272440085446657);
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")*******************
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
