["```\n\n    The development of the Imp language in Imp.v completely ignores\n    issues of concrete syntax \u2014 how an ascii string that a programmer\n    might write gets translated into abstract syntax trees defined by\n    the datatypes aexp, bexp, and com.  In this chapter, we\n    illustrate how the rest of the story can be filled in by building\n    a simple lexical analyzer and parser using Coq's functional\n    programming facilities.\n\n    It is not important to understand all the details here (and\n    accordingly, the explanations are fairly terse and there are no\n    exercises).  The main point is simply to demonstrate that it can\n    be done.  You are invited to look through the code \u2014 most of it\n    is not very complicated, though the parser relies on some\n    \"monadic\" programming idioms that may require a little work to\n    make out \u2014 but most readers will probably want to just skim down\n    to the Examples section at the very end to get the punchline.\n\n```", "```\n\n# Internals\n\n```", "```\n\n## Lexical Analysis\n\n```", "```\n\n## Parsing\n\n### Options With Errors\n\n    An option type with error messages:\n\n```", "```\n\n    Some syntactic sugar to make writing nested match-expressions on\n    optionE more convenient.\n\n```", "```\n\n### Generic Combinators for Building Parsers\n\n```", "```\n\n    A (step-indexed) parser that expects zero or more ps:\n\n```", "```\n\n    A parser that expects a given token, followed by p:\n\n```", "```\n\n    A parser that expects a particular token:\n\n```", "```\n\n### A Recursive-Descent Parser for Imp\n\n    Identifiers:\n\n```", "```\n\n    Numbers:\n\n```", "```\n\n    Parse arithmetic expressions\n\n```", "```\n\n    Parsing boolean expressions:\n\n```", "```\n\n    Parsing commands:\n\n```", "```\n\n# Examples\n\n```", "```\n\n```"]