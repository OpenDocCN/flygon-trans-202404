["```\n\n```", "```\n\n# Decorated Programs\n\n The beauty of Hoare Logic is that it is *compositional*: the\n    structure of proofs exactly follows the structure of programs.\n    This suggests that we can record the essential ideas of a proof\n    informally (leaving out some low-level calculational details) by\n    decorating a program with appropriate assertions on each of its\n    commands.  Such a *decorated program* carries with it\n    an (informal) proof of its own correctness.\n\n    For example, consider the program: \n\n```", "```\n\n   (Note the *parameters* m and p, which stand for\n   fixed-but-arbitrary numbers.  Formally, they are simply Coq\n   variables of type nat.)\n One possible specification for this program: \n\n```", "```\n\n Finally, here is a decorated version of the program, embodying a\n    proof of this specification: \n\n```", "```\n\n Concretely, a decorated program consists of the program text\n    interleaved with assertions (either a single assertion or possibly\n    two assertions separated by an implication).  To check that a\n    decorated program represents a valid proof, we check that each\n    individual command is *locally consistent* with its nearby\n    assertions in the following sense: \n\n*   SKIP is locally consistent if its precondition and\n          postcondition are the same:\n\n    ```", "```\n\n*   The sequential composition of c[1] and c[2] is locally\n          consistent (with respect to assertions P and R) if c[1] is\n          locally consistent (with respect to P and Q) and c[2] is\n          locally consistent (with respect to Q and R):\n\n    ```", "```\n\n*   An assignment is locally consistent if its precondition is the\n          appropriate substitution of its postcondition:\n\n    ```", "```\n\n*   A conditional is locally consistent (with respect to assertions\n          P and Q) if the assertions at the top of its \"then\" and\n          \"else\" branches are exactly P \u2227 b and P \u2227 \u00acb and if its\n          \"then\" branch is locally consistent (with respect to P \u2227 b\n          and Q) and its \"else\" branch is locally consistent (with\n          respect to P \u2227 \u00acb and Q):\n\n    ```", "```\n\n*   A while loop with precondition P is locally consistent if its\n          postcondition is P \u2227 \u00acb, if the pre- and postconditions of\n          its body are exactly P \u2227 b and P, and if its body is\n          locally consistent:\n\n    ```", "```\n\n*   A pair of assertions separated by \u21fe is locally consistent if\n          the first implies the second:\n\n    ```", "```\n\n          This corresponds to the application of hoare_consequence and\n          is the only place in a decorated program where checking whether\n          decorations are correct is not fully mechanical and syntactic,\n          but rather may involve logical and/or arithmetic reasoning. \n\n The above essentially describes a procedure for *verifying*\n    the correctness of a given proof involves checking that every\n    single command is locally consistent with the accompanying\n    assertions.  If we are instead interested in *finding* a proof for\n    a given specification, we need to discover the right assertions.\n    This can be done in an almost mechanical way, with the exception\n    of finding loop invariants, which is the subject of the next\n    section.  In the remainder of this section we explain in detail\n    how to construct decorations for several simple programs that\n    don't involve non-trivial loop invariants. \n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0+\u00a0Y;;\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0X\u00a0-\u00a0Y;;\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0-\u00a0Y\n\n```", "```\n    \u00a0\u00a0\u00a0\u00a0(m\u00a0+\u00a0n)\u00a0-\u00a0((m\u00a0+\u00a0n)\u00a0-\u00a0n)\u00a0=\u00a0n\u00a0\u2227\u00a0(m\u00a0+\u00a0n)\u00a0-\u00a0n\u00a0=\u00a0m\u00a0\n    \u00a0\u00a0\u00a0\u00a0(m\u00a0+\u00a0n)\u00a0-\u00a0m\u00a0=\u00a0n\u00a0\u2227\u00a0m\u00a0=\u00a0m\u00a0\n    \u00a0\u00a0\u00a0\u00a0n\u00a0=\u00a0n\u00a0\u2227\u00a0m\u00a0=\u00a0m\n\n    ```", "```\n\n## Example: Simple Conditionals\n\n Here is a simple decorated program using conditionals:\n\n```", "```\n\nThese decorations were constructed as follows:\n\n*   We start with the outer precondition (1) and postcondition (8).\n\n*   We follow the format dictated by the hoare_if rule and copy the\n        postcondition (8) to (4) and (7). We conjoin the precondition (1)\n        with the guard of the conditional to obtain (2). We conjoin (1)\n        with the negated guard of the conditional to obtain (5).\n\n*   In order to use the assignment rule and obtain (3), we substitute\n        Z by Y - X in (4). To obtain (6) we substitute Z by X - Y\n        in (7).\n\n*   Finally, we verify that (2) implies (3) and (5) implies (6). Both\n        of these implications crucially depend on the ordering of X and\n        Y obtained from the guard. For instance, knowing that X \u2264 Y\n        ensures that subtracting X from Y and then adding back X\n        produces Y, as required by the first disjunct of (3). Similarly,\n        knowing that \u00ac (X \u2264 Y) ensures that subtracting Y from X\n        and then adding back Y produces X, as needed by the second\n        disjunct of (6). Note that n - m + m = n does *not* hold for\n        arbitrary natural numbers n and m (for example, 3 - 5 + 5 =\n        5). \n\n#### Exercise: 2 starsM (if_minus_plus_reloaded)\n\n Fill in valid decorations for the following program:\n\n```", "```\n\n \u2610 \n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0True\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0X\u00a0\u2260\u00a00\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(2)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0True\u00a0\u2227\u00a0X\u00a0\u2260\u00a00\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(3)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0True\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0-\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(4)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0True\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(5)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0True\u00a0\u2227\u00a0X\u00a0=\u00a00\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(6)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a00\u00a0}}\n\n```", "```\nDefinition reduce_to_zero' : com :=\n\u00a0\u00a0WHILE BNot (BEq (AId X) (ANum 0)) DO\n\u00a0\u00a0\u00a0\u00a0X ::= AMinus (AId X) (ANum 1)\n\u00a0\u00a0END.\n\nTheorem reduce_to_zero_correct' :\n\u00a0\u00a0{{fun st \u21d2 True}}\n\u00a0\u00a0reduce_to_zero'\n\u00a0\u00a0{{fun st \u21d2 st X = 0}}.\nProof.\n\u00a0\u00a0unfold reduce_to_zero'.\n\u00a0\u00a0(*\u00a0First\u00a0we\u00a0need\u00a0to\u00a0transform\u00a0the\u00a0postcondition\u00a0so\n\u00a0\u00a0\u00a0\u00a0\u00a0that\u00a0hoare_while\u00a0will\u00a0apply.\u00a0*)\n\u00a0\u00a0eapply hoare_consequence_post.\n\u00a0\u00a0apply hoare_while.\n\u00a0\u00a0- (*\u00a0Loop\u00a0body\u00a0preserves\u00a0invariant\u00a0*)\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Need\u00a0to\u00a0massage\u00a0precondition\u00a0before\u00a0hoare_asgn\u00a0applies\u00a0*)\n\u00a0\u00a0\u00a0\u00a0eapply hoare_consequence_pre. apply hoare_asgn.\n\u00a0\u00a0\u00a0\u00a0(*\u00a0Proving\u00a0trivial\u00a0implication\u00a0(2)\u00a0->>\u00a0(3)\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros st [HT Hbp]. unfold assn_sub. apply I.\n\u00a0\u00a0- (*\u00a0Invariant\u00a0and\u00a0negated\u00a0guard\u00a0imply\u00a0postcondition\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros st [Inv GuardFalse].\n\u00a0\u00a0\u00a0\u00a0unfold bassn in GuardFalse. simpl in GuardFalse.\n\u00a0\u00a0\u00a0\u00a0rewrite not_true_iff_false in GuardFalse.\n\u00a0\u00a0\u00a0\u00a0rewrite negb_false_iff in GuardFalse.\n\u00a0\u00a0\u00a0\u00a0apply beq_nat_true in GuardFalse.\n\u00a0\u00a0\u00a0\u00a0apply GuardFalse. Qed.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0m;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0n\u00a0\u2264\u00a0X\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0-\u00a0n;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0END;\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(1)\u00a0\u00a0\u00a0\u00a0{{\u00a0True\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(2)\u00a0\u00a0\u00a0\u00a0{{\u00a0n\u00a0*\u00a00\u00a0+\u00a0m\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0m;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(3)\u00a0\u00a0\u00a0\u00a0{{\u00a0n\u00a0*\u00a00\u00a0+\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(4)\u00a0\u00a0\u00a0\u00a0{{\u00a0n\u00a0*\u00a0Y\u00a0+\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0n\u00a0\u2264\u00a0X\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(5)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0n\u00a0*\u00a0Y\u00a0+\u00a0X\u00a0=\u00a0m\u00a0\u2227\u00a0n\u00a0\u2264\u00a0X\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(6)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0n\u00a0*\u00a0(Y\u00a0+\u00a01)\u00a0+\u00a0(X\u00a0-\u00a0n)\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0-\u00a0n;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(7)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0n\u00a0*\u00a0(Y\u00a0+\u00a01)\u00a0+\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(8)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0n\u00a0*\u00a0Y\u00a0+\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(9)\u00a0\u00a0\u00a0\u00a0{{\u00a0n\u00a0*\u00a0Y\u00a0+\u00a0X\u00a0=\u00a0m\u00a0\u2227\u00a0X\u00a0<\u00a0n\u00a0}}\n\n```", "```\n\n# Finding Loop Invariants\n\n Once the outermost precondition and postcondition are\n    chosen, the only creative part in verifying programs using Hoare\n    Logic is finding the right loop invariants.  The reason this is\n    difficult is the same as the reason that inductive mathematical\n    proofs are: strengthening the loop invariant (or the induction\n    hypothesis) means that you have a stronger assumption to work with\n    when trying to establish the postcondition of the loop body (or\n    complete the induction step of the proof), but it also means that\n    the loop body's postcondition (or the statement being proved\n    inductively) is stronger and thus harder to prove!\n\n    This section explains how to approach the challenge of finding loop\n    invariants through a series of examples and exercises. \n\n## Example: Slow Subtraction\n\n The following program subtracts the value of X from the value of\n    Y by repeatedly decrementing both X and Y.  We want to verify its\n    correctness with respect to the following specification:\n\n```", "```\n\n    To verify this program, we need to find an invariant I for the\n    loop.  As a first step we can leave I as an unknown and build a\n    *skeleton* for the proof by applying (backward) the rules for local\n    consistency.  This process leads to the following skeleton:\n\n```", "```\n\n    By examining this skeleton, we can see that any valid I will\n    have to respect three conditions:\n\n*   (a) it must be weak enough to be implied by the loop's\n          precondition, i.e., (1) must imply (2);\n\n*   (b) it must be strong enough to imply the program's postcondition,\n          i.e., (7) must imply (8);\n\n*   (c) it must be preserved by one iteration of the loop, i.e., (3)\n          must imply (4). \n\n These conditions are actually independent of the particular\n    program and specification we are considering. Indeed, every loop\n    invariant has to satisfy them. One way to find an invariant that\n    simultaneously satisfies these three conditions is by using an\n    iterative process: start with a \"candidate\" invariant (e.g., a\n    guess or a heuristic choice) and check the three conditions above;\n    if any of the checks fails, try to use the information that we get\n    from the failure to produce another \u2014 hopefully better \u2014 candidate\n    invariant, and repeat the process.\n\n    For instance, in the reduce-to-zero example above, we saw that,\n    for a very simple loop, choosing True as an invariant did the\n    job.  So let's try instantiating I with True in the skeleton \n    above see what we get...\n\n```", "```\n\n    While conditions (a) and (c) are trivially satisfied,\n    condition (b) is wrong, i.e., it is not the case that (7) True \u2227\n    X = 0 implies (8) Y = n - m.  In fact, the two assertions are\n    completely unrelated, so it is very easy to find a counterexample \n    to the implication (say, Y = X = m = 0 and n = 1).\n\n    If we want (b) to hold, we need to strengthen the invariant so\n    that it implies the postcondition (8).  One simple way to do\n    this is to let the invariant *be* the postcondition.  So let's\n    return to our skeleton, instantiate I with Y = n - m, and\n    check conditions (a) to (c) again.\n\n```", "```\n\n    This time, condition (b) holds trivially, but (a) and (c) are\n    broken. Condition (a) requires that (1) X = m \u2227 Y = n\n    implies (2) Y = n - m.  If we substitute Y by n we have to\n    show that n = n - m for arbitrary m and n, which is not \n    the case (for instance, when m = n = 1).  Condition (c) requires \n    that n - m - 1 = n - m, which fails, for instance, for n = 1 \n    and m = 0. So, although Y = n - m holds at the end of the loop, \n    it does not hold from the start, and it doesn't hold on each \n    iteration; it is not a correct invariant.\n\n    This failure is not very surprising: the variable Y changes\n    during the loop, while m and n are constant, so the assertion\n    we chose didn't have much chance of being an invariant!\n\n    To do better, we need to generalize (8) to some statement that is\n    equivalent to (8) when X is 0, since this will be the case\n    when the loop terminates, and that \"fills the gap\" in some\n    appropriate way when X is nonzero.  Looking at how the loop\n    works, we can observe that X and Y are decremented together\n    until X reaches 0.  So, if X = 2 and Y = 5 initially,\n    after one iteration of the loop we obtain X = 1 and Y = 4;\n    after two iterations X = 0 and Y = 3; and then the loop stops.\n    Notice that the difference between Y and X stays constant\n    between iterations: initially, Y = n and X = m, and the\n    difference is always n - m.  So let's try instantiating I in\n    the skeleton above with Y - X = n - m.\n\n```", "```\n\n    Success!  Conditions (a), (b) and (c) all hold now.  (To\n    verify (c), we need to check that, under the assumption that X \u2260\n    0, we have Y - X = (Y - 1) - (X - 1); this holds for all\n    natural numbers X and Y.) \n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0X\u00a0\u2260\u00a00\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0-\u00a01;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Y\u00a0=\u00a0m\u00a0}}\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n## Exercise: Slow Addition\n\n#### Exercise: 3 stars, optional (add_slowly_decoration)\n\n The following program adds the variable X into the variable Z\n    by repeatedly decrementing X and incrementing Z.\n\n```", "```\n\n    Following the pattern of the subtract_slowly example above, pick\n    a precondition and postcondition that give an appropriate\n    specification of add_slowly; then (informally) decorate the\n    program accordingly. \n\n```", "```\n\n\u2610 \n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a02\u00a0\u2264\u00a0X\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0-\u00a02\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0parity\u00a0m\u00a0}}\n\n```", "```\nFixpoint parity x :=\n\u00a0\u00a0match x with\n\u00a0\u00a0| 0 \u21d2 0\n\u00a0\u00a0| 1 \u21d2 1\n\u00a0\u00a0| S (S x') \u21d2 parity x'\n\u00a0\u00a0end.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0m\u00a0}}\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a\u00a0-\u00a0OK)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0parity\u00a0X\u00a0=\u00a0parity\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a02\u00a0\u2264\u00a0X\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0parity\u00a0X\u00a0=\u00a0parity\u00a0m\u00a0\u2227\u00a02\u00a0\u2264\u00a0X\u00a0}}\u00a0\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0(c\u00a0-\u00a0OK)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0parity\u00a0(X-2)\u00a0=\u00a0parity\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0-\u00a02\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0parity\u00a0X\u00a0=\u00a0parity\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0parity\u00a0X\u00a0=\u00a0parity\u00a0m\u00a0\u2227\u00a0X\u00a0<\u00a02\u00a0}}\u00a0\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(b\u00a0-\u00a0OK)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0parity\u00a0m\u00a0}}\n\n```", "```\nLemma parity_ge_2 : \u2200x,\n\u00a0\u00a02 \u2264 x \u2192\n\u00a0\u00a0parity (x - 2) = parity x.\n\nProof.\n\u00a0\u00a0induction x; intro. reflexivity.\n\u00a0\u00a0destruct x. inversion H. inversion H[1].\n\u00a0\u00a0simpl. rewrite \u2190 [minus_n_O](http://coq.inria.fr/library/Coq.Arith.Minus.html#minus_n_O). reflexivity.\nQed.\n\nLemma parity_lt_2 : \u2200x,\n\u00a0\u00a0\u00ac 2 \u2264 x \u2192\n\u00a0\u00a0parity (x) = x.\n\nProof.\n\u00a0\u00a0intros. induction x. reflexivity. destruct x. reflexivity.\n\u00a0\u00a0\u00a0\u00a0exfalso. apply H. omega.\nQed.\n\nTheorem parity_correct : \u2200m,\n\u00a0\u00a0\u00a0\u00a0{{ fun st \u21d2 st X = m }}\n\u00a0\u00a0WHILE BLe (ANum 2) (AId X) DO\n\u00a0\u00a0\u00a0\u00a0X ::= AMinus (AId X) (ANum 2)\n\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0{{ fun st \u21d2 st X = parity m }}.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n## Example: Finding Square Roots\n\n The following program computes the square root of X\n    by naive iteration:\n\n```", "```\n\n As above, we can try to use the postcondition as a candidate\n    invariant, obtaining the following decorated program:\n\n```", "```\n\n    This didn't work very well: conditions (a) and (c) both failed.\n    Looking at condition (c), we see that the second conjunct of (4)\n    is almost the same as the first conjunct of (5), except that (4)\n    mentions X while (5) mentions m. But note that X is never\n    assigned in this program, so we should always have X=m, but we \n    didn't propagate this information from (1) into the loop invariant.\n\n    Also, looking at the second conjunct of (8), it seems quite\n    hopeless as an invariant (why?); fortunately, we don't need it, \n    since we can obtain it from the negation of the guard \u2014 the third \n    conjunct in (7) \u2014 again under the assumption that X=m.\n\n    So we now try X=m \u2227 Z*Z \u2264 m as the loop invariant:\n\n```", "```\n\n    This works, since conditions (a), (b), and (c) are now all\n    trivially satisfied.\n\n    Very often, even if a variable is used in a loop in a read-only\n    fashion (i.e., it is referred to by the program or by the\n    specification and it is not changed by the loop), it is necessary\n    to add the fact that it doesn't change to the loop invariant. \n\n```", "```\n\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0Y\u00a0::=\u00a00;;\n\u00a0\u00a0Z\u00a0::=\u00a00;;\n\u00a0\u00a0WHILE\u00a0\u00a0Y\u00a0\u2260\u00a0X\u00a0\u00a0DO\n\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Z\u00a0+\u00a0X;;\n\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a01\n\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0m*m\u00a0}}\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0m\u00a0}}\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a\u00a0-\u00a0WRONG)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a00\u00a0=\u00a0m*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a00\u00a0=\u00a0m*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0m*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0WHILE\u00a0Y\u00a0\u2260\u00a0X\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0Y*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0\u2227\u00a0Y\u00a0\u2260\u00a0X\u00a0}}\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0\u00a0(c\u00a0-\u00a0WRONG)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z+X\u00a0=\u00a0m*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Z\u00a0+\u00a0X;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0m*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0m*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0m*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0\u2227\u00a0~(Y\u00a0\u2260\u00a0X)\u00a0}}\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(b\u00a0-\u00a0OK)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0m*m\u00a0}}\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a0m\u00a0}}\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(a\u00a0-\u00a0OK)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a00\u00a0=\u00a00*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a00\u00a0=\u00a0Y*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0Y*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0WHILE\u00a0Y\u00a0\u2260\u00a0X\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0Y*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0\u2227\u00a0Y\u00a0\u2260\u00a0X\u00a0}}\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(c\u00a0-\u00a0OK)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z+X\u00a0=\u00a0(Y+1)*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Z\u00a0+\u00a0X;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0(Y+1)*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0Y*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0}}\n\u00a0\u00a0\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0Y*m\u00a0\u2227\u00a0X\u00a0=\u00a0m\u00a0\u2227\u00a0~(Y\u00a0\u2260\u00a0X)\u00a0}}\u00a0\u21fe\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(b\u00a0-\u00a0OK)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0m*m\u00a0}}\n\n```", "```\n\n## Exercise: Factorial\n\n#### Exercise: 3 starsM (factorial)\n\n Recall that n! denotes the factorial of n (i.e., n! =\n    1*2*...*n).  Here is an Imp program that calculates the factorial\n    of the number initially stored in the variable X and puts it in\n    the variable Y:\n\n```", "```\n\n    Fill in the blanks in following decorated program:\n\n```", "```\n\n \u2610 \n\n```", "```\n\u00a0\u00a0Lemma\u00a0lemma1\u00a0:\u00a0\u2200x\u00a0y,\n\u00a0\u00a0\u00a0\u00a0(x=0\u00a0\u2228\u00a0y=0)\u00a0\u2192\u00a0min\u00a0x\u00a0y\u00a0=\u00a00.\n\u00a0\u00a0Lemma\u00a0lemma2\u00a0:\u00a0\u2200x\u00a0y,\n\u00a0\u00a0\u00a0\u00a0min\u00a0(x-1)\u00a0(y-1)\u00a0=\u00a0(min\u00a0x\u00a0y)\u00a0-\u00a01.\n\n```", "```\n\u00a0\u00a0{{\u00a0True\u00a0}}\u00a0\u21fe\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0X\u00a0::=\u00a0a;;\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0Y\u00a0::=\u00a0b;;\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0Z\u00a0::=\u00a00;;\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0WHILE\u00a0(X\u00a0\u2260\u00a00\u00a0\u2227\u00a0Y\u00a0\u2260\u00a00)\u00a0DO\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\u00a0\u21fe\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0X\u00a0:=\u00a0X\u00a0-\u00a01;;\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0Y\u00a0:=\u00a0Y\u00a0-\u00a01;;\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0Z\u00a0:=\u00a0Z\u00a0+\u00a01\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0END\n\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\u00a0\u21fe\n\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0min\u00a0a\u00a0b\u00a0}}\n\n```", "```\n\u00a0\u00a0X\u00a0::=\u00a00;;\n\u00a0\u00a0Y\u00a0::=\u00a00;;\n\u00a0\u00a0Z\u00a0::=\u00a0c;;\n\u00a0\u00a0WHILE\u00a0X\u00a0\u2260\u00a0a\u00a0DO\n\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0+\u00a01;;\n\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Z\u00a0+\u00a01\n\u00a0\u00a0END;;\n\u00a0\u00a0WHILE\u00a0Y\u00a0\u2260\u00a0b\u00a0DO\n\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a01;;\n\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Z\u00a0+\u00a01\n\u00a0\u00a0END\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0{{\u00a0True\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0X\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0Y\u00a0::=\u00a00;;\n\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0Z\u00a0::=\u00a0c;;\n\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0WHILE\u00a0X\u00a0\u2260\u00a0a\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a0X\u00a0+\u00a01;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Z\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0END;;\n\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0WHILE\u00a0Y\u00a0\u2260\u00a0b\u00a0DO\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0\u00a0\u00a0Y\u00a0::=\u00a0Y\u00a0+\u00a01;;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0\u00a0\u00a0Z\u00a0::=\u00a0Z\u00a0+\u00a01\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\n\u00a0\u00a0END\n\u00a0\u00a0\u00a0\u00a0{{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}}\u00a0\u21fe\n\u00a0\u00a0\u00a0\u00a0{{\u00a0Z\u00a0=\u00a0a\u00a0+\u00a0b\u00a0+\u00a0c\u00a0}}\n\n```", "```\n\n## Exercise: Power Series\n\n#### Exercise: 4 stars, optional (dpow2_down)\n\n Here is a program that computes the series:\n    1 + 2 + 2^2 + ... + 2^m = 2^(m+1) - 1\n\n```", "```\n\n    Write a decorated program for this. \n\n```", "```\n\n\u2610 \n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0False\u00a0}}\u00a0\u00a0X\u00a0::=\u00a0Y\u00a0+\u00a01\u00a0\u00a0{{\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Y\u00a0\u2264\u00a04\u00a0\u2227\u00a0Z\u00a0=\u00a00\u00a0}}\u00a0\u00a0X\u00a0::=\u00a0Y\u00a0+\u00a01\u00a0{{\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Y\u00a0\u2264\u00a04\u00a0}}\u00a0\u00a0X\u00a0::=\u00a0Y\u00a0+\u00a01\u00a0\u00a0{{\u00a0X\u00a0\u2264\u00a05\u00a0}}\n\n```", "```\nDefinition is_wp P c Q :=\n\u00a0\u00a0{{P}} c {{Q}} \u2227\n\u00a0\u00a0\u2200P', {{P'}} c {{Q}} \u2192 (P' \u21fe P).\n\n```", "```\n\u00a0\u00a01)\u00a0{{\u00a0?\u00a0}}\u00a0\u00a0SKIP\u00a0\u00a0{{\u00a0X\u00a0=\u00a05\u00a0}}\n\n\u00a0\u00a02)\u00a0{{\u00a0?\u00a0}}\u00a0\u00a0X\u00a0::=\u00a0Y\u00a0+\u00a0Z\u00a0{{\u00a0X\u00a0=\u00a05\u00a0}}\n\n\u00a0\u00a03)\u00a0{{\u00a0?\u00a0}}\u00a0\u00a0X\u00a0::=\u00a0Y\u00a0\u00a0{{\u00a0X\u00a0=\u00a0Y\u00a0}}\n\n\u00a0\u00a04)\u00a0{{\u00a0?\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0IFB\u00a0X\u00a0==\u00a00\u00a0THEN\u00a0Y\u00a0::=\u00a0Z\u00a0+\u00a01\u00a0ELSE\u00a0Y\u00a0::=\u00a0W\u00a0+\u00a02\u00a0FI\n\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0Y\u00a0=\u00a05\u00a0}}\n\n\u00a0\u00a05)\u00a0{{\u00a0?\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0X\u00a0::=\u00a05\n\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a00\u00a0}}\n\n\u00a0\u00a06)\u00a0{{\u00a0?\u00a0}}\n\u00a0\u00a0\u00a0\u00a0\u00a0WHILE\u00a0True\u00a0DO\u00a0X\u00a0::=\u00a00\u00a0END\n\u00a0\u00a0\u00a0\u00a0\u00a0{{\u00a0X\u00a0=\u00a00\u00a0}}\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\nTheorem is_wp_example :\n\u00a0\u00a0is_wp (fun st \u21d2 st Y \u2264 4)\n\u00a0\u00a0\u00a0\u00a0(X ::= APlus (AId Y) (ANum 1)) (fun st \u21d2 st X \u2264 5).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem hoare_asgn_weakest : \u2200Q X a,\n\u00a0\u00a0is_wp (Q [X \u21a6 a]) (X ::= a) Q.\nProof.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nModule Himp2.\nImport Himp.\n\nLemma hoare_havoc_weakest : \u2200(P Q : Assertion) (X : id),\n\u00a0\u00a0{{ P }} HAVOC X {{ Q }} \u2192\n\u00a0\u00a0P \u21fe havoc_pre X Q.\nProof.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Formal Decorated Programs (Optional)\n\n Our informal conventions for decorated programs amount to a\n    way of displaying Hoare triples, in which commands are annotated\n    with enough embedded assertions that checking the validity of a\n    triple is reduced to simple logical and algebraic calculations\n    showing that some assertions imply others.  In this section, we\n    show that this informal presentation style can actually be made\n    completely formal and indeed that checking the validity of\n    decorated programs can mostly be automated.  \n\n## Syntax\n\n The first thing we need to do is to formalize a variant of the\n    syntax of commands with embedded assertions.  We call the new\n    commands *decorated commands*, or dcoms. \n\n We don't want both preconditions and postconditions on each\n    command, because a sequence of two commands would contain\n    redundant decorations, the postcondition of the first likely\n    being the same as the precondition of the second. Instead,\n    decorations are added corresponding to each postcondition.\n    A separate type, decorated, is used to add the precondition\n    for the entire program. \n\n```", "```\n\nTo avoid clashing with the existing Notation definitions\n    for ordinary commands, we introduce these notations in a special\n    scope called dcom_scope, and we wrap examples with the\n    declaration % dcom to signal that we want the notations to be\n    interpreted in this scope.\n\n    Careful readers will note that we've defined two notations for the\n    DCPre constructor, one with and one without a \u21fe.  The\n    \"without\" version is intended to be used to supply the initial\n    precondition at the very top of the program. \n\n```", "```\n\nIt is easy to go from a dcom to a com by erasing all\n    annotations. \n\n```", "```\n\nThe choice of exactly where to put assertions in the definition of\n    dcom is a bit subtle.  The simplest thing to do would be to\n    annotate every dcom with a precondition and postcondition.  But\n    this would result in very verbose programs with a lot of repeated\n    annotations: for example, a program like SKIP;SKIP would have to\n    be annotated as\n\n```", "```\n\n    with pre- and post-conditions on each SKIP, plus identical pre-\n    and post-conditions on the semicolon!\n\n    Instead, the rule we've followed is this:\n\n*   The *post*-condition expected by each dcom d is embedded\n             in d.\n\n*   The *pre*-condition is supplied by the context. \n\n In other words, the invariant of the representation is that a\n    dcom d together with a precondition P determines a Hoare\n    triple {{P}} (extract d) {{post d}}, where post is defined as\n    follows: \n\n```", "```\n\nIt is straightforward to extract the precondition and\n    postcondition from a decorated program. \n\n```", "```\n\nWe can express what it means for a decorated program to be\n    correct as follows: \n\n```", "```\n\nTo check whether this Hoare triple is *valid*, we need a way to\n    extract the \"proof obligations\" from a decorated program.  These\n    obligations are often called *verification conditions*, because\n    they are the facts that must be verified to see that the\n    decorations are logically consistent and thus add up to a complete\n    proof of correctness. \n\n## Extracting Verification Conditions\n\n The function verification_conditions takes a dcom d together\n    with a precondition P and returns a *proposition* that, if it\n    can be proved, implies that the triple {{P}} (extract d) {{post d}}\n    is valid. \n\n It does this by walking over d and generating a big\n    conjunction including all the \"local checks\" that we listed when\n    we described the informal rules for decorated programs.  (Strictly\n    speaking, we need to massage the informal rules a little bit to\n    add some uses of the rule of consequence, but the correspondence\n    should be clear.) \n\n```", "```\n\nAnd now the key theorem, stating that verification_conditions\n    does its job correctly.  Not surprisingly, we need to use each of\n    the Hoare Logic rules at some point in the proof. \n\n```", "```\n\n(If you expand the proof, you'll see that it uses an\n    unfamiliar idiom: simpl in *.  We have used ...in... variants\n    of several tactics before, to apply them to values in the context\n    rather than the goal.  The syntax tactic in * extends this idea,\n    applying tactic in the goal and every hypothesis in the\n    context.) \n\n## Automation\n\n Now that all the pieces are in place, we can verify an entire program. \n\n```", "```\n\nThe propositions generated by verification_conditions are fairly\n    big, and they contain many conjuncts that are essentially trivial. \n\n```", "```\n\n```", "```\n\n In principle, we could work with such propositions using just the\n    tactics we have so far, but we can make things much smoother with\n    a bit of automation.  We first define a custom verify tactic\n    that uses split repeatedly to turn all the conjunctions into\n    separate subgoals and then uses omega and eauto (described in\n    chapter [Auto](Auto.html)) to deal with as many of them as possible. \n\n```", "```\n\nWhat's left after verify does its thing is \"just the interesting\n    parts\" of checking that the decorations are correct. For very\n    simple examples verify immediately solves the goal (provided\n    that the annotations are correct). \n\n```", "```\n\nAnother example (formalizing a decorated program we've seen\n    before): \n\n```", "```\n\n## Examples\n\n In this section, we use the automation developed above to verify\n    formal decorated programs corresponding to most of the informal\n    ones we have seen. \n\n### Swapping Using Addition and Subtraction\n\n```", "```\n\n### Simple Conditionals\n\n```", "```\n\n### Division\n\n```", "```\n\n### Parity\n\n```", "```\n\nThere are actually several ways to phrase the loop invariant for\n    this program.  Here is one natural one, which leads to a rather\n    long proof: \n\n```", "```\n\nHere is a more intuitive way of writing the invariant: \n\n```", "```\n\nHere is the simplest invariant we've found for this program: \n\n```", "```\n\n### Square Roots\n\n```", "```\n\n### Squaring\n\n Again, there are several ways of annotating the squaring program.\n    The simplest variant we've found, square_simpler_dec, is given\n    last. \n\n```", "```\n\n### Two loops\n\n```", "```\n\n### Power Series\n\n```", "```\n\nFurther Exercises \n\n#### Exercise: 3 stars, advanced (slow_assignment_dec)\n\n In the slow_assignment exercise above, we saw a roundabout way\n    of assigning a number currently stored in X to the variable Y:\n    start Y at 0, then decrement X until it hits 0,\n    incrementing Y at each step.  Write a formal version of this\n    decorated program and prove it correct. \n\n```", "```\n\n\u2610 \n\n#### Exercise: 4 stars, advancedM (factorial_dec)\n\n Remember the factorial function we worked with before: \n\n```", "```\n\nFollowing the pattern of subtract_slowly_dec, write a decorated\n    program factorial_dec that implements the factorial function and\n    prove it correct as factorial_dec_correct. \n\n```", "```\n\n\u2610 \n\n#### Exercise: 4 stars, advanced, optional (fib_eqn)\n\n The Fibonacci function is usually written like this:\n\n```", "```\n\n   This doesn't pass Coq's termination checker, but here is a \n   slightly clunkier definition that does: \n\n```", "```\n\nProve that fib satisfies the following equation: \n\n```", "```\n\n\u2610 \n\n#### Exercise: 4 stars, advanced, optional (fib)\n\n The following Imp program leaves the value of fib n in the\n    variable Y when it terminates: \n\n```", "```\n\n    Fill in the following definition of dfib and prove that it \n    satisfies this specification:\n\n```", "```\n\n```", "```\n\n\u2610 \n\n#### Exercise: 5 stars, advanced, optional (improve_dcom)\n\n The formal decorated programs defined in this section are intended \n    to look as similar as possible to the informal ones defined earlier\n    in the chapter.  If we drop this requirement, we can eliminate\n    almost all annotations, just requiring final postconditions and \n    loop invariants to be provided explicitly.  Do this \u2014 i.e., define a \n    new version of dcom with as few annotations as possible and adapt the\n    rest of the formal development leading up to the verification_correct \n    theorem. \n\n```", "```\n\n\u2610 \n\n#### Exercise: 4 stars, advanced, optional (implement_dcom)\n\n Adapt the parser for Imp presented in chapter [ImpParser](ImpParser.html) \n    to parse decorated commands (either ours or the ones you defined\n    in the previous exercise). \n\n```", "```\n\n\u2610 \n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]