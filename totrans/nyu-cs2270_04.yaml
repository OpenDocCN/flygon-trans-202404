- en: Notes for September 30 class -- More Ray Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Phong model for specular reflection**'
  prefs: []
  type: TYPE_NORMAL
- en: The first really interesting model for surface reflection was developed by Bui-Tong
    Phong in 1973. Before that, computer graphics surfaces were rendered using only
    diffuse lambert reflection. Phong's was the first model that accounted for specular
    highlights.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Phong model begins by defining a reflection vector R, which is a reflection
    of the direction to the light source L about the surface normal N.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As we showed in class, and as you can see from the diagram on the right, it
    is given by:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: R = 2 (N • L) N - L
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/c6a507e6c31d54eee688470f6ceb06f9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once R has been defined, then the Phong model approximates the *specular* component
    of surface reflectance as:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: s[rgb] max(0, E • R)^p )
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where s[rgb] is the color of specular reflection, p is a specular power, and
    E is the direction to the eye (in our case, E = -W, the reverse of the ray direction).
    The larger the specular power p, the "shinier" the surface will appear.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To get the complete Phong reflectance, we sum over the lights in the scene:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a[rgb] + ∑[i] lightColor[i] ( d[rgb] max(0, N • L[i]) + s[rgb] max(0, E • R)
    ^p )
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where a[rgb], d[rgb] and s[rgb] are the ambient, diffuse and specular color,
    respectively, and p is the specular power.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/2770813ee2d1c88e575f42edfd7bf5c9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Blinn model for specular reflection**'
  prefs: []
  type: TYPE_NORMAL
- en: A few years later, Jim Blinn created a variation on the Phong model which produced
    somewhat more realistic highlights in extreme cases (when the viewer is looking
    from an angle that is far from the surface normal).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Blinn model is also appreciably faster in the special case where we approximate
    E by a constant vector everywhere, and we assume that the light direction L is
    constant throughout the object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The basic idea is that a halfway vector H is defined as the normalized midpoint
    between direction to light L and direction to eye E. If E and L are constant,
    this needs to be done only once for each light source.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Then at each pixel, we just take the inner product between N and H:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: s[rgb] max(0, N • H)^p
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because H tends to stay relatively near to N, to get the same level of specularity
    the power p needs to be about three times greater in the Blinn model than the
    corresponding value in the Phong model.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/cf02950a9f00a38497907141b0bccf6c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Shadows**'
  prefs: []
  type: TYPE_NORMAL
- en: Casting shadows is relatively easy in ray tracing. Once we have found a surface
    point S, then for each light source, we shoot another ray whose origin V' is just
    the surface point S, and whose direction W' is the direction toward that light
    source L[i].
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We want to make sure that the ray misses the object we are starting from, so
    we move the origin V'' of our new ray slightly out of the surface toward the light
    source. Our "shadow ray" will therefore be:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: V' = S + ε L[i]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: W' = L[i]
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: where ε can be any tiny positive value, such as 0.001.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: If this shadow ray encounters any other object, then the surface is in shadow
    at this pixel, and we do not add in the diffuse and specular components of surface
    reflectance.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: To the right above is an example of the surface not being in shadow. Just below
    that is an example of a surface being in shadow, because its light path is blocked
    by another object.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/d8c6b7c36abbd59b4dd069d02a2ed365.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![](../Images/3c3873a203f0358d9cd11c1231ecff43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Reflection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another great thing about ray tracing is that we can continue to follow the
    path of a light ray backward from the camera, to model the behavior of mirror
    reflection. Adapting the technique that we used to calculate the reflection direction
    R for the Phong reflectance model, but replacing L in that equation by -W (the
    direction back along the incoming ray):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: W' = 2 (N • (-W)) N - (-W)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'we can compute a new ray that starts at surface point S, and goes into that
    reflected direction:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: V' = S + ε W'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As shown in the figure on the right, we want to offset the origin of this ray
    a bit out of the surface, so that the ray does not accidentally encounter the
    object itself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whatever color is computed by this ray, we mix it into the result of the Phong
    reflectance algorithm. The result is the appearance of a shaded surface with a
    mirror finish.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/f321c6f49e0a6a5c8b7f5e118f792b35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Boolean intersection**'
  prefs: []
  type: TYPE_NORMAL
- en: Another nice thing about ray tracing is that we can use it to do *boolean modeling*,
    as we discussed in class. For example, given two spheres A and B, we can compute
    the intersection (if any) of those spheres by calculating their intersection along
    the ray.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose, along a given ray, the values of t when entering and exiting sphere
    A are A[in] and A[out], respectively.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also suppose that along this ray the values of t when entering and exiting sphere
    B are B[in] and B[out], respectively.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Then the intersection of the two shapes, along the ray, is given by the maximum
    of the enter (in) values and the minimum of the exit (out) values:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: t[in] of entry into intersection shape = max(A[in] , B[in])
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: t[out] of exit from intersection shape = min(A[out] , B[out])
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If t[in] < t[out], then the ray has intersected the intersection shape. Otherwise,
    the ray has missed the intersection shape.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To shade the resulting intersection shape at a pixel, we need to use the normal
    of the surface that was actually hit by the ray. For example, if A[in] > B[in],
    then we need to use the surface normal of A.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/4e5091838a01bcc4e3ddcdca03139b81.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Refraction**'
  prefs: []
  type: TYPE_NORMAL
- en: In the real world many materials, such as oil, water, plastic, glass and diamond,
    are transparent. A transparent material has an *index of refraction* which measures
    how much light slows down as it enters that medium. For example, the index of
    refraction of water is about 1.333, of glass is about 1.5\. The index of refraction
    of diamond, the substance with the highest known index of refraction, is 2.42.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As in the diagram to the right, you can add refraction to your ray tracing
    by following Snell''s law:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: n1 / n2 = sin(θ2) / sin(θ1)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: to determine how much the ray should bend as it enters or exits a transparent
    object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that you will need to change your ray tracing model to incorporate refraction.
    In addition to your initial incoming ray, and any shadow or reflection rays, you
    also need to add a refraction ray, which starts just inside the surface, and continues
    inward.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that if you have ray traced to a sphere, and are now computing where the
    refracting ray will exit that sphere, you will want to compute the *second* root
    of the quadratic equation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Then, after this refracting ray has exited out the back of the transparent sphere,
    you will want to compute how much it refracts on its way out, and then shoot a
    ray from there into the scene behind the sphere.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In general, you use the results of refraction by mixing the color it returns
    together with whatever surface color you have computed due to pure reflection
    or blinn/phong reflectance.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/33e3353b748d7d1f122bba9dc8127b7e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Homework (due before class on Wednesday Oct 8)**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement either the Phong or the Blinn reflectance model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement shadows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement boolean intersection between two spheres.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extra credit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement both Phong and Blinn reflectdance.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement reflection.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement refraction.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement boolean intersection between more than two spheres.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, make something cool and fun, try to create something interactive
    (using uCursor) and/or animated (using uTime).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
