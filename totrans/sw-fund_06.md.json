["```\n\n    This chapter introduces several additional proof strategies\n    and tactics that allow us to begin proving more interesting\n    properties of functional programs.  We will see:\n\n*   how to use auxiliary lemmas in both \"forward-style\" and \"backward-style\" proofs;\n\n*   how to reason about data constructors (in particular, how to use the fact that they are injective and disjoint);\n\n*   how to strengthen an induction hypothesis (and when such strengthening is required); and\n\n*   more details on how to reason by case analysis.\n\n```", "```\n\n# The apply Tactic\n\n    We often encounter situations where the goal to be proved is\n    *exactly* the same as some hypothesis in the context or some\n    previously proved lemma.\n\n```", "```\n\n    Here, we could finish with \"rewrite \u2192 eq[2]. reflexivity.\" as we\n    have done several times before.  We can achieve the same effect in\n    a single step by using the apply tactic instead:\n\n```", "```\n\n    The apply tactic also works with *conditional* hypotheses\n    and lemmas: if the statement being applied is an implication, then\n    the premises of this implication will be added to the list of\n    subgoals needing to be proved.\n\n```", "```\n\n    You may find it instructive to experiment with this proof\n    and see if there is a way to complete it using just rewrite\n    instead of apply. \n\n    Typically, when we use apply H, the statement H will\n    begin with a \u2200 that binds some *universal variables*.  When\n    Coq matches the current goal against the conclusion of H, it\n    will try to find appropriate values for these variables.  For\n    example, when we do apply eq[2] in the following proof, the\n    universal variable q in eq[2] gets instantiated with n and r\n    gets instantiated with m.\n\n```", "```\n\n#### Exercise: 2 stars, optional (silly_ex)\n\n    Complete the following proof without using simpl.\n\n```", "```\n\n    \u2610 \n\n    To use the apply tactic, the (conclusion of the) fact\n    being applied must match the goal exactly \u2014 for example, apply\n    will not work if the left and right sides of the equality are\n    swapped.\n\n```", "```\n\n    Here we cannot use apply directly, but we can use the symmetry\n    tactic, which switches the left and right sides of an equality in\n    the goal.\n\n```", "```\n\n#### Exercise: 3 stars (apply_exercise1)\n\n    (*Hint*: You can use apply with previously defined lemmas, not\n    just hypotheses in the context.  Remember that Search is\n    your friend.)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 1 star, optionalM (apply_rewrite)\n\n    Briefly explain the difference between the tactics apply and\n    rewrite.  What are the situations where both can usefully be\n    applied?\n\n    (*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n    \u2610\n\n```", "```\nExample trans_eq_example : \u2200(a b c d e f : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0[a;b] = [c;d] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0[c;d] = [e;f] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0[a;b] = [e;f].\nProof.\n\u00a0\u00a0intros a b c d e f eq[1] eq[2].\n\u00a0\u00a0rewrite \u2192 eq[1]. rewrite \u2192 eq[2]. reflexivity. Qed.\n\n```", "```\nTheorem trans_eq : \u2200(X:Type) (n m o : X),\n\u00a0\u00a0n = m \u2192 m = o \u2192 n = o.\nProof.\n\u00a0\u00a0intros X n m o eq[1] eq[2]. rewrite \u2192 eq[1]. rewrite \u2192 eq[2].\n\u00a0\u00a0reflexivity. Qed.\n\n```", "```\nExample trans_eq_example' : \u2200(a b c d e f : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0[a;b] = [c;d] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0[c;d] = [e;f] \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0[a;b] = [e;f].\nProof.\n\u00a0\u00a0intros a b c d e f eq[1] eq[2].\n\n```", "```\n\u00a0\u00a0apply trans_eq with (m:=[c;d]).\n\u00a0\u00a0apply eq[1]. apply eq[2]. Qed.\n\n```", "```\nExample trans_eq_exercise : \u2200(n m o p : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0m = (minustwo o) \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0(n + p) = m \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0(n + p) = (minustwo o).\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# The inversion Tactic\n\n    Recall the definition of natural numbers:\n\n```", "```\nTheorem S_injective : \u2200(n m : nat),\n\u00a0\u00a0S n = S m \u2192\n\u00a0\u00a0n = m.\nProof.\n\u00a0\u00a0intros n m H.\n\n```", "```\n\u00a0\u00a0inversion H.\n\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nTheorem inversion_ex[1] : \u2200(n m o : nat),\n\u00a0\u00a0[n; m] = [o; o] \u2192\n\u00a0\u00a0[n] = [m].\nProof.\n\u00a0\u00a0intros n m o H. inversion H. reflexivity. Qed.\n\n```", "```\nTheorem inversion_ex[2] : \u2200(n m : nat),\n\u00a0\u00a0[n] = [m] \u2192\n\u00a0\u00a0n = m.\nProof.\n\u00a0\u00a0intros n m H. inversion H as [Hnm]. reflexivity. Qed.\n\n```", "```\nExample inversion_ex[3] : \u2200(X : Type) (x y z : X) (l j : list X),\n\u00a0\u00a0x :: y :: l = z :: j \u2192\n\u00a0\u00a0y :: l = x :: j \u2192\n\u00a0\u00a0x = y.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem beq_nat_0_l : \u2200n,\n\u00a0\u00a0\u00a0beq_nat 0 n = true \u2192 n = 0.\nProof.\n\u00a0\u00a0intros n.\n\n```", "```\n\u00a0\u00a0destruct n as [| n'].\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a00\u00a0*)\n\u00a0\u00a0\u00a0\u00a0intros H. reflexivity.\n\n```", "```\n\u00a0\u00a0- (*\u00a0n\u00a0=\u00a0S\u00a0n'\u00a0*)\n\u00a0\u00a0\u00a0\u00a0simpl.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0intros H. inversion H. Qed.\n\n```", "```\nTheorem inversion_ex[4] : \u2200(n : nat),\n\u00a0\u00a0S n = O \u2192\n\u00a0\u00a02 + 2 = 5.\nProof.\n\u00a0\u00a0intros n contra. inversion contra. Qed.\n\nTheorem inversion_ex[5] : \u2200(n m : nat),\n\u00a0\u00a0false = true \u2192\n\u00a0\u00a0[n] = [m].\nProof.\n\u00a0\u00a0intros n m contra. inversion contra. Qed.\n\n```", "```\nExample inversion_ex[6] : \u2200(X : Type)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(x y z : X) (l j : list X),\n\u00a0\u00a0x :: y :: l = [] \u2192\n\u00a0\u00a0y :: l = z :: j \u2192\n\u00a0\u00a0x = z.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c\u00a0a[1]\u00a0a[2]\u00a0... an\u00a0=\u00a0d\u00a0b[1]\u00a0b[2]\u00a0... bm\n\n    for some constructors c and d and arguments a[1] ... an and\n    b[1] ... bm.  Then inversion H has the following effect:\n\n*   If c and d are the same constructor, then, by the injectivity of this constructor, we know that a[1] = b[1], a[2] = b[2], etc. The inversion H adds these facts to the context and tries to use them to rewrite the goal. \n\n*   If c and d are different constructors, then the hypothesis H is contradictory, and the current goal doesn't have to be considered at all. In this case, inversion H marks the current goal as completed and pops it off the goal stack.\n\n    The injectivity of constructors allows us to reason that\n    \u2200 (n m : nat), S n = S m \u2192 n = m.  The converse of this\n    implication is an instance of a more general fact about both\n    constructors and functions, which we will find useful in a few\n    places below:\n\n```", "```\n\n# Using Tactics on Hypotheses\n\n    By default, most tactics work on the goal formula and leave\n    the context unchanged.  However, most tactics also have a variant\n    that performs a similar operation on a statement in the context.\n\n    For example, the tactic simpl in H performs simplification in\n    the hypothesis named H in the context.\n\n```", "```\n\n    Similarly, apply L in H matches some conditional statement\n    L (of the form L[1] \u2192 L[2], say) against a hypothesis H in the\n    context.  However, unlike ordinary apply (which rewrites a goal\n    matching L[2] into a subgoal L[1]), apply L in H matches H\n    against L[1] and, if successful, replaces it with L[2].\n\n    In other words, apply L in H gives us a form of \"forward\n    reasoning\": from L[1] \u2192 L[2] and a hypothesis matching L[1], it\n    produces a hypothesis matching L[2].  By contrast, apply L is\n    \"backward reasoning\": it says that if we know L[1]\u2192L[2] and we are\n    trying to prove L[2], it suffices to prove L[1].\n\n    Here is a variant of a proof from above, using forward reasoning\n    throughout instead of backward reasoning.\n\n```", "```\n\n    Forward reasoning starts from what is *given* (premises,\n    previously proven theorems) and iteratively draws conclusions from\n    them until the goal is reached.  Backward reasoning starts from\n    the *goal*, and iteratively reasons about what would imply the\n    goal, until premises or previously proven theorems are reached.\n    If you've seen informal proofs before (for example, in a math or\n    computer science class), they probably used forward reasoning.  In\n    general, idiomatic use of Coq tends to favor backward reasoning,\n    but in some situations the forward style can be easier to think\n    about.  \n\n#### Exercise: 3 stars, recommended (plus_n_n_injective)\n\n    Practice using \"in\" variants in this exercise.  (Hint: use\n    plus_n_Sm.)\n\n```", "```\n\n    \u2610\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0Theorem\u00a0double_injective:\u00a0\u2200n\u00a0m,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0double\u00a0n\u00a0=\u00a0double\u00a0m\u00a0\u2192\u00a0n\u00a0=\u00a0m.\n\n    The way we *start* this proof is a bit delicate: if we begin with\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0intros\u00a0n\u00a0m. induction\u00a0n.\n\n    we get stuck in the middle of the inductive case...\n\n```", "```\n\n    At this point, the induction hypothesis, IHn', does *not* give us\n    n' = m' \u2014 there is an extra S in the way \u2014 so the goal is\n    not provable.\n\n```", "```\n\n    What went wrong? \n\n    The problem is that, at the point we invoke the induction\n    hypothesis, we have already introduced m into the context \u2014\n    intuitively, we have told Coq, \"Let's consider some particular n\n    and m...\" and we now have to prove that, if double n = double m for *these particular* n and m, then n = m.\n\n    The next tactic, induction n says to Coq: We are going to show\n    the goal by induction on n.  That is, we are going to prove, for\n    *all* n, that the proposition\n\n*   P n = \"if double n = double m, then n = m\"\n\n    holds, by showing\n\n*   P O \n\n     (i.e., \"if double O = double m then O = m\") and \n\n*   P n \u2192 P (S n) \n\n     (i.e., \"if double n = double m then n = m\" implies \"if double (S n) = double m then S n = m\").\n\n    If we look closely at the second statement, it is saying something\n    rather strange: it says that, for a *particular* m, if we know\n\n*   \"if double n = double m then n = m\"\n\n    then we can prove\n\n*   \"if double (S n) = double m then S n = m\".\n\n    To see why this is strange, let's think of a particular m \u2014\n    say, 5.  The statement is then saying that, if we know\n\n*   Q = \"if double n = 10 then n = 5\"\n\n    then we can prove\n\n*   R = \"if double (S n) = 10 then S n = 5\".\n\n    But knowing Q doesn't give us any help at all with proving\n    R!  (If we tried to prove R from Q, we would start with\n    something like \"Suppose double (S n) = 10...\" but then we'd be\n    stuck: knowing that double (S n) is 10 tells us nothing about\n    whether double n is 10, so Q is useless.) \n\n    Trying to carry out this proof by induction on n when m is\n    already in the context doesn't work because we are then trying to\n    prove a relation involving *every* n but just a *single* m. \n\n    The successful proof of double_injective leaves m in the goal\n    statement at the point where the induction tactic is invoked on\n    n:\n\n```", "```\n\n    Notice that both the goal and the induction hypothesis are\n    different this time: the goal asks us to prove something more\n    general (i.e., to prove the statement for *every* m), but the IH\n    is correspondingly more flexible, allowing us to choose any m we\n    like when we apply the IH.\n\n```", "```\n\n    Now we've chosen a particular m and introduced the assumption\n    that double n = double m.  Since we are doing a case analysis on\n    n, we also need a case analysis on m to keep the two \"in sync.\"\n\n```", "```\n\n    The 0 case is trivial:\n\n```", "```\n\n    At this point, since we are in the second branch of the destruct m, the m' mentioned in the context is the predecessor of the\n    m we started out talking about.  Since we are also in the S\n    branch of the induction, this is perfect: if we instantiate the\n    generic m in the IH with the current m' (this instantiation is\n    performed automatically by the apply in the next step), then\n    IHn' gives us exactly what we need to finish the proof.\n\n```", "```\n\n    What you should take away from all this is that we need to be\n    careful about using induction to try to prove something too\n    specific: To prove a property of n and m by induction on n,\n    it is sometimes important to leave m generic. \n\n    The following exercise requires the same pattern. \n\n#### Exercise: 2 stars (beq_nat_true)\n\n```", "```\n\n    \u2610 \n\n#### Exercise: 2 stars, advancedM (beq_nat_true_informal)\n\n    Give a careful informal proof of beq_nat_true, being as explicit\n    as possible about quantifiers.\n\n```", "```\n\n    \u2610 \n\n    The strategy of doing fewer intros before an induction to\n    obtain a more general IH doesn't always work by itself; sometimes\n    some *rearrangement* of quantified variables is needed.  Suppose,\n    for example, that we wanted to prove double_injective by\n    induction on m instead of n.\n\n```", "```\n\n    The problem is that, to do induction on m, we must first\n    introduce n.  (If we simply say induction m without\n    introducing anything first, Coq will automatically introduce n\n    for us!)  \n\n    What can we do about this?  One possibility is to rewrite the\n    statement of the lemma so that m is quantified before n.  This\n    works, but it's not nice: We don't want to have to twist the\n    statements of lemmas to fit the needs of a particular strategy for\n    proving them!  Rather we want to state them in the clearest and\n    most natural way. \n\n    What we can do instead is to first introduce all the quantified\n    variables and then *re-generalize* one or more of them,\n    selectively taking variables out of the context and putting them\n    back at the beginning of the goal.  The generalize dependent\n    tactic does this.\n\n```", "```\n\n    Let's look at an informal proof of this theorem.  Note that\n    the proposition we prove by induction leaves n quantified,\n    corresponding to the use of generalize dependent in our formal\n    proof.\n\n    *Theorem*: For any nats n and m, if double n = double m, then\n      n = m.\n\n    *Proof*: Let m be a nat. We prove by induction on m that, for\n      any n, if double n = double m then n = m.\n\n*   First, suppose m = 0, and suppose n is a number such that double n = double m. We must show that n = 0. \n\n     Since m = 0, by the definition of double we have double n = 0. There are two cases to consider for n. If n = 0 we are done, since m = 0 = n, as required. Otherwise, if n = S n' for some n', we derive a contradiction: by the definition of double, we can calculate double n = S (S (double n')), but this contradicts the assumption that double n = 0. \n\n*   Second, suppose m = S m' and that n is again a number such that double n = double m. We must show that n = S m', with the induction hypothesis that for every number s, if double s = double m' then s = m'. \n\n     By the fact that m = S m' and the definition of double, we have double n = S (S (double m')). There are two cases to consider for n. \n\n     If n = 0, then by definition double n = 0, a contradiction. \n\n     Thus, we may assume that n = S n' for some n', and again by the definition of double we have S (S (double n')) = S (S (double m')), which implies by inversion that double n' = double m'. Instantiating the induction hypothesis with n' thus allows us to conclude that n' = m', and it follows immediately that S n' = S m'. Since S n' = n and S m' = m, this is just what we wanted to show. \u2610\n\n    Before we close this section and move on to some exercises,\n    let's digress briefly and use beq_nat_true to prove a similar\n    property of identifiers that we'll need in later chapters:\n\n```", "```\n\n#### Exercise: 3 stars, recommended (gen_dep_practice)\n\n    Prove this by induction on l.\n\n```", "```\n\n    \u2610\n\n```", "```\nDefinition square n := n * n.\n\n```", "```\nLemma square_mult : \u2200n m, square (n * m) = square n * square m.\nProof.\n\u00a0\u00a0intros n m.\n\u00a0\u00a0simpl.\n\n```", "```\n\u00a0\u00a0unfold square.\n\n```", "```\n\u00a0\u00a0rewrite mult_assoc.\n\u00a0\u00a0assert (H : n * m * n = n * n * m).\n\u00a0\u00a0{ rewrite mult_comm. apply mult_assoc. }\n\u00a0\u00a0rewrite H. rewrite mult_assoc. reflexivity.\nQed.\n\n```", "```\nDefinition foo (x: nat) := 5.\n\n```", "```\nFact silly_fact_1 : \u2200m, foo m + 1 = foo (m + 1) + 1.\nProof.\n\u00a0\u00a0intros m.\n\u00a0\u00a0simpl.\n\u00a0\u00a0reflexivity.\nQed.\n\n```", "```\nDefinition bar x :=\n\u00a0\u00a0match x with\n\u00a0\u00a0| O \u21d2 5\n\u00a0\u00a0| S _ \u21d2 5\n\u00a0\u00a0end.\n\n```", "```\nFact silly_fact_2_FAILED : \u2200m, bar m + 1 = bar (m + 1) + 1.\nProof.\n\u00a0\u00a0intros m.\n\u00a0\u00a0simpl. (*\u00a0Does\u00a0nothing!\u00a0*)\nAbort.\n\n```", "```\nFact silly_fact_2 : \u2200m, bar m + 1 = bar (m + 1) + 1.\nProof.\n\u00a0\u00a0intros m.\n\u00a0\u00a0destruct m.\n\u00a0\u00a0- simpl. reflexivity.\n\u00a0\u00a0- simpl. reflexivity.\nQed.\n\n```", "```\nFact silly_fact_2' : \u2200m, bar m + 1 = bar (m + 1) + 1.\nProof.\n\u00a0\u00a0intros m.\n\u00a0\u00a0unfold bar.\n\n```", "```\n\u00a0\u00a0destruct m.\n\u00a0\u00a0- reflexivity.\n\u00a0\u00a0- reflexivity.\nQed.\n\n```", "```\nDefinition sillyfun (n : nat) : bool :=\n\u00a0\u00a0if beq_nat n 3 then false\n\u00a0\u00a0else if beq_nat n 5 then false\n\u00a0\u00a0else false.\n\nTheorem sillyfun_false : \u2200(n : nat),\n\u00a0\u00a0sillyfun n = false.\nProof.\n\u00a0\u00a0intros n. unfold sillyfun.\n\u00a0\u00a0destruct (beq_nat n 3).\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0beq_nat\u00a0n\u00a03\u00a0=\u00a0true\u00a0*) reflexivity.\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0beq_nat\u00a0n\u00a03\u00a0=\u00a0false\u00a0*) destruct (beq_nat n 5).\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0beq_nat\u00a0n\u00a05\u00a0=\u00a0true\u00a0*) reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0beq_nat\u00a0n\u00a05\u00a0=\u00a0false\u00a0*) reflexivity. Qed.\n\n```", "```\nTheorem combine_split : \u2200X Y (l : list (X * Y)) l[1] l[2],\n\u00a0\u00a0split l = (l[1], l[2]) \u2192\n\u00a0\u00a0combine l[1] l[2] = l.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition sillyfun1 (n : nat) : bool :=\n\u00a0\u00a0if beq_nat n 3 then true\n\u00a0\u00a0else if beq_nat n 5 then true\n\u00a0\u00a0else false.\n\n```", "```\nTheorem sillyfun1_odd_FAILED : \u2200(n : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0sillyfun1 n = true \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0oddb n = true.\nProof.\n\u00a0\u00a0intros n eq. unfold sillyfun1 in eq.\n\u00a0\u00a0destruct (beq_nat n 3).\n\u00a0\u00a0(*\u00a0stuck...\u00a0*)\nAbort.\n\n```", "```\nTheorem sillyfun1_odd : \u2200(n : nat),\n\u00a0\u00a0\u00a0\u00a0\u00a0sillyfun1 n = true \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0oddb n = true.\nProof.\n\u00a0\u00a0intros n eq. unfold sillyfun1 in eq.\n\u00a0\u00a0destruct (beq_nat n 3) eqn:Heqe3.\n\u00a0\u00a0(*\u00a0Now\u00a0we\u00a0have\u00a0the\u00a0same\u00a0state\u00a0as\u00a0at\u00a0the\u00a0point\u00a0where\u00a0we\u00a0got \u00a0\u00a0\u00a0\u00a0\u00a0stuck\u00a0above,\u00a0except\u00a0that\u00a0the\u00a0context\u00a0contains\u00a0an\u00a0extra \u00a0\u00a0\u00a0\u00a0\u00a0equality\u00a0assumption,\u00a0which\u00a0is\u00a0exactly\u00a0what\u00a0we\u00a0need\u00a0to \u00a0\u00a0\u00a0\u00a0\u00a0make\u00a0progress.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0e[3]\u00a0=\u00a0true\u00a0*) apply beq_nat_true in Heqe3.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2192 Heqe3. reflexivity.\n\u00a0\u00a0\u00a0\u00a0- (*\u00a0e[3]\u00a0=\u00a0false\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0(*\u00a0When\u00a0we\u00a0come\u00a0to\u00a0the\u00a0second\u00a0equality\u00a0test\u00a0in\u00a0the\u00a0body \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of\u00a0the\u00a0function\u00a0we\u00a0are\u00a0reasoning\u00a0about,\u00a0we\u00a0can\u00a0use \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0eqn:\u00a0again\u00a0in\u00a0the\u00a0same\u00a0way,\u00a0allow\u00a0us\u00a0to\u00a0finish\u00a0the \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0proof.\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0destruct (beq_nat n 5) eqn:Heqe5.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0e[5]\u00a0=\u00a0true\u00a0*)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0apply beq_nat_true in Heqe5.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rewrite \u2192 Heqe5. reflexivity.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ (*\u00a0e[5]\u00a0=\u00a0false\u00a0*) inversion eq. Qed.\n\n```", "```\nTheorem bool_fn_applied_thrice :\n\u00a0\u00a0\u2200(f : bool \u2192 bool) (b : bool),\n\u00a0\u00a0f (f (f b)) = f b.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\n# Review\n\n    We've now seen many of Coq's most fundamental tactics.  We'll\n    introduce a few more in the coming chapters, and later on we'll\n    see some more powerful *automation* tactics that make Coq help us\n    with low-level details.  But basically we've got what we need to\n    get work done.\n\n    Here are the ones we've seen:\n\n*   intros: move hypotheses/variables from goal to context \n\n*   reflexivity: finish the proof (when the goal looks like e = e) \n\n*   apply: prove goal using a hypothesis, lemma, or constructor \n\n*   apply... in H: apply a hypothesis, lemma, or constructor to a hypothesis in the context (forward reasoning) \n\n*   apply... with...: explicitly specify values for variables that cannot be determined by pattern matching \n\n*   simpl: simplify computations in the goal \n\n*   simpl in H: ... or a hypothesis \n\n*   rewrite: use an equality hypothesis (or lemma) to rewrite the goal \n\n*   rewrite ... in H: ... or a hypothesis \n\n*   symmetry: changes a goal of the form t=u into u=t \n\n*   symmetry in H: changes a hypothesis of the form t=u into u=t \n\n*   unfold: replace a defined constant by its right-hand side in the goal \n\n*   unfold... in H: ... or a hypothesis \n\n*   destruct... as...: case analysis on values of inductively defined types \n\n*   destruct... eqn:...: specify the name of an equation to be added to the context, recording the result of the case analysis \n\n*   induction... as...: induction on values of inductively defined types \n\n*   inversion: reason by injectivity and distinctness of constructors \n\n*   assert (H: e) (or assert (e) as H): introduce a \"local lemma\" e and call it H \n\n*   generalize dependent x: move the variable x (and anything else that depends on it) from the context back to an explicit hypothesis in the goal formula\n\n```", "```\nTheorem beq_nat_sym : \u2200(n m : nat),\n\u00a0\u00a0beq_nat n m = beq_nat m n.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem beq_nat_trans : \u2200n m p,\n\u00a0\u00a0beq_nat n m = true \u2192\n\u00a0\u00a0beq_nat m p = true \u2192\n\u00a0\u00a0beq_nat n p = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nDefinition split_combine_statement : Prop\n\u00a0\u00a0(*\u00a0(\": Prop\"\u00a0means\u00a0that\u00a0we\u00a0are\u00a0giving\u00a0a\u00a0name\u00a0to\u00a0a \u00a0\u00a0\u00a0\u00a0\u00a0logical\u00a0proposition\u00a0here.)\u00a0*)\n\u00a0\u00a0(*\u00a0REPLACE\u00a0THIS\u00a0LINE\u00a0WITH\u00a0\":=\u00a0_your_definition_\u00a0.\"\u00a0*). Admitted.\n\nTheorem split_combine : split_combine_statement.\nProof.\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\nTheorem filter_exercise : \u2200(X : Type) (test : X \u2192 bool)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(x : X) (l lf : list X),\n\u00a0\u00a0\u00a0\u00a0\u00a0filter test l = x :: lf \u2192\n\u00a0\u00a0\u00a0\u00a0\u00a0test x = true.\nProof.\n\u00a0\u00a0(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*) Admitted.\n\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forallb\u00a0oddb\u00a0[1;3;5;7;9]\u00a0=\u00a0true\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forallb\u00a0negb\u00a0[false;false]\u00a0=\u00a0true\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forallb\u00a0evenb\u00a0[0;2;4;5]\u00a0=\u00a0false\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0forallb\u00a0(beq_nat\u00a05)\u00a0[]\u00a0=\u00a0true\n\n    The second checks whether there exists an element in the list that\n    satisfies a given predicate:\n\n```", "```\n(*\u00a0FILL\u00a0IN\u00a0HERE\u00a0*)\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```"]