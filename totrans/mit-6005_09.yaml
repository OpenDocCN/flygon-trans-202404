- en: 'Reading 9: Mutability & Immutability'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 9：可变性与不可变性
- en: Software in 6.005
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.005 中的软件
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '-   无 bug | 易于理解 | 可以应对变化'
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '-   改正今天，也适用于未知的未来。| 与未来的程序员清晰沟通，包括未来的你。| 设计用于在不重写的情况下容纳变化。'
- en: Objectives
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 目标
- en: Understand mutability and mutable objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可变性和可变对象
- en: Identify aliasing and understand the dangers of mutability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定别名和理解可变性的危险
- en: Use immutability to improve correctness, clarity, & changeability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用不可变性来提高正确性、清晰度和可变性
- en: Mutability
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变性
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutability/Knxg2PP7BRU)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutability/Knxg2PP7BRU)'
- en: 'Recall from [*Basic Java* when we discussed snapshot diagrams](../02-basic-java/#snapshot_diagrams)
    that some objects are *immutable*: once created, they always represent the same
    value. Other objects are *mutable*: they have methods that change the value of
    the object.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从[*Basic Java* 中我们讨论快照图表](../02-basic-java/#snapshot_diagrams)时，可以回想起，某些对象是*不可变*的：一旦创建，它们始终代表相同的值。其他对象是*可变*的：它们具有可以改变对象值的方法。
- en: '[`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    is an example of an immutable type. A `String` object always represents the same
    string. [`StringBuilder`](http://docs.oracle.com/javase/8/docs/api/?java/lang/StringBuilder.html)
    is an example of a mutable type. It has methods to delete parts of the string,
    insert or replace characters, etc.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    是不可变类型的一个例子。`String` 对象始终表示相同的字符串。[`StringBuilder`](http://docs.oracle.com/javase/8/docs/api/?java/lang/StringBuilder.html)
    是可变类型的一个例子。它具有删除字符串的部分、插入或替换字符等方法。'
- en: '![reassigning a variable](../Images/ded61b67bfe27877e4bb9fa6f2fd07a9.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![重新分配变量](../Images/ded61b67bfe27877e4bb9fa6f2fd07a9.jpg)'
- en: 'Since `String` is immutable, once created, a `String` object always has the
    same value. To add something to the end of a String, you have to create a new
    String object:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `String` 是不可变的，一旦创建，`String` 对象始终具有相同的值。要在字符串末尾添加内容，必须创建一个新的 String 对象：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![mutating an object](../Images/1c6923d6a53006c05c2e0d3c8cfd35c5.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![改变对象的可变性](../Images/1c6923d6a53006c05c2e0d3c8cfd35c5.jpg)'
- en: 'By contrast, `StringBuilder` objects are mutable. This class has methods that
    change the value of the object, rather than just returning new values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`StringBuilder` 对象是可变的。这个类有改变对象值的方法，而不仅仅是返回新值：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`StringBuilder` has other methods as well, for deleting parts of the string,
    inserting in the middle, or changing individual characters.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder` 还有其他方法，用于删除字符串的部分、在中间插入或更改单个字符。'
- en: 'So what? In both cases, you end up with `s` and `sb` referring to the string
    of characters `"ab"`. The difference between mutability and immutability doesn’t
    matter much when there’s only one reference to the object. But there are big differences
    in how they behave when there are *other* references to the object. For example,
    when another variable `t` points to the same String object as `s`, and another
    variable `tb` points to the same StringBuilder as `sb`, then the differences between
    the immutable and mutable objects become more evident:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么呢？在两种情况下，最终你都会得到 `s` 和 `sb` 引用字符串 `"ab"`。当只有一个引用指向对象时，可变性和不可变性之间的差异并不重要。但是当对象存在*其他*引用时，它们的行为就有很大的区别。例如，当另一个变量
    `t` 指向与 `s` 相同的 String 对象，另一个变量 `tb` 指向与 `sb` 相同的 StringBuilder 对象时，不可变对象和可变对象之间的差异变得更加明显：
- en: '![different behavior of String and StringBuilder](../Images/f4006e707b06ed2882bb54298a40999c.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![String 和 StringBuilder 的不同行为](../Images/f4006e707b06ed2882bb54298a40999c.jpg)'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This shows that changing `t` had no effect on `s`, but changing `tb` affected
    `sb` too — possibly to the surprise of the programmer. That’s the essence of the
    problem we’re going to look at in this reading.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明改变`t`对`s`没有影响，但改变`tb`也会影响`sb` —— 这可能让程序员感到意外。这就是我们将在本次阅读中探讨的问题的实质。
- en: 'Since we have the immutable `String` class already, why do we even need the
    mutable `StringBuilder` in programming? A common use for it is to concatenate
    a large number of strings together. Consider this code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了不可变的 `String` 类，为什么我们在编程中还需要可变的 `StringBuilder`？它的一个常见用途是将大量的字符串连接在一起。考虑以下代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using immutable strings, this makes a lot of temporary copies — the first number
    of the string (`"0"`) is actually copied *n* times in the course of building up
    the final string, the second number is copied *n-1* times, and so on. It actually
    costs *O(n²)* time just to do all that copying, even though we only concatenated
    *n* elements.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变字符串，这会产生很多临时副本 —— 字符串的第一个数字（`"0"`）实际上在构建最终字符串的过程中被复制了 *n* 次，第二个数字被复制了 *n-1*
    次，依此类推。即使我们只是连接了 *n* 个元素，做所有这些复制实际上需要 *O(n²)* 的时间。
- en: '`StringBuilder` is designed to minimize this copying. It uses a simple but
    clever internal data structure to avoid doing any copying at all until the very
    end, when you ask for the final `String` with a `toString()` call:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder` 被设计为最小化这种复制。它使用一种简单但巧妙的内部数据结构，在你调用 `toString()` 方法请求最终的 `String`
    时完全避免了任何复制：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Getting good performance is one reason why we use mutable objects. Another
    is convenient sharing: two parts of your program can communicate more conveniently
    by sharing a common mutable data structure.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 获得良好性能是我们使用可变对象的另一个原因。另一个原因是方便共享：程序的两个部分可以通过共享一个共同的可变数据结构更方便地进行通信。
- en: reading exercises
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Follow me
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 跟我来
- en: '![](../Images/56525f335edebebf0c97a8f974cac834.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/56525f335edebebf0c97a8f974cac834.jpg)'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: （答案缺失）（答案缺失）（答案缺失）（答案缺失）
- en: (missing explanation)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: （解释缺失）
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: （答案缺失）（答案缺失）（答案缺失）（答案缺失）
- en: (missing explanation)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: （解释缺失）
- en: Choose the best answer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最佳答案。
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: （答案缺失）（答案缺失）（答案缺失）（答案缺失）（答案缺失）（答案缺失）
- en: (missing explanation)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: （解释缺失）
- en: Risks of mutation
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变异风险
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,risks_of_mutation/UWpF9C77e3U)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,risks_of_mutation/UWpF9C77e3U)'
- en: Mutable types seem much more powerful than immutable types. If you were shopping
    in the Datatype Supermarket, and you had to choose between a boring immutable
    `String` and a super-powerful-do-anything mutable `StringBuilder`, why on earth
    would you choose the immutable one? `StringBuilder` should be able to do everything
    that `String` can do, plus `set()` and `append()` and everything else.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可变类型似乎比不可变类型更强大。如果你在 Datatype 超市购物，并且必须在一个无聊的不可变 `String` 和一个超级强大的可变 `StringBuilder`
    中选择，为什么你会选择不可变的？`StringBuilder` 应该能够做任何 `String` 能做的事情，而且还可以 `set()` 和 `append()`
    等等。
- en: The answer is that **immutable types are safer from bugs, easier to understand,
    and more ready for change**. Mutability makes it harder to understand what your
    program is doing, and much harder to enforce contracts. Here are two examples
    that illustrate why.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是**不可变类型更安全，更容易理解，并且更容易应对变化**。可变性使得理解程序在做什么变得更加困难，并且更加难以强制执行合同。以下是两个说明原因的示例。
- en: 'Risky example #1: passing mutable values'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '风险示例 #1：传递可变值'
- en: 'Let’s start with a simple method that sums the integers in a list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的方法开始，它对列表中的整数求和：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Suppose we also need a method that sums the absolute values. Following good
    DRY practice ([Don’t Repeat Yourself](http://en.wikipedia.org/wiki/Don''t_repeat_yourself)),
    the implementer writes a method that uses `sum()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们还需要一个求绝对值之和的方法。遵循良好的 DRY 实践（[不要重复自己](http://en.wikipedia.org/wiki/Don't_repeat_yourself)），实施者编写了一个使用
    `sum()` 的方法：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that this method does its job by **mutating the list directly**. It
    seemed sensible to the implementer, because it’s more efficient to reuse the existing
    list. If the list is millions of items long, then you’re saving the time and memory
    of generating a new million-item list of absolute values. So the implementer has
    two very good reasons for this design: DRY, and performance.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个方法通过**直接改变列表**来完成其工作。对于实施者来说，这似乎是合理的，因为重用现有列表更高效。如果列表有数百万个项目，那么你就节省了生成新的百万项目的绝对值列表的时间和内存。因此，实施者对这种设计有两个非常好的理由：DRY
    和性能。
- en: 'But the resulting behavior will be very surprising to anybody who uses it!
    For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是结果行为对于任何使用它的人都会非常令人惊讶！例如：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What will this code print? Will it be 10 followed by -10? Or something else?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会打印什么？是`10`后面跟着`-10`吗？还是其他什么？
- en: reading exercises
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: 'Risky #1(missing answer)(missing answer)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '风险 #1（答案缺失）（答案缺失）'
- en: (missing explanation)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: （解释缺失）
- en: 'Let’s think about the key points here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下这里的要点：
- en: '**Safe from bugs?** In this example, it’s easy to blame the implementer of
    `sum­Absolute()` for going beyond what its spec allowed. But really, **passing
    mutable objects around is a latent bug**. It’s just waiting for some programmer
    to inadvertently mutate that list, often with very good intentions like reuse
    or performance, but resulting in a bug that may be very hard to track down.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免于错误？** 在这个例子中，很容易责怪`sum­Absolute()`的实现者超出了其规范允许的范围。但实际上，**传递可变对象是一个潜在的错误**。它只是在等待一些程序员无意中改变那个列表，通常出于重用或性能的很好意图，但导致一个可能非常难以追踪的错误。'
- en: '**Easy to understand?** When reading `main()`, what would you assume about
    `sum()` and `sum­Absolute()`? Is it clearly visible to the reader that `myData`
    gets *changed* by one of them?'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解？** 当阅读`main()`时，你会认为`sum()`和`sum­Absolute()`会对`myData`做出什么样的改变？读者清楚地看到`myData`被它们中的一个*改变*了吗？'
- en: 'Risky example #2: returning mutable values'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '风险示例 #2：返回可变值'
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,risks_of_mutation,risky_example_2_returning_mutable_values/DBshg8se4Jc)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,risks_of_mutation,risky_example_2_returning_mutable_values/DBshg8se4Jc)'
- en: We just saw an example where passing a mutable object to a function caused problems.
    What about returning a mutable object?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到一个例子，其中将一个可变对象传递给函数导致了问题。那么返回一个可变对象会发生什么呢？
- en: 'Let’s consider [`Date`](http://docs.oracle.com/javase/8/docs/api/?java/util/Date.html),
    one of the built-in Java classes. `Date` happens to be a mutable type. Suppose
    we write a method that determines the first day of spring:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下[`Date`](http://docs.oracle.com/javase/8/docs/api/?java/util/Date.html)，其中之一内置的Java类。
    `Date`碰巧是一个可变类型。假设我们编写一个确定春天第一天的方法：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we’re using the well-known Groundhog algorithm for calculating when spring
    starts (Harold Ramis, Bill Murray, et al. *Groundhog Day*, 1993).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了计算春天开始时间的著名土拨鼠算法（哈罗德·拉米斯，比尔·默里等人，《土拨鼠之日》，1993年）。
- en: 'Clients start using this method, for example to plan their big parties:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 客户开始使用这个方法，例如计划他们的大型聚会：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All the code works and people are happy. Now, independently, two things happen.
    First, the implementer of `startOfSpring()` realizes that the groundhog is starting
    to get annoyed from being constantly asked when spring will start. So the code
    is rewritten to ask the groundhog at most once, and then cache the groundhog’s
    answer for future calls:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的代码都能够正常运行，人们也都很满意。现在，独立地发生了两件事情。首先，`startOfSpring()`的实现者意识到，地鼠因为被不断询问春天何时开始而开始感到恼火。于是代码被重写，最多只询问一次地鼠，然后将地鼠的答案缓存起来供将来使用：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '(Aside: note the use of a private static variable for the cached answer. Would
    you consider this a global variable, or not?)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (另外：请注意为缓存答案使用了一个私有静态变量。你会认为这是一个全局变量吗？还是不是？)
- en: 'Second, one of the clients of `startOfSpring()` decides that the actual first
    day of spring is too cold for the party, so the party will be exactly a month
    later instead:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`startOfSpring()`的一个客户决定实际的春天第一天太冷了，所以聚会将会推迟一个月：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '(Aside: this code also has a latent bug in the way it adds a month. Why? What
    does it implicitly assume about when spring starts?)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (另外：这段代码在增加一个月的方式上也存在潜在的错误。为什么？它隐含地假设了春天开始的时间？)
- en: What happens when these two decisions interact? Even worse, think about who
    will first discover this bug — will it be `startOfSpring()`? Will it be `partyPlanning()`?
    Or will it be some completely innocent third piece of code that also calls `startOfSpring()`?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个决定相互作用时会发生什么？更糟糕的是，想象一下谁会首先发现这个错误——是`startOfSpring()`吗？是`partyPlanning()`吗？还是一些完全无辜的第三方代码，也会调用`startOfSpring()`吗？
- en: reading exercises
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: 'Risky #2'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '风险 #2'
- en: We don’t know how `Date` stores the month, so we’ll represent that with the
    abstract values `...march...` and `...april...` in an imagined `month` field of
    `Date`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道`Date`是如何存储月份的，所以我们将用`Date`的想象中的`month`字段中的抽象值`...march...`和`...april...`来表示。
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少答案)(缺少答案)(缺少答案)(缺少答案)(缺少答案)
- en: (missing explanation)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (缺少解释)
- en: 'Understanding risky example #2'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '理解风险示例 #2'
- en: '`partyPlanning` has unwittingly changed the start of spring, because `partyDate`
    and `groundhogAnswer` happen to point to the same mutable `Date` object.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`partyPlanning`无意中改变了春天的开始，因为`partyDate`和`groundhogAnswer`碰巧指向同一个可变的`Date`对象。'
- en: Worse, this bug will probably *not* be discovered in `partyPlanning()` or `startOfSpring()`
    right away. Instead, it will be some innocent piece of code that subsequently
    calls `startOfSpring()`, gets the wrong date back, and goes on to compute its
    own wrong answer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，这个错误可能不会立即在`partyPlanning()`或`startOfSpring()`中被发现。相反，它将是一些无辜的代码片段，随后调用`startOfSpring()`，得到错误的日期返回，并继续计算自己的错误答案。
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: A second bug
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个错误
- en: The code has another potential bug in how it adds to the month.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在如何增加月份方面还存在另一个潜在的错误。
- en: Take a look at the Java API documentation for `Date.setMonth`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看Java API文档中的`Date.setMonth`。
- en: <select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option>,<option>5</option>,<option>6</option>,<option>7</option>,<option>8</option>,<option>9</option>,<option>10</option>,<option>11</option>,<option>12</option></select>(missing
    answer)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`<select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option>,<option>5</option>,<option>6</option>,<option>7</option>,<option>8</option>,<option>9</option>,<option>10</option>,<option>11</option>,<option>12</option></select>(缺少答案)'
- en: (missing explanation)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: NoSuchMonthException
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoSuchMonthException`'
- en: 'The documentation for `Date.setMonth` says `month: the month value between
    0-11`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date.setMonth`的文档说`month: 介于0-11之间的月份值`。'
- en: Based on that statement and just what you’ve read so far…
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据那个陈述和你到目前为止所读到的内容…
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: SuchTerribleSpecificationsException
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`SuchTerribleSpecificationsException`'
- en: 'Elsewhere in the documentation for `Date`, it says: “arguments given to methods
    […] need not fall within the indicated ranges; for example, a date may be specified
    as January 32 and is interpreted as meaning February 1”.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Date`文档的其他地方，它说：“给方法传递的参数可以不在指定的范围内；例如，一个日期可以被指定为1月32日，解释为2月1日”。
- en: What looks like a precondition… isn’t!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像是前提条件的… 不是！
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少答案）（缺少答案）（缺少答案）（缺少答案）（缺少答案）
- en: (missing explanation)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: （缺少解释）
- en: 'Key points:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点：
- en: '**Safe from bugs?** Again we had a latent bug that reared its ugly head.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误困扰？**再次出现了一个潜在的错误。'
- en: '**Ready for change?** Obviously the mutation of the date object is a change,
    but that’s not the kind of change we’re talking about when we say “ready for change.”
    Instead, the question is whether the code of the program can be easily changed
    without rewriting a lot of it or introducing bugs. Here we had two apparently
    independent changes, by different programmers, that interacted to produce a bad
    bug.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备好变化？**显然，日期对象的变异是一种变化，但这不是我们谈论“准备好变化”时所指的那种变化。相反，问题是程序的代码是否可以在不大量重写或引入错误的情况下轻松更改。在这里，我们有两个显然独立的更改，由不同的程序员完成，它们相互作用产生了一个严重的错误。'
- en: In both of these examples — the `List<Integer>` and the `Date` — the problems
    would have been completely avoided if the list and the date had been immutable
    types. The bugs would have been impossible by design.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中——`List<Integer>`和`Date`——如果列表和日期是不可变类型，问题就完全可以避免。这些错误本来是设计上不可能出现的。
- en: 'In fact, you should never use `Date`! Use one of the classes from [package
    `java.time`](http://docs.oracle.com/javase/8/docs/api/index.html?java/time/package-summary.html):
    [`LocalDateTime`](http://docs.oracle.com/javase/8/docs/api/?java/time/LocalDateTime.html),
    [`Instant`](http://docs.oracle.com/javase/8/docs/api/?java/time/Instant.html),
    etc. All guarantee in their specifications that they are *immutable*.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不应该使用`Date`！使用`java.time`包中的类之一：[`LocalDateTime`](http://docs.oracle.com/javase/8/docs/api/?java/time/LocalDateTime.html)，[`Instant`](http://docs.oracle.com/javase/8/docs/api/?java/time/Instant.html)等。它们在规范中保证它们是*不可变*的。
- en: 'This example also illustrates why using mutable objects can actually be *bad*
    for performance. The simplest solution to this bug, which avoids changing any
    of the specifications or method signatures, is for `startOfSpring()` to always
    return a *copy* of the groundhog’s answer:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子也说明了为什么使用可变对象实际上对性能可能是有害的。避免更改任何规范或方法签名的最简单解决方案是，`startOfSpring()`始终返回土拨鼠的答案的*副本*：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This pattern is **defensive copying**, and we’ll see much more of it when we
    talk about abstract data types. The defensive copy means `partyPlanning()` can
    freely stomp all over the returned date without affecting `startOfSpring()`’s
    cached date. But defensive copying forces `startOfSpring()` to do extra work and
    use extra space for *every client* — even if 99% of the clients never mutate the
    date it returns. We may end up with lots of copies of the first day of spring
    throughout memory. If we used an immutable type instead, then different parts
    of the program could safely share the same values in memory, so less copying and
    less memory space is required. Immutability can be more efficient than mutability,
    because immutable types never need to be defensively copied.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是**防御性拷贝**，当我们谈论抽象数据类型时，我们会看到更多这种情况。防御性拷贝意味着`partyPlanning()`可以自由地修改返回的日期，而不会影响`startOfSpring()`缓存的日期。但是防御性拷贝会迫使`startOfSpring()`做额外的工作，并使用额外的空间来*为每个客户端*做拷贝
    — 即使99%的客户端从不改变它返回的日期。我们可能会在内存中有很多复制的春天第一天。如果我们使用不可变类型，那么程序的不同部分可以安全地共享内存中的相同值，因此需要更少的拷贝和更少的内存空间。不可变性可能比可变性更有效，因为不可变类型永远不需要进行防御性拷贝。
- en: Aliasing is what makes mutable types risky
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 别名是使可变类型风险的原因
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,aliasing_is_what_makes_mutable_types_risky/vjn4owb1HPI)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,aliasing_is_what_makes_mutable_types_risky/vjn4owb1HPI)'
- en: Actually, using mutable objects is just fine if you are using them entirely
    locally within a method, and with only one reference to the object. What led to
    the problem in the two examples we just looked at was having multiple references,
    also called **aliases**, for the same mutable object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果你在一个方法中完全本地使用可变对象，并且只有一个对对象的引用，那么使用可变对象是完全可以的。刚刚我们看到的两个例子中��现问题的原因是有多个引用，也称为**别名**，指向同一个可变对象。
- en: 'Walking through the examples with a snapshot diagram will make this clear,
    but here’s the outline:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快照图示例来解释这一点，但这里是概述：
- en: In the `List` example, the same list is pointed to by both `list` (in `sum`
    and `sumAbsolute`) and `myData` (in `main`). One programmer (`sumAbsolute`’s)
    thinks it’s ok to modify the list; another programmer (`main`’s) wants the list
    to stay the same. Because of the aliases, `main`’s programmer loses.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`List`的例子中，同一个列表被`list`（在`sum`和`sumAbsolute`中）和`myData`（在`main`中）指向。一个程序员（`sumAbsolute`的）认为修改列表是可以的；另一个程序员（`main`的）希望列表保持不变。由于别名的存在，`main`的程序员失败了。
- en: In the `Date` example, there are two variable names that point to the `Date`
    object, `groundhogAnswer` and `partyDate`. These aliases are in completely different
    parts of the code, under the control of different programmers who may have no
    idea what the other is doing.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Date`的例子中，有两个变量名指向`Date`对象，`groundhogAnswer`和`partyDate`。这些别名位于代码的完全不同部分，由不同的程序员控制，他们可能不知道对方在做什么。
- en: Draw snapshot diagrams on paper first, but your real goal should be to develop
    the snapshot diagram in your head, so you can visualize what’s happening in the
    code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在纸上绘制快照图示，但你真正的目标应该是在脑海中开发快照图示，这样你就可以可视化代码中发生的情况。
- en: Specifications for mutating methods
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变异方法的规范
- en: At this point it should be clear that when a method performs mutation, it is
    crucial to include that mutation in the method’s spec, using [the structure we
    discussed in the previous reading](../06-specifications/specs/#specifications_for_mutating_methods).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，应该清楚，当一个方法执行变异时，将该变异包含在方法的规范中是至关重要的，使用[我们在上一篇阅读中讨论的结构](../06-specifications/specs/#specifications_for_mutating_methods)。
- en: (Now we’ve seen that even when a particular method *doesn’t* mutate an object,
    that object’s mutability can still be a source of bugs.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: (现在我们已经看到，即使一个特定的方法*不*改变一个对象，该对象的可变性仍然可能是错误的来源。)
- en: 'Here’s an example of a mutating method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个改变方法的例子：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And an example of a method that does not mutate its argument:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不改变其参数的方法的例子：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the *effects* do not explicitly say that an input can be mutated, then in
    6.005 we assume mutation of the input is implicitly disallowed. Virtually all
    programmers would assume the same thing. Surprise mutations lead to terrible bugs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*效果*没有明确说明输入可以被改变，那么在6.005中，我们假设输入的变异是被隐式禁止的。几乎所有程序员都会假设相同的事情。意外的变异会导致可怕的错误。
- en: Iterating over arrays and lists
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历数组和列表
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,iterating_over_arrays_and_lists/zTjUFSIZFhc)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,iterating_over_arrays_and_lists/zTjUFSIZFhc)'
- en: 'The next mutable object we’re going to look at is an **iterator** — an object
    that steps through a collection of elements and returns the elements one by one.
    Iterators are used under the covers in Java when you’re using a [`for (... : ...)`
    loop](../02-basic-java/#iteration) to step through a `List` or array. This code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将要看的下一个可变对象是一个**迭代器** —— 一个逐步遍历元素集合并逐个返回元素的对象。在 Java 中，当你使用 [`for (... :
    ...)` 循环](../02-basic-java/#iteration) 遍历 `List` 或数组时，底层实际上使用了迭代器。这段代码：'
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'is rewritten by the compiler into something like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 被编译器重写为类似于这样的内容：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An iterator has two methods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个迭代器有两个方法：
- en: '`next()` returns the next element in the collection'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()` 返回集合中的下一个元素。'
- en: '`hasNext()` tests whether the iterator has reached the end of the collection.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNext()` 用于测试迭代器是否已经到达集合的末尾。'
- en: Note that the `next()` method is a **mutator** method, not only returning an
    element but also advancing the iterator so that the subsequent call to `next()`
    will return a different element.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`next()` 方法是一个**变异方法**，不仅返回一个元素，还推进迭代器，以便随后调用 `next()` 将返回不同的元素。
- en: You can also look at the [Java API definition of `Iterator`](http://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看 [Java API 中 `Iterator` 的定义](http://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html)。
- en: 'Before we go any further:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步讨论之前：
- en: 'You should already have read: **[Classes and Objects](http://docs.oracle.com/javase/tutorial/java/javaOO/index.html)**
    in the Java Tutorials.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经阅读了：**[类和对象](http://docs.oracle.com/javase/tutorial/java/javaOO/index.html)**
    在 Java 教程中。
- en: 'Read: **[the `final` keyword](http://www.codeguru.com/java/tij/tij0071.shtml)**
    on CodeGuru.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读：在 CodeGuru 上的 **[final 关键字](http://www.codeguru.com/java/tij/tij0071.shtml)**。
- en: '`MyIterator`'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MyIterator`'
- en: 'To better understand how an iterator works, here’s a simple implementation
    of an iterator for `ArrayList<String>`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解迭代器的工作原理，这里有一个简单的 `ArrayList<String>` 迭代器的实现：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`MyIterator` makes use of a few Java language features that are different from
    the classes we’ve been writing up to this point. Make sure you’ve read the linked
    Java Tutorial sections so that you understand them:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyIterator` 使用了一些与我们迄今为止编写的类不同的 Java 语言特性。确保你已经阅读了链接的 Java 教程部分，以便你理解它们：'
- en: '[**Instance variables**](http://docs.oracle.com/javase/tutorial/java/javaOO/variables.html),
    also called fields in Java. Instance variables differ from method parameters and
    local variables; the instance variables are stored in the object instance and
    persist for longer than a method call. What are the instance variables of `My­Iterator`?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[**实例变量**](http://docs.oracle.com/javase/tutorial/java/javaOO/variables.html)，在
    Java 中也称为字段。实例变量与方法参数和局部变量不同；实例变量存储在对象实例中，并且在方法调用之后持续存在。`My­Iterator` 的实例变量是什么？'
- en: A [**constructor**](http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html),
    which makes a new object instance and initializes its instance variables. Where
    is the constructor of `My­Iterator`?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[**构造函数**](http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html)，用于创建一个新的对象实例并初始化其实例变量。`My­Iterator`
    的构造函数在哪里？
- en: The `static` keyword is missing from `My­Iterator`’s methods, which means they
    are [**instance methods**](http://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)
    that must be called on an instance of the object, e.g. `iter.next()`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`My­Iterator` 的方法缺少了 `static` 关键字，这意味着它们是[**实例方法**](http://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)，必须在对象实例上调用，例如
    `iter.next()`。'
- en: The [**`this` keyword**](http://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html)
    is used at one point to refer to the **instance object**, in particular to refer
    to an instance variable (`this.list`). This was done to disambiguate two different
    variables named `list` (an instance variable and a constructor parameter). Most
    of `My­Iterator`’s code refers to instance variables without an explicit `this`,
    but this is just a convenient shorthand that Java supports — e.g., `index` actually
    means `this.index`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个地方使用了[**`this` 关键字**](http://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html)
    来引用**实例对象**，特别是用来引用实例变量（`this.list`）。这是为了消除两个不同命名的变量 `list`（一个是实例变量，一个是构造函数参数）之间的歧义。`My­Iterator`
    的大部分代码都引用了没有显式 `this` 的实例变量，但这只是 Java 支持的一种方便的简写 —— 例如，`index` 实际上是 `this.index`。
- en: '**`private`** is used for the object’s internal state and internal helper methods,
    while `public` indicates methods and constructors that are intended for clients
    of the class ([access control](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**`private`** 用于对象的内部状态和内部辅助方法，而 `public` 表示供类的客户端使用的方法和构造函数 ([访问控制](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html))。'
- en: '**`final`** is used to indicate which of the object’s internal variables can
    be reassigned and which can’t. `index` is allowed to change (`next()` updates
    it as it steps through the list), but `list` cannot (the iterator has to keep
    pointing at the same list for its entire life — if you want to iterate through
    another list, you’re expected to create another iterator object).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**`final`** 用于指示对象的哪些内部变量可以重新分配，哪些不能。`index` 允许更改（`next()` 在遍历列表时更新它），但 `list`
    不能（迭代器必须始终指向相同的列表 —— 如果要遍历另一个列表，应该创建另一个迭代器对象）。'
- en: '![](../Images/b425ac1c5aee54fb3b1c903aa52d460a.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b425ac1c5aee54fb3b1c903aa52d460a.jpg)'
- en: 'Here’s a snapshot diagram showing a typical state for a `MyIterator` object
    in action:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示 `MyIterator` 对象在操作中的典型状态的快照图：
- en: Note that we draw the arrow from `list` with a double line, to indicate that
    it’s *final*. That means the arrow can’t change once it’s drawn. But the `ArrayList`
    object it points to is mutable — elements can be changed within it — and declaring
    `list` as final has no effect on that.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们用双线从 `list` 画箭头，表示它是 *final* 的。这意味着一旦画出箭头，它就不能改变。但是它所指向的 `ArrayList` 对象是可变的
    —— 元素可以在其中改变 —— 并且将 `list` 声明为 final 对此没有影响。
- en: Why do iterators exist? There are many kinds of collection data structures (linked
    lists, maps, hash tables) with different kinds of internal representations. The
    iterator concept allows a single uniform way to access them all, so that client
    code is simpler and the collection implementation can change without changing
    the client code that iterates over it. Most modern languages (including Python,
    C#, and Ruby) use the notion of an iterator. It’s an effective **design pattern**
    (a well-tested solution to a common design problem). We’ll see many other design
    patterns as we move through the course.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器为什么存在？有许多种类型的集合数据结构（链表、映射、哈希表）具有不同种类的内部表示。迭代器概念允许以单一统一的方式访问它们，因此客户端代码更简单，集合实现可以更改而不必更改遍历它的客户端代码。大多数现代语言（包括
    Python、C＃和 Ruby）使用迭代器的概念。这是一个有效的 **设计模式**（对常见设计问题的经过测试的解决方案）。随着我们课程的进行，我们会看到许多其他设计模式。
- en: reading exercises
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: MyIterator.next signature
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyIterator.next` 签名'
- en: This example is one of the first we’ve seen that uses *instance methods*. Instance
    methods operate on an instance of a class, take an implicit `this` parameter (like
    the explicit `self` parameter in Python), and can access *instance fields*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是我们见过的第一个使用 *实例方法* 的例子。实例方法在类的实例上操作，带有一个隐式的 `this` 参数（类似于 Python 中的显式 `self`
    参数），并且可以访问 *实例字段*。
- en: 'Let’s examine `MyIterator`’s `next` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `MyIterator` 的 `next` 方法：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Thinking about `next` as an [**operation** as defined in *Static Checking:
    Types*](../01-static-checking/#types)…'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '将 `next` 视为 [*Static Checking: Types* 中定义的 **操作**](../01-static-checking/#types)…'
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: MyIterator.next precondition
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyIterator.next` 前提条件'
- en: '`next` has the precondition `requires: hasNext() returns true.`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 具有前提条件 `requires: hasNext() 返回 true。`'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: When the precondition isn’t satisfied, the implementation is free to do anything.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当前提条件不满足时，实现可以执行任何操作。
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: MyIterator.next postcondition
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyIterator.next` 后置条件'
- en: 'Part of the postcondition of `next` is: `@return next element of the list`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 的后置条件的一部分是：`@return 列表的下一个元素`。'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: 'Another part of the postcondition of `next` is `modifies: this iterator to
    advance it to the element following the returned element.`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`的后置条件的另一部分是`modifies: this iterator to advance it to the element following
    the returned element.`。'
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Mutation undermines an iterator
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突变损害迭代器
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutation_undermines_an_iterator/84x14NBeDm4)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutation_undermines_an_iterator/84x14NBeDm4)'
- en: 'Let’s try using our iterator for a simple job. Suppose we have a list of MIT
    subjects represented as strings, like `["6.005", "8.03", "9.00"]`. We want a method
    `dropCourse6` that will delete the Course 6 subjects from the list, leaving the
    other subjects behind. Following good practices, we first write the spec:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们的迭代器来做一个简单的任务。假设我们有一个表示 MIT 课程的字符串列表，如 `["6.005", "8.03", "9.00"]`。我们希望有一个名为`dropCourse6`的方法，它将从列表中删除课程6，留下其他课程。遵循良好的实践，我们首先编写规范：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that `dropCourse6` has a frame condition (the *modifies* clause) in its
    contract, warning the client that its list argument will be mutated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`dropCourse6`在其合同中有一个框架条件（*modifies*条款），警告客户端其列表参数将被改变。
- en: 'Next, following test-first programming, we devise a testing strategy that partitions
    the input space, and choose test cases to cover that partition:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，遵循测试驱动的编程方式，我们设计一个测试策略，将输入空间划分为分区，并选择测试用例来覆盖该分区：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we implement it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来实现它：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we run our test cases, and they work! … almost. The last test case fails:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行我们的测试用例，它们可以工作了！...几乎。最后一个测试用例失败了：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We got the wrong answer: `dropCourse6` left a course behind in the list! Why?
    Trace through what happens. It will help to use a snapshot diagram showing the
    `MyIterator` object and the `ArrayList` object and update it while you work through
    the code.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了错误的答案：`dropCourse6`在列表中留下了一门课程！为什么？追踪发生了什么。在你分析代码时使用快照图，展示`MyIterator`对象和`ArrayList`对象，并在工作过程中更新它。
- en: reading exercises
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Draw a snapshot diagram
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个快照图
- en: Draw a snapshot diagram to illustrate the bug.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个快照图来说明这个错误。
- en: '*(feel free to use this space and a magic marker)*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '*(随意使用这个空间和一个魔法笔)*'
- en: (missing answer)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失答案)
- en: (missing explanation)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: 'Note that this isn’t just a bug in our `MyIterator`. The built-in iterator
    in `ArrayList` suffers from the same problem, and so does the `for` loop that’s
    syntactic sugar for it. The problem just has a different symptom. If you used
    this code instead:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不仅仅是我们的`MyIterator`中的一个错误。`ArrayList`中的内置迭代器也遇到了同样的问题，`for`循环是它的语法糖。问题只是有不同的症状。如果您使用了这段代码：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: then you’ll get a [`Concurrent­Modification­Exception`](http://docs.oracle.com/javase/8/docs/api/?java/util/ConcurrentModificationException.html).
    The built-in iterator detects that you’re changing the list under its feet, and
    cries foul. (How do you think it does that?)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会得到一个[`Concurrent­Modification­Exception`](http://docs.oracle.com/javase/8/docs/api/?java/util/ConcurrentModificationException.html)。内置迭代器检测到您在其脚下更改列表，并大声疾呼。（你认为它是怎么做到的？）
- en: 'How can you fix this problem? One way is to use the `remove()` method of `Iterator`,
    so that the iterator adjusts its index appropriately:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么解决这个问题？一种方法是使用`Iterator`的`remove()`方法，这样迭代器就会适当地调整其索引：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is actually more efficient as well, it turns out, because `iter.remove()`
    already knows where the element it should remove is, while `subjects.remove()`
    had to search for it again.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这也更有效率，因为`iter.remove()`已经知道应该删除的元素在哪里，而`subjects.remove()`需要重新搜索。
- en: But this doesn’t fix the whole problem. What if there are other `Iterator`s
    currently active over the same list? They won’t all be informed!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这并不能解决整个问题。如果当前有其他`Iterator`在相同的列表上活动呢？它们都不会被通知！
- en: reading exercises
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Pick a snapshot diagram(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个快照图(缺失答案)(缺失答案)(缺失答案)(缺失答案)(缺失答案)
- en: (missing explanation)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (缺失解释)
- en: Mutation and contracts
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突变和契约
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutation_and_contracts/uiw04Cl6DxM)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutation_and_contracts/uiw04Cl6DxM)'
- en: Mutable objects can make simple contracts very complex
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变对象可能使简单的合同变得非常复杂
- en: This is a fundamental issue with mutable data structures. Multiple references
    to the same mutable object (also called **aliases** for the object) may mean that
    multiple places in your program — possibly widely separated — are relying on that
    object to remain consistent.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可变数据结构的一个基本问题。对同一可变对象的多个引用（也称为对象的**别名**）可能意味着程序中的多个地方——可能相距很远——都依赖于该对象保持一致。
- en: To put it in terms of specifications, contracts can’t be enforced in just one
    place anymore, e.g. between the client of a class and the implementer of a class.
    Contracts involving mutable objects now depend on the good behavior of everyone
    who has a reference to the mutable object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以规范的术语来说，契约不能再仅仅在一个地方强制执行了，例如在类的客户端和类的实现者之间。涉及可变对象的契约现在取决于每个持有对可变对象引用的人的良好行为。
- en: As a symptom of this non-local contract phenomenon, consider the Java collections
    classes, which are normally documented with very clear contracts on the client
    and implementer of a class. Try to find where it documents the crucial requirement
    on the client that we’ve just discovered — that you can’t modify a collection
    while you’re iterating over it. Who takes responsibility for it? [`Iterator`](http://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html)?
    [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)? [`Collection`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collection.html)?
    Can you find it?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种非本地契约现象的一种症状，考虑一下Java集合类，这些类通常在类的客户端和实现者之间具有非常明确的契约。试图找到它在哪里记录了我们刚刚发现的关键要求——在迭代集合时不能修改集合。谁负责？[`Iterator`](http://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html)？[`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)？[`Collection`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collection.html)？你能找到吗？
- en: The need to reason about global properties like this make it much harder to
    understand, and be confident in the correctness of, programs with mutable data
    structures. We still have to do it — for performance and convenience — but we
    pay a big cost in bug safety for doing so.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要推理全局属性像这样使得理解和对可变数据结构的程序的正确性更加困难和自信。我们仍然必须这样做——为了性能和方便——但我们为此付出了巨大的bug安全成本。
- en: Mutable objects reduce changeability
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变对象减少了可变性
- en: Mutable objects make the contracts between clients and implementers more complicated,
    and reduce the freedom of the client and implementer to change. In other words,
    using *objects* that are allowed to change makes the *code* harder to change.
    Here’s an example to illustrate the point.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象使客户端和实现者之间的契约变得更加复杂，并减少了客户端和实现者的自由变动。换句话说，使用允许更改的*对象*使*代码*更难更改。下面是一个例子来说明这一点。
- en: 'The crux of our example will be the specification for this method, which looks
    up a username in MIT’s database and returns the user’s 9-digit identifier:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例的关键将是该方法的规范，该方法查找MIT数据库中的用户名并返回用户的9位标识符：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A reasonable specification. Now suppose we have a client using this method
    to print out a user’s identifier:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合理的规范。现在假设我们有一个客户端使用此方法来打印用户的标识符：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Now both the client and the implementor separately decide to make a change.**
    The client is worried about the user’s privacy, and decides to obscure the first
    5 digits of the id:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在客户端和实现者分别决定进行更改。** 客户端担心用户的隐私，决定遮蔽id的前5位：'
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementer is worried about the speed and load on the database, so the
    implementer introduces a cache that remembers usernames that have been looked
    up:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 实现者担心数据库的速度和负载，所以引入了一个记住已查找过的用户名的缓存：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These two changes have created a subtle bug. When the client looks up `"bitdiddle"`
    and gets back a char array, now both the client and the implementer’s cache are
    pointing to the *same* char array. The array is aliased. That means that the client’s
    obscuring code is actually overwriting the identifier in the cache, so future
    calls to `getMidId("bitdiddle")` will not return the full 9-digit number, like
    “928432033”, but instead the obscured version “*****2033”.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变化引入了一个微妙的错误。当客户端查找`"bitdiddle"`并返回一个字符数组时，现在客户端和实现者的缓存都指向*相同的*字符数组。该数组是别名。这意味着客户端的遮蔽代码实际上正在覆盖缓存中的标识符，因此对`getMidId("bitdiddle")`的未来调用将不会返回完整的9位数，例如“928432033”，而是遮蔽版本“*****2033”。
- en: '**Sharing a mutable object complicates a contract**. If this contract failure
    went to software engineering court, it would be contentious. Who’s to blame here?
    Was the client obliged not to modify the object it got back? Was the implementer
    obliged not to hold on to the object that it returned?'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享可变对象会使合同复杂化**。如果这个合同的失败上升到软件工程法庭，将会引发争议。谁在这里应该负责？客户是否有义务不修改返回的对象？实现者是否有义务不保留返回的对象？'
- en: 'Here’s one way we could have clarified the spec:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以澄清规范的一种方式：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**This is a bad way to do it**. The problem with this approach is that it means
    the contract has to be in force for the entire rest of the program. It’s a lifetime
    contract! The other contracts we wrote were much narrower in scope; you could
    think about the precondition just before the call was made, and the postcondition
    just after, and you didn’t have to reason about what would happen for the rest
    of time.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**这是一个不好的做法**。这种方法的问题在于，这意味着合同必须在整个程序的剩余生命周期内有效。这是一个终身合同！我们编写的其他合同范围更窄；你可以在调用之前仔细考虑前置条件，调用之后仔细考虑后置条件，而不必考虑将来的一切会发生什么。'
- en: 'Here’s a spec with a similar problem:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个类似问题的规范：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**This doesn’t entirely fix the problem either**. This spec at least says that
    the array has to be fresh. But does it keep the implementer from holding an alias
    to that new array? Does it keep the implementer from changing that array or reusing
    it in the future for something else?'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**这也并不能完全解决问题**。这个规范至少说数组必须是新的。但这能阻止实现者保留对该新数组的别名吗？它能阻止实现者改变该数组或将其来用于将来的其他用途吗？'
- en: 'Here’s a much better spec:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个更好的规范：
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The immutable String return value provides a *guarantee* that the client and
    the implementer will never step on each other the way they could with char arrays.
    It doesn’t depend on a programmer reading the spec comment carefully. String is
    *immutable*. Not only that, but this approach (unlike the previous one) gives
    the implementer the freedom to introduce a cache — a performance improvement.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变的 String 返回值提供了一个*保证*，即客户和实现者不会像使用 char 数组那样相互干扰。它不依赖于程序员仔细阅读规范注释。String
    是*不可变的*。不仅如此，这种方法（与之前的方法不同）还赋予了实现者引入缓存的自由——一种性能改进。
- en: Useful immutable types
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的不可变类型
- en: 'Since immutable types avoid so many pitfalls, let’s enumerate some commonly-used
    immutable types in the Java API:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可变类型避免了许多陷阱，让我们列举一些在 Java API 中常用的不可变类型：
- en: The primitive types and primitive wrappers are all immutable. If you need to
    compute with large numbers, [`BigInteger`](http://docs.oracle.com/javase/8/docs/api/?java/math/BigInteger.html)
    and [`BigDecimal`](http://docs.oracle.com/javase/8/docs/api/?java/math/BigDecimal.html)
    are immutable.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型和原始包装类型都是不可变的。如果需要处理大数，[`BigInteger`](http://docs.oracle.com/javase/8/docs/api/?java/math/BigInteger.html)
    和 [`BigDecimal`](http://docs.oracle.com/javase/8/docs/api/?java/math/BigDecimal.html)
    是不可变的。
- en: Don’t use mutable `Date`s, use the appropriate immutable type from [`java.time`](http://docs.oracle.com/javase/8/docs/api/index.html?java/time/package-summary.html)
    based on the granularity of timekeeping you need.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用可变的 `Date`，而是根据您需要的时间粒度使用 [`java.time`](http://docs.oracle.com/javase/8/docs/api/index.html?java/time/package-summary.html)
    中的适当不可变类型。
- en: 'The usual implementations of Java’s collections types — `List`, `Set`, `Map`
    — are all mutable: `ArrayList`, `HashMap`, etc. The [`Collections`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html)
    utility class has methods for obtaining *unmodifiable views* of these mutable
    collections:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 集合类型的通常实现——`List`、`Set`、`Map`——都是可变的：`ArrayList`、`HashMap` 等。[`Collections`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html)
    实用类有用于获取这些可变集合的*不可修改视图*的方法：
- en: '[`Collections.unmodifiableList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Collections.unmodifiableList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)'
- en: '[`Collections.unmodifiableSet`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableSet-java.util.Set-)'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Collections.unmodifiableSet`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableSet-java.util.Set-)'
- en: '[`Collections.unmodifiableMap`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableMap-java.util.Map-)'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Collections.unmodifiableMap`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableMap-java.util.Map-)'
- en: You can think of the unmodifiable view as a wrapper around the underlying list/set/map.
    A client who has a reference to the wrapper and tries to perform mutations — `add`,
    `remove`, `put`, etc. — will trigger an [`Unsupported­Operation­Exception`](http://docs.oracle.com/javase/8/docs/api/?java/lang/UnsupportedOperationException.html).
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以将不可修改的视图视为封装在底层列表/集合/映射周围的包装器。拥有对该包装器的引用并尝试执行突变操作 —— `add`、`remove`、`put`等
    —— 将触发一个[`Unsupported­Operation­Exception`](http://docs.oracle.com/javase/8/docs/api/?java/lang/UnsupportedOperationException.html)。
- en: Before we pass a mutable collection to another part of our program, we can wrap
    it in an unmodifiable wrapper. We should be careful at that point to forget our
    reference to the mutable collection, lest we accidentally mutate it. (One way
    to do that is to let it go out of scope.) Just as a mutable object behind a `final`
    reference can be mutated, the mutable collection inside an unmodifiable wrapper
    can still be modified by someone with a reference to it, defeating the wrapper.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在将可变集合传递给程序的另一部分之前，我们可以将其包装在不可修改的包装器中。在那一点上，我们应该小心地忘记对可变集合的引用，以免意外突变它。（一个方法是让它超出作用域。）就像一个`final`引用后面的可变对象一样可以被突变一样，不可修改包装器中的可变集合仍然可以被拥有对其的引用的人修改，从而破坏包装器。
- en: '`Collections` also provides methods for obtaining immutable empty collections:
    [`Collections.emptyList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--),
    etc. Nothing’s worse than discovering your *definitely very empty* list is suddenly
    *definitely not empty*!'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collections`还提供了获取不可变空集合的方法：[`Collections.emptyList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--)，等等。最糟糕的是发现您*绝对是空的*列表突然变得*绝对不是空的*！'
- en: reading exercises
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Immutability(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
- en: (missing explanation)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: (missing explanation)
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this reading, we saw that mutability is useful for performance and convenience,
    but it also creates risks of bugs by requiring the code that uses the objects
    to be well-behaved on a global level, greatly complicating the reasoning and testing
    we have to do to be confident in its correctness.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本阅读中，我们看到可变性对性能和方便是有用的，但它也通过要求使用对象的代码在全局层面上表现良好而产生了bug的风险，这极大地复杂化了我们需要进行的推理和测试，以确保其正确性。
- en: Make sure you understand the difference between an immutable *object* (like
    a `String`) and an immutable *reference* (like a `final` variable). Snapshot diagrams
    can help with this understanding. Objects are values, represented by circles in
    a snapshot diagram, and an immutable one has a double border indicating that it
    never changes its value. A reference is a pointer to an object, represented by
    an arrow in the snapshot diagram, and an immutable reference is an arrow with
    a double line, indicating that the arrow can’t be moved to point to a different
    object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你理解不可变*对象*（如`String`）和不可变*引用*（如`final`变量）之间的区别。快照图可以帮助理解这一点。对象是值，用快照图中的圆圈表示，不可变对象具有双重边框，表示它永远不会改变其值。引用是指向对象的指针，用快照图中的箭头表示，不可变引用是一条带有双线的箭头，表示该箭头不能移动指向不同的对象。
- en: 'The key design principle here is **immutability**: using immutable objects
    and immutable references as much as possible. Let’s review how immutability helps
    with the main goals of this course:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键设计原则是**不可变性**：尽可能使用不可变对象和不可变引用。让我们回顾一下不可变性如何帮助达到本课程的主要目标：
- en: '**Safe from bugs**. Immutable objects aren’t susceptible to bugs caused by
    aliasing. Immutable references always point to the same object.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免于bug**。不可变对象不容易受到别名的影响而产生bug。不可变引用始终指向相同的对象。'
- en: '**Easy to understand**. Because an immutable object or reference always means
    the same thing, it’s simpler for a reader of the code to reason about — they don’t
    have to trace through all the code to find all the places where the object or
    reference might be changed, because it can’t be changed.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**。因为不可变对象或引用始终意味着相同的事物，所以对于代码的读者来说更容易推理 —— 他们不必追踪所有代码以找到对象或引用可能被更改的所有位置，因为它无法更改。'
- en: '**Ready for change**. If an object or reference can’t be changed at runtime,
    then code that depends on that object or reference won’t have to be revised when
    the program changes.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为变化做好准备**。如果一个对象或引用在运行时不能被更改，那么依赖于该对象或引用的代码在程序更改时就不必进行修订。'
