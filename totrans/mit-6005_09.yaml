- en: 'Reading 9: Mutability & Immutability'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software in 6.005
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '| Safe from bugs | Easy to understand | Ready for change |'
  prefs: []
  type: TYPE_TB
- en: '| Correct today and correct in the unknown future. | Communicating clearly
    with future programmers, including future you. | Designed to accommodate change
    without rewriting. |'
  prefs: []
  type: TYPE_TB
- en: Objectives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Understand mutability and mutable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify aliasing and understand the dangers of mutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use immutability to improve correctness, clarity, & changeability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutability/Knxg2PP7BRU)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from [*Basic Java* when we discussed snapshot diagrams](../02-basic-java/#snapshot_diagrams)
    that some objects are *immutable*: once created, they always represent the same
    value. Other objects are *mutable*: they have methods that change the value of
    the object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`String`](http://docs.oracle.com/javase/8/docs/api/?java/lang/String.html)
    is an example of an immutable type. A `String` object always represents the same
    string. [`StringBuilder`](http://docs.oracle.com/javase/8/docs/api/?java/lang/StringBuilder.html)
    is an example of a mutable type. It has methods to delete parts of the string,
    insert or replace characters, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '![reassigning a variable](../Images/ded61b67bfe27877e4bb9fa6f2fd07a9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since `String` is immutable, once created, a `String` object always has the
    same value. To add something to the end of a String, you have to create a new
    String object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![mutating an object](../Images/1c6923d6a53006c05c2e0d3c8cfd35c5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By contrast, `StringBuilder` objects are mutable. This class has methods that
    change the value of the object, rather than just returning new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`StringBuilder` has other methods as well, for deleting parts of the string,
    inserting in the middle, or changing individual characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what? In both cases, you end up with `s` and `sb` referring to the string
    of characters `"ab"`. The difference between mutability and immutability doesn’t
    matter much when there’s only one reference to the object. But there are big differences
    in how they behave when there are *other* references to the object. For example,
    when another variable `t` points to the same String object as `s`, and another
    variable `tb` points to the same StringBuilder as `sb`, then the differences between
    the immutable and mutable objects become more evident:'
  prefs: []
  type: TYPE_NORMAL
- en: '![different behavior of String and StringBuilder](../Images/f4006e707b06ed2882bb54298a40999c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This shows that changing `t` had no effect on `s`, but changing `tb` affected
    `sb` too — possibly to the surprise of the programmer. That’s the essence of the
    problem we’re going to look at in this reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have the immutable `String` class already, why do we even need the
    mutable `StringBuilder` in programming? A common use for it is to concatenate
    a large number of strings together. Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using immutable strings, this makes a lot of temporary copies — the first number
    of the string (`"0"`) is actually copied *n* times in the course of building up
    the final string, the second number is copied *n-1* times, and so on. It actually
    costs *O(n²)* time just to do all that copying, even though we only concatenated
    *n* elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`StringBuilder` is designed to minimize this copying. It uses a simple but
    clever internal data structure to avoid doing any copying at all until the very
    end, when you ask for the final `String` with a `toString()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting good performance is one reason why we use mutable objects. Another
    is convenient sharing: two parts of your program can communicate more conveniently
    by sharing a common mutable data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Follow me
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/56525f335edebebf0c97a8f974cac834.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Choose the best answer.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Risks of mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,risks_of_mutation/UWpF9C77e3U)'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable types seem much more powerful than immutable types. If you were shopping
    in the Datatype Supermarket, and you had to choose between a boring immutable
    `String` and a super-powerful-do-anything mutable `StringBuilder`, why on earth
    would you choose the immutable one? `StringBuilder` should be able to do everything
    that `String` can do, plus `set()` and `append()` and everything else.
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that **immutable types are safer from bugs, easier to understand,
    and more ready for change**. Mutability makes it harder to understand what your
    program is doing, and much harder to enforce contracts. Here are two examples
    that illustrate why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Risky example #1: passing mutable values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with a simple method that sums the integers in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we also need a method that sums the absolute values. Following good
    DRY practice ([Don’t Repeat Yourself](http://en.wikipedia.org/wiki/Don''t_repeat_yourself)),
    the implementer writes a method that uses `sum()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this method does its job by **mutating the list directly**. It
    seemed sensible to the implementer, because it’s more efficient to reuse the existing
    list. If the list is millions of items long, then you’re saving the time and memory
    of generating a new million-item list of absolute values. So the implementer has
    two very good reasons for this design: DRY, and performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the resulting behavior will be very surprising to anybody who uses it!
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What will this code print? Will it be 10 followed by -10? Or something else?
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Risky #1(missing answer)(missing answer)'
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s think about the key points here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs?** In this example, it’s easy to blame the implementer of
    `sum­Absolute()` for going beyond what its spec allowed. But really, **passing
    mutable objects around is a latent bug**. It’s just waiting for some programmer
    to inadvertently mutate that list, often with very good intentions like reuse
    or performance, but resulting in a bug that may be very hard to track down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand?** When reading `main()`, what would you assume about
    `sum()` and `sum­Absolute()`? Is it clearly visible to the reader that `myData`
    gets *changed* by one of them?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Risky example #2: returning mutable values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,risks_of_mutation,risky_example_2_returning_mutable_values/DBshg8se4Jc)'
  prefs: []
  type: TYPE_NORMAL
- en: We just saw an example where passing a mutable object to a function caused problems.
    What about returning a mutable object?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider [`Date`](http://docs.oracle.com/javase/8/docs/api/?java/util/Date.html),
    one of the built-in Java classes. `Date` happens to be a mutable type. Suppose
    we write a method that determines the first day of spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we’re using the well-known Groundhog algorithm for calculating when spring
    starts (Harold Ramis, Bill Murray, et al. *Groundhog Day*, 1993).
  prefs: []
  type: TYPE_NORMAL
- en: 'Clients start using this method, for example to plan their big parties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All the code works and people are happy. Now, independently, two things happen.
    First, the implementer of `startOfSpring()` realizes that the groundhog is starting
    to get annoyed from being constantly asked when spring will start. So the code
    is rewritten to ask the groundhog at most once, and then cache the groundhog’s
    answer for future calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '(Aside: note the use of a private static variable for the cached answer. Would
    you consider this a global variable, or not?)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, one of the clients of `startOfSpring()` decides that the actual first
    day of spring is too cold for the party, so the party will be exactly a month
    later instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '(Aside: this code also has a latent bug in the way it adds a month. Why? What
    does it implicitly assume about when spring starts?)'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when these two decisions interact? Even worse, think about who
    will first discover this bug — will it be `startOfSpring()`? Will it be `partyPlanning()`?
    Or will it be some completely innocent third piece of code that also calls `startOfSpring()`?
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Risky #2'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t know how `Date` stores the month, so we’ll represent that with the
    abstract values `...march...` and `...april...` in an imagined `month` field of
    `Date`.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding risky example #2'
  prefs: []
  type: TYPE_NORMAL
- en: '`partyPlanning` has unwittingly changed the start of spring, because `partyDate`
    and `groundhogAnswer` happen to point to the same mutable `Date` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Worse, this bug will probably *not* be discovered in `partyPlanning()` or `startOfSpring()`
    right away. Instead, it will be some innocent piece of code that subsequently
    calls `startOfSpring()`, gets the wrong date back, and goes on to compute its
    own wrong answer.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: A second bug
  prefs: []
  type: TYPE_NORMAL
- en: The code has another potential bug in how it adds to the month.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the Java API documentation for `Date.setMonth`.
  prefs: []
  type: TYPE_NORMAL
- en: <select class="form-control"><option>0</option>,<option>1</option>,<option>2</option>,<option>3</option>,<option>4</option>,<option>5</option>,<option>6</option>,<option>7</option>,<option>8</option>,<option>9</option>,<option>10</option>,<option>11</option>,<option>12</option></select>(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: NoSuchMonthException
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation for `Date.setMonth` says `month: the month value between
    0-11`.'
  prefs: []
  type: TYPE_NORMAL
- en: Based on that statement and just what you’ve read so far…
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: SuchTerribleSpecificationsException
  prefs: []
  type: TYPE_NORMAL
- en: 'Elsewhere in the documentation for `Date`, it says: “arguments given to methods
    […] need not fall within the indicated ranges; for example, a date may be specified
    as January 32 and is interpreted as meaning February 1”.'
  prefs: []
  type: TYPE_NORMAL
- en: What looks like a precondition… isn’t!
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Key points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs?** Again we had a latent bug that reared its ugly head.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change?** Obviously the mutation of the date object is a change,
    but that’s not the kind of change we’re talking about when we say “ready for change.”
    Instead, the question is whether the code of the program can be easily changed
    without rewriting a lot of it or introducing bugs. Here we had two apparently
    independent changes, by different programmers, that interacted to produce a bad
    bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both of these examples — the `List<Integer>` and the `Date` — the problems
    would have been completely avoided if the list and the date had been immutable
    types. The bugs would have been impossible by design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, you should never use `Date`! Use one of the classes from [package
    `java.time`](http://docs.oracle.com/javase/8/docs/api/index.html?java/time/package-summary.html):
    [`LocalDateTime`](http://docs.oracle.com/javase/8/docs/api/?java/time/LocalDateTime.html),
    [`Instant`](http://docs.oracle.com/javase/8/docs/api/?java/time/Instant.html),
    etc. All guarantee in their specifications that they are *immutable*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example also illustrates why using mutable objects can actually be *bad*
    for performance. The simplest solution to this bug, which avoids changing any
    of the specifications or method signatures, is for `startOfSpring()` to always
    return a *copy* of the groundhog’s answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is **defensive copying**, and we’ll see much more of it when we
    talk about abstract data types. The defensive copy means `partyPlanning()` can
    freely stomp all over the returned date without affecting `startOfSpring()`’s
    cached date. But defensive copying forces `startOfSpring()` to do extra work and
    use extra space for *every client* — even if 99% of the clients never mutate the
    date it returns. We may end up with lots of copies of the first day of spring
    throughout memory. If we used an immutable type instead, then different parts
    of the program could safely share the same values in memory, so less copying and
    less memory space is required. Immutability can be more efficient than mutability,
    because immutable types never need to be defensively copied.
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing is what makes mutable types risky
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,aliasing_is_what_makes_mutable_types_risky/vjn4owb1HPI)'
  prefs: []
  type: TYPE_NORMAL
- en: Actually, using mutable objects is just fine if you are using them entirely
    locally within a method, and with only one reference to the object. What led to
    the problem in the two examples we just looked at was having multiple references,
    also called **aliases**, for the same mutable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Walking through the examples with a snapshot diagram will make this clear,
    but here’s the outline:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `List` example, the same list is pointed to by both `list` (in `sum`
    and `sumAbsolute`) and `myData` (in `main`). One programmer (`sumAbsolute`’s)
    thinks it’s ok to modify the list; another programmer (`main`’s) wants the list
    to stay the same. Because of the aliases, `main`’s programmer loses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Date` example, there are two variable names that point to the `Date`
    object, `groundhogAnswer` and `partyDate`. These aliases are in completely different
    parts of the code, under the control of different programmers who may have no
    idea what the other is doing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw snapshot diagrams on paper first, but your real goal should be to develop
    the snapshot diagram in your head, so you can visualize what’s happening in the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Specifications for mutating methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point it should be clear that when a method performs mutation, it is
    crucial to include that mutation in the method’s spec, using [the structure we
    discussed in the previous reading](../06-specifications/specs/#specifications_for_mutating_methods).
  prefs: []
  type: TYPE_NORMAL
- en: (Now we’ve seen that even when a particular method *doesn’t* mutate an object,
    that object’s mutability can still be a source of bugs.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a mutating method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And an example of a method that does not mutate its argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the *effects* do not explicitly say that an input can be mutated, then in
    6.005 we assume mutation of the input is implicitly disallowed. Virtually all
    programmers would assume the same thing. Surprise mutations lead to terrible bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over arrays and lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,iterating_over_arrays_and_lists/zTjUFSIZFhc)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next mutable object we’re going to look at is an **iterator** — an object
    that steps through a collection of elements and returns the elements one by one.
    Iterators are used under the covers in Java when you’re using a [`for (... : ...)`
    loop](../02-basic-java/#iteration) to step through a `List` or array. This code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'is rewritten by the compiler into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An iterator has two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next()` returns the next element in the collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasNext()` tests whether the iterator has reached the end of the collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the `next()` method is a **mutator** method, not only returning an
    element but also advancing the iterator so that the subsequent call to `next()`
    will return a different element.
  prefs: []
  type: TYPE_NORMAL
- en: You can also look at the [Java API definition of `Iterator`](http://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go any further:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should already have read: **[Classes and Objects](http://docs.oracle.com/javase/tutorial/java/javaOO/index.html)**
    in the Java Tutorials.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read: **[the `final` keyword](http://www.codeguru.com/java/tij/tij0071.shtml)**
    on CodeGuru.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MyIterator`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To better understand how an iterator works, here’s a simple implementation
    of an iterator for `ArrayList<String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`MyIterator` makes use of a few Java language features that are different from
    the classes we’ve been writing up to this point. Make sure you’ve read the linked
    Java Tutorial sections so that you understand them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Instance variables**](http://docs.oracle.com/javase/tutorial/java/javaOO/variables.html),
    also called fields in Java. Instance variables differ from method parameters and
    local variables; the instance variables are stored in the object instance and
    persist for longer than a method call. What are the instance variables of `My­Iterator`?'
  prefs: []
  type: TYPE_NORMAL
- en: A [**constructor**](http://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html),
    which makes a new object instance and initializes its instance variables. Where
    is the constructor of `My­Iterator`?
  prefs: []
  type: TYPE_NORMAL
- en: The `static` keyword is missing from `My­Iterator`’s methods, which means they
    are [**instance methods**](http://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)
    that must be called on an instance of the object, e.g. `iter.next()`.
  prefs: []
  type: TYPE_NORMAL
- en: The [**`this` keyword**](http://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html)
    is used at one point to refer to the **instance object**, in particular to refer
    to an instance variable (`this.list`). This was done to disambiguate two different
    variables named `list` (an instance variable and a constructor parameter). Most
    of `My­Iterator`’s code refers to instance variables without an explicit `this`,
    but this is just a convenient shorthand that Java supports — e.g., `index` actually
    means `this.index`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`private`** is used for the object’s internal state and internal helper methods,
    while `public` indicates methods and constructors that are intended for clients
    of the class ([access control](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**`final`** is used to indicate which of the object’s internal variables can
    be reassigned and which can’t. `index` is allowed to change (`next()` updates
    it as it steps through the list), but `list` cannot (the iterator has to keep
    pointing at the same list for its entire life — if you want to iterate through
    another list, you’re expected to create another iterator object).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b425ac1c5aee54fb3b1c903aa52d460a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s a snapshot diagram showing a typical state for a `MyIterator` object
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we draw the arrow from `list` with a double line, to indicate that
    it’s *final*. That means the arrow can’t change once it’s drawn. But the `ArrayList`
    object it points to is mutable — elements can be changed within it — and declaring
    `list` as final has no effect on that.
  prefs: []
  type: TYPE_NORMAL
- en: Why do iterators exist? There are many kinds of collection data structures (linked
    lists, maps, hash tables) with different kinds of internal representations. The
    iterator concept allows a single uniform way to access them all, so that client
    code is simpler and the collection implementation can change without changing
    the client code that iterates over it. Most modern languages (including Python,
    C#, and Ruby) use the notion of an iterator. It’s an effective **design pattern**
    (a well-tested solution to a common design problem). We’ll see many other design
    patterns as we move through the course.
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MyIterator.next signature
  prefs: []
  type: TYPE_NORMAL
- en: This example is one of the first we’ve seen that uses *instance methods*. Instance
    methods operate on an instance of a class, take an implicit `this` parameter (like
    the explicit `self` parameter in Python), and can access *instance fields*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine `MyIterator`’s `next` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Thinking about `next` as an [**operation** as defined in *Static Checking:
    Types*](../01-static-checking/#types)…'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: MyIterator.next precondition
  prefs: []
  type: TYPE_NORMAL
- en: '`next` has the precondition `requires: hasNext() returns true.`'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: When the precondition isn’t satisfied, the implementation is free to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: MyIterator.next postcondition
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of the postcondition of `next` is: `@return next element of the list`.'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Another part of the postcondition of `next` is `modifies: this iterator to
    advance it to the element following the returned element.`'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)(missing answer)(missing answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Mutation undermines an iterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutation_undermines_an_iterator/84x14NBeDm4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try using our iterator for a simple job. Suppose we have a list of MIT
    subjects represented as strings, like `["6.005", "8.03", "9.00"]`. We want a method
    `dropCourse6` that will delete the Course 6 subjects from the list, leaving the
    other subjects behind. Following good practices, we first write the spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that `dropCourse6` has a frame condition (the *modifies* clause) in its
    contract, warning the client that its list argument will be mutated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, following test-first programming, we devise a testing strategy that partitions
    the input space, and choose test cases to cover that partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we run our test cases, and they work! … almost. The last test case fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We got the wrong answer: `dropCourse6` left a course behind in the list! Why?
    Trace through what happens. It will help to use a snapshot diagram showing the
    `MyIterator` object and the `ArrayList` object and update it while you work through
    the code.'
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Draw a snapshot diagram
  prefs: []
  type: TYPE_NORMAL
- en: Draw a snapshot diagram to illustrate the bug.
  prefs: []
  type: TYPE_NORMAL
- en: '*(feel free to use this space and a magic marker)*'
  prefs: []
  type: TYPE_NORMAL
- en: (missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this isn’t just a bug in our `MyIterator`. The built-in iterator
    in `ArrayList` suffers from the same problem, and so does the `for` loop that’s
    syntactic sugar for it. The problem just has a different symptom. If you used
    this code instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: then you’ll get a [`Concurrent­Modification­Exception`](http://docs.oracle.com/javase/8/docs/api/?java/util/ConcurrentModificationException.html).
    The built-in iterator detects that you’re changing the list under its feet, and
    cries foul. (How do you think it does that?)
  prefs: []
  type: TYPE_NORMAL
- en: 'How can you fix this problem? One way is to use the `remove()` method of `Iterator`,
    so that the iterator adjusts its index appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is actually more efficient as well, it turns out, because `iter.remove()`
    already knows where the element it should remove is, while `subjects.remove()`
    had to search for it again.
  prefs: []
  type: TYPE_NORMAL
- en: But this doesn’t fix the whole problem. What if there are other `Iterator`s
    currently active over the same list? They won’t all be informed!
  prefs: []
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pick a snapshot diagram(missing answer)(missing answer)(missing answer)(missing
    answer)(missing answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Mutation and contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_9_mutability_immutability,mutation_and_contracts/uiw04Cl6DxM)'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable objects can make simple contracts very complex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a fundamental issue with mutable data structures. Multiple references
    to the same mutable object (also called **aliases** for the object) may mean that
    multiple places in your program — possibly widely separated — are relying on that
    object to remain consistent.
  prefs: []
  type: TYPE_NORMAL
- en: To put it in terms of specifications, contracts can’t be enforced in just one
    place anymore, e.g. between the client of a class and the implementer of a class.
    Contracts involving mutable objects now depend on the good behavior of everyone
    who has a reference to the mutable object.
  prefs: []
  type: TYPE_NORMAL
- en: As a symptom of this non-local contract phenomenon, consider the Java collections
    classes, which are normally documented with very clear contracts on the client
    and implementer of a class. Try to find where it documents the crucial requirement
    on the client that we’ve just discovered — that you can’t modify a collection
    while you’re iterating over it. Who takes responsibility for it? [`Iterator`](http://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html)?
    [`List`](http://docs.oracle.com/javase/8/docs/api/?java/util/List.html)? [`Collection`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collection.html)?
    Can you find it?
  prefs: []
  type: TYPE_NORMAL
- en: The need to reason about global properties like this make it much harder to
    understand, and be confident in the correctness of, programs with mutable data
    structures. We still have to do it — for performance and convenience — but we
    pay a big cost in bug safety for doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable objects reduce changeability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mutable objects make the contracts between clients and implementers more complicated,
    and reduce the freedom of the client and implementer to change. In other words,
    using *objects* that are allowed to change makes the *code* harder to change.
    Here’s an example to illustrate the point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The crux of our example will be the specification for this method, which looks
    up a username in MIT’s database and returns the user’s 9-digit identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A reasonable specification. Now suppose we have a client using this method
    to print out a user’s identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**Now both the client and the implementor separately decide to make a change.**
    The client is worried about the user’s privacy, and decides to obscure the first
    5 digits of the id:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementer is worried about the speed and load on the database, so the
    implementer introduces a cache that remembers usernames that have been looked
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: These two changes have created a subtle bug. When the client looks up `"bitdiddle"`
    and gets back a char array, now both the client and the implementer’s cache are
    pointing to the *same* char array. The array is aliased. That means that the client’s
    obscuring code is actually overwriting the identifier in the cache, so future
    calls to `getMidId("bitdiddle")` will not return the full 9-digit number, like
    “928432033”, but instead the obscured version “*****2033”.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sharing a mutable object complicates a contract**. If this contract failure
    went to software engineering court, it would be contentious. Who’s to blame here?
    Was the client obliged not to modify the object it got back? Was the implementer
    obliged not to hold on to the object that it returned?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one way we could have clarified the spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '**This is a bad way to do it**. The problem with this approach is that it means
    the contract has to be in force for the entire rest of the program. It’s a lifetime
    contract! The other contracts we wrote were much narrower in scope; you could
    think about the precondition just before the call was made, and the postcondition
    just after, and you didn’t have to reason about what would happen for the rest
    of time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a spec with a similar problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**This doesn’t entirely fix the problem either**. This spec at least says that
    the array has to be fresh. But does it keep the implementer from holding an alias
    to that new array? Does it keep the implementer from changing that array or reusing
    it in the future for something else?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a much better spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The immutable String return value provides a *guarantee* that the client and
    the implementer will never step on each other the way they could with char arrays.
    It doesn’t depend on a programmer reading the spec comment carefully. String is
    *immutable*. Not only that, but this approach (unlike the previous one) gives
    the implementer the freedom to introduce a cache — a performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Useful immutable types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since immutable types avoid so many pitfalls, let’s enumerate some commonly-used
    immutable types in the Java API:'
  prefs: []
  type: TYPE_NORMAL
- en: The primitive types and primitive wrappers are all immutable. If you need to
    compute with large numbers, [`BigInteger`](http://docs.oracle.com/javase/8/docs/api/?java/math/BigInteger.html)
    and [`BigDecimal`](http://docs.oracle.com/javase/8/docs/api/?java/math/BigDecimal.html)
    are immutable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use mutable `Date`s, use the appropriate immutable type from [`java.time`](http://docs.oracle.com/javase/8/docs/api/index.html?java/time/package-summary.html)
    based on the granularity of timekeeping you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The usual implementations of Java’s collections types — `List`, `Set`, `Map`
    — are all mutable: `ArrayList`, `HashMap`, etc. The [`Collections`](http://docs.oracle.com/javase/8/docs/api/?java/util/Collections.html)
    utility class has methods for obtaining *unmodifiable views* of these mutable
    collections:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Collections.unmodifiableList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Collections.unmodifiableSet`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableSet-java.util.Set-)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Collections.unmodifiableMap`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableMap-java.util.Map-)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can think of the unmodifiable view as a wrapper around the underlying list/set/map.
    A client who has a reference to the wrapper and tries to perform mutations — `add`,
    `remove`, `put`, etc. — will trigger an [`Unsupported­Operation­Exception`](http://docs.oracle.com/javase/8/docs/api/?java/lang/UnsupportedOperationException.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before we pass a mutable collection to another part of our program, we can wrap
    it in an unmodifiable wrapper. We should be careful at that point to forget our
    reference to the mutable collection, lest we accidentally mutate it. (One way
    to do that is to let it go out of scope.) Just as a mutable object behind a `final`
    reference can be mutated, the mutable collection inside an unmodifiable wrapper
    can still be modified by someone with a reference to it, defeating the wrapper.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Collections` also provides methods for obtaining immutable empty collections:
    [`Collections.emptyList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#emptyList--),
    etc. Nothing’s worse than discovering your *definitely very empty* list is suddenly
    *definitely not empty*!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reading exercises
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Immutability(missing answer)(missing answer)(missing answer)(missing answer)(missing
    answer)
  prefs: []
  type: TYPE_NORMAL
- en: (missing explanation)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this reading, we saw that mutability is useful for performance and convenience,
    but it also creates risks of bugs by requiring the code that uses the objects
    to be well-behaved on a global level, greatly complicating the reasoning and testing
    we have to do to be confident in its correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you understand the difference between an immutable *object* (like
    a `String`) and an immutable *reference* (like a `final` variable). Snapshot diagrams
    can help with this understanding. Objects are values, represented by circles in
    a snapshot diagram, and an immutable one has a double border indicating that it
    never changes its value. A reference is a pointer to an object, represented by
    an arrow in the snapshot diagram, and an immutable reference is an arrow with
    a double line, indicating that the arrow can’t be moved to point to a different
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key design principle here is **immutability**: using immutable objects
    and immutable references as much as possible. Let’s review how immutability helps
    with the main goals of this course:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe from bugs**. Immutable objects aren’t susceptible to bugs caused by
    aliasing. Immutable references always point to the same object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to understand**. Because an immutable object or reference always means
    the same thing, it’s simpler for a reader of the code to reason about — they don’t
    have to trace through all the code to find all the places where the object or
    reference might be changed, because it can’t be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ready for change**. If an object or reference can’t be changed at runtime,
    then code that depends on that object or reference won’t have to be revised when
    the program changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
