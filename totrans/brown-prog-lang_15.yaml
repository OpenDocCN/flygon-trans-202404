- en: 15Sets Appeal
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15集合的吸引力
- en: '|     [15.1 Representing Sets by Lists](#%28part._rep-sets-as-lists%29) |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|     [15.1 用列表表示集合](#%28part._rep-sets-as-lists%29) |'
- en: '|       [15.1.1 Representation Choices](#%28part._.Representation_.Choices%29)
    |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|       [15.1.1 表示选择](#%28part._.Representation_.Choices%29) |'
- en: '|       [15.1.2 Time Complexity](#%28part._.Time_.Complexity%29) |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '|       [15.1.2 时间复杂度](#%28part._.Time_.Complexity%29) |'
- en: '|       [15.1.3 Choosing Between Representations](#%28part._choosing-set-reps%29)
    |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '|       [15.1.3 在表示之间进行选择](#%28part._choosing-set-reps%29) |'
- en: '|       [15.1.4 Other Operations](#%28part._.Other_.Operations%29) |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|       [15.1.4 其他操作](#%28part._.Other_.Operations%29) |'
- en: '|     [15.2 Making Sets Grow on Trees](#%28part._.Making_.Sets_.Grow_on_.Trees%29)
    |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|     [15.2 使集合在树上生长](#%28part._.Making_.Sets_.Grow_on_.Trees%29) |'
- en: '|       [15.2.1 Converting Values to Ordered Values](#%28part._hashing-values%29)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.1 将值转换为有序值](#%28part._hashing-values%29) |'
- en: '|       [15.2.2 Using Binary Trees](#%28part._.Using_.Binary_.Trees%29) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.2 使用二叉树](#%28part._.Using_.Binary_.Trees%29) |'
- en: '|       [15.2.3 A Fine Balance: Tree Surgery](#%28part._sets-from-balanced-trees%29)
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|       [15.2.3 微妙的平衡：树手术](#%28part._sets-from-balanced-trees%29) |'
- en: '|         [15.2.3.1 Left-Left Case](#%28part._.Left-.Left_.Case%29) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.3.1 左-左情况](#%28part._.Left-.Left_.Case%29) |'
- en: '|         [15.2.3.2 Left-Right Case](#%28part._.Left-.Right_.Case%29) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.3.2 左-右情况](#%28part._.Left-.Right_.Case%29) |'
- en: '|         [15.2.3.3 Any Other Cases?](#%28part._.Any_.Other_.Cases_%29) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|         [15.2.3.3 还有其他情况吗？](#%28part._.Any_.Other_.Cases_%29) |'
- en: Earlier [[Sets as Collective Data](Collections_of_Structured_Data.html#%28part._sets-as-collections%29)]
    we introduced sets. Recall that the elements of a set have no specific order,
    and ignore duplicates.If these ideas are not familiar, please read [Sets as Collective
    Data](Collections_of_Structured_Data.html#%28part._sets-as-collections%29), since
    they will be important when discussing the representation of sets. At that time
    we relied on Pyret’s built-in representation of sets. Now we will discuss how
    to build sets for ourselves. In what follows, we will focus only on sets of numbers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 之前[[集合作为集体数据](Collections_of_Structured_Data.html#%28part._sets-as-collections%29)]我们介绍了集合。回想一下，集合的元素没有特定的顺序，并且忽略重复。如果这些概念对你不熟悉，请阅读[集合作为集体数据](Collections_of_Structured_Data.html#%28part._sets-as-collections%29)，因为在讨论集合的表示时它们将是重要的。那时我们依赖于
    Pyret 内置的集合表示。现在我们将讨论如何自己构建集合。在接下来的内容中，我们将只关注数字集合。
- en: We will start by discussing how to represent sets using lists. Intuitively,
    using lists to represent sets of data seems problematic, because lists respect
    both order and duplication. For instance,
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论如何使用列表表示集合。直观地，使用列表来表示数据集似乎有问题，因为列表尊重顺序和重复。例如，
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: fails.In principle, we want sets to obey the following interface:<set-operations>
    ::=
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 失败。原则上，我们希望集合遵循以下接口：<set-operations> ::=
- en: '|   mt-set :: Set |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '|   mt-set :: 集合 |'
- en: '|   is-in :: (T, Set<T> -> Bool) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|   is-in :: (T, Set<T> -> 布尔) |'
- en: '|   insert :: (T, Set<T> -> Set<T>) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|   insert :: (T, Set<T> -> Set<T>) |'
- en: '|   union :: (Set<T>, Set<T> -> Set<T>) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|   union :: (Set<T>, Set<T> -> Set<T>) |'
- en: '|   size :: (Set<T> -> Number) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|   size :: (Set<T> -> 数字) |'
- en: '|   to-list :: (Set<T> -> List<T>) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|   to-list :: (Set<T> -> 列表<T>) |'
- en: We may also find it also useful to have functions such as
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可能发现有些函数也很有用，比如
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: which, combined with mt-set, easily gives us a to-set function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 结合 mt-set，我们很容易得到一个 to-set 函数。
- en: 'Sets can contain many kinds of values, but not necessarily any kind: we need
    to be able to check for two values being equal (which is a requirement for a set,
    but not for a list!), which can’t be done with all values [REF]; and sometimes
    we might even want the elements to obey an ordering [[Converting Values to Ordered
    Values](#%28part._hashing-values%29)]. Numbers satisfy both characteristics.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以包含多种类型的值，但不一定是任何一种类型：我们需要能够检查两个值是否相等（这是集合的要求，但不是列表的要求！），这不能用所有值来做到[REF]；有时我们甚至可能希望元素服从一种排序[[将值转换为有序值](#%28part._hashing-values%29)]。数字满足这两个特点。
- en: 15.1Representing Sets by Lists
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1用列表表示集合
- en: In what follows we will see multiple different representations of sets, so we
    will want names to tell them apart. We’ll use LSet to stand for “sets represented
    as lists”.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将看到多种不同的集合表示，因此我们需要名称来区分它们。我们将使用 LSet 来代表“以列表形式表示的集合”。
- en: As a starting point, let’s consider the implementation of sets using lists as
    the underlying representation. After all, a set appears to merely be a list wherein
    we ignore the order of elements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，让我们考虑使用列表作为基础表示的集合的实现。毕竟，集合似乎只是一个我们忽略元素顺序的列表。
- en: 15.1.1Representation Choices
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.1表示选择
- en: The empty list can stand in for the empty set—<wbr>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表可以代表空集—<wbr>
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: —<wbr>and we can presumably define size as
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: —<wbr>我们可以假定将大小定义为
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, this [☛ reduction](glossary.html#%28elem._glossary-reduction%29) (of
    sets to lists) can be dangerous:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种[☛减少](glossary.html#%28elem._glossary-reduction%29)（将集合减少为列表）可能是危险的：
- en: There is a subtle difference between lists and sets. The list
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表和集合之间存在微妙的差异。列表
- en: '[PRE4]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: is not the same as
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同于
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'because the first list has length two whereas the second has length one. Treated
    as a set, however, the two are the same: they both have size one. Thus, our implementation
    of size above is incorrect if we don’t take into account duplicates (either during
    insertion or while computing the size).'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为第一个列表的长度为二，而第二个列表的长度为一。然而，将它们视为集合时，两者是相同的：它们都有大小为一。因此，如果我们不考虑重复项（在插入期间或计算大小时），我们上面的大小实现是不正确的。
- en: We might falsely make assumptions about the order in which elements are retrieved
    from the set due to the ordering guaranteed provided by the underlying list representation.
    This might hide bugs that we don’t discover until we change the representation.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于底层列表表示提供的顺序保证，我们可能会错误地假设从集合中检索元素的顺序。这可能会隐藏我们直到更改表示形式才发现的错误。
- en: We might have chosen a set representation because we didn’t need to care about
    order, and expected lots of duplicate items. A list representation might store
    all the duplicates, resulting in significantly more memory use (and slower programs)
    than we expected.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能选择了集合表示，因为我们不需要关心顺序，并且预期会有大量重复项。列表表示可能会存储所有重复项，导致内存使用量（和程序速度）比我们预期的要多得多。
- en: To avoid these perils, we have to be precise about how we’re going to use lists
    to represent sets. One key question (but not the only one, as we’ll soon see [REF])
    is what to do about duplicates. One possibility is for insert to check whether
    an element is already in the set and, if so, leave the representation unchanged;
    this incurs a cost during insertion but avoids unnecessary duplication and lets
    us use length to implement size. The other option is to define insert as link—<wbr>literally,
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些危险，我们必须准确地说明我们将如何使用列表来表示集合。一个关键问题（但不是唯一的问题，正如我们很快将看到的[REF]）是如何处理重复项。一种可能性是插入检查元素是否已经在集合中，如果是，则保持表示形式不变；这在插入期间会产生成本，但避免了不必要的重复，并使我们可以使用长度来实现大小。另一种选择是将插入定义为链接—<wbr>字面上，
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: —<wbr>and have some other procedure perform the filtering of duplicates.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: —<wbr>并让其他过程执行重复项的过滤。
- en: 15.1.2Time Complexity
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.2 时间复杂度
- en: 'What is the complexity of this representation of sets? Let’s consider just
    insert, check, and size. Suppose the size of the set is \(k\) (where, to avoid
    ambiguity, we let \(k\) represent the number of distinct elements). The complexity
    of these operations depends on whether or not we store duplicates:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种集合表示的复杂度是多少？让我们只考虑插入、检查和大小。假设集合的大小是 \(k\)（为了避免歧义，我们让 \(k\) 表示不同元素的数量）。这些操作的复杂性取决于我们是否存储重复项：
- en: If we don’t store duplicates, then size is simply length, which takes time linear
    in \(k\). Similarly, check only needs to traverse the list once to determine whether
    or not an element is present, which also takes time linear in \(k\). But insert
    needs to check whether an element is already present, which takes time linear
    in \(k\), followed by at most a constant-time operation (link).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不存储重复项，则大小只是长度，它的时间复杂度是 \(k\) 的线性时间。同样，检查只需要遍历列表一次来确定元素是否存在，这也需要 \(k\) 的线性时间。但是插入需要检查元素是否已经存在，这需要
    \(k\) 的线性时间，然后是最多的常数时间操作（链接）。
- en: 'If we do store duplicates, then insert is constant time: it simply links on
    the new element without regard to whether it already is in the set representation.
    check traverses the list once, but the number of elements it needs to visit could
    be significantly greater than \(k\), depending on how many duplicates have been
    added. Finally, size needs to check whether or not each element is duplicated
    before counting it.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们存储重复项，那么插入是常数时间：它只是链接到新元素而不考虑它是否已经在集合表示中。检查遍历列表一次，但是它需要访问的元素数量可能明显大于 \(k\)，这取决于已添加多少个重复项。最后，在计算大小之前，大小需要检查每个元素是否重复。
- en: Do Now!
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在动手！
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the time complexity of size if the list has duplicates?
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果列表中有重复项，大小的时间复杂度是多少？
- en: One implementation of size is
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大小的一个实现是
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s now compute the complexity of the body of the function, assuming the number
    of distinct elements in s is \(k\) but the actual number of elements in s is \(d\),
    where \(d \geq k\). To compute the time to run size on \(d\) elements, \(T(d)\),
    we should determine the number of operations in each question and answer. The
    first question has a constant number of operations, and the first answer also
    a constant. The second question also has a constant number of operations. Its
    answer is a conditional, whose first question (r.member(f) needs to traverse the
    entire list, and hence has \(O([k -> d])\) operations. If it succeeds, we recur
    on something of size \(T(d-1)\); else we do the same but perform a constant more
    operations. Thus \(T(0)\) is a constant, while the recurrence (in big-Oh terms)
    is
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们计算函数体的复杂度，假设集合 s 中不同元素的数量为 \(k\)，但实际元素数量为 \(d\)，其中 \(d \geq k\)。要计算在 \(d\)
    个元素上运行 size 的时间 \(T(d)\)，我们应该确定每个问题和答案中的操作数量。第一个问题有恒定数量的操作，第一个答案也是常数。第二个问题也有恒定数量的操作。它的答案是一个条件，其第一个问题
    \(r.member(f)\) 需要遍历整个列表，因此具有 \(O([k \rightarrow d])\) 操作。如果成功，则我们递归处理大小为 \(T(d-1)\)
    的东西；否则，我们执行相同的操作，但操作数量增加了一个常数。因此 \(T(0)\) 是一个常数，而递归（用大 O 表示）为
- en: \begin{equation*}T(d) = d + T(d-1)\end{equation*}
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: \begin{equation*}T(d) = d + T(d-1)\end{equation*}
- en: Thus \(T \in O([d \rightarrow d^2])\). Note that this is quadratic in the number
    of elements in the list, which may be much bigger than the size of the set.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 \(T \in O([d \rightarrow d^2])\)。注意，这在列表中的元素数量上是二次的，这可能比集合的大小要大得多。
- en: 15.1.3Choosing Between Representations
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.3选择表示方式
- en: 'Now that we have two representations with different complexities, it’s worth
    thinking about how to choose between them. To do so, let’s build up the following
    table. The table distinguishes between the interface (the set) and the implementation
    (the list), because—<wbr>owing to duplicates in the representation—<wbr>these
    two may not be the same. In the table we’ll consider just two of the most common
    operations, insertion and membership checking:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两种不同复杂度的表示方式，值得考虑如何在它们之间进行选择。为此，让我们建立以下表格。表格区分接口（集合）和实现（列表），因为——<wbr>由于表示中的重复——<wbr>这两者可能不相同。在表格中，我们将考虑两种最常见的操作之一，插入和成员检查：
- en: '|  |  | With Duplicates |  | Without Duplicates |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 有重复 |  | 无重复 |'
- en: '|  |  | insert |  | is-in |  | insert |  | is-in |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |  | 插入 |  | 是否存在 |  | 插入 |  | 是否存在 |'
- en: '| Size of Set |  | constant |  | linear |  | linear |  | linear |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 集合大小 |  | 常数 |  | 线性 |  | 线性 |  | 线性 |'
- en: '| Size of List |  | constant |  | linear |  | linear |  | linear |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 列表大小 |  | 常数 |  | 线性 |  | 线性 |  | 线性 |'
- en: 'A naive reading of this would suggest that the representation with duplicates
    is better because it’s sometimes constant and sometimes linear, whereas the version
    without duplicates is always linear. However, this masks a very important distinction:
    what the linear means. When there are no duplicates, the size of the list is the
    same as the size of the set. However, with duplicates, the size of the list can
    be arbitrarily larger than that of the set!Based on this, we can draw several
    lessons:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个朴素的理解会认为带有重复的表示方式更好，因为它有时是常数有时是线性，而没有重复的版本始终是线性的。然而，这掩盖了一个非常重要的区别：线性代表什么。当没有重复时，列表的大小与集合的大小相同。然而，有重复时，列表的大小可以比集合的大小任意大！基于此，我们可以得出几个结论：
- en: Which representation we choose is a matter of how much duplication we expect.
    If there won’t be many duplicates, then the version that stores duplicates pays
    a small extra price in return for some faster operations.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择哪种表示方式取决于我们期望有多少重复。如果不会有太多重复，那么存储重复的版本将付出一小额外代价，以换取一些更快的操作。
- en: 'Which representation we choose is also a matter of how often we expect each
    operation to be performed. The representation without duplication is “in the middle”:
    everything is roughly equally expensive (in the worst case). With duplicates is
    “at the extremes”: very cheap insertion, potentially very expensive membership.
    But if we will mostly only insert without checking membership, and especially
    if we know membership checking will only occur in situations where we’re willing
    to wait, then permitting duplicates may in fact be the smart choice. (When might
    we ever be in such a situation? Suppose your set represents a backup data structure;
    then we add lots of data but very rarely—<wbr>indeed, only in case of some catastrophe—<wbr>ever
    need to look for things in it.)'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择哪种表示形式也取决于我们预计每个操作将被执行的频率。没有重复的表示形式处于“中间”：每件事在最坏情况下都大致相同昂贵。有重复的是“极端”：非常便宜的插入，可能非常昂贵的成员资格。但如果我们大多数时候只插入而不检查成员资格，特别是如果我们知道成员资格检查只会在我们愿意等待的情况下发生，那么允许重复项实际上可能是明智的选择。（我们何时可能会处于这种情况？假设您的集合表示备份数据结构；然后我们添加大量数据，但很少——<wbr>实际上，只有在发生一些灾难的情况下——<wbr>需要在其中查找东西。）
- en: Another way to cast these insights is that our form of analysis is too weak.
    In situations where the complexity depends so heavily on a particular sequence
    of operations, big-Oh is too loose and we should instead study the complexity
    of specific sequences of operations. We will address precisely this question later
    ([Halloween Analysis](amortized-analysis.html)).
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种表达这些见解的方式是我们的分析形式过于弱。在复杂性严重依赖于特定操作序列的情况下，大O是太宽松了，我们应该代替研究特定操作序列的复杂性。我们将稍后精确地解决这个问题（[万圣节分析](amortized-analysis.html)）。
- en: Moreover, there is no reason a program should use only one representation. It
    could well begin with one representation, then switch to another as it better
    understands its workload. The only thing it would need to do to switch is to convert
    all existing data between the representations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，程序不应该只使用一种表示。它可能以一种表示开始，然后随着更好地理解其工作量而切换到另一种表示。要切换的唯一需要做的事情就是在表示之间转换所有现有数据。
- en: 'How might this play out above? Observe that data conversion is very cheap in
    one direction: since every list without duplicates is automatically also a list
    with (potential) duplicates, converting in that direction is trivial (the representation
    stays unchanged, only its interpretation changes). The other direction is harder:
    we have to filter duplicates (which takes time quadratic in the number of elements
    in the list). Thus, a program can make an initial guess about its workload and
    pick a representation accordingly, but maintain statistics as it runs and, when
    it finds its assumption is wrong, switch representations—<wbr>and can do so as
    many times as needed.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在上面如何发挥作用？注意，数据转换在一个方向上非常便宜：因为每个没有重复的列表自动也是一个（潜在的）重复列表，所以在那个方向上进行转换是微不足道的（表示保持不变，只是其解释发生变化）。另一个方向则更难：我们必须过滤重复项（这需要与列表中元素数量的平方成正比的时间）。因此，程序可以对其工作量进行初步猜测并选择相应的表示，但在运行过程中维护统计信息，并且当发现其假设错误时，切换表示——<wbr>并且可以根据需要多次切换。
- en: 15.1.4Other Operations
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.4其他操作
- en: Exercise
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the remaining operations catalogued above ([<set-operations>](#%28elem._set-operations%29))
    under each list representation.
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在每个列表表示下，实现上面分类的剩余操作（[<set-operations>](#%28elem._set-operations%29)）。
- en: Exercise
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement the operation
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现操作
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: under each list representation. What difference do you see?
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在每个列表表示下。你看到了什么不同吗？
- en: Do Now!
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就做！
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Suppose you’re asked to extend sets with these operations, as the set analog
    of first and rest:'
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设要扩展集合以使用这些操作，作为“first”和“rest”的集合类比：
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You should refuse to do so! Do you see why?
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你应该拒绝这样做！你明白为什么吗？
- en: With lists the “first” element is well-defined, whereas sets are defined to
    have no ordering. Indeed, just to make sure users of your sets don’t accidentally
    assume anything about your implementation (e.g., if you implement one using first,
    they may notice that one always returns the element most recently added to the
    list), you really ought to return a random element of the set on each invocation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表， “第一个” 元素是明确定义的，而集合被定义为没有顺序。事实上，为了确保您的集合的用户不会意外地假设您的实现有关的任何内容（例如，如果您使用“第一个”实现了一个，他们可能会注意到一个总是返回最近添加到列表中的元素），您确实应该在每次调用时返回集合的随机元素。
- en: Unfortunately, returning a random element means the above interface is unusable.
    Suppose s is bound to a set containing 1, 2, and 3. Say the first time one(s)
    is invoked it returns 2, and the second time 1. (This already means one is not
    a function—<wbr>an issue we’ll get to elsewhere [REF].) The third time it may
    again return 2. Thus others has to remember which element was returned the last
    time one was called, and return the set sans that element. Suppose we now invoke
    one on the result of calling others. That means we might have a situation where
    one(s) produces the same result as one(others(s)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，返回一个随机元素意味着上述接口无法使用。假设 s 绑定到一个包含 1、2 和 3 的集合。假设第一次调用 one(s) 时返回 2，第二次返回
    1。（这已经意味着 one 不是一个函数——<wbr>这是我们在其他地方会解决的问题 [REF]。）第三次它可能再次返回 2。因此，others 必须记住上次调用
    one 时返回的元素，并返回不包含该元素的集合。假设我们现在在调用 others 的结果上调用 one。这意味着我们可能会出现一种情况，其中 one(s)
    产生与 one(others(s)) 相同的结果。
- en: Exercise
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is it unreasonable for one(s) to produce the same result as one(others(s))?
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么认为一个元素产生与一个元素的其他元素相同的结果是不合理的？
- en: Exercise
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose you wanted to extend sets with a subset operation that partitioned the
    set according to some condition. What would its type be? See [REF join lists]
    for a similar operation.
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你想要使用一个根据某个条件对集合进行分区的子集操作来扩展集合。它的类型会是什么？请参阅[REF join lists]以查看类似的操作。
- en: Exercise
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The types we have written above are not as crisp as they could be. Define a
    has-no-duplicates predicate, refine the relevant types with it, and check that
    the functions really do satisfy this criterion.
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们上面写的类型并不够清晰。定义一个无重复项的谓词，用它来细化相关的类型，并检查这些函数是否真正满足这个条件。
- en: 15.2Making Sets Grow on Trees
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 **使集合在树上增长**
- en: Let’s start by noting that it seems better, if at all possible, to avoid storing
    duplicates. Duplicates are only problematic during insertion due to the need for
    a membership test. But if we can make membership testing cheap, then we would
    be better off using it to check for duplicates and storing only one instance of
    each value (which also saves us space). Thus, let’s try to improve the time complexity
    of membership testing (and, hopefully, of other operations too).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先注意到，如果可能的话，最好避免存储重复项。重复项只在插入时会有问题，因为需要进行成员测试。但是如果我们可以使成员测试变得廉价，那么最好使用它来检查重复项，并且仅存储每个值的一个实例（这也节省了空间）。因此，让我们尝试改进成员测试的时间复杂度（并且，希望也能改进其他操作的时间复杂度）。
- en: It seems clear that with a (duplicate-free) list representation of a set, we
    cannot really beat linear time for membership checking. This is because at each
    step, we can eliminate only one element from contention which in the worst case
    requires a linear amount of work to examine the whole set. Instead, we need to
    eliminate many more elements with each comparison—<wbr>more than just a constant.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，用（无重复项的）列表表示集合，我们无法真正击败线性时间进行成员检查。这是因为在每一步中，我们只能排除一个元素，而在最坏的情况下，需要线性数量的工作来检查整个集合。相反，我们需要在每次比较中消除更多的元素——<wbr>不仅仅是一个常数。
- en: 'In our handy set of recurrences ([Solving Recurrences](predicting-growth.html#%28part._solving-recurrences%29)),
    one stands out: \(T(k) = T(k/2) + c\). It says that if, with a constant amount
    of work we can eliminate half the input, we can perform membership checking in
    logarithmic time. This will be our goal.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们方便使用的递归集合中（[解决递归](predicting-growth.html#%28part._solving-recurrences%29)），有一个是突出的：\(T(k)
    = T(k/2) + c\)。它表明，如果我们可以用恒定的工作量消除一半的输入，我们可以在对数时间内执行成员检查。这将是我们的目标。
- en: Before we proceed, it’s worth putting logarithmic growth in perspective. Asymptotically,
    logarithmic is obviously not as nice as constant. However, logarithmic growth
    is very pleasant because it grows so slowly. For instance, if an input doubles
    from size \(k\) to \(2k\), its logarithm—<wbr>and hence resource usage—<wbr>grows
    only by \(\log 2k - \log k = \log 2\), which is a constant. Indeed, for just about
    all problems, practically speaking the logarithm of the input size is bounded
    by a constant (that isn’t even very large). Therefore, in practice, for many programs,
    if we can shrink our resource consumption to logarithmic growth, it’s probably
    time to move on and focus on improving some other part of the system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，值得将对数增长放在透视中。从渐近的角度来看，对数显然不如常数好。然而，对数增长非常愉快，因为它增长得如此缓慢。例如，如果一个输入从大小
    \(k\) 增加到 \(2k\)，其对数—<wbr>因此资源使用—<wbr>仅增加了 \(\log 2k - \log k = \log 2\)，这是一个常数。实际上，对于几乎所有问题，从实际角度来看，输入大小的对数都受到一个常数的限制（甚至不是很大的常数）。因此，在实践中，对于许多程序来说，如果我们可以将资源消耗缩小到对数增长，那么现在可能是时候继续前进，专注于��进系统的其他部分了。
- en: 15.2.1Converting Values to Ordered Values
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.1将值转换为有序值
- en: We have actually just made an extremely subtle assumption. When we check one
    element for membership and eliminate it, we have eliminated only one element.
    To eliminate more than one element, we need one element to “speak for” several.
    That is, eliminating that one value needs to have safely eliminated several others
    as well without their having to be consulted. In particular, then, we can no longer
    compare for mere equality, which compares one set element against another element;
    we need a comparison that compares against an element against a set of elements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上只是做了一个非常微妙的假设。当我们检查一个元素是否属于集合并将其排除时，我们只排除了一个元素。要排除多个元素，我们需要一个元素来“代表”几个元素。也就是说，排除那个值需要安全地排除其他几个元素，而无需再次查看它们。特别是，我们不能再仅仅比较相等性，这种比较一个集合元素与另一个元素的方式；我们需要一种比较方式，将一个元素与一组元素进行比较。
- en: 'To do this, we have to convert an arbitrary datum into a datatype that permits
    such comparison. This is known as hashing. A hash function consumes an arbitrary
    value and produces a comparable representation of it (its hash)—<wbr>most commonly
    (but not strictly necessarily), a number. A hash function must naturally be deterministic:
    a fixed value should always yield the same hash (otherwise, we might conclude
    that an element in the set is not actually in it, etc.). Particular uses may need
    additional properties: e.g., below we assume its output is partially ordered.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们必须将任意数据转换为允许这种比较的数据类型。这就是所谓的哈希。哈希函数接受一个任意值并产生一个可比较的表示（其哈希值）—<wbr>最常见的（但不是绝对必要的）是一个数字。哈希函数必须自然是确定性的：一个固定值应该始终产生相同的哈希值（否则，我们可能会得出结论，集合中的元素实际上不在其中等等）。特定的用途可能需要额外的属性：例如，下面我们假设其输出是部分有序的。
- en: Let us now consider how one can compute hashes. If the input datatype is a number,
    it can serve as its own hash. Comparison simply uses numeric comparison (e.g.,
    <). Then, transitivity of < ensures that if an element \(A\) is less than another
    element \(B\), then \(A\) is also less than all the other elements bigger than
    \(B\). The same principle applies if the datatype is a string, using string inequality
    comparison. But what if we are handed more complex datatypes?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑如何计算哈希值。如果输入数据类型是一个数字，它可以作为自己的哈希值。比较简单地使用数字比较（例如，<）。然后，< 的传递性确保如果一个元素
    \(A\) 小于另一个元素 \(B\)，那么 \(A\) 也小于所有比 \(B\) 大的其他元素。如果数据类型是字符串，则使用字符串不等比较。但如果我们被交付更复杂的数据类型呢？
- en: 'Before we answer that, consider that in practice numbers are more efficient
    to compare than strings (since comparing two numbers is very nearly constant time).
    Thus, although we could use strings directly, it may be convenient to find a numeric
    representation of strings. In both cases, we will convert each character of the
    string into a number—<wbr>e.g., by considering its ASCII encoding. Based on that,
    here are two hash functions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这个问题之前，考虑到实际上比较数字比比较字符串更有效率（因为比较两个数字几乎是常数时间）。因此，虽然我们可以直接使用字符串，但找到字符串的数值表示可能更方便。在这两种情况下，我们将把字符串的每个字符转换为一个数字—<wbr>例如，通过考虑其ASCII编码。基于此，这里有两个哈希函数：
- en: Consider a list of primes as long as the string. Raise each prime by the corresponding
    number, and multiply the result. For instance, if the string is represented by
    the character codes [6, 4, 5] (the first character has code 6, the second one
    4, and the third 5), we get the hash
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑一个与字符串一样长的素数列表。将每个素数提升到相应的数字，并相乘。例如，如果字符串由字符代码[6, 4, 5]表示（第一个字符的代码为6，第二个字符为4，第三个为5），我们得到哈希
- en: '[PRE10]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: or 16200000.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或16200000。
- en: Simply add together all the character codes. For the above example, this would
    correspond to the has
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地将所有字符代码相加。对于上面的例子，这将对应于哈希
- en: '[PRE11]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: or 15.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或15。
- en: 'The first representation is invertible, using the [Fundamental Theorem of Arithmetic](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic):
    given the resulting number, we can reconstruct the input unambiguously (i.e.,
    16200000 can only map to the input above, and none other). The second encoding
    is, of course, not invertible (e.g., simply permute the characters and, by commutativity,
    the sum will be the same).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表示是可逆的，使用[算术基本定理](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)：给定结果数字，我们可以明确地重构输入（即，16200000只能映射到上面的输入，没有其他）。第二个编码当然是不可逆的（例如，简单地排列字符，通过交换性，总和将是相同的）。
- en: 'Now let us consider more general datatypes. The principle of hashing will be
    similar. If we have a datatype with several variants, we can use a numeric tag
    to represent the variants: e.g., the primes will give us invertible tags. For
    each field of a record, we need an ordering of the fields (e.g., lexicographic,
    or “alphabetical” order), and must hash their contents recursively; having done
    so, we get in effect a string of numbers, which we have shown how to handle.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑更一般的数据类型。哈希的原则将是类似的。如果我们有一个具有几个变体的数据类型，我们可以使用数字标签来表示变体：例如，素数将给我们可逆的标签。对于记录的每个字段，我们需要字段的排序（例如，词典顺序或“字母顺序”），并且必须递归地哈希它们的内容；这样做后，我们实际上得到了一串数字，我们已经展示了如何处理。
- en: Now that we have understood how one can deterministically convert any arbitrary
    datum into a number, in what follows, we will assume that the trees representing
    sets are trees of numbers. However, it is worth considering what we really need
    out of a hash. In [Set Membership by Hashing Redux](Algorithms_That_Exploit_State.html#%28part._hash-tables%29),
    we will not need partial ordering. Invertibility is more tricky. In what follows
    below, we have assumed that finding a hash is tantamount to finding the set element
    itself, which is not true if multiple values can have the same hash. In that case,
    the easiest thing to do is to store alongside the hash all the values that hashed
    to it, and we must search through all of these values to find our desired element.
    Unfortunately, this does mean that in an especially perverse situation, the desired
    logarithmic complexity will actually be linear complexity after all!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何确定性地将任意数据转换为数字，接下来，我们将假设表示集合的树是数字树。然而，值得考虑的是我们真正需要哈希的是什么。在[通过哈希实现集合成员](Algorithms_That_Exploit_State.html#%28part._hash-tables%29)中，我们不需要部分排序。可逆性更加棘手。在下文中，我们假设找到一个哈希等同于找到集合元素本身，但如果多个值可以具有相同的哈希，则这并不正确。在这种情况下，最简单的方法是将所有哈希到它的值都存储在哈希旁边，我们必须搜索所有这些值以找到我们想要的元素。不幸的是，这意味着在一个特别恶劣的情况下，所需的对数复杂度实际上将变成线性复杂度！
- en: 'In real systems, hashes of values are typically computed by the programming
    language implementation. This has the virtue that they can often be made unique.
    How does the system achieve this? Easy: it essentially uses the memory address
    of a value as its hash. (Well, not so fast! Sometimes the memory system can and
    does move values around ((part "garbage-collection")). In these cases computing
    a hash value is more complicated.)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际系统中，值的哈希通常由编程语言实现计算。这样做的好处是它们通常可以被做成唯一的。系统是如何实现这一点的呢？很简单：它基本上使用值的内存地址作为其哈希值。（嗯，不要那么快！有时内存系统可以并且确实移动值（部分“垃圾回收”）。在这些情况下，计算哈���值更加复杂。）
- en: 15.2.2Using Binary Trees
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.2使用二叉树
- en: Because logs come from trees.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对数来自树。
- en: 'Clearly, a list representation does not let us eliminate half the elements
    with a constant amount of work; instead, we need a tree. Thus we define a binary
    tree of (for simplicity) numbers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，列表表示不允许我们用恒定的工作量消除一半的元素；相反，我们需要一棵树。因此，我们定义一个二叉树（为简单起见）的数字：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Given this definition, let’s define the membership checker:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个定义，让我们定义成员检查器：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Oh, wait. If the element we’re looking for isn’t the root, what do we do? It
    could be in the left child or it could be in the right; we won’t know for sure
    until we’ve examined both. Thus, we can’t throw away half the elements; the only
    one we can dispose of is the value at the root. Furthermore, this property holds
    at every level of the tree. Thus, membership checking needs to examine the entire
    tree, and we still have complexity linear in the size of the set.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。如果我们要查找的元素不是根节点，我们该怎么办？它可能在左子节点中，也可能在右子节点中；我们在检查完两者之前是无法确定的。因此，我们无法丢弃一半的元素；我们唯一能够丢弃的是根节点的值。此外，这个属性在树的每一层都成立。因此，成员检查需要检查整个树，而且我们仍然具有与集合大小线性相关的复杂度。
- en: How can we improve on this? The comparison needs to help us eliminate not only
    the root but also one whole sub-tree. We can only do this if the comparison “speaks
    for” an entire sub-tree. It can do so if all elements in one sub-tree are less
    than or equal to the root value, and all elements in the other sub-tree are greater
    than or equal to it. Of course, we have to be consistent about which side contains
    which subset; it is conventional to put the smaller elements to the left and the
    bigger ones to the right. This refines our binary tree definition to give us a
    binary search tree (BST).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改进？比较需要帮助我们消除不仅是根节点而且是整个子树。只有当比较“代表”整个子树时才能做到这一点。如果一个子树中的所有元素都小于或等于根值，而另一个子树中的所有元素都大于或等于它，则可以这样做。当然，我们必须在哪一侧包含哪个子集方面保持一致；将较小的元素放在左边，较大的元素放在右边是传统的。这使我们的二叉树定义更精细，从而给我们一个二叉搜索树（BST）。
- en: Do Now!
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在开始！
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here is a candiate predicate for recognizing when a binary tree is in fact
    a binary search tree:'
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里有一个识别二叉树实际上是否是二叉搜索树的候选谓词：
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Is this definition correct?
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个定义正确吗？
- en: 'It’s not. To actually throw away half the tree, we need to be sure that everything
    in the left sub-tree is less than the value in the root and similarly, everything
    in the right sub-tree is greater than the root.We have used <= instead of < above
    because even though we don’t want to permit duplicates when representing sets,
    in other cases we might not want to be so stringent; this way we can reuse the
    above implementation for other purposes. But the definition above performs only
    a “shallow” comparison. Thus we could have a root a with a right child, b, such
    that b > a; and the b node could have a left child c such that c < b; but this
    does not guarantee that c > a. In fact, it is easy to construct a counter-example
    that passes this check:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不是。要实际丢弃一半的树，我们需要确保左子树中的所有元素都小于根值，同样，右子树中的所有元素都大于根。我们在上面使用了 <= 而不是 <，因为尽管在表示集合时我们不想允许重复，但在其他情况下我们可能不想那么严格；这样我们可以将上面的实现重用于其他目的。但是上面的定义只执行了一个“浅”比较。因此，我们可以有一个根节点
    a，它有一个右子节点 b，使得 b > a；而 b 节点可以有一个左子节点 c，使得 c < b；但这并不保证 c > a。事实上，我们很容易构造一个通过此检查的反例：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Exercise
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fix the BST checker.
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修复 BST 检查器。
- en: 'With a corrected definition, we can now define a refined version of binary
    trees that are search trees:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修正的定义，我们现在可以定义一个更精细的二叉树版本，它是搜索树：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also remind ourselves that the purpose of this exercise was to define
    sets, and define TSets to be tree sets:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以提醒自己，这个练习的目的是定义集合，并定义 TSets 为树集：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let’s implement our operations on the BST representation. First we’ll write
    a template:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在 BST 表示上实现我们的操作。首先我们将写一个模板：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Observe that the data definition of a BST gives us rich information about the
    two children: they are each a BST, so we know their elements obey the ordering
    property. We can use this to define the actual operations:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，BST 的数据定义为我们提供了关于两个子节点的丰富信息：它们各自都是 BST，所以我们知道它们的元素遵循排序属性。我们可以利用这一点来定义实际的操作：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In both functions we are strictly assuming the invariant of the BST, and in
    the latter case also ensuring it. Make sure you identify where, why, and how.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数中，我们严格假设 BST 的不变式，并在后一种情况下也确保它。确保你能够确定在哪里、为什么以及如何做到这一点。
- en: You should now be able to define the remaining operations. Of these, size clearly
    requires linear time (since it has to count all the elements), but because is-in
    and insert both throw away one of two children each time they recur, they take
    logarithmic time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够定义剩下的操作了。其中，size 显然需要线性时间（因为它必须计算所有元素），但是因为 is-in 和 insert 每次递归时都会丢弃两个子节点中的一个，所以它们花费对数时间。
- en: Exercise
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Suppose we frequently needed to compute the size of a set. We ought to be able
    to reduce the time complexity of size by having each tree [☛ cache](glossary.html#%28elem._glossary-cache%29)
    its size, so that size could complete in constant time (note that the size of
    the tree clearly fits the criterion of a cache, since it can always be reconstructed).
    Update the data definition and all affected functions to keep track of this information
    correctly.
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设我们经常需要计算一个集合的大小。我们应该能够通过使每棵树[☛缓存](glossary.html#%28elem._glossary-cache%29)其大小来降低size的时间复杂度，以便size可以在常数时间内完成（注意树的大小显然符合缓存的标准，因为它总是可以重新构建的）。更新数据定义和所有受影响的函数，以正确跟踪此信息。
- en: But wait a minute. Are we actually done? Our recurrence takes the form \(T(k)
    = T(k/2) + c\), but what in our data definition guaranteed that the size of the
    child traversed by is-in will be half the size?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。我们真的完成了吗？我们的递归的形式是\(T(k) = T(k/2) + c\)，但是我们的数据定义中什么保证了is-in所遍历的子树的大小是父节点的一半？
- en: Do Now!
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在就行动！
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Construct an example—<wbr>consisting of a sequence of inserts to the empty tree—<wbr>such
    that the resulting tree is not balanced. Show that searching for certain elements
    in this tree will take linear, not logarithmic, time in its size.
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建一个例子—<wbr>由一系列插入到空树中的插入组成—<wbr>使得得到的树不平衡。证明在该树中搜索某些元素将花费线性时间，而不是对数时间。
- en: Imagine starting with the empty tree and inserting the values 1, 2, 3, and 4,
    in order. The resulting tree would be
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下从空树开始，按顺序插入值1、2、3和4。结果得到的树将是
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Searching for 4 in this tree would have to examine all the set elements in the
    tree. In other words, this binary search tree is degenerate—<wbr>it is effectively
    a list, and we are back to having the same complexity we had earlier.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这棵树中搜索4将不得不检查树中的所有集合元素。换句话说，这棵二叉搜索树是退化的—<wbr>它实际上是一个列表，我们回到了之前的复杂度。
- en: 'Therefore, using a binary tree, and even a BST, does not guarantee the complexity
    we want: it does only if our inputs have arrived in just the right order. However,
    we cannot assume any input ordering; instead, we would like an implementation
    that works in all cases. Thus, we must find a way to ensure that the tree is always
    balanced, so each recursive call in is-in really does throw away half the elements.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用二叉树，甚至是BST，并不能保证我们想要的复杂度：只有当我们的输入按照恰当的顺序到达时才会如此。然而，我们不能假设任何输入顺序；相反，我们希望一种在所有情况下都有效的实现。因此，我们必须找到一种方法来确保树始终保持平衡，以便is-in中的每个递归调用都实际上丢弃了一半的元素。
- en: '15.2.3A Fine Balance: Tree Surgery'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3精密平衡：树手术
- en: 'Let’s define a balanced binary search tree (BBST). It must obviously be a search
    tree, so let’s focus on the “balanced” part. We have to be careful about precisely
    what this means: we can’t simply expect both sides to be of equal size because
    this demands that the tree (and hence the set) have an even number of elements
    and, even more stringently, to have a size that is a power of two.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个平衡二叉搜索树（BBST）。显然它必须是一个搜索树，所以让我们专注于“平衡”部分。我们必须小心确切地理解这意味着什么：我们不能简单地期望两边的大小相等，因为这要求树（因而也要求集合）具有偶数个元素，甚至更严格地说，具有二的幂次的大小。
- en: Exercise
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Define a predicate for a BBST that consumes a BT and returns a Boolean indicating
    whether or not it a balanced search tree.
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义一个BBST的谓词，它消耗一个BT并返回一个布尔值，指示它是否是平衡搜索树。
- en: 'Therefore, we relax the notion of balance to one that is both accommodating
    and sufficient. We use the term balance factor for a node to refer to the height
    of its left child minus the height of its right child (where the height is the
    depth, in edges, of the deepest node). We allow every node of a BBST to have a
    balance factor of \(-1\), \(0\), or \(1\) (but nothing else): that is, either
    both have the same height, or the left or the right can be one taller. Note that
    this is a recursive property, but it applies at all levels, so the imbalance cannot
    accumulate making the whole tree arbitrarily imbalanced.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将平衡的概念放宽到既宽容又足够的程度。我们使用节点的平衡因子来指代其左子树的高度减去其右子树的高度（其中高度是最深节点的深度，以边数表示）。我们允许BBST的每个节点具有-1、0或1的平衡因子（但没有其他值）：即，左右两侧要么高度相同，要么一侧比另一侧高一。注意，这是一个递归属性，但它适用于所有级别，因此不平衡不能积累使整个树任意不平衡。
- en: Exercise
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given this definition of a BBST, show that the number of nodes is exponential
    in the height. Thus, always recurring on one branch will terminate after a logarithmic
    (in the number of nodes) number of steps.
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定 BBST 的定义，证明节点数与高度呈指数关系。因此，总是在一个分支上循环将在经过对数（节点数）步骤后终止。
- en: 'Here is an obvious but useful observation: every BBST is also a BST (this was
    true by the very definition of a BBST). Why does this matter? It means that a
    function that operates on a BST can just as well be applied to a BBST without
    any loss of correctness.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个明显但有用的观察：每个 BBST 也是一个 BST（这是 BBST 的定义所决定的）。这为什么重要？这意味着对 BST 进行操作的函数同样适用于
    BBST，而不会丢失正确性。
- en: So far, so easy. All that leaves is a means of creating a BBST, because it’s
    responsible for ensuring balance. It’s easy to see that the constant empty-set
    is a BBST value. So that leaves only insert.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很容易。唯一剩下的是创建 BBST 的方法，因为它负责确保平衡。很容易看出，常数空集是 BBST 的一个值。因此，只剩下插入。
- en: Here is our situation with insert. Assuming we start with a BBST, we can determine
    in logarithmic time whether the element is already in the tree and, if so, ignore
    it.To implement a bag we count how many of each element are in it, which does
    not affect the tree’s height. When inserting an element, given balanced trees,
    the insert for a BST takes only a logarithmic amount of time to perform the insertion.
    Thus, if performing the insertion does not affect the tree’s balance, we’re done.
    Therefore, we only need to consider cases where performing the insertion throws
    off the balance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在插入时的情况。假设我们从一个 BBST 开始，我们可以在对数时间内确定元素是否已经在树中，如果是，则忽略它。为了实现一个包，我们计算其中每个元素的数量，这不会影响树的高度。在插入元素时，鉴于平衡树，BST
    的插入只需要对数时间来执行插入。因此，如果执行插入不会影响树的平衡，我们就完成了。因此，我们只需要考虑执行插入会破坏平衡的情况。
- en: 'Observe that because \(<\) and \(>\) are symmetric (likewise with \(<=\) and
    \(>=\)), we can consider insertions into one half of the tree and a symmetric
    argument handles insertions into the other half. Thus, suppose we have a tree
    that is currently balanced into which we are inserting the element \(e\). Let’s
    say \(e\) is going into the left sub-tree and, by virtue of being inserted, will
    cause the entire tree to become imbalanced.Some trees, like family trees [REF],
    represent real-world data. It makes no sense to “balance” a family tree: it must
    accurately model whatever reality it represents. These set-representing trees,
    in contrast, are chosen by us, not dictated by some external reality, so we are
    free to rearrange them.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，因为 \(<\) 和 \(>\) 是对称的（同样适用于 \(<=\) 和 \(>=\)），我们可以考虑插入到树的一半，并且对另一半进行对称处理。因此，假设我们有一棵当前平衡的树，我们要向其中插入元素
    \(e\)。假设 \(e\) 要插入左子树，并且由于被插入，将导致整棵树失衡。有些树，比如家谱树[REF]，代表着现实世界的数据。对于“平衡”家谱树是毫无意义的：它必须准确地模拟它所代表的现实。相比之下，这些代表集合的树是我们选择的，而不是由外部现实所规定的，因此我们可以自由地重新排列它们。
- en: There are two ways to proceed. One is to consider all the places where we might
    insert \(e\) in a way that causes an imbalance and determine what to do in each
    case.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以继续。一种是考虑我们可能在其中插入 \(e\) 以导致失衡的所有位置，并确定在每种情况下该怎么做。
- en: Exercise
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Enumerate all the cases where insertion might be problematic, and dictate what
    to do in each case.
  id: totrans-176
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 枚举插入可能有问题的所有情况，并规定在每种情况下该怎么做。
- en: 'The number of cases is actually quite overwhelming (if you didn’t think so,
    you missed a few...). Therefore, we instead attack the problem after it has occurred:
    allow the existing BST insert to insert the element, assume that we have an imbalanced
    tree, and show how to restore its balance.The insight that a tree can be made
    “self-balancing” is quite remarkable, and there are now many solutions to this
    problem. This particular one, one of the oldest, is due to G.M. Adelson-Velskii
    and E.M. Landis. In honor of their initials it is called an AVL Tree, though the
    tree itself is quite evident; their genius is in defining re-balancing.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 案例的数量实际上是相当庞大的（如果你认为不是，那你可能漏掉了一些...）。因此，我们改变策略，等问题发生后再解决：允许现有的 BST 插入元素，假设我们有一棵失衡的树，并展示如何恢复其平衡。树可以自我平衡的这一洞察力是相当了不起的，现在有许多解决方案。这个特定的解决方案，是最古老的之一，归功于
    G.M. Adelson-Velskii 和 E.M. Landis。为了纪念他们的首字母，它被称为 AVL 树，尽管树本身是相当明显的；他们的天才在于定义重新平衡。
- en: 'Thus, in what follows, we begin with a tree that is balanced; insert causes
    it to become imbalanced; we have assumed that the insertion happened in the left
    sub-tree. In particular, suppose a (sub-)tree has a balance factor of \(2\) (positive
    because we’re assuming the left is imbalanced by insertion). The procedure for
    restoring balance depends critically on the following property:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在接下来的内容中，我们从一个平衡的树开始；插入导致其失衡；我们假设插入发生在左子树中。特别地，假设一个（子）树的平衡因子为\(2\)（正因为我们假设左边由插入导致失衡）。恢复平衡的过程关键取决于以下属性：
- en: Exercise
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show that if a tree is currently balanced, i.e., the balance factor at every
    node is \(-1\), \(0\), or \(1\), then insert can at worst make the balance factor
    \(\pm 2\).
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 证明如果一棵树当前是平衡的，即每个节点的平衡因子为\(-1\)，\(0\)或\(1\)，那么插入操作最多会使平衡因子变为\(\pm 2\)。
- en: The algorithm that follows is applied as insert returns from its recursion,
    i.e., on the path from the inserted value back to the root. Since this path is
    of logarithmic length in the set’s size (due to the balancing property), and (as
    we shall see) performs only a constant amount of work at each step, it ensures
    that insertion also takes only logarithmic time, thus completing our challenge.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 插入返回递归时，即在从插入值返回到根的路径上应用下面的算法。由于该路径的长度是对数级别的（由于平衡属性），并且（正如我们将看到的）每一步只执行恒定数量的工作，因此它确保插入也仅需对数时间，从而完成我们的挑战。
- en: 'To visualize the algorithm, let’s use this tree schematic:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化算法，让我们使用这个树的示意图：
- en: '|     p |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|     p |'
- en: '|    / \ |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|    / \ |'
- en: '|   q   C |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|   q   C |'
- en: '|  / \ |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  / \ |'
- en: '| A   B |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| A   B |'
- en: Here, \(p\) is the value of the element at the root (though we will also abuse
    terminology and use the value at a root to refer to that whole tree), \(q\) is
    the value at the root of the left sub-tree (so \(q < p\)), and \(A\), \(B\), and
    \(C\) name the respective sub-trees. We have assumed that \(e\) is being inserted
    into the left sub-tree, which means \(e < p\).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，\(p\)是根元素的值（尽管我们还将滥用术语并使用根处的值来指代整个树），\(q\)是左子树根处的值（因此\(q < p\)），\(A\)、\(B\)和\(C\)分别命名了各自的子树。我们假设\(e\)正在被插入到左子树中，这意味着\(e
    < p\)。
- en: Let’s say that \(C\) is of height \(k\). Before insertion, the tree rooted at
    \(q\) must have had height \(k+1\) (or else one insertion cannot create imbalance).
    In turn, this means \(A\) must have had height \(k\) or \(k-1\), and likewise
    for \(B\).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设\(C\)的高度为\(k\)。在插入之前，以\(q\)为根的树必须具有高度\(k+1\)（否则一个插入不可能造成失衡）。反过来，这意味着\(A\)必须具有高度\(k\)或\(k-1\)，\(B\)也是如此。
- en: Suppose that after insertion, the tree rooted at \(q\) has height \(k+2\). Thus,
    either \(A\) or \(B\) has height \(k+1\) and the other must have height less than
    that (either \(k\) or \(k-1\)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设插入后，以\(q\)为根的树的高度为\(k+2\)。因此，\(A\)或\(B\)中的一个高度为\(k+1\)，另一个高度必须小于\(k+1\)（要么是\(k\)，要么是\(k-1\)）。
- en: Exercise
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why can they both not have height \(k+1\) after insertion?
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么它们在插入后都不能同时具有高度\(k+1\)？
- en: This gives us two cases to consider.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们两种情况要考虑。
- en: 15.2.3.1Left-Left Case
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3.1左-左情况
- en: 'Let’s say the imbalance is in \(A\), i.e., it has height \(k+1\). Let’s expand
    that tree:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 假设不平衡出现在\(A\)中，即其高度为\(k+1\)。让我们扩展该树：
- en: '|       p |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|       p |'
- en: '|      / \ |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|      / \ |'
- en: '|     q   C |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|     q   C |'
- en: '|    / \ |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|    / \ |'
- en: '|   r   B |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|   r   B |'
- en: '|  / \ |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|  / \ |'
- en: '| A1  A2 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| A1  A2 |'
- en: We know the following about the data in the sub-trees. We’ll use the notation
    \(T < a\) where \(T\) is a tree and \(a\) is a single value to mean every value
    in \(T\) is less than \(a\).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道子树中的数据如下。我们将使用\(T < a\)的符号，其中\(T\)是一个树，\(a\)是一个单值，表示\(T\)中的每个值都小于\(a\)。
- en: \(A_1 < r\).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A_1 < r\)。
- en: \(r < A_2 < q\).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(r < A_2 < q\)。
- en: \(q < B < p\).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(q < B < p\)。
- en: \(p < C\).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(p < C\).
- en: 'Let’s also remind ourselves of the sizes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也提醒自己一下大小：
- en: The height of \(A_1\) or of \(A_2\) is \(k\) (the cause of imbalance).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A_1\)或\(A_2\)的高度为\(k\)（导致失衡的原因）。
- en: The height of the other \(A_i\) is \(k-1\) (see exercise above [REF]).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他\(A_i\)的高度为\(k-1\)（参见上面的练习[REF]）。
- en: The height of \(C\) is \(k\) (initial assumption; \(k\) is arbitrary).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(C\)的高度为\(k\)（初始假设；\(k\)是任意的）。
- en: The height of \(B\) must be \(k-1\) or \(k\) (argued above).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(B\)的高度必须为\(k-1\)或\(k\)（上述论述）。
- en: 'Imagine this tree is a mobile, which has gotten a little skewed to the left.
    You would naturally think to suspend the mobile a little further to the left to
    bring it back into balance. That is effectively what we will do:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这棵树是一个移动的部件，它有点向左倾斜了。你自然会想把移动的部件稍微往左边悬挂一点，以恢复平衡。这实际上就是我们要做的事情：
- en: '|      q |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|      q |'
- en: '|     / \ |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|     / \ |'
- en: '|   r     p |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|   r     p |'
- en: '|  / \   / \ |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  / \   / \ |'
- en: '| A1  A2 B  C |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| A1  A2 B  C |'
- en: Observe that this preserves each of the ordering properties above. In addition,
    the \(A\) subtree has been brought one level closer to the root than earlier relative
    to \(B\) and \(C\). This restores the balance (as you can see if you work out
    the heights of each of \(A_i\), \(B\), and \(C\)). Thus, we have also restored
    balance.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到这保留了上述每个排序属性。此外，\(A\)子树相对于\(B\)和\(C\)的根被带到了更接近根的一个级别。这恢复了平衡（如果您计算出每个\(A_i\)、\(B\)和\(C\)的高度，您会看到的）。因此，我们也恢复了平衡。
- en: 15.2.3.2Left-Right Case
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3.2左-右情况
- en: 'The imbalance might instead be in \(B\). Expanding:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不平衡可能在\(B\)中而不是\(B\)中。扩展：
- en: '|     p |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|     p |'
- en: '|    / \ |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|    / \ |'
- en: '|   q   C |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|   q   C |'
- en: '|  / \ |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  / \ |'
- en: '| A   r |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| A   r |'
- en: '|    / \ |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|    / \ |'
- en: '|   B1  B2 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|   B1  B2 |'
- en: 'Again, let’s record what we know about data order:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们记录一下我们对数据顺序的了解：
- en: \(A < q\).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A < q\)。
- en: \(q < B_1 < r\).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(q < B_1 < r\)。
- en: \(r < B_2 < p\).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(r < B_2 < p\)。
- en: \(p < C\).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(p < C\)。
- en: 'and sizes:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 和大小：
- en: Suppose the height of \(C\) is \(k\).
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设\(C\)的高度为\(k\)。
- en: The height of \(A\) must be \(k-1\) or \(k\).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(A\)的高度必须为\(k-1\)或\(k\)。
- en: The height of \(B_1\) or \(B_2\) must be \(k\), but not both (see exercise above
    [REF]). The other must be \(k-1\).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: \(B_1\)或\(B_2\)的高度必须为\(k\)，但不能同时为\(k\)（参见上面的练习[REF]）。另一个必须是\(k-1\)。
- en: 'We therefore have to somehow bring \(B_1\) and \(B_2\) one level closer to
    the root of the tree. By using the above data ordering knowledge, we can construct
    this tree:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须以某种方式使\(B_1\)和\(B_2\)靠近树的根节点。通过使用上述数据排序知识，我们可以构造这棵树：
- en: '|       p |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|       p |'
- en: '|      / \ |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|      / \ |'
- en: '|     r   C |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|     r   C |'
- en: '|    / \ |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|    / \ |'
- en: '|   q   B2 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|   q   B2 |'
- en: '|  / \ |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|  / \ |'
- en: '| A   B1 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| A   B1 |'
- en: 'Of course, if \(B_1\) is the problematic sub-tree, this still does not address
    the problem. However, we are now back to the previous (left-left) case; rotating
    gets us to:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果\(B_1\)是有问题的子树，这仍然不能解决问题。然而，我们现在回到了之前的（左-左）情况；旋转得到：
- en: '|       r |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|       r |'
- en: '|    /    \ |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|    /    \ |'
- en: '|   q      p |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|   q      p |'
- en: '|  / \    / \ |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|  / \    / \ |'
- en: '| A   B1 B2  C |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| A   B1 B2  C |'
- en: Now observe that we have precisely maintained the data ordering constraints.
    Furthermore, from the root, \(A\)’s lowest node is at height \(k+1\) or \(k+2\);
    so is \(B_1\)’s; so is \(B_2\)’s; and \(C\)’s is at \(k+2\).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在观察我们已经准确地保持了数据的排序约束。此外，从根开始，\(A\)的最低节点位于高度\(k+1\)或\(k+2\)；\(B_1\)的也是如此；\(B_2\)的也是如此；\(C\)的高度为\(k+2\)。
- en: 15.2.3.3Any Other Cases?
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3.3其他情况？
- en: Were we a little too glib before? In the left-right case we said that only one
    of \(B_1\) or \(B_2\) could be of height \(k\) (after insertion); the other had
    to be of height \(k-1\). Actually, all we can say for sure is that the other has
    to be at most height \(k-2\).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前是不是有点太轻率了？在左-右情况下，我们说\(B_1\)或\(B_2\)只能有一个是高度为\(k\)的（插入后）；另一个必须是高度为\(k-1\)的。实际上，我们唯一可以确定的是另一个必须至多为高度\(k-2\)。
- en: Exercise
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 练习
- en: ''
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Can the height of the other tree actually be \(k-2\) instead of \(k-1\)?
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个树的高度实际上可以是\(k-2\)而不是\(k-1\)吗？
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If so, does the solution above hold? Is there not still an imbalance of two
    in the resulting tree?
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是这样，上面的解决方案是否成立？结果树中仍然存在两个不平衡吗？
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Is there actually a bug in the above algorithm?
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述算法中实际上是否存在错误？
