["```\n// define the square function\nlet square x = x * x\n\n// define the sumOfSquares function\nlet sumOfSquares n = \n   [1..n] |> List.map square |> List.sum\n\n// try it\nsumOfSquares 100 \n```", "```\npublic static class SumOfSquaresHelper\n{\n   public static int Square(int i) {\n      return i * i;\n   }\n\n   public static int SumOfSquares(int n) {\n      int sum = 0;\n      for (int i = 1; i <= n; i++)\n      {\n         sum += Square(i);\n      }\n      return sum;\n   }\n} \n```", "```\nlet sumOfSquares n = \n   [1..n] \n   |> List.map square \n   |> List.sum \n```", "```\nval square : int -> int \n```", "```\n// define the square function\nlet squareF x = x * x\n\n// define the sumOfSquares function\nlet sumOfSquaresF n = \n   [1.0 .. n] |> List.map squareF |> List.sum  // \"1.0\" is a float\n\nsumOfSquaresF 100.0 \n```", "```\n// define the square function\nlet square x = x * x\n\n// test\nlet s2 = square 2\nlet s3 = square 3\nlet s4 = square 4 \n```", "```\npublic static class FunctionalSumOfSquaresHelper\n{\n   public static int SumOfSquares(int n) {\n      return Enumerable.Range(1, n)\n         .Select(i => i * i)\n         .Sum();\n   }\n} \n```", "```\nIf the list is empty, there is nothing to do.\nOtherwise: \n  1\\. Take the first element of the list\n  2\\. Find all elements in the rest of the list that \n      are less than the first element, and sort them. \n  3\\. Find all elements in the rest of the list that \n      are >= than the first element, and sort them\n  4\\. Combine the three parts together to get the final result: \n      (sorted smaller elements + firstElement + \n       sorted larger elements)\n\n```", "```\nlet rec quicksort list =\n   match list with\n   | [] ->                            // If the list is empty\n        []                            // return an empty list\n   | firstElem::otherElements ->      // If the list is not empty \n        let smallerElements =         // extract the smaller ones \n            otherElements             \n            |> List.filter (fun e -> e < firstElem) \n            |> quicksort              // and sort them\n        let largerElements =          // extract the large ones\n            otherElements \n            |> List.filter (fun e -> e >= firstElem)\n            |> quicksort              // and sort them\n        // Combine the 3 parts into a new list and return it\n        List.concat [smallerElements; [firstElem]; largerElements]\n\n//test\nprintfn \"%A\" (quicksort [1;5;23;18;9;1;3]) \n```", "```\nmatch x with\n| caseA -> something\n| caseB -> somethingElse \n```", "```\npublic class QuickSortHelper\n{\n   public static List<T> QuickSort<T>(List<T> values) \n      where T : IComparable\n   {\n      if (values.Count == 0)\n      {\n         return new List<T>();\n      }\n\n      //get the first element\n      T firstElement = values[0];\n\n      //get the smaller and larger elements\n      var smallerElements = new List<T>();\n      var largerElements = new List<T>();\n      for (int i = 1; i < values.Count; i++)  // i starts at 1\n      {                                       // not 0!\n         var elem = values[i];\n         if (elem.CompareTo(firstElement) < 0)\n         {\n            smallerElements.Add(elem);\n         }\n         else\n         {\n            largerElements.Add(elem);\n         }\n      }\n\n      //return the result\n      var result = new List<T>();\n      result.AddRange(QuickSort(smallerElements.ToList()));\n      result.Add(firstElement);\n      result.AddRange(QuickSort(largerElements.ToList()));\n      return result;\n   }\n} \n```", "```\npublic static class QuickSortExtension\n{\n    /// <summary>\n    /// Implement as an extension method for IEnumerable\n    /// </summary>\n    public static IEnumerable<T> QuickSort<T>(\n        this IEnumerable<T> values) where T : IComparable\n    {\n        if (values == null || !values.Any())\n        {\n            return new List<T>();\n        }\n\n        //split the list into the first element and the rest\n        var firstElement = values.First();\n        var rest = values.Skip(1);\n\n        //get the smaller and larger elements\n        var smallerElements = rest\n                .Where(i => i.CompareTo(firstElement) < 0)\n                .QuickSort();\n\n        var largerElements = rest\n                .Where(i => i.CompareTo(firstElement) >= 0)\n                .QuickSort();\n\n        //return the result\n        return smallerElements\n            .Concat(new List<T>{firstElement})\n            .Concat(largerElements);\n    }\n} \n```", "```\nif (values == null || !values.Any()) ... \n```", "```\nvar firstElement = values.First(); \n```", "```\nvar item = values.FirstOrDefault();  // instead of .First()\nif (item != null) \n{ \n   // do something if item is valid \n} \n```", "```\nlet rec quicksort2 = function\n   | [] -> []                         \n   | first::rest -> \n        let smaller,larger = List.partition ((>=) first) rest \n        List.concat [quicksort2 smaller; [first]; quicksort2 larger]\n\n// test code \nprintfn \"%A\" (quicksort2 [1;5;23;18;9;1;3]) \n```", "```\n// \"open\" brings a .NET namespace into visibility\nopen System.Net\nopen System\nopen System.IO\n\n// Fetch the contents of a web page\nlet fetchUrl callback url =        \n    let req = WebRequest.Create(Uri(url)) \n    use resp = req.GetResponse() \n    use stream = resp.GetResponseStream() \n    use reader = new IO.StreamReader(stream) \n    callback reader url \n```", "```\nclass WebPageDownloader\n{\n    public TResult FetchUrl<TResult>(\n        string url,\n        Func<string, StreamReader, TResult> callback)\n    {\n        var req = WebRequest.Create(url);\n        using (var resp = req.GetResponse())\n        {\n            using (var stream = resp.GetResponseStream())\n            {\n                using (var reader = new StreamReader(stream))\n                {\n                    return callback(url, reader);\n                }\n            }\n        }\n    }\n} \n```", "```\nlet myCallback (reader:IO.StreamReader) url = \n    let html = reader.ReadToEnd()\n    let html1000 = html.Substring(0,1000)\n    printfn \"Downloaded %s. First 1000 is %s\" url html1000\n    html      // return all the html\n\n//test\nlet google = fetchUrl myCallback \"http://google.com\" \n```", "```\n// build a function with the callback \"baked in\"\nlet fetchUrl2 = fetchUrl myCallback \n\n// test\nlet google = fetchUrl2 \"http://www.google.com\"\nlet bbc    = fetchUrl2 \"http://news.bbc.co.uk\"\n\n// test with a list of sites\nlet sites = [\"http://www.bing.com\";\n             \"http://www.google.com\";\n             \"http://www.yahoo.com\"]\n\n// process each site in the list\nsites |> List.map fetchUrl2 \n```", "```\n[Test]\npublic void TestFetchUrlWithCallback() {\n    Func<string, StreamReader, string> myCallback = (url, reader) =>\n    {\n        var html = reader.ReadToEnd();\n        var html1000 = html.Substring(0, 1000);\n        Console.WriteLine(\n            \"Downloaded {0}. First 1000 is {1}\", url,\n            html1000);\n        return html;\n    };\n\n    var downloader = new WebPageDownloader();\n    var google = downloader.FetchUrl(\"http://www.google.com\",\n                                      myCallback);\n\n    // test with a list of sites\n    var sites = new List<string> {\n        \"http://www.bing.com\",\n        \"http://www.google.com\",\n        \"http://www.yahoo.com\"};\n\n    // process each site in the list\n    sites.ForEach(site => downloader.FetchUrl(site, myCallback));\n} \n```", "```\nlet square x = x * x\n\n// functions as values\nlet squareclone = square\nlet result = [1..10] |> List.map squareclone\n\n// functions taking other functions as parameters\nlet execFunction aFunc aParam = aFunc aParam\nlet result2 = execFunction square 12 \n```", "```\nSELECT EmployeeName \nFROM Employees\nWHERE EmployeeID IN \n    (SELECT DISTINCT ManagerID FROM Employees)  -- subquery \n```", "```\n// statement-based code in C#\nint result;     \nif (aBool)\n{\n  result = 42; \n}\nConsole.WriteLine(\"result={0}\", result); \n```", "```\n// expression-based code in C#\nint result = (aBool) ? 42 : 0;\nConsole.WriteLine(\"result={0}\", result); \n```", "```\n//declare it\ntype IntAndBool = {intPart: int; boolPart: bool}\n\n//use it\nlet x = {intPart=1; boolPart=false} \n```", "```\n//declare it\ntype IntOrBool = \n    | IntChoice of int\n    | BoolChoice of bool\n\n//use it\nlet y = IntChoice 42\nlet z = BoolChoice true \n```", "```\nmatch booleanExpression with\n| true -> // true branch\n| false -> // false branch \n```", "```\nmatch aDigit with\n| 1 -> // Case when digit=1\n| 2 -> // Case when digit=2\n| _ -> // Case otherwise \n```", "```\nmatch aList with\n| [] -> \n     // Empty case \n| first::rest -> \n     // Case with at least one element.\n     // Process first element, and then call \n     // recursively with the rest of the list \n```", "```\ntype Shape =        // define a \"union\" of alternative structures\n| Circle of int \n| Rectangle of int * int\n| Polygon of (int * int) list\n| Point of (int * int) \n\nlet draw shape =    // define a function \"draw\" with a shape param\n  match shape with\n  | Circle radius -> \n      printfn \"The circle has a radius of %d\" radius\n  | Rectangle (height,width) -> \n      printfn \"The rectangle is %d high by %d wide\" height width\n  | Polygon points -> \n      printfn \"The polygon is made of these points %A\" points\n  | _ -> printfn \"I don't recognize this shape\"\n\nlet circle = Circle(10)\nlet rect = Rectangle(4,5)\nlet polygon = Polygon( [(1,1); (2,2); (3,3)])\nlet point = Point(2,3)\n\n[circle; rect; polygon; point] |> List.iter draw \n```", "```\n    | _ -> printfn \"I don't recognize this shape\" \n    ```", "```\npublic IEnumerable<TSource> Where<TSource>(\n    IEnumerable<TSource> source,\n    Func<TSource, bool> predicate\n    )\n{\n    //use the standard LINQ implementation\n    return source.Where(predicate);\n}\n\npublic IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(\n    IEnumerable<TSource> source,\n    Func<TSource, TKey> keySelector\n    )\n{\n    //use the standard LINQ implementation\n    return source.GroupBy(keySelector);\n} \n```", "```\nlet Where source predicate = \n    //use the standard F# implementation\n    Seq.filter predicate source\n\nlet GroupBy source keySelector = \n    //use the standard F# implementation\n    Seq.groupBy keySelector source \n```", "```\nlet i  = 1\nlet s = \"hello\"\nlet tuple  = s,i      // pack into tuple \nlet s2,i2  = tuple    // unpack\nlet list = [s2]       // type is string list \n```", "```\nlet sumLengths strList = \n    strList |> List.map String.length |> List.sum\n\n// function type is: string list -> int \n```", "```\nopen System\n\n// some \"record\" types\ntype Person = {FirstName:string; LastName:string; Dob:DateTime}\ntype Coord = {Lat:float; Long:float}\n\n// some \"union\" (choice) types\ntype TimePeriod = Hour | Day | Week | Year\ntype Temperature = C of int | F of int\ntype Appointment = OneTime of DateTime \n                   | Recurring of DateTime list \n```", "```\ntype PersonalName = {FirstName:string; LastName:string}\n\n// Addresses\ntype StreetAddress = {Line1:string; Line2:string; Line3:string }\n\ntype ZipCode =  ZipCode of string   \ntype StateAbbrev =  StateAbbrev of string\ntype ZipAndState =  {State:StateAbbrev; Zip:ZipCode }\ntype USAddress = {Street:StreetAddress; Region:ZipAndState}\n\ntype UKPostCode =  PostCode of string\ntype UKAddress = {Street:StreetAddress; Region:UKPostCode}\n\ntype InternationalAddress = {\n    Street:StreetAddress; Region:string; CountryName:string}\n\n// choice type  -- must be one of these three specific types\ntype Address = USAddress | UKAddress | InternationalAddress\n\n// Email\ntype Email = Email of string\n\n// Phone\ntype CountryPrefix = Prefix of int\ntype Phone = {CountryPrefix:CountryPrefix; LocalNumber:string}\n\ntype Contact = \n    {\n    PersonalName: PersonalName;\n    // \"option\" means it might be missing\n    Address: Address option;\n    Email: Email option;\n    Phone: Phone option;\n    }\n\n// Put it all together into a CustomerAccount type\ntype CustomerAccountId = AccountId of string\ntype CustomerType = Prospect | Active | Inactive\n\n// override equality and deny comparison\n[<CustomEquality; NoComparison>]\ntype CustomerAccount = \n    {\n    CustomerAccountId: CustomerAccountId;\n    CustomerType: CustomerType;\n    ContactInfo: Contact;\n    }\n\n    override this.Equals(other) =\n        match other with\n        | :? CustomerAccount as otherCust -> \n          (this.CustomerAccountId = otherCust.CustomerAccountId)\n        | _ -> false\n\n    override this.GetHashCode() = hash this.CustomerAccountId \n```", "```\npublic static int Product(int n) {\n    int product = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        product *= i;\n    }\n    return product;\n}\n\npublic static int SumOfOdds(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (i % 2 != 0) { sum += i; }\n    }\n    return sum;\n}\n\npublic static int AlternatingSum(int n) {\n    int sum = 0;\n    bool isNeg = true;\n    for (int i = 1; i <= n; i++)\n    {\n        if (isNeg)\n        {\n            sum -= i;\n            isNeg = false;\n        }\n        else\n        {\n            sum += i;\n            isNeg = true;\n        }\n    }\n    return sum;\n} \n```", "```\nlet product n = \n    let initialValue = 1\n    let action productSoFar x = productSoFar * x\n    [1..n] |> List.fold action initialValue\n\n//test\nproduct 10\n\nlet sumOfOdds n = \n    let initialValue = 0\n    let action sumSoFar x = if x%2=0 then sumSoFar else sumSoFar+x \n    [1..n] |> List.fold action initialValue\n\n//test\nsumOfOdds 10\n\nlet alternatingSum n = \n    let initialValue = (true,0)\n    let action (isNeg,sumSoFar) x = if isNeg then (false,sumSoFar-x)\n                                             else (true ,sumSoFar+x)\n    [1..n] |> List.fold action initialValue |> snd\n\n//test\nalternatingSum 100 \n```", "```\nlet sumOfSquaresWithFold n = \n    let initialValue = 0\n    let action sumSoFar x = sumSoFar + (x*x)\n    [1..n] |> List.fold action initialValue \n\n//test\nsumOfSquaresWithFold 100 \n```", "```\npublic static int ProductWithAggregate(int n) {\n    var initialValue = 1;\n    Func<int, int, int> action = (productSoFar, x) => \n        productSoFar * x;\n    return Enumerable.Range(1, n)\n            .Aggregate(initialValue, action);\n}\n\npublic static int SumOfOddsWithAggregate(int n) {\n    var initialValue = 0;\n    Func<int, int, int> action = (sumSoFar, x) =>\n        (x % 2 == 0) ? sumSoFar : sumSoFar + x;\n    return Enumerable.Range(1, n)\n        .Aggregate(initialValue, action);\n}\n\npublic static int AlternatingSumsWithAggregate(int n) {\n    var initialValue = Tuple.Create(true, 0);\n    Func<Tuple<bool, int>, int, Tuple<bool, int>> action =\n        (t, x) => t.Item1\n            ? Tuple.Create(false, t.Item2 - x)\n            : Tuple.Create(true, t.Item2 + x);\n    return Enumerable.Range(1, n)\n        .Aggregate(initialValue, action)\n        .Item2;\n} \n```", "```\npublic class NameAndSize\n{\n    public string Name;\n    public int Size;\n}\n\npublic static NameAndSize MaxNameAndSize(IList<NameAndSize> list) {\n    if (list.Count() == 0)\n    {\n        return default(NameAndSize);\n    }\n\n    var maxSoFar = list[0];\n    foreach (var item in list)\n    {\n        if (item.Size > maxSoFar.Size)\n        {\n            maxSoFar = item;\n        }\n    }\n    return maxSoFar;\n} \n```", "```\npublic class NameAndSize\n{\n    public string Name;\n    public int Size;\n}\n\npublic static NameAndSize MaxNameAndSize(IList<NameAndSize> list) {\n    if (!list.Any())\n    {\n        return default(NameAndSize);\n    }\n\n    var initialValue = list[0];\n    Func<NameAndSize, NameAndSize, NameAndSize> action =\n        (maxSoFar, x) => x.Size > maxSoFar.Size ? x : maxSoFar;\n    return list.Aggregate(initialValue, action);\n} \n```", "```\ntype NameAndSize= {Name:string;Size:int}\n\nlet maxNameAndSize list = \n\n    let innerMaxNameAndSize initialValue rest = \n        let action maxSoFar x = if maxSoFar.Size < x.Size then x else maxSoFar\n        rest |> List.fold action initialValue \n\n    // handle empty lists\n    match list with\n    | [] -> \n        None\n    | first::rest -> \n        let max = innerMaxNameAndSize first rest\n        Some max \n```", "```\n//test\nlet list = [\n    {Name=\"Alice\"; Size=10}\n    {Name=\"Bob\"; Size=1}\n    {Name=\"Carol\"; Size=12}\n    {Name=\"David\"; Size=5}\n    ]    \nmaxNameAndSize list\nmaxNameAndSize [] \n```", "```\n// use the built in function\nlist |> List.maxBy (fun item -> item.Size)\n[] |> List.maxBy (fun item -> item.Size) \n```", "```\nlet maxNameAndSize list = \n    match list with\n    | [] -> \n        None\n    | _ -> \n        let max = list |> List.maxBy (fun item -> item.Size)\n        Some max \n```", "```\n// building blocks\nlet add2 x = x + 2\nlet mult3 x = x * 3\nlet square x = x * x\n\n// test\n[1..10] |> List.map add2 |> printfn \"%A\"\n[1..10] |> List.map mult3 |> printfn \"%A\"\n[1..10] |> List.map square |> printfn \"%A\" \n```", "```\n// new composed functions\nlet add2ThenMult3 = add2 >> mult3\nlet mult3ThenSquare = mult3 >> square \n```", "```\nlet add2ThenMult3 x = mult3 (add2 x)\nlet mult3ThenSquare x = square (mult3 x) \n```", "```\n// test\nadd2ThenMult3 5\nmult3ThenSquare 5\n[1..10] |> List.map add2ThenMult3 |> printfn \"%A\"\n[1..10] |> List.map mult3ThenSquare |> printfn \"%A\" \n```", "```\n// helper functions;\nlet logMsg msg x = printf \"%s%i\" msg x; x     //without linefeed \nlet logMsgN msg x = printfn \"%s%i\" msg x; x   //with linefeed\n\n// new composed function with new improved logging!\nlet mult3ThenSquareLogged = \n   logMsg \"before=\" \n   >> mult3 \n   >> logMsg \" after mult3=\" \n   >> square\n   >> logMsgN \" result=\" \n\n// test\nmult3ThenSquareLogged 5\n[1..10] |> List.map mult3ThenSquareLogged //apply to a whole list \n```", "```\nlet listOfFunctions = [\n   mult3; \n   square;\n   add2;\n   logMsgN \"result=\";\n   ]\n\n// compose all functions in the list into a single one\nlet allFunctions = List.reduce (>>) listOfFunctions \n\n//test\nallFunctions 5 \n```", "```\n// set up the vocabulary\ntype DateScale = Hour | Hours | Day | Days | Week | Weeks\ntype DateDirection = Ago | Hence\n\n// define a function that matches on the vocabulary\nlet getDate interval scale direction =\n    let absHours = match scale with\n                   | Hour | Hours -> 1 * interval\n                   | Day | Days -> 24 * interval\n                   | Week | Weeks -> 24 * 7 * interval\n    let signedHours = match direction with\n                      | Ago -> -1 * absHours \n                      | Hence ->  absHours \n    System.DateTime.Now.AddHours(float signedHours)\n\n// test some examples\nlet example1 = getDate 5 Days Ago\nlet example2 = getDate 1 Hour Hence\n\n// the C# equivalent would probably be more like this:\n// getDate().Interval(5).Days().Ago()\n// getDate().Interval(1).Hour().Hence() \n```", "```\nFluentShape.Default\n   .SetColor(\"red\")\n   .SetLabel(\"box\")\n   .OnClick( s => Console.Write(\"clicked\") ); \n```", "```\n// create an underlying type\ntype FluentShape = {\n    label : string; \n    color : string; \n    onClick : FluentShape->FluentShape // a function type\n    } \n```", "```\nlet defaultShape = \n    {label=\"\"; color=\"\"; onClick=fun shape->shape}\n\nlet click shape = \n    shape.onClick shape\n\nlet display shape = \n    printfn \"My label=%s and my color=%s\" shape.label shape.color\n    shape   //return same shape \n```", "```\nlet setLabel label shape = \n   {shape with FluentShape.label = label}\n\nlet setColor color shape = \n   {shape with FluentShape.color = color}\n\n//add a click action to what is already there\nlet appendClickAction action shape = \n   {shape with FluentShape.onClick = shape.onClick >> action} \n```", "```\n// Compose two \"base\" functions to make a compound function.\nlet setRedBox = setColor \"red\" >> setLabel \"box\" \n\n// Create another function by composing with previous function.\n// It overrides the color value but leaves the label alone.\nlet setBlueBox = setRedBox >> setColor \"blue\"  \n\n// Make a special case of appendClickAction\nlet changeColorOnClick color = appendClickAction (setColor color) \n```", "```\n//setup some test values\nlet redBox = defaultShape |> setRedBox\nlet blueBox = defaultShape |> setBlueBox \n\n// create a shape that changes color when clicked\nredBox \n    |> display\n    |> changeColorOnClick \"green\"\n    |> click\n    |> display  // new version after the click\n\n// create a shape that changes label and color when clicked\nblueBox \n    |> display\n    |> appendClickAction (setLabel \"box2\" >> setColor \"green\")  \n    |> click\n    |> display  // new version after the click \n```", "```\nlet rainbow =\n    [\"red\";\"orange\";\"yellow\";\"green\";\"blue\";\"indigo\";\"violet\"]\n\nlet showRainbow = \n    let setColorAndDisplay color = setColor color >> display \n    rainbow \n    |> List.map setColorAndDisplay \n    |> List.reduce (>>)\n\n// test the showRainbow function\ndefaultShape |> showRainbow \n```", "```\n//matching tuples directly\nlet firstPart, secondPart, _ =  (1,2,3)  // underscore means ignore\n\n//matching lists directly\nlet elem1::elem2::rest = [1..10]       // ignore the warning for now\n\n//matching lists inside a match..with\nlet listMatcher aList = \n    match aList with\n    | [] -> printfn \"the list is empty\" \n    | [firstElement] -> printfn \"the list has one element %A \" firstElement \n    | [first; second] -> printfn \"list is %A and %A\" first second \n    | _ -> printfn \"the list has more than two elements\"\n\nlistMatcher [1;2;3;4]\nlistMatcher [1;2]\nlistMatcher [1]\nlistMatcher [] \n```", "```\n// create some types\ntype Address = { Street: string; City: string; }   \ntype Customer = { ID: int; Name: string; Address: Address}   \n\n// create a customer \nlet customer1 = { ID = 1; Name = \"Bob\"; \n      Address = {Street=\"123 Main\"; City=\"NY\" } }     \n\n// extract name only\nlet { Name=name1 } =  customer1 \nprintfn \"The customer is called %s\" name1\n\n// extract name and id \nlet { ID=id2; Name=name2; } =  customer1 \nprintfn \"The customer called %s has id %i\" name2 id2\n\n// extract name and address\nlet { Name=name3;  Address={Street=street3}  } =  customer1   \nprintfn \"The customer is called %s and lives on %s\" name3 street3 \n```", "```\ntype PersonalName = {FirstName:string; LastName:string} \n```", "```\nclass ImmutablePersonalName\n{\n    public ImmutablePersonalName(string firstName, string lastName) {\n        this.FirstName = firstName;\n        this.LastName = lastName;\n    }\n\n    public string FirstName { get; private set; }\n    public string LastName { get; private set; }\n} \n```", "```\ntype USAddress = \n   {Street:string; City:string; State:string; Zip:string}\ntype UKAddress = \n   {Street:string; Town:string; PostCode:string}\ntype Address = US of USAddress | UK of UKAddress\ntype Person = \n   {Name:string; Address:Address}\n\nlet alice = {\n   Name=\"Alice\"; \n   Address=US {Street=\"123 Main\";City=\"LA\";State=\"CA\";Zip=\"91201\"}}\nlet bob = {\n   Name=\"Bob\"; \n   Address=UK {Street=\"221b Baker St\";Town=\"London\";PostCode=\"NW1 6XE\"}} \n\nprintfn \"Alice is %A\" alice\nprintfn \"Bob is %A\" bob \n```", "```\nAlice is {Name = \"Alice\";\n Address = US {Street = \"123 Main\";\n               City = \"LA\";\n               State = \"CA\";\n               Zip = \"91201\";};} \n```", "```\ntype PersonalName = {FirstName:string; LastName:string}\nlet alice1 = {FirstName=\"Alice\"; LastName=\"Adams\"}\nlet alice2 = {FirstName=\"Alice\"; LastName=\"Adams\"}\nlet bob1 = {FirstName=\"Bob\"; LastName=\"Bishop\"}\n\n//test\nprintfn \"alice1=alice2 is %A\" (alice1=alice2)\nprintfn \"alice1=bob1 is %A\" (alice1=bob1) \n```", "```\n type Suit = Club | Diamond | Spade | Heart\ntype Rank = Two | Three | Four | Five | Six | Seven | Eight \n            | Nine | Ten | Jack | Queen | King | Ace \n```", "```\nlet compareCard card1 card2 = \n    if card1 < card2 \n    then printfn \"%A is greater than %A\" card2 card1 \n    else printfn \"%A is greater than %A\" card1 card2 \n```", "```\nlet aceHearts = Heart, Ace\nlet twoHearts = Heart, Two\nlet aceSpades = Spade, Ace\n\ncompareCard aceHearts twoHearts \ncompareCard twoHearts aceSpades \n```", "```\nlet hand = [ Club,Ace; Heart,Three; Heart,Ace; \n             Spade,Jack; Diamond,Two; Diamond,Ace ]\n\n//instant sorting!\nList.sort hand |> printfn \"sorted hand is (low to high) %A\" \n```", "```\nList.max hand |> printfn \"high card is %A\"\nList.min hand |> printfn \"low card is %A\" \n```", "```\ninterface ICalculator \n{\n   int Calculate(int input);\n} \n```", "```\nclass AddingCalculator: ICalculator\n{\n   public int Calculate(int input) { return input + 1; }\n} \n```", "```\nclass LoggingCalculator: ICalculator\n{\n   ICalculator _innerCalculator;\n\n   LoggingCalculator(ICalculator innerCalculator)\n   {\n      _innerCalculator = innerCalculator;\n   }\n\n   public int Calculate(int input) { \n      Console.WriteLine(\"input is {0}\", input);\n      var result  = _innerCalculator.Calculate(input);\n      Console.WriteLine(\"result is {0}\", result);\n      return result; \n   }\n} \n```", "```\nlet addingCalculator input = input + 1\n\nlet loggingCalculator innerCalculator input = \n   printfn \"input is %A\" input\n   let result = innerCalculator input\n   printfn \"result is %A\" result\n   result \n```", "```\nlet add1 input = input + 1\nlet times2 input = input * 2\n\nlet genericLogger anyFunc input = \n   printfn \"input is %A\" input   //log the input\n   let result = anyFunc input    //evaluate the function\n   printfn \"result is %A\" result //log the result\n   result                        //return the result\n\nlet add1WithLogging = genericLogger add1\nlet times2WithLogging = genericLogger times2 \n```", "```\n// test\nadd1WithLogging 3\ntimes2WithLogging 3\n\n[1..5] |> List.map add1WithLogging \n```", "```\nlet genericTimer anyFunc input = \n   let stopwatch = System.Diagnostics.Stopwatch()\n   stopwatch.Start() \n   let result = anyFunc input  //evaluate the function\n   printfn \"elapsed ms is %A\" stopwatch.ElapsedMilliseconds\n   result\n\nlet add1WithTimer = genericTimer add1WithLogging \n\n// test\nadd1WithTimer 3 \n```", "```\ntype Animal(noiseMakingStrategy) = \n   member this.MakeNoise = \n      noiseMakingStrategy() |> printfn \"Making noise %s\" \n\n// now create a cat \nlet meowing() = \"Meow\"\nlet cat = Animal(meowing)\ncat.MakeNoise\n\n// .. and a dog\nlet woofOrBark() = if (System.DateTime.Now.Second % 2 = 0) \n                   then \"Woof\" else \"Bark\"\nlet dog = Animal(woofOrBark)\ndog.MakeNoise\ndog.MakeNoise  //try again a second later \n```", "```\n// define a adding function\nlet add x y = x + y\n\n// normal use \nlet z = add 1 2 \n```", "```\nlet add42 = add 42 \n```", "```\n// use the new function\nadd42 2\nadd42 3 \n```", "```\nlet genericLogger anyFunc input = \n   printfn \"input is %A\" input   //log the input\n   let result = anyFunc input    //evaluate the function\n   printfn \"result is %A\" result //log the result\n   result                        //return the result \n```", "```\nlet genericLogger before after anyFunc input = \n   before input               //callback for custom behavior\n   let result = anyFunc input //evaluate the function\n   after result               //callback for custom behavior\n   result                     //return the result \n```", "```\nlet add1 input = input + 1\n\n// reuse case 1\ngenericLogger \n    (fun x -> printf \"before=%i. \" x) // function to call before \n    (fun x -> printfn \" after=%i.\" x) // function to call after\n    add1                              // main function\n    2                                 // parameter \n\n// reuse case 2\ngenericLogger\n    (fun x -> printf \"started with=%i \" x) // different callback \n    (fun x -> printfn \" ended with=%i\" x) \n    add1                              // main function\n    2                                 // parameter \n```", "```\n// define a reusable function with the \"callback\" functions fixed\nlet add1WithConsoleLogging = \n    genericLogger\n        (fun x -> printf \"input=%i. \" x) \n        (fun x -> printfn \" result=%i\" x)\n        add1\n        // last parameter NOT defined here yet! \n```", "```\nadd1WithConsoleLogging 2\nadd1WithConsoleLogging 3\nadd1WithConsoleLogging 4\n[1..5] |> List.map add1WithConsoleLogging \n```", "```\npublic class GenericLoggerHelper<TInput, TResult>\n{\n    public TResult GenericLogger(\n        Action<TInput> before,\n        Action<TResult> after,\n        Func<TInput, TResult> aFunc,\n        TInput input)\n    {\n        before(input);             //callback for custom behavior\n        var result = aFunc(input); //do the function\n        after(result);             //callback for custom behavior\n        return result;\n    }\n} \n```", "```\n[NUnit.Framework.Test]\npublic void TestGenericLogger() {\n    var sut = new GenericLoggerHelper<int, int>();\n    sut.GenericLogger(\n        x => Console.Write(\"input={0}. \", x),\n        x => Console.WriteLine(\" result={0}\", x),\n        x => x + 1,\n        3);\n} \n```", "```\n// create an active pattern\nlet (|Int|_|) str =\n   match System.Int32.TryParse(str) with\n   | (true,int) -> Some(int)\n   | _ -> None\n\n// create an active pattern\nlet (|Bool|_|) str =\n   match System.Boolean.TryParse(str) with\n   | (true,bool) -> Some(bool)\n   | _ -> None \n```", "```\n// create a function to call the patterns\nlet testParse str = \n    match str with\n    | Int i -> printfn \"The value is an int '%i'\" i\n    | Bool b -> printfn \"The value is a bool '%b'\" b\n    | _ -> printfn \"The value '%s' is something else\" str\n\n// test\ntestParse \"12\"\ntestParse \"true\"\ntestParse \"abc\" \n```", "```\n// create an active pattern\nopen System.Text.RegularExpressions\nlet (|FirstRegexGroup|_|) pattern input =\n   let m = Regex.Match(input,pattern) \n   if (m.Success) then Some m.Groups.[1].Value else None \n```", "```\n// create a function to call the pattern\nlet testRegex str = \n    match str with\n    | FirstRegexGroup \"http://(.*?)/(.*)\" host -> \n           printfn \"The value is a url and the host is %s\" host\n    | FirstRegexGroup \".*?@(.*)\" host -> \n           printfn \"The value is an email and the host is %s\" host\n    | _ -> printfn \"The value '%s' is something else\" str\n\n// test\ntestRegex \"http://google.com/test\"\ntestRegex \"alice@hotmail.com\" \n```", "```\n// setup the active patterns\nlet (|MultOf3|_|) i = if i % 3 = 0 then Some MultOf3 else None\nlet (|MultOf5|_|) i = if i % 5 = 0 then Some MultOf5 else None\n\n// the main function\nlet fizzBuzz i = \n  match i with\n  | MultOf3 & MultOf5 -> printf \"FizzBuzz, \" \n  | MultOf3 -> printf \"Fizz, \" \n  | MultOf5 -> printf \"Buzz, \" \n  | _ -> printf \"%i, \" i\n\n// test\n[1..20] |> List.iter fizzBuzz \n```", "```\npublic List<int> MakeList() {\n   return new List<int> {1,2,3,4,5,6,7,8,9,10};\n}\n\npublic List<int> OddNumbers(List<int> list) { \n   // some code\n}\n\npublic List<int> EvenNumbers(List<int> list) { \n   // some code\n} \n```", "```\npublic void Test() { \n   var odds = OddNumbers(MakeList()); \n   var evens = EvenNumbers(MakeList());\n   // assert odds = 1,3,5,7,9 -- OK!\n   // assert evens = 2,4,6,8,10 -- OK!\n} \n```", "```\npublic void RefactoredTest() { \n   var list = MakeList();\n   var odds = OddNumbers(list); \n   var evens = EvenNumbers(list);\n   // assert odds = 1,3,5,7,9 -- OK!\n   // assert evens = 2,4,6,8,10 -- FAIL!\n} \n```", "```\npublic IEnumerable<int> MakeList() {}\npublic List<int> OddNumbers(IEnumerable<int> list) {} \npublic List<int> EvenNumbers(IEnumerable <int> list) {} \n```", "```\n// immutable list\nlet list = [1;2;3;4]    \n\ntype PersonalName = {FirstName:string; LastName:string}\n// immutable person\nlet john = {FirstName=\"John\"; LastName=\"Doe\"} \n```", "```\nlet alice = {john with FirstName=\"Alice\"} \n```", "```\n// create an immutable list\nlet list1 = [1;2;3;4]   \n\n// prepend to make a new list\nlet list2 = 0::list1    \n\n// get the last 4 of the second list \nlet list3 = list2.Tail\n\n// the two lists are the identical object in memory!\nSystem.Object.ReferenceEquals(list1,list3) \n```", "```\nenum State { New, Draft, Published, Inactive, Discontinued }\nvoid HandleState(State state) {\n    switch (state)\n    {\n        case State.Inactive: // code for Inactive\n            break;\n        case State.Draft: // code for Draft\n            break;\n        case State.New: // code for New\n            break;\n        case State.Discontinued: // code for Discontinued\n            break;\n    }\n} \n```", "```\ntype State = New | Draft | Published | Inactive | Discontinued\nlet handleState state = \n   match state with\n   | Inactive -> () // code for Inactive\n   | Draft -> () // code for Draft\n   | New -> () // code for New\n   | Discontinued -> () // code for Discontinued \n```", "```\nif (myObject != null)\n{\n  // do something\n} \n```", "```\nlet getFileInfo filePath =\n   let fi = new System.IO.FileInfo(filePath)\n   if fi.Exists then Some(fi) else None\n\nlet goodFileName = \"good.txt\"\nlet badFileName = \"bad.txt\"\n\nlet goodFileInfo = getFileInfo goodFileName // Some(fileinfo)\nlet badFileInfo = getFileInfo badFileName   // None \n```", "```\nmatch goodFileInfo with\n  | Some fileInfo -> \n      printfn \"the file %s exists\" fileInfo.FullName\n  | None -> \n      printfn \"the file doesn't exist\" \n\nmatch badFileInfo with\n  | Some fileInfo -> \n      printfn \"the file %s exists\" fileInfo.FullName\n  | None -> \n      printfn \"the file doesn't exist\" \n```", "```\npublic IList<float> MovingAverages(IList<int> list) {\n    var averages = new List<float>();\n    for (int i = 0; i < list.Count; i++)\n    {\n        var avg = (list[i] + list[i+1]) / 2;\n        averages.Add(avg);\n    }\n    return averages;\n} \n```", "```\nlet rec movingAverages list = \n    match list with\n    // if input is empty, return an empty list\n    | [] -> []\n    // otherwise process pairs of items from the input \n    | x::y::rest -> \n        let avg = (x+y)/2.0 \n        //build the result by recursing the rest of the list\n        avg :: movingAverages (y::rest) \n```", "```\nlet rec movingAverages list = \n    match list with\n    // if input is empty, return an empty list\n    | [] -> []\n    // otherwise process pairs of items from the input \n    | x::y::rest -> \n        let avg = (x+y)/2.0 \n        //build the result by recursing the rest of the list\n        avg :: movingAverages (y::rest)\n    // for one item, return an empty list\n    | [_] -> []\n\n// test\nmovingAverages [1.0]\nmovingAverages [1.0; 2.0]\nmovingAverages [1.0; 2.0; 3.0] \n```", "```\n// define a \"union\" of two different alternatives\ntype Result<'a, 'b> = \n    | Success of 'a  // 'a means generic type. The actual type\n                     // will be determined when it is used.\n    | Failure of 'b  // generic failure type as well\n\n// define all possible errors\ntype FileErrorReason = \n    | FileNotFound of string\n    | UnauthorizedAccess of string * System.Exception\n\n// define a low level function in the bottom layer\nlet performActionOnFile action filePath =\n   try\n      //open file, do the action and return the result\n      use sr = new System.IO.StreamReader(filePath:string)\n      let result = action sr  //do the action to the reader\n      sr.Close()\n      Success (result)        // return a Success\n   with      // catch some exceptions and convert them to errors\n      | :? System.IO.FileNotFoundException as ex \n          -> Failure (FileNotFound filePath)      \n      | :? System.Security.SecurityException as ex \n          -> Failure (UnauthorizedAccess (filePath,ex))  \n      // other exceptions are unhandled \n```", "```\n// a function in the middle layer\nlet middleLayerDo action filePath = \n    let fileResult = performActionOnFile action filePath\n    // do some stuff\n    fileResult //return\n\n// a function in the top layer\nlet topLayerDo action filePath = \n    let fileResult = middleLayerDo action filePath\n    // do some stuff\n    fileResult //return \n```", "```\n/// get the first line of the file\nlet printFirstLineOfFile filePath = \n    let fileResult = topLayerDo (fun fs->fs.ReadLine()) filePath\n\n    match fileResult with\n    | Success result -> \n        // note type-safe string printing with %s\n        printfn \"first line is: '%s'\" result   \n    | Failure reason -> \n       match reason with  // must match EVERY reason\n       | FileNotFound file -> \n           printfn \"File not found: %s\" file\n       | UnauthorizedAccess (file,_) -> \n           printfn \"You do not have access to the file: %s\" file \n```", "```\n/// get the length of the text in the file\nlet printLengthOfFile filePath = \n   let fileResult = \n     topLayerDo (fun fs->fs.ReadToEnd().Length) filePath\n\n   match fileResult with\n   | Success result -> \n      // note type-safe int printing with %i\n      printfn \"length is: %i\" result       \n   | Failure _ -> \n      printfn \"An error happened but I don't want to be specific\" \n```", "```\n/// write some text to a file\nlet writeSomeText filePath someText = \n    use writer = new System.IO.StreamWriter(filePath:string)\n    writer.WriteLine(someText:string)\n    writer.Close()\n\nlet goodFileName = \"good.txt\"\nlet badFileName = \"bad.txt\"\n\nwriteSomeText goodFileName \"hello\" \n```", "```\nprintFirstLineOfFile goodFileName \nprintLengthOfFile goodFileName \n\nprintFirstLineOfFile badFileName \nprintLengthOfFile badFileName \n```", "```\ntype Result<'a, 'b> = \n    | Success of 'a \n    | Failure of 'b\n    | Indeterminate \n```", "```\ntype Result<'a> = \n    | Success of 'a \n```", "```\n//define a \"safe\" email address type\ntype EmailAddress = EmailAddress of string\n\n//define a function that uses it \nlet sendEmail (EmailAddress email) = \n   printfn \"sent an email to %s\" email\n\n//try to send one\nlet aliceEmail = EmailAddress \"alice@example.com\"\nsendEmail aliceEmail\n\n//try to send a plain string\nsendEmail \"bob@example.com\"   //error \n```", "```\nlet printingExample = \n   printf \"an int %i\" 2                        // ok\n   printf \"an int %i\" 2.0                      // wrong type\n   printf \"an int %i\" \"hello\"                  // wrong type\n   printf \"an int %i\"                          // missing param\n\n   printf \"a string %s\" \"hello\"                // ok\n   printf \"a string %s\" 2                      // wrong type\n   printf \"a string %s\"                        // missing param\n   printf \"a string %s\" \"he\" \"lo\"              // too many params\n\n   printf \"an int %i and string %s\" 2 \"hello\"  // ok\n   printf \"an int %i and string %s\" \"hello\" 2  // wrong type\n   printf \"an int %i and string %s\" 2          // missing param \n```", "```\nlet printAString x = printf \"%s\" x\nlet printAnInt x = printf \"%i\" x\n\n// the result is:\n// val printAString : string -> unit  //takes a string parameter\n// val printAnInt : int -> unit       //takes an int parameter \n```", "```\n// define some measures\n[<Measure>] \ntype cm\n\n[<Measure>] \ntype inches\n\n[<Measure>] \ntype feet =\n   // add a conversion function\n   static member toInches(feet : float<feet>) : float<inches> = \n      feet * 12.0<inches/feet>\n\n// define some values\nlet meter = 100.0<cm>\nlet yard = 3.0<feet>\n\n//convert to different measure\nlet yardInInches = feet.toInches(yard)\n\n// can't mix and match!\nyard + meter\n\n// now define some currencies\n[<Measure>] \ntype GBP\n\n[<Measure>] \ntype USD\n\nlet gbp10 = 10.0<GBP>\nlet usd10 = 10.0<USD>\ngbp10 + gbp10             // allowed: same currency\ngbp10 + usd10             // not allowed: different currency\ngbp10 + 1.0               // not allowed: didn't specify a currency\ngbp10 + 1.0<_>            // allowed using wildcard \n```", "```\nusing System;\nvar obj = new Object();\nvar ex = new Exception();\nvar b = (obj == ex); \n```", "```\nopen System\nlet obj = new Object()\nlet ex = new Exception()\nlet b = (obj = ex) \n```", "```\n// deny comparison\n[<NoEquality; NoComparison>]\ntype CustomerAccount = {CustomerAccountId: int}\n\nlet x = {CustomerAccountId = 1}\n\nx = x       // error!\nx.CustomerAccountId = x.CustomerAccountId // no error \n```", "```\npublic class NaiveShoppingCart<TItem>\n{\n   private List<TItem> items;\n   private decimal paidAmount;\n\n   public NaiveShoppingCart()\n   {\n      this.items = new List<TItem>();\n      this.paidAmount = 0;\n   }\n\n   /// Is cart paid for?\n   public bool IsPaidFor { get { return this.paidAmount > 0; } }\n\n   /// Readonly list of items\n   public IEnumerable<TItem> Items { get {return this.items; } }\n\n   /// add item only if not paid for\n   public void AddItem(TItem item)\n   {\n      if (!this.IsPaidFor)\n      {\n         this.items.Add(item);\n      }\n   }\n\n   /// remove item only if not paid for\n   public void RemoveItem(TItem item)\n   {\n      if (!this.IsPaidFor)\n      {\n         this.items.Remove(item);\n      }\n   }\n\n   /// pay for the cart\n   public void Pay(decimal amount)\n   {\n      if (!this.IsPaidFor)\n      {\n         this.paidAmount = amount;\n      }\n   }\n} \n```", "```\nif (!this.IsPaidFor) { do something } \n```", "```\ntype CartItem = string    // placeholder for a more complicated type\n\ntype EmptyState = NoItems // don't use empty list! We want to\n                          // force clients to handle this as a \n                          // separate case. E.g. \"you have no \n                          // items in your cart\"\n\ntype ActiveState = { UnpaidItems : CartItem list; }\ntype PaidForState = { PaidItems : CartItem list; \n                      Payment : decimal}\n\ntype Cart = \n    | Empty of EmptyState \n    | Active of ActiveState \n    | PaidFor of PaidForState \n```", "```\n// =============================\n// operations on empty state\n// =============================\n\nlet addToEmptyState item = \n   // returns a new Active Cart\n   Cart.Active {UnpaidItems=[item]}\n\n// =============================\n// operations on active state\n// =============================\n\nlet addToActiveState state itemToAdd = \n   let newList = itemToAdd :: state.UnpaidItems\n   Cart.Active {state with UnpaidItems=newList }\n\nlet removeFromActiveState state itemToRemove = \n   let newList = state.UnpaidItems \n                 |> List.filter (fun i -> i<>itemToRemove)\n\n   match newList with\n   | [] -> Cart.Empty NoItems\n   | _ -> Cart.Active {state with UnpaidItems=newList} \n\nlet payForActiveState state amount = \n   // returns a new PaidFor Cart\n   Cart.PaidFor {PaidItems=state.UnpaidItems; Payment=amount} \n```", "```\ntype EmptyState with\n   member this.Add = addToEmptyState \n\ntype ActiveState with\n   member this.Add = addToActiveState this \n   member this.Remove = removeFromActiveState this \n   member this.Pay = payForActiveState this \n```", "```\nlet addItemToCart cart item =  \n   match cart with\n   | Empty state -> state.Add item\n   | Active state -> state.Add item\n   | PaidFor state ->  \n       printfn \"ERROR: The cart is paid for\"\n       cart   \n\nlet removeItemFromCart cart item =  \n   match cart with\n   | Empty state -> \n      printfn \"ERROR: The cart is empty\"\n      cart   // return the cart \n   | Active state -> \n      state.Remove item\n   | PaidFor state ->  \n      printfn \"ERROR: The cart is paid for\"\n      cart   // return the cart\n\nlet displayCart cart  =  \n   match cart with\n   | Empty state -> \n      printfn \"The cart is empty\"   // can't do state.Items\n   | Active state -> \n      printfn \"The cart contains %A unpaid items\"\n                                                state.UnpaidItems\n   | PaidFor state ->  \n      printfn \"The cart contains %A paid items. Amount paid: %f\"\n                                    state.PaidItems state.Payment\n\ntype Cart with\n   static member NewCart = Cart.Empty NoItems\n   member this.Add = addItemToCart this \n   member this.Remove = removeItemFromCart this \n   member this.Display = displayCart this \n```", "```\nlet emptyCart = Cart.NewCart\nprintf \"emptyCart=\"; emptyCart.Display\n\nlet cartA = emptyCart.Add \"A\"\nprintf \"cartA=\"; cartA.Display \n```", "```\nlet cartAB = cartA.Add \"B\"\nprintf \"cartAB=\"; cartAB.Display\n\nlet cartB = cartAB.Remove \"A\"\nprintf \"cartB=\"; cartB.Display\n\nlet emptyCart2 = cartB.Remove \"B\"\nprintf \"emptyCart2=\"; emptyCart2.Display \n```", "```\nlet emptyCart3 = emptyCart2.Remove \"B\"    //error\nprintf \"emptyCart3=\"; emptyCart3.Display \n```", "```\n//  try to pay for cartA\nlet cartAPaid = \n    match cartA with\n    | Empty _ | PaidFor _ -> cartA \n    | Active state -> state.Pay 100m\nprintf \"cartAPaid=\"; cartAPaid.Display \n```", "```\n//  try to pay for emptyCart\nlet emptyCartPaid = \n    match emptyCart with\n    | Empty _ | PaidFor _ -> emptyCart\n    | Active state -> state.Pay 100m\nprintf \"emptyCartPaid=\"; emptyCartPaid.Display \n```", "```\n//  try to pay for cartAB \nlet cartABPaid = \n    match cartAB with\n    | Empty _ | PaidFor _ -> cartAB // return the same cart\n    | Active state -> state.Pay 100m\n\n//  try to pay for cartAB again\nlet cartABPaidAgain = \n    match cartABPaid with\n    | Empty _ | PaidFor _ -> cartABPaid  // return the same cart\n    | Active state -> state.Pay 100m \n```", "```\nmatch cartABPaid with\n| Empty state -> state.Pay 100m\n| PaidFor state -> state.Pay 100m\n| Active state -> state.Pay 100m \n```", "```\nvar paidCart = cartA.Do(\n    // lambda for Empty state\n    state => cartA,  \n    // lambda for Active state\n    state => state.Pay(100),\n    // lambda for Paid state\n    state => cartA); \n```", "```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace WhyUseFsharp\n{\n\n    public class ShoppingCart<TItem>\n    {\n\n        #region ShoppingCart State classes\n\n        /// <summary>\n        /// Represents the Empty state\n        /// </summary>\n        public class EmptyState\n        {\n            public ShoppingCart<TItem> Add(TItem item)\n            {\n                var newItems = new[] { item };\n                var newState = new ActiveState(newItems);\n                return FromState(newState);\n            }\n        }\n\n        /// <summary>\n        /// Represents the Active state\n        /// </summary>\n        public class ActiveState\n        {\n            public ActiveState(IEnumerable<TItem> items)\n            {\n                Items = items;\n            }\n\n            public IEnumerable<TItem> Items { get; private set; }\n\n            public ShoppingCart<TItem> Add(TItem item)\n            {\n                var newItems = new List<TItem>(Items) {item};\n                var newState = new ActiveState(newItems);\n                return FromState(newState);\n            }\n\n            public ShoppingCart<TItem> Remove(TItem item)\n            {\n                var newItems = new List<TItem>(Items);\n                newItems.Remove(item);\n                if (newItems.Count > 0)\n                {\n                    var newState = new ActiveState(newItems);\n                    return FromState(newState);\n                }\n                else\n                {\n                    var newState = new EmptyState();\n                    return FromState(newState);\n                }\n            }\n\n            public ShoppingCart<TItem> Pay(decimal amount)\n            {\n                var newState = new PaidForState(Items, amount);\n                return FromState(newState);\n            }\n\n        }\n\n        /// <summary>\n        /// Represents the Paid state\n        /// </summary>\n        public class PaidForState\n        {\n            public PaidForState(IEnumerable<TItem> items, decimal amount)\n            {\n                Items = items.ToList();\n                Amount = amount;\n            }\n\n            public IEnumerable<TItem> Items { get; private set; }\n            public decimal Amount { get; private set; }\n        }\n\n        #endregion ShoppingCart State classes\n\n        //====================================\n        // Execute of shopping cart proper\n        //====================================\n\n        private enum Tag { Empty, Active, PaidFor }\n        private readonly Tag _tag = Tag.Empty;\n        private readonly object _state;       //has to be a generic object\n\n        /// <summary>\n        /// Private ctor. Use FromState instead\n        /// </summary>\n        private ShoppingCart(Tag tagValue, object state)\n        {\n            _state = state;\n            _tag = tagValue;\n        }\n\n        public static ShoppingCart<TItem> FromState(EmptyState state)\n        {\n            return new ShoppingCart<TItem>(Tag.Empty, state);\n        }\n\n        public static ShoppingCart<TItem> FromState(ActiveState state)\n        {\n            return new ShoppingCart<TItem>(Tag.Active, state);\n        }\n\n        public static ShoppingCart<TItem> FromState(PaidForState state)\n        {\n            return new ShoppingCart<TItem>(Tag.PaidFor, state);\n        }\n\n        /// <summary>\n        /// Create a new empty cart\n        /// </summary>\n        public static ShoppingCart<TItem> NewCart()\n        {\n            var newState = new EmptyState();\n            return FromState(newState);\n        }\n\n        /// <summary>\n        /// Call a function for each case of the state\n        /// </summary>\n        /// <remarks>\n        /// Forcing the caller to pass a function for each possible case means that all cases are handled at all times.\n        /// </remarks>\n        public TResult Do<TResult>(\n            Func<EmptyState, TResult> emptyFn,\n            Func<ActiveState, TResult> activeFn,\n            Func<PaidForState, TResult> paidForyFn\n            )\n        {\n            switch (_tag)\n            {\n                case Tag.Empty:\n                    return emptyFn(_state as EmptyState);\n                case Tag.Active:\n                    return activeFn(_state as ActiveState);\n                case Tag.PaidFor:\n                    return paidForyFn(_state as PaidForState);\n                default:\n                    throw new InvalidOperationException(string.Format(\"Tag {0} not recognized\", _tag));\n            }\n        }\n\n        /// <summary>\n        /// Do an action without a return value\n        /// </summary>\n        public void Do(\n            Action<EmptyState> emptyFn,\n            Action<ActiveState> activeFn,\n            Action<PaidForState> paidForyFn\n            )\n        {\n            //convert the Actions into Funcs by returning a dummy value\n            Do(\n                state => { emptyFn(state); return 0; },\n                state => { activeFn(state); return 0; },\n                state => { paidForyFn(state); return 0; }\n                );\n        }\n\n    }\n\n    /// <summary>\n    /// Extension methods for my own personal library\n    /// </summary>\n    public static class ShoppingCartExtension\n    {\n        /// <summary>\n        /// Helper method to Add\n        /// </summary>\n        public static ShoppingCart<TItem> Add<TItem>(this ShoppingCart<TItem> cart, TItem item)\n        {\n            return cart.Do(\n                state => state.Add(item), //empty case\n                state => state.Add(item), //active case\n                state => { Console.WriteLine(\"ERROR: The cart is paid for and items cannot be added\"); return cart; } //paid for case\n            );\n        }\n\n        /// <summary>\n        /// Helper method to Remove\n        /// </summary>\n        public static ShoppingCart<TItem> Remove<TItem>(this ShoppingCart<TItem> cart, TItem item)\n        {\n            return cart.Do(\n                state => { Console.WriteLine(\"ERROR: The cart is empty and items cannot be removed\"); return cart; }, //empty case\n                state => state.Remove(item), //active case\n                state => { Console.WriteLine(\"ERROR: The cart is paid for and items cannot be removed\"); return cart; } //paid for case\n            );\n        }\n\n        /// <summary>\n        /// Helper method to Display\n        /// </summary>\n        public static void Display<TItem>(this ShoppingCart<TItem> cart)\n        {\n            cart.Do(\n                state => Console.WriteLine(\"The cart is empty\"),\n                state => Console.WriteLine(\"The active cart contains {0} items\", state.Items.Count()),\n                state => Console.WriteLine(\"The paid cart contains {0} items. Amount paid {1}\", state.Items.Count(), state.Amount)\n            );\n        }\n    }\n\n    [NUnit.Framework.TestFixture]\n    public class CorrectShoppingCartTest\n    {\n        [NUnit.Framework.Test]\n        public void TestCart()\n        {\n            var emptyCart = ShoppingCart<string>.NewCart();\n            emptyCart.Display();\n\n            var cartA = emptyCart.Add(\"A\");  //one item\n            cartA.Display();\n\n            var cartAb = cartA.Add(\"B\");  //two items\n            cartAb.Display();\n\n            var cartB = cartAb.Remove(\"A\"); //one item\n            cartB.Display();\n\n            var emptyCart2 = cartB.Remove(\"B\"); //empty\n            emptyCart2.Display();\n\n            Console.WriteLine(\"Removing from emptyCart\");\n            emptyCart.Remove(\"B\"); //error\n\n            //  try to pay for cartA\n            Console.WriteLine(\"paying for cartA\");\n            var paidCart = cartA.Do(\n                state => cartA,\n                state => state.Pay(100),\n                state => cartA);\n            paidCart.Display();\n\n            Console.WriteLine(\"Adding to paidCart\");\n            paidCart.Add(\"C\");\n\n            //  try to pay for emptyCart\n            Console.WriteLine(\"paying for emptyCart\");\n            var emptyCartPaid = emptyCart.Do(\n                state => emptyCart,\n                state => state.Pay(100),\n                state => emptyCart);\n            emptyCartPaid.Display();\n        }\n    }\n} \n```", "```\nopen System\n\nlet userTimerWithCallback = \n    // create an event to wait on\n    let event = new System.Threading.AutoResetEvent(false)\n\n    // create a timer and add an event handler that will signal the event\n    let timer = new System.Timers.Timer(2000.0)\n    timer.Elapsed.Add (fun _ -> event.Set() |> ignore )\n\n    //start\n    printfn \"Waiting for timer at %O\" DateTime.Now.TimeOfDay\n    timer.Start()\n\n    // keep working\n    printfn \"Doing something useful while waiting for event\"\n\n    // block on the timer via the AutoResetEvent\n    event.WaitOne() |> ignore\n\n    //done\n    printfn \"Timer ticked at %O\" DateTime.Now.TimeOfDay \n```", "```\nopen System\n//open Microsoft.FSharp.Control  // Async.* is in this module.\n\nlet userTimerWithAsync = \n\n    // create a timer and associated async event\n    let timer = new System.Timers.Timer(2000.0)\n    let timerEvent = Async.AwaitEvent (timer.Elapsed) |> Async.Ignore\n\n    // start\n    printfn \"Waiting for timer at %O\" DateTime.Now.TimeOfDay\n    timer.Start()\n\n    // keep working\n    printfn \"Doing something useful while waiting for event\"\n\n    // block on the timer event now by waiting for the async to complete\n    Async.RunSynchronously timerEvent\n\n    // done\n    printfn \"Timer ticked at %O\" DateTime.Now.TimeOfDay \n```", "```\nlet fileWriteWithAsync = \n\n    // create a stream to write to\n    use stream = new System.IO.FileStream(\"test.txt\",System.IO.FileMode.Create)\n\n    // start\n    printfn \"Starting async write\"\n    let asyncResult = stream.BeginWrite(Array.empty,0,0,null,null)\n\n    // create an async wrapper around an IAsyncResult\n    let async = Async.AwaitIAsyncResult(asyncResult) |> Async.Ignore\n\n    // keep working\n    printfn \"Doing something useful while waiting for write to complete\"\n\n    // block on the timer now by waiting for the async to complete\n    Async.RunSynchronously async \n\n    // done\n    printfn \"Async write completed\" \n```", "```\nlet sleepWorkflow  = async{\n    printfn \"Starting sleep workflow at %O\" DateTime.Now.TimeOfDay\n    do! Async.Sleep 2000\n    printfn \"Finished sleep workflow at %O\" DateTime.Now.TimeOfDay\n    }\n\nAsync.RunSynchronously sleepWorkflow \n```", "```\nlet nestedWorkflow  = async{\n\n    printfn \"Starting parent\"\n    let! childWorkflow = Async.StartChild sleepWorkflow\n\n    // give the child a chance and then keep working\n    do! Async.Sleep 100\n    printfn \"Doing something useful while waiting \"\n\n    // block on the child\n    let! result = childWorkflow\n\n    // done\n    printfn \"Finished parent\" \n    }\n\n// run the whole workflow\nAsync.RunSynchronously nestedWorkflow \n```", "```\nlet testLoop = async {\n    for i in [1..100] do\n        // do something\n        printf \"%i before..\" i\n\n        // sleep a bit \n        do! Async.Sleep 10  \n        printfn \"..after\"\n    } \n```", "```\nAsync.RunSynchronously testLoop \n```", "```\nopen System\nopen System.Threading\n\n// create a cancellation source\nlet cancellationSource = new CancellationTokenSource()\n\n// start the task, but this time pass in a cancellation token\nAsync.Start (testLoop,cancellationSource.Token)\n\n// wait a bit\nThread.Sleep(200)  \n\n// cancel after 200ms\ncancellationSource.Cancel() \n```", "```\ndo! Async.Sleep(10) \n```", "```\n// create a workflow to sleep for a time\nlet sleepWorkflowMs ms = async {\n    printfn \"%i ms workflow started\" ms\n    do! Async.Sleep ms\n    printfn \"%i ms workflow finished\" ms\n    } \n```", "```\nlet workflowInSeries = async {\n    let! sleep1 = sleepWorkflowMs 1000\n    printfn \"Finished one\" \n    let! sleep2 = sleepWorkflowMs 2000\n    printfn \"Finished two\" \n    }\n\n#time\nAsync.RunSynchronously workflowInSeries \n#time \n```", "```\n// Create them\nlet sleep1 = sleepWorkflowMs 1000\nlet sleep2 = sleepWorkflowMs 2000\n\n// run them in parallel\n#time\n[sleep1; sleep2] \n    |> Async.Parallel\n    |> Async.RunSynchronously \n#time \n```", "```\nopen System.Net\nopen System\nopen System.IO\n\nlet fetchUrl url =        \n    let req = WebRequest.Create(Uri(url)) \n    use resp = req.GetResponse() \n    use stream = resp.GetResponseStream() \n    use reader = new IO.StreamReader(stream) \n    let html = reader.ReadToEnd() \n    printfn \"finished downloading %s\" url \n```", "```\n// a list of sites to fetch\nlet sites = [\"http://www.bing.com\";\n             \"http://www.google.com\";\n             \"http://www.microsoft.com\";\n             \"http://www.amazon.com\";\n             \"http://www.yahoo.com\"]\n\n#time                     // turn interactive timer on\nsites                     // start with the list of sites\n|> List.map fetchUrl      // loop through each site and download\n#time                     // turn timer off \n```", "```\nopen Microsoft.FSharp.Control.CommonExtensions   \n                                        // adds AsyncGetResponse\n\n// Fetch the contents of a web page asynchronously\nlet fetchUrlAsync url =        \n    async {                             \n        let req = WebRequest.Create(Uri(url)) \n        use! resp = req.AsyncGetResponse()  // new keyword \"use!\" \n        use stream = resp.GetResponseStream() \n        use reader = new IO.StreamReader(stream) \n        let html = reader.ReadToEnd() \n        printfn \"finished downloading %s\" url \n        } \n```", "```\n// a list of sites to fetch\nlet sites = [\"http://www.bing.com\";\n             \"http://www.google.com\";\n             \"http://www.microsoft.com\";\n             \"http://www.amazon.com\";\n             \"http://www.yahoo.com\"]\n\n#time                      // turn interactive timer on\nsites \n|> List.map fetchUrlAsync  // make a list of async tasks\n|> Async.Parallel          // set up the tasks to run in parallel\n|> Async.RunSynchronously  // start them off\n#time                      // turn timer off \n```", "```\nlet childTask() = \n    // chew up some CPU. \n    for i in [1..1000] do \n        for i in [1..1000] do \n            do \"Hello\".Contains(\"H\") |> ignore \n            // we don't care about the answer!\n\n// Test the child task on its own.\n// Adjust the upper bounds as needed\n// to make this run in about 0.2 sec\n#time\nchildTask()\n#time \n```", "```\nlet parentTask = \n    childTask\n    |> List.replicate 20\n    |> List.reduce (>>)\n\n//test\n#time\nparentTask()\n#time \n```", "```\nlet asyncChildTask = async { return childTask() } \n```", "```\nlet asyncParentTask = \n    asyncChildTask\n    |> List.replicate 20\n    |> Async.Parallel\n\n//test\n#time\nasyncParentTask \n|> Async.RunSynchronously\n#time \n```", "```\n #nowarn \"40\"\nlet printerAgent = MailboxProcessor.Start(fun inbox-> \n\n    // the message processing function\n    let rec messageLoop = async{\n\n        // read a message\n        let! msg = inbox.Receive()\n\n        // process a message\n        printfn \"message is: %s\" msg\n\n        // loop to top\n        return! messageLoop  \n        }\n\n    // start the loop \n    messageLoop \n    ) \n```", "```\n// test it\nprinterAgent.Post \"hello\" \nprinterAgent.Post \"hello again\" \nprinterAgent.Post \"hello a third time\" \n```", "```\nopen System\nopen System.Threading\nopen System.Diagnostics\n\n// a utility function\ntype Utility() = \n    static let rand = new Random()\n\n    static member RandomSleep() = \n        let ms = rand.Next(1,10)\n        Thread.Sleep ms\n\n// an implementation of a shared counter using locks\ntype LockedCounter () = \n\n    static let _lock = new Object()\n\n    static let mutable count = 0\n    static let mutable sum = 0\n\n    static let updateState i = \n        // increment the counters and...\n        sum <- sum + i\n        count <- count + 1\n        printfn \"Count is: %i. Sum is: %i\" count sum \n\n        // ...emulate a short delay\n        Utility.RandomSleep()\n\n    // public interface to hide the state\n    static member Add i = \n        // see how long a client has to wait\n        let stopwatch = new Stopwatch()\n        stopwatch.Start() \n\n        // start lock. Same as C# lock{...}\n        lock _lock (fun () ->\n\n            // see how long the wait was\n            stopwatch.Stop()\n            printfn \"Client waited %i\" stopwatch.ElapsedMilliseconds\n\n            // do the core logic\n            updateState i \n            )\n        // release lock \n```", "```\n// test in isolation\nLockedCounter.Add 4\nLockedCounter.Add 5 \n```", "```\nlet makeCountingTask addFunction taskId  = async {\n    let name = sprintf \"Task%i\" taskId\n    for i in [1..3] do \n        addFunction i\n    }\n\n// test in isolation\nlet task = makeCountingTask LockedCounter.Add 1\nAsync.RunSynchronously task \n```", "```\nlet lockedExample5 = \n    [1..10]\n        |> List.map (fun i -> makeCountingTask LockedCounter.Add i)\n        |> Async.Parallel\n        |> Async.RunSynchronously\n        |> ignore \n```", "```\ntype MessageBasedCounter () = \n\n    static let updateState (count,sum) msg = \n\n        // increment the counters and...\n        let newSum = sum + msg\n        let newCount = count + 1\n        printfn \"Count is: %i. Sum is: %i\" newCount newSum \n\n        // ...emulate a short delay\n        Utility.RandomSleep()\n\n        // return the new state\n        (newCount,newSum)\n\n    // create the agent\n    static let agent = MailboxProcessor.Start(fun inbox -> \n\n        // the message processing function\n        let rec messageLoop oldState = async{\n\n            // read a message\n            let! msg = inbox.Receive()\n\n            // do the core logic\n            let newState = updateState oldState msg\n\n            // loop to top\n            return! messageLoop newState \n            }\n\n        // start the loop \n        messageLoop (0,0)\n        )\n\n    // public interface to hide the implementation\n    static member Add i = agent.Post i \n```", "```\n// test in isolation\nMessageBasedCounter.Add 4\nMessageBasedCounter.Add 5 \n```", "```\nlet task = makeCountingTask MessageBasedCounter.Add 1\nAsync.RunSynchronously task \n```", "```\nlet messageExample5 = \n    [1..5]\n        |> List.map (fun i -> makeCountingTask MessageBasedCounter.Add i)\n        |> Async.Parallel\n        |> Async.RunSynchronously\n        |> ignore \n```", "```\nlet slowConsoleWrite msg = \n    msg |> String.iter (fun ch->\n        System.Threading.Thread.Sleep(1)\n        System.Console.Write ch\n        )\n\n// test in isolation\nslowConsoleWrite \"abc\" \n```", "```\nlet makeTask logger taskId = async {\n    let name = sprintf \"Task%i\" taskId\n    for i in [1..3] do \n        let msg = sprintf \"-%s:Loop%i-\" name i\n        logger msg \n    }\n\n// test in isolation\nlet task = makeTask slowConsoleWrite 1\nAsync.RunSynchronously task \n```", "```\ntype UnserializedLogger() = \n    // interface\n    member this.Log msg = slowConsoleWrite msg\n\n// test in isolation\nlet unserializedLogger = UnserializedLogger()\nunserializedLogger.Log \"hello\" \n```", "```\nlet unserializedExample = \n    let logger = new UnserializedLogger()\n    [1..5]\n        |> List.map (fun i -> makeTask logger.Log i)\n        |> Async.Parallel\n        |> Async.RunSynchronously\n        |> ignore \n```", "```\ntype SerializedLogger() = \n\n    // create the mailbox processor\n    let agent = MailboxProcessor.Start(fun inbox -> \n\n        // the message processing function\n        let rec messageLoop () = async{\n\n            // read a message\n            let! msg = inbox.Receive()\n\n            // write it to the log\n            slowConsoleWrite msg\n\n            // loop to top\n            return! messageLoop ()\n            }\n\n        // start the loop\n        messageLoop ()\n        )\n\n    // public interface\n    member this.Log msg = agent.Post msg\n\n// test in isolation\nlet serializedLogger = SerializedLogger()\nserializedLogger.Log \"hello\" \n```", "```\nlet serializedExample = \n    let logger = new SerializedLogger()\n    [1..5]\n        |> List.map (fun i -> makeTask logger.Log i)\n        |> Async.Parallel\n        |> Async.RunSynchronously\n        |> ignore \n```", "```\nopen System\nopen System.Threading\n\n/// create a timer and register an event handler, \n/// then run the timer for five seconds\nlet createTimer timerInterval eventHandler =\n    // setup a timer\n    let timer = new System.Timers.Timer(float timerInterval)\n    timer.AutoReset <- true\n\n    // add an event handler\n    timer.Elapsed.Add eventHandler\n\n    // return an async task\n    async {\n        // start timer...\n        timer.Start()\n        // ...run for five seconds...\n        do! Async.Sleep 5000\n        // ... and stop\n        timer.Stop()\n        } \n```", "```\n// create a handler. The event args are ignored\nlet basicHandler _ = printfn \"tick %A\" DateTime.Now\n\n// register the handler\nlet basicTimer1 = createTimer 1000 basicHandler\n\n// run the task now\nAsync.RunSynchronously basicTimer1 \n```", "```\nlet createTimerAndObservable timerInterval =\n    // setup a timer\n    let timer = new System.Timers.Timer(float timerInterval)\n    timer.AutoReset <- true\n\n    // events are automatically IObservable\n    let observable = timer.Elapsed  \n\n    // return an async task\n    let task = async {\n        timer.Start()\n        do! Async.Sleep 5000\n        timer.Stop()\n        }\n\n    // return a async task and the observable\n    (task,observable) \n```", "```\n// create the timer and the corresponding observable\nlet basicTimer2 , timerEventStream = createTimerAndObservable 1000\n\n// register that everytime something happens on the \n// event stream, print the time.\ntimerEventStream \n|> Observable.subscribe (fun _ -> printfn \"tick %A\" DateTime.Now)\n\n// run the task now\nAsync.RunSynchronously basicTimer2 \n```", "```\nCreate a timer that ticks every 500ms. \nAt each tick, print the number of ticks so far and the current time. \n```", "```\ntype ImperativeTimerCount() =\n\n    let mutable count = 0\n\n    // the event handler. The event args are ignored\n    member this.handleEvent _ =\n      count <- count + 1\n      printfn \"timer ticked with count %i\" count \n```", "```\n// create a handler class\nlet handler = new ImperativeTimerCount()\n\n// register the handler method\nlet timerCount1 = createTimer 500 handler.handleEvent\n\n// run the task now\nAsync.RunSynchronously timerCount1 \n```", "```\n// create the timer and the corresponding observable\nlet timerCount2, timerEventStream = createTimerAndObservable 500\n\n// set up the transformations on the event stream\ntimerEventStream \n|> Observable.scan (fun count _ -> count + 1) 0 \n|> Observable.subscribe (fun count -> printfn \"timer ticked with count %i\" count)\n\n// run the task now\nAsync.RunSynchronously timerCount2 \n```", "```\nCreate two timers, called '3' and '5'. The '3' timer ticks every 300ms and the '5' timer ticks \nevery 500ms. \n\nHandle the events as follows:\na) for all events, print the id of the time and the time\nb) when a tick is simultaneous with a previous tick, print 'FizzBuzz'\notherwise:\nc) when the '3' timer ticks on its own, print 'Fizz'\nd) when the '5' timer ticks on its own, print 'Buzz' \n```", "```\ntype FizzBuzzEvent = {label:int; time: DateTime} \n```", "```\nlet areSimultaneous (earlierEvent,laterEvent) =\n    let {label=_;time=t1} = earlierEvent\n    let {label=_;time=t2} = laterEvent\n    t2.Subtract(t1).Milliseconds < 50 \n```", "```\ntype ImperativeFizzBuzzHandler() =\n\n    let mutable previousEvent: FizzBuzzEvent option = None\n\n    let printEvent thisEvent  = \n      let {label=id; time=t} = thisEvent\n      printf \"[%i] %i.%03i \" id t.Second t.Millisecond\n      let simultaneous = previousEvent.IsSome && areSimultaneous (previousEvent.Value,thisEvent)\n      if simultaneous then printfn \"FizzBuzz\"\n      elif id = 3 then printfn \"Fizz\"\n      elif id = 5 then printfn \"Buzz\"\n\n    member this.handleEvent3 eventArgs =\n      let event = {label=3; time=DateTime.Now}\n      printEvent event\n      previousEvent <- Some event\n\n    member this.handleEvent5 eventArgs =\n      let event = {label=5; time=DateTime.Now}\n      printEvent event\n      previousEvent <- Some event \n```", "```\n// create the class\nlet handler = new ImperativeFizzBuzzHandler()\n\n// create the two timers and register the two handlers\nlet timer3 = createTimer 300 handler.handleEvent3\nlet timer5 = createTimer 500 handler.handleEvent5\n\n// run the two timers at the same time\n[timer3;timer5]\n|> Async.Parallel\n|> Async.RunSynchronously \n```", "```\nlet timer3, timerEventStream3 = createTimerAndObservable 300\nlet timer5, timerEventStream5 = createTimerAndObservable 500 \n```", "```\n// convert the time events into FizzBuzz events with the appropriate id\nlet eventStream3  = \n   timerEventStream3  \n   |> Observable.map (fun _ -> {label=3; time=DateTime.Now})\n\nlet eventStream5  = \n   timerEventStream5  \n   |> Observable.map (fun _ -> {label=5; time=DateTime.Now}) \n```", "```\n// combine the two streams\nlet combinedStream = \n    Observable.merge eventStream3 eventStream5\n\n// make pairs of events\nlet pairwiseStream = \n   combinedStream |> Observable.pairwise\n\n// split the stream based on whether the pairs are simultaneous\nlet simultaneousStream, nonSimultaneousStream = \n    pairwiseStream |> Observable.partition areSimultaneous \n```", "```\n// split the non-simultaneous stream based on the id\nlet fizzStream, buzzStream  =\n    nonSimultaneousStream  \n    // convert pair of events to the first event\n    |> Observable.map (fun (ev1,_) -> ev1)\n    // split on whether the event id is three\n    |> Observable.partition (fun {label=id} -> id=3) \n```", "```\n//print events from the combinedStream\ncombinedStream \n|> Observable.subscribe (fun {label=id;time=t} -> \n                              printf \"[%i] %i.%03i \" id t.Second t.Millisecond)\n\n//print events from the simultaneous stream\nsimultaneousStream \n|> Observable.subscribe (fun _ -> printfn \"FizzBuzz\")\n\n//print events from the nonSimultaneous streams\nfizzStream \n|> Observable.subscribe (fun _ -> printfn \"Fizz\")\n\nbuzzStream \n|> Observable.subscribe (fun _ -> printfn \"Buzz\") \n```", "```\n// run the two timers at the same time\n[timer3;timer5]\n|> Async.Parallel\n|> Async.RunSynchronously \n```", "```\n// create the event streams and raw observables\nlet timer3, timerEventStream3 = createTimerAndObservable 300\nlet timer5, timerEventStream5 = createTimerAndObservable 500\n\n// convert the time events into FizzBuzz events with the appropriate id\nlet eventStream3  = timerEventStream3  \n                    |> Observable.map (fun _ -> {label=3; time=DateTime.Now})\nlet eventStream5  = timerEventStream5  \n                    |> Observable.map (fun _ -> {label=5; time=DateTime.Now})\n\n// combine the two streams\nlet combinedStream = \n   Observable.merge eventStream3 eventStream5\n\n// make pairs of events\nlet pairwiseStream = \n   combinedStream |> Observable.pairwise\n\n// split the stream based on whether the pairs are simultaneous\nlet simultaneousStream, nonSimultaneousStream = \n   pairwiseStream |> Observable.partition areSimultaneous\n\n// split the non-simultaneous stream based on the id\nlet fizzStream, buzzStream  =\n    nonSimultaneousStream  \n    // convert pair of events to the first event\n    |> Observable.map (fun (ev1,_) -> ev1)\n    // split on whether the event id is three\n    |> Observable.partition (fun {label=id} -> id=3)\n\n//print events from the combinedStream\ncombinedStream \n|> Observable.subscribe (fun {label=id;time=t} -> \n                              printf \"[%i] %i.%03i \" id t.Second t.Millisecond)\n\n//print events from the simultaneous stream\nsimultaneousStream \n|> Observable.subscribe (fun _ -> printfn \"FizzBuzz\")\n\n//print events from the nonSimultaneous streams\nfizzStream \n|> Observable.subscribe (fun _ -> printfn \"Fizz\")\n\nbuzzStream \n|> Observable.subscribe (fun _ -> printfn \"Buzz\")\n\n// run the two timers at the same time\n[timer3;timer5]\n|> Async.Parallel\n|> Async.RunSynchronously \n```", "```\n// debugging code\n//simultaneousStream |> Observable.subscribe (fun e -> printfn \"sim %A\" e)\n//nonSimultaneousStream |> Observable.subscribe (fun e -> printfn \"non-sim %A\" e) \n```", "```\n//using an Int32\nlet (i1success,i1) = System.Int32.TryParse(\"123\");\nif i1success then printfn \"parsed as %i\" i1 else printfn \"parse failed\"\n\nlet (i2success,i2) = System.Int32.TryParse(\"hello\");\nif i2success then printfn \"parsed as %i\" i2 else printfn \"parse failed\"\n\n//using a DateTime\nlet (d1success,d1) = System.DateTime.TryParse(\"1/1/1980\");\nlet (d2success,d2) = System.DateTime.TryParse(\"hello\");\n\n//using a dictionary\nlet dict = new System.Collections.Generic.Dictionary<string,string>();\ndict.Add(\"a\",\"hello\")\nlet (e1success,e1) = dict.TryGetValue(\"a\");\nlet (e2success,e2) = dict.TryGetValue(\"b\"); \n```", "```\nlet createReader fileName = new System.IO.StreamReader(fileName)\n// error FS0041: A unique overload for method 'StreamReader' \n//               could not be determined \n```", "```\nlet createReader2 fileName = new System.IO.StreamReader(path=fileName) \n```", "```\nlet (|Digit|Letter|Whitespace|Other|) ch = \n   if System.Char.IsDigit(ch) then Digit\n   else if System.Char.IsLetter(ch) then Letter\n   else if System.Char.IsWhiteSpace(ch) then Whitespace\n   else Other \n```", "```\nlet printChar ch = \n  match ch with\n  | Digit -> printfn \"%c is a Digit\" ch\n  | Letter -> printfn \"%c is a Letter\" ch\n  | Whitespace -> printfn \"%c is a Whitespace\" ch\n  | _ -> printfn \"%c is something else\" ch\n\n// print a list\n['a';'b';'1';' ';'-';'c'] |> List.iter printChar \n```", "```\nopen System.Data.SqlClient\n\nlet (|ConstraintException|ForeignKeyException|Other|) (ex:SqlException) = \n   if ex.Number = 2601 then ConstraintException \n   else if ex.Number = 2627 then ConstraintException \n   else if ex.Number = 547 then ForeignKeyException \n   else Other \n```", "```\nlet executeNonQuery (sqlCommmand:SqlCommand) = \n    try\n       let result = sqlCommmand.ExecuteNonQuery()\n       // handle success\n    with \n    | :?SqlException as sqlException -> // if a SqlException\n        match sqlException with         // nice pattern matching\n        | ConstraintException  -> // handle constraint error\n        | ForeignKeyException  -> // handle FK error\n        | _ -> reraise()          // don't handle any other cases\n    // all non SqlExceptions are thrown normally \n```", "```\n// create a new object that implements IDisposable\nlet makeResource name = \n   { new System.IDisposable \n     with member this.Dispose() = printfn \"%s disposed\" name }\n\nlet useAndDisposeResources = \n    use r1 = makeResource \"first resource\"\n    printfn \"using first resource\" \n    for i in [1..3] do\n        let resourceName = sprintf \"\\tinner resource %d\" i\n        use temp = makeResource resourceName \n        printfn \"\\tdo something with %s\" resourceName \n    use r2 = makeResource \"second resource\"\n    printfn \"using second resource\" \n    printfn \"done.\" \n```", "```\nusing first resource\n    do something with     inner resource 1\n    inner resource 1 disposed\n    do something with     inner resource 2\n    inner resource 2 disposed\n    do something with     inner resource 3\n    inner resource 3 disposed\nusing second resource\ndone.\nsecond resource disposed\nfirst resource disposed \n```", "```\ntype IAnimal = \n   abstract member MakeNoise : unit -> string\n\nlet showTheNoiseAnAnimalMakes (animal:IAnimal) = \n   animal.MakeNoise() |> printfn \"Making noise %s\" \n```", "```\ntype Cat = Felix | Socks\ntype Dog = Butch | Lassie \n```", "```\n// now mixin the interface with the F# types\ntype Cat with\n   member this.AsAnimal = \n        { new IAnimal \n          with member a.MakeNoise() = \"Meow\" }\n\ntype Dog with\n   member this.AsAnimal = \n        { new IAnimal \n          with member a.MakeNoise() = \"Woof\" } \n```", "```\nlet dog = Lassie\nshowTheNoiseAnAnimalMakes (dog.AsAnimal)\n\nlet cat = Felix\nshowTheNoiseAnAnimalMakes (cat.AsAnimal) \n```", "```\nopen System.Reflection\nopen Microsoft.FSharp.Reflection\n\n// create a record type...\ntype Account = {Id: int; Name: string}\n\n// ... and show the fields\nlet fields = \n    FSharpType.GetRecordFields(typeof<Account>)\n    |> Array.map (fun propInfo -> propInfo.Name, propInfo.PropertyType.Name)\n\n// create a union type...\ntype Choices = | A of int | B of string\n\n// ... and show the choices\nlet choices = \n    FSharpType.GetUnionCases(typeof<Choices>)\n    |> Array.map (fun choiceInfo -> choiceInfo.Name) \n```", "```\n// interface\ntype IEnumerator<'a> = \n    abstract member Current : 'a\n    abstract MoveNext : unit -> bool \n\n// abstract base class with virtual methods\n[<AbstractClass>]\ntype Shape() = \n    //readonly properties\n    abstract member Width : int with get\n    abstract member Height : int with get\n    //non-virtual method\n    member this.BoundingArea = this.Height * this.Width\n    //virtual method with base implementation\n    abstract member Print : unit -> unit \n    default this.Print () = printfn \"I'm a shape\"\n\n// concrete class that inherits from base class and overrides \ntype Rectangle(x:int, y:int) = \n    inherit Shape()\n    override this.Width = x\n    override this.Height = y\n    override this.Print ()  = printfn \"I'm a Rectangle\"\n\n//test\nlet r = Rectangle(2,3)\nprintfn \"The width is %i\" r.Width\nprintfn \"The area is %i\" r.BoundingArea\nr.Print() \n```", "```\ntype Circle(rad:int) = \n    inherit Shape()\n\n    //mutable field\n    let mutable radius = rad\n\n    //property overrides\n    override this.Width = radius * 2\n    override this.Height = radius * 2\n\n    //alternate constructor with default radius\n    new() = Circle(10)      \n\n    //property with get and set\n    member this.Radius\n         with get() = radius\n         and set(value) = radius <- value\n\n// test constructors\nlet c1 = Circle()   // parameterless ctor\nprintfn \"The width is %i\" c1.Width\nlet c2 = Circle(2)  // main ctor\nprintfn \"The width is %i\" c2.Width\n\n// test mutable property\nc2.Radius <- 3\nprintfn \"The width is %i\" c2.Width \n```", "```\n// standard generics\ntype KeyValuePair<'a,'b>(key:'a, value: 'b) = \n    member this.Key = key\n    member this.Value = value\n\n// generics with constraints\ntype Container<'a,'b \n    when 'a : equality \n    and 'b :> System.Collections.ICollection>\n    (name:'a, values:'b) = \n    member this.Name = name\n    member this.Values = values \n```", "```\n type Point2D =\n   struct\n      val X: float\n      val Y: float\n      new(x: float, y: float) = { X = x; Y = y }\n   end\n\n//test\nlet p = Point2D()  // zero initialized\nlet p2 = Point2D(2.0,3.0)  // explicitly initialized \n```", "```\n// create a new Exception class\nexception MyError of string\n\ntry\n    let e = MyError(\"Oops!\")\n    raise e\nwith \n    | MyError msg -> \n        printfn \"The exception error was %s\" msg\n    | _ -> \n        printfn \"Some other exception\" \n```", "```\ntype System.String with\n    member this.StartsWithA = this.StartsWith \"A\"\n\n//test\nlet s = \"Alice\"\nprintfn \"'%s' starts with an 'A' = %A\" s s.StartsWithA\n\ntype System.Int32 with\n    member this.IsEven = this % 2 = 0\n\n//test\nlet i = 20\nif i.IsEven then printfn \"'%i' is even\" i \n```", "```\nopen System\ntype MyConsole() =\n    member this.WriteLine([<ParamArray>] args: Object[]) =\n        for arg in args do\n            printfn \"%A\" arg\n\nlet cons = new MyConsole()\ncons.WriteLine(\"abc\", 42, 3.14, true) \n```", "```\ntype MyButton() =\n    let clickEvent = new Event<_>()\n\n    [<CLIEvent>]\n    member this.OnClick = clickEvent.Publish\n\n    member this.TestEvent(arg) =\n        clickEvent.Trigger(this, arg)\n\n// test\nlet myButton = new MyButton()\nmyButton.OnClick.Add(fun (sender, arg) -> \n        printfn \"Click event with arg=%O\" arg)\n\nmyButton.TestEvent(\"Hello World!\") \n```", "```\n// delegates\ntype MyDelegate = delegate of int -> int\nlet f = MyDelegate (fun x -> x * x)\nlet result = f.Invoke(5) \n```", "```\n// enums\ntype Color = | Red=1 | Green=2 | Blue=3\n\nlet color1  = Color.Red    // simple assignment\nlet color2:Color = enum 2  // cast from int\n// created from parsing a string\nlet color3 = System.Enum.Parse(typeof<Color>,\"Green\") :?> Color // :?> is a downcast\n\n[<System.FlagsAttribute>]\ntype FileAccess = | Read=1 | Write=2 | Execute=4 \nlet fileaccess = FileAccess.Read ||| FileAccess.Write \n```", "```\nopen System.Windows.Forms \n\nlet form = new Form(Width= 400, Height = 300, Visible = true, Text = \"Hello World\") \nform.TopMost <- true\nform.Click.Add (fun args-> printfn \"the form was clicked\")\nform.Show() \n```"]