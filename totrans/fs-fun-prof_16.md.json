["```\nmodule MethodDependencyExample = \n\n    type Customer(name, observer:CustomerObserver) = \n        let mutable name = name\n        member this.Name \n            with get() = name\n            and set(value) = \n                name <- value\n                observer.OnNameChanged(this)\n\n    and CustomerObserver() = \n        member this.OnNameChanged(c:Customer) =     \n            printfn \"Customer name changed to '%s' \" c.Name\n\n    // test\n    let observer = new CustomerObserver()\n    let customer = Customer(\"Alice\",observer)\n    customer.Name <- \"Bob\" \n```", "```\ntype Something \nand type SomethingElse  // wrong\n\ntype Something \nand SomethingElse       // correct \n```", "```\ntype Something\n   // 500 lines of code\nand SomethingElse\n   // 500 more lines of code \n```", "```\nmodule MethodDependency_ParameterizedInterface = \n\n    type INameObserver<'T> = \n        abstract OnNameChanged : 'T -> unit\n\n    type Customer(name, observer:INameObserver<Customer>) = \n        let mutable name = name\n        member this.Name \n            with get() = name\n            and set(value) = \n                name <- value\n                observer.OnNameChanged(this)\n\n    type CustomerObserver() = \n        interface INameObserver<Customer> with \n            member this.OnNameChanged c =     \n                printfn \"Customer name changed to '%s' \" c.Name\n\n    // test\n    let observer = new CustomerObserver()\n    let customer = Customer(\"Alice\", observer)\n    customer.Name <- \"Bob\" \n```", "```\nmodule MethodDependency_ParameterizedInterface = \n\n    // code as above\n\n    // test\n    let observer2 = {\n        new INameObserver<Customer> with \n            member this.OnNameChanged c =     \n                printfn \"Customer name changed to '%s' \" c.Name\n        }\n    let customer2 = Customer(\"Alice\", observer2)\n    customer2.Name <- \"Bob\" \n```", "```\nmodule MethodDependency_ParameterizedInterface2 = \n\n    type ICustomerObserver<'T> = \n        abstract OnNameChanged : 'T -> unit\n        abstract OnEmailChanged : 'T -> unit\n\n    type Customer(name, email, observer:ICustomerObserver<Customer>) = \n\n        let mutable name = name\n        let mutable email = email\n\n        member this.Name \n            with get() = name\n            and set(value) = \n                name <- value\n                observer.OnNameChanged(this)\n\n        member this.Email\n            with get() = email\n            and set(value) = \n                email <- value\n                observer.OnEmailChanged(this)\n\n    // test\n    let observer2 = {\n        new ICustomerObserver<Customer> with \n            member this.OnNameChanged c =     \n                printfn \"Customer name changed to '%s' \" c.Name\n            member this.OnEmailChanged c =     \n                printfn \"Customer email changed to '%s' \" c.Email\n        }\n    let customer2 = Customer(\"Alice\", \"x@example.com\",observer2)\n    customer2.Name <- \"Bob\"\n    customer2.Email <- \"y@example.com\" \n```", "```\nmodule MethodDependency_ParameterizedClasses_HOF  = \n\n    type Customer(name, observer) = \n\n        let mutable name = name\n\n        member this.Name \n            with get() = name\n            and set(value) = \n                name <- value\n                observer this\n\n    // test\n    let observer(c:Customer) = \n        printfn \"Customer name changed to '%s' \" c.Name\n    let customer = Customer(\"Alice\", observer)\n    customer.Name <- \"Bob\" \n```", "```\nlet observer(c:Customer) = \n    printfn \"Customer name changed to '%s' \" c.Name \n```", "```\nmodule MethodDependencyExample_SeparateTypes = \n\n    module DomainTypes = \n        type Customer = { name:string; observer:NameChangedObserver }\n        and  NameChangedObserver = Customer -> unit\n\n    module Customer = \n        open DomainTypes\n\n        let changeName customer newName = \n            let newCustomer = {customer with name=newName}\n            customer.observer newCustomer\n            newCustomer     // return the new customer\n\n    module Observer = \n        open DomainTypes\n\n        let printNameChanged customer = \n            printfn \"Customer name changed to '%s' \" customer.name\n\n    // test\n    module Test = \n        open DomainTypes\n\n        let observer = Observer.printNameChanged \n        let customer = {name=\"Alice\"; observer=observer}\n        Customer.changeName customer \"Bob\" \n```", "```\nmodule MethodDependency_SeparateTypes2 = \n\n    module DomainTypes = \n        type Customer = { name:string; observer:Customer -> unit}\n\n    module Customer = \n        open DomainTypes\n\n        let changeName customer newName = \n            let newCustomer = {customer with name=newName}\n            customer.observer newCustomer\n            newCustomer     // return the new customer\n\n    module Observer = \n        open DomainTypes\n\n        let printNameChanged customer = \n            printfn \"Customer name changed to '%s' \" customer.name\n\n    module Test = \n        open DomainTypes\n\n        let observer = Observer.printNameChanged \n        let customer = {name=\"Alice\"; observer=observer}\n        Customer.changeName customer \"Bob\" \n```", "```\nlet changeName observer customer newName = \n    let newCustomer = {customer with name=newName}\n    observer newCustomer    // call the observer with the new customer\n    newCustomer             // return the new customer \n```", "```\nmodule MethodDependency_SeparateTypes3 = \n\n    module DomainTypes = \n        type Customer = {name:string}\n\n    module Customer = \n        open DomainTypes\n\n        let changeName observer customer newName = \n            let newCustomer = {customer with name=newName}\n            observer newCustomer    // call the observer with the new customer\n            newCustomer             // return the new customer\n\n    module Observer = \n        open DomainTypes\n\n        let printNameChanged customer = \n            printfn \"Customer name changed to '%s' \" customer.name\n\n    module Test = \n        open DomainTypes\n\n        let observer = Observer.printNameChanged \n        let customer = {name=\"Alice\"}\n        Customer.changeName observer customer \"Bob\" \n```", "```\nmodule MethodDependency_SeparateTypes3 = \n\n    // code as above\n\n    module TestWithPartialApplication = \n        open DomainTypes\n\n        let observer = Observer.printNameChanged \n\n        // set up this partial application only once (at the top of your module, say)\n        let changeName = Customer.changeName observer \n\n        // then call changeName without needing an observer\n        let customer = {name=\"Alice\"}\n        changeName customer \"Bob\" \n```", "```\nlet changeName observer customer newName = \n    let newCustomer = {customer with name=newName}\n    observer newCustomer    // call the observer with the new customer\n    newCustomer             // return the new customer \n```", "```\nlet hook2 observer f param1 param2 = \n    let y = f param1 param2 // do something to make a result value\n    observer y              // call the observer with the result value\n    y                       // return the result value \n```", "```\nlet hook observer f param1 = \n    let y = f param1 // do something to make a result value \n    observer y       // call the observer with the result value\n    y                // return the result value \n```", "```\nlet observer = Observer.printNameChanged \nlet changeName = hook2 observer Customer.changeName \n```", "```\nlet customer = {name=\"Alice\"}\nchangeName customer \"Bob\" \n```", "```\nmodule MethodDependency_SeparateTypes_WithHookFunction = \n\n    [<AutoOpen>]\n    module MyFunctionLibrary = \n\n        let hook observer f param1 = \n            let y = f param1 // do something to make a result value \n            observer y       // call the observer with the result value\n            y                // return the result value\n\n        let hook2 observer f param1 param2 = \n            let y = f param1 param2 // do something to make a result value\n            observer y              // call the observer with the result value\n            y                       // return the result value\n\n    module DomainTypes = \n        type Customer = { name:string}\n\n    module Customer = \n        open DomainTypes\n\n        let changeName customer newName = \n            {customer with name=newName}\n\n    module Observer = \n        open DomainTypes\n\n        let printNameChanged customer = \n            printfn \"Customer name changed to '%s' \" customer.name\n\n    module TestWithPartialApplication = \n        open DomainTypes\n\n        // set up this partial application only once (at the top of your module, say)\n        let observer = Observer.printNameChanged \n        let changeName = hook2 observer Customer.changeName \n\n        // then call changeName without needing an observer\n        let customer = {name=\"Alice\"}\n        changeName customer \"Bob\" \n```", "```\nmodule StructuralDependencyExample = \n\n    type Employee(name, location:Location) = \n        member this.Name = name\n        member this.Location = location\n\n    and Location(name, employees: Employee list) = \n        member this.Name = name\n        member this.Employees  = employees \n```", "```\nmodule StructuralDependencyExample = \n\n    // code as above\n\n    module Test = \n        let location = new Location(\"CA\",[])       \n        let alice = new Employee(\"Alice\",location)       \n        let bob = new Employee(\"Bob\",location)      \n\n        location.Employees  // empty!\n        |> List.iter (fun employee -> \n            printfn \"employee %s works at %s\" employee.Name employee.Location.Name) \n```", "```\nmodule UncompilableTest = \n    let rec location = new Location(\"NY\",[alice;bob])       \n    and alice = new Employee(\"Alice\",location  )       \n    and bob = new Employee(\"Bob\",location ) \n```", "```\nmodule StructuralDependencyExample_Mutable = \n\n    type Employee(name, location:Location) = \n        member this.Name = name\n        member this.Location = location\n\n    and Location(name, employees: Employee list) = \n        let mutable employees = employees\n\n        member this.Name = name\n        member this.Employees  = employees \n        member this.SetEmployees es = \n            employees <- es\n\n    module TestWithMutableData = \n        let location = new Location(\"CA\",[])       \n        let alice = new Employee(\"Alice\",location)       \n        let bob = new Employee(\"Bob\",location)      \n        // fixup after creation\n        location.SetEmployees [alice;bob]  \n\n        location.Employees  \n        |> List.iter (fun employee -> \n            printfn \"employee %s works at %s\" employee.Name employee.Location.Name) \n```", "```\nmodule StructuralDependencyExample_ParameterizedClasses = \n\n    type ParameterizedEmployee<'Location>(name, location:'Location) = \n        member this.Name = name\n        member this.Location = location\n\n    type Location(name, employees: ParameterizedEmployee<Location> list) = \n        let mutable employees = employees\n        member this.Name = name\n        member this.Employees  = employees \n        member this.SetEmployees es = \n            employees <- es\n\n    type Employee = ParameterizedEmployee<Location> \n\n    module Test = \n        let location = new Location(\"CA\",[])       \n        let alice = new Employee(\"Alice\",location)       \n        let bob = new Employee(\"Bob\",location)      \n        location.SetEmployees [alice;bob]\n\n        location.Employees  // non-empty!\n        |> List.iter (fun employee -> \n            printfn \"employee %s works at %s\" employee.Name employee.Location.Name) \n```", "```\ntype Employee = ParameterizedEmployee<Location> \n```", "```\nlet alice = new Employee(\"Alice\",location) \n```", "```\nmodule StructuralDependency_WithAge = \n\n    type Employee(name, age:float, location:Location) = \n        member this.Name = name\n        member this.Age = age\n        member this.Location = location\n\n        // expects Name property\n        member this.LocationName = location.Name  \n\n    and Location(name, employees: Employee list) = \n        let mutable employees = employees\n        member this.Name = name\n        member this.Employees  = employees \n        member this.SetEmployees es = \n            employees <- es\n\n        // expects Age property \n        member this.AverageAge = \n            employees |> List.averageBy (fun e -> e.Age)\n\n    module Test = \n        let location = new Location(\"CA\",[])       \n        let alice = new Employee(\"Alice\",20.0,location)       \n        let bob = new Employee(\"Bob\",30.0,location)      \n        location.SetEmployees [alice;bob]\n        printfn \"Average age is %g\" location.AverageAge \n```", "```\nmodule StructuralDependencyWithAge_ParameterizedError = \n\n    type ParameterizedEmployee<'Location>(name, age:float, location:'Location) = \n        member this.Name = name\n        member this.Age = age\n        member this.Location = location\n        member this.LocationName = location.Name  // error\n\n    type Location(name, employees: ParameterizedEmployee<Location> list) = \n        let mutable employees = employees\n        member this.Name = name\n        member this.Employees  = employees \n        member this.SetEmployees es = \n            employees <- es\n        member this.AverageAge = \n            employees |> List.averageBy (fun e -> e.Age) \n```", "```\nmodule StructuralDependencyWithAge_ParameterizedCorrect = \n\n    type ParameterizedEmployee<'Location>(name, age:float, location:'Location, getLocationName) = \n        member this.Name = name\n        member this.Age = age\n        member this.Location = location\n        member this.LocationName = getLocationName location  // ok\n\n    type Location(name, employees: ParameterizedEmployee<Location> list) = \n        let mutable employees = employees\n        member this.Name = name\n        member this.Employees  = employees \n        member this.SetEmployees es = \n            employees <- es\n        member this.AverageAge = \n            employees |> List.averageBy (fun e -> e.Age) \n```", "```\nmodule StructuralDependencyWithAge_ParameterizedCorrect = \n\n    // same code as above\n\n    // create a helper function to construct Employees\n    let Employee(name, age, location) = \n        let getLocationName (l:Location) = l.Name\n        new ParameterizedEmployee<Location>(name, age, location, getLocationName) \n```", "```\nmodule StructuralDependencyWithAge_ParameterizedCorrect = \n\n    // same code as above\n\n    module Test = \n        let location = new Location(\"CA\",[])       \n        let alice = Employee(\"Alice\",20.0,location)       \n        let bob = Employee(\"Bob\",30.0,location)      \n        location.SetEmployees [alice;bob]\n\n        location.Employees  // non-empty!\n        |> List.iter (fun employee -> \n            printfn \"employee %s works at %s\" employee.Name employee.LocationName) \n```", "```\nmodule StructuralDependencyExample_SeparateTypes = \n\n    module DomainTypes = \n        type Employee = {name:string; age:float; location:Location}\n        and Location = {name:string; mutable employees: Employee list}\n\n    module Employee = \n        open DomainTypes \n\n        let Name (employee:Employee) = employee.name\n        let Age (employee:Employee) = employee.age\n        let Location (employee:Employee) = employee.location\n        let LocationName (employee:Employee) = employee.location.name\n\n    module Location = \n        open DomainTypes \n\n        let Name (location:Location) = location.name\n        let Employees (location:Location) = location.employees\n        let AverageAge (location:Location) =\n            location.employees |> List.averageBy (fun e -> e.age)\n\n    module Test = \n        open DomainTypes \n\n        let location = { name=\"NY\"; employees= [] }\n        let alice = {name=\"Alice\"; age=20.0; location=location  }\n        let bob = {name=\"Bob\"; age=30.0; location=location }\n        location.employees <- [alice;bob]\n\n        Location.Employees location\n        |> List.iter (fun e -> \n            printfn \"employee %s works at %s\" (Employee.Name e) (Employee.LocationName e) ) \n```", "```\nmodule StructuralDependencyExample_SeparateTypes2 = \n\n    module DomainTypes = \n        type Employee = {name:string; age:float; location:Location}\n        and Location = {name:string; mutable employees: Employee list}\n\n    module Employee = \n        open DomainTypes \n\n        let LocationName employee = employee.location.name\n\n    module Location = \n        open DomainTypes \n\n        let AverageAge location =\n            location.employees |> List.averageBy (fun e -> e.age) \n```", "```\nmodule LocationOfThings =\n\n    type Location<'Thing> = {name:string; mutable things: 'Thing list}\n\n    type Employee = {name:string; age:float; location:Location<Employee> }\n    type WorkLocation = Location<Employee>\n\n    type Product = {SKU:string; price:float }\n    type Warehouse = Location<Product>\n\n    type Book = {title:string; author:string}\n    type Library = Location<Book> \n```", "```\nmodule StructuralDependencyExample_SeparateTypes_Parameterized = \n\n    module DomainTypes = \n        type Location<'Thing> = {name:string; mutable things: 'Thing list}\n        type Employee = {name:string; age:float; location:Location<Employee> }\n\n    module Employee = \n        open DomainTypes \n\n        let LocationName employee = employee.location.name\n\n    module Test = \n        open DomainTypes \n\n        let location = { name=\"NY\"; things = [] }\n        let alice = {name=\"Alice\"; age=20.0; location=location  }\n        let bob = {name=\"Bob\"; age=30.0; location=location }\n        location.things <- [alice;bob]\n\n        let employees = location.things\n        employees \n        |> List.iter (fun e -> \n            printfn \"employee %s works at %s\" (e.name) (Employee.LocationName e) ) \n\n        let averageAge = \n            employees \n            |> List.averageBy (fun e -> e.age) \n```", "```\nmodule Employee = \n\n    let AverageAgeAtLocation location = \n        location.things |> List.averageBy (fun e -> e.age) \n```", "```\nmodule StructuralDependencyExample_Normalized = \n\n    module DomainTypes = \n        type Relationship<'Left,'Right> = 'Left * 'Right\n\n        type Location= {name:string}\n        type Employee = {name:string; age:float }\n\n    module Employee = \n        open DomainTypes \n\n        let EmployeesAtLocation location relations = \n            relations\n            |> List.filter (fun (loc,empl) -> loc = location) \n            |> List.map (fun (loc,empl) -> empl) \n\n        let AverageAgeAtLocation location relations = \n            EmployeesAtLocation location relations \n            |> List.averageBy (fun e -> e.age) \n\n    module Test = \n        open DomainTypes \n\n        let location = { Location.name=\"NY\"}\n        let alice = {name=\"Alice\"; age=20.0; }\n        let bob = {name=\"Bob\"; age=30.0; }\n        let relations = [ \n            (location,alice)\n            (location,bob) \n            ]\n\n        relations \n        |> List.iter (fun (loc,empl) -> \n            printfn \"employee %s works at %s\" (empl.name) (loc.name) ) \n```", "```\nmodule InheritanceDependencyExample = \n\n    type Control(name, form:Form) = \n        member this.Name = name\n\n        abstract Form : Form\n        default this.Form = form\n\n    and Form(name) as self = \n        inherit Control(name, self)\n\n    // test\n    let form = new Form(\"form\")       // NullReferenceException!\n    let button = new Control(\"button\",form) \n```", "```\nmodule InheritanceDependencyExample2 = \n\n    [<AbstractClass>]\n    type Control(name) = \n        member this.Name = name\n\n        abstract Form : Form\n\n    and Form(name) = \n        inherit Control(name)\n\n        override this.Form = this\n\n    and Button(name,form) = \n        inherit Control(name)\n\n        override this.Form = form\n\n    // test\n    let form = new Form(\"form\")       \n    let button = new Button(\"button\",form) \n```", "```\nmodule InheritanceDependencyExample_ParameterizedClasses = \n\n    [<AbstractClass>]\n    type Control<'Form>(name) = \n        member this.Name = name\n\n        abstract Form : 'Form\n\n    type Form(name) = \n        inherit Control<Form>(name)\n\n        override this.Form = this\n\n    type Button(name,form) = \n        inherit Control<Form>(name)\n\n        override this.Form = form\n\n    // test\n    let form = new Form(\"form\")       \n    let button = new Button(\"button\",form) \n```"]