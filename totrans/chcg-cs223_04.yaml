- en: Crash Course in Asymptotic Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us review the basic mathematical techniques for describing the time- and
    space-efficiency of algorithms. The "costs" of algorithmic operations are typically
    specified as functions of (properties of) their inputs. As a result, tools are
    required to "compare" functions.
  prefs: []
  type: TYPE_NORMAL
- en: Big-O Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*f(n)* is *O(g(n))* if there exist constants *c > 0* and *N > 0* such that
    for all *n ≥ N*, *f(n) ≤ c·g(n)*. This is read "*f(n)* is Big-O of *g(n)*". Definitions
    sometimes vary in their uses of *>, ≥, <, and ≤*, but these differences do not
    matter much.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: '*f[1](n) = n/100*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f[2](n) = 100n*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f[3](n) = 100n + 23*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f[1](n) is O(n)* because'
  prefs: []
  type: TYPE_NORMAL
- en: '*f[1](n) ≤ n* for all *n ≥ 0*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f[2](n) is O(n)* because'
  prefs: []
  type: TYPE_NORMAL
- en: '*f[2](n) ≤ 100·n* for all *n ≥ 0*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f[3](n) is O(n)* because'
  prefs: []
  type: TYPE_NORMAL
- en: '*f[3](n) ≤ 101·n* for all *n ≥ 23*, or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f[3](n) ≤ 102·n* for all *n ≥ 12*, or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f[3](n) ≤ 111·n* for all *n ≥ 3*, or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f[3](n) ≤ 200·n* for all *n ≥ 0*, or ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In computer science settings, *g(n)* is often referred to as Big-Omega of *f(n)*
    (written *g(n)* is *Ω(f(n))*) if *f(n)* is *O(g(n))*. However, this definition
    conflicts with [other definitions of Big-Omega](http://en.wikipedia.org/wiki/Big_O_notation#Related_asymptotic_notations).
  prefs: []
  type: TYPE_NORMAL
- en: Tight Bounds
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Big-O relationship specifies an asymptotic upper bound but provides no information
    about how "tight" the bound is. For example, *n²* is *O(n⁴)*, but this bound is
    not as informative as other valid upper bounds.
  prefs: []
  type: TYPE_NORMAL
- en: It is often useful to establish a lower bound *L(n)* for a function *f(n)* (such
    that *L(n)* is *O(f(n))*) in addition to an upper bound *U(n)* (such that *f(n)*
    is *O(U(n))*). When *L = U*, the bound is referred to as tight.
  prefs: []
  type: TYPE_NORMAL
- en: Tight bounds are described by Big-Theta notation. That is, *f(n)* is *Θ(g(n))*
    if *f(n)* is *O(g(n))* and *g(n)* is *O(f(n))*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Exercise** — Prove that for all *i* and *j*, *log[i](n)* is *O(log[j](n))*.
    Hint: for all *b*, *log[b](x) = (ln x) / (ln b)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unless otherwise noted, we write *O(log(n))* as shorthand for *O(log[2](n))*.
    Considering the fact above, this convention is justified with respect to asymptotic
    growth rates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Optional Exercise** — Define an ordering *[f[1], f[2], f[3,]...]* of the
    functions below such that for all *i* and *j*, *i < j* implies *f[i]* is *O(f[j])*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*2^n*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*4*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sqrt(n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n²+3n*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*log(n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n·log(n)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n!*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n⁵ - n⁴*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*1.5^n*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recurrence Relations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will consider a couple simple algorithms that traverse data structures looking
    for a particular element.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup in Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is a simple `find` function that traverses the list `xs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We want to define a function *T(n)* to describe the time cost of `find`, where
    *n* is the size of (i.e. number of elements in) the `xs` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three cases to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: If `xs` is `[]`, then `find` returns after some constant *c1* amount of work
    for the pattern matching. So, *T(n) = c1*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the head `y` of the list equals `x`, then `find` returns after some constant
    *c2* amount of work for the pattern matching and equality test (note that we are
    assuming that `(==)` is a constant-time operation, which may not always be a reasonable
    assumption). So, *T(n) = c2*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, `find` performs some constant *c3* amount of work for the pattern
    matching and comparison *and* also recursively calls `find` with the rest of the
    list `xs'`. So, *T(n) = c3 + T(n-1)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To compute an upper bound on the running time of `find`, we must consider the
    worst case, which means traversing the entire list without finding the desired
    element `x`. By unrolling the three cases above for the entire list, we obtain
    the following recurrence relation below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute a closed form solution for *T(n)*, we sum the system of equations
    and obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because, *T(n)* is *O(n)*, we say that `find` runs in worst-case *O(n)* time.
    It is hardly more work to show that *T(n)* is *Θ(n)*, which is the kind of tight
    bound that we are usually interested in. However, it is common to informally refer
    to Big-O even when a Big-Theta bound is known.
  prefs: []
  type: TYPE_NORMAL
- en: What about the running time of `find` if the input list `xs` is sorted? Even
    so, the worst case for the function is that `x` is absent from the list, and the
    only way to be sure is to traverse all of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this *linear search* algorithm is guided by the constraint that, in
    a purely functional language, only the *head* of a list can be accessed at once.
    In a language with pointers or references, *arbitrary* elements of a list can
    be accessed in constant-time (such lists are usually called arrays). The cost
    of the *binary search* algorithm on arrays has a much smaller asymptotic growth
    rate. (Later, we will see how purely functional languages typically provide an
    array data structure.)
  prefs: []
  type: TYPE_NORMAL
- en: Lookup in Binary Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An analogous lookup function on binary trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Without knowing anything about the structure of the tree, `findBT` must search
    the entire tree, by recursively traversing the `left` and `right` subtrees in
    the worst case. If the size of `t` = `Node y left right` is *n*, then the combined
    size of `left` and `right` is *n-1*. Therefore, making both recursive calls takes
    time *T(n-1)* in total. This leads to the following recurrence relation, where
    we make use of constants *c* and *c'* for operations involved in the worst (requiring
    both recursive calls) and best (inspecting the `Empty` tree) cases, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As a result, `findBT` runs in worst-case *O(n)* time (in fact, in *Θ(n)* time).
  prefs: []
  type: TYPE_NORMAL
- en: Lookup in Binary Search Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A binary tree satisfies the *binary search order* property if for every subtree
    of the form `Node x left right`, all `Node`s in `left` store values `y` such that
    `y < x` and all `Node`s in `right` store values `y` such that `x < y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that a tree `t` satisfies this ordering property, `findBST` is defined
    to look *only* in the subtree that contain the desired element `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The recurrence relation for `findBST`, however, looks just like the one for
    `findBT`; even though only one recursive call is made in the worst case (either
    to `left` or `right`), the worst case size of the traversed subtree is *n-1*.
    Therefore, `findBST` runs in *O(n)* time.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup in Balanced Binary Search Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a binary-search ordered tree is also *balanced*, where every subtree''s
    children are roughly the same size (there are various reasonable definitions,
    as we will see later in the course), then the recurrence relation for `findBST`
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As opposed to *n* recursive calls in the worst case before, there are now at
    most *log[2](n)* recursive calls, because each child tree is (roughly) half the
    size. Therefore, `findBST` runs in worst-case *O(n·log[2](n)* time when the tree
    is balanced.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are not being thorough in tracking exactly what the sizes of
    subtrees are, and we are simply taking them to be half the size of the entire
    tree. Although this can and should be rigorously worked out, in the end it does
    not matter, because of the wiggle room provided by the constants and inequalities
    in the definitions of rates of growth. If you are not already comfortable with
    this material, you may wish to read more background on these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optional
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A more long-winded primer on asymptotic analysis and recurrence relations (using
    Java programming examples) can be found in Chapters 7 and 8 of [these notes](http://people.cs.uchicago.edu/~rchugh/static/classes/introhwandsw.pdf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comprehensive presentation of these topics can be found in the classic [CLRS
    textbook](http://mitpress.mit.edu/books/introduction-algorithms).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
