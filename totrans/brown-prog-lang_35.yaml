- en: 35Glossary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ☞ bandwidth
  prefs: []
  type: TYPE_NORMAL
- en: The bandwidth between two network nodes is the quantity of data that can be
    transferred in a unit of time between the nodes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ cache
  prefs: []
  type: TYPE_NORMAL
- en: 'A cache is an instance of a [☛ space-time tradeoff](#%28elem._glossary-space-time._tradeoff%29):
    it trades space for time by using the space to avoid recomputing an answer. The
    act of using a cache is called caching. The word “cache” is often used loosely;
    I use it only for information that can be perfectly reconstructed even if it were
    lost: this enables a program that needs to reverse the trade—<wbr>i.e., use less
    space in return for more time—<wbr>to do so safely, knowing it will lose no information
    and thus not sacrifice correctness.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ coinduction
  prefs: []
  type: TYPE_NORMAL
- en: Coinduction is a proof principle for mathematical structures that are equipped
    with methods of observation rather than of construction. Conversely, functions
    over inductive data take them apart; functions over coinductive data construct
    them. The [classic tutorial](http://www.cs.ru.nl/~bart/PAPERS/JR.pdf) on the topic
    will be useful to mathematically sophisticated readers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ idempotence
  prefs: []
  type: TYPE_NORMAL
- en: An idempotent operator is one whose repeated application to any value in its
    domain yields the same result as a single application (note that this implies
    the range is a subset of the domain). Thus, a function \(f\) is idempotent if,
    for all \(x\) in its domain, \(f(f(x)) = f(x)\) (and by induction this holds for
    additional applications of \(f\)).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ invariants
  prefs: []
  type: TYPE_NORMAL
- en: Invariants are assertions about programs that are intended to always be true
    (“in-vary-ant”—<wbr>never varying). For instance, a sorting routine may have as
    an invariant that the list it returns is sorted.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ latency
  prefs: []
  type: TYPE_NORMAL
- en: The latency between two network nodes is the time it takes for packets to get
    between the nodes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ metasyntactic variable
  prefs: []
  type: TYPE_NORMAL
- en: A metasyntactic variable is one that lives outside the language, and ranges
    over a fragment of syntax. For instance, if I write “for expressions e1 and e2,
    the sum e1 + e2”, I do not mean the programmer literally wrote “e1” in the program;
    rather I am using e1 to refer to whatever the programmer might write on the left
    of the addition sign. Therefore, e1 is metasyntax.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ packed representation
  prefs: []
  type: TYPE_NORMAL
- en: At the machine level, a packed representation is one that ignores traditional
    alignment boundaries (in older or smaller machines, bytes; on most contemporary
    machines, words) to let multiple values fit inside or even spill over the boundary.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For instance, say we wish to store a vector of four values, each of which represents
    one of four options. A traditional representation would store one value per alignment
    boundary, thereby consuming four units of memory. A packed representation would
    recognize that each value requires two bits, and four of them can fit into eight
    bits, so a single byte can hold all four values. Suppose instead we wished to
    store four values representing five options each, therefore requiring three bits
    for each value. A byte- or word-aligned representation would not fundamentally
    change, but the packed representation would use two bytes to store the twelve
    bits, even permitting the third value’s three bytes to be split across a byte
    boundary.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Of course, packed representations have a cost. Extracting the values requires
    more careful and complex operations. Thus, they represent a classic [☛ space-time
    tradeoff](#%28elem._glossary-space-time._tradeoff%29): using more time to shrink
    space consumption. More subtly, packed representations can confound certain run-time
    systems that may have expected data to be aligned.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ parsing
  prefs: []
  type: TYPE_NORMAL
- en: 'Parsing is, very broadly speaking, the act of converting content in one kind
    of structured input into content in another. The structures could be very similar,
    but usually they are quite different. Often, the input format is simple while
    the output format is expected to capture rich information about the content of
    the input. For instance, the input might be a linear sequence of chacters on an
    input stream, and the output might be expected to be a rich, tree-structured according
    to some datatype: most program and natural-language parsers are faced with this
    task.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ reduction
  prefs: []
  type: TYPE_NORMAL
- en: Reduction is a relationship between a pair of situations—<wbr>problems, functions,
    data structures, etc.—<wbr>where one is defined in terms of the other. A reduction
    R is a function from situations of the form P to ones of the form Q if, for every
    instance of P, R can construct an instance of Q such that it preserves the meaning
    of P. Note that the converse strictly does not need to hold.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ space-time tradeoff
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have an expensive computation that always produces the same answer
    for a given set of inputs. Once you have computed the answer once, you now have
    a choice: store the answer so that you can simply look it up when you need it
    again, or throw it away and re-compute it the next time. The former uses more
    space, but saves time; the latter uses less space, but consumes more time. This,
    at its heart, is the space-time tradeoff. Memoization [REF], using a [☛ cache](#%28elem._glossary-cache%29),
    environments ([From Substitution to Environments](Interpreting_Functions.html#%28part._subst-to-env%29)),
    etc. are all instances of it.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ type variable
  prefs: []
  type: TYPE_NORMAL
- en: Type variables are identifiers in the type language that (usually) range over
    actual types.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ☞ wire format
  prefs: []
  type: TYPE_NORMAL
- en: A notation used to transmit data across, as opposed to within, a closed platform
    (such as a virtual machine). These are usually expected to be relatively simple
    because they must be implemented in many languages and on weak processes. They
    are also expected to be unambiguous to aid simple, fast, and correct parsing.
    Popular examples include XML [REF], JSON [REF], and s-expressions [REF].
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
