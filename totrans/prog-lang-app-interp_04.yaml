- en: 4A First Taste of Desugaring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve begun with a very spartan arithmetic language. Let’s look at how we might
    extend it with more arithmetic operations that can nevertheless be expressed in
    terms of existing ones. We’ll add just two, because these will suffice to illustrate
    the point.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '4.1Extension: Binary Subtraction'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll add subtraction. Because our language already has numbers, addition,
    and multiplication, it’s easy to define subtraction: \(a - b = a + -1 \times b\).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, that was easy! But now we should turn this into concrete code. To do
    so, we face a decision: where does this new subtraction operator reside? It is
    tempting, and perhaps seems natural, to just add one more rule to our existing
    ArithC datatype.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: What are the negative consequences of modifying ArithC?
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This creates a few problems. The first, obvious, one is that we now have to
    modify all programs that process ArithC. So far that’s only our interpreter, which
    is pretty simple, but in a more complex implementation, that could already be
    a concern. Second, we were trying to add new constructs that we can define in
    terms of existing ones; it feels slightly self-defeating to do this in a way that
    isn’t modular. Third, and most subtly, there’s something conceptually wrong about
    modifying ArithC. That’s because ArithC represents our core language. In contrast,
    subtraction and other additions represent our user-facing, surface language. It’s
    wise to record conceptually different ideas in distinct datatypes, rather than
    shoehorn them into one. The separation can look a little unwieldy sometimes, but
    it makes the program much easier for future developers to read and maintain. Besides,
    for different purposes you might want to layer on different extensions, and separating
    the core from the surface enables that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we’ll define a new datatype to reflect our intended surface syntax
    terms:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '| (define-type ArithS |'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [numS (n : number)] |'
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [plusS (l : ArithS) (r : ArithS)] |'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [bminusS (l : ArithS) (r : ArithS)] |'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   [multS (l : ArithS) (r : ArithS)]) |'
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: This looks almost exactly like ArithC, other than the added case, which follows
    the familiar recursive pattern.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Given this datatype, we should do two things. First, we should modify our parser
    to also parse - expressions, and always construct ArithS terms (rather than any
    ArithC ones). Second, we should implement a desugar function that translates ArithS
    values into ArithC ones.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the obvious part of desugar:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[<desugar>](#(elem._(chunk._~3cdesugar~3e~3a1))) ::='
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '| (define (desugar [as : ArithS]) : ArithC |'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|   (type-case ArithS as |'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [numS (n) (numC n)] |'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [plusS (l r) (plusC (desugar l) |'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (desugar r))] |'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [multS (l r) (multC (desugar l) |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                         (desugar r))] |'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|     [<bminusS-case>](#(elem._(chunk._~3cbminus.S-case~3e~3a1))))) |'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Now let’s convert the mathematical description of subtraction above into code:[<bminusS-case>](#(elem._(chunk._~3cbminus.S-case~3e~3a1)))
    ::=
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '| [bminusS (l r) (plusC (desugar l) |'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '|                       (multC (numC -1) (desugar r)))] |'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: Do Now!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: It’s a common mistake to forget the recursive calls to desugar on l and r. What
    happens when you forget them? Try for yourself and see.
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '4.2Extension: Unary Negation'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s consider another extension, which is a little more interesting: unary
    negation. This forces you to do a little more work in the parser because, depending
    on your surface syntax, you may need to look ahead to determine whether you’re
    in the unary or binary case. But that’s not even the interesting part!'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways we can desugar unary negation. We can define it naturally
    as \(-b = 0 - b\), or we could abstract over the desugaring of binary subtraction
    with this expansion: \(-b = 0 + -1 \times b\).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Which one do you prefer? Why?
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It’s tempting to pick the first expansion, because it’s much simpler. Imagine
    we’ve extended the ArithS datatype with a representation of unary negation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '| [uminusS (e : ArithS)] |'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Now the implementation in desugar is straightforward:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '| [uminusS (e) (desugar (bminusS (numS 0) e))] |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'Let’s make sure the types match up. Observe that e is a ArithS term, so it
    is valid to use as an argument to bminusS, and the entire term can legally be
    passed to desugar. It is therefore important to not desugar e but rather embed
    it directly in the generated term. This embedding of an input term in another
    one and recursively calling desugar is a common pattern in desugaring tools; it
    is called a macro (specifically, the “macro” here is this definition of uminusS).However,
    there are two problems with the definition above:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that the recursion is generative, which forces us to take extra
    care.If you haven’t heard of generative recursion before, read the section on
    it in [How to Design Programs](http://www.htdp.org/). Essentially, in generative
    recursion the sub-problem is a computed function of the input, rather than a structural
    piece of it. This is an especially simple case of generative recursion, because
    the “function” is simple: it’s just the bminusS constructor. We might be tempted
    to fix this by using a different rewrite:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [uminusS (e) (bminusS (numS 0) (desugar e))] |'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_TB
- en: which does indeed eliminate the generativity.Do Now!
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unfortunately, this desguaring transformation won’t work at all! Do you see
    why? If you don’t, try to run it.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second is that we are implicitly depending on exactly what bminusS means;
    if its meaning changes, so will that of uminusS, even if we don’t want it to.
    In contrast, defining a functional abstraction that consumes two terms and generates
    one representing the addition of the first to -1 times the second, and using this
    to define the desugaring of both uminusS and bminusS, is a little more fault-tolerant.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might say that the meaning of subtraction is never going to change, so why
    bother? Yes and no. Yes, it’s meaning is unlikely to change; but no, its implementation
    might. For instance, the developer may decide to log all uses of binary subtraction.
    In the macro expansion, all uses of unary negation would also get logged, but
    they would not in the second expansion.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会说减法的含义永远不会改变，所以为什么要费心呢？是的和不是。是的，它的含义不太可能改变；但不是，它的实现可能会改变。例如，开发者可能决定记录所有二进制减法的使用情况。在宏展开中，所有一元否定的使用情况也会被记录下来，但在第二次展开中则不会。
- en: Fortunately, in this particular case we have a much simpler option, which is
    to define \(-b = -1 \times b\). This expansion works with the primitives we have,
    and follows structural recursion. The reason we took the above detour, however,
    is to alert you to these problems, and warn that you might not always be so fortunate.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在这种特殊情况下，我们有一个更简单的选项，即定义\(-b = -1 \times b\)。这种展开适用于我们拥有的原语，并遵循结构递归。然而，我们上面的绕道之所以有所警示，是为了提醒您这些问题，并警告您可能并不总是如此幸运。
