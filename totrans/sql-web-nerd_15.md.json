["```\n> create table product_categories (\n> \tproduct_category_id\tinteger primary key,\n> \tproduct_category_name\tvarchar(100) not null\n> );\n> \n> create table manufacturers (\n> \tmanufacturer_id\t\tinteger primary key,\n> \tmanufacturer_name\tvarchar(100) not null\n> );\n> \n> create table products (\n> \tproduct_id\t\tinteger primary key,\n> \tproduct_name\t\tvarchar(100) not null,\n> \tproduct_category_id\treferences product_categories,\n> \tmanufacturer_id\t\treferences manufacturers\n> );\n> \n> create table cities (\n> \tcity_id\t\t\tinteger primary key,\n> \tcity_name\t\tvarchar(100) not null,\n> \tstate\t\t\tvarchar(100) not null,\n> \tpopulation\t\tinteger not null\n> );\n> \n> create table stores (\n> \tstore_id\t\tinteger primary key,\n> \tcity_id\t\t\treferences cities,\n> \tstore_location\t\tvarchar(200) not null,\n> \tphone_number\t\tvarchar(20)\t\n> );\n> \n> create table sales (\n> \tproduct_id\tnot null references products,\n> \tstore_id\tnot null references stores,\n> \tquantity_sold\tinteger not null,\n> \t-- the Oracle \"date\" type is precise to the second\n> \t-- unlike the ANSI date datatype\n> \tdate_time_of_sale\tdate not null\n> );\n> \n> -- put some data in \n> \n> insert into product_categories values (1, 'toothpaste');\n> insert into product_categories values (2, 'soda');\n> \n> insert into manufacturers values (68, 'Colgate');\n> insert into manufacturers values (5, 'Coca Cola');\n> \n> insert into products values (567, 'Colgate Gel Pump 6.4 oz.', 1, 68);\n> insert into products values (219, 'Diet Coke 12 oz. can', 2, 5);\n> \n> insert into cities values (34, 'San Francisco', 'California', 700000);\n> insert into cities values (58, 'East Fishkill', 'New York', 30000);\n> \n> insert into stores values (16, 34, '510 Main Street', '415-555-1212');\n> insert into stores values (17, 58, '13 Maple Avenue', '914-555-1212');\n> \n> insert into sales values (567, 17, 1, to_date('1997-10-22 09:35:14', 'YYYY-MM-DD HH24:MI:SS'));\n> insert into sales values (219, 16, 4, to_date('1997-10-22 09:35:14', 'YYYY-MM-DD HH24:MI:SS'));\n> insert into sales values (219, 17, 1, to_date('1997-10-22 09:35:17', 'YYYY-MM-DD HH24:MI:SS'));\n> \n> -- keep track of which dates are holidays\n> -- the presence of a date (all dates will be truncated to midnight)\n> -- in this table indicates that it is a holiday\n> create table holiday_map (\n> holiday_date\t\tdate primary key\n> );\n> \n> -- where the prices are kept\n> create table product_prices (\n> product_id\tnot null references products,\n> from_date\tdate not null,\n> price\t\tnumber not null\n> );\n> \n> insert into product_prices values (567,'1997-01-01',2.75);\n> insert into product_prices values (219,'1997-01-01',0.40);\n> \n> ```", "```\n>  select sum(sales.quantity_sold) from sales, products, product_categories, manufacturers, stores, cities where manufacturer_name = 'Colgate' and product_category_name = 'toothpaste' and cities.population < 40000 and trunc(sales.date_time_of_sale) = trunc(sysdate-1) -- restrict to yesterday and sales.product_id = products.product_id and sales.store_id = stores.store_id and products.product_category_id = product_categories.product_category_id and products.manufacturer_id = manufacturers.manufacturer_id and stores.city_id = cities.city_id; \n> \n> ```", "```\n> select sum(sales.quantity_sold) \n> from sales, holiday_map\n> where trunc(sales.date_time_of_sale) = trunc(holiday_map.holiday_date)\n> \n> ```", "```\n> select sum(sales.quantity_sold) \n> from sales\n> where trunc(sales.date_time_of_sale) \n> not in\n> (select holiday_date from holiday_map)\n> \n> ```", "```\n> select store_id \n> from sales\n> group by store_id\n> having sum(quantity_sold) > 1000\n> \n> ```", "```\n> select sum(quantity_sold) \n> from sales\n> where store_id in\n> (select store_id \n>  from sales\n>  group by store_id\n>  having sum(quantity_sold) > 1000)\n> \n> ```", "```\n> create table sales_fact (\n> \tsales_date\tdate not null,\n> \tproduct_id\tinteger,\n> \tstore_id\tinteger,\n> \tunit_sales\tinteger,\n> \tdollar_sales\tnumber\n> );\n> \n> ```", "```\n> select product_id, sum(dollar_sales)\n> from sales_fact\n> group by product_id\n> \n> ```", "```\n> create table time_dimension (\n> \ttime_key\t\tinteger primary key,\n> \t-- just to make it a little easier to work with; this is \n> \t-- midnight (TRUNC) of the date in question\n> \toracle_date\t\tdate not null,\n> \tday_of_week\t\tvarchar(9) not null, -- 'Monday', 'Tuesday'...\n> \tday_number_in_month\tinteger not null, -- 1 to 31\n> \tday_number_overall\tinteger not null, -- days from the epoch (first day is 1)\n> \tweek_number_in_year\tinteger not null, -- 1 to 52\n> \tweek_number_overall\tinteger not null, -- weeks start on Sunday\n> \tmonth\t\t\tinteger not null, -- 1 to 12\n> \tmonth_number_overall\tinteger not null,\n> \tquarter\t\t\tinteger not null, -- 1 to 4\n> \tfiscal_period\t\tvarchar(10),\n> \tholiday_flag\t\tchar(1) default 'f' check (holiday_flag in ('t', 'f')),\n> \tweekday_flag\t\tchar(1) default 'f' check (weekday_flag in ('t', 'f')),\n> \tseason\t\t\tvarchar(50),\n> \tevent\t\t\tvarchar(50)\n> );\n> \n> ```", "```\n> create table sales_fact (\n> \ttime_key integer not null references time_dimension,\n> \tproduct_id\tinteger,\n> \tstore_id\tinteger,\n> \tunit_sales\tinteger,\n> \tdollar_sales\tnumber\n> );\n> \n> ```", "```\n> select td.season, sum(f.dollar_sales)\n> from sales_fact f, time_dimension td\n> where f.time_key = td.time_key\n> group by td.season\n> \n> ```", "```\n> create table stores_dimension (\n> \tstores_key\t\tinteger primary key,\n> \tname\t\t\tvarchar(100),\n> \tcity\t\t\tvarchar(100),\n> \tcounty\t\t\tvarchar(100),\n> \tstate\t\t\tvarchar(100),\n> \tzip_code\t\tvarchar(100),\n> \tdate_opened\t\tdate,\n> \tdate_remodeled\t\tdate,\n> \t-- 'small', 'medium', 'large', or 'super'\n> \tstore_size\t\tvarchar(100),\n> \t...\n> );\n> \n> ```", "```\n> select sd.city, sum(f.dollar_sales)\n> from sales_fact f, stores_dimension sd\n> where f.stores_key = sd.stores_key\n> group by sd.city\n> \n> ```", "```\n> select sd.city, td.fiscal_period, sum(f.dollar_sales)\n> from sales_fact f, stores_dimension sd, time_dimension td\n> where f.stores_key = sd.stores_key\n> and f.time_key = td.time_key\n> group by sd.stores_key, td.fiscal_period\n> \n> ```", "```\n> We employ a standard star join schema for the following reasons:\n> \n> * Many relational database management systems, including Oracle 8.1,\n> are heavily optimized to execute queries against these schemata.\n> \n> * This kind of schema has been proven to scale to the world's\n> largest data warehouses.\n> \n> * If we hired a data warehousing nerd off the street, he or she\n> would have no trouble understanding our schema.\n> \n> In a star join schema, there is one fact table (\"we sold a pair of\n> khakis at 1:23 pm to Joe Smith\") that references a bunch of dimension\n> tables.  As a general rule, if we're going to narrow our interest\n> based on a column, it should be in the dimension table.  I.e., if\n> we're only looking at sales of grey dressy fabric khakis, we should\n> expect to accomplish that with WHERE clauses on columns of a product\n> dimension table.  By contrast, if we're going to be aggregating\n> information with a SUM or AVG command, these data should be stored in\n> the columns of the fact table.  For example, the dollar amount of the\n> sale should be stored within the fact table.  Since we have so few\n> prices (essentially only one), you might think that this should go in\n> a dimension.  However, by keeping it in the fact table we're more\n> consistent with traditional data warehouses.\n> \n> ```", "```\n> create table time_dimension (\n> \ttime_key\t\tinteger primary key,\n> \t-- just to make it a little easier to work with; this is \n> \t-- midnight (TRUNC) of the date in question\n> \toracle_date\t\tdate not null,\n> \tday_of_week\t\tvarchar(9) not null, -- 'Monday', 'Tuesday'...\n> \tday_number_in_month\tinteger not null, -- 1 to 31\n> \tday_number_overall\tinteger not null, -- days from the epoch (first day is 1)\n> \tweek_number_in_year\tinteger not null, -- 1 to 52\n> \tweek_number_overall\tinteger not null, -- weeks start on Sunday\n> \tmonth\t\t\tinteger not null, -- 1 to 12\n> \tmonth_number_overall\tinteger not null,\n> \tquarter\t\t\tinteger not null, -- 1 to 4\n> \tfiscal_period\t\tvarchar(10),\n> \tholiday_flag\t\tchar(1) default 'f' check (holiday_flag in ('t', 'f')),\n> \tweekday_flag\t\tchar(1) default 'f' check (weekday_flag in ('t', 'f')),\n> \tseason\t\t\tvarchar(50),\n> \tevent\t\t\tvarchar(50)\n> );\n> \n> ```", "```\n> -- Uses the integers table to drive the insertion, which just contains\n> -- a set of integers, from 0 to n.\n> -- The 'epoch' is hardcoded here as July 1, 1998.\n> \n> -- d below is the Oracle date of the day we're inserting.\n> insert into time_dimension\n> (time_key, oracle_date, day_of_week, day_number_in_month, \n>  day_number_overall, week_number_in_year, week_number_overall,\n>  month, month_number_overall, quarter, weekday_flag)\n> select n, d, rtrim(to_char(d, 'Day')), to_char(d, 'DD'), n + 1,\n>        to_char(d, 'WW'),\n>        trunc((n + 3) / 7), -- July 1, 1998 was a Wednesday, so +3 to get the week numbers to line up with the week\n>        to_char(d, 'MM'), trunc(months_between(d, '1998-07-01') + 1),\n>        to_char(d, 'Q'), decode(to_char(d, 'D'), '1', 'f', '7', 'f', 't')\n> from (select n, to_date('1998-07-01', 'YYYY-MM-DD') + n as d\n>       from integers);\n> \n> ```", "```\n> create table fixed_holidays (\n> \tmonth\t\t\tinteger not null check (month >= 1 and month <= 12),=\"\" day=\"\" integer=\"\" not=\"\" null=\"\" check=\"\" (day=\"\">= 1 and day <= 31),=\"\" name=\"\" varchar(100)=\"\" not=\"\" null,=\"\" primary=\"\" key=\"\" (month,=\"\" day)=\"\" );=\"\" --=\"\" specifies=\"\" holidays=\"\" that=\"\" fall=\"\" on=\"\" the=\"\" nth=\"\" day_of_week=\"\" in=\"\" month.=\"\" negative=\"\" means=\"\" count=\"\" backwards=\"\" from=\"\" end.=\"\" create=\"\" table=\"\" floating_holidays=\"\" (=\"\" month=\"\" integer=\"\" null=\"\" check=\"\" (month=\"\">= 1 and month <= 12),=\"\" day_of_week=\"\" varchar(9)=\"\" not=\"\" null,=\"\" nth=\"\" integer=\"\" name=\"\" varchar(100)=\"\" primary=\"\" key=\"\" (month,=\"\" day_of_week,=\"\" nth)=\"\" );=\"\" <=\"\" pre=\"\">\n> ```", "```\n> insert into fixed_holidays (name, month, day) \n>    values ('New Year''s Day', 1, 1);\n> insert into fixed_holidays (name, month, day)\n>    values ('Christmas', 12, 25);\n> insert into fixed_holidays (name, month, day)\n>    values ('Veteran''s Day', 11, 11);\n> insert into fixed_holidays (name, month, day)\n>    values ('Independence Day', 7, 4);\n> \n> insert into floating_holidays (month, day_of_week, nth, name)\n>    values (1, 'Monday', 3, 'Martin Luther King Day');\n> insert into floating_holidays (month, day_of_week, nth, name)\n>    values (10, 'Monday', 2, 'Columbus Day');\n> insert into floating_holidays (month, day_of_week, nth, name)\n>    values (11, 'Thursday', 4, 'Thanksgiving');\n> insert into floating_holidays (month, day_of_week, nth, name)\n>    values (2, 'Monday', 3, 'President''s Day');\n> insert into floating_holidays (month, day_of_week, nth, name)\n>    values (9, 'Monday', 1, 'Labor Day');\n> insert into floating_holidays (month, day_of_week, nth, name)\n>    values (5, 'Monday', -1, 'Memorial Day');\n> \n> ```", "```\n> foreach row in \"select name, month, day from fixed_holidays\"\n>     update time_dimension \n>       set holiday_flag = 't'\n>       where month = row.month and day_number_in_month = row.day;\n> end foreach\n> \n> foreach row in \"select month, day_of_week, nth, name from floating_holidays\"\n>     if row.nth > 0 then\n> \t# If nth is positive, put together a date range constraint\n>         # to pick out the right week.\n>         ending_day_of_month := row.nth * 7\n>         starting_day_of_month := ending_day_of_month - 6\n> \n> \tupdate time_dimension\n>           set holiday_flag = 't'\n>           where month = row.month\n>             and day_of_week = row.day_of_week\n>             and starting_day_of_month <= day_number_in_month\n>             and day_number_in_month <= ending_day_of_month;\n>     else\n> \t# If it is negative, get all the available dates \n>         # and get the nth one from the end.\n>         i := 0;\n>         foreach row2 in \"select day_number_in_month from time_dimension\n>                          where month = row.month\n>                            and day_of_week = row.day_of_week\n>                          order by day_number_in_month desc\"\n>             i := i - 1;\n>             if i = row.nth then\n>                 update time_dimension \n>                   set holiday_flag = 't' \n>                   where month = row.month\n>                     and day_number_in_month = row2.day_number_in_month\n>                 break;\n>             end if\n>         end foreach\n>     end if\n> end foreach\t\n> \n> ```", "```\n> create table product_dimension ( \n> \tproduct_key     integer primary key, \n> \t-- right now this will always be \"ikhakis\" \n> \tproduct_type    varchar(20) not null, \n> \t-- could be \"men\", \"women\", \"kids\", \"unisex adults\" \n> \texpected_consumers      varchar(20), \n> \tcolor           varchar(20), \n> \t-- \"dressy\" or \"casual\" \n> \tfabric          varchar(20), \n> \t-- \"cuffed\" or \"hemmed\" for pants \n> \t-- null for stuff where it doesn't matter \n> \tcuff_state      varchar(20), \n> \t-- \"pleated\" or \"plain front\" for pants \n> \tpleat_state     varchar(20) \n> );\n> \n> ```", "```\n> create table t1 (expected_consumers varchar(20));\n> create table t2 (color varchar(20));\n> create table t3 (fabric varchar(20));\n> create table t4 (cuff_state varchar(20));\n> create table t5 (pleat_state varchar(20));\n> \n> insert into t1 values ('men');\n> insert into t1 values ('women');\n> insert into t1 values ('kids');\n> insert into t1 values ('unisex');\n> insert into t1 values ('adults');\n> [etc.]\n> \n> insert into product_dimension\n> (product_key, product_type, expected_consumers, \n> color, fabric, cuff_state, pleat_state)\n> select \n>   product_key_sequence.nextval, \n>   'ikhakis',\n>   t1.expected_consumers, \n>   t2.color, \n>   t3.fabric,\n>   t4.cuff_state, \n>   t5.pleat_state\n> from t1,t2,t3,t4,t5;\n> \n> ```", "```\n> create table promotion_dimension ( \n> \tpromotion_key           integer primary key, \n> \t-- can be \"coupon\" or \"no coupon\" \n> \tcoupon_state            varchar(20), \n> \t-- a text string such as \"under $10\" \n> \tcoupon_range            varchar(20) \n> ); \n> \n> ```", "```\n> create table consumer_dimension (\n> \tconsumer_key            integer primary key,\n> \t-- 'new customer' or 'repeat customer'\n> \trepeat_class            varchar(20)\n> );\n> \n> ```", "```\n> create table user_experience_dimension ( \n> \tuser_experience_key     integer primary key, \n> \t-- 'shipped on time', 'shipped late' \n> \ton_time_status          varchar(20), \n> \t-- 'kept', 'returned for exchange', 'returned for refund' \n> \treturned_status         varchar(30) \n> ); \n> \n> ```", "```\n> create table ship_to_dimension ( \n> \tship_to_key     integer primary key, \n> \t-- e.g., Northeast \n> \tship_to_region  varchar(30) not null, \n> \tship_to_state   char(2) not null \n> ); \n> \n> create table state_regions ( \n> \tstate           char(2) not null primary key, \n> \tregion          varchar(50) not null \n> ); \n> \n> -- to populate: \n> insert into ship_to_dimension\n> (ship_to_key, ship_to_region, ship_to_state) \n> select ship_to_key_sequence.nextval, region, state \n> from state_regions; \n> \n> ```", "```\n> create table sales_fact ( \n> \t-- keys over to the OLTP production database \n> \torder_id                integer primary key, \n> \tconsumer_id             integer not null, \n> \ttime_key                not null references time_dimension, \n> \tproduct_key             not null references product_dimension, \n> \tpromotion_key           not null references promotion_dimension, \n> \tconsumer_key            not null references consumer_dimension, \n> \tuser_experience_key     not null references user_experience_dimension, \n> \tship_to_key             not null references ship_to_dimension, \n> \t-- time stuff \n> \tminutes_login_to_order          number, \n> \tdays_first_invite_to_order      number, \n> \tdays_order_to_shipment          number, \n> \t-- this will be NULL normally (unless order was returned) \n> \tdays_shipment_to_intent         number, \n> \tpants_id                integer, \n> \tprice_charged           number, \n> \ttax_charged             number, \n> \tshipping_charged        number \n> );\n> \n> ```", "```\n> -- find_product, find_promotion, find_consumer, and find_user_experience\n> -- are PL/SQL procedures that return the appropriate key from the dimension\n> -- tables for a given set of parameters\n> \n> insert into sales_fact \n>  select o.order_id, o.consumer_id, td.time_key,  \n>         find_product(o.color, o.casual_p, o.cuff_p, o.pleat_p),  \n>         find_promotion(o.coupon_id),  \n>         find_consumer(o.pants_id),  \n>         find_user_experience(o.order_state, o.confirmed_date, o.shipped_date),\n>         std.ship_to_key, \n>         minutes_login_to_order(o.order_id, usom.user_session_id),  \n>         decode(sign(o.confirmed_date - gt.issue_date), -1, null, round(o.confirmed_date - gt.issue_date, 6)),  \n>         round(o.shipped_date - o.confirmed_date, 6),  \n>         round(o.intent_date - o.shipped_date, 6), \n>         o.pants_id, o.price_charged, o.tax_charged, o.shipping_charged \n>  from khaki.reportable_orders o, ship_to_dimension std,  \n>       khaki.user_session_order_map usom, time_dimension td,  \n>       khaki.addresses a, khaki.golden_tickets gt \n>  where o.shipping = a.address_id \n>         and std.ship_to_state = a.usps_abbrev \n>         and o.order_id = usom.order_id(+) \n>         and trunc(o.confirmed_date) = td.oracle_date \n>         and o.consumer_id = gt.consumer_id; \n> \n> ```", "```\n    > select count(*) as n_orders,\n    >        round(sum(price_charged)) as total_revenue,\n    >        round(sum(tax_charged)) as total_tax,\n    >        round(sum(shipping_charged)) as total_shipping,\n    >        round(avg(price_charged),2) as avg_price,\n    >        round(avg(days_order_to_shipment),2) as avg_days_to_ship \n    > from sales_fact;\n    > \n    > ```", "```\n    > select round(avg(minutes_login_to_order), 2)\n    > from sales_fact\n    > where minutes_login_to_order < 30\n    > \n    > ```", "```\n    > select round(avg(days_first_invite_to_order), 2)\n    > from sales_fact\n    > where days_first_invite_to_order < 14\n    > \n    > ```", "```\n> select ship_to_region, count(*) as n_pants \n> from sales_fact f, ship_to_dimension s \n> where f.ship_to_key = s.ship_to_key \n> group by ship_to_region \n> order by n_pants desc\n> \n> ```", "```\n> select day_of_week, count(*) as n_pants \n> from sales_fact f, time_dimension t \n> where f.time_key = t.time_key \n> group by day_of_week \n> order by n_pants desc\n> \n> ```", "```\n> select color, count(*) as n_pants, sum(decode(fabric,'dressy',1,0)) as n_dressy \n> from sales_fact f, product_dimension p \n> where f.product_key = p.product_key \n> group by color \n> order by n_pants desc\n> \n> ```", "```\n> create table queries ( \n>         query_id        integer primary key, \n>         query_name      varchar(100) not null, \n>         query_owner     not null references users, \n>         definition_time date not null, \n>         -- if this is non-null, we just forget about all the query_columns \n>         -- stuff; the user has hand-edited the SQL \n>         query_sql       varchar(4000) \n> ); \n> \n> ```", "```\n> -- this specifies the columns we we will be using in a query and \n> -- what to do with each one, e.g., \"select_and_group_by\" or \n> -- \"select_and_aggregate\" \n>  \n> -- \"restrict_by\" is tricky; value1 contains the restriction value, e.g., '40' \n> -- or 'MA' and value2 contains the SQL comparion operator, e.g., \"=\" or \">\" \n>  \n> create table query_columns ( \n>         query_id        not null references queries, \n>         column_name     varchar(30), \n>         pretty_name     varchar(50), \n>         what_to_do      varchar(30), \n>         -- meaning depends on value of what_to_do \n>         value1          varchar(4000), \n>         value2          varchar(4000) \n> ); \n>  \n> create index query_columns_idx on query_columns(query_id); \n> \n> ```", "```\n> create or replace view ad_hoc_query_view  \n> as  \n> select minutes_login_to_order, days_first_invite_to_order, \n>        days_order_to_shipment, days_shipment_to_intent, pants_id,\n>        price_charged, tax_charged, shipping_charged, \n>        oracle_date, day_of_week,\n>        day_number_in_month, week_number_in_year, week_number_overall,\n>        month, month_number_overall, quarter, fiscal_period, \n>        holiday_flag, weekday_flag, season, color, fabric, cuff_state,\n>        pleat_state, coupon_state, coupon_range, repeat_class, \n>        on_time_status, returned_status, ship_to_region, ship_to_state \n> from sales_fact f, time_dimension t, product_dimension p, \n>      promotion_dimension pr, consumer_dimension c, \n>      user_experience_dimension u, ship_to_dimension s \n> where f.time_key = t.time_key \n> and f.product_key = p.product_key \n> and f.promotion_key = pr.promotion_key \n> and f.consumer_key = c.consumer_key \n> and f.user_experience_key = u.user_experience_key \n> and f.ship_to_key = s.ship_to_key; \n> \n> ```", "```\n> -- tell SQL*Plus to turn on query tracing\n> set autotrace on\n> \n> -- let's look at how many pants of each color\n> -- were sold in each region\n> \n> SELECT ship_to_region, color, count(pants_id)\n> FROM ad_hoc_query_view\n> GROUP BY ship_to_region, color;\n> \n> ```", "```\n> Execution Plan \n> ---------------------------------------------------------- \n>    0      SELECT STATEMENT Optimizer=CHOOSE (Cost=181 Card=15 Bytes=2430) \n>    1    0   SORT (GROUP BY) (Cost=181 Card=15 Bytes=2430) \n>    2    1     NESTED LOOPS (Cost=12 Card=2894 Bytes=468828) \n>    3    2       HASH JOIN (Cost=12 Card=885 Bytes=131865) \n>    4    3         TABLE ACCESS (FULL) OF 'PRODUCT_DIMENSION' (Cost=1 Card=336 Bytes=8400) \n>    5    3         HASH JOIN (Cost=6 Card=885 Bytes=109740) \n>    6    5           TABLE ACCESS (FULL) OF 'SHIP_TO_DIMENSION' (Cost=1 Card=55 Bytes=1485) \n>    7    5           NESTED LOOPS (Cost=3 Card=885 Bytes=85845) \n>    8    7             NESTED LOOPS (Cost=3 Card=1079 Bytes=90636) \n>    9    8               NESTED LOOPS (Cost=3 Card=1316 Bytes=93436) \n>   10    9                 TABLE ACCESS (FULL) OF 'SALES_FACT' (Cost=3 Card=1605 Bytes=93090) \n>   11    9                 INDEX (UNIQUE SCAN) OF 'SYS_C0016416' (UNIQUE) \n>   12    8               INDEX (UNIQUE SCAN) OF 'SYS_C0016394' (UNIQUE) \n>   13    7             INDEX (UNIQUE SCAN) OF 'SYS_C0016450' (UNIQUE) \n>   14    2       INDEX (UNIQUE SCAN) OF 'SYS_C0016447' (UNIQUE) \n> \n> ```", "```\n> proc generate_sql_for_query(a_query_id)\n>     select_list_items list;\n>     group_by_items list;\n>     order_clauses list;\n> \n>     foreach row in \"select column_name, pretty_name\n>                     from query_columns  \n>                     where query_id = a_query_id \n>                       and what_to_do = 'select_and_group_by'\"] \n>         if row.pretty_name is null then\n>             append_to_list(group_by_items, row.column_name)\n>         else\n>             append_to_list(group_by_items, row.column_name || ' as \"' || row.pretty_name || '\"'\n>         end if\n>     end foreach\n> \n>     foreach row in \"select column_name, pretty_name, value1 \n>                     from query_columns  \n>                     where query_id = a_query_id \n>                       and what_to_do = 'select_and_aggregate'\"\n>          if row.pretty_name is null then\n> \t    append_to_list(select_list_items, row.value1 || row.column_name)\n>          else\n>             append_to_list(select_list_items, row.value1 || row.column_name || ' as \"' || row.pretty_name || '\"'\n>          end if\n>     end foreach\n> \n>     foreach row in \"select column_name, value1, value2 \n>                     from query_columns  \n>                     where query_id = a_query_id \n>                       and what_to_do = 'restrict_by'\"\n>         append_to_list(where_clauses, row.column_name || ' ' || row.value2 || ' ' || row.value1)\n>     end foreach\n>  \n>     foreach row in \"select column_name \n>                     from query_columns  \n>                     where query_id = a_query_id \n>                       and what_to_do = 'order_by'\"] \n>         append_to_list(order_clauses, row.column_name)\n>     end foreach\n>  \n>     sql := \"SELECT \" || join(select_list_items, ', ') || \n>            \" FROM ad_hoc_query_view\"\n> \n>     if list_length(where_clauses) > 0 then\n>         append(sql, ' WHERE ' || join(where_clauses, ' AND '))\n>     end if\n>  \n>     if list_length(group_by_items) > 0 then\n>         append(sql, ' GROUP BY ' || join(group_by_items, ', '))\n>     end if \n>  \n>     if list_length(order_clauses) > 0 then\n>         append(sql, ' ORDER BY ' || join(order_clauses, ', '))\n>     end if\n>  \n>     return sql\n> end proc\n> \n> ```", "```\n> SELECT ship_to_region, pleat_state, count(pants_id)\n> FROM ad_hoc_query_view\n> GROUP BY ship_to_region, pleat_state\n> \n> ```", "```\n> SELECT ship_to_region, pleat_state, count(pants_id)\n> FROM ad_hoc_query_view\n> WHERE oracle_date > sysdate - 45\n> GROUP BY ship_to_region, pleat_state\n> \n> ```", "```\n> SELECT \n>   ship_to_region, \n>   pleat_state, \n>   count(pants_id),\n>   ratio_to_report(count(pants_id)) over (partition by ship_to_region) as percent_in_region\n> FROM ad_hoc_query_view\n> WHERE oracle_date > sysdate - 45\n> GROUP BY ship_to_region, pleat_state\n> \n> ```", "```\n> select ship_to_region, pleat_state, n_pants, round(percent_in_region*100) \n> from\n> (SELECT \n>    ship_to_region, \n>    pleat_state, \n>    count(pants_id) as n_pants,\n>    ratio_to_report(count(pants_id))\n>         over (partition by ship_to_region) as percent_in_region\n>  FROM ad_hoc_query_view\n>  WHERE oracle_date > sysdate - 45\n>  GROUP BY ship_to_region, pleat_state)\n> \n> ```"]