- en: The `match` FormTuesday, January 17th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syntax for `match` is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The value is matched against each pattern, possibly binding names in the process,
    and if a pattern matches it evaluates the result expression. The simplest form
    of a pattern is simply an identifier — it always matches and binds that identifier
    to the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another simple pattern is a quoted symbol, which matches that symbol. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: will evaluate to `"yes"` if `foo` is the symbol `x`, and to `"no"` otherwise.
    Note that `else` is not a keyword here — it happens to be a pattern that always
    succeeds, so it behaves like an else clause except that it binds `else` to the
    unmatched-so-far value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many patterns look like function application — but don’t confuse them with
    applications. A `(list x y z)` pattern matches a list of exactly three items and
    binds the three identifiers; or if the “arguments” are themselves patterns, `match`
    will descend into the values and match them too. More specifically, this means
    that patterns can be nested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is also a `cons` pattern that matches a non-empty list and then matches
    the first part against the head for the list and the second part against the tail
    of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a `list` pattern, you can use `...` to specify that the previous pattern
    is repeated zero or more times, and bound names get bound to the list of respective
    matching. One simple consequent is that the `(list hd tl ...)` pattern is exactly
    the same as `(cons hd tl)`, but being able to repeat an arbitrary pattern is very
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A few more useful patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The patterns are tried one by one *in-order*, and if no pattern matches the
    value, an error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `...` in a `list` pattern can follow *any* pattern, including all
    of the above, and including nested list patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples — you can try them out with `#lang pl untyped` at the
    top of the definitions window. This:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'matches `x` against a pattern that accepts only a list of symbols, and binds
    `syms` to those symbols. And here’s an example that matches a list of any number
    of lists, where each of the sub-lists begins with a symbol and then has any number
    of numbers. Note how the `n` and `s` bindings get values for a list of all symbols
    and a list of lists of the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a quick example for how `or` is used with two literal alternatives,
    how `and` is used to name a specific piece of data, and how `or` is used with
    a binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
