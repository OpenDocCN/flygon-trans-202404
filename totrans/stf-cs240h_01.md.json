["```\npublic class TestAdder { public void testSum() { Adder adder = new AdderImpl(); assert(adder.add(1, 1) == 2); assert(adder.add(1, 2) == 3); assert(adder.add(2, 2) == 4); assert(adder.add(0, 0) == 0); assert(adder.add(-1, -2) == -3); assert(adder.add(-1, 1) == 0); assert(adder.add(1234, 988) == 2222); } }\n```", "```\npublic class TestAdder { public void testSum() { Adder adder = new AdderImpl(); assert(adder.add(1, 1) == 2); assert(adder.add(1, 2) == 3); assert(adder.add(2, 2) == 4); assert(adder.add(0, 0) == 0); assert(adder.add(-1, -2) == -3); assert(adder.add(-1, 1) == 0); assert(adder.add(1234, 988) == 2222); } }\n```", "```\nimport Data.Word (Word16)\n```", "```\nencodeChar :: ???\n```", "```\nimport Data.Char (ord) ord :: Char -> Int fromIntegral :: (Integral a, Num b) => a -> b\n```", "```\nencodeChar :: Char -> [Word16] encodeChar x | w < 0x10000 = [fromIntegral w] where w = ord x\n```", "```\nimport Data.Bits ((.&.), shiftR)\n```", "```\nencodeChar :: Char -> [Word16] encodeChar x | w < 0x10000 = [fromIntegral w] | otherwise = [fromIntegral a, fromIntegral b] where w = ord x a = ((w - 0x10000) `shiftR` 10) + 0xD800 b = (w .&. 0x3FF) + 0xDC00\n```", "```\nimport Test.HUnit (assertEqual) testASCII = assertEqual \"ASCII encodes as one code unit\" 1 (length (encodeChar 'a'))\n```", "```\nbadTest = do assertEqual \"sestertius encodes as one code unit\" 1 (length (encodeChar '\\x10198'))\n```", "```\nghci> badTest *** Exception: HUnitFailure \"sestertius encodes as one code unit\\nexpected: 1\\n but got: 2\"\n```", "```\ntestASCII = do assertEqual \"ASCII encodes as one code unit\" 1 (length (encodeChar 'a'))\n```", "```\ntestOne char = do assertEqual \"ASCII encodes as one code unit\" 1 (length (encodeChar char))\n```", "```\ntestOne char = do assertEqual \"ASCII encodes as one code unit\" 1 (length (encodeChar char))\n```", "```\ntestASCII = mapM_ testOne ['\\0'..'\\127']\n```", "```\nimport Test.QuickCheck prop_encodeOne c = length (encodeChar c) == 1\n```", "```\nghci> quickCheck prop_encodeOne +++ OK, passed 100 tests.\n```", "```\n+++ OK, passed 100 tests.\n```", "```\nprop_encodeOne c = length (encodeChar c) == 1\n```", "```\n-- Generator type. data Gen a -- The set of types for which we -- can produce random values. class Arbitrary a where  arbitrary :: Gen a\n```", "```\n-- Generate a random value within a range. choose :: Random a => (a,a) -> Gen a instance Arbitrary Bool where arbitrary = choose (False,True) instance Arbitrary Char {- ... -}\n```", "```\n-- Simply protection for a Gen. data Property = MkProperty (Gen a) -- The set of types that can be tested. class Testable prop -- The instance bodies are not interesting. instance Testable Bool instance (Arbitrary a, Show a, Testable prop) => Testable (a -> prop)\n```", "```\nprop_encodeOne :: Char -> Bool prop_encodeOne c = length (encodeChar c) == 1\n```", "```\nquickCheck :: Testable prop => prop -> IO ()\n```", "```\nprop_encodeOne :: Char -> Bool quickCheck :: Testable prop => prop -> IO ()\n```", "```\n-- Satisfied by the result type instance Testable Bool -- Satisfied by the argument and result instance (Arbitrary a, Show a, Testable prop) => Testable (a -> prop)\n```", "```\nmodule Test.QuickCheck.Arbitrary where instance Arbitrary Char where arbitrary = chr `fmap` oneof [choose (0,127), choose (0,255)]\n```", "```\nnewtype BigChar = Big Char deriving (Eq, Show)\n```", "```\ninstance Arbitrary BigChar where arbitrary = {- ... what? ... -}\n```", "```\n-- Generate a random value within a range. choose :: Random a => (a,a) -> Gen a\n```", "```\nimport Control.Arrow (first) import System.Random instance Random BigChar where random = first Big `fmap` random randomR (Big a,Big b) = first Big `fmap` randomR (a,b)\n```", "```\n{-# LANGUAGE GeneralizedNewtypeDeriving #-} import System.Random newtype BigChar = Big Char deriving (Eq, Show, Random)\n```", "```\ninstance Arbitrary BigChar where arbitrary = choose (Big '0',Big '\\x10FFFF')\n```", "```\nprop_encodeOne3 (Big c) = length (encodeChar c) == 1\n```", "```\nghci> quickCheck prop_encodeOne3 *** Failed! Falsifiable (after 1 test): Big '\\317537'\n```", "```\ncurl -O http://cs240h.cs.stanford.edu/ShrinkChar.hs\n```", "```\ninstance Arbitrary BigChar where arbitrary = choose (Big '0',Big '\\x10FFFF') shrink (Big c) = map Big (shrinkChar c) -- Write a body for this. shrinkChar c = undefined\n```", "```\nprop_encodeOne2 = do c <- choose ('\\0', '\\xFFFF') return $ length (encodeChar c) == 1\n```", "```\n-- These two are basically the same, modulo verbosity. prop_encodeOne4 (Big c) = (c < '\\x10000') ==> length (encodeChar c) == 1 prop_encodeOne5 = do Big c <- arbitrary `suchThat` (< Big '\\x10000') return $ length (encodeChar c) == 1\n```", "```\ncurl -O http://cs240h.cs.stanford.edu/Utf16.hs\n```", "```\ndecodeUtf16 :: [Word16] -> [Char]\n```", "```\nsized :: (Int -> Gen a) -> Gen a resize :: Int -> Gen a -> Gen a\n```", "```\nclass Functor f where  fmap :: (a -> b) -> f a -> f b\n```", "```\nliftM :: (Monad m) => (a -> b) -> m a -> m b liftM f action = do b <- action return (f b)\n```", "```\nfmap :: (Functor f) => (a -> b) -> f a -> f b liftM :: (Monad m) => (a -> b) -> m a -> m b\n```", "```\nclass (Functor m) => Monad m where {- blah blah -}\n```", "```\ninstance Monad MyThingy where {- whatever -} instance Functor MyThingy where fmap = liftM\n```", "```\nliftM2 :: (Monad m) => (a -> b -> c) -> m a -> m b -> m b liftM2 f act1 act2 = do a <- act1 b <- act2 return (f a b)\n```", "```\ndata Point a = Point a a instance (Arbitrary a) => Arbitrary (Point a) where arbitrary = do x <- arbitrary y <- arbitrary return (Point x y)\n```", "```\nimport Control.Monad (liftM2) instance (Arbitrary a) => Arbitrary (Point a) where arbitrary = liftM2 Point arbitrary arbitrary\n```", "```\ncurl -O http://cs240h.cs.stanford.edu/TestPoint.hs\n```", "```\nimport Control.Monad import Test.QuickCheck data Point a = Point a a deriving (Eq, Show) instance (Arbitrary a) => Arbitrary (Point a) where arbitrary = liftM2 Point arbitrary arbitrary -- TODO: provide a body for shrink shrink = undefined\n```", "```\ndata Tree a = Node (Tree a) (Tree a) | Leaf a deriving (Show)\n```", "```\ninstance (Arbitrary a) => Arbitrary (Tree a) where arbitrary = oneof [ liftM Leaf arbitrary , liftM2 Node arbitrary arbitrary ]\n```", "```\noneof :: [Gen a] -> Gen a\n```", "```\nsample :: (Show a) => Gen a -> IO ()\n```", "```\ninstance (Arbitrary a) => Arbitrary (Tree a) where arbitrary = sized tree tree :: (Arbitrary a) => Int -> Gen (Tree a) tree 0 = liftM Leaf arbitrary tree n = oneof [ liftM Leaf arbitrary , liftM2 Node subtree subtree ] where subtree = tree (n `div` 2)\n```"]