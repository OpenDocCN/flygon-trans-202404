["```\n    ;; An AE is one of:\u00a0  ; \\;;\u00a0 (make-Num Number) ;\u00a0 > HtDP;;\u00a0 (make-Add AE AE)\u00a0 ; /(define-type AE\u00a0 \u00a0 \u00a0  ; \\\u00a0 [Num number?]\u00a0 \u00a0 \u00a0  ;\u00a0 > Predicates =~= contracts (PLAI)\u00a0 [Add AE? AE?])\u00a0 \u00a0 \u00a0 ; /\u00a0 \u00a0 (has names of defined types too)(define-type AE\u00a0 \u00a0 \u00a0  ; \\\u00a0 [Num Number]\u00a0 \u00a0 \u00a0 \u00a0 ;\u00a0 > Typed Racket (our PL)\u00a0 [Add AE AE])\u00a0 \u00a0 \u00a0 \u00a0 ; /\n    ```", "```\n    #lang typed/racket;; Program goes here.\n    ```", "```\n    #lang pl;; Program goes here.\n    ```", "```\n    ;; f : Number -> Number(define (f x)\u00a0 (* x (+ x 1)))\n    ```", "```\n    #lang pl(: f : Number -> Number)(define (f x)\u00a0 (* x (+ x 1)))\n    ```", "```\n    #lang typed/racket(define (f [x : Number]) : Number\u00a0 (* x (+ x 1)))\n    ```", "```\n    (define-type AE\u00a0 [Num Number]\u00a0 [Add AE AE])\n    ```", "```\n    (define-type AE\u00a0 [Num number?]\u00a0 [Add AE? AE?])\n    ```", "```\n(: digit-num : Number -> (U Number String))(define (digit-num n)\u00a0 (cond [(<= n 9)\u00a0 \u00a0 1]\u00a0 \u00a0 \u00a0 \u00a0 [(<= n 99)\u00a0  2]\u00a0 \u00a0 \u00a0 \u00a0 [(<= n 999)\u00a0 3]\u00a0 \u00a0 \u00a0 \u00a0 [(<= n 9999) 4]\u00a0 \u00a0 \u00a0 \u00a0 [else\u00a0 \u00a0 \u00a0 \u00a0 \"a lot\"]))(: fact : Number -> Number)(define (fact n)\u00a0 (if (zero? n)\u00a0 \u00a0 1\u00a0 \u00a0 (* n (fact (- n 1)))))(: helper : Number Number -> Number)(define (helper n acc)\u00a0 (if (zero? n)\u00a0 \u00a0 acc\u00a0 \u00a0 (helper (- n 1) (* acc n))))(: fact : Number -> Number)(define (fact n)\u00a0 (helper n 1))(: fact : Number -> Number)(define (fact n)\u00a0 (: helper : Number Number -> Number)\u00a0 (define (helper n acc)\u00a0 \u00a0 (if (zero? n)\u00a0 \u00a0 \u00a0 acc\u00a0 \u00a0 \u00a0 (helper (- n 1) (* acc n))))\u00a0 (helper n 1))(: every? : (All (A) (A -> Boolean) (Listof A) -> Boolean));; Returns false if any element of lst fails the given pred,;; true if all pass pred.(define (every? pred lst)\u00a0 (or (null? lst)\u00a0 \u00a0 \u00a0 (and (pred (first lst))\u00a0 \u00a0 \u00a0 \u00a0 \u00a0  (every? pred (rest lst)))))(define-type AE\u00a0 [Num Number]\u00a0 [Add AE AE]\u00a0 [Sub AE AE]);; the only difference in the following definition is;; using (: <name> : <type>) instead of \";; <name> : <type>\"(: parse-sexpr : Sexpr -> AE);; parses s-expressions into AEs(define (parse-sexpr sexpr)\u00a0 (match sexpr\u00a0 \u00a0 [(number: n) (Num n)]\u00a0 \u00a0 [(list '+ left right)\u00a0 \u00a0  (Add (parse-sexpr left) (parse-sexpr right))]\u00a0 \u00a0 [(list '- left right)\u00a0 \u00a0  (Sub (parse-sexpr left) (parse-sexpr right))]\u00a0 \u00a0 [else (error 'parse-sexpr \"bad syntax in ~s\" sexpr)]))\n```", "```\n    (: foo : (U String Number) -> Number)(define (foo x)\u00a0 (if (string? x)\u00a0 \u00a0 (string-length x)\u00a0 \u00a0 ;; at this point it knows that `x' is not a\u00a0 \u00a0 ;; string, therefore it must be a number\u00a0 \u00a0 (+ 1 x)))\n    ```", "```\n    type string_or_number = Str of string | Int of int ;;let foo x = match x with Str s -> String.length s\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0  | Int i -> i+1 ;;\n    ```", "```\n    foo (Str \"bar\") ;;foo (Int 3) ;;\n    ```", "```\n    (define (id x) x)\n    ```", "```\n    (let ([x (id 123)]) (if (number? x) (+ x 10) 999))\n    ```", "```\n    (: id : (All (A) A -> A))\n    ```", "```\n    (: digit-num : Number -> (U Number String))(define (digit-num n)\u00a0 (cond [(<= n 9)\u00a0 \u00a0 1]\u00a0 \u00a0 \u00a0 \u00a0 [(<= n 99)\u00a0  2]\u00a0 \u00a0 \u00a0 \u00a0 [(<= n 999)\u00a0 3]\u00a0 \u00a0 \u00a0 \u00a0 [(<= n 9999) 4]\u00a0 \u00a0 \u00a0 \u00a0 [(>\u00a0 n 9999) \"a lot\"]))\n    ```", "```\n    (> (* n 10) (/ (* (- 10000 1) 20) 2))\n    ```", "```\n    (>= n 10000)\n    ```", "```\n    (: call : (All (A B) (A -> B) A -> B))(define (call f x)\u00a0 (f x))(call rest (list 4))\n    ```", "```\n    (call (inst rest Number) (list 4))\n    ```", "```\n    (call (ann rest : ((Listof Number) -> (Listof Number))) (list 4))\n    ```"]