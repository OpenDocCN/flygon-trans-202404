- en: 'Reading 1: Static Checking'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读 1：静态检查
- en: Objectives for Today’s Class
  id: totrans-1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 今天课程的目标
- en: 'Today’s class has two topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的课程有两个主题：
- en: static typing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态类型检查
- en: the big three properties of good software
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优秀软件的三个关键属性
- en: Hailstone Sequence
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冰雹序列
- en: Many readings include optional videos from the MITx version of 6.005\.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 许多阅读包括来自MITx版本6.005的可选视频。
- en: '[More info about the videos](../../general/#classes_readings_and_nanoquizzes)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[有关视频的更多信息](../../general/#classes_readings_and_nanoquizzes)'
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,hailstone_sequence/4kz_aOjSxms)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,hailstone_sequence/4kz_aOjSxms)'
- en: 'As a running example, we’re going to explore the hailstone sequence, which
    is defined as follows. Starting with a number *n*, the next number in the sequence
    is *n/2* if *n* is even, or *3n+1* if *n* is odd. The sequence ends when it reaches
    1. Here are some examples:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个运行的示例，我们将探讨冰雹序列，其定义如下。从数字*n*开始，序列中的下一个数字如果*n*是偶数，则为*n/2*，如果*n*是奇数，则为*3n+1*。当序列达到1时结束。以下是一些示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because of the odd-number rule, the sequence may bounce up and down before decreasing
    to 1. It’s conjectured that all hailstones eventually fall to the ground – i.e.,
    the hailstone sequence reaches 1 for all starting *n* – but that’s still an [open
    question](https://en.wikipedia.org/wiki/Collatz_conjecture). Why is it called
    a hailstone sequence? Because hailstones form in clouds by bouncing up and down,
    until they eventually build enough weight to fall to earth.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于奇数规则的存在，序列在减少到1之前可能会上下跳动。有人推测所有冰雹最终都会落到地面上——即，所有起始为*n*的冰雹序列最终会达到1，但这仍然是一个[待解决的问题](https://en.wikipedia.org/wiki/Collatz_conjecture)。为什么称它为冰雹序列？因为冰雹在云中通过上下跳动形成，直到最终积累足够的重量落到地面上。
- en: Computing Hailstones
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算冰雹数
- en: 'Here’s some code for computing and printing the hailstone sequence for some
    starting *n*. We’ll write Java and Python side by side for comparison:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些用于计算和打印一些起始为*n*的冰雹序列的代码。我们将Java和Python并排写出来进行比较：
- en: '|'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'A few things are worth noting here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几点值得注意：
- en: 'The basic semantics of expressions and statements in Java are very similar
    to Python: `while` and `if` behave the same, for example.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java中的表达式和语句的基本语义与Python非常相似：例如，`while`和`if`的行为相同。
- en: Java requires semicolons at the ends of statements. The extra punctuation can
    be a pain, but it also gives you more freedom in how you organize your code –
    you can split a statement into multiple lines for more readability.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java要求在语句的末尾加上分号。额外的标点符号可能会让人头疼，但它也使你在组织代码时拥有更多的自由——你可以将一个语句分成多行以增加可读性。
- en: Java requires parentheses around the conditions of the `if` and `while`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java要求在`if`和`while`的条件周围加上括号。
- en: Java requires curly braces around blocks, instead of indentation. You should
    always indent the block, even though Java won’t pay any attention to your extra
    spaces. Programming is a form of communication, and you’re communicating not only
    to the compiler, but to human beings. Humans need that indentation. We’ll come
    back to this later.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java要求在块周围加上大括号，而不是缩进。你应该始终缩进代码块，即使Java不会关注你多出的空格。编程是一种交流形式，你不仅在向编译器传达信息，也在向人类传达信息。人类需要那个缩进。我们稍后会回来讨论这个问题。
- en: Types
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,types/eUb4Cm94TLE)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,types/eUb4Cm94TLE)'
- en: 'The most important semantic difference between the Python and Java code above
    is the declaration of the variable `n`, which specifies its type: `int`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上面Python和Java代码之间最重要的语义差异是变量`n`的声明，指定了它的类型：`int`。
- en: A **type** is a set of values, along with operations that can be performed on
    those values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**是一组值，以及可以对这些值执行的操作。'
- en: 'Java has several **primitive types**, among them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Java有几种**基本类型**，其中包括：
- en: '`int` (for integers like 5 and -200, but limited to the range ± 2^(31), or
    roughly ± 2 billion)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`（用于像5和-200这样的整数，但限制在±2^(31)范围内，大约±20亿）'
- en: '`long` (for larger integers up to ± 2^(63))'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`（用于更大的整数，范围为±2^(63)）'
- en: '`boolean` (for true or false)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean`（表示真或假）'
- en: '`double` (for floating-point numbers, which represent a subset of the real
    numbers)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`（用于浮点数，代表实数的一个子集）'
- en: '`char` (for single characters like `''A''` and `''$''`)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`（用于像`''A''`和`''$''`这样的单个字符）'
- en: 'Java also has **object types**, for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Java还有**对象类型**，例如：
- en: '`String` represents a sequence of characters, like a Python string.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`表示字符序列，类似于Python的字符串。'
- en: '`BigInteger` represents an integer of arbitrary size, so it acts like a Python
    integer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BigInteger` 表示任意大小的整数，因此它的行为类似于Python的整数。'
- en: By Java convention, primitive types are lowercase, while object types start
    with a capital letter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Java的约定，基本类型是小写的，而对象类型以大写字母开头。
- en: '*Operations* are functions that take inputs and produce outputs (and sometimes
    change the values themselves). The syntax for operations varies, but we still
    think of them as functions no matter how they’re written. Here are three different
    syntaxes for an operation in Python or Java:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作* 是接受输入并产生输出（有时还会更改值本身）的函数。操作的语法各不相同，但无论它们如何编写，我们仍然将它们视为函数。以下是Python或Java中一个操作的三种不同语法：'
- en: '*As an infix, prefix, or postfix operator.* For example, `a + b` invokes the
    operation `+ : int × int → int`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为中缀、前缀或后缀运算符。* 例如，`a + b` 调用操作 `+ : int × int → int`。'
- en: '*As a method of an object.* For example, `bigint1.add(bigint2)` calls the operation
    `add: BigInteger × BigInteger → BigInteger`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为对象的方法。* 例如，`bigint1.add(bigint2)` 调用操作 `add: BigInteger × BigInteger → BigInteger`。'
- en: '*As a function.* For example, `Math.sin(theta)` calls the operation `sin: double
    → double`. Here, `Math` is not an object. It’s the class that contains the `sin`
    function.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作为一个函数。* 例如，`Math.sin(theta)` 调用操作 `sin: double → double`。这里，`Math` 不是一个对象。它是包含
    `sin` 函数的类。'
- en: Contrast Java’s `str.length()` with Python’s `len(str)`. It’s the same operation
    in both languages – a function that takes a string and returns its length – but
    it just uses different syntax.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对比Java的 `str.length()` 和 Python的 `len(str)`。在两种语言中，它执行的是相同的操作 - 一个函数，接受一个字符串并返回其长度
    - 但它只是使用了不同的语法。
- en: Some operations are **overloaded** in the sense that the same operation name
    is used for different types. The arithmetic operators `+`, `-`, `*`, `/` are heavily
    overloaded for the numeric primitive types in Java. Methods can also be overloaded.
    Most programming languages have some degree of overloading.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作是**重载**的，即相同的操作名称用于不同的类型。在Java中，算术运算符 `+`、`-`、`*`、`/` 在数字原始类型中被大量重载。方法也可以重载。大多数编程语言都具有某种程度的重载。
- en: Static Typing
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态类型
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,static_typing/DiuLwjz_hdU)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,static_typing/DiuLwjz_hdU)'
- en: Java is a **statically-typed language**. The types of all variables are known
    at compile time (before the program runs), and the compiler can therefore deduce
    the types of all expressions as well. If `a` and `b` are declared as `int`s, then
    the compiler concludes that `a+b` is also an `int`. The Eclipse environment does
    this while you’re writing the code, in fact, so you find out about many errors
    while you’re still typing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Java是一种**静态类型语言**。所有变量的类型在编译时（程序运行之前）就已知，因此编译器也可以推断所有表达式的类型。如果 `a` 和 `b` 被声明为
    `int`，那么编译器会得出 `a+b` 也是一个 `int` 的结论。实际上，Eclipse环境在您输入代码时就会这样做，因此您会在打字时就发现许多错误。
- en: In **dynamically-typed languages** like Python, this kind of checking is deferred
    until runtime (while the program is running).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Python这样的**动态类型语言**中，这种检查被推迟到运行时（程序正在运行时）。
- en: 'Static typing is a particular kind of **static checking**, which means checking
    for bugs at compile time. Bugs are the bane of programming. Many of the ideas
    in this course are aimed at eliminating bugs from your code, and static checking
    is the first idea that we’ve seen for this. Static typing prevents a large class
    of bugs from infecting your program: to be precise, bugs caused by applying an
    operation to the wrong types of arguments. If you write a broken line of code
    like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '静态类型是一种特定类型的**静态检查**，它在编译时检查错误。错误是编程的祸根。本课程中的许多思想都旨在消除代码中的错误，而静态检查是我们看到的第一个旨在实现这一目标的思想。静态类型可以防止程序感染一大类由于将操作应用于错误类型的参数而引起的错误。如果您编写了一行破损的代码，例如： '
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: that tries to multiply two strings, then static typing will catch this error
    while you’re still programming, rather than waiting until the line is reached
    during execution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试将两个字符串相乘，则在编程过程中静态类型将捕捉到此错误，而不是等到执行期间到达该行时。
- en: Static Checking, Dynamic Checking, No Checking
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态检查，动态检查，无检查
- en: 'It’s useful to think about three kinds of automatic checking that a language
    can provide:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 思考语言可以提供的三种自动检查方式是很有用的：
- en: '**Static checking**: the bug is found automatically before the program even
    runs.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态检查**：在程序运行之前自动发现错误。'
- en: '**Dynamic checking**: the bug is found automatically when the code is executed.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态检查**：在执行代码时自动发现错误。'
- en: '**No checking**: the language doesn’t help you find the error at all. You have
    to watch for it yourself, or end up with wrong answers.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无检查**：语言不会帮助您找到错误。您必须自己注意，否则会得到错误的答案。'
- en: Needless to say, catching a bug statically is better than catching it dynamically,
    and catching it dynamically is better than not catching it at all.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，静态捕获错误总比动态捕获好，而动态捕获总比不捕获好。
- en: Here are some rules of thumb for what errors you can expect to be caught at
    each of these times.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些经验法则，指出你可以在每个时间点预期会被捕获的错误。
- en: '**Static checking** can catch:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 静态检查可以捕获：
- en: syntax errors, like extra punctuation or spurious words. Even dynamically-typed
    languages like Python do this kind of static checking. If you have an indentation
    error in your Python program, you’ll find out before the program starts running.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法错误，例如额外的标点符号或多余的单词。即使是像 Python 这样的动态类型语言也会进行这种静态检查。如果您的 Python 程序存在缩进错误，您将在程序开始运行之前就会发现这个问题。
- en: wrong names, like `Math.sine(2)`. (The right name is `sin`.)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的名称，例如`Math.sine(2)`。（正确的名称是 `sin`。）
- en: wrong number of arguments, like `Math.sin(30, 20)`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的参数数量，例如`Math.sin(30, 20)`。
- en: wrong argument types, like `Math.sin("30")`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的参数类型，例如`Math.sin("30")`。
- en: wrong return types, like `return "30";` from a function that’s declared to return
    an `int`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的返回类型，例如从声明为返回 `int` 的函数返回`"30"`。
- en: '**Dynamic checking** can catch:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态检查**可以捕获：'
- en: illegal argument values. For example, the integer expression `x/y` is only erroneous
    when `y` is actually zero; otherwise it works. So in this expression, divide-by-zero
    is not a static error, but a dynamic error.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非法的参数值。例如，整数表达式 `x/y` 仅在 `y` 实际上为零时才出错；否则它可以运行。因此，在这个表达式中，除零错误不是静态错误，而是动态错误。
- en: unrepresentable return values, i.e., when the specific return value can’t be
    represented in the type.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能表示的返回值，即特定返回值无法在类型中表示。
- en: out-of-range indexes, e.g., using a negative or too-large index on a string.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出范围的索引，例如在字符串上使用负值或太大的索引。
- en: calling a method on a `null` object reference (`null` is like Python `None`).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在空对象引用上调用方法（`null`类似于 Python 的 `None`）。
- en: Static checking tends to be about types, errors that are independent of the
    specific value that a variable has. A type is a set of values. Static typing guarantees
    that a variable will have *some* value from that set, but we don’t know until
    runtime exactly which value it has. So if the error would be caused only by certain
    values, like divide-by-zero or index-out-of-range then the compiler won’t raise
    a static error about it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 静态检查倾向于关于类型的错误，这些错误与变量具体的值无关。类型是一组值。静态类型保证变量将具有该集合中的*某些*值，但直到运行时我们才知道它实际上具有哪个值。因此，如果错误仅由某些值引起，例如除以零或索引超出范围，则编译器不会提出静态错误。
- en: Dynamic checking, by contrast, tends to be about errors caused by specific values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，动态检查倾向于关于特定值引起的错误。
- en: 'Surprise: Primitive Types Are Not True Numbers'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惊喜：原始类型并非真正的数字
- en: 'One trap in Java – and many other programming languages – is that its primitive
    numeric types have corner cases that do not behave like the integers and real
    numbers we’re used to. As a result, some errors that really should be dynamically
    checked are not checked at all. Here are the traps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中的一个陷阱——以及许多其他编程语言——是它的原始数值类型有一些边界情况，这些情况的行为与我们习惯的整数和实数不同。因此，一些真正应该被动态检查的错误根本不会被检查。以下是陷阱：
- en: '**Integer division**. `5/2` does not return a fraction, it returns a truncated
    integer. So this is an example of where what we might have hoped would be a dynamic
    error (because a fraction isn’t representable as an integer) frequently produces
    the wrong answer instead.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数除法**。`5/2` 不会返回分数，它返回一个截断的整数。因此，这是一个例子，我们本来希望它是一个动态错误的地方（因为分数不能表示为整数），经常产生错误的答案。'
- en: '**Integer overflow**. The `int` and `long` types are actually finite sets of
    integers, with maximum and minimum values. What happens when you do a computation
    whose answer is too positive or too negative to fit in that finite range? The
    computation quietly *overflows* (wraps around), and returns an integer from somewhere
    in the legal range but not the right answer.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数溢出**。`int` 和 `long` 类型实际上是有限的整数集，具有最大和最小值。当你进行一个计算，其答案太正或太负而无法适应该有限范围时会发生什么？计算会静默地*溢出*（环绕），并返回一个整数，该整数位于合法范围内但不是正确的答案。'
- en: '**Special values in floating-point types**. Floating-point types like `double`
    have several special values that aren’t real numbers: `NaN` (which stands for
    “Not a Number”), `POSITIVE_INFINITY`, and `NEGATIVE_INFINITY`. So when you apply
    certain operations to a `double` that you’d expect to produce dynamic errors,
    like dividing by zero or taking the square root of a negative number, you will
    get one of these special values instead. If you keep computing with it, you’ll
    end up with a bad final answer.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点类型中的特殊值**。像`double`这样的浮点类型有几个不是实数的特殊值：`NaN`（代表“不是数字”）、`POSITIVE_INFINITY`和`NEGATIVE_INFINITY`。因此，当你对`double`应用某些你期望产生动态错误的操作，比如除以零或取负数的平方根时，你会得到这些特殊值之一。如果你继续计算，最终会得到一个错误的最终答案。'
- en: reading exercises
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 阅读练习
- en: Let’s try some examples of buggy code and see how they behave in Java. Are these
    bugs caught statically, dynamically, or not at all?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些有错误的代码示例，并看看它们在Java中的行为如何。这些错误是静态地、动态地捕捉到的，还是根本没有捕捉到？
- en: '1'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: '2'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: '3'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: '4'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: '5'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (missing answer)(missing answer)(missing answer)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失答案）（缺失答案）（缺失答案）
- en: (missing explanation)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: （缺失解释）
- en: Arrays and Collections
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组和集合
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,arrays_and_collections/f4oHmAIC-Fg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,arrays_and_collections/f4oHmAIC-Fg)'
- en: 'Let’s change our hailstone computation so that it stores the sequence in a
    data structure, instead of just printing it out. Java has two kinds of list-like
    types that we could use: arrays and Lists.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的哈尔斯通计算，使其将序列存储在数据结构中，而不仅仅是打印出来。Java有两种我们可以使用的类似列表的类型：数组和列表。
- en: 'Arrays are fixed-length sequences of another type T. For example, here’s how
    to declare an array variable and construct an array value to assign to it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是另一种类型T的固定长度序列。例如，下面是如何声明数组变量并构造数组值以赋给它的：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `int[]` array type includes all possible array values, but a particular
    array value, once created, can never change its length. Operations on array types
    include:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`int[]`数组类型包含所有可能的数组值，但特定的数组值一旦创建，就永远不能改变其长度。数组类型的操作包括：'
- en: 'indexing: `a[2]`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引：`a[2]`
- en: 'assignment: `a[2]=0`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值：`a[2]=0`
- en: 'length: `a.length` (note that this is different syntax from `String.length()`
    – `a.length` is not a method call, so you don’t put parentheses after it)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度：`a.length`（注意这与`String.length()`的语法不同 - `a.length`不是一个方法调用，所以你不需要在它后面加括号）
- en: Here’s a crack at the hailstone code using an array. We start by constructing
    the array, and then use an index variable `i` to step through the array, storing
    values of the sequence as we generate them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用数组的哈尔斯通代码的一个示例。我们首先构造数组，然后使用索引变量`i`来遍历数组，将我们生成的序列值存储起来。
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Something should immediately smell wrong in this approach. What’s that magic
    number 100? What would happen if we tried an n that turned out to have a very
    long hailstone sequence? It wouldn’t fit in a length-100 array. We have a bug.
    Would Java catch the bug statically, dynamically, or not at all? Incidentally,
    bugs like these – overflowing a fixed-length array, which are commonly used in
    less-safe languages like C and C++ that don’t do automatic runtime checking of
    array accesses – have been responsible for a large number of network security
    breaches and internet worms.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法应该立即感觉有问题。那个魔术数字100是什么意思？如果我们尝试一个具有非常长的哈尔斯通序列的n会发生什么？它不会适应长度为100的数组。我们有一个错误。Java是否会静态地、动态地或根本不会捕捉到这个错误？顺便说一句，这样的错误
    - 溢出固定长度数组，这些错误通常在不像C和C++这样不进行数组访问的自动运行时检查的不太安全的语言中使用 - 已经导致了大量的网络安全漏洞和互联网蠕虫。
- en: 'Instead of a fixed-length array, let’s use the `List` type. Lists are variable-length
    sequences of another type `T`. Here’s how we can declare a `List` variable and
    make a list value:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们不使用固定长度数组，而是使用`List`类型。列表是另一种类型`T`的可变长度序列。下面是声明`List`变量并生成列表值的方法：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And here are some of its operations:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些它的操作：
- en: 'indexing: `list.get(2)`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引：`list.get(2)`
- en: 'assignment: `list.set(2, 0)`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值：`list.set(2, 0)`
- en: 'length: `list.size()`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度：`list.size()`
- en: Note that `List` is an interface, a type that can’t be constructed directly
    with new, but that instead specifies the operations that a List must provide.
    We’ll talk about this notion in a future class on abstract data types. `ArrayList`
    is a class, a concrete type that provides implementations of those operations.
    `ArrayList` isn’t the only implementation of the List type, though it’s the most
    commonly used one. `LinkedList` is another. Check them out in the Java API documentation,
    which you can find by searching the web for “Java 8 API”. Get to know the Java
    API docs, they’re your friend. (“API” means “application programmer interface,”
    and is commonly used as a synonym for “library.”)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`List` 是一个接口，一个不能直接用 new 构造的类型，而是指定了一个 List 必须提供的操作。我们将在关于抽象数据类型的未来课程中讨论这个概念。`ArrayList`
    是一个类，一个提供了这些操作的具体类型的实现。`ArrayList` 不是 List 类型的唯一实现，尽管它是最常用的一个。`LinkedList` 是另一个。在
    Java API 文档中查找它们，可以通过在网上搜索“Java 8 API”找到。了解 Java API 文档，它们是你的朋友。（“API” 意味着“应用程序编程接口”，通常被用作“库”的同义词。）
- en: Note also that we wrote `List<Integer>` instead of `List<int>`. Unfortunately
    we can’t write `List<int>` in direct analog to `int[]`. Lists only know how to
    deal with object types, not primitive types. In Java, each of the primitive types
    (which are written in lowercase and often abbreviated, like `int`) has an equivalent
    object type (which is capitalized, and fully spelled out, like `Integer`). Java
    requires us to use these object type equivalents when we parameterize a type with
    angle brackets. But in other contexts, Java automatically converts between `int`
    and `Integer`, so we can write `Integer i = 5` without any type error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们写的是 `List<Integer>` 而不是 `List<int>`。不幸的是，我们无法像 `int[]` 的直接类比那样写 `List<int>`。列表只知道如何处理对象类型，而不是原始类型。在
    Java 中，每个原始类型（以小写字母书写并经常缩写，如 `int`）都有一个对应的对象类型（以大写字母书写，并完整拼写，如 `Integer`）。当我们使用尖括号参数化类型时，Java
    要求我们使用这些对象类型的等价物。但在其他情况下，Java 会自动在 `int` 和 `Integer` 之间转换，所以我们可以毫无类型错误地写 `Integer
    i = 5`。
- en: 'Here’s the hailstone code written with Lists:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用列表编写的雹石代码：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Not only simpler but safer too, because the List automatically enlarges itself
    to fit as many numbers as you add to it (until you run out of memory, of course).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅更简单，而且更安全，因为列表会自动扩展自身以适应添加的数字（当然，直到内存耗尽）。
- en: Iterating
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代
- en: 'A for loop steps through the elements of an array or a list, just as in Python,
    though the syntax looks a little different. For example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: for 循环遍历数组或列表的元素，就像在 Python 中一样，尽管语法看起来有点不同。例如：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can iterate through arrays as well as lists. The same code would work if
    the list were replaced by an array.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遍历数组以及列表。如果列表被数组替换，相同的代码也会起作用。
- en: '`Math.max()` is a handy function from the Java API. The `Math` class is full
    of useful functions like this – search for “java 8 Math” on the web to find its
    documentation.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.max()` 是来自 Java API 的一个方便的函数。`Math` 类中充满了像这样的有用函数 - 在网上搜索“java 8 Math”以找到其文档。'
- en: Methods
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,methods/zfvl9K0DgbQ)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,methods/zfvl9K0DgbQ)'
- en: 'In Java, statements generally have to be inside a method, and every method
    has to be in a class, so the simplest way to write our hailstone program looks
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，语句通常必须在方法内部，每个方法都必须在一个类中，所以编写我们的雹石程序的最简单方法看起来像这样：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s explain a few of the new things here.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这里的一些新东西。
- en: '`public` means that any code, anywhere in your program, can refer to the class
    or method. Other access modifiers, like private, are used to get more safety in
    a program, and to guarantee immutability for immutable types. We’ll talk more
    about them in an upcoming class.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 表示程序中的任何代码都可以引用该类或方法。其他访问修饰符，如 private，用于在程序中获得更多的安全性，并保证不可变类型的不可变性。我们将在即将到来的课程中更多地讨论它们。'
- en: '`static` means that the method doesn’t take a self parameter – which in Java
    is implicit anyway, you won’t ever see it as a method parameter. Static methods
    can’t be called on an object. Contrast that with the `List` `add()` method or
    the `String` `length()` method, for example, which require an object to come first.
    Instead, the right way to call a static method uses the class name instead of
    an object reference:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 表示该方法不接受 self 参数 - 在 Java 中这是隐式的，你永远不会看到它作为方法参数。静态方法不能在对象上调用。与之相反，`List`
    `add()` 方法或 `String` `length()` 方法，例如，需要首先一个对象。调用静态方法的正确方式是使用类名而不是对象引用：'
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Take note also of the comment before the method, because it’s very important.
    This comment is a specification of the method, describing the inputs and outputs
    of the operation. The specification should be concise and clear and precise. The
    comment provides information that is not already clear from the method types.
    It doesn’t say, for example, that `n` is an integer, because the `int n` declaration
    just below already says that. But it does say that `n` must be positive, which
    is not captured by the type declaration but is very important for the caller to
    know.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意方法前面的注释，因为它非常重要。这个注释是对方法的规范，描述了操作的输入和输出。规范应该简洁、清晰且准确。这个注释提供了从方法类型中并不清晰的信息。例如，它并没有说
    `n` 是一个整数，因为下面的 `int n` 声明已经说了。但它确实说 `n` 必须是正数，这对调用者来说是非常重要的。
- en: We’ll have a lot more to say about how to write good specifications in a few
    classes, but you’ll have to start reading them and using them right away.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来几节课中详细讨论如何编写良好的规范，但你必须立即开始阅读并使用它们。
- en: Mutating Values vs. Reassigning Variables
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变值 vs. 重新分配变量
- en: The next reading will introduce *snapshot diagrams* to give us a way to visualize
    the distinction between changing a variable and changing a value. When you assign
    to a variable, you’re changing where the variable’s arrow points. You can point
    it to a different value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一篇阅读将介绍 *快照图*，为我们提供一种可视化区分改变变量和改变值的方法。当你给一个变量赋值时，你正在改变变量的箭头指向。你可以将其指向一个不同的值。
- en: When you assign to the contents of a mutable value – such as an array or list
    – you’re changing references inside that value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给可变值（如数组或列表）分配内容时，你正在改变该值内部的引用。
- en: Change is a necessary evil. Good programmers avoid things that change, because
    they may change unexpectedly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 变化是一个必要的恶。好的程序员避免变化，因为它们可能会出乎意料地改变。
- en: Immutability (immunity from change) is a major design principle in this course.
    Immutable types are types whose values can never change once they have been created.
    (At least not in a way that’s visible to the outside world – there are some subtleties
    there that we’ll talk more about in a future class about immutability.) Which
    of the types we’ve discussed so far are immutable, and which are mutable?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性（免于变化）是本课程的一个主要设计原则。不可变类型是一旦创建就永远不会改变其值的类型。（至少对外部世界来说不会改变——在这方面还有一些微妙之处，我们将在未来关于不可变性的课程中更多地讨论。）我们到目前为止讨论过的类型中，哪些是不可变的，哪些是可变的？
- en: 'Java also gives us immutable references: variables that are assigned once and
    never reassigned. To make a reference immutable, declare it with the keyword final:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Java 也给了我们不可变的引用：只赋值一次且不会重新赋值的变量。要使引用不可变，用关键字 final 声明它：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the Java compiler isn’t convinced that your final variable will only be assigned
    once at runtime, then it will produce a compiler error. So final gives you static
    checking for immutable references.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Java 编译器不确信你的 final 变量在运行时只会被赋值一次，那么它会产生编译错误。因此，final 为不可变引用提供了静态检查。
- en: It’s good practice to use final for declaring the parameters of a method and
    as many local variables as possible. Like the type of the variable, these declarations
    are important documentation, useful to the reader of the code and statically checked
    by the compiler.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 final 声明方法的参数和尽可能多的局部变量是一种良好的做法。与变量的类型一样，这些声明是重要的文档，对代码的读者有用，并且被编译器静态地检查。
- en: 'There are two variables in our hailstoneSequence method: can we declare them
    final, or not?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 hailstoneSequence 方法中有两个变量：我们可以把它们声明为 final 吗，还是不行？
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Documenting Assumptions
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档化假设
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,documenting_assumptions/OMBFWUh3W3s)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放 MITx 视频**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,documenting_assumptions/OMBFWUh3W3s)'
- en: 'Writing the type of a variable down documents an assumption about it: e.g.,
    this variable will always refer to an integer. Java actually checks this assumption
    at compile time, and guarantees that there’s no place in your program where you
    violated this assumption.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 写下变量的类型是对它的一个假设的文档化：比如，这个变量将永远引用一个整数。Java 实际上会在编译时检查这个假设，并保证在你的程序中没有违反这个假设的地方。
- en: Declaring a variable final is also a form of documentation, a claim that the
    variable will never change after its initial assignment. Java checks that too,
    statically.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个变量为 final 也是一种文档化的形式，它声明这个变量在初始赋值后永远不会改变。Java 也会静态地检查这一点。
- en: 'We documented another assumption that Java (unfortunately) doesn’t check automatically:
    that n must be positive.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录了Java（不幸地）不能自动检查的另一个假设：n必须是正数。
- en: Why do we need to write down our assumptions? Because programming is full of
    them, and if we don’t write them down, we won’t remember them, and other people
    who need to read or change our programs later won’t know them. They’ll have to
    guess.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要写下我们的假设？因为编程中充满了假设，如果我们不把它们写下来，我们就不会记住它们，以后需要阅读或更改我们的程序的其他人也不会知道它们。他们将不得不猜测。
- en: 'Programs have to be written with two goals in mind:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序时必须牢记两个目标：
- en: communicating with the computer. First persuading the compiler that your program
    is sensible – syntactically correct and type-correct. Then getting the logic right
    so that it gives the right results at runtime.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与计算机进行通信。首先说服编译器，使你的程序合理——语法正确且类型正确。然后确保逻辑正确，以便在运行时产生正确的结果。
- en: communicating with other people. Making the program easy to understand, so that
    when somebody has to fix it, improve it, or adapt it in the future, they can do
    so.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他人进行通信。使程序易于理解，这样当有人需要在未来修复、改进或适应它时，他们可以这样做。
- en: Hacking vs. Engineering
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑客 vs. 工程
- en: 'We’ve written some hacky code in this class. Hacking is often marked by unbridled
    optimism:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这门课上写了一些黑客式的代码。黑客通常表现出无限的乐观：
- en: 'Bad: writing lots of code before testing any of it'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不好：在测试之前写很多代码
- en: 'Bad: keeping all the details in your head, assuming you’ll remember them forever,
    instead of writing them down in your code'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不好：把所有细节都记在脑子里，假设你永远记得它们，而不是写在你的代码中
- en: 'Bad: assuming that bugs will be nonexistent or else easy to find and fix'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不好：假设错误将不存在，否则很容易找到和修复
- en: 'But software engineering is not hacking. Engineers are pessimists:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但软件工程不是黑客行为。工程师是悲观主义者：
- en: 'Good: write a little bit at a time, testing as you go. In a future class, we’ll
    talk about test-first programming.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好：一次写一点，边写边测试。在以后的课程中，我们会谈论测试优先编程。
- en: 'Good: document the assumptions that your code depends on'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好：记录你的代码依赖的假设
- en: 'Good: defend your code against stupidity – especially your own! Static checking
    helps with that.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好：保护你的代码免受愚蠢之人的影响——尤其是你自己！静态检查有助于这一点。
- en: The Goal of 6.005
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.005的目标
- en: '[**▶ Play MITx video**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,the_goal_of_6005/0aEaInEKBy8)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[**▶ 播放MITx视频**](https://courses.csail.mit.edu/6.005/video/reading_1_static_checking,the_goal_of_6005/0aEaInEKBy8)'
- en: 'Our primary goal in this course is learning how to produce software that is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这门课程中的主要目标是学习如何生产以下软件：
- en: '**Safe from bugs**. Correctness (correct behavior right now), and defensiveness
    (correct behavior in the future).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止错误**。正确性（当前正确的行为）和防御性（未来正确的行为）。'
- en: '**Easy to understand**. Has to communicate to future programmers who need to
    understand it and make changes in it (fixing bugs or adding new features). That
    future programmer might be you, months or years from now. You’ll be surprised
    how much you forget if you don’t write it down, and how much it helps your own
    future self to have a good design.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解**。必须传达给未来的程序员，他们需要理解它并对其进行更改（修复错误或添加新功能）。那个未来的程序员可能是你，几个月或几年后。如果你不把它写下来，你会惊讶地发现你忘记了多少，而且拥有良好的设计对你自己的未来有多么有帮助。'
- en: '**Ready for change**. Software always changes. Some designs make it easy to
    make changes; others require throwing away and rewriting a lot of code.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备好改变**。软件总是在变化。有些设计使得改变变得容易；另一些则需要抛弃并重新编写大量代码。'
- en: There are other important properties of software (like performance, usability,
    security), and they may trade off against these three. But these are the Big Three
    that we care about in 6.005, and that software developers generally put foremost
    in the practice of building software. It’s worth considering every language feature,
    every programming practice, every design pattern that we study in this course,
    and understanding how they relate to the Big Three.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 软件还有其他重要的属性（如性能、可用性、安全性），它们可能与这三个属性相互权衡。但这些是我们在6.005中关心的三个最重要的属性，也是软件开发者在构建软件时通常最重视的属性。值得考虑我们在这门课程中学习的每一种语言特性、每一种编程实践、每一种设计模式，以及它们如何与这三个重要属性相关。
- en: Why we use Java in this course
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们在这门课上使用Java
- en: Since you’ve had 6.01, we’re assuming that you’re comfortable with Python. So
    why aren’t we using Python in this course? Why do we use Java in 6.005?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经学过6.01，我们假设你对Python很熟悉。那么为什么我们在这门课上不使用Python？为什么我们在6.005中使用Java？
- en: '**Safety** is the first reason. Java has static checking (primarily type checking,
    but other kinds of static checks too, like that your code returns values from
    methods declared to do so). We’re studying software engineering in this course,
    and safety from bugs is a key tenet of that approach. Java dials safety up to
    11, which makes it a good language for learning about good software engineering
    practices. It’s certainly possible to write safe code in dynamic languages like
    Python, but it’s easier to understand what you need to do if you learn how in
    a safe, statically-checked language.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全性**是第一个原因。Java具有静态检查（主要是类型检查，但还有其他类型的静态检查，比如你的代码是否从声明为返回值的方法返回值）。我们在这门课程中学习软件工程，防止错误是该方法的一个关键原则。Java将安全性提升到了极致，这使得它成为学习良好软件工程实践的好语言。在动态语言（如Python）中编写安全代码当然是可能的，但是如果你学习在一个安全的、静态检查的语言中做什么，你会更容易理解你需要做什么。'
- en: '**Ubiquity** is another reason. Java is widely used in research, education,
    and industry. Java runs on many platforms, not just Windows/Mac/Linux. Java can
    be used for web programming (both on the server and in the client), and native
    Android programming is done in Java. Although other programming languages are
    far better suited to teaching programming (Scheme and ML come to mind), regrettably
    these languages aren’t as widespread in the real world. Java on your resume will
    be recognized as a marketable skill. But don’t get us wrong: the real skills you’ll
    get from this course are not Java-specific, but carry over to any language that
    you might program in. The most important lessons from this course will survive
    language fads: safety, clarity, abstraction, engineering instincts.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**无处不在**是另一个原因。Java在研究、教育和工业领域广泛使用。Java可以在许多平台上运行，不仅仅是Windows/Mac/Linux。Java可以用于Web编程（服务器端和客户端），原生Android编程是用Java完成的。尽管其他编程语言更适合教授编程（Scheme和ML是我想到的），遗憾的是这些语言在现实世界中并不如Java广泛使用。在你的简历上写上Java将被认为是一种有市场价值的技能。但是不要误解我们：你从这门课程中获得的真正技能并不是特定于Java的，而是适用于你可能使用的任何语言。这门课程的最重要的教训将会在语言潮流中生存下来：安全性、清晰度、抽象化、工程直觉。'
- en: In any case, a good programmer must be **multilingual**. Programming languages
    are tools, and you have to use the right tool for the job. You will certainly
    have to pick up other programming languages before you even finish your MIT career
    (JavaScript, C/C++, Scheme or Ruby or ML or Haskell), so we’re getting started
    now by learning a second one.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，一个好的程序员必须是**多语言**的。编程语言是工具，你必须使用正确的工具来完成工作。在你甚至还没有完成MIT的职业生涯之前，你肯定会学习其他编程语言（JavaScript，C/C++，Scheme或Ruby或ML或Haskell），所以我们现在开始学习第二种语言。
- en: As a result of its ubiquity, Java has a wide array of interesting and useful
    **libraries** (both its enormous built-in library, and other libraries out on
    the net), and excellent free **tools** for development (IDEs like Eclipse, editors,
    compilers, test frameworks, profilers, code coverage, style checkers). Even Python
    is still behind Java in the richness of its ecosystem.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其无处不在，Java拥有各种有趣且有用的**库**（既包括其庞大的内置库，也包括网络上的其他库），以及出色的免费**开发工具**（如Eclipse等IDE，编辑器，编译器，测试框架，性能分析工具，代码覆盖率工具，样式检查器）。即使Python在生态系统的丰富程度上仍落后于Java。
- en: There are some reasons to regret using Java. It’s wordy, which makes it hard
    to write examples on the board. It’s large, having accumulated many features over
    the years. It’s internally inconsistent (e.g. the `final` keyword means different
    things in different contexts, and the `static` keyword in Java has nothing to
    do with static checking). It’s weighted with the baggage of older languages like
    C/C++ (the primitive types and the `switch` statement are good examples). It has
    no interpreter like Python’s, where you can learn by playing with small bits of
    code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些原因让人后悔使用Java。它很冗长，这使得在白板上编写示例变得困难。它很庞大，多年来积累了许多功能。它内部不一致（例如，`final`关键字在不同的上下文中具有不同的含义，在Java中，`static`关键字与静态检查无关）。它负载了像C/C++这样的旧语言的包袱（原始类型和`switch`语句是很好的例子）。它没有像Python那样的解释器，你可以通过玩弄一些小段代码来学习。
- en: But on the whole, Java is a reasonable choice of language right now to learn
    how to write code that is safe from bugs, easy to understand, and ready for change.
    And that’s our goal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，目前选择学习编写安全、易于理解且易于变更的代码的语言，Java是一个合理的选择。这就是我们的目标。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The main idea we introduced today is **static checking**. Here’s how this idea
    relates to the goals of the course:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们今天介绍的主要概念是**静态检查**。以下是这个概念与课程目标的关系：
- en: '**Safe from bugs.** Static checking helps with safety by catching type errors
    and other bugs before runtime.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免受错误困扰。** 静态检查通过在运行时之前捕获类型错误和其他错误来帮助确保安全性。'
- en: '**Easy to understand.** It helps with understanding, because types are explicitly
    stated in the code.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于理解。** 它有助于理解，因为类型在代码中明确声明。'
- en: '**Ready for change.** Static checking makes it easier to change your code by
    identifying other places that need to change in tandem. For example, when you
    change the name or type of a variable, the compiler immediately displays errors
    at all the places where that variable is used, reminding you to update them as
    well.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备好改变。** 静态检查使得通过识别需要同时更改的其他位置，更容易改变您的代码。例如，当您更改变量的名称或类型时，编译器立即在所有使用该变量的地方显示错误，提醒您也要更新它们。'
