- en: CSE 331 Software Design and Implementation
  prefs: []
  type: TYPE_NORMAL
- en: Class and Method Specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Introduction](#Introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Abstract Values and Abstract State](#AbstractValuesAndAbstractState)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mathematical Abstract Values](#MAV)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Specification Fields](#SpecificationFields)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Derived Fields](#DerivedFields)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Method Specifications](#Method_Specifications)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Preconditions](#Preconditions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Postconditions](#Postconditions)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Spec Fields for Specifications](#UsingSpecFields)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using Derived Spec Fields for Specifications](#UsingDerivedSpecFields)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Subclasses and overridden methods](#subclassing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This handout describes how to document the specifications of classes and methods.
    This document focuses on practical issues.
  prefs: []
  type: TYPE_NORMAL
- en: This document uses a `Line` class as an example. We do not provide fields or
    method bodies in our example. This document covers *specifying* the behavior of
    classes and methods (what they should do), not their *implementation* (what they
    actually do and how they do it).
  prefs: []
  type: TYPE_NORMAL
- en: '[Abstraction Functions and Representation Invariants](abstraction-functions-and-rep-invariants.html)
    covers how to document a class''s implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Because several concepts discussed here are interrelated, let's starts with
    a short list of definitions before diving into the details.
  prefs: []
  type: TYPE_NORMAL
- en: '*Abstract Value*'
  prefs: []
  type: TYPE_NORMAL
- en: What an instance of a class is supposed to represent. For example, each instance
    of `Line` represents some line segment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Abstract State*'
  prefs: []
  type: TYPE_NORMAL
- en: The information that defines the abstract value. For example, each abstract
    line has a start point and an end point.
  prefs: []
  type: TYPE_NORMAL
- en: '*Specification Fields*'
  prefs: []
  type: TYPE_NORMAL
- en: Describes components of the abstract state of a class. For example, the abstract
    state of a `Line` is made up by the specification fields `start-point` and `end-point`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Derived Specification Fields*'
  prefs: []
  type: TYPE_NORMAL
- en: Information that can be derived from specification fields but is useful to give
    a name to. For example, `Line` has the derived field `length`, which describes
    the length of the line segment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Abstract Invariant*'
  prefs: []
  type: TYPE_NORMAL
- en: A condition that must stay true over the abstract state of all instances of
    a class. For example, `Line` requires that no instance has the same start and
    end point. Abstract invariants are expressed in terms of the abstract state. Note
    that this is not the same as the Representation Invariant (RI) that describes
    properties of the concrete representation. An abstract invariant, if one is present,
    specifies constraints on abstract values only.
  prefs: []
  type: TYPE_NORMAL
- en: '*Method Specifications*'
  prefs: []
  type: TYPE_NORMAL
- en: Describe a method's behaviors in terms of abstract state. For example, `Line`'s
    `setEndPoint` method updates the `end-point` specification field.
  prefs: []
  type: TYPE_NORMAL
- en: The above concepts are included in a class's external specification (in Javadoc).
    They help document for clients how to use the class.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this document is organized as follows. First, it explains how to
    document what a class abstractly represents using [abstract state](#AbstractValuesAndAbstractState),
    [specification fields](#SpecificationFields) and [derived fields](#DerivedFields).
    Then, it explains how to [specify method behavior](#Method_Specifications), in
    terms of abstract state.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Values and Abstract State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract value of an object is the information that clients use when reasoning
    about an object. For example, a line segment is defined in terms of a start point
    and an end point. This does *not* necessarily imply that the concrete reprsentation
    of the object has two point fields. That is one representation, but there are
    others, such as a start point, an angle, and a length. Abstract values are typically
    at a less detailed level than an implementation because this helps clients reason
    about only what matters to them. For example, clients of some representation of
    strings just need to know that a string is a sequence of characters, not whether
    that sequence is implemented with an array, a linked list, a combination of the
    two, or some completely different way. The notion of *sequence* is more abstract
    than particular ways to reprsent sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Abstract Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For some ADTs, the abstract values are well-described by concepts and notation
    that are common in mathematics and well-understood by software developers. Examples
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: a *set* of integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a *sequence* of characters (i.e., a string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a *pair* of real numbers (or a triple, or in general a *tuple*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are specifying such a class, then you''re in luck. You can use conventional
    notation for specifyng the class''s abstract values and methods. Such notation
    includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*set comprehension*: **{ x | P(x) }** denotes the set of all elements *x* that
    satisfy the property *P*. More generally, **{ f(x) | P(x) }** denotes the set
    of values of the expression *f(x)* for all *x* that satisfy the property *P*.
    For example, **{ x * x | x > 10 }** represents the set of all numbers whose square
    root is greater than 10.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*set union*: **x ∪ y** denotes the union of two sets *x* and *y*. (This can
    also be written **x + y** when there''s no danger of confusion with addition.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*set membership*: **a ∈ x** or **a in x** tests whether *a* is an element of
    the set *x*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sequence construction:* **[a, b, c]** denotes a sequence of three elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sequence concatenation*: **x : y** denotes the concatenation of two sequences
    *x* and *y*. (This can also be written **x + y** when there''s no danger of confusion
    with addition or union.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sequence indexing*: **x[i]** denotes the *i*^(th) element of a sequence *x*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*set or sequence size*: **|x|** denotes the number of elements in a set or
    sequence *x*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*tuple construction*: **<a, b, c>** is a tuple of three elements. This is also
    written **(a, b, c)**. Unlike sequences, tuples are fixed-length, so we don''t
    normally think about concatenating them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You aren''t obliged to use this syntax. Some of it is more standard than the
    rest: set-comprehension syntax is standard in just about all of mathematics, but
    sequence concatenation isn''t particularly standardized. You may find it clearer
    to write sequence concatenation as a function like **concat(x, y)**. What really
    matters is clarity and lack of ambiguity, so if you have any doubt whether your
    reader will understand you, just define it: “...where **concat(x,y)** is the concatenation
    of two sequences **x** and **y**.”'
  prefs: []
  type: TYPE_NORMAL
- en: Specification Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, abstract values are not only simple mathematical objects like numbers
    or sets. In these cases, it's more useful to think about the abstract value as
    if it were an object with fields. For example, a line has a *start* and an *end*;
    a mailing address has a *number*, *street*, *city*, and *zipcode*; and a URL has
    a *protocol*, *host name*, and *resource name*.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, this is the same as a *tuple*; it's just a tuple whose parts
    have useful names for humans, rather than simply parts in some order without names.
    So even though we could use tuples, it's convenient, and more readable, to break
    the abstraction state into named parts, where each part is a *specification field*.
    (Specification fields are more commonly called *abstract fields*, because they're
    fields of the abstract value, as opposed to *rep fields* which are fields of the
    representation value. Unfortunately, *abstract* has another meaning in Java, so
    we will avoid that potentially confusing terminology.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Specification fields often (but not always) correspond to observers or getters
    on the abstract data type. Because the structure of abstract values is a matter
    of interest to the clients of your class, the specification fields should be listed
    in the class overview. In CSE 331, we have a Javadoc convention for describing
    them: `@specfield *name* : *type* // *description*`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By convention, in specification fields, lowercase types like *sequence* or *set*
    refer to mathematical entities. Capitalized types refer to other ADTs (classes
    or interfaces). Where you have a choice, prefer a mathematical entity as the type
    of a spec field; it is better to use sequence than List, for example. It's more
    elegant, and reduces the coupling between your specification and particular Java
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence of a specification field does not imply anything about the interface
    or implementation of the class. Although spec fields often correspond to observer
    methods, that''s not always true. (An observer method is one that computes a value
    without performing any side effects. All getter methods are observers, but not
    all observers are getters.) The interface might not provide any observers that
    query the spec field''s state, so clients of the class might not have access to
    the information stored in the spec field. (An example is that a stack implementation
    might have a spec field for the elements of the stack, but a client might only
    be able to push and pop rather than being able to obtain the full state of the
    stack.) Likewise, the implementation might not actually have a concrete field
    of the spec field''s type: that information may be computed from multiple concrete
    fields, or it might not be available at all. The point is that specification fields
    are useful for giving method specifications in terms of the abstraction being
    provided.'
  prefs: []
  type: TYPE_NORMAL
- en: Derived Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Derived fields are information that can be derived from the specification fields
    that it is useful to give a name to. For example, consider this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The derived field `area` can be derived by squaring the `length` specification
    field. A derived field's documentation should state how it is derived from the
    specification fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'A derived field''s purpose is to help with writing method specifications, abstraction
    functions, and representation invariants: It is easier to write and understand
    `area` than `length^2`. They are a shorthand that can make class and method specifications
    easier to understand. Because a derived field is defined entirely in terms of
    specification fields (or other derived fields), method specifications do not need
    to state a method''s effects on a derived fields. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the method specification of `differenceInArea` uses the derived field
    `area` to make it easier to explain what it returns.
  prefs: []
  type: TYPE_NORMAL
- en: It is never necessary for a method specification to indicate its effect on a
    derived specification field because the class documentation has defined the derived
    specification field in terms of specification fields. Since `area` is a derived
    field, the constructor does not need to say what the newly constructed `Square`'s
    `area` is. Similarly, the method specification for `setLength` does not need to
    document its effect on `area`.
  prefs: []
  type: TYPE_NORMAL
- en: When we relate concrete implementations to abstract values using [Abstraction
    Functions](abstraction-functions-and-rep-invariants.html#AbstractionFunctions),
    we will similarly only need to describe the abstraction in terms of specification
    fields and then the derived fields will follow from the specification fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note that one could have made `area` a specification field instead of a derived
    field. This would relieve the programmer from the responsibility of documenting
    how `area` can be derived from the specification fields. However, in this case,
    the constructor and `setLength` would be required to specify their effects on
    `area`.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you have a derived specification field `f`. It is permissible for there
    to be a concrete field in the implementation that stores the value of `f`, or
    for there to be a method that computes the value of `f`, or for there to be no
    such field or method. That is an implementation detail that is of no interest
    to clients of the specification.
  prefs: []
  type: TYPE_NORMAL
- en: Method Specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method specifications describe the behavior of a method in terms of its preconditions
    and postconditions. Note that method specifications may only refer to specification
    fields, method arguments, and global variables (also known as public static fields),
    never to the concrete fields of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Preconditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Preconditions are properties that must be true when the method is called. It
    is the responsibility of the caller to guarantee that these properties hold. If
    the preconditions do not hold, the method is allowed to behave in absolutely any
    fashion, including crashing the program, continuing with incorrect results, informing
    the user of the problem, or gracefully recovering from the problem. Callers should
    always assume that preconditions are not checked by a method. However, it is good
    practice — though not required — for an implementation to check its preconditions
    (if the check can be performed efficiently) and throw an exception if they are
    not satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Preconditions are indicated by the "**requires**" clause in a method specification.
    If a "requires" clause is omitted from the method specification, it is assumed
    that the method does not have any preconditions.
  prefs: []
  type: TYPE_NORMAL
- en: '**requires** (default: no constraints)'
  prefs: []
  type: TYPE_NORMAL
- en: The preconditions that must be met by the method's caller
  prefs: []
  type: TYPE_NORMAL
- en: Postconditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Postconditions are properties that a method guarantees will hold when the method
    exits. However, if the precondition did not hold when the method was called, then
    nothin else is relevant, and the method may behave in any fashion whatsoever.
    In particular, if the precondition does not hold upon method entry, then the postcondition
    need not hold on method exit.
  prefs: []
  type: TYPE_NORMAL
- en: A postcondition can be written as a single complex logical formula, but it is
    convenient to separate it into logically distinct parts. CSE 331 uses "return",
    "effects", "throws", and "modifies". (In the descriptions below, "default" indicates
    what is assumed if that clause is omitted from the method specification.)
  prefs: []
  type: TYPE_NORMAL
- en: '**return** (default: no constraint on what is returned)'
  prefs: []
  type: TYPE_NORMAL
- en: The value returned by the method, if any
  prefs: []
  type: TYPE_NORMAL
- en: '**throws** (default: none, which means that no exceptions are ever thrown)'
  prefs: []
  type: TYPE_NORMAL
- en: The exceptions that may be raised, and under which conditions. The specification
    should not make guarantees about the behavior when the preconditions are not satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: '**modifies** (default: nothing, which means that there are no side effects)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables whose value *may* be modified by the procedure: They are not guaranteed
    to be modified, unless otherwise indicated by the effects clause. If object `x`
    has specification fields `f`, `g`, and `h`, then "`modifies x`" means that any
    combination of `x.f`, `x.g`, and `x.h` might be modified. "`modifies x.g, x.h`"
    would be more restrictive. Often, programmers are more interested in quantities
    that are *not* listed in the modifies clause, since those are guaranteed not to
    be changed by the method.'
  prefs: []
  type: TYPE_NORMAL
- en: '**effects** (default: true, which means "can have any effect" on the references
    listed under modifies)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The side effects of the method, such as changes to the state of the current
    object, to parameters, or to objects held in global variables: If a specification
    field is listed in the modifies clause but not in the effects clause, then it
    may take on any value allowed by the abstract invariants of this class of objects.
    The difference between the modifies and effects causes is that modifies lists
    everything that may change and effects indicates what changes occur.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Spec Fields for Specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Specification fields are useful for writing specifications of the ADT''s operations.
    Here''s a specification for a method on the [`Line`](#LineDef) class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Specifications may refer to specification fields (such as `start-point` and
    `end-point`), but never to representation fields. Rep fields depend on a particular
    implementation, so we don't want to expose them in a specification, which can
    be implemented in many different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Using Derived Spec Fields for Specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you''re writing specifications for operations, you may find it useful
    to use [*derived* spec fields](#DerivedFields). A derived spec field is just a
    spec field that can be written in terms of other spec fields. In other words,
    it''s a shorthand. You can freely use derived spec fields in a method specification
    (and easing such specifications is the point of derived spec fields):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Subclasses and overridden methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A subclass often has a different (stronger) specification than its superclass,
    and often has a larger abstract state than its superclass. When the specification
    and abstract state are identical to those of the parent (for instance, an implementation
    of an abstract class), then there is no need to repeat them in the subclass. However,
    it is helpful to include a brief note indicating that the superclass documentation
    should be used instead. That note helps readers to distinguish whether the specification
    is the same, or the author simply didn't document the class.
  prefs: []
  type: TYPE_NORMAL
- en: When the specifications differ, then you have two options. The first option
    is to repeat, in the subclass, the full superclass documentation. The advantage
    is that everything is in one place, which may improve understanding. The second
    option is to augment the existing specification -- for example, to add a few new
    specification fields and constraints on them. Whichever you do, make sure that
    you clearly indicate your approach.
  prefs: []
  type: TYPE_NORMAL
- en: Similar rules hold for a method that overrides another method. It is acceptable
    to leave the Javadoc blank if the specification is identical. (The generated HTML
    will use the overridden method's Javadoc documentation, but a normal Java comment
    is a good hint to someone who is reading the source code.) Otherwise, it is usually
    better to give the complete specification. If you merely augment the overridden
    method's specification, be sure to refer to it in the documentation.
  prefs: []
  type: TYPE_NORMAL
