- en: クラス
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/class/](https://jsprimer.net/basic/class/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 「クラス」と一言にいってもさまざまであるため、ここでは**構造**、**動作**、**状態**を定義できるものを指すことにします。 また、この章では概念を示す場合は**クラス**と呼び、クラスに関する構文（記述するコード）のことを`class`構文と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: '**クラス**とは**動作**や**状態**を定義した**構造**です。 クラスからはインスタンスと呼ばれるオブジェクトを作成でき、インスタンスはクラスに定義した**動作**を継承し、**状態**は動作によって変化します。
    とても抽象的なことに思えますが、これは今までオブジェクトや関数を使って表現してきたものです。 JavaScriptではES2015より前までは`class`構文はなく、関数を使ってクラスのようなものを表現して扱っていました。'
  prefs: []
  type: TYPE_NORMAL
- en: ES2015でクラスを表現するための`class`構文が導入されましたが、この`class`構文で定義したクラスは関数オブジェクトの一種です。 `class`構文ではプロトタイプベースの継承の仕組みを使って関数でクラスを表現しています。
    そのため、`class`構文はクラスを作るための関数定義や継承をパターン化した書き方と言えます。
  prefs: []
  type: TYPE_NORMAL
- en: また、関数の定義方法として関数宣言文と関数式があるように、クラスにもクラス宣言文とクラス式があります。 このように関数とクラスは似ている部分が多いです。
  prefs: []
  type: TYPE_NORMAL
- en: この章では、`class`構文でのクラスの定義や継承、クラスの性質について学んでいきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#class-declaration)*クラスの定義*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*クラスを定義するには`class`構文を使います。 クラスの定義方法にはクラス宣言文とクラス式があります。'
  prefs: []
  type: TYPE_NORMAL
- en: まずは、クラス宣言文によるクラスの定義方法を見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: クラス宣言文では`class`キーワードを使い、`class クラス名{ }`のようにクラスの**構造**を定義できます。
  prefs: []
  type: TYPE_NORMAL
- en: クラスは必ずコンストラクタを持ち、`constructor`という名前のメソッドとして定義します。 コンストラクタとは、そのクラスからインスタンスを作成する際にインスタンスに関する**状態**の初期化を行うメソッドです。
    `constructor`メソッドに定義した処理は、クラスをインスタンス化したときに自動的に呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: もうひとつの定義方法であるクラス式は、クラスを値として定義する方法です。 クラス式ではクラス名を省略できます。これは関数式における無名関数と同じです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: コンストラクタ関数内で、何も処理がない場合はコンストラクタの記述を省略できます。 省略した場合でも自動的に空のコンストラクタが定義されるため、クラスにはコンストラクタが必ず存在します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[](#class-instance)*クラスのインスタンス化*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*クラスは`new`演算子でインスタンスであるオブジェクトを作成できます。 `class`構文で定義したクラスからインスタンスを作成することを**インスタンス化**と呼びます。
    あるインスタンスが指定したクラスから作成されたものかを判定するには`instanceof`演算子が利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: このままでは何も処理がない空のクラスなので、値を持ったクラスを定義してみましょう。
  prefs: []
  type: TYPE_NORMAL
- en: クラスではインスタンスの初期化処理をコンストラクタ関数で行います。 コンストラクタ関数は`new`演算子でインスタンス化する際に自動的に呼び出されます。
    コンストラクタ関数内での`this`はこれから新しく作るインスタンスオブジェクトとなります。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`x`座標と`y`座標の値を持つ`Point`というクラスを定義しています。 コンストラクタ関数（`constructor`）の中でインスタンスオブジェクト（`this`）の`x`と`y`プロパティに値を代入して初期化しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: この`Point`クラスのインスタンスを作成するには`new`演算子を使います。 `new`演算子には関数呼び出しと同じように引数を渡すことができます。
    `new`演算子の引数はクラスの`constructor`メソッド（コンストラクタ関数）の仮引数に渡されます。 そして、コンストラクタの中ではインスタンスオブジェクト（`this`）の初期化処理を行います。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: このようにクラスからインスタンスを作成するには必ず`new`演算子を使います。
  prefs: []
  type: TYPE_NORMAL
- en: 一方、クラスは通常の関数として呼ぶことができません。 これは、クラスのコンストラクタはインスタンス（`this`）を初期化する場所であり、通常の関数とは役割が異なるためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: また、コンストラクタ関数は`return`文で任意のオブジェクトを返すことが可能ですが、行うべきではありません。 なぜなら、クラスを`new`演算子で呼び出し、その評価結果はクラスのインスタンスを期待するのが一般的であるためです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードのようにコンストラクタで返した値が`new`演算子で呼び出した際の返り値となります。 このような書き方は混乱を生むため避けるべきです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[](#class-name-start-upper-case)*[Note] クラス名は大文字ではじめる*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*JavaScriptでは慣習としてクラス名には大文字ではじまる名前をつけます。 これは、変数名にキャメルケースを使う慣習があるのと同じで、名前自体に特別なルールがあるわけではありません。
    クラス名を大文字にしておき、そのインスタンスは小文字で開始すれば名前が被らないという合理的な理由で好まれています。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[](#class-vs-function)*[コラム] `class`構文と関数でのクラスの違い*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ES2015より前はこれらのクラスを`class`構文ではなく、関数で表現していました。 その表現方法は人によってさまざまで、これも`class`構文という統一した記法が導入された理由の1つです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードは、関数でクラスを実装した1つの例です。 この関数でのクラス表現は、継承の仕組みなどは省かれていますが、`class`構文とよく似ています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 大きな違いとして、`class`構文で定義したクラスは関数として呼び出すことができません。 クラスは`new`演算子でインスタンス化して使うものなので、これはクラスの誤用を防ぐ仕様です。
    一方、関数でのクラス表現はただの関数なので、当然関数として呼び出せます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: このように、関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。 このような問題を避けるためにもクラスは`class`構文を使って実装します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#class-prototype-method-definition)*クラスのプロトタイプメソッドの定義*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*クラスの**動作**はメソッドによって定義できます。 `constructor`メソッドは初期化時に呼ばれる特殊なメソッドですが、`class`構文ではクラスに対して自由にメソッドを定義できます。
    このクラスに定義したメソッドは作成したインスタンスが持つ動作となります。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のように`class`構文ではクラスに対してメソッドを定義できます。 メソッドの中からクラスのインスタンスを参照するには、`constructor`メソッドと同じく`this`を使います。
    このクラスのメソッドにおける`this`は「[関数とthis](../function-this/)」の章で学んだメソッドと同じくベースオブジェクトを参照します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'クラスのプロトタイプメソッド定義では、オブジェクトにおけるメソッドとは異なり`key : value`のように`:`区切りでメソッドを定義できないことに注意してください。
    つまり、次のような書き方は構文エラー（`SyntaxError`）となります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: このメソッド定義の構文でクラスに対して定義したメソッドは、クラスの各インスタンスから**共有されるメソッド**となります。 このインスタンス間で共有されるメソッドのことを**プロトタイプメソッド**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`Counter`クラスに`increment`メソッドを定義しています。 このときの`Counter`クラスのインスタンスは、それぞれ別々の状態（`count`プロパティ）を持ちます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: このときの`increment`メソッドはプロトタイプメソッドとして定義されています。 プロトタイプメソッドは各インスタンス間(`counterA`と`counterB`)で共有されます。
    そのため、次のように各インスタンスの`increment`メソッドの参照先は同じとなっていることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: プロトタイプメソッドがなぜインスタンス間で共有されているのかは、クラスの継承の仕組みと密接に関係しています。 プロトタイプメソッドの仕組みについては後ほど解説します。
  prefs: []
  type: TYPE_NORMAL
- en: ここでは、次のような構文でクラスにメソッドを定義すると、各インスタンスで共有されるプロトタイプメソッドとして定義されるということが理解できていれば問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[](#class-accessor-property)*クラスのアクセッサプロパティの定義*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*クラスに対してメソッドを定義できますが、メソッドは`インスタンス名.メソッド名()`のように呼び出す必要があります。 クラスでは、プロパティの参照（getter）、プロパティへの代入（setter）時に呼び出される特殊なメソッドを定義できます。
    このメソッドはプロパティのように振る舞うため**アクセッサプロパティ**と呼ばれます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、プロパティの参照（getter）、プロパティへの代入（setter）に対するアクセッサプロパティを定義しています。 アクセッサプロパティはメソッド名（プロパティ名）の前に`get`または`set`をつけるだけです。
    getter（`get`）には仮引数はありませんが、必ず値を返す必要があります。 setter（`set`）の仮引数にはプロパティへ代入する値が入りますが、値を返す必要はありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは、`NumberWrapper`クラスの`value`プロパティをアクセッサプロパティとして定義しています。 `value`プロパティへアクセスした際にそれぞれ定義したgetterとsetterが呼ばれているのがわかります。
    このアクセッサプロパティで実際に読み書きされているのは、`NumberWrapper`インスタンスの`_value`プロパティとなります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[](#underbar-private-property)*[コラム] `_`（アンダーバー）から始まるプロパティ名*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*NumberWrapperの`value`のアクセッサプロパティで実際に読み書きしているのは、`_value`プロパティです。 このように、外から直接読み書きしてほしくないプロパティを`_`（アンダーバー）から始まる名前にするのはただの習慣であるため、構文としての意味はありません。'
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 2022から、外から直接読み書きしてほしくないプライベートなプロパティを定義するPrivateクラスフィールド構文が追加されました。
    Privateクラスフィールド構文では`#`（ハッシュ）記号をプロパティ名の前につけます。 そのため、外から直接読み書きしてほしくないプロパティを`_`からはじめるという慣習は、Privateクラスフィールド構文の利用が進むにつれて使われなくなっていくと考えています。
  prefs: []
  type: TYPE_NORMAL
- en: Privateクラスフィールド構文については、この後に解説します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#array-like-length)*`Array.prototype.length`をアクセッサプロパティで再現する*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*getterやsetterを利用しないと実現が難しいものとして、`Array.prototype.length`プロパティがあります。 Arrayの`length`プロパティへ値を代入すると、そのインデックス以降の要素は自動的に削除される仕様になっています。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、配列の要素数（`length`プロパティ）を小さくすると配列の要素が削除されています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: この`length`プロパティの挙動を再現する`ArrayLike`クラスを実装してみます。 Arrayの`length`プロパティは、`length`プロパティへ値を代入した際に次のようなことを行っています。
  prefs: []
  type: TYPE_NORMAL
- en: 現在要素数より小さな**要素数**が指定された場合、その**要素数**を変更し、配列の末尾の要素を削除する
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 現在要素数より大きな**要素数**が指定された場合、その**要素数**だけを変更し、配列の実際の要素はそのままにする
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ArrayLikeの`length`プロパティのsetterで要素の追加や削除を実装することで、配列のような`length`プロパティを実装できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: このようにアクセッサプロパティでは、プロパティのようでありながら実際にアクセスした際には他のプロパティと連動する動作を実現できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#public-class-fields)*[ES2022] Publicクラスフィールド*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*クラスでは、`constructor`メソッドの中でクラスの状態であるインスタンスのプロパティを初期化することを紹介しました。 先ほども紹介した`Counter`クラスでは、`constructor`メソッドの中で`count`プロパティの初期値を`0`として定義しています。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: この`Counter`では`new`演算子で何も引数を渡すことなく初期化するため、`constructor`メソッドには仮引数を定義していません。 このような場合でも、`constructor`メソッドを書かないとプロパティの初期化ができないためわずらわしいという問題がありました。
  prefs: []
  type: TYPE_NORMAL
- en: ES2022で、クラスのインスタンスが持つプロパティの初期化をわかりやすく宣言的にする構文として、**クラスフィールド**構文が追加されました。
  prefs: []
  type: TYPE_NORMAL
- en: クラスフィールドは、クラスのインスタンスが持つプロパティを定義する次のような構文です。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: クラスフィールドを使って先ほどの`Counter`クラスを書き直してみると次のようになります。 `count`プロパティをクラスフィールドとして定義して、その初期値は`0`としています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: クラスフィールドで定義するのは、クラスのインスタンスが持つプロパティです。 そのため、`constructor`メソッドの中で`this.count =
    0`のように定義した場合と結果的にはほとんど同じ意味となります。 クラスフィールドで定義したプロパティは、クラス内から他のプロパティと同じように`this.プロパティ名`で参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: クラスフィールドは`constructor`メソッドでの初期化と併用が可能です。 次のコードでは、クラスフィールドと`constructor`メソッドでそれぞれインスタンスのプロパティを定義しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: また、クラスフィールドでの初期化処理が行われ、そのあと`constructor`でのプロパティの定義という処理順となります。 そのため、同じプロパティ名への定義がある場合は、`constructor`メソッド内での定義でプロパティは上書きされます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: この`publicField`プロパティのように、クラスの外からアクセスできるプロパティを定義するクラスフィールドを**Publicクラスフィールド**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#declare-class-fields)*クラスフィールドを使ってプロパティの存在を宣言する*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*クラスフィールドでは、プロパティの初期値は省略可能となっています。 そのため、次のように初期値を省略したPublicクラスフィールドも定義できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: このときの`myProperty`は`undefined`で初期化されます。 この初期値を省略したクラスフィールドの定義は、クラスのインスタンスが持つプロパティを明示するために利用できます。
  prefs: []
  type: TYPE_NORMAL
- en: 次の`Loader`クラスは、`load`メソッドを呼び出すまでは、`loadedContent`プロパティの値は`undefined`です。 クラスフィールドを使えば、`Loader`クラスのインスタンスは、`loadedContent`というプロパティを持っていることを宣言的に表現できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: JavaScriptでは、オブジェクトのプロパティは初期化時に存在していなくても、後から代入すれば作成できてしまいます。 そのため、次のように`Loader`クラスを実装しても意味は同じです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: しかし、このように実装してしまうと`Loader`クラスを利用する側は、`loadedContent`プロパティの存在を`load`メソッドの中まで読まないとわからないという問題があります。
    これに対して、クラスフィールドを使って「`Loader`クラスは`loadedContent`というプロパティを持っている」ということを宣言的に表現できます。
    宣言的にプロパティを定義することで、エディターでのコード補完が可能になったり、コードを読む人に優しいというメリットがあります。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#this-in-class-fields)*クラスフィールドでの`this`はクラスのインスタンスを示す*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*クラスフィールドの初期値には任意の式が書け、`this`も利用できます。 クラスフィールドでの`this`は、そのクラスのインスタンスを参照します。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`up`フィールドの初期値に`increment`メソッドを指定しています。 JavaScriptでは関数も値として扱えるため、`up`メソッドを呼び出すと`increment`メソッドが呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: クラスフィールドでの`this`は、Arrow Functionと組み合わせると強力です。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`up`メソッドをArrow Functionとして定義し、関数内では`this.increment`メソッドを呼び出しています。 Arrow
    Functionで定義した関数における`this`は、どのような呼び出し方をしても変化しません（「[Arrow Functionでコールバック関数を扱う](../function-this/#arrow-function-callback)」を参照）。
    そのため、`up`メソッドはどのような呼び方をした場合でも`this`がクラスのインスタンスとなるため、確実に`increment`メソッドを呼び出せます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[](#difference-between-class-fields-and-instance-property)*[コラム] クラスフィールドとインスタンスのプロパティの違い*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*クラスフィールドで定義したプロパティやメソッドは、クラスのインスタンスにプロパティとして定義されます。 そのため、クラスフィールドは、`constructor`の中で`this`に対してプロパティを追加するのと意味的にはほぼ同じで、見た目がわかりやすくなった構文と捉えることができます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: しかし、厳密にはこのふたつのプロパティ定義には異なる点はあります。 次のように、クラスフィールドと`constructor`の中で`this`に追加するプロパティ名に対するsetterを定義してみるとこの違いがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: クラスフィールド名に対するsetterは呼び出されないのに対して、`this.property`への代入に対するsetterは呼び出されています。 これは、クラスフィールドは`=`を使った代入で定義されるのではなく、[Object.defineProperty](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)メソッドを使ってプロパティが定義されるという違いがあります。
    `Object.defineProperty`を使ったプロパティの定義では、setterは無視してプロパティが定義されます。 setterは`=`での代入に反応します。そのため、`constructor`の中での`this.property`への代入に対してはsetterが呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: 同じプロパティの定義であっても、プロパティの定義の仕組みが微妙に異なる点から、このような挙動の違いが存在しています。 しかし、この違いを意識するようなコードを書くことは避けたほうが安全です。
    実際に見た目からこの違いを意識するのは難しく、それを意識させるようなコードは複雑性が高いためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#private-class-fields)*[ES2022] Privateクラスフィールド*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*クラスフィールド構文で次のように書くと、定義したプロパティはクラスをインスタンス化した後に外からも参照できます。 そのため、Publicクラスフィールドと呼ばれます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 一方で外からアクセスされたくないインスタンスのプロパティも存在します。 そのようなプライベートなプロパティを定義する構文もES2022で追加されています。
  prefs: []
  type: TYPE_NORMAL
- en: Privateクラスフィールドは、次のように`#`をフィールド名の前につけたクラスフィールドを定義します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 定義したPrivateクラスフィールドは、`this.#フィールド名`で参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: もう少し具体的なPrivateクラスフィールドの使い方を見ていきます。 アクセッサプロパティの例でも登場した`NumberWrapper`をPrivateクラスフィールドを使って書き直してみます。
    元々の`NumberWrapper`クラスでは、`_value`プロパティに実際の値を読み書きしていました。 この場合、`_value`プロパティは、外からもアクセスできてしまうため、定義したgetterとsetterが無視できてしまいます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Privateクラスフィールドでは、外からアクセスされたくないプロパティを`#`をつけてクラスフィールドとして定義します。 次のコードでは、`#value`はプライベートプロパティとなっているため、構文エラーが発生し外からアクセスできなくなることが確認できます。
    Privateクラスフィールドを使うことで、クラスを利用する際はgetterとsetterを経由しないと`#value`を参照できなくなりました。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Privateクラスフィールドを使うことで、クラスの外からアクセスさせたくないプロパティを宣言できます。 これは、実装したクラスの意図しない使われ方を防いだり、クラスの外からプロパティの状態を直接書き換えるといった行為を防げます。
  prefs: []
  type: TYPE_NORMAL
- en: また、Privateクラスフィールドでは、途中から値が入る場合でもフィールドの宣言が必須となっています。 次のコードでは、`#loadedContent`に実際に値が入るのは`load`メソッドが呼び出されたときです。
    Publicクラスフィールドではフィールドの定義は省略可能でしたが、Privateクラスフィールドでは`#loadedContent`フィールドの定義が必須となっています。
    言い換えると、Privateクラスフィールドでは、クラスを定義した段階でクラスに存在するすべてのPrivateクラスフィールドを明示する必要があります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[](#static-method)*静的メソッド*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*インスタンスメソッドは、クラスをインスタンス化して利用します。 一方、クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。'
  prefs: []
  type: TYPE_NORMAL
- en: 静的メソッドの定義方法はメソッド名の前に、`static`をつけるだけです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは、配列をラップする`ArrayWrapper`というクラスを定義しています。 `ArrayWrapper`はコンストラクタの引数として配列を受け取って初期化しています。
    このクラスに配列ではなく要素そのものを引数に受け取ってインスタンス化できる`ArrayWrapper.of`という静的メソッドを定義します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: クラスの静的メソッドにおける`this`は、そのクラス自身を参照します。 そのため、先ほどのコードは`new ArrayWrapper`の代わりに`new
    this`と書くこともできます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: このように静的メソッドでの`this`はクラス自身を参照するため、クラスのインスタンスは参照できません。 そのため静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#static-class-fields)*[ES2022] 静的クラスフィールド*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*ES2022で追加されたクラスフィールドでは、インスタンスではなくクラス自体に定義する静的クラスフィールドも利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 静的クラスフィールドは、フィールドの前に`static`をつけるだけです。 静的クラスフィールドで定義したプロパティは、クラス自体のプロパティとして定義されます。
    次のコードでは、Public静的クラスフィールドを使って`Colors`クラス自体にプロパティを定義しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: また、Privateクラスフィールドも静的に利用できます。 Private静的クラスフィールドは、クラス自体にプロパティを定義したいが、そのプロパティを外から参照されたくない場合に利用します。
    Private静的クラスフィールドはフィールドの前に、`static`をつけるだけです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[](#two-instance-method-definition)*プロトタイプに定義したメソッドとインスタンスに定義したメソッドの違い*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ここまでで、プロトタイプメソッドの定義とクラスフィールドを使ったインスタンスに対するメソッドの定義の2種類を見てきました。 プロトタイプメソッドの定義方法は、メソッドをプロトタイプオブジェクトという特殊なオブジェクトに定義します。
    一方で、クラスフィールドで定義したメソッドは、クラスのインスタンスに対してメソッドを定義します。'
  prefs: []
  type: TYPE_NORMAL
- en: どちらのメソッド定義方法でも、`new`演算子でインスタンス化したオブジェクトからメソッドを呼び出すことができる点は同じです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: しかしこの2つのメソッドの定義方法は、メソッドの定義先となるオブジェクトが異なります。
  prefs: []
  type: TYPE_NORMAL
- en: まず、この2種類のメソッドがそれぞれ別の場所へと定義されていることを見ていきます。 次のコードでは、`ConflictClass`クラスに`method`という同じ名前のメソッドをプロトタイプメソッドとインスタンスに対してそれぞれ定義しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 結論から述べると、この場合はインスタンスオブジェクトに定義した`method`が呼び出されます。 このとき、インスタンスの`method`プロパティを`delete`演算子で削除すると、今度はプロトタイプメソッドの`method`が呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: この実行結果から次のことがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: インスタンスオブジェクトのメソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: どちらも注意深く意識しないと気づきにくいですが、この挙動はJavaScriptの重要な仕組みであるため理解することは重要です。
  prefs: []
  type: TYPE_NORMAL
- en: この挙動は**プロトタイプオブジェクト**と呼ばれる特殊なオブジェクトと**プロトタイプチェーン**と呼ばれる仕組みで成り立っています。 どちらも**プロトタイプ**とついていることからわかるように、2つで1組のような仕組みです。
  prefs: []
  type: TYPE_NORMAL
- en: 次のセクションでは、**プロトタイプオブジェクト**と**プロトタイプチェーン**とはどのような仕組みなのかを見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#prototype)*プロトタイプオブジェクト*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '***プロトタイプメソッド**と**インスタンスオブジェクトのメソッド**を同時に定義しても、互いのメソッドは上書きされるわけでありません。 なぜなら、プロトタイプメソッドは**プロトタイプオブジェクト**へ、インスタンスオブジェクトのメソッドは**インスタンスオブジェクト**へそれぞれ定義されるためです。'
  prefs: []
  type: TYPE_NORMAL
- en: プロトタイプオブジェクトについては「[プロトタイプオブジェクト](../prototype-object/)」の章で簡単に紹介していましたが、改めて解説していきます。
  prefs: []
  type: TYPE_NORMAL
- en: '**プロトタイプオブジェクト**とは、JavaScriptの関数オブジェクトの`prototype`プロパティに自動的に作成される特殊なオブジェクトです。
    クラスも一種の関数オブジェクトであるため、自動的に`prototype`プロパティにプロトタイプオブジェクトが作成されています。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、関数やクラス自身の`prototype`プロパティに、プロトタイプオブジェクトが自動的に作成されていることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`class`構文のメソッド定義は、このプロトタイプオブジェクトのプロパティとして定義されます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、クラスのメソッドがプロトタイプオブジェクトに定義されていることを確認できます。 また、クラスには`constructor`メソッド（コンストラクタ）が必ず定義されます。
    この`constructor`メソッドもプロトタイプオブジェクトに定義されており、この`constructor`プロパティはクラス自身を参照します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: このように、プロトタイプメソッドはプロトタイプオブジェクトに定義され、インスタンスオブジェクトのメソッドとは異なるオブジェクトに定義されています。そのため、それぞれの方法でメソッドを定義しても、上書きされることはありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#prototype-chain)*プロトタイプチェーン*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`class`構文で定義したプロトタイプメソッドはプロトタイプオブジェクトに定義されます。 しかし、インスタンス（オブジェクト）にはメソッドが定義されていないのに、インスタンスからクラスのプロトタイプメソッドを呼び出せます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: インスタンスからプロトタイプメソッドを呼び出せるのは**プロトタイプチェーン**と呼ばれる仕組みによるものです。 プロトタイプチェーンは2つの処理から成り立ちます。
  prefs: []
  type: TYPE_NORMAL
- en: インスタンス作成時に、インスタンスの`[[Prototype]]`内部プロパティへプロトタイプオブジェクトの参照を保存する処理
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: インスタンスからプロパティ（またはメソッド）を参照するときに、`[[Prototype]]`内部プロパティまで探索する処理
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[](#write-prototype-chain)*インスタンス作成とプロトタイプチェーン*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*クラスから`new`演算子によってインスタンスを作成する際に、インスタンスにはクラスのプロトタイプオブジェクトへの参照が保存されます。 このとき、インスタンスからクラスのプロトタイプオブジェクトへの参照は、インスタンスオブジェクトの`[[Prototype]]`という内部プロパティに保存されます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[Prototype]]`内部プロパティはECMAScriptの仕様で定められた内部的な表現であるため、通常のプロパティのようにはアクセスできません。
    ここでは説明のために、`[[プロパティ名]]`という書式でECMAScriptの仕様上に存在する内部プロパティを表現しています。'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[Prototype]]`内部プロパティへプロパティのようにはアクセスできませんが、`Object.getPrototypeOf`メソッドで`[[Prototype]]`内部プロパティを参照できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`instance`オブジェクトの`[[Prototype]]`内部プロパティを取得しています。 その取得した結果がクラスのプロトタイプオブジェクトを参照していることを確認できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: ここで重要なのは、インスタンスはどのクラスから作られたかやそのクラスのプロトタイプオブジェクトを知っているということです。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#inner-property)*[Note] `[[Prototype]]`内部プロパティを読み書きする*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*`Object.getPrototypeOf(オブジェクト)`で`オブジェクト`の`[[Prototype]]`を読み取ることができます。 一方、`Object.setPrototypeOf(オブジェクト,
    プロトタイプオブジェクト)`で`オブジェクト`の`[[Prototype]]`に`プロトタイプオブジェクト`を設定できます。 また、`[[Prototype]]`内部プロパティを通常のプロパティのように扱える`__proto__`という特殊なアクセッサプロパティが存在します。'
  prefs: []
  type: TYPE_NORMAL
- en: しかし、これらの`[[Prototype]]`内部プロパティを直接読み書きすることは通常の用途では行いません。 また、既存のビルトインオブジェクトの動作なども変更できるため、不用意に扱うべきではないでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#read-prototype-chain)*プロパティの参照とプロトタイプチェーン*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*プロトタイプオブジェクトのプロパティがどのようにインスタンスから参照されるかを見ていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: オブジェクトのプロパティを参照するときに、オブジェクト自身がプロパティを持っていない場合でも、そこで探索が終わるわけではありません。 オブジェクトの`[[Prototype]]`内部プロパティ（仕様上の内部的なプロパティ）の参照先であるプロトタイプオブジェクトに対しても探索を続けます。
    これは、スコープに指定した識別子の変数がなかった場合に外側のスコープへと探索するスコープチェーンと良く似た仕組みです。
  prefs: []
  type: TYPE_NORMAL
- en: つまり、オブジェクトがプロパティを探索するときは次のような順番で、それぞれのオブジェクトを調べます。 すべてのオブジェクトにおいて見つからなかった場合の結果は`undefined`を返します。
  prefs: []
  type: TYPE_NORMAL
- en: '`instance`オブジェクト自身'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`instance`オブジェクトの`[[Prototype]]`の参照先（プロトタイプオブジェクト）'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: どこにもなかった場合は`undefined`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 次のコードでは、インスタンスオブジェクト自身は`method`プロパティを持っていません。 そのため、実際に参照しているのはクラスのプロトタイプオブジェクトの`method`プロパティです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: このように、インスタンスオブジェクトに`method`が定義されていなくても、クラスのプロトタイプオブジェクトの`method`を呼び出すことができます。
    このプロパティを参照する際に、オブジェクト自身から`[[Prototype]]`内部プロパティへと順番に探す仕組みのことを**プロトタイプチェーン**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: プロトタイプチェーンの仕組みを疑似的なコードとして表現すると次のような動きをしています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: プロトタイプチェーンの仕組みによって、プロトタイプオブジェクトに定義したプロトタイプメソッドをインスタンスから呼び出せます。
  prefs: []
  type: TYPE_NORMAL
- en: 普段は、プロトタイプオブジェクトやプロトタイプチェーンといった仕組みを意識する必要はありません。 `class`構文はこのようなプロトタイプを意識せずにクラスを利用できるように導入された構文です。
    しかし、プロトタイプベースである言語のJavaScriptではクラスをこのようなプロトタイプを使って表現していることは知っておくとよいでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#extends)*継承*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`extends`キーワードを使うことで既存のクラスを継承できます。 継承とは、クラスの**構造**や**機能**を引き継いだ新しいクラスを定義することです。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#class-extends)*継承したクラスの定義*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`extends`キーワードを使って既存のクラスを継承した新しいクラスを定義してみます。 `class`構文の右辺に`extends`キーワードで継承元となる**親クラス**（基底クラス）を指定することで、
    親クラスを継承した**子クラス**（派生クラス）を定義できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは、`Parent`クラスを継承した`Child`クラスを定義しています。 子クラスである`Child`クラスのインスタンス化は通常のクラスと同じく`new`演算子を使って行います。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[](#class-super)*`super`*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`extends`を使って定義した子クラスから親クラスを参照するには`super`というキーワードを利用します。 もっともシンプルな`super`を使う例としてコンストラクタの処理を見ていきます。'
  prefs: []
  type: TYPE_NORMAL
- en: '`class`構文でも紹介しましたが、クラスは必ず`constructor`メソッド（コンストラクタ）を持ちます。 これは、継承した子クラスでも同じです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`Parent`クラスを継承した`Child`クラスのコンストラクタで、`super()`を呼び出しています。 `super()`は子クラスから親クラスの`constructor`メソッドを呼び出します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`class`構文でのクラス定義では、`constructor`メソッド（コンストラクタ）で何も処理しない場合は省略できることを紹介しました。 これは、継承した子クラスでも同じです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードの`Child`クラスのコンストラクタでは、何も処理を行っていません。 そのため、`Child`クラスの`constructor`メソッドの定義を省略できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: このように子クラスで`constructor`を省略した場合は次のように書いた場合と同じ意味になります。 `constructor`メソッドの引数をすべて受け取り、そのまま`super`へ引数の順番を維持して渡します。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[](#constructor-order)*コンストラクタの処理順は親クラスから子クラスへ*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*コンストラクタの処理順は、親クラスから子クラスへと順番が決まっています。'
  prefs: []
  type: TYPE_NORMAL
- en: '`class`構文では必ず親クラスのコンストラクタ処理（`super()`の呼び出し）を先に行い、その次に子クラスのコンストラクタ処理を行います。 子クラスのコンストラクタでは、`this`を触る前に`super()`で親クラスのコンストラクタ処理を呼び出さないと`ReferenceError`となるためです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`Parent`と`Child`でそれぞれインスタンス（`this`）の`name`プロパティに値を書き込んでいます。 子クラスでは先に`super()`を呼び出してからでないと`this`を参照できません。
    そのため、コンストラクタの処理順は`Parent`から`Child`という順番に限定されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[](#class-fields-inheritance)*クラスフィールドの継承*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Publicクラスフィールドもコンストラクタの処理順と同じく親クラスのフィールドが初期化された後に子クラスのフィールドが初期化されます。 Publicクラスフィールドは、インスタンスオブジェクトに対してプロパティを定義する構文でした。
    そのため、親クラスで定義されていたフィールドも、実際にインスタンス化したオブジェクトのプロパティとして定義されます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 同じ名前のフィールドが定義されている場合は、子クラスのフィールド定義で上書きされます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Publicクラスフィールドは、このように親クラスで定義したフィールドも子クラスに定義されます。 一方で、Privateクラスフィールドは、このように親クラスで定義したフィールドは子クラスに定義されません。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、親クラスで定義したPrivateクラスフィールドを子クラスから参照しようとしています。 しかし、`#parentField`は参照できずに構文エラーとなることがわかります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: これは、PrivateクラスフィールドのPrivateとは各クラスごとのPrivateを守る目的であるためです。 継承したクラスからPrivateクラスフィールドが利用できてしまうと、Privateな情報が子クラスに漏れてしまうためです。
    JavaScriptでは、クラスの外に公開したくないが、子クラスからは利用できるようにしたいというような中間の制限を持ったプロパティを定義する構文はありません。
  prefs: []
  type: TYPE_NORMAL
- en: このように子クラスも含むクラスの外からアクセスを厳密に拒否するPrivateをhard privateと呼びます。 JavaScriptでのPrivateクラスフィールドはhard
    privateとなっています。
  prefs: []
  type: TYPE_NORMAL
- en: 一方で、子クラスからのアクセスは許可したり、クラス外からのアクセスが可能となるような特例を持つようなPrivateをsoft privateと呼びます。
    JavaScriptでのsoft privateは、WeakMapやWeakSetを使ってユーザー自身で実装する必要があります（「[Map/Set](../map-and-set/)」の章を参照）。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#prototype-inheritance)*プロトタイプ継承*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*次のコードでは`extends`キーワードを使って`Parent`クラスを継承した`Child`クラスを定義しています。 `Parent`クラスでは`method`を定義しているため、これを継承している`Child`クラスのインスタンスからも呼び出せます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: このように、子クラスのインスタンスから親クラスのプロトタイプメソッドもプロトタイプチェーンの仕組みによって呼び出せます。
  prefs: []
  type: TYPE_NORMAL
- en: '`extends`によって継承した場合、子クラスのプロトタイプオブジェクトの`[[Prototype]]`内部プロパティには親クラスのプロトタイプオブジェクトが設定されます。
    このコードでは、`Child.prototype`オブジェクトの`[[Prototype]]`内部プロパティには`Parent.prototype`が設定されます。'
  prefs: []
  type: TYPE_NORMAL
- en: これにより、プロパティを参照する場合には次のような順番でオブジェクトを探索しています。
  prefs: []
  type: TYPE_NORMAL
- en: '`instance`オブジェクト自身'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Child.prototype`（`instance`オブジェクトの`[[Prototype]]`の参照先）'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Parent.prototype`（`Child.prototype`オブジェクトの`[[Prototype]]`の参照先）'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: このプロトタイプチェーンの仕組みにより、`method`プロパティは`Parent.prototype`オブジェクトに定義されたものを参照します。
  prefs: []
  type: TYPE_NORMAL
- en: このようにJavaScriptでは`class`構文と`extends`キーワードを使うことでクラスの**機能**を継承できます。 `class`構文ではプロトタイプオブジェクトを参照する仕組みによって継承が行われています。
    そのため、この継承の仕組みを**プロトタイプ継承**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#static-inheritance)*静的メソッドの継承*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*インスタンスとクラスのプロトタイプオブジェクトとの間にはプロトタイプチェーンがあります。 クラス自身（クラスのコンストラクタ）も親クラス自身（親クラスのコンストラクタ）との間にプロトタイプチェーンがあります。'
  prefs: []
  type: TYPE_NORMAL
- en: 簡単に言えば、静的メソッドも継承されるということです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`extends`によって継承した場合、子クラスのコンストラクタの`[[Prototype]]`内部プロパティには親クラスのコンストラクタが設定されます。
    このコードでは、`Child`コンストラクタの`[[Prototype]]`内部プロパティに`Parent`コンストラクタが設定されます。'
  prefs: []
  type: TYPE_NORMAL
- en: つまり、先ほどのコードでは`Child.hello`プロパティを参照した場合には、次のような順番でオブジェクトを探索しています。
  prefs: []
  type: TYPE_NORMAL
- en: '`Child`コンストラクタ'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Parent`コンストラクタ（`Child`コンストラクタの`[[Prototype]]`の参照先）'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: クラスのコンストラクタ同士にもプロトタイプチェーンの仕組みがあるため、子クラスは親クラスの静的メソッドを呼び出せます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#super-property)*`super`プロパティ*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*子クラスから親クラスのコンストラクタ処理を呼び出すには`super()`を使います。 同じように、子クラスのプロトタイプメソッドからは、`super.プロパティ名`で親クラスのプロトタイプメソッドを参照できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`Child.prototype.method`の中で`super.method()`と書くことで`Parent.prototype.method`を呼び出しています。
    このように、子クラスから継承元の親クラスのプロトタイプメソッドは`super.プロパティ名`で参照できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: プロトタイプチェーンでは、インスタンスからクラス、さらに親のクラスと継承関係をさかのぼるようにメソッドを探索すると紹介しました。 このコードでは`Child.prototype.method`が定義されているため、`child.method`は`Child.prototype.method`を呼び出します。
    そして`Child.prototype.method`は`super.method`を呼び出しているため、`Parent.prototype.method`が呼び出されます。
  prefs: []
  type: TYPE_NORMAL
- en: クラスの静的メソッド同士も同じように`super.method()`と書くことで呼び出せます。 次のコードでは、`Parent`を継承した`Child`から親クラスの静的メソッドを呼び出しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[](#instanceof)*継承の判定*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*あるクラスが指定したクラスをプロトタイプ継承しているかは`instanceof`演算子を使って判定できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`Child`のインスタンスは`Child`クラスと`Parent`クラスを継承したオブジェクトであることを確認しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: より具体的な継承の使い方については「[ユースケース:Todoアプリ](../../use-case/todoapp/)」の章で見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#extends-built-in)*ビルトインオブジェクトの継承*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ここまで自身が定義したクラスを継承してきましたが、ビルトインオブジェクトのコンストラクタも継承できます。 ビルトインオブジェクトには`Array`、`String`、`Object`、`Number`、`Error`、`Date`などのコンストラクタがあります。
    `class`構文ではこれらのビルトインオブジェクトを継承できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、ビルトインオブジェクトである`Array`を継承して独自のメソッドを加えた`MyArray`クラスを定義しています。 継承した`MyArray`は`Array`の性質であるメソッドや状態管理についての仕組みを継承しています。
    継承した性質に加えて、MyArrayクラスへ`first`や`last`といったアクセッサプロパティを追加しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`Array`を継承した`MyArray`は、`Array`が元々持つ`length`プロパティや`Array.from`メソッドなどを継承しているので利用できます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#conclusion)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章ではクラスについて学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptのクラスはプロトタイプベース
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: クラスは`class`構文で定義できる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: クラスで定義したメソッドはプロトタイプオブジェクトとプロトタイプチェーンの仕組みで呼び出せる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: クラスのインスタンスに対するプロパティの定義にはクラスフィールドが利用できる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: クラスの外からアクセスさせたくないプロパティの定義にはPrivateクラスフィールドを使う
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: アクセッサプロパティはgetterとsetterのメソッドを定義することでプロパティのように振る舞う
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: クラスは`extends`で継承できる
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: クラスのプロトタイプメソッドと静的メソッドはどちらも継承される********************************
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
