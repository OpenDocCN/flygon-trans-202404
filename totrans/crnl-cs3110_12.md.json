["```\nmodule *ModuleName* = struct *implementation* end\n\n```", "```\nmodule type *SIGNAME* = sig *definitions* end\n\n```", "```\nmodule *ModuleName* : *SIGNAME* = struct *implementation* end\n\n```", "```\n(* Set data abstraction with union and intersection *)\n\nmodule type SET = sig\n  type 'a set\n  val empty : 'a set\n  val mem : 'a -> 'a set -> bool\n  val add : 'a -> 'a set -> 'a set\n  val rem : 'a -> 'a set -> 'a set\n  val size: 'a set -> int\n  val union: 'a set -> 'a set -> 'a set\n  val inter: 'a set -> 'a set -> 'a set\nend\n\n(* Implementation of sets as lists with duplicates *)\n\nmodule Set1 : SET = struct\n  type 'a set = 'a list\n  let empty = []\n  let mem = List.mem\n  let add x l = x :: l\n  let rem x = List.filter ((<>) x)\n  let rec size l = \n    match l with\n    | [] -> 0\n    | h :: t -> size t + (if mem h t then 0 else 1)\n  let union l1 l2 = l1 @ l2\n  let inter l1 l2 = List.filter (fun h -> mem h l2) l1\nend\n\n(* Implementation of sets as lists without duplicates *)\n\nmodule Set2 : SET = struct\n  type 'a set = 'a list\n  let empty = []\n  let mem = List.mem\n  (* add checks if already a member *)\n  let add x l = if mem x l then l else x :: l \n  let rem x = List.filter ((<>) x)\n  let size = List.length (* size is just length if no duplicates *)\n  let union l1 l2 = (* check if already in other set *)\n    List.fold_left (fun a x -> if mem x l2 then a else x :: a) l2 l1\n  let inter l1 l2 = List.filter (fun h -> mem h l2) l1\nend\n\n```", "```\n(* A specification of an immutable stack of elements of type 'a. *)\n\nmodule type STACK = sig\n  type 'a stack\n  exception EmptyStack\n  val empty : 'a stack\n  val is_empty : 'a stack -> bool\n  val push : 'a -> 'a stack -> 'a stack\n  val pop : 'a stack -> 'a * 'a stack\n  val map : ('a -> 'b) -> 'a stack -> 'b stack\nend\n\n(* An implementation using lists, where the top of the stack is\n * represented by the head of the list. *)\n\nmodule Stack : STACK = struct\n  type 'a stack = 'a list\n  exception EmptyStack\n\n  let empty = []\n  let is_empty l = l = []\n  let push x l = x :: l\n\n  let pop l =\n    match l with\n    | [] -> raise EmptyStack\n    | x :: xs -> (x, xs)\n\n  let map = List.map\nend\n```", "```\n(* Univariate polynomials with integer coefficients. *)\n\nmodule type POLYNOMIAL = sig\n  type poly\n  val zero : poly\n  (* monomial (c, d) is the polynomial cx^d. Requires d >= 0\\. *)\n  val monomial : int * int -> poly\n  (* degree is the largest exponent with a nonzero coefficient *)\n  val degree : poly -> int\n  (* evaluate p at integer value x *)\n  val evaluate : poly * int -> int\n  (* coeff (p, d) is the coefficient of the of the degree-d term,\n   * or zero if there is no such term. Requires: d >= 0\\. *)\n  val coeff : poly * int -> int\n  (* ring operations *)\n  val plus : poly * poly -> poly\n  val minus : poly * poly -> poly\n  val times : poly * poly -> poly\n  (* conversion to printable form *)\n  val to_string: poly -> string\nend\n\nmodule Polynomial : POLYNOMIAL = struct\n  (* Univariate polynomials represented as a list of coefficients.\n   * Degree is based on position in the list, low degrees first. *)\n  type poly = int list\n  let zero = []\n\n  (* A monomial cx^d is a list of length d with c last and all\n   * other elements 0 *)\n  let rec monomial (coeff, degree) =\n    if degree < 0 then failwith \"negative degree\" else\n    match (coeff, degree) with\n      | (0, _) -> zero\n      | (c, 0) -> [c]\n      | (c, d) -> 0 :: monomial (c, d - 1)\n\n  let degree p =       \n    match p with\n      | [] -> 0\n      | _ -> List.length p - 1\n\n  let rec coeff (p, n) =\n    match p with\n      | [] -> 0\n      | h :: t -> if n = 0 then h else coeff (t, n - 1)\n\n  (* plus and minus both operate on two polynomials term by term,\n   * so this function abstracts out the common pattern *)\n  let rec termapply (f, p, q) =\n    match (p, q) with\n      | ([], []) -> []\n      | ([], b :: q2) -> f (0, b) :: termapply (f, [], q2)\n      | (a :: p2, []) -> f(a, 0) :: termapply (f, p2, [])\n      | (a :: p2, b :: q2) -> f (a, b) :: termapply (f, p2, q2)\n\n  let plus (p, q) = termapply ((fun (a, b) -> a + b), p, q)\n  let minus (p, q) = termapply ((fun (a, b) -> a - b), p, q)\n  let times (p, q) = failwith \"not implemented\"\n\n  let evaluate (p, x) =\n    List.fold_right (fun h a -> h + x * a) p 0\n\n  let to_string p =\n    let term (d, s) c =\n      if c = 0 then (d + 1, s) else \n      (d + 1, (if s = \"\" then \"\" else s ^ \" + \") ^\n      (if c = 1 then \"\" else (if c = (-1) then \"-\" else string_of_int c)) ^\n      (if d > 0 then \"x\" ^ (if d > 1 then \"^\" ^ string_of_int d else \"\")\n      else \"\")) in\n    match List.fold_left term (0, \"\") p with (d, s) -> s\n\nend\n\n(* some test cases *)\n\nlet px2 = Polynomial.monomial (1, 2);;\nlet p3x2 = Polynomial.monomial (3, 2);;\nlet p2x3 = Polynomial.monomial (2, 3);;\nlet p3x4 = Polynomial.monomial (3, 4);;\nlet px5 = Polynomial.monomial (1, 5);;\nlet tp1 = Polynomial.plus (px2, px2);;\nlet tp2 = Polynomial.plus (tp1, Polynomial.plus (p2x3, px5));;\nPolynomial.evaluate (tp2, 2);;\nPolynomial.to_string tp2;;\n```"]