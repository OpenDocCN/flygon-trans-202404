- en: 'Recitation 9: Examples of functors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous lecture we saw functors for the first time. Today we will see
    more examples of them. Recall that a *functor* is a module that is parameterized
    on other modules. Functors allow us to create a module whose implementation depends
    on the implementation of one or several other modules, the argument(s) of the
    functor. Among other uses, functors allow us to define several modules with small
    differences. This is done without any code duplication, by making the argument
    module implement those differences.
  prefs: []
  type: TYPE_NORMAL
- en: An implementation of maps using functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *map* is a data abstraction that binds *keys* to *values*. We define a functor
    taking two arguments: the first argument is an implementation of the keys, and
    the second argument is an implementation of the values. The key implementation
    is required to support an equality comparison. There are no requirements placed
    on the value implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example of how to use our map abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: module type RING = sig
  prefs: []
  type: TYPE_NORMAL
- en: type t
  prefs: []
  type: TYPE_NORMAL
- en: 'val zero : t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val one : t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val plus : t -> t -> t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val mult : t -> t -> t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val equal : t -> t -> bool'
  prefs: []
  type: TYPE_NORMAL
- en: 'val print : t -> unit'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: module type POLYNOMIAL = sig
  prefs: []
  type: TYPE_NORMAL
- en: type c (* type of numbers used in the polynomial *)
  prefs: []
  type: TYPE_NORMAL
- en: type t (* type of the polynomials *)
  prefs: []
  type: TYPE_NORMAL
- en: 'val zero : t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val one : t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val monom : c -> int -> t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val plus : t -> t -> t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val mult : t -> t -> t'
  prefs: []
  type: TYPE_NORMAL
- en: 'val equal : t -> t -> bool'
  prefs: []
  type: TYPE_NORMAL
- en: 'val print : t -> unit'
  prefs: []
  type: TYPE_NORMAL
- en: 'val eval : t -> c -> c'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'module MakePolynomial (A : RING) : POLYNOMIAL'
  prefs: []
  type: TYPE_NORMAL
- en: with type c=A.t =
  prefs: []
  type: TYPE_NORMAL
- en: struct
  prefs: []
  type: TYPE_NORMAL
- en: type c = A.t
  prefs: []
  type: TYPE_NORMAL
- en: type monom = (c * int)  (* a monom is a pair (coefficient,power) *)
  prefs: []
  type: TYPE_NORMAL
- en: type t = monom list
  prefs: []
  type: TYPE_NORMAL
- en: (* a polynomial of type t is a list of monoms, where powers are
  prefs: []
  type: TYPE_NORMAL
- en: all different and ordered, and where coefficients are all non-zero *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let zero = []
  prefs: []
  type: TYPE_NORMAL
- en: let one = [A.one, 0]
  prefs: []
  type: TYPE_NORMAL
- en: let rec equal p1 p2 =  match p1, p2 with
  prefs: []
  type: TYPE_NORMAL
- en: '| [],[] -> true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| (a1, k1)::q1, (a2, k2)::q2 -> k1 = k2 &&'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A.equal a1 a2 && equal q1 q2
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| _ -> false'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let monom a k =
  prefs: []
  type: TYPE_NORMAL
- en: if k < 0
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'then failwith "fail monom: negative power"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: else if A.equal a A.zero
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then []
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else [(a,k)]
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let rec plus p1 p2 =  match p1, p2 with
  prefs: []
  type: TYPE_NORMAL
- en: (x1, k1)::r1, ((x2, k2)::r2) ->
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if k1 < k2 then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '(x1, k1):: (plus r1 p2)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else if k1 = k2 then
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let x = A.plus x1 x2 in
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if A.equal x A.zero then plus r1 r2
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (* in some rings, like Z/2Z, x=0 can happen *)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else (A.plus x1 x2, k1):: (plus r1 r2)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '(x2, k2):: (plus p1 r2)'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| [], _ -> p2'
  prefs: []
  type: TYPE_NORMAL
- en: '| _ , [] -> p1'
  prefs: []
  type: TYPE_NORMAL
- en: let rec times (a, k) p =
  prefs: []
  type: TYPE_NORMAL
- en: (* auxiliary function, multiplies p by aX^k *)
  prefs: []
  type: TYPE_NORMAL
- en: (* supposes a <> 0 *)
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| [] -> []'
  prefs: []
  type: TYPE_NORMAL
- en: '| (a1, k1)::q ->'
  prefs: []
  type: TYPE_NORMAL
- en: let a2 = A.mult a a1 in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if A.equal a2 A.zero (* in some rings, like Z/2Z, a2=0 can happen *)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then times (a,k) q
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else (a2, k + k1) :: times (a,k) q'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mult p = List.fold_left (fun r m -> plus r (times m p)) zero
  prefs: []
  type: TYPE_NORMAL
- en: let print p =
  prefs: []
  type: TYPE_NORMAL
- en: print_string "(";
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let b = List.fold_left
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (fun acc (a,k) ->
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* acc is false only for the first monom printed *)
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if acc then print_string "+";
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A.print a; print_string "X^"; print_int k;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'true'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) false p in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (not b) then (A.print A.zero);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_string ")"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let rec pow c k = match k with
  prefs: []
  type: TYPE_NORMAL
- en: (* auxiliary function for eval *)
  prefs: []
  type: TYPE_NORMAL
- en: (* given c and k, calculates c^k *)
  prefs: []
  type: TYPE_NORMAL
- en: 0 -> A.one
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| 1 -> c'
  prefs: []
  type: TYPE_NORMAL
- en: '| k ->'
  prefs: []
  type: TYPE_NORMAL
- en: let l = pow c (k/2) in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let l2 = A.mult l l in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if k mod 2 = 0 then l2 else A.mult c l2
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let eval p c = match List.rev p with
  prefs: []
  type: TYPE_NORMAL
- en: '[] -> A.zero'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| (h::t) ->'
  prefs: []
  type: TYPE_NORMAL
- en: let (* supposes k >= l. *)  dmeu (a, k) (b, l) =
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A.plus (A.mult (pow c (k-l)) a) b, l
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: in let a, k = List.fold_left dmeu h t in
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A.mult (pow c k) a
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: module IntRing = struct
  prefs: []
  type: TYPE_NORMAL
- en: type t=int
  prefs: []
  type: TYPE_NORMAL
- en: let zero=0
  prefs: []
  type: TYPE_NORMAL
- en: let one=1
  prefs: []
  type: TYPE_NORMAL
- en: let plus a b=a+b
  prefs: []
  type: TYPE_NORMAL
- en: let mult a b=a*b
  prefs: []
  type: TYPE_NORMAL
- en: let equal a b=(a=b)
  prefs: []
  type: TYPE_NORMAL
- en: let print=print_int
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: module BoolRing = struct
  prefs: []
  type: TYPE_NORMAL
- en: type t=bool
  prefs: []
  type: TYPE_NORMAL
- en: let zero=false
  prefs: []
  type: TYPE_NORMAL
- en: let one=true
  prefs: []
  type: TYPE_NORMAL
- en: let plus a b=a || b
  prefs: []
  type: TYPE_NORMAL
- en: let mult a b=a && b
  prefs: []
  type: TYPE_NORMAL
- en: let equal a b=(a=b)
  prefs: []
  type: TYPE_NORMAL
- en: let print a=if a then print_string "true"
  prefs: []
  type: TYPE_NORMAL
- en: else print_string "false"
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: module IntPolynomial=MakePolynomial(IntRing)
  prefs: []
  type: TYPE_NORMAL
- en: module BoolPolynomial=MakePolynomial(BoolRing)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: open IntPolynomial;;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: let a=monom 5 4;;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'val a : IntPolynomial.t = <abstr>'
  prefs: []
  type: TYPE_NORMAL
- en: print a;;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '(5X^4)- : unit = ()'
  prefs: []
  type: TYPE_NORMAL
- en: let b=monom 1 8;;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'val b : IntPolynomial.t = <abstr>'
  prefs: []
  type: TYPE_NORMAL
- en: print b;;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '(1X^8)- : unit = ()'
  prefs: []
  type: TYPE_NORMAL
- en: print (plus a b);;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '(5X^4+1X^8)- : unit = ()'
  prefs: []
  type: TYPE_NORMAL
- en: print (mult a b);;
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '(5X^12)- : unit = ()'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: module IntPolynomial2Vars=MakePolynomial(IntPolynomial)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
