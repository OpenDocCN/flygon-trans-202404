- en: 'Recitation 9: Examples of functors'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous lecture we saw functors for the first time. Today we will see
    more examples of them. Recall that a *functor* is a module that is parameterized
    on other modules. Functors allow us to create a module whose implementation depends
    on the implementation of one or several other modules, the argument(s) of the
    functor. Among other uses, functors allow us to define several modules with small
    differences. This is done without any code duplication, by making the argument
    module implement those differences.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: An implementation of maps using functors
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *map* is a data abstraction that binds *keys* to *values*. We define a functor
    taking two arguments: the first argument is an implementation of the keys, and
    the second argument is an implementation of the values. The key implementation
    is required to support an equality comparison. There are no requirements placed
    on the value implementation.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here is an example of how to use our map abstraction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: module type RING = sig
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: type t
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'val zero : t'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'val one : t'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'val plus : t -> t -> t'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'val mult : t -> t -> t'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'val equal : t -> t -> bool'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'val print : t -> unit'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: module type POLYNOMIAL = sig
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: type c (* type of numbers used in the polynomial *)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: type t (* type of the polynomials *)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'val zero : t'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'val one : t'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'val monom : c -> int -> t'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'val plus : t -> t -> t'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'val mult : t -> t -> t'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'val equal : t -> t -> bool'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'val print : t -> unit'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'val eval : t -> c -> c'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: end
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'module MakePolynomial (A : RING) : POLYNOMIAL'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: with type c=A.t =
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: struct
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: type c = A.t
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: type monom = (c * int)  (* a monom is a pair (coefficient,power) *)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: type t = monom list
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: (* a polynomial of type t is a list of monoms, where powers are
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: all different and ordered, and where coefficients are all non-zero *)
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let zero = []
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: let one = [A.one, 0]
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: let rec equal p1 p2 =  match p1, p2 with
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '| [],[] -> true'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| (a1, k1)::q1, (a2, k2)::q2 -> k1 = k2 &&'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A.equal a1 a2 && equal q1 q2
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| _ -> false'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let monom a k =
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: if k < 0
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'then failwith "fail monom: negative power"'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: else if A.equal a A.zero
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then []
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else [(a,k)]
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: let rec plus p1 p2 =  match p1, p2 with
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: (x1, k1)::r1, ((x2, k2)::r2) ->
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if k1 < k2 then
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '(x1, k1):: (plus r1 p2)'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else if k1 = k2 then
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let x = A.plus x1 x2 in
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if A.equal x A.zero then plus r1 r2
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: (* in some rings, like Z/2Z, x=0 can happen *)
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else (A.plus x1 x2, k1):: (plus r1 r2)'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: else
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '(x2, k2):: (plus p1 r2)'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '| [], _ -> p2'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '| _ , [] -> p1'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: let rec times (a, k) p =
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: (* auxiliary function, multiplies p by aX^k *)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: (* supposes a <> 0 *)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: match p with
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| [] -> []'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '| (a1, k1)::q ->'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: let a2 = A.mult a a1 in
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if A.equal a2 A.zero (* in some rings, like Z/2Z, a2=0 can happen *)
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: then times (a,k) q
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else (a2, k + k1) :: times (a,k) q'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let mult p = List.fold_left (fun r m -> plus r (times m p)) zero
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: let print p =
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: print_string "(";
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let b = List.fold_left
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (fun acc (a,k) ->
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (* acc is false only for the first monom printed *)
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: if acc then print_string "+";
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: A.print a; print_string "X^"; print_int k;
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'true'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ) false p in
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: if (not b) then (A.print A.zero);
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: print_string ")"
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let rec pow c k = match k with
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: let rec pow c k = match k with
- en: (* auxiliary function for eval *)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: (* 用于 eval 的辅助函数 *)
- en: (* given c and k, calculates c^k *)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: (* 给定 c 和 k，计算 c^k *)
- en: 0 -> A.one
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0 -> A.one
- en: '| 1 -> c'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '| 1 -> c'
- en: '| k ->'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '| k ->'
- en: let l = pow c (k/2) in
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let l = pow c (k/2) in
- en: let l2 = A.mult l l in
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let l2 = A.mult l l in
- en: if k mod 2 = 0 then l2 else A.mult c l2
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if k mod 2 = 0 then l2 else A.mult c l2
- en: let eval p c = match List.rev p with
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: let eval p c = match List.rev p with
- en: '[] -> A.zero'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[] -> A.zero'
- en: '| (h::t) ->'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '| (h::t) ->'
- en: let (* supposes k >= l. *)  dmeu (a, k) (b, l) =
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let (* 假设 k >= l. *)  dmeu (a, k) (b, l) =
- en: A.plus (A.mult (pow c (k-l)) a) b, l
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: A.plus (A.mult (pow c (k-l)) a) b, l
- en: in let a, k = List.fold_left dmeu h t in
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: in let a, k = List.fold_left dmeu h t in
- en: A.mult (pow c k) a
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A.mult (pow c k) a
- en: end
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: module IntRing = struct
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: module IntRing = struct
- en: type t=int
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: type t=int
- en: let zero=0
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: let zero=0
- en: let one=1
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: let one=1
- en: let plus a b=a+b
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: let plus a b=a+b
- en: let mult a b=a*b
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: let mult a b=a*b
- en: let equal a b=(a=b)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: let equal a b=(a=b)
- en: let print=print_int
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: let print=print_int
- en: end
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: module BoolRing = struct
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: module BoolRing = struct
- en: type t=bool
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: type t=bool
- en: let zero=false
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: let zero=false
- en: let one=true
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: let one=true
- en: let plus a b=a || b
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: let plus a b=a || b
- en: let mult a b=a && b
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: let mult a b=a && b
- en: let equal a b=(a=b)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: let equal a b=(a=b)
- en: let print a=if a then print_string "true"
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: let print a=if a then print_string "true"
- en: else print_string "false"
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: else print_string "false"
- en: end
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: end
- en: module IntPolynomial=MakePolynomial(IntRing)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: module IntPolynomial=MakePolynomial(IntRing)
- en: module BoolPolynomial=MakePolynomial(BoolRing)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: module BoolPolynomial=MakePolynomial(BoolRing)
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: open IntPolynomial;;
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: open IntPolynomial;;
- en: let a=monom 5 4;;
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: let a=monom 5 4;;
- en: 'val a : IntPolynomial.t = <abstr>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'val a : IntPolynomial.t = <abstr>'
- en: print a;;
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: print a;;
- en: '(5X^4)- : unit = ()'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '(5X^4)- : unit = ()'
- en: let b=monom 1 8;;
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: let b=monom 1 8;;
- en: 'val b : IntPolynomial.t = <abstr>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'val b : IntPolynomial.t = <abstr>'
- en: print b;;
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: print b;;
- en: '(1X^8)- : unit = ()'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '(1X^8)- : unit = ()'
- en: print (plus a b);;
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: print (plus a b);;
- en: '(5X^4+1X^8)- : unit = ()'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '(5X^4+1X^8)- : unit = ()'
- en: print (mult a b);;
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: print (mult a b);;
- en: '(5X^12)- : unit = ()'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '(5X^12)- : unit = ()'
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: module IntPolynomial2Vars=MakePolynomial(IntPolynomial)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: module IntPolynomial2Vars=MakePolynomial(IntPolynomial)
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
