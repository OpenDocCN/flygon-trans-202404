- en: 18Sharing and Equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|     [18.1 Re-Examining Equality](#%28part._identical-eq%29) |'
  prefs: []
  type: TYPE_TB
- en: '|     [18.2 The Cost of Evaluating References](#%28part._.The_.Cost_of_.Evaluating_.References%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [18.3 On the Internet, Nobody Knows You’re a DAG](#%28part._.On_the_.Internet__.Nobody_.Knows_.You_re_a_.D.A.G%29)
    |'
  prefs: []
  type: TYPE_TB
- en: '|     [18.4 From Acyclicity to Cycles](#%28part._acyc-to-cyc%29) |'
  prefs: []
  type: TYPE_TB
- en: 18.1Re-Examining Equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following data definition and example values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In particular, it might seem that the way we’ve written b-tree is morally equivalent
    to how we’ve written a-tree, but we’ve created a helpful binding to avoid code
    duplication.Because both a-tree and b-tree are bound to trees with 5 at the root
    and a left and right child each containing 4, we can indeed reasonably consider
    these trees equivalent. Sure enough:<equal-tests> ::=
  prefs: []
  type: TYPE_NORMAL
- en: '|   check: |'
  prefs: []
  type: TYPE_TB
- en: '|     a-tree is b-tree |'
  prefs: []
  type: TYPE_TB
- en: '|     a-tree.l is a-tree.l |'
  prefs: []
  type: TYPE_TB
- en: '|     a-tree.l is a-tree.r |'
  prefs: []
  type: TYPE_TB
- en: '|     b-tree.l is b-tree.r |'
  prefs: []
  type: TYPE_TB
- en: '|   end |'
  prefs: []
  type: TYPE_TB
- en: However, there is another sense in which these trees are not equivalent. concretely,
    a-tree constructs a distinct node for each child, while b-tree uses the same node
    for both children. Surely this difference should show up somehow, but we have
    not yet seen a way to write a program that will tell these apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the is operator uses the same equality test as Pyret’s ==. There
    are, however, other equality tests in Pyret. In particular, the way we can tell
    apart these data is by using Pyret’s identical function, which implements reference
    equality. This checks not only whether two values are structurally equivalent
    but whether they are the result of the very same act of value construction. With
    this, we can now write additional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is actually another way to write these tests in Pyret: the is operator
    can also be parameterized by a different equality predicate than the default ==.
    Thus, the above block can equivalently be written as:We can use is-not to check
    for expected failure of equality.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use this style of equality testing from now on.Observe how these are
    the same values that were compared earlier ([<equal-tests>](#%28elem._equal-tests%29)),
    but the results are now different: some values that were true earlier are now
    false. In particular,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Later we will return both to what identical really means [[What it Means to
    be Identical](State__Change__and_More_Equality.html#%28part._sem-identical%29)]
    and to the full range of Pyret’s equality operations [[A Family of Equality Predicates](State__Change__and_More_Equality.html#%28part._equality-operations%29)].
  prefs: []
  type: TYPE_NORMAL
- en: 18.2The Cost of Evaluating References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From a complexity viewpoint, it’s important for us to understand how these
    references work. As we have hinted, four-node is computed only once, and each
    use of it refers to the same value: if, instead, it was evaluated each time we
    referred to four-node, there would be no real difference between a-tree and b-tree,
    and the above tests would not distinguish between them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially relevant when understanding the cost of function evaluation.
    We’ll construct two simple examples that illustrate this. We’ll begin with a contrived
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we now define
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Constructing a list clearly takes time at least proportional to the length;
    therefore, we expect the time to compute L to be considerably more than that for
    a single link operation. Therefore, the question is how long it takes to compute
    L1 and L2 after L has been computed: constant time, or time proportional to the
    length of L?The answer, for Pyret, and for most other contemporary languages (including
    Java, C#, OCaml, Racket, etc.), is that these additional computations take constant
    time. That is, the value bound to L is computed once and bound to L; subsequent
    expressions refer to this value (hence “reference”) rather than reconstructing
    it, as reference equality shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can define a function, pass L to it, and see whether the resulting
    argument is identical to the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: or, equivalently,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, neither built-in operations (like .rest) nor user-defined ones (like
    check-for-no-copy) make copies of their arguments.Strictly speaking, of course,
    we cannot conclude that no copy was made. Pyret could have made a copy, discarded
    it, and still passed a reference to the original. Given how perverse this would
    be, we can assume—<wbr>and take the language’s creators’ word for it—<wbr>that
    this doesn’t actually happen. By creating extremely large lists, we can also use
    timing information to observe that the time of constructing the list grows proportional
    to the length of the list while the time of passing it as a parameter remains
    constant. The important thing to observe here is that, instead of simply relying
    on authority, we have used operations in the language itself to understand how
    the language behaves.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3On the Internet, Nobody Knows You’re a DAG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Despite the name we’ve given it, b-tree is not actually a tree. In a tree,
    by definition, there are no shared nodes, whereas in b-tree the node named by
    four-node is shared by two parts of the tree. Despite this, traversing b-tree
    will still terminate, because there are no cyclic references in it: if you start
    from any node and visit its “children”, you cannot end up back at that node. There
    is a special name for a value with such a shape: directed acyclic graph (DAG).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many important data structures are actually a DAG underneath. For instance,
    consider Web sites. It is common to think of a site as a tree of pages: the top-level
    refers to several sections, each of which refers to sub-sections, and so on. However,
    sometimes an entry needs to be cataloged under multiple sections. For instance,
    an academic department might organize pages by people, teaching, and research.
    In the first of these pages it lists the people who work there; in the second,
    the list of courses; and in the third, the list of research groups. In turn, the
    courses might have references to the people teaching them, and the research groups
    are populated by these same people. Since we want only one page per person (for
    both maintenance and search indexing purposes), all these personnel links refer
    back to the same page for people.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s construct a simple form of this. First a datatype to represent a site’s
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now define a few people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'and a way to extract a particular person’s page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can define theory and systems sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'which are integrated into a site as a whole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can confirm that each of these luminaries needs to keep only one Web
    page current; for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 18.4From Acyclicity to Cycles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s another example that arises on the Web. Suppose we are constructing
    a table of output in a Web page. We would like the rows of the table to alternate
    between white and grey. If the table had only two rows, we could map the row-generating
    function over a list of these two colors. Since we do not know how many rows it
    will have, however, we would like the list to be as long as necessary. In effect,
    we would like to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: to obtain an indefinitely long list, so that we could eventually write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'which applies a color-table-row function to two arguments: the current row
    from table-row-content, and the current color from web-colors, proceeding in lockstep
    over the two lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are many things wrong with this attempted definition.
  prefs: []
  type: TYPE_NORMAL
- en: Do Now!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do you see what they are?
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here are some problems in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: This will not even parse. The identifier web-colors is not bound on the right
    of the =.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Earlier, we saw a solution to such a problem: use rec [[Streams From Functions](func-as-data.html#%28part._streams-from-funs%29)].
    What happens if we write'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: instead?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why does rec work in the definition of ones but not above?
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assuming we have fixed the above problem, one of two things will happen. It
    depends on what the initial value of web-colors is. Because it is a dummy value,
    we do not get an arbitrarily long list of colors but rather a list of two colors
    followed by the dummy value. Indeed, this program will not even type-check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose, however, that web-colors were written instead as a function definition
    to delay its creation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On its own this just defines a function. If, however, we use it—<wbr>web-colors()—<wbr>it
    goes into an infinite loop constructing links.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even if all that were to work, map2 would either (a) not terminate because its
    second argument is indefinitely long, or (b) report an error because the two arguments
    aren’t the same length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these problems are symptoms of a bigger issue. What we are trying to do
    here is not merely create a shared datum (like a DAG) but something much richer:
    a cyclic datum, i.e., one that refers back to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/dd3d4a0319da6629470312684c9597ff.jpg)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: 'When you get to cycles, even defining the datum becomes difficult because its
    definition depends on itself so it (seemingly) needs to already be defined in
    the process of being defined. We will return to cyclic data later: [Recursion
    and Cycles from Mutation](State__Change__and_More_Equality.html#%28part._rec-from-mut%29).'
  prefs: []
  type: TYPE_NORMAL
