- en: Chapter 10\. Libraries and Top-Level Programs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。库和顶层程序
- en: '*Libraries* and *top-level programs* are the basic units of portable code in
    the language defined by the Revised⁶ Report on Scheme [[24](bibliography.html#g242)].
    Top-level programs may import from one or more libraries, and libraries may import
    from other libraries.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*库*和*顶层程序*是修订⁶报告中定义的语言中的可移植代码的基本单位。顶层程序可以从一个或多个库中导入，而库可以从其他库中导入。'
- en: Libraries are named using a parenthesized syntax that encloses a sequence of
    identifiers, optionally followed by a version; the version is itself a parenthesized
    form that encloses a sequence of subversions represented as exact nonnegative
    integers. So, for example, `(a)`, `(a b)`, `(a b ())`, and `(a b (1 2 3))` are
    all valid library names. Implementations typically treat the sequence of names
    as a path by which a library's source or object code can be found, possibly rooted
    in some standard set of locations in the host-machine's filesystem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 库的命名采用括号语法，括号内包含一系列标识符，可选地跟随版本号；版本号本身是一个括号形式，括号内包含一系列表示为非负整数的子版本。因此，例如，`(a)`，`(a b)`，`(a b ())`和`(a b (1 2 3))`都是有效的库名称。实现通常将名称序列视为路径，通过该路径可以找到库的源代码或目标代码，可能根据主机文件系统中某些标准位置进行定位。
- en: An implementation of the standard library mechanism is available with the portable
    implementation of `syntax-case` at *http://www.cs.indiana.edu/syntax-case/*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库机制的一个实现可在*http://www.cs.indiana.edu/syntax-case/*上找到可移植的`syntax-case`实现。
- en: Section 10.1\. Standard Libraries
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第10.1节。标准库
- en: The Revised⁶ Report [[24](bibliography.html#g242)] describes a base library
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 修订⁶报告[[24](bibliography.html#g242)]描述了一个基本库
- en: '`  (rnrs base (6))`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (rnrs base (6))`'
- en: that defines the most commonly used features of the language. A separate Standard
    Libraries document [[26](bibliography.html#g244)] describes the libraries listed
    below.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了语言中最常用的功能。一个单独的标准库文档[[26](bibliography.html#g244)]描述了下面列出的库。
- en: '`  (rnrs arithmetic bitwise (6))'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (rnrs arithmetic bitwise (6))'
- en: (rnrs arithmetic fixnums (6))
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs arithmetic fixnums (6))
- en: (rnrs arithmetic flonums (6))
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs arithmetic flonums (6))
- en: (rnrs bytevectors (6))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs bytevectors (6))
- en: (rnrs conditions (6))
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs conditions (6))
- en: (rnrs control (6))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs control (6))
- en: (rnrs enums (6))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs enums (6))
- en: (rnrs eval (6))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs eval (6))
- en: (rnrs exceptions (6))
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs exceptions (6))
- en: (rnrs files (6))
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs files (6))
- en: (rnrs hashtables (6))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs hashtables (6))
- en: (rnrs io ports (6))
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs io ports (6))
- en: (rnrs io simple (6))
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs io simple (6))
- en: (rnrs lists (6))
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs lists (6))
- en: (rnrs mutable-pairs (6))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs mutable-pairs (6))
- en: (rnrs mutable-strings (6))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs mutable-strings (6))
- en: (rnrs programs (6))
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs programs (6))
- en: (rnrs r5rs (6))
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs r5rs (6))
- en: (rnrs records procedural (6))
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs records procedural (6))
- en: (rnrs records syntactic (6))
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs records syntactic (6))
- en: (rnrs records inspection (6))
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs records inspection (6))
- en: (rnrs sorting (6))
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs sorting (6))
- en: (rnrs syntax-case (6))
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs syntax-case (6))
- en: (rnrs unicode (6))`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: (rnrs unicode (6))`
- en: One more library is described in the Standard Libraries document, a composite
    library
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库文档中还描述了另一个库，即一个复合库
- en: '`  (rnrs (6))`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`  (rnrs (6))`'
- en: that exports all of the `(rnrs base (6))` bindings along with those of the other
    libraries listed above, except those of `(rnrs eval (6))`, `(rnrs mutable-pairs (6))`,
    `(rnrs mutable-strings (6))`, and `(rnrs r5rs (6))`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该库导出了所有`(rnrs base (6))`绑定以及上述其他库的绑定，但不包括`(rnrs eval (6))`，`(rnrs mutable-pairs (6))`，`(rnrs mutable-strings (6))`和`(rnrs r5rs (6))`。
- en: Although each of these libraries has the version `(6)`, references to them can
    and in most cases should leave the version out, e.g., the composite library should
    be referenced simply as `(rnrs)`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些库的版本都是`(6)`，但对它们的引用可以并且在大多数情况下应该省略版本，例如，复合库应该简单地被引用为`(rnrs)`。
- en: Section 10.2\. Defining New Libraries
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第10.2节。定义新库
- en: New libraries are defined with the `library` form, which has the following syntax.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 新库使用具有以下语法的`library`形式定义。
- en: '`(library *library-name*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library *library-name*'
- en: (export *export-spec* ...)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: (export *export-spec* ...)
- en: (import *import-spec* ...)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: (import *import-spec* ...)
- en: '*library-body*)`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*library-body*)`'
- en: 'A `*library-name*` specifies the name and possibly version by which the library
    is identified by the `import` form of another library or top-level program. It
    also serves as kind of path that the implementation uses to locate the library,
    via some implementation-specific process, whenever it needs to be loaded. A `*library-name*`
    has one of the following two forms:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`*library-name*`指定了库的名称和可能的版本，由另一个库或顶层程序的`import`形式识别。它还作为一种路径，实现在需要加载库时通过某种特定于实现的过程定位库。`*library-name*`具有以下两种形式之一：'
- en: '`(*identifier* *identifier* ...)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*标识符* *标识符* ...)'
- en: (*identifier* *identifier* ... *version*)`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (*标识符* *标识符* ... *版本*)`
- en: 'where `*version*` has the following form:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `*版本*` 具有以下形式：
- en: '`(*subversion* ...)`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*子版本* ...)`'
- en: and each `*subversion*` represents an exact nonnegative integer. A library name
    with no `*version*` is treated the same as a library name with the empty `*version*`
    `()`. For example, `(list-tools setops)` and `(list-tools setops ())` are equivalent
    and specify a library name with no version, while `(list-tools setops (1 2))`
    specifies a versioned library name, which can be thought of as Version 1.2 of
    the `(list-tools setops)` library.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `*子版本*` 代表一个确切的非负整数。一个没有 `*版本*` 的库名称被视为具有空 `*版本*` `()` 的库名称。例如，`(list-tools setops)`
    和 `(list-tools setops ())` 是等效的，指定了一个没有版本的库名称，而 `(list-tools setops (1 2))` 指定了一个带版本的库名称，可以将其视为
    `(list-tools setops)` 库的版本 1.2。
- en: 'The `export` subform names the exports and, optionally, the names by which
    they should be known outside of the library. Each `*export-spec*` takes one of
    the following two forms:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`export` 子形式命名了导出项，以及可选地指定它们在库外应该被知道的名称。每个 `*导出规范*` 采用以下两种形式之一：'
- en: '`*identifier*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`*标识符*'
- en: (rename (*internal-name* *export-name*) ...)`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: (重命名 (*内部名称* *导出名称*) ...)`
- en: where each `*internal-name*` and `*export-name*` is an identifier. The first
    form names a single export, `*identifier*`, whose export name is the same as its
    internal name. The second names a set of exports, each of whose export name is
    given explicitly and may differ from its internal name.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其中每个 `*内部名称*` 和 `*导出名称*` 都是标识符。第一种形式命名了一个单一的导出项 `*标识符*`，其导出名称与其内部名称相同。第二种形式命名了一组导出项，每个导出项的导出名称都明确给出，可能与其内部名称不同。
- en: 'The `import` subform names the other libraries upon which the new library depends
    and, possibly, the set of identifiers to be imported and the names by which they
    should be known inside the new library. It may also specify when the bindings
    should be made available for implementations that require such information. Each
    `*import-spec*` takes one of the following two forms:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 子形式命名了新库依赖的其他库，可能还指定要导入的标识符集以及它们在新库中应该被知道的名称。它还可以指定实现需要这些信息时应该何时使绑定可用。每个
    `*导入规范*` 采用以下两种形式之一：'
- en: '`*import-set*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`*导入集*'
- en: (for *import-set* *import-level* ...)`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: (对于 *导入集* *导入级别* ...)`
- en: 'where `*import-level*` is one of the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `*导入级别*` 是以下之一：
- en: '`run'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`运行'
- en: expand
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展
- en: (meta *level*)`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: (meta *级别*)`
- en: and `*level*` represents an exact integer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `*级别*` 代表一个确切的整数。
- en: The `for` syntax declares when the imported bindings might be used by the importing
    library and thus when the implementation must make the bindings available. `run`
    and `(meta 0)` are equivalent and specify that the bindings imported from a library
    might be referenced by the run-time expressions (`define` right-hand-side expressions
    and initialization expressions) of the importing library. `expand` and `(meta 1)`
    are equivalent and specify that the bindings imported from a library might be
    referenced by the transformer expressions (`define-syntax`, `let-syntax`, or `letrec-syntax`
    right-hand-side expressions) of the importing library. `(meta 2)` specifies that
    the bindings imported from a library might be referenced by a transformer expression
    that appears within a transformer expression of the importing library, and so
    on for higher meta levels. Negative meta levels may also be specified and are
    needed in certain circumstances when a transformer expands into the transformer
    for another keyword binding used at a lower meta level.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 语法声明了导入的绑定何时可能被导入库使用，因此实现必须使绑定可用。 `run` 和 `(meta 0)` 是等效的，指定了从库中导入的绑定可能被导入库的运行时表达式（`define`
    右侧表达式和初始化表达式）引用。 `expand` 和 `(meta 1)` 是等效的，指定了从库中导入的绑定可能被导入库的转换器表达式（`define-syntax`、`let-syntax`
    或 `letrec-syntax` 右侧表达式）引用。 `(meta 2)` 指定了从库中导入的绑定可能被引用导入库的转换器表达式中的转换器表达式，以此类推，适用于更高的元级别。在某些情况下，当一个转换器扩展为另一个关键字绑定的转换器时，可能还需要指定负元级别。'
- en: A library export may have a non-zero *export* meta level, in which case the
    effective import level is the sum of the level specified by `for` and the export
    level. The exports of each standard library except `(rnrs base)` and `(rnrs)`
    have export level zero. For `(rnrs base)`, all exports have export level zero
    except for `syntax-rules`, `identifier-syntax`, and their auxiliary keywords `_`,
    `...`, and `set!`. `set!` has export levels zero and one, while the others have
    export level one. All exports of the `(rnrs)` library have export levels zero
    and one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个库导出可能具有非零的 *export* 元级别，此时有效的导入级别是由 `for` 指定的级别和导出级别的总和。除了 `(rnrs base)` 和
    `(rnrs)` 之外的每个标准库的导出级别为零。对于 `(rnrs base)`，所有导出的元级别为零，除了 `syntax-rules`、`identifier-syntax`
    和它们的辅助关键字 `_`、`...` 和 `set!`。`set!` 的导出级别为零和一，而其他的导出级别为一。`(rnrs)` 库的所有导出级别为零和一。
- en: It can be difficult for the programmer to specify the import levels that allow
    a library or top-level program to compile or run properly. Moreover, it is often
    impossible to cause a library's bindings to be made available when they are needed
    without causing them to be made available in some cases when they are not needed.
    For example, it is not possible to say that the run-time bindings of a library
    A are needed when a library B is expanded without also having the run-time bindings
    of A made available when code importing B is expanded. Making bindings available
    involves executing the code for the right-hand sides of the bindings and possibly
    executing initialization expressions as well, so the inability to specify when
    bindings are needed precisely can add both compile- and run-time overhead to a
    program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员来说，很难指定允许库或顶层程序正确编译或运行的导入级别。此外，通常无法在需要时使库的绑定可用，而在不需要时也使其可用。例如，无法说在扩展库B时需要库A的运行时绑定，而不在扩展导入B的代码时也使A的运行时绑定可用。使绑定可用涉及执行绑定的右侧代码以及可能执行初始化表达式，因此无法准确指定何时需要绑定可能会给程序增加编译和运行时开销。
- en: Because of this, implementations are permitted to ignore export levels and the
    `for` wrapper on an `*import-set*` and instead automatically determine, while
    expanding an importing library or top-level program, when an imported library's
    bindings must be made available, based on where references to the imported library's
    exports actually appear. When using such an implementation, the `for` wrapper
    need never be used, i.e., all `*import-spec*`s can be `*import-set*`s. If code
    is intended for use with systems that do not automatically determine when a library's
    bindings must be made available, however, the `for` must be used if the importing
    library's bindings would not otherwise be available at the right time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实现允许忽略导出级别和 `*import-set*` 上的 `for` 包装器，并在扩展导入库或顶层程序时自动确定导入库的绑定何时必须可用，这取决于导入库的导出实际出现的位置。在使用这种实现时，永远不需要使用
    `for` 包装器，即所有 `*import-spec*` 都可以是 `*import-set*`。然而，如果代码打算与不自动确定库的绑定何时必须可用的系统一起使用，则在导入库的绑定在正确时间不可用时必须使用
    `for`。
- en: 'An `*import-set*` takes one of the following forms:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `*import-set*` 可以采用以下形式：
- en: '`*library-spec*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`*library-spec*'
- en: (only *import-set* *identifier* ...)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: (只有 *import-set* *identifier* ...)
- en: (except *import-set* *identifier* ...)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: (除了 *import-set* *identifier* ...)
- en: (prefix *import-set* *prefix*)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: (prefix *import-set* *prefix*)
- en: (rename *import-set* (*import-name* *internal-name*) ...)`
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: (rename *import-set* (*import-name* *internal-name*) ...)
- en: where `*prefix*`, `*import-name*`, and `*internal-name*` are identifiers. An
    `*import-set*` is a recursive specification of the identifiers to be imported
    from a library and possibly the names by which they should be known within the
    importing library. At the base of the recursive structure must sit a `*library-spec*`,
    which identifies a library and imports all of the identifiers from that library.
    An `only` wrapper restricts the imported identifiers of the enclosed `*import-set*`
    to the ones listed, an `except` wrapper restricts the imported identifiers of
    the enclosed `*import-set*` to those not listed, a `prefix` wrapper adds a prefix
    to each of the imported identifiers of the enclosed `*import-set*`, and a `rename`
    wrapper specifies internal names for selected identifiers of the enclosed `*import-set*`,
    while leaving the names of the other imports alone. So, for example, the `*import-set*`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`*前缀*`、`*导入名称*`和`*内部名称*`是标识符。一个`*导入集*`是从库中导入的标识符的递归规范，可能还包括这些标识符在导入库内部应该使用的名称。在递归结构的底部必须有一个`*库规范*`，它标识一个库并从该库中导入所有标识符。一个`only`包装器将封闭的`*导入集*`的导入标识符限制为列出的标识符，一个`except`包装器将封闭的`*导入集*`的导入标识符限制为未列出的标识符，一个`prefix`包装器为封闭的`*导入集*`的每个导入标识符添加前缀，一个`rename`包装器为封闭的`*导入集*`的选定标识符指定内部名称，同时保持其他导入的名称不变。因此，例如，`*导入集*`
- en: '`(prefix'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`(prefix'
- en: (only
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: (only
- en: (rename (list-tools setops) (difference diff))
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (rename (list-tools setops) (difference diff))
- en: union
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: union
- en: diff)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: diff)
- en: set:)`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: set:)`
- en: imports only `union` and `difference` from the `(list-tools setops)` library,
    renames `difference` to `diff` while leaving `union` alone, and adds the prefix
    `set:` to the two names so that the names by which the two imports are known inside
    the importing library are `set:union` and `set:diff`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 仅从`(list-tools setops)`库中导入`union`和`difference`，将`difference`重命名为`diff`，而保留`union`不变，并为这两个名称添加前缀`set:`，以便在导入库内部使用这两个导入的名称为`set:union`和`set:diff`。
- en: 'A `*library-spec*` takes one of the following forms:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`*库规范*`可以采用以下形式之一：
- en: '`*library-reference*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`*库引用*'
- en: (library *library-reference*)`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: (library *库引用*)`
- en: 'where a `*library-reference*` is in either of the following two forms:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个`*库引用*`可以是以下两种形式之一：
- en: '`(*identifier* *identifier* ...)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*标识符* *标识符* ...)'
- en: (*identifier* *identifier* ... *version-reference*)`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (*标识符* *标识符* ... *版本引用*)`
- en: Enclosing a `*library-reference*` in a `library` wrapper is necessary when the
    first identifier of the `*library-reference*` is `for`, `library`, `only`, `except`,
    `prefix`, or `rename`, to distinguish it from an `*import-spec*` or `*import-set*`
    identified by one of these keywords.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将`*库引用*`放在`library`包装器中是必要的，当`*库引用*`的第一个标识符是`for`、`library`、`only`、`except`、`prefix`或`rename`时，以区别于由这些关键字标识的`*导入规范*`或`*导入集*`。
- en: 'A `*version-reference*` identifies a particular version of the library or a
    set of possible versions. A `*version-reference*` has one of the following forms:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`*版本引用*`标识库的特定版本或一组可能的版本。一个`*版本引用*`可以采用以下形式之一：
- en: '`(*subversion-reference[1]* ... *subversion-reference[n]*)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*子版本引用[1]* ... *子版本引用[n]*)'
- en: (and *version-reference* ...)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: (and *版本引用* ...)
- en: (or *version-reference* ...)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: (or *版本引用* ...)
- en: (not *version-reference*)`
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (not *版本引用*)`
- en: A `*version-reference*` of the first form matches a `*version*` with at least
    *n* elements if each `*subversion-reference*` matches `*version*`'s corresponding
    `*subversion*`. An `and` `*version-reference*` form matches a `*version*` if each
    of its `*version-reference*` subforms matches `*version*`. An `or` `*version-reference*`
    form matches a `*version*` if any of its `*version-reference*` subforms matches
    `*version*`. A `not` `*version-reference*` form matches a `*version*` if its `*version-reference*`
    subform does not match `*version*`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式的`*版本引用*`匹配具有至少*n*个元素的`*版本*`，如果每个`*子版本引用*`匹配`*版本*`的相应`*子版本*`。`and` `*版本引用*`形式匹配`*版本*`，如果它的每个`*版本引用*`子形式都匹配`*版本*`。`or`
    `*版本引用*`形式匹配`*版本*`，如果它的任何`*版本引用*`子形式都匹配`*版本*`。`not` `*版本引用*`形式匹配`*版本*`，如果它的`*版本引用*`子形式不匹配`*版本*`。
- en: 'A `*subversion-reference*` takes one of the following forms:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`*子版本引用*`可以采用以下形式之一：
- en: '`*subversion*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`*子版本*'
- en: (>= *subversion*)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: (>= *子版本*)
- en: (<= *subversion*)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: (<= *子版本*)
- en: (and *subversion-reference* ...)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: (和 *子版本引用* ...)
- en: (or *subversion-reference* ...)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: (or *子版本引用* ...)
- en: (not *subversion-reference*)`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: (not *子版本引用*)`
- en: A `*subversion-reference*` of the first form matches a `*subversion*` if it
    is identical to it. A `>=` `*subversion-reference*` matches a `*version*`'s `*subversion*`
    if the `*version*`'s `*subversion*` is greater than or equal to the `*subversion*`
    appearing within the `>=` form. Similarly, a `<=` `*subversion-reference*` matches
    a `*version*`'s `*subversion*` if the `*version*`'s `*subversion*` is less than
    or equal to the `*subversion*` appearing within the `>=` form. An `and` `*subversion-reference*`
    form matches a `*version*`'s `*subversion*` if each of its `*subversion-reference*`
    subforms matches the `*version*`'s `*subversion*`. An `or` `*subversion-reference*`
    matches a `*version*`'s `*subversion*` if any of its `*subversion-reference*`
    subforms match the `*version*`'s `*subversion*`. A `not` `*subversion-reference*`
    matches a `*version*`'s `*subversion*` if its `*subversion-reference*` subform
    does not match the `*version*`'s `*subversion*`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式的`*subversion-reference*`与`*subversion*`匹配，如果它与之相同。`>=` `*subversion-reference*`与`*version*`的`*subversion*`匹配，如果`*version*`的`*subversion*`大于或等于出现在`>=`形式中的`*subversion*`。类似地，`<=`
    `*subversion-reference*`与`*version*`的`*subversion*`匹配，如果`*version*`的`*subversion*`小于或等于出现在`>=`形式中的`*subversion*`。`and`
    `*subversion-reference*`形式与`*version*`的`*subversion*`匹配，如果它的每个`*subversion-reference*`子形式都与`*version*`的`*subversion*`匹配。`or`
    `*subversion-reference*`与`*version*`的`*subversion*`匹配，如果它的任何`*subversion-reference*`子形式与`*version*`的`*subversion*`匹配。`not`
    `*subversion-reference*`与`*version*`的`*subversion*`匹配，如果它的`*subversion-reference*`子形式不与`*version*`的`*subversion*`匹配。
- en: For example, if two versions of a library are available, one with version `(1 2)`
    and the other with version `(1 3 1)`, the version references `()` and `(1)` match
    both, `(1 2)` matches the first but not the second, `(1 3)` matches the second
    but not the first, `(1 (>= 2))` matches both, and `(and (1 (>= 3)) (not (1 3 1)))`
    matches neither.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果有两个版本的库可用，一个版本为`(1 2)`，另一个版本为`(1 3 1)`，则版本引用`()`和`(1)`都匹配，`(1 2)`匹配第一个但不匹配第二个，`(1 3)`匹配第二个但不匹配第一个，`(1 (>= 2))`匹配两个，`(and (1 (>= 3)) (not (1 3 1)))`两者都不匹配。
- en: When a library reference identifies more than one available library, one of
    the available libraries is selected in some implementation-dependent manner.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当库引用标识多个可用库时，某些实现相关的方式会选择其中一个可用库。
- en: Libraries and top-level programs should not, directly or indirectly, specify
    the import of two libraries that have the same names but different versions. To
    avoid problems such as incompatible types and replicated state, implementations
    are encouraged, though not required, to prohibit programs from importing two versions
    of the same library.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 库和顶层程序不应直接或间接指定导入具有相同名称但不同版本的两个库。为了避免诸如不兼容类型和复制状态之类的问题，鼓励实现，尽管不是必需的，禁止程序导入同一库的两个版本。
- en: A `*library-body*` contains definitions of exported identifiers, definitions
    of identifiers not intended for export, and initialization expressions. It consists
    of a (possibly empty) sequence of definitions followed by a (possibly empty) sequence
    of initialization expressions. When `begin`, `let-syntax`, or `letrec-syntax`
    forms occur in a library body prior to the first expression, they are spliced
    into the body. Any body form may be produced by a syntactic extension, including
    definitions, the splicing forms just mentioned, or initialization expressions.
    A library body is expanded in the same manner as a `lambda` or other body (page [292](syntax.html#body-expansion)),
    and it expands into the equivalent of a `letrec*` form so that the definitions
    and initialization forms in the body are evaluated from left to right.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`*library-body*`包含导出标识符的定义，不打算导出的标识符的定义以及初始化表达式。它由一系列（可能为空）的定义后跟一系列（可能为空）的初始化表达式组成。当`begin`、`let-syntax`或`letrec-syntax`形式在第一个表达式之前出现在库体中时，它们会被插入到体中。任何体形式都可以由语法扩展生成，包括定义，刚才提到的插入形式或初始化表达式。库体的扩展方式与`lambda`或其他体（第[292](syntax.html#body-expansion)页）相同，并且它扩展为等效的`letrec*`形式，以便库体中的定义和初始化形式从左到右进行评估。'
- en: Each of the exports listed in a library's `export` form must either be imported
    from another library or defined within the `*library-body*`, in either case with
    the internal rather than the export name, if the two differ.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库的`export`表单中列出的导出必须从另一个库中导入或在`*library-body*`中定义，无论哪种情况都要使用内部名称而不是导出名称，如果两者不同。
- en: Each identifier imported into or defined within a library must have exactly
    one binding. If imported into a library, it must not be defined in the library
    body, and if defined in the library body, it must be defined only once. If imported
    from two libraries, it must have the same binding in both cases, which can happen
    only if the binding originates in one of the two libraries and is reexported by
    the other or if the binding originates in a third library and is reexported by
    both.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 导入到库中或在库内定义的每个标识符必须有且仅有一个绑定。如果导入到库中，则不能在库体中定义，如果在库体中定义，则必须只定义一次。如果从两个库中导入，它必须在两种情况下具有相同的绑定，这只有在绑定源自两个库之一并被另一个重新导出，或者绑定源自第三个库并被两个库都重新导出时才会发生。
- en: The identifiers defined within a library and not exported by the library are
    not visible in code that appears outside of the library. A syntactic extension
    defined within a library may, however, expand into a reference to such an identifier,
    so that the expanded code does contain a reference to the identifier; this is
    referred to as an *indirect export*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在库内定义但未被库导出的标识符在出现在库外的代码中是不可见的。然而，在库内定义的语法扩展可能会扩展为对这种标识符的引用，以便扩展的代码确实包含对该标识符的引用；这被称为*间接导出*。
- en: The exported variables of a library are *immutable* both inside the library
    and outside, whether they are explicitly or implicitly exported. It is a syntax
    violation if an explicitly exported variable appears on the left-hand side of
    a `set!` expression within or outside of the exporting library. It is also a syntax
    violation if any other variable defined by a library appears on the left-hand
    side of a `set!` expression and is indirectly exported.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个库的导出变量在库内部和外部都是*不可变*的，无论它们是显式还是隐式导出的。如果一个显式导出的变量出现在导出库内或外的`set!`表达式的左侧，这是语法违例。如果由库定义的任何其他变量出现在`set!`表达式的左侧并且是间接导出的，也是语法违例。
- en: Libraries are loaded and the code contained within them evaluated on an "as
    needed" basis by the implementation, as determined by the import relationships
    among libraries. A library's transformer expressions (the expressions on the right-hand
    sides of a library body's `define-syntax` forms) may be evaluated at different
    times from the library's body expressions (the expressions on the right-hand side
    of the body's `define` forms, plus initialization expressions). At a minimum,
    the transformer expressions of a library must be evaluated when (if not before)
    a reference to one of the library's exported keywords is found while expanding
    another library or top-level program, and the body expressions must be evaluated
    when (if not before) a reference to one of the library's exported variables is
    evaluated, which may occur either when a program using the library is run or when
    another library or top-level program is being expanded, if the reference is evaluated
    by a transformer called during the expansion process. An implementation may evaluate
    a library's transformer and body expressions as many times as it pleases in the
    process of expanding other libraries. In particular, it may evaluate the expressions
    zero times if they are not actually needed, exactly one time, or one time for
    each meta level of the expansion. It is generally a bad idea for the evaluation
    of a library's transformer or body expressions to involve externally visible side
    effects, e.g., popping up a window, since the time or times at which these side
    effects occur is unspecified. Localized effects that affect only the library's
    initialization, e.g., to create a table used by the library, are generally okay.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 库是按需加载的，其中包含的代码由实现根据库之间的导入关系确定的。一个库的变换器表达式（库体的`define-syntax`形式右侧的表达式）可能在不同的时间被评估，与库体表达式（库体的`define`形式右侧的表达式，加上初始化表达式）不同。至少，当（如果不是在之前）在扩展另一个库或顶层程序时发现对库导出的关键字之一的引用时，必须评估库的变换器表达式，而当（如果不是在之前）评估库导出的变量之一的引用时，必须评估库的体表达式，这可能发生在运行使用库的程序时，或者在扩展另一个库或顶层程序时，如果引用是由在扩展过程中调用的变换器评估的。实现可以在扩展其他库的过程中随意评估库的变换器和体表达式多次。特别地，如果实际上不需要，它可以零次评估表达式，恰好一次，或者对扩展的每个元级别评估一次。通常，库的变换器或体表达式的评估涉及外部可见的副作用是一个坏主意，例如弹出一个窗口，因为这些副作用发生的时间是不确定的。只影响库初始化的局部效果，例如创建库使用的表，通常是可以接受的。
- en: Examples are given in Section [10.4](libraries.html#g146).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例见第[10.4](libraries.html#g146)节。
- en: Section 10.3\. Top-Level Programs
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第10.3节。顶层程序
- en: 'A top-level program is not a syntactic form per se but rather a set of forms
    that are usually delimited only by file boundaries. Top-level programs can be
    thought of as library forms without the `library` wrapper, library name, and export
    form. The other difference is that definitions and expressions can be intermixed
    within the body of a top-level program but not within the body of a library. Thus
    the syntax of a top-level program is, simply, an `import` form followed by a sequence
    of definitions and expressions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层程序本身不是一个语法形式，而是一组通常仅由文件边界限定的形式。顶层程序可以被视为没有`library`包装器、库名称和导出形式的库形式。另一个区别是定义和表达式可以在顶层程序的主体中交错，但不能在库的主体中交错。因此，顶层程序的语法就是一个`import`形式，后面跟着一系列的定义和表达式：
- en: '`(import *import-spec* ...)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`(导入 *import-spec* ...)'
- en: '*definition-or-expression*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*定义或表达式*'
- en: '...`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '...`'
- en: An expression that appears within a top-level program body before one or more
    definitions is treated as if it appeared on the right-hand side of a definition
    for a dummy variable that is not visible anywhere within the program.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在一个或多个定义之前的顶层程序主体中的表达式被视为出现在一个虚拟变量的定义的右侧，该虚拟变量在程序中任何地方都不可见。
- en: '**procedure**: `(command-line)`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(command-line)`'
- en: '**returns:** a list of strings representing command-line arguments'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 代表命令行参数的字符串列表'
- en: '**libraries:** `(rnrs programs)`, `(rnrs)`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs programs)`, `(rnrs)`'
- en: This procedure may be used within a top-level program to obtain a list of the
    command-line arguments passed to the program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以在顶层程序中使用，以获取传递给程序的命令行参数列表。
- en: '**procedure**: `(exit)`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(exit)`'
- en: '**procedure**: `(exit *obj*)`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程**: `(exit *obj*)`'
- en: '**returns:** does not return'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回:** 不返回'
- en: '**libraries:** `(rnrs programs)`, `(rnrs)`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**库:** `(rnrs programs)`, `(rnrs)`'
- en: This procedure may be used to exit from a top-level program to the operating
    system. If no `*obj*` is given, the exit value returned to the operating system
    should indicate a normal exit. If `*obj*` is false, the exit value returned to
    the operating system should indicate an abnormal exit. Otherwise, `*obj*` is translated
    into an exit value as appropriate for the operating system.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可以用于从顶层程序退出到操作系统。如果没有给出`*obj*`，则返回给操作系统的退出值应指示正常退出。如果`*obj*`为false，则返回给操作系统的退出值应指示异常退出。否则，`*obj*`将根据操作系统适当地转换为退出值。
- en: Section 10.4\. Examples
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第10.4节。示例
- en: The example below demonstrates several features of the `library` syntax. It
    defines "Version 1" of the `(list-tools setops)` library, which exports two keywords
    and several variables. The library imports the `(rnrs base)` library, which provides
    everything it needs except the `member` procedure, which it imports from `(rnrs lists)`.
    Most of the variables exported by the library are bound to procedures, which is
    typical.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例演示了`library`语法的几个特点。它定义了“(list-tools setops)”库的“版本1”，导出了两个关键字和几个变量。该库导入了`(rnrs
    base)`库，它提供了除了`member`过程之外的所有需要的内容，该过程从`(rnrs lists)`导入。该库导出的大多数变量都绑定到过程，这是典型的。
- en: The syntactic extension `set` expands into a reference to the variable `list->set`,
    and `member?` similarly expands into a reference to the variable `$member?`. While
    `list->set` is explicitly exported, `$member?` is not. This makes `$member?` an
    indirect export. The procedure `u-d-help` is not explicitly exported, and since
    neither of the exported syntactic extensions expand into references to `u-d-help`,
    it is not indirectly exported either. This means it could be assigned, but it
    is not assigned in this example.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 语法扩展`set`扩展为对变量`list->set`的引用，而`member?`类似地扩展为对变量`$member?`的引用。虽然`list->set`被明确导出，但`$member?`没有。这使得`$member?`成为一种间接导出。过程`u-d-help`没有被明确导出，而且由于导出的语法扩展都没有扩展为对`u-d-help`的引用，它也不是间接导出的。这意味着它可以被赋值，但在这个例子中没有被赋值。
- en: '`(library (list-tools setops (1))'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (list-tools setops (1))'
- en: (export set empty-set empty-set? list->set set->list
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: (导出 set empty-set empty-set? list->set set->list
- en: union intersection difference member?)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: union intersection difference member?)
- en: (import (rnrs base) (only (rnrs lists) member))
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: (导入(rnrs base) (only (rnrs lists) member))
- en: (define-syntax set
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定义语法`set`
- en: (syntax-rules ()
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ x ...)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ x ...)'
- en: (list->set (list x ...))]))
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: (list->set (list x ...))]))
- en: (define empty-set '())
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: (define empty-set '())
- en: (define empty-set? null?)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: (define empty-set? null?)
- en: (define list->set
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: (define list->set
- en: (lambda (ls)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (ls)
- en: (cond
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: (条件
- en: '[(null? ls) ''()]'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? ls) ''()]'
- en: '[(member (car ls) (cdr ls)) (list->set (cdr ls))]'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[(member (car ls) (cdr ls)) (list->set (cdr ls))]'
- en: '[else (cons (car ls) (list->set (cdr ls)))])))'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (cons (car ls) (list->set (cdr ls)))])))'
- en: (define set->list (lambda (set) set))
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: (define set->list (lambda (set) set))
- en: (define u-d-help
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: (define u-d-help
- en: (lambda (s1 s2 ans)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s1 s2 ans)
- en: (let f ([s1 s1])
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: (let f ([s1 s1])
- en: (cond
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? s1) ans]'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? s1) ans]'
- en: '[(member? (car s1) s2) (f (cdr s1))]'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[(member? (car s1) s2) (f (cdr s1))]'
- en: '[else (cons (car s1) (f (cdr s1)))]))))'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (cons (car s1) (f (cdr s1)))]))))'
- en: (define union
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: (define union
- en: (lambda (s1 s2)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s1 s2)
- en: (u-d-help s1 s2 s2)))
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: (u-d-help s1 s2 s2)))
- en: (define intersection
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: (define intersection
- en: (lambda (s1 s2)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s1 s2)
- en: (cond
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: (cond
- en: '[(null? s1) ''()]'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[(null? s1) ''()]'
- en: '[(member? (car s1) s2)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[(member? (car s1) s2)'
- en: (cons (car s1) (intersection (cdr s1) s2))]
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: (cons (car s1) (intersection (cdr s1) s2))]
- en: '[else (intersection (cdr s1) s2)])))'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[else (intersection (cdr s1) s2)])))'
- en: (define difference
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: (define difference
- en: (lambda (s1 s2)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (s1 s2)
- en: (u-d-help s1 s2 '())))
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: (u-d-help s1 s2 '())))
- en: (define member-help?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (define member-help?
- en: (lambda (x s)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x s)
- en: (and (member x s) #t)))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: (and (member x s) #t)))
- en: (define-syntax member?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax member?
- en: (syntax-rules ()
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ elt-expr set-expr)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ elt-expr set-expr)'
- en: (let ([x elt-expr] [s set-expr])
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (let ([x elt-expr] [s set-expr])
- en: (and (not (null? s)) (member-help? x s)))])))`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (and (not (null? s)) (member-help? x s)))])))`
- en: The next library, `(more-setops)`, defines a few additional set operations in
    terms of the `(list-tools setops)` operations. No version is included in the library
    reference to `(list-tools setops)`; this is equivalent to an empty version reference,
    which matches any version. The `quoted-set` keyword is interesting because its
    transformer references `list->set` from `(list-tools setops)` at expansion time.
    As a result, if another library or top-level program that imports from `(more-setops)`
    references `quoted-set`, the run-time expressions of the `(list-tools setops)`
    library will have to be evaluated when the other library or top-level program
    is expanded. On the other hand, the run-time expressions of the `(list-tools setops)`
    library need not be evaluated when the `(more-setops)` library is itself expanded.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个库 `(more-setops)` 定义了一些额外的集合操作，以 `(list-tools setops)` 操作为基础。库参考中没有版本信息 `(list-tools setops)`；这相当于一个空版本引用，可以匹配任何版本。`quoted-set`
    关键字很有趣，因为其转换器在扩展时引用了 `(list-tools setops)` 中的 `list->set`。因此，如果另一个库或顶层程序导入了 `(more-setops)`
    并引用了 `quoted-set`，那么在扩展其他库或顶层程序时，将不得不评估 `(list-tools setops)` 库的运行时表达式。另一方面，当
    `(more-setops)` 库自身被扩展时，无需评估 `(list-tools setops)` 库的运行时表达式。
- en: '`(library (more-setops)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`(library (more-setops)'
- en: (export quoted-set set-cons set-remove)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: (export quoted-set set-cons set-remove)
- en: (import (list-tools setops) (rnrs base) (rnrs syntax-case))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (import (list-tools setops) (rnrs base) (rnrs syntax-case))
- en: (define-syntax quoted-set
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax quoted-set
- en: (lambda (x)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x)
- en: (syntax-case x ()
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-case x ()
- en: '[(k elt ...)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[(k elt ...)'
- en: '#`(quote'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '#`(quote'
- en: '#,(datum->syntax #''k'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#,(datum->syntax #''k'
- en: (list->set
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: (list->set
- en: (syntax->datum #'(elt ...)))))])))
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax->datum #'(elt ...)))))])))
- en: (define set-cons
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: (define set-cons
- en: (lambda (opt optset)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (opt optset)
- en: (union (set opt) optset)))
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: (union (set opt) optset)))
- en: (define set-remove
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: (define set-remove
- en: (lambda (opt optset)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (opt optset)
- en: (difference optset (set opt)))))`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: (difference optset (set opt)))))`
- en: 'If the implementation does not automatically infer when bindings need to be
    made available, the `import` form in the `(more-setops)` library must be modified
    to specify at which meta levels the bindings it imports are used via the `for`
    `*import-spec*` syntax as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现不会自动推断何时需要进行绑定，那么 `(more-setops)` 库中的 `import` 表单必须修改，以指定它导入的绑定在哪些元级别上使用，通过
    `for` `*import-spec*` 语法如下所示：
- en: '`(import'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`(import'
- en: (for (list-tools setops) expand run)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: (for (list-tools setops) expand run)
- en: (for (rnrs base) expand run)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: (for (rnrs base) expand run)
- en: (for (rnrs syntax-case) expand))`
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: (for (rnrs syntax-case) expand))`
- en: To complete the example, the short top-level program below exercises several
    of the `(list-tools setops)` and `(more-setops)` exports.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成示例，下面是一个简短的顶层程序，演示了 `(list-tools setops)` 和 `(more-setops)` 导出的几个操作。
- en: '`(import (list-tools setops) (more-setops) (rnrs))'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`(import (list-tools setops) (more-setops) (rnrs))'
- en: (define-syntax pr
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: (define-syntax pr
- en: (syntax-rules ()
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: (syntax-rules ()
- en: '[(_ obj)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[(_ obj)'
- en: (begin
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: (begin
- en: (write 'obj)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: (write 'obj)
- en: (display " ;=> ")
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: (display " ;=> ")
- en: (write obj)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: (write obj)
- en: (newline))]))
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: (newline))]))
- en: (define get-set1
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: (define get-set1
- en: (lambda ()
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda ()
- en: (quoted-set a b c d)))
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: (quoted-set a b c d)))
- en: (define set1 (get-set1))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: (define set1 (get-set1))
- en: (define set2 (quoted-set a c e))
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: (define set2 (quoted-set a c e))
- en: (pr (list set1 set2))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (list set1 set2))
- en: (pr (eq? (get-set1) (get-set1)))
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (eq? (get-set1) (get-set1)))
- en: (pr (eq? (get-set1) (set 'a 'b 'c 'd)))
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (eq? (get-set1) (set 'a 'b 'c 'd)))
- en: (pr (union set1 set2))
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (union set1 set2))
- en: (pr (intersection set1 set2))
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (intersection set1 set2))
- en: (pr (difference set1 set2))
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (difference set1 set2))
- en: (pr (set-cons 'a set2))
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (set-cons 'a set2))
- en: (pr (set-cons 'b set2))
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (set-cons 'b set2))
- en: (pr (set-remove 'a set2))`
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (pr (set-remove 'a set2))`
- en: What running this program should print is left as an exercise for the reader.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序应该打印出什么留给读者作为一个练习。
- en: Additional library and top-level program examples are given in Chapter [12](examples.html#g151).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 附加的库和顶层程序示例在第[12](examples.html#g151)章中给出。
