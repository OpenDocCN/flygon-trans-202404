["```\n/// ExprAST - Base class for all expression nodes.\nclass ExprAST {\npublic:\n  virtual ~ExprAST() {}\n};\n\n/// NumberExprAST - Expression class for numeric literals like \"1.0\".\nclass NumberExprAST : public ExprAST {\n  double Val;\npublic:\n  NumberExprAST(double val) : Val(val) {}\n}; \n```", "```\n/// VariableExprAST - Expression class for referencing a variable, like \"a\".\nclass VariableExprAST : public ExprAST {\n  std::string Name;\npublic:\n  VariableExprAST(const std::string &name) : Name(name) {}\n};\n\n/// BinaryExprAST - Expression class for a binary operator.\nclass BinaryExprAST : public ExprAST {\n  char Op;\n  ExprAST *LHS, *RHS;\npublic:\n  BinaryExprAST(char op, ExprAST *lhs, ExprAST *rhs)\n    : Op(op), LHS(lhs), RHS(rhs) {}\n};\n\n/// CallExprAST - Expression class for function calls.\nclass CallExprAST : public ExprAST {\n  std::string Callee;\n  std::vector<ExprAST*> Args;\npublic:\n  CallExprAST(const std::string &callee, std::vector<ExprAST*> &args)\n    : Callee(callee), Args(args) {}\n}; \n```", "```\n/// PrototypeAST - This class represents the \"prototype\" for a function,\n/// which captures its name, and its argument names (thus implicitly the number\n/// of arguments the function takes).\nclass PrototypeAST {\n  std::string Name;\n  std::vector<std::string> Args;\npublic:\n  PrototypeAST(const std::string &name, const std::vector<std::string> &args)\n    : Name(name), Args(args) {}\n};\n\n/// FunctionAST - This class represents a function definition itself.\nclass FunctionAST {\n  PrototypeAST *Proto;\n  ExprAST *Body;\npublic:\n  FunctionAST(PrototypeAST *proto, ExprAST *body)\n    : Proto(proto), Body(body) {}\n}; \n```", "```\nExprAST *X = new VariableExprAST(\"x\");\nExprAST *Y = new VariableExprAST(\"y\");\nExprAST *Result = new BinaryExprAST('+', X, Y);\nIn order to do this, we'll start by defining some basic helper routines:\n\n/// CurTok/getNextToken - Provide a simple token buffer.  CurTok is the current\n/// token the parser is looking at.  getNextToken reads another token from the\n/// lexer and updates CurTok with its results.\nstatic int CurTok;\nstatic int getNextToken() {\n  return CurTok = gettok();\n} \n```", "```\n/// Error* - These are little helper functions for error handling.\nExprAST *Error(const char *Str) { fprintf(stderr, \"Error: %s\\n\", Str);return 0;}\nPrototypeAST *ErrorP(const char *Str) { Error(Str); return 0; }\nFunctionAST *ErrorF(const char *Str) { Error(Str); return 0; } \n```", "```\n/// numberexpr ::= number\nstatic ExprAST *ParseNumberExpr() {\n  ExprAST *Result = new NumberExprAST(NumVal);\n  getNextToken(); // consume the number\n  return Result;\n} \n```", "```\n/// parenexpr ::= '(' expression ')'\nstatic ExprAST *ParseParenExpr() {\n  getNextToken();  // eat (.\n  ExprAST *V = ParseExpression();\n  if (!V) return 0;\n\n  if (CurTok != ')')\n    return Error(\"expected ')'\");\n  getNextToken();  // eat ).\n  return V;\n} \n```", "```\n/// identifierexpr\n///   ::= identifier\n///   ::= identifier '(' expression* ')'\nstatic ExprAST *ParseIdentifierExpr() {\n  std::string IdName = IdentifierStr;\n\n  getNextToken();  // eat identifier.\n\n  if (CurTok != '(') // Simple variable ref.\n    return new VariableExprAST(IdName);\n\n  // Call.\n  getNextToken();  // eat (\n  std::vector<ExprAST*> Args;\n  if (CurTok != ')') {\n    while (1) {\n      ExprAST *Arg = ParseExpression();\n      if (!Arg) return 0;\n      Args.push_back(Arg);\n\n      if (CurTok == ')') break;\n\n      if (CurTok != ',')\n        return Error(\"Expected ')' or ',' in argument list\");\n      getNextToken();\n    }\n  }\n\n  // Eat the ')'.\n  getNextToken();\n\n  return new CallExprAST(IdName, Args);\n} \n```", "```\n/// primary\n///   ::= identifierexpr\n///   ::= numberexpr\n///   ::= parenexpr\nstatic ExprAST *ParsePrimary() {\n  switch (CurTok) {\n  default: return Error(\"unknown token when expecting an expression\");\n  case tok_identifier: return ParseIdentifierExpr();\n  case tok_number:     return ParseNumberExpr();\n  case '(':            return ParseParenExpr();\n  }\n} \n```", "```\n/// BinopPrecedence - This holds the precedence for each binary operator that is\n/// defined.\nstatic std::map<char, int> BinopPrecedence;\n\n/// GetTokPrecedence - Get the precedence of the pending binary operator token.\nstatic int GetTokPrecedence() {\n  if (!isascii(CurTok))\n    return -1;\n\n  // Make sure it's a declared binop.\n  int TokPrec = BinopPrecedence[CurTok];\n  if (TokPrec <= 0) return -1;\n  return TokPrec;\n}\n\nint main() {\n  // Install standard binary operators.\n  // 1 is lowest precedence.\n  BinopPrecedence['<'] = 10;\n  BinopPrecedence['+'] = 20;\n  BinopPrecedence['-'] = 20;\n  BinopPrecedence['*'] = 40;  // highest.\n  ...\n} \n```", "```\n/// expression\n///   ::= primary binoprhs\n///\nstatic ExprAST *ParseExpression() {\n  ExprAST *LHS = ParsePrimary();\n  if (!LHS) return 0;\n\n  return ParseBinOpRHS(0, LHS);\n} \n```", "```\n/// binoprhs\n///   ::= ('+' primary)*\nstatic ExprAST *ParseBinOpRHS(int ExprPrec, ExprAST *LHS) {\n  // If this is a binop, find its precedence.\n  while (1) {\n    int TokPrec = GetTokPrecedence();\n\n    // If this is a binop that binds at least as tightly as the current binop,\n    // consume it, otherwise we are done.\n    if (TokPrec < ExprPrec)\n      return LHS; \n```", "```\n// Okay, we know this is a binop.\nint BinOp = CurTok;\ngetNextToken();  // eat binop\n\n// Parse the primary expression after the binary operator.\nExprAST *RHS = ParsePrimary();\nif (!RHS) return 0; \n```", "```\n// If BinOp binds less tightly with RHS than the operator after RHS, let\n// the pending operator take RHS as its LHS.\nint NextPrec = GetTokPrecedence();\nif (TokPrec < NextPrec) { \n```", "```\n ... if body omitted ...\n    }\n\n    // Merge LHS/RHS.\n    LHS = new BinaryExprAST(BinOp, LHS, RHS);\n  }  // loop around to the top of the while loop.\n} \n```", "```\n // If BinOp binds less tightly with RHS than the operator after RHS, let\n    // the pending operator take RHS as its LHS.\n    int NextPrec = GetTokPrecedence();\n    if (TokPrec < NextPrec) {\n      RHS = ParseBinOpRHS(TokPrec+1, RHS);\n      if (RHS == 0) return 0;\n    }\n    // Merge LHS/RHS.\n    LHS = new BinaryExprAST(BinOp, LHS, RHS);\n  }  // loop around to the top of the while loop.\n} \n```", "```\n/// prototype\n///   ::= id '(' id* ')'\nstatic PrototypeAST *ParsePrototype() {\n  if (CurTok != tok_identifier)\n    return ErrorP(\"Expected function name in prototype\");\n\n  std::string FnName = IdentifierStr;\n  getNextToken();\n\n  if (CurTok != '(')\n    return ErrorP(\"Expected '(' in prototype\");\n\n  // Read the list of argument names.\n  std::vector<std::string> ArgNames;\n  while (getNextToken() == tok_identifier)\n    ArgNames.push_back(IdentifierStr);\n  if (CurTok != ')')\n    return ErrorP(\"Expected ')' in prototype\");\n\n  // success.\n  getNextToken();  // eat ')'.\n\n  return new PrototypeAST(FnName, ArgNames);\n} \n```", "```\n/// definition ::= 'def' prototype expression\nstatic FunctionAST *ParseDefinition() {\n  getNextToken();  // eat def.\n  PrototypeAST *Proto = ParsePrototype();\n  if (Proto == 0) return 0;\n\n  if (ExprAST *E = ParseExpression())\n    return new FunctionAST(Proto, E);\n  return 0;\n} \n```", "```\n/// external ::= 'extern' prototype\nstatic PrototypeAST *ParseExtern() {\n  getNextToken();  // eat extern.\n  return ParsePrototype();\n} \n```", "```\n/// toplevelexpr ::= expression\nstatic FunctionAST *ParseTopLevelExpr() {\n  if (ExprAST *E = ParseExpression()) {\n    // Make an anonymous proto.\n    PrototypeAST *Proto = new PrototypeAST(\"\", std::vector<std::string>());\n    return new FunctionAST(Proto, E);\n  }\n  return 0;\n} \n```", "```\n/// top ::= definition | external | expression | ';'\nstatic void MainLoop() {\n  while (1) {\n    fprintf(stderr, \"ready> \");\n    switch (CurTok) {\n    case tok_eof:    return;\n    case ';':        getNextToken(); break;  // ignore top-level semicolons.\n    case tok_def:    HandleDefinition(); break;\n    case tok_extern: HandleExtern(); break;\n    default:         HandleTopLevelExpression(); break;\n    }\n  }\n} \n```", "```\n$ ./a.out\nready> def foo(x y) x+foo(y, 4.0);\nParsed a function definition.\nready> def foo(x y) x+y y;\nParsed a function definition.\nParsed a top-level expr\nready> def foo(x y) x+y );\nParsed a function definition.\nError: unknown token when expecting an expression\nready> extern sin(a);\nready> Parsed an extern\nready> ^D\n$ \n```"]