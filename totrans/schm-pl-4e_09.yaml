- en: Chapter 9\. Records
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。记录
- en: This chapter describes the means by which the programmer may define new data
    types, or *records types*, each distinct from all other types. A record type determines
    the number and names of the fields each instance of the type has. Records are
    defined via the `define-record-type` form or the `make-record-type-descriptor`
    procedure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了程序员可以定义新数据类型或*记录类型*的方式，每种类型都与所有其他类型不同。记录类型确定该类型的每个实例具有的字段数量和名称。记录通过`define-record-type`形式或`make-record-type-descriptor`过程定义。
- en: Section 9.1\. Defining Records
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9.1节。定义记录
- en: A `define-record-type` form defines a record type and, along with it, a constructor
    procedure for records of the type, a type predicate that returns true only for
    records of the type, an access procedure for each field, and an assignment procedure
    for each mutable field. For example, the definition
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`define-record-type`形式定义了一个记录类型，以及该类型的记录构造函数，仅对该类型的记录返回true的类型谓词，每个字段的访问过程以及每个可变字段的赋值过程。例如，以下定义'
- en: '`(define-record-type point (fields x y))`'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type point (fields x y))`'
- en: 'creates a `point` record type with two fields, `x` and `y`, and defines the
    following procedures:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个具有两个字段`x`和`y`的`point`记录类型，并定义了以下过程：
- en: '| `(make-point *x* *y*)` | constructor |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `(make-point *x* *y*)` | 构造函数 |'
- en: '| `(point? *obj*)` | predicate |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `(point? *obj*)` | 谓词 |'
- en: '| `(point-x *p*)` | accessor for field `x` |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `(point-x *p*)` | `x`字段的访问器 |'
- en: '| `(point-y *p*)` | accessor for field `y` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `(point-y *p*)` | `y`字段的访问器 |'
- en: With this definition in place, we can use these procedures to create and manipulate
    records of the `point` type, as illustrated below.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义，我们可以使用这些过程来创建和操作`point`类型的记录，如下所示。
- en: '`(define p (make-point 36 -17))'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define p (make-point 36 -17))'
- en: (point? p) ![<graphic>](ch2_0.gif) #t
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: (point? p) ![<graphic>](ch2_0.gif) #t
- en: (point? '(cons 36 -17)) ![<graphic>](ch2_0.gif) #f
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: (point? '(cons 36 -17)) ![<graphic>](ch2_0.gif) #f
- en: (point-x p) ![<graphic>](ch2_0.gif) 36
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: (point-x p) ![<graphic>](ch2_0.gif) 36
- en: (point-y p) ![<graphic>](ch2_0.gif) -17`
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: (point-y p) ![<graphic>](ch2_0.gif) -17`
- en: Fields are immutable by default, but may be declared mutable. In the alternate
    definition of `point` below, the `x` field is mutable while `y` remains immutable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，字段是不可变的，但可以声明为可变。在下面的`point`的替代定义中，`x`字段是可变的，而`y`保持不可变。
- en: '`(define-record-type point (fields (mutable x) y))`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type point (fields (mutable x) y))`'
- en: In this case, `define-record-type` defines a mutator for the `x` field in addition
    to the other products shown above.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`define-record-type`除了上述其他产品外还定义了`x`字段的修改器。
- en: '| `(point-x-set! *p* *x*)` | mutator for field `x` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `(point-x-set! *p* *x*)` | `x`字段的修改器 |'
- en: The mutator can be used to change the contents of the `x` field.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 修改器可用于更改`x`字段的内容。
- en: '`(define p (make-point 36 -17))'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define p (make-point 36 -17))'
- en: (point-x-set! p (- (point-x p) 12))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (point-x-set! p (- (point-x p) 12))
- en: (point-x p) ![<graphic>](ch2_0.gif) 24`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: (point-x p) ![<graphic>](ch2_0.gif) 24`
- en: A field may be declared immutable explicitly for clarity; the definition of
    `point` below is equivalent to the second definition above.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，可以显式声明字段为不可变；下面的`point`定义等同于上面的第二个定义。
- en: '`(define-record-type point (fields (mutable x) (immutable y)))`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type point (fields (mutable x) (immutable y)))`'
- en: The names of the procedures defined by `define-record-type` follow the regular
    naming convention illustrated by the examples above, by default, but the programmer
    can override the defaults if desired. With the following definition of `point`,
    the constructor is `mkpoint`, the predicate is `ispoint?`, and the accessors for
    `x` and `y` are `x-val` and `y-val`. The mutator for `x` is `set-x-val!`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`define-record-type`定义的过程名称遵循上面示例中的常规命名约定，默认情况下，但如果需要，程序员可以覆盖默认值。使用以下`point`的定义，构造函数是`mkpoint`，谓词是`ispoint?`，`x`和`y`的访问器是`x-val`和`y-val`。`x`的修改器是`set-x-val!`。'
- en: '`(define-record-type (point mkpoint ispoint?)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type (point mkpoint ispoint?)'
- en: (fields (mutable x x-val set-x-val!)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (fields (mutable x x-val set-x-val!)
- en: (immutable y y-val)))`
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: (immutable y y-val)))`
- en: By default, a record definition creates a new type each time it is evaluated,
    as illustrated by the example below.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每次评估记录定义时都会创建一个新类型，如下例所示。
- en: '`(define (f p)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (f p)'
- en: (define-record-type point (fields x y))
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: (define-record-type point (fields x y))
- en: (if (eq? p 'make) (make-point 3 4) (point? p)))
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: (if (eq? p 'make) (make-point 3 4) (point? p)))
- en: (f (f 'make)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: (f (f 'make)) ![<graphic>](ch2_0.gif) #f`
- en: The first (inner) call to `f` returns a point `*p*`, which is passed to `f`
    in the second (outer) call, which applies `point?` to `*p*`. This `point?` is
    looking for points of the type created by the second call, while `*p*` is a point
    of the type created by the first call. So `point?` returns `#f`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `f` 的第一次（内部）调用返回一个点 `*p*`，它被传递给第二次（外部）调用的 `f`，该调用将 `point?` 应用于 `*p*`。这个 `point?`
    寻找由第二次调用创建的类型的点，而 `*p*` 是由第一次调用创建的类型的点。因此 `point?` 返回 `#f`。
- en: This default *generative* behavior may be overridden by including a `nongenerative`
    clause in the record definition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种默认的 *生成* 行为可以通过在记录定义中包含 `nongenerative` 子句来覆盖。
- en: '`(define (f p)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (f p)'
- en: (define-record-type point (fields x y) (nongenerative))
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: (define-record-type point (fields x y) (nongenerative))
- en: (if (eq? p 'make) (make-point 3 4) (point? p)))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: (if (eq? p 'make) (make-point 3 4) (point? p)))
- en: (define p (f 'make))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: (define p (f 'make))
- en: (f p) ![<graphic>](ch2_0.gif) #t`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '(f p) ![<graphic>](ch2_0.gif) #t`'
- en: 'Record types created in this manner are still distinct from record types created
    by a definition appearing in a different part of the program, even if the definitions
    are syntactically identical:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建的记录类型仍然与程序的不同部分中出现的定义创建的记录类型不同，即使这些定义在语法上是相同的：
- en: '`(define (f)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (f)'
- en: (define-record-type point (fields x y) (nongenerative))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (define-record-type point (fields x y) (nongenerative))
- en: (make-point 3 4))
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: (make-point 3 4))
- en: (define (g p)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: (define (g p)
- en: (define-record-type point (fields x y) (nongenerative))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: (define-record-type point (fields x y) (nongenerative))
- en: (point? p))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: (point? p))
- en: (g (f)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '(g (f)) ![<graphic>](ch2_0.gif) #f`'
- en: 'Even this can be overridden by including a uid (unique id) in the `nongenerative`
    clause:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这样也可以通过在 `nongenerative` 子句中包含 uid（唯一标识符）来覆盖：
- en: '`(define (f)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define (f)'
- en: (define-record-type point (fields x y)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: (define-record-type point (fields x y)
- en: (nongenerative really-the-same-point))
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: (nongenerative really-the-same-point))
- en: (make-point 3 4))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: (make-point 3 4))
- en: (define (g p)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (define (g p)
- en: (define-record-type point (fields x y)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: (define-record-type point (fields x y)
- en: (nongenerative really-the-same-point))
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: (nongenerative really-the-same-point))
- en: (point? p))
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: (point? p))
- en: (g (f)) ![<graphic>](ch2_0.gif) #t`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '(g (f)) ![<graphic>](ch2_0.gif) #t`'
- en: The uid may be any identifier, but programmers are encouraged to select uids
    from the RFC 4122 UUID namespace [[20](bibliography.html#g238)], possibly with
    the record-type name as a prefix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: uid 可以是任何标识符，但程序员被鼓励从 RFC 4122 UUID 命名空间[[20](bibliography.html#g238)]中选择 uid，可能以记录类型名称作为前缀。
- en: A record type may be defined as a subtype of an existing "parent" type with
    a `parent` clause that declares the name of the existing record type. If a parent
    is specified, the new "child" record type inherits the parent record's fields,
    and each instance of the child type is considered to be an instance of the parent
    type, so that accessors and mutators for the parent type may be used on instances
    of the child type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `parent` 子句声明现有记录类型的名称，将记录类型定义为现有“父”类型的子类型。如果指定了父类型，则新的“子”记录类型继承父记录的字段，并且将子类型的每个实例视为父类型的实例，因此可以在子类型的实例上使用父类型的访问器和修改��。
- en: '`(define-record-type point (fields x y))'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type point (fields x y))'
- en: (define-record-type cpoint (parent point) (fields color))`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: (define-record-type cpoint (parent point) (fields color))`
- en: The child type has all of the fields of the parent type, plus the additional
    fields declared in the child's definition. This is reflected in the constructor
    for `cpoint`, which now takes three arguments, with the parent arguments followed
    by the child argument.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型具有父类型的所有字段，以及子类型定义中声明的附加字段。这反映在 `cpoint` 的构造函数中，现在需要三个参数，父参数后跟子参数。
- en: '`(define cp (make-cpoint 3 4 ''red))`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define cp (make-cpoint 3 4 ''red))`'
- en: A record of the child type is considered a record of the parent type, but a
    record of the parent type is not a record of the new type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型的记录被视为父类型的记录，但父类型的记录不是新类型的记录。
- en: '`(point? (make-cpoint 3 4 ''red)) ![<graphic>](ch2_0.gif) #t'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`(point? (make-cpoint 3 4 ''red)) ![<graphic>](ch2_0.gif) #t'
- en: (cpoint? (make-point 3 4)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '(cpoint? (make-point 3 4)) ![<graphic>](ch2_0.gif) #f`'
- en: Only one new accessor is created for `cpoint`, the one for the new field `color`.
    The existing accessors and mutators for the parent type may be used to access
    and modify the parent fields of the child type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `cpoint` 只创建一个新的访问器，用于新字段 `color`。可以使用父类型的现有访问器和修改器来访问和修改子类型的父字段。
- en: '`(define cp (make-cpoint 3 4 ''red))'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define cp (make-cpoint 3 4 ''red))'
- en: (point-x cp) ![<graphic>](ch2_0.gif) 3
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: (point-x cp) ![<graphic>](ch2_0.gif) 3
- en: (point-y cp) ![<graphic>](ch2_0.gif) 4
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: (point-y cp) ![<graphic>](ch2_0.gif) 4
- en: (cpoint-color cp) ![<graphic>](ch2_0.gif) red`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: (cpoint-color cp) ![<graphic>](ch2_0.gif) red`
- en: 'As the examples given so far illustrate, the default constructor defined by
    `define-record-type` accepts as many arguments as the record has fields, including
    parent fields, and parent''s parent fields, and so on. The programmer may override
    the default and specify the arguments to the constructor for the new type and
    how it determines the initial values of the constructed record''s fields, via
    the `protocol` clause. The following definition creates a `point` record with
    three fields: `x`, `y`, and `d`, where `d` represents the displacement from the
    origin. The constructor still takes only two arguments, the `x` and `y` values,
    and initializes `d` to the square root of the sum of the squares of `x` and `y`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如迄今为止给出的示例所示，`define-record-type`定义的默认构造函数接受与记录具有的字段数量相同的参数，包括父字段，父的父字段等。 程序员可以覆盖默认值，并通过`protocol`子句指定新类型的构造函数的参数以及它如何确定构造记录字段的初始值。
    以下定义创建一个具有三个字段的`point`记录：`x`，`y`和`d`，其中`d`表示与原点的位移。 构造函数仍然只接受两个参数，`x`和`y`值，并将`d`初始化为`x`和`y`的平方和的平方根。
- en: '`(define-record-type point'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type point'
- en: (fields x y d)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: (fields x y d)
- en: (protocol
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: (protocol
- en: (lambda (new)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new)
- en: (lambda (x y)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: (new x y (sqrt (+ (* x x) (* y y))))))))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: (new x y (sqrt (+ (* x x) (* y y))))))))
- en: (define p (make-point 3 4))
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: (define p (make-point 3 4))
- en: (point-x p) ![<graphic>](ch2_0.gif) 3
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: (point-x p) ![<graphic>](ch2_0.gif) 3
- en: (point-y p) ![<graphic>](ch2_0.gif) 4
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: (point-y p) ![<graphic>](ch2_0.gif) 4
- en: (point-d p) ![<graphic>](ch2_0.gif) 5`
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: (point-d p) ![<graphic>](ch2_0.gif) 5`
- en: The procedure value of the expression within the `protocol` clause receives
    as an argument a primitive constructor `*new*` and returns a final constructor
    `*c*`. There are essentially no limits on what `*c*` is allowed to do, but if
    it returns, it should return the result of calling `*new*`. Before it does so,
    it may modify the new record instance (if the record type has mutable fields),
    register it with some external handler, print messages, etc. In this case, `*c*`
    accepts two arguments, `*x*` and `*y*`, and applies `*new*` to `*x*`, `*y*`, and
    the result of computing the origin displacement based on `*x*` and `*y*`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`protocol`子句内表达式的过程值接收一个原始构造函数`*new*`作为参数，并返回一个最终构造函数`*c*`。 `*c*`允许做的事情基本上没有限制，但如果它返回，应该返回调用`*new*`的结果。
    在这样做之前，它可以修改新的记录实例（如果记录类型具有可变字段），将其注册到某些外部处理程序，打印消息等。 在这种情况下，`*c*`接受两个参数，`*x*`和`*y*`，并将`*new*`应用于`*x*`，`*y*`以及基于`*x*`和`*y*`计算原始位移的结果。'
- en: If a parent record is specified, the construction protocol becomes more involved.
    The following definition of `cpoint` assumes that `point` has been defined as
    shown just above.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了父记录，则构造协议变得更加复杂。 以下`cpoint`的定义假定`point`已如上所示定义。
- en: '`(define-record-type cpoint'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type cpoint'
- en: (parent point)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: (parent point)
- en: (fields color)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (fields color)
- en: (protocol
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: (protocol
- en: (lambda (pargs->new)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (pargs->new)
- en: (lambda (c x y)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (c x y)
- en: ((pargs->new x y) c)))))
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ((pargs->new x y) c)))))
- en: (define cp (make-cpoint 'red 3 4))
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: (define cp (make-cpoint 'red 3 4))
- en: (point-x cp) ![<graphic>](ch2_0.gif) 3
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: (point-x cp) ![<graphic>](ch2_0.gif) 3
- en: (point-y cp) ![<graphic>](ch2_0.gif) 4
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: (point-y cp) ![<graphic>](ch2_0.gif) 4
- en: (point-d cp) ![<graphic>](ch2_0.gif) 5
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: (point-d cp) ![<graphic>](ch2_0.gif) 5
- en: (cpoint-color cp) ![<graphic>](ch2_0.gif) red`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: (cpoint-color cp) ![<graphic>](ch2_0.gif) red`
- en: Because a parent clause is present, the procedure value of the expression within
    the `protocol` clause receives a procedure `*pargs*->*new*` that, when applied
    to parent arguments, returns a `*new*` procedure. The `*new*` procedure, when
    passed the values of the child fields, returns the result of applying the parent
    protocol to an appropriate `*new*` procedure of its own. In this case, `*pargs*->*new*`
    is passed the values of the child constructor's second and third arguments (the
    `*x*` and `*y*` values) and the resulting `*new*` procedure is passed the value
    of the child constructor's first argument (the color). Thus, the protocol supplied
    in this example effectively reverses the normal order of arguments in which the
    parent arguments come before the child arguments, while arranging to pass along
    the arguments needed by the parent protocol.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在父子句，`protocol`子句内表达式的过程值接收一个过程`*pargs*->*new*`，当应用于父参数时，返回一个`*new*`过程。 当传递子字段的值时，`*new*`过程返回将父协议应用于其自身适当`*new*`过程的结果。
    在这种情况下，`*pargs*->*new*`传递子构造函数的第二和第三参数的值（`*x*`和`*y*`值），并且生成的`*new*`过程传递子构造函数的第一个参数的值（颜色）。
    因此，此示例中提供的协议有效地颠倒了父参数在子参数之前的正常顺序，同时安排传递父协议所需的参数。
- en: The default protocol is equivalent to
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认协议等同于
- en: '`(lambda (new) new)`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (new) new)`'
- en: for record types with no parents, while for record types with parents, the default
    protocol is equivalent to the following
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有父记录类型的记录类型，而对于具有父记录类型的记录类型，默认协议等同于以下内容
- en: '`(lambda (pargs->new)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`(lambda (pargs->new)`'
- en: (lambda (*x[1]* ... *x[n]* *y[1]* ... *y[m]*)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (*x[1]* ... *x[n]* *y[1]* ... *y[m]*)
- en: ((pargs->new *x[1]* ... *x[n]*) *y[1]* ... *y[m]*)))`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ((pargs->new *x[1]* ... *x[n]*) *y[1]* ... *y[m]*)))`
- en: where `*n*` is the number of parent (including grandparent, etc.) fields and
    `*m*` is the number of child fields.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `*n*` 是父（包括祖父等）字段的数量，而 `*m*` 是子字段的数量。
- en: Use of the `protocol` clause insulates the child record definition from some
    changes to the parent record type. The parent definition may be modified to add
    or remove fields, or even add, remove, or change a parent, yet the child protocol
    and constructor need not change as long as the parent protocol does not change.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `protocol` 条款可使子记录定义免受对父记录类型的某些更改的影响。可以修改父定义以添加或删除字段，甚至添加、删除或更改父级，但只要父协议不改变，子协议和构造函数就不需要更改。
- en: Additional details and options for `define-record-type` are given in its formal
    description below.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`define-record-type` 的更多细节和选项在下面的正式描述中给出。'
- en: '**syntax**: `(define-record-type *record-name* *clause* ...)`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：**`(define-record-type *record-name* *clause* ...)`'
- en: '**syntax**: `(define-record-type (*record-name* *constructor* *pred*) *clause* ...)`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法：**`(define-record-type (*record-name* *constructor* *pred*) *clause* ...)`'
- en: '**libraries:** `(rnrs records syntactic)`, `(rnrs)`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs records syntactic)`，`(rnrs)`'
- en: 'A `define-record-type` form, or *record definition*, is a definition and may
    appear anywhere other definitions may appear. It defines a record type identified
    by `*record-name*`, plus a predicate, constructor, accessors, and mutators for
    the record type. If the record definition takes the first form above, the names
    of the constructor and predicate are derived from `*record-name*`: `make-*record-name*`
    for the constructor and `*record-name*?` for the predicate. If the record definition
    takes the second form above, the name of the constructor is `*constructor*` and
    the name of the predicate is `*pred*`. All names defined by a record definition
    are scoped where the record definition appears.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `define-record-type` 表单，或 *记录定义*，是一个定义，并且可以出现在其他定义可能出现的任何地方。它定义了一个由 `*record-name*`
    标识的记录类型，以及记录类型的谓词、构造函数、访问者和变异者。如果记录定义采用上述第一种形式，则构造函数和谓词的名称源自于 `*record-name*`：构造函数为
    `make-*record-name*`，谓词为 `*record-name*?`。如果记录定义采用上述第二种形式，则构造函数的名称为 `*constructor*`，谓词的名称为
    `*pred*`。记录定义定义的所有名称在记录定义出现的地方作用域。
- en: The clauses `*clause* ...` of the record definition determine the fields of
    the record type and the names of their accessors and mutators; its parent type,
    if any; its construction protocol; whether it is nongenerative and, if so, whether
    its uid is specified; whether it is sealed; and whether it is opaque. The syntax
    and impact of each clause is described below.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记录定义的 `*clause* ...` 决定了记录类型的字段及其访问者和变异者的名称；其父类型（如果有）；其构造协议；它是否是非生成的，如果是，则其uid是否已指定；它是否被密封；以及它是否是不透明的。下面描述了每个条款的语法和影响。
- en: None of the clauses is required; thus, the simplest record definition is
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个条款是必需的；因此，最简单的记录定义是
- en: '`(define-record-type *record-name*)`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define-record-type *record-name*)`'
- en: which defines a new, generative, non-sealed, non-opaque record type with no
    parent and no fields, plus a constructor of no arguments and a predicate.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个新的，生成的，非密封的，非不透明的记录类型，没有父级和字段，以及一个无参数的构造函数和一个谓词。
- en: At most one of each kind of clause may be present in the set of clauses, and
    if a `parent` clause is present, a `parent-rtd` clause must not be present. The
    clauses that appear may appear in any order.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的条款最多只能出现一次在条款集合中，并且如果出现了 `parent` 条款，则不能出现 `parent-rtd` 条款。出现的条款可以以任何顺序出现。
- en: '**Fields clause.**  A `(fields *field-spec* ...)` clause declares the fields
    of the record type. Each `*field-spec*` must take one of the following forms:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**字段条款。** `(fields *field-spec* ...)` 条款声明了记录类型的字段。每个 `*field-spec*` 必须采取以下形式之一：'
- en: '`*field-name*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`*field-name*'
- en: (immmutable *field-name*)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (不可变的 *field-name*)
- en: (mutable *field-name*)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: (可变的 *field-name*)
- en: (immmutable *field-name* *accessor-name*)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: (不可变的 *field-name* *accessor-name*)
- en: (mutable *field-name* *accessor-name* *mutator-name*)`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (可变的 *field-name* *accessor-name* *mutator-name*)`
- en: where `*field-name*`, `*accessor-name*`, and `*mutator-name*` are identifiers.
    The first form, `*field-name*`, is equivalent to `(immutable *field-name*)`. The
    value of a field declared immutable may not be changed, and no mutator is created
    for it. With the first three forms, the name of the accessor is `*rname*-*fname*`,
    where `*rname*` is the record name and `*fname*` is the field name. With the third
    form, the name of the accessor is `*rname*-*fname*-set!`. The fourth and fifth
    forms explicitly declare the accessor and mutator names.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`*field-name*`、`*accessor-name*`和`*mutator-name*`是标识符。第一种形式，`*field-name*`，等价于`(immutable *field-name*)`。声明为不可变的字段的值不能被更改，并且不会为其创建修改器。对于前三种形式，访问器的名称是`*rname*-*fname*`，其中`*rname*`是记录名称，`*fname*`是字段名称。对于第三种形式，访问器的名称是`*rname*-*fname*-set!`。第四和第五种形式明确声明了访问器和修改器的名称。
- en: If no `fields` clause is present or the list `*field-spec* ...` is empty, the
    record type has no fields (other than parent fields, if any).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现`fields`子句或列表`*field-spec* ...`为空，则记录类型没有字段（除非有父字段）。
- en: '**Parent clause.**  A `(parent *parent-name*)` clause declares the parent record
    type; `*parent-name*` must be the name of a non-sealed record type previously
    defined via `define-record-type`. Instances of a record type are also considered
    instances of its parent record type and have all the fields of its parent record
    type in addition to those declared via the `fields` clause.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**父项子句。**  一个`(parent *parent-name*)`子句声明父记录类型；`*parent-name*`必须是先前通过`define-record-type`定义的非封闭记录类型的名称。记录类型的实例也被视为其父记录类型的实例，并且除了通过`fields`子句声明的字段外，还具有其父记录类型的所有字段。'
- en: '**Nongenerative clause.**  A `nongenerative` clause may take one of two forms:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**非生成子句。**  一个`nongenerative`子句可能有两种形式：'
- en: '`(nongenerative)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`(nongenerative)`'
- en: (nongenerative *uid*)`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`(nongenerative *uid*)`'
- en: where `*uid*` is a symbol. The first form is equivalent to the second, with
    a uid generated by the implementation at macro-expansion time. When a `define-record-type`
    form with a nongenerative clause is evaluated, a new type is created if and only
    if the uid is not the uid of an existing record type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`*uid*`是一个符号。第一种形式等价于第二种形式，在宏展开时由实现生成的uid。当评估具有非生成子句的`define-record-type`形式时，只有当uid不是现有记录类型的uid时，才会创建新类型。
- en: If it is the uid of an existing record type, the parent, field-names, sealed
    property, and opaque property must match as follows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是现有记录类型的uid，则父项、字段名称、封闭属性和不透明属性必须匹配如下。
- en: If a parent is specified, the existing record type must have the same parent
    rtd (by `eqv?`). If a parent is not specified, the existing record type must not
    have a parent.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果指定了父项，则现有记录类型必须具有相同的父rtd（通过`eqv?`）。如果未指定父项，则现有记录类型不得具有父项。
- en: The same number of fields must be provided, with the same names and in the same
    order, and the mutability of each field must be the same.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须提供相同数量的字段，具有相同的名称和相同的顺序，并且每个字段的可变性必须相同。
- en: If a `(sealed #t)` clause is present, the existing record type must be sealed.
    Otherwise, the existing record type must not be sealed.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出现`(sealed #t)`子句，则现有记录类型必须是封闭的。否则，现有记录类型必须不是封闭的。
- en: If an `(opaque #t)` clause is present, the existing record type must be opaque.
    Otherwise, the existing record type must be opaque if and only if an opaque parent
    type is specified.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出现`(opaque #t)`子句，则现有记录类型必须是不透明的。否则，仅当指定了不透明父类型时，现有记录类型才必须是不透明的。
- en: If these constraints are met, no new record type is created, and the other products
    of the record-type definition (constructor, predicate, accessors, and mutators)
    operate on records of the existing type. If these constraints are not met, the
    implementation may treat it as a syntax violation, or it may raise a run-time
    exception with condition type `&assertion`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足这些约束条件，则不会创建新的记录类型，并且记录类型定义的其他产品（构造函数、谓词、访问器和修改器）将对现有类型的记录进行操作。如果不满足这些约束条件，实现可能会将其视为语法错误，或者可能会引发具有条件类型`&assertion`的运行时异常。
- en: With the first form of `nongenerative` clause, the generated uid can be the
    uid of an existing record type only if the same definition is executed multiple
    times, e.g., if it appears in the body of a procedure that is invoked multiple
    times.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`nongenerative`子句的第一种形式，只有在相同的定义被多次执行时（例如，如果它出现在被多次调用的过程的体中），生成的uid才可以是现有记录类型的uid。
- en: If `*uid*` is not the uid of an existing record type, or if no `nongenerative`
    clause is present, a new record type is created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*uid*`不是现有记录类型的uid，或者没有出现`nongenerative`子句，则会创建一个新的记录类型。
- en: '**Protocol clause.**  A `(protocol *expression*)` determines the protocol that
    the generated constructor uses to construct instances of the record type. It must
    evaluate to a procedure, and this procedure should be an appropriate protocol
    for the record type, as described on page [326](records.html#page:protocols).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**Protocol 子句。**  一个`(protocol *expression*)`确定生成的构造函数用于构造记录类型实例的协议。它必须求值为一个过程，这个过程应该是记录类型的适当协议，如第[326](records.html#page:protocols)页所述。'
- en: '**Sealed clause.**  A `sealed` clause of the form `(sealed #t)` declares that
    the record type is *sealed*. This means that it cannot be extended, i.e., cannot
    be used as the parent for another record definition or `make-record-type-descriptor`
    call. If no `sealed` clause is present or if one of the form `(sealed #f)` is
    present, the record type is not sealed.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sealed 子句。**  一个形式为`(sealed #t)`的`sealed`子句声明记录类型是*封闭*的。这意味着它不能被扩展，即不能用作另一个记录定义或`make-record-type-descriptor`调用的父记录。如果没有`sealed`子句或者形式为`(sealed #f)`之一，记录类型不是封闭的。'
- en: '**Opaque clause.**  An `opaque` clause of the form `(opaque #t)` declares that
    the record type is *opaque*. Instances of an opaque record type are not considered
    records by the `record?` predicate or, more importantly, the rtd-extraction procedure
    `record-rtd`, which are both described in Section [9.3](records.html#g141). Thus,
    it is not possible for code that does not have access to the `record-name`, accessors,
    or mutators to access or modify any of the fields of an opaque record type. A
    record type is also opaque if its parent is opaque. If no `opaque` clause is present
    or if one of the form `(opaque #f)` is present, and the parent, if any, is not
    opaque, the record type is not opaque.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**Opaque 子句。**  一个形式为`(opaque #t)`的`opaque`子句声明记录类型是*不透明*的。不透明记录类型的实例不被`record?`谓词或更重要的是`record-rtd`提取过程视为记录，这两者都在第[9.3](records.html#g141)节中描述。因此，如果没有访问`record-name`、访问器或修改器的代码，就无法访问或修改不透明记录类型的任何字段。如果记录类型的父记录是不透明的，则记录类型也是不透明的。如果没有`opaque`子句或者形式为`(opaque #f)`之一，且父记录（如果有）不是不透明的，则记录类型不是不透明的。'
- en: '**Parent-rtd clause.**  A `(parent-rtd *parent-rtd* *parent-rcd*)` clause is
    an alternative to the `parent` clause for specifying the parent record type, along
    with a parent record constructor descriptor. It is primarily useful when the parent
    rtd and rcd were obtained via calls to `make-record-type-descriptor` and `make-record-constructor-descriptor`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parent-rtd 子句。**  一个`(parent-rtd *parent-rtd* *parent-rcd*)`子句是指定父记录类型以及父记录构造函数描述符的`parent`子句的替代方案。当父
    rtd 和 rcd 是通过调用`make-record-type-descriptor`和`make-record-constructor-descriptor`获得时，这是非常有用的。'
- en: '`*parent-rtd*` must evaluate to an rtd or `#f`. If `*parent-rtd*` evaluates
    to `#f`, `*parent-rcd*` must also evaluate to `#f`. Otherwise, `*parent-rcd*`
    must evaluate to an rcd or `#f`. If `*parent-rcd*` evaluates to an rcd, it must
    encapsulate an rtd equivalent (by `eqv?`) to the value of `*parent-rtd*`. If the
    value of `*parent-rcd*` is `#f`, it is treated as an rcd for the value of `*parent-rtd*`
    with a default protocol.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`*parent-rtd*`必须求值为一个 rtd 或`#f`。如果`*parent-rtd*`求值为`#f`，`*parent-rcd*`也必须求值为`#f`。否则，`*parent-rcd*`必须求值为一个
    rcd 或`#f`。如果`*parent-rcd*`求值为一个 rcd，则它必须封装一个与`*parent-rtd*`的值等效（通过`eqv?`）的 rtd。如果`*parent-rcd*`的值为`#f`，则将其视为具有默认协议的`*parent-rtd*`的
    rcd。'
- en: The `define-record-type` form is designed in such a way that it is normally
    possible for a compiler to determine the shapes of the record types it defines,
    including the offsets for all fields. This guarantee does not hold, however, when
    the `parent-rtd` clause is used, since the parent rtd might not be determinable
    until run time. Thus, the `parent` clause is preferred over the `parent-rtd` clause
    whenever the `parent` clause suffices.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`define-record-type`形式设计得通常可以使编译器确定其定义的记录类型的形状，包括所有字段的偏移量。然而，当使用`parent-rtd`子句时，这种保证不成立，因为父
    rtd 可能直到运行时才能确定。因此，每当`parent`子句足够时，都应优先使用`parent`子句而不是`parent-rtd`子句。'
- en: '**syntax**: `fields`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`fields`'
- en: '**syntax**: `mutable`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`mutable`'
- en: '**syntax**: `immutable`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`immutable`'
- en: '**syntax**: `parent`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`parent`'
- en: '**syntax**: `protocol`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`protocol`'
- en: '**syntax**: `sealed`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`sealed`'
- en: '**syntax**: `opaque`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`opaque`'
- en: '**syntax**: `nongenerative`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`nongenerative`'
- en: '**syntax**: `parent-rtd`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：`parent-rtd`'
- en: '**libraries:** `(rnrs records syntactic)`, `(rnrs)`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：**`(rnrs records syntactic)`，`(rnrs)`'
- en: These identifiers are auxiliary keywords for `define-record-type`. It is a syntax
    violation to reference these identifiers except in contexts where they are recognized
    as auxiliary keywords.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标识符是`define-record-type`的辅助关键字。在不被识别为辅助关键字的上下文中引用这些标识符是语法违例。
- en: Section 9.2\. Procedural Interface
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9.2节。过程接口
- en: The procedural (`make-record-type-descriptor`) interface may also be used to
    create new record types. The procedural interface is more flexible than the syntactic
    interface, but this flexibility can lead to less readable and efficient programs,
    so programmers should use the syntactic interface whenever it suffices.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 过程（`make-record-type-descriptor`）接口也可以用于创建新的记录类型。过程接口比语法接口更灵活，但这种灵活性可能导致程序不够可读和高效，因此程序员应在足够的情况下使用语法接口。
- en: '**procedure**: `(make-record-type-descriptor *name* *parent* *uid* *s?* *o?* *fields*)`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-record-type-descriptor *name* *parent* *uid* *s?* *o?* *fields*)`'
- en: '**returns:** a record-type descriptor (rtd) for a new or existing record type'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 一个新的或现有记录类型的记录类型描述符（rtd）'
- en: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
- en: '`*name*` must be a symbol, `*parent*` must be `#f` or the rtd of a non-sealed
    record type, `*uid*` must be `#f` or a symbol, and `*fields*` must be a vector,
    each element of which is a two-element list of the form `(mutable *field-name*)`
    or `(immutable *field-name*)`. The field names `*field-name* ...` must be symbols
    and need not be distinct from each other.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`*name*`必须是一个符号，`*parent*`必须是`#f`或者非密封记录类型的rtd，`*uid*`必须是`#f`或者一个符号，`*fields*`必须是一个向量，其中每个元素都是形式为`(mutable *field-name*)`或`(immutable *field-name*)`的两元素列表。字段名称`*field-name* ...`必须是符号，不需要彼此不同。'
- en: If `*uid*` is `#f` or is not the uid of an existing record type, this procedure
    creates a new record type and returns a record-type descriptor (rtd) for the new
    type. The type has the parent type (page [325](records.html#page:parent-type))
    described by `*parent*`, if nonfalse; the uid specified by `*uid*`, if nonfalse;
    and the fields specified by `*fields*`. It is sealed (page [330](records.html#page:sealed))
    if `*s?*` is nonfalse. It is opaque (page [330](records.html#page:opaque)) if
    `*opaque*` is nonfalse or the parent (if specified) is opaque. The name of the
    new record type is `*name*` and the names of the fields are `*field-name* ...`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*uid*`是`#f`或者不是现有记录类型的uid，则此过程将创建一个新的记录类型，并返回新类型的记录类型描述符（rtd）。该类型具有父类型（页面[325](records.html#page:parent-type)）由`*parent*`描述，如果非假；由`*uid*`指定的uid，如果非假；以及由`*fields*`指定的字段。如果`*s?*`为非假，则它是密封的（页面[330](records.html#page:sealed)）。如果`*opaque*`为非假或者父类型（如果指定）是不透明的，则它是不透明的（页面[330](records.html#page:opaque)）。新记录类型的名称是`*name*`，字段的名称是`*field-name* ...`。
- en: If `*uid*` is nonfalse and is the uid (page [325](records.html#page:record-uid))
    of an existing record type, the `*parent*`, `*fields*`, `*s?*`, and `*o?*` arguments
    must match the corresponding characteristics of the existing record type. That
    is, `*parent*` must be the same (by `eqv?`); the number of fields must be the
    same; the fields must have the same names, be in the same order, and have the
    same mutability; `*s?*` must be false if and only if the existing record type
    is sealed; and, if a parent is not specified or is not opaque, `*o?*` must be
    false if and only if the existing record type is opaque. If this is the case,
    `make-record-type-descriptor` returns the rtd for the existing record type. Otherwise,
    an exception with condition type `&assertion` is raised.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`*uid*`为非假并且是现有记录类型的uid（页面[325](records.html#page:record-uid)），则`*parent*`、`*fields*`、`*s?*`和`*o?*`参数必须与现有记录类型的相应特征匹配。也就是说，`*parent*`必须相同（通过`eqv?`）；字段数量必须相同；字段必须具有相同的名称，按相同顺序排列，并具有相同的可变性；如果现有记录类型是密封的，则`*s?*`必须为假；如果未指定父类型或父类型不是不透明的，则`*o?*`必须为假，如果现有记录类型是不透明的。如果是这种情况，`make-record-type-descriptor`返回现有记录类型的rtd。否则，将引发带有条件类型`&assertion`的异常。
- en: Using the rtd returned by `make-record-type-descriptor`, programs can generate
    constructors, type predicates, field accessors, and field mutators dynamically.
    The following code demonstrates how the procedural interface might be used to
    create a `point` record type and associated definitions similar to those of the
    second `point` record definition in Section [9.1](records.html#g139), with a mutable
    `x` field and an immutable `y` field.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`make-record-type-descriptor`返回的rtd，程序可以动态生成构造函数、类型谓词、字段访问器和字段修改器。以下代码演示了如何使用过程接口创建一个`point`记录类型和与第9.1节中第二个`point`记录定义类似的相关定义，其中有一个可变的`x`字段和一个不可变的`y`字段。
- en: '`(define point-rtd (make-record-type-descriptor ''point #f #f #f #f'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define point-rtd (make-record-type-descriptor ''point #f #f #f #f'
- en: '''#((mutable x) (immutable y))))'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '''#((mutable x) (immutable y))))'
- en: (define point-rcd (make-record-constructor-descriptor point-rtd
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: (define point-rcd (make-record-constructor-descriptor point-rtd
- en: '#f #f))'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '#f #f))'
- en: (define make-point (record-constructor point-rcd))
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (define make-point (record-constructor point-rcd))
- en: (define point? (record-predicate point-rtd))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: (define point? (record-predicate point-rtd))
- en: (define point-x (record-accessor point-rtd 0))
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: (define point-x (record-accessor point-rtd 0))
- en: (define point-y (record-accessor point-rtd 1))
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: (define point-y (record-accessor point-rtd 1))
- en: (define point-x-set! (record-mutator point-rtd 0))`
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: (define point-x-set! (record-mutator point-rtd 0))`
- en: See the additional examples given at the end of this section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本节末尾给出的其他示例。
- en: '**procedure**: `(record-type-descriptor? *obj*)`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(record-type-descriptor? *obj*)`'
- en: '**returns:** `#f` if `*obj*` is a record-type descriptor, otherwise `#f`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 如果`*obj*`是记录类型描述符，则返回`#f`，否则返回`#f`。'
- en: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
- en: See the examples given at the end of this section.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本节末尾给出的示例。
- en: '**procedure**: `(make-record-constructor-descriptor *rtd* *parent-rcd* *protocol*)`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(make-record-constructor-descriptor *rtd* *parent-rcd* *protocol*)`'
- en: '**returns:** a record-constructor descriptor (rcd)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 记录构造器描述符（rcd）。'
- en: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
- en: 'An rtd alone is sufficient to create predicates, accessors, and mutators. To
    create a constructor, however, it is first necessary to create a record-constructor
    descriptor (rcd) for the record type. An rcd encapsulates three pieces of information:
    the rtd of the record type for which the rcd has been created, the parent rcd
    (if any), and the protocol.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 仅rtd就足以创建谓词、访问器和变异器。然而，要创建构造器，首先需要为记录类型创建记录构造器描述符（rcd）。rcd封装了三个信息：为其创建了rcd的记录类型的rtd、父rcd（如果有）和协议。
- en: The `*parent-rcd*` argument must be an rcd or `#f`. If it is an rcd, `*rtd*`
    must have a parent rtd, and the parent rtd must be the same as the rtd encapsulated
    within `*parent-rcd*`. If `*parent-rcd*` is false, either `*rtd*` has no parent
    or an rcd with a default protocol is assumed for the parent.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`*parent-rcd*`参数必须是一个rcd或`#f`。如果它是一个rcd，则`*rtd*`必须有一个父rtd，并且父rtd必须与`*parent-rcd*`中封装的rtd相同。如果`*parent-rcd*`为false，则`*rtd*`没有父级或者假定父级为具有默认协议的rcd。'
- en: The `*protocol*` argument must be a procedure or `#f`. If it is `#f`, a default
    protocol is assumed. Protocols are discussed on page [326](records.html#page:protocols).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`*protocol*`参数必须是一个过程或`#f`。如果是`#f`，则假定默认协议。协议在第326页讨论（records.html#page:protocols）。'
- en: See the examples given at the end of this section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本节末尾给出的示例。
- en: '**syntax**: `(record-type-descriptor *record-name*)`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(record-type-descriptor *record-name*)`'
- en: '**returns:** the rtd for the record type identified by `record-name`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 返回由`record-name`标识的记录类型的rtd。'
- en: '**syntax**: `(record-constructor-descriptor *record-name*)`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**syntax**: `(record-constructor-descriptor *record-name*)`'
- en: '**returns:** the rcd for the record type identified by `record-name`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 返回由`record-name`标识的记录类型的rcd。'
- en: '**libraries:** `(rnrs records syntactic)`, `(rnrs)`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs records syntactic)`, `(rnrs)`'
- en: Each record definition creates, behind the scenes, an rtd and rcd for the defined
    record type. These procedures allow the rtd and rcd to be obtained and used like
    any other rtd or rcd. `*record-name*` must be the name of a record previously
    defined via `define-record-type`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个记录定义在幕后创建了一个定义的记录类型的rtd和rcd。这些过程允许获取和使用rtd和rcd，就像获取和使用任何其他rtd或rcd一样。`*record-name*`必须是先前通过`define-record-type`定义的记录的名称。
- en: '**procedure**: `(record-constructor *rcd*)`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(record-constructor *rcd*)`'
- en: '**returns:** a record constructor for the record type encapsulated within `*rcd*`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 封装在`*rcd*`中的记录类型的记录构造器。'
- en: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
- en: The behavior of the record constructor is determined by the protocol and parent
    rcd (if any) also encapsulated within `*rcd*`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 记录构造器的行为由协议和父rcd（如果有）也封装在`*rcd*`中来确定。
- en: See the examples given at the end of this section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本节末尾给出的示例。
- en: '**procedure**: `(record-predicate *rtd*)`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**procedure**: `(record-predicate *rtd*)`'
- en: '**returns:** a predicate for `*rtd*`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**returns:** 用于`*rtd*`的谓词。'
- en: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
- en: This procedure returns a predicate that accepts one argument and returns `#t`
    if the argument is an instance of the record-type described by `*rtd*`, `#f` otherwise.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程返回一个接受一个参数并返回`#t`（如果参数是由`*rtd*`描述的记录类型的实例）的谓词，否则返回`#f`。
- en: See the examples given at the end of this section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本节末尾给出的示例。
- en: '**procedure**: `(record-accessor *rtd* *idx*)`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(record-accessor *rtd* *idx*)`'
- en: '**returns:** an accessor for the field of `*rtd*` specified by `*idx*`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 用于指定`*rtd*`字段的访问器`*idx*`'
- en: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs records procedural)`, `(rnrs)`'
- en: '`*idx*` must be a nonnegative integer less than the number of fields of `*rtd*`,
    not counting parent fields. An `*idx*` value of 0 specifies the first field given
    in the `define-record-type` form or `make-record-type-descriptor` call that created
    the record type, 1 specifies the second, and so on.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`*idx*`必须是小于`*rtd*`字段数的非负整数，不包括父字段。`*idx*`值为0指定了在创建记录类型的`define-record-type`形式或`make-record-type-descriptor`调用中给出的第一个字段，1指定了第二个字段，依此类推。'
- en: A child rtd cannot be used directly to create accessors for parent fields. To
    create an accessor for a parent field, the record-type descriptor of the parent
    must be used instead.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 子rtd不能直接用于创建父字段的访问器。要为父字段创建访问��，必须使用父记录的记录类型描述符。
- en: See the examples given at the end of this section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本节末尾给出的示例。
- en: '**procedure**: `(record-mutator *rtd* *idx*)`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**过程：** `(record-mutator *rtd* *idx*)`'
- en: '**returns:** a mutator for the field of `*rtd*` specified by `*idx*`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回：** 用于指定`*idx*`的`*rtd*`字段的修改器'
- en: '**libraries:** `(rnrs records procedural)`, `(rnrs)`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**库：** `(rnrs records procedural)`, `(rnrs)`'
- en: '`*idx*` must be a nonnegative integer less than the number of fields of `*rtd*`,
    not counting parent fields. An `*idx*` value of 0 specifies the first field given
    in the `define-record-type` form or `make-record-type-descriptor` call that created
    the record type, 1 specifies the second, and so on. The indicated field must be
    mutable; otherwise, an exception with condition type `&assertion` is raised.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`*idx*`必须是小于`*rtd*`字段数的非负整数，不包括父字段。`*idx*`值为0指定了在创建记录类型的`define-record-type`形式或`make-record-type-descriptor`调用中给出的第一个字段，1指定了第二个字段，依此类推。指定的字段必须是可变的；否则，将引发带有条件类型`&assertion`的异常。'
- en: A child rtd cannot be used directly to create mutators for parent fields. To
    create a mutator for a parent field, the record-type descriptor of the parent
    must be used instead.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 子rtd不能直接用于创建父字段的修改器。要为父字段创建修改器，必须使用父记录的记录类型描述符。
- en: The following example illustrates the creation of parent and child record types,
    predicates, accessors, mutators, and constructors using the procedures described
    in this section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了使用本节描述的程序创建父记录和子记录类型、谓词、访问器、修改器和构造器。
- en: '`(define rtd/parent'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`(define rtd/parent'
- en: (make-record-type-descriptor 'parent #f #f #f #f
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: (make-record-type-descriptor 'parent #f #f #f #f
- en: '''#((mutable x))))'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '''#((mutable x))))'
- en: (record-type-descriptor? rtd/parent) ![<graphic>](ch2_0.gif) #t
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: (record-type-descriptor? rtd/parent) ![<graphic>](ch2_0.gif) #t
- en: (define parent? (record-predicate rtd/parent))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: (define parent? (record-predicate rtd/parent))
- en: (define parent-x (record-accessor rtd/parent 0))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: (define parent-x (record-accessor rtd/parent 0))
- en: (define set-parent-x! (record-mutator rtd/parent 0))
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: (define set-parent-x! (record-mutator rtd/parent 0))
- en: (define rtd/child
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: (define rtd/child
- en: (make-record-type-descriptor 'child rtd/parent #f #f #f
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: (make-record-type-descriptor 'child rtd/parent #f #f #f
- en: '''#((mutable x) (immutable y))))'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '''#((mutable x) (immutable y))))'
- en: (define child? (record-predicate rtd/child))
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: (define child? (record-predicate rtd/child))
- en: (define child-x (record-accessor rtd/child 0))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: (define child-x (record-accessor rtd/child 0))
- en: (define set-child-x! (record-mutator rtd/child 0))
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: (define set-child-x! (record-mutator rtd/child 0))
- en: (define child-y (record-accessor rtd/child 1))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: (define child-y (record-accessor rtd/child 1))
- en: (record-mutator rtd/child 1) ![<graphic>](ch2_0.gif) *exception: immutable field*
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: (record-mutator rtd/child 1) ![<graphic>](ch2_0.gif) *异常：不可变字段*
- en: (define rcd/parent
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: (define rcd/parent
- en: (make-record-constructor-descriptor rtd/parent #f
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: (make-record-constructor-descriptor rtd/parent #f
- en: (lambda (new) (lambda (x) (new (* x x))))))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (new) (lambda (x) (new (* x x))))))
- en: (record-type-descriptor? rcd/parent) ![<graphic>](ch2_0.gif) #f
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: (record-type-descriptor? rcd/parent) ![<graphic>](ch2_0.gif) #f
- en: (define make-parent (record-constructor rcd/parent))
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: (define make-parent (record-constructor rcd/parent))
- en: (define p (make-parent 10))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: (define p (make-parent 10))
- en: (parent? p) ![<graphic>](ch2_0.gif) #t
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: (parent? p) ![<graphic>](ch2_0.gif) #t
- en: (parent-x p) ![<graphic>](ch2_0.gif) 100
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: (parent-x p) ![<graphic>](ch2_0.gif) 100
- en: (set-parent-x! p 150)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (set-parent-x! p 150)
- en: (parent-x p) ![<graphic>](ch2_0.gif) 150
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: (parent-x p) ![<graphic>](ch2_0.gif) 150
- en: (define rcd/child
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: (define rcd/child
- en: (make-record-constructor-descriptor rtd/child rcd/parent
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: (make-record-constructor-descriptor rtd/child rcd/parent
- en: (lambda (pargs->new)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (pargs->new)
- en: (lambda (x y)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: (lambda (x y)
- en: ((pargs->new x) (+ x 5) y)))))
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ((pargs->new x) (+ x 5) y)))))
- en: (define make-child (record-constructor rcd/child))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: (define make-child (record-constructor rcd/child))
- en: (define c (make-child 10 'cc))
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: (define c (make-child 10 'cc))
- en: (parent? c) ![<graphic>](ch2_0.gif) #t
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: (child? c) ![<graphic>](ch2_0.gif) #t
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: (child? p) ![<graphic>](ch2_0.gif) #f
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: (parent-x c) ![<graphic>](ch2_0.gif) 100
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: (child-x c) ![<graphic>](ch2_0.gif) 15
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: (child-y c) ![<graphic>](ch2_0.gif) cc
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: (child-x p) ![<graphic>](ch2_0.gif) *exception: invalid argument type*`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Section 9.3\. Inspection
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section describes various procedures for asking questions about or extracting
    information from record-type descriptors (rtds). It also describes the `record-rtd`
    procedure, with which the rtd of a non-opaque record instance may be extracted,
    allowing the record type of the instance to be inspected and, via record accessors
    and mutators generated from the rtd, the record itself to be inspected or modified.
    This is a powerful feature that permits the coding of portable record printers
    and inspectors.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The record-type descriptor cannot be extracted from an instance of an opaque
    record type; this is the feature that distinguishes opaque from non-opaque record
    types.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-type-name *rtd*)`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the name associated with `*rtd*`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs records inspection)`, `(rnrs)`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '`(define record->name'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (x)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: (and (record? x) (record-type-name (record-rtd x)))))
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type dim (fields w l h))
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: (record->name (make-dim 10 15 6)) ![<graphic>](ch2_0.gif) dim
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type dim (fields w l h) (opaque #t))
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: (record->name (make-dim 10 15 6)) ![<graphic>](ch2_0.gif) #f`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-type-parent *rtd*)`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the parent of `*rtd*`, or `#f` if it has no parent'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs records inspection)`, `(rnrs)`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type point (fields x y))'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type cpoint (parent point) (fields color))
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-parent (record-type-descriptor point)) ![<graphic>](ch2_0.gif) #f
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-parent (record-type-descriptor cpoint)) ![<graphic>](ch2_0.gif) #<rtd>`
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-type-uid *rtd*)`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the uid of `*rtd*`, or `#f` if it has no uid'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs records inspection)`, `(rnrs)`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Whether a record type created without a programmer-supplied uid actually has
    one anyway is left up to the implementation, so this procedure is never guaranteed
    to return `#f`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type point (fields x y))'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type cpoint
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: (parent point)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: (fields color)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: (nongenerative e40cc926-8cf4-4559-a47c-cac636630314))
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-uid (record-type-descriptor point)) ![<graphic>](ch2_0.gif) *unspecified*
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-uid (record-type-descriptor cpoint)) ![<graphic>](ch2_0.gif)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: e40cc926-8cf4-4559-a47c-cac636630314`
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-type-generative? *rtd*)`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the record type described by `*rtd*` is generative, `#f`
    otherwise'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-type-sealed? *rtd*)`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the record type described by `*rtd*` is sealed, `#f` otherwise'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-type-opaque? *rtd*)`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if the record type described by `*rtd*` is opaque, `#f` otherwise'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs records inspection)`, `(rnrs)`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type table'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: (fields keys vals)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: (opaque #t))
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: (define rtd (record-type-descriptor table))
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-generative? rtd) ![<graphic>](ch2_0.gif) #t
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-sealed? rtd) ![<graphic>](ch2_0.gif) #f
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-opaque? rtd) ![<graphic>](ch2_0.gif) #t
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type cache-table
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: (parent table)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: (fields key val)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: (nongenerative))
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: (define rtd (record-type-descriptor cache-table))
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-generative? rtd) ![<graphic>](ch2_0.gif) #f
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-sealed? rtd) ![<graphic>](ch2_0.gif) #f
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-opaque? rtd) ![<graphic>](ch2_0.gif) #t`
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-type-field-names *rtd*)`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** a vector containing the names of the fields of the type described
    by `*rtd*`'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs records inspection)`, `(rnrs)`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'The vector returned by this procedure is immutable: the effect on `*rtd*` of
    modifying it is unspecified. The vector does not include parent field names. The
    order of the names in the vector is the same as the order in which the fields
    were specified in the `define-record-type` form or `make-record-type-descriptor`
    call that created the record type.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type point (fields x y))'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type cpoint (parent point) (fields color))
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-field-names
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-descriptor point)) ![<graphic>](ch2_0.gif) #(x y)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-field-names
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: (record-type-descriptor cpoint)) ![<graphic>](ch2_0.gif) #(color)`
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-field-mutable? *rtd* *idx*)`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t if the specified field of *rtd*` is mutable, `#f` otherwise'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs records inspection)`, `(rnrs)`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '`*idx*` must be a nonnegative integer less than the number of fields of `*rtd*`,
    not counting parent fields. An `*idx*` value of 0 specifies the first field given
    in the `define-record-type` form or `make-record-type-descriptor` call that created
    the record type, 1 specifies the second, and so on.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type point (fields (mutable x) (mutable y)))'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type cpoint (parent point) (fields color))
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: (record-field-mutable? (record-type-descriptor point) 0) ![<graphic>](ch2_0.gif) #t
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: (record-field-mutable? (record-type-descriptor cpoint) 0) ![<graphic>](ch2_0.gif) #f`
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record? *obj*)`'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** `#t` if `*obj*` is a non-opaque record instance, `#f` otherwise'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs records inspection)`, `(rnrs)`'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: When passed an instance of an opaque record type, `record?` returns `#f`. While
    an instance of an opaque record type is, in essence, a record, the point of opacity
    is to hide all representation information from the parts of a program that should
    not have access to the information, and this includes whether an object is a record.
    Furthermore, the primary purpose of this predicate is to allow programs to check
    whether it is possible to obtain from the argument an rtd via the `record-rtd`
    procedure described below.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type statement (fields str))'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: (define q (make-statement "He's dead, Jim"))
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: (statement? q) ![<graphic>](ch2_0.gif) #t
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: (record? q) ![<graphic>](ch2_0.gif) #t
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type opaque-statement (fields str) (opaque #t))
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: (define q (make-opaque-statement "He's moved on, Jim"))
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: (opaque-statement? q) ![<graphic>](ch2_0.gif) #t
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: (record? q) ![<graphic>](ch2_0.gif) #f`
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '**procedure**: `(record-rtd *record*)`'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '**returns:** the record-type descriptor (rtd) of `*record*`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '**libraries:** `(rnrs records inspection)`, `(rnrs)`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The argument must be an instance of a non-opaque record type. In combination
    with some of the other procedures described in this section and Section [9.2](records.html#g140),
    `record-rtd` allows the inspection or mutation of record instances, even if the
    type of the instance is unknown to the inspector. This capability is illustrated
    by the procedure `print-fields` below, which accepts a record argument and writes
    the name and value of each field of the record.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '`(define print-fields'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: (lambda (r)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: (unless (record? r)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: (assertion-violation 'print-fields "not a record" r))
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: (let loop ([rtd (record-rtd r)])
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: (let ([prtd (record-type-parent rtd)])
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: (when prtd (loop prtd)))
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: (let* ([v (record-type-field-names rtd)]
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[n (vector-length v)])'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: (do ([i 0 (+ i 1)])
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: ((= i n))
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: (write (vector-ref v i))
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: (display "=")
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: (write ((record-accessor rtd i) r))
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: (newline))))))`
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'With the familiar definitions of `point` and `cpoint`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '`(define-record-type point (fields x y))'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: (define-record-type cpoint (parent point) (fields color))`
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: the expression `(print-fields (make-cpoint -3 7 'blue))` displays the following
    three lines.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`x=-3'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: y=7
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: color=blue`
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
