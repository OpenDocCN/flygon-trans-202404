- en: Compound Procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already know how to define simple procedures such as `square`. The standard
    way to define a procedure is `(define (name formal-parameters) body)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vocab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compound Procedure: a compound procedure is a procedure that is defined in
    terms of Racket primitive procedures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: the name of the procedure is a symbol used to refer to the procedure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Formal Parameters: the formal parameters of a procedure are the names used
    within the body of the procedure to refer to the arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Body: the body of the procedure is the "meat" of the procedure. It is formally
    defined as "an expression that will yield the value of the procedure application
    when the formal parameters are replaced by the actual arguments to which the procedure
    is applied", but you can think of it as instructions for the computer to follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the procedure definition `(define (square x) (* x x))`, the *name* is `square`,
    the *formal parameter* is `x`, and the *body* is `(* x x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose I define a procedure as such: `(define (foo x y) (+ (* 3 x) (* 4 y)))`.
    Please answer the following questions.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the name of the above procedure?What are the two formal parameters?What
    is the body of the procedure?
  prefs: []
  type: TYPE_NORMAL
- en: Procedures with Multiple Formal Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Procedures don''t have to have just one formal parameter, such as in `square`.
    They can also have multiple formal parameters. The way to create procedures with
    multiple arguments is fairly straightforward. It looks something like this: `(define
    (foo x y z) (* x y z))`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create procedures with no arguments at all! The code for that looks
    something like this: `(define (foo) 3))`. Now, whenever you call `(foo)`, it will
    return 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Procedure-Ception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most useful (and coolest!) parts about programming is that, once
    you've defined a procedure, not only can you can use it over and over again, you
    can also use it to define other procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you''re probably sick of `square` right now, let''s use another function
    as an example. Let''s define a predicate `vowel?`, and use it to define another
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (vowel? letter) (member? letter ''(a e i o u))`'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `vowel?`, we can use it in different procedures. For example,
    one of the problems in 0.3 deals with Pig Latin. If a word starts with a vowel,
    translating that word into Pig Latin is as simple as adding "ay" to the end of
    the word. We're not going to worry about translating words into Pig Latin right
    now; we're just going to define yet another predicate to check if a word starts
    with a vowel.
  prefs: []
  type: TYPE_NORMAL
- en: '`(define (pig-complete? wd) (vowel? (first wd)))`'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we used one user-defined procedure (`vowel?`), to define another
    one.
  prefs: []
  type: TYPE_NORMAL
