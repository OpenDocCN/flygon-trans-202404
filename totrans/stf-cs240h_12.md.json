["```\ndata Int32 = I32# Int# deriving (Eq, Ord, Typeable) instance Num Int32 where (I32# x#) + (I32# y#) = I32# (narrow32Int# (x# +# y#)) ...\n```", "```\nnewtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)) returnIO :: a -> IO a returnIO x = IO $ \\ s -> (# s, x #) bindIO :: IO a -> (a -> IO b) -> IO b bindIO (IO m) k = IO $ \\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s\n```", "```\nunsafePerformIO :: IO a -> a unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m) unsafeDupablePerformIO :: IO a -> a unsafeDupablePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)\n```", "```\nvariables, literals, let, case, lambda abstraction, application\n```", "```\ndata Expr b -- \"b\" for the type of binders,  = Var Id | Lit Literal | App (Expr b) (Arg b) | Lam b (Expr b) | Let (Bind b) (Expr b) | Case (Expr b) b Type [Alt b] | Type Type | Cast (Expr b) Coercion | Coercion Coercion | Tick (Tickish Id) (Expr b) data Bind b = NonRec b (Expr b) | Rec [(b, (Expr b))] type Arg b = Expr b type Alt b = (AltCon, [b], Expr b) data AltCon = DataAlt DataCon | LitAlt Literal | DEFAULT\n```", "```\nidChar :: Char -> Char idChar c = c\n```", "```\nidChar :: GHC.Types.Char -> GHC.Types.Char [GblId, Arity=1, Caf=NoCafRefs] idChar = \\ (c :: GHC.Types.Char) -> c\n```", "```\nid :: a -> a id x = x idChar2 :: Char -> Char idChar2 = id\n```", "```\nid :: forall a. a -> a id = \\ (@ a) (x :: a) -> x idChar2 :: GHC.Types.Char -> GHC.Types.Char idChar2 = id @ GHC.Types.Char\n```", "```\nmap :: (a -> b) -> [a] -> [b] map _ [] = [] map f (x:xs) = f x : map f xs\n```", "```\nmap :: forall a b. (a -> b) -> [a] -> [b] map = \\ (@ a) (@ b) (f :: a -> b) (xs :: [a]) -> case xs of _ { [] -> GHC.Types.[] @ b; : y ys -> GHC.Types.: @ b (f y) (map @ a @ b f ys) }\n```", "```\ncase e of result { __DEFAULT -> result }\n```", "```\ndox :: Int -> Int dox n = x * x where x = n + 2\n```", "```\ndox :: GHC.Types.Int -> GHC.Types.Int dox = \\ (n :: GHC.Types.Int) -> let {  x :: GHC.Types.Int x = GHC.base.plusInt n (GHC.Types.I# 2) } in GHC.base.multInt x x\n```", "```\niff :: Bool -> a -> a -> a iff True x _ = x iff False _ y = y\n```", "```\niff :: forall a. GHC.Bool.Bool -> a -> a -> a iff = \\ (@ a) (d :: GHC.Bool.Bool) (x :: a) (y :: a) -> case d of _ GHC.Bool.False -> y GHC.Bool.True -> x\n```", "```\ntypeclass MyEnum a where  toId :: a -> Int  fromId :: Int -> a\n```", "```\ndata MyEnum a = DMyEnum (a -> Int) (Int -> a) toId :: forall a. MyEnum a => a -> GHC.Types.Int toId = \\ (@ a) (d :: MyEnum a) (x :: a) -> case d of _ DMyEnum f1 _ -> f1 x fromId :: forall a. MyEnum a => GHC.Types.Int -> a fromId = \\ (@ a) (d :: MyEnum a) (x :: a) -> case d of _ DMyEnum _ f2 -> f2 x\n```", "```\ninstance MyEnum Int where toId = id fromId = id\n```", "```\nfMyEnumInt :: MyEnum GHC.Types.Int fMyEnumInt = DMyEnum @ GHC.Types.Int (id @ GHC.Types.Int) (id @ GHC.Types.Int)\n```", "```\ninstance (MyEnum a) => MyEnum (Maybe a) where toId (Nothing) = 0 toId (Just n) = toId n fromId 0 = Nothing fromId n = Just $ fromId n\n```", "```\nfMyEnumMaybe :: forall a. MyEnum a => MyEnum (Maybe a) fMyEnumMaybe = \\ (@ a) (dict :: MyEnum a) -> DMyEnum @ (Maybe a) (fMyEnumMaybe_ctoId @ a dict) (fMyEnumMaybe_cfromId @ a dict) fMyEnumMaybe_ctoId :: forall a. MyEnum a => Maybe a -> Int fMyEnumMaybe_ctoId = \\ (@ a) (dict :: MyEnum a) (mx :: Maybe a) -> case mx of _ Nothing -> I# 0 Just n -> case (toId @ a dict n) of _ I# y -> I# (1 +# y)\n```", "```\ndata Point = Point {-# UNPACK #-} !Int {-# UNPACK #-} !Int\n```", "```\ndata Point = Point Int# Int#\n```", "```\naddP :: P -> Int addP (P x y ) = x + y\n```", "```\naddP :: P -> Int addP = \\ (p :: P) -> case p of _ { P x y -> case +# x y of z { __DEFAULT -> I# z } }\n```", "```\nmodule M where {-# NOINLINE add #-} add x y = x + y module P where addP_bad (P x y) = add x y\n```", "```\naddP_bad = \\ (p :: P) -> case p of _ { P x y -> let { x' = I# x y' = I# y  } in M.add x' y' }\n```", "```\nFun Fact: Estimated that functional languages gain 20 - 40% improvement from inlining Vs. imperative languages which gain 10 - 15%\n```", "```\nfac :: Int -> Int -> Int fac x 0 = a fac x n = fac (n*x) (n-1)\n```", "```\nfac :: Int -> Int -> Int fac = \\ (x :: Int) (n :: Int) -> case n of _ { I# n# -> case n# of _ 0# -> x __DEFAULT -> let { one = I# 1 n' = n - one x' = n * x } in fac x' n'\n```", "```\nwfac :: Int# -> Int# -> Int# wfac = \\ x# n# -> case n# of _ 0# -> x# _ -> case (n# -# 1#) of n'# _ -> case (n# *# x#) of x'# _ -> $wfac x'# n'# fac :: Int -> Int -> Int fac = \\ a n -> case a of I# a# -> case n of I# n# -> case ($wfac a# n#) of r# -> I# r#\n```", "```\ndrop :: Int -> [a] -> [a] drop n [] = [] drop 0 xs = xs drop n (x:xs) = drop (n-1) xs\n```", "```\ndrop n xs = case xs of [] -> [] (y:ys) -> case n of I# n# -> case n# of 0 -> [] _ -> let n' = I# (n# -# 1#) in drop n' ys\n```", "```\ndrop n xs = case xs of [] -> [] (y:ys) -> case n of I# n# -> case n# of 0 -> [] _ -> drop' (n# -# 1#) xs -- works with unboxed n drop' n# xs = case xs of [] -> [] (y:ys) -> case n# of 0# -> [] _ -> drop (n# -# 1#) xs\n```", "```\n    ghc -ddump-stg A.hs > A.stg\n    ```", "```\nmap :: (a -> b) -> [a] -> [b] map f [] = [] map f (x:xs) = f x : map f xs\n```", "```\nmap :: forall a b. (a -> b) -> [a] -> [b] map = \\r [f xs] case xs of _ [] -> [] [] : z zs -> let { bds = \\u [] map f zs; bd = \\u [] f z; } in : [bd bds]\n```", "```\nf g = let x = 2 + 2 in (g x, x)\n```", "```\nf g = let x = 2 + 2 in (g x, x)\n```", "```\ndata G = G (Int -> Int) {-# UNPACK #-} !Int\n```", "```\njmp Sp[0]\n```", "```\nf = \\x -> let g = \\y -> x + y in g x\n```", "```\nfoldr (:)\n```", "```\nrange = [1..100]\n```", "```\nmk :: Int -> Int mk x = x + 1\n```", "```\n// thunk entry - setup stack, evaluate x mk_entry() entry: if (Sp - 24 < SpLim) goto gc; I64[Sp - 16] = stg_upd_frame_info; // setup update frame (closure type) I64[Sp - 8] = R1; // set thunk to be updated (payload) I64[Sp - 24] = mk_exit; // setup continuation (+) continuation Sp = Sp - 24; // increase stack R1 = I64[R1 + 8]; // grab 'x' from environment jump I64[R1] (); // eval 'x' gc: jump stg_gc_enter_1 (); }\n```", "```\nmk :: Int -> Int mk x = x + 1\n```", "```\n// thunk exit - setup value on heap, tear-down stack mk_exit() entry: Hp = Hp + 16; if (Hp > HpLim) goto gc; v::I64 = I64[R1] + 1; // perform ('x' + 1) I64[Hp - 8] = GHC_Types_I_con_info; // setup Int closure I64[Hp + 0] = v::I64; R1 = Hp; // point R1 to computed thunk value Sp = Sp + 8; // pop stack jump (I64[Sp + 0]) (); // jump to continuation ('stg_upd_frame_info') gc: HpAlloc = 16; jump stg_gc_enter_1 (); }\n```", "```\nmk :: Int -> Int mk x = x + 1\n```", "```\nmk_entry() entry: ... R1 = I64[R1 + 16]; // grab 'x' from environment if (R1 & 7 != 0) goto cxd; // check if 'x' is eval'd jump I64[R1] (); // not eval'd so eval cxd: jump mk_exit (); // 'x' eval'd so jump to (+) continuation } mk_exit() cx0: I64[Hp - 8] = ghczmprim_GHCziTypes_Izh_con_info; // setup Int closure I64[Hp + 0] = v::I64; // setup Int closure R1 = Hp - 7; // point R1 to computed thunk value (with tag) ... }\n```", "```\ndata MyBool a = MTrue a | MFalse a\n```"]