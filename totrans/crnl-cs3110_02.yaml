- en: 'Lecture 2: Syntax and Evaluation of OCaml Programs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Summary of topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: OCaml syntax
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression, terms, types, and values
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation and rewrite rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces and scope
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualified identifiers and libraries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OCaml syntax
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous recitation, you should have seen a few simple expression and
    declaration forms for OCaml.  The syntax of this fragment of the language can
    be summarized as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '| syntactic class | syntactic variable(s) and grammar rule(s) | examples |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: '| **identifiers** | *x, f* | `a`, `x`, `y`, `x_y`, `foo1000`, ... |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| **constants** | *c* | ...`-2`, `-1`, `0`, `1`, `2` (integers) `1.0`, `-0.001`,
    `3.141` (floats)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '`true`, `false` (booleans)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`"hello"`, `""`, `"!"` (strings)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '`''A''`, `'' ''`, `''\n''` (characters) |'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '| **unary operator** | *u* | `-`, `not` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| **binary operators** | *b* | `+`, `*`, `-`, `>`, `<`, `>=`, `<=`, `^`, `!=`,
    ... |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| **terms** | *e* ::= *x*  &#124;  *c * &#124;  *u e  &#124;  e*[1]* b e*[2]
    *&#124;*`if`* e *`then`* e* `else`* e  &#124;  *`let` *d*[1] `and`...`and` *d[n]*`in`*e*
     &#124;  *e* `(`*e*[1]`,` ...`,` *e**[n]*`)` | `foo`, `-0.001`, `not` `b`, `2+2`
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| **declarations** | *d* ::= *x = e  &#124;  * * f *`(` *x*[1], ...,  *x[n]*`):`
    *t* =  *e* | `one = 1 square(x:int):int = x*x` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| **types** | *t* ::= `int`  &#124;  `float`  &#124;  `bool`  &#124;  `string`
     &#124;  `char`  &#124;  *t*[1]`*`...`*`*t[n]*`->`*t* | `int`, `string`, `int->int`,
    `bool*int->bool` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: A program in OCaml, like any other language, is made up of various kinds of
    **expressions**. The table above describes how to construct some of those expressions.
    That is, it specifies some of the syntax of OCaml. Some of these expressions,
    such as identifiers, constants, and operators, we have described only by example.
    These expressions are all single **tokens**. Other expressions, such as terms,
    declarations, and types, are described by **grammar rules**. These rules are written
    in a form known as BNF, for **B**ackus-**N**aur **F**orm (named after its inventors).
    Each rule describes various ways to build a particular kind of expression, separated
    by vertical bars. For example, a term may be an identifier, a constant, any unary
    operator *u* followed by any expression *e* (*u e*), any two terms *e*[1] and
    *e*[2] separated by any binary operator *b*, and so on. Notice that we use the
    letter *u* to represent any unary operator and the letter *e* to represent any
    term. These are examples of **syntactic variables** or **metavariables**. A syntactic
    variable is not an OCaml program variable; it is just a generic name for a certain
    syntactic construct. For instance, *x* can be any identifier, and *e* can be any
    expression. We sometimes stick subscripts on syntactic variables to help us keep
    them distinct (as is done above), but this is not necessary.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The OCaml interpreter allows either terms or declarations to be typed at the
    prompt. We can think of a program as being just an OCaml expression, although
    later we'll see it is more complex.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Program errors
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just because an expression has legal syntax doesn't mean that it is legal; the
    expression must also be well-typed. That is, it must use expressions only in accordance
    with their types. We will look at what it means for an expression to be well-typed
    in more detail later in the course. In general, it is useful to think of a type
    as a set of possible values (usually an infinite set). We will see that OCaml
    has a powerful, expressive type system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, there are many ways that an expression in OCaml can be wrong,
    like in English:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '*Syntax errors*: `let 0 x =`; "Spot run see"'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Type errors*: `"x" + 3`; "See Spot ran"'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Semantic errors*: 1/0; "Colorless green ideas sleep furiously" (good grammar,
    incoherent semantics)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*More general errors*: OCaml program that correctly computes the wrong answer,
    "Officer, you wouldn''t dare give me a ticket!"'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, how do we write expressions and declarations? Here is a declaration of
    a simple function that computes the absolute value of a given integer:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Equivalently, one could write
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: or more briefly,
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every expression and declaration has both a *type* and a *value*.  When you
    type an expression or declaration into the OCaml top-level, it will report both
    the type and the value of the expression.  If we type the definition of `abs`
    at the OCaml prompt, followed by ;; to let the OCaml interpreter know that the
    expression should now be evaluated, it responds with
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: which means that we have just bound the name `abs` to a function whose type
    is `int -> int`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a function that determines whether its argument is a prime number. The
    type of the function is `int -> bool`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a couple things to notice about this program. First, note the use
    of the recursive helper function `noDivisors` that is declared inside the function
    `isPrime`. The function is defined with `let rec` because it is recursive. This
    function would be written with a loop in an imperative language, but an appropriately
    named helper function can be clearer to read than a generic loop. The scope of
    the declaration is the body of the declaration itself and the expression following
    the `in`; it is not available anywhere else.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Here is a function that finds an approximation to the square root of a given
    floating point number.  It is based on the fact that for any positive numbers
    *x* and *g*, the numbers *g* and *x*/*g* lie on opposite sides of sqrt(*x*). 
    This is because their product is *x*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is example shows a number of things.  First, you can declare local values
    such as `delta` and local functions such as `goodEnough`, `improve`, and `tryGuess`. 
    Notice that "inner" functions, such as `improve`, can refer to "outer" variables
    (such as `x`).  Also notice that later declarations can refer to earlier declarations. 
    For instance, `tryGuess` refers to both `goodEnough` and `improve`.  Actually,
    the later declarations are inside the `in` expressions of the earlier ones.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type the `squareRoot` declaration above into the OCaml top-level, it
    responds with:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'indicating that you''ve declared a variable (`squareRoot`), that its value
    is a function (`<fun>`), and that its type is a function from float to float. 
    All of the internal structure of the function definition is hidden; all we know
    from the outside is that its value is a simple function `float -> float`.  In
    particular, the function `tryGuess` is not defined outside of `squareRoot`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After typing in the function, you might try it out on a floating point number
    such as 9.0:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: OCaml has evaluated the expression `squareRoot 9.0` and printed its value (`3.0000000013969839`)
    and its type (`float`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: At the moment we have only an imprecise notion of exactly what happens when
    you type this expression into OCaml.  We will have a more precise understanding
    soon.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to apply `squareRoot` to an expression that does not have type float
    (say an integer or a boolean), then you''ll get a type error:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: where carets (`^^^`) are used to indicate the erroneous expression.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Qualified Identifiers and the Library
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Qualified identifiers are of the form *x.y* where *x* is a **module** identifier. 
    Examples include `String.length`, `List.map`, and `String.sub`. As in Java with
    packages and classes, in OCaml qualified identifiers allow a set of names to be
    grouped together in a separate code module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The OCaml prompt lets you type either a term or a declaration that binds a
    variable to a term. It **evaluates** the term to produce a **value**: a term that
    does not need any further evaluation. We can define values *v* as a syntactic
    class too. For now, we can think of values as just being the same as constants,
    though we''ll see there is much more to them.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Running an OCaml program is just evaluating a term. What happens when we evaluate
    a term? In an imperative (non-functional) language like Java, we sometimes imagine
    that there is an idea of a "current statement" that is executing. This isn''t
    a very good model for OCaml; it is better to think of OCaml programs as being
    evaluated in the same way that you would evaluate a mathematical expression. For
    example, if you see an expression like (1+2)*3, you know that you first evaluate
    the subexpression 1+2, getting a new expression 3*3\. Then you evaluate 3*3\.
    OCaml evaluation works the same way. As each point in time, the OCaml evaluator
    takes the left-most expression that is not a value and **rewrites** (or **reduces**)
    it to some simpler expression. Eventually the whole expression is a value and
    then evaluation stops: the program is done. Or maybe the expression never reduces
    to a value, in which case you have an infinite loop.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'OCaml has a bunch of built-in rules for rewriting terms that go well beyond
    simple arithmetic. Consider the if expression. It has two important rewrite rules:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the evaluator runs into an if expression, the first thing it does is try
    to reduce the conditional expression to either true or false. Then it can apply
    one of the two rules here.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果评估器遇到一个if表达式，它首先尝试将条件表达式简化为true或false。然后它可以应用这里的两条规则中的一条。
- en: Substitution
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换
- en: 'The `let` expression is also evaluated using rewrite rules. It works by first
    evaluating all of its bindings. Then those bindings are substituted into the **body**
    of the `let` expression (the expression after the `in`). For example, here is
    a sequence of evaluation steps using `let`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用重写规则也会对`let`表达式进行评估。它的工作原理是首先评估所有的绑定。然后，这些绑定被替换到`let`表达式的**主体**（`in`之后的表达式）中。例如，下面是使用`let`的一系列评估步骤：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Function calls are the most interesting case. When a function is called, OCaml
    does a similar subsitution: it substitutes the values passed as arguments into
    the body of the function. Consider evaluating `abs(2+1)`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用是最有趣的情况。当调用函数时，OCaml会进行类似的替换：它将传递的参数值替换到函数的主体中。考虑评估`abs(2+1)`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a simple start on how to think about evaluation; we'll have more to
    say about evaluation in a couple of lectures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的开始，介绍了如何思考评估问题；我们将在接下来的几堂课上进一步讨论评估问题。
