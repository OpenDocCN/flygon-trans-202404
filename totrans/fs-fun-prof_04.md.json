["```\n// single line comments use a double slash\n(* multi line comments use (* . . . *) pair\n\n-end of multi line comment- *)\n\n// ======== \"Variables\" (but not really) ==========\n// The \"let\" keyword defines an (immutable) value\nlet myInt = 5\nlet myFloat = 3.14\nlet myString = \"hello\"    //note that no types needed\n\n// ======== Lists ============\nlet twoToFive = [2;3;4;5]        // Square brackets create a list with\n                                 // semicolon delimiters.\nlet oneToFive = 1 :: twoToFive   // :: creates list with new 1st element\n// The result is [1;2;3;4;5]\nlet zeroToFive = [0;1] @ twoToFive   // @ concats two lists\n\n// IMPORTANT: commas are never used as delimiters, only semicolons!\n\n// ======== Functions ========\n// The \"let\" keyword also defines a named function.\nlet square x = x * x          // Note that no parens are used.\nsquare 3                      // Now run the function. Again, no parens.\n\nlet add x y = x + y           // don't use add (x,y)! It means something\n                              // completely different.\nadd 2 3                       // Now run the function.\n\n// to define a multiline function, just use indents. No semicolons needed.\nlet evens list =\n   let isEven x = x%2 = 0     // Define \"isEven\" as an inner (\"nested\") function\n   List.filter isEven list    // List.filter is a library function\n                              // with two parameters: a boolean function\n                              // and a list to work on\n\nevens oneToFive               // Now run the function\n\n// You can use parens to clarify precedence. In this example,\n// do \"map\" first, with two args, then do \"sum\" on the result.\n// Without the parens, \"List.map\" would be passed as an arg to List.sum\nlet sumOfSquaresTo100 =\n   List.sum ( List.map square [1..100] )\n\n// You can pipe the output of one operation to the next using \"|>\"\n// Here is the same sumOfSquares function written using pipes\nlet sumOfSquaresTo100piped =\n   [1..100] |> List.map square |> List.sum  // \"square\" was defined earlier\n\n// you can define lambdas (anonymous functions) using the \"fun\" keyword\nlet sumOfSquaresTo100withFun =\n   [1..100] |> List.map (fun x->x*x) |> List.sum\n\n// In F# returns are implicit -- no \"return\" needed. A function always\n// returns the value of the last expression used.\n\n// ======== Pattern Matching ========\n// Match..with.. is a supercharged case/switch statement.\nlet simplePatternMatch =\n   let x = \"a\"\n   match x with\n    | \"a\" -> printfn \"x is a\"\n    | \"b\" -> printfn \"x is b\"\n    | _ -> printfn \"x is something else\"   // underscore matches anything\n\n// Some(..) and None are roughly analogous to Nullable wrappers\nlet validValue = Some(99)\nlet invalidValue = None\n\n// In this example, match..with matches the \"Some\" and the \"None\",\n// and also unpacks the value in the \"Some\" at the same time.\nlet optionPatternMatch input =\n   match input with\n    | Some i -> printfn \"input is an int=%d\" i\n    | None -> printfn \"input is missing\"\n\noptionPatternMatch validValue\noptionPatternMatch invalidValue\n\n// ========= Complex Data Types =========\n\n// Tuple types are pairs, triples, etc. Tuples use commas.\nlet twoTuple = 1,2\nlet threeTuple = \"a\",2,true\n\n// Record types have named fields. Semicolons are separators.\ntype Person = {First:string; Last:string}\nlet person1 = {First=\"john\"; Last=\"Doe\"}\n\n// Union types have choices. Vertical bars are separators.\ntype Temp = \n    | DegreesC of float\n    | DegreesF of float\nlet temp = DegreesF 98.6\n\n// Types can be combined recursively in complex ways.\n// E.g. here is a union type that contains a list of the same type:\ntype Employee = \n  | Worker of Person\n  | Manager of Employee list\nlet jdoe = {First=\"John\";Last=\"Doe\"}\nlet worker = Worker jdoe\n\n// ========= Printing =========\n// The printf/printfn functions are similar to the\n// Console.Write/WriteLine functions in C#.\nprintfn \"Printing an int %i, a float %f, a bool %b\" 1 2.0 true\nprintfn \"A string %s, and something generic %A\" \"hello\" [1;2;3;4]\n\n// all complex types have pretty printing built in\nprintfn \"twoTuple=%A,\\nPerson=%A,\\nTemp=%A,\\nEmployee=%A\" \n         twoTuple person1 temp worker\n\n// There are also sprintf/sprintfn functions for formatting data\n// into a string, similar to String.Format. \n```"]