["```\n1 + 2 = 3 \n```", "```\n1 + (2 + 3) = (1 + 2) + 3 \n```", "```\n1 + 0 = 1 and 0 + 1 = 1 \n```", "```\n\"\" + \"hello\" = \"hello\"\n\"hello\" + \"\" = \"hello\" \n```", "```\n[] @ [1;2;3] = [1;2;3]\n[1;2;3] @ [] = [1;2;3] \n```", "```\n1 + 2 = 3\n1 + (2 + 3) = (1 + 2) + 3\n1 + 0 = 1 and 0 + 1 = 1 \n```", "```\nlet x = 1.0/0.0 // infinity\nlet y = x * 2.0 // two times infinity \nlet z = 2.0 / x // two divided by infinity \n```", "```\nlet sumUpTo2 = 1 + 2\nlet sumUpTo3 = sumUpTo2 + 3\nlet sumUpTo4 = sumUpTo3 + 4\n// etc\nlet result = sumUpTo7 + 8 \n```", "```\nlet sum1To4 = 1 + 2 + 3 + 4\nlet sum5To8 = 5 + 6 + 7 + 8\nlet result = sum1To4 + sum5To8 \n```", "```\nlet sum1To2 = 1 + 2 \nlet sum3To4 = 3 + 4\nlet sum1To4 = sum1To2 + sum3To4 \n```", "```\n// ok\n[1..10] |> List.reduce (+)\n\n// error\n[] |> List.reduce (+)  \n\n// ok with explicit zero\n[1..10] |> List.fold (+) 0 \n\n// ok with explicit zero\n[] |> List.fold (+) 0 \n```", "```\n[1..4] |> List.fold (*) 1  // result is 24\n[] |> List.fold (*) 1      // result is 1 \n```", "```\nMonoid Aggregation : 'T list -> 'T \n```", "```\nlet s1 = \"hello\"\nlet s2 = \" world!\"\n\n// closure\nlet sum = s1 + s2  // sum is a string\n\n// associativity\nlet s3 = \"x\"\nlet s4a = (s1+s2) + s3  \nlet s4b = s1 + (s2+s3)\nassert (s4a = s4b)\n\n// an empty string is the identity\nassert (s1 + \"\" = s1)\nassert (\"\" + s1 = s1) \n```", "```\ntype OrderLine = {\n    ProductCode: string\n    Qty: int\n    Total: float\n    } \n```", "```\nlet calculateOrderTotal lines = \n    let mutable total = 0.0\n    for line in lines do\n        total <- total + line.Total\n    total \n```", "```\nmodule OrdersUsingImperativeLoop = \n\n    type OrderLine = {\n        ProductCode: string\n        Qty: int\n        Total: float\n        }\n\n    let calculateOrderTotal lines = \n        let mutable total = 0.0\n        for line in lines do\n            total <- total + line.Total\n        total\n\n    let orderLines = [\n        {ProductCode=\"AAA\"; Qty=2; Total=19.98}\n        {ProductCode=\"BBB\"; Qty=1; Total=1.99}\n        {ProductCode=\"CCC\"; Qty=3; Total=3.99}\n        ]\n\n    orderLines \n    |> calculateOrderTotal \n    |> printfn \"Total is %g\" \n```", "```\nmodule OrdersUsingFold = \n\n    type OrderLine = {\n        ProductCode: string\n        Qty: int\n        Total: float\n        }\n\n    let calculateOrderTotal lines = \n        let accumulateTotal total line = \n            total + line.Total\n        lines \n        |> List.fold accumulateTotal 0.0 \n\n    let orderLines = [\n        {ProductCode=\"AAA\"; Qty=2; Total=19.98}\n        {ProductCode=\"BBB\"; Qty=1; Total=1.99}\n        {ProductCode=\"CCC\"; Qty=3; Total=3.99}\n        ]\n\n    orderLines \n    |> calculateOrderTotal \n    |> printfn \"Total is %g\" \n```", "```\nlet addLine orderLine1 orderLine2 =\n    orderLine1.Total + orderLine2.Total \n```", "```\naddLine : OrderLine -> OrderLine -> float \n```", "```\nlet addLine orderLine1 orderLine2 =\n    {\n    ProductCode = \"TOTAL\"\n    Qty = orderLine1.Qty + orderLine2.Qty\n    Total = orderLine1.Total + orderLine2.Total\n    } \n```", "```\n// utility method to print an OrderLine\nlet printLine {ProductCode=p; Qty=q;Total=t} = \n    printfn \"%-10s %5i %6g\" p q t \n\nlet orderLine1 = {ProductCode=\"AAA\"; Qty=2; Total=19.98}\nlet orderLine2 = {ProductCode=\"BBB\"; Qty=1; Total=1.99}\n\n//add two lines to make a third\nlet orderLine3 = addLine orderLine1 orderLine2 \norderLine3 |> printLine // and print it \n```", "```\nTOTAL          3  21.97 \n```", "```\nlet orderLines = [\n    {ProductCode=\"AAA\"; Qty=2; Total=19.98}\n    {ProductCode=\"BBB\"; Qty=1; Total=1.99}\n    {ProductCode=\"CCC\"; Qty=3; Total=3.99}\n    ]\n\norderLines \n|> List.reduce addLine\n|> printLine \n```", "```\nTOTAL          6  25.96 \n```", "```\nlet printReceipt lines = \n    lines \n    |> List.iter printLine\n\n    printfn \"-----------------------\"\n\n    lines \n    |> List.reduce addLine\n    |> printLine\n\norderLines \n|> printReceipt \n```", "```\nAAA            2  19.98\nBBB            1   1.99\nCCC            3   3.99\n-----------------------\nTOTAL          6  25.96 \n```", "```\nlet subtotal = orderLines |> List.reduce addLine \nlet newLine = {ProductCode=\"DDD\"; Qty=1; Total=29.98}\nlet newSubtotal = subtotal |> addLine newLine \nnewSubtotal |> printLine \n```", "```\nlet (++) a b = addLine a b  // custom operator\n\nlet newSubtotal = subtotal ++ newLine \n```", "```\nlet addLine orderLine1 orderLine2 =\n    match orderLine1.ProductCode, orderLine2.ProductCode with\n    // is one of them zero? If so, return the other one\n    | \"\", _ -> orderLine2\n    | _, \"\" -> orderLine1\n    // anything else is as before\n    | _ -> \n        {\n        ProductCode = \"TOTAL\"\n        Qty = orderLine1.Qty + orderLine2.Qty\n        Total = orderLine1.Total + orderLine2.Total\n        }\n\nlet zero = {ProductCode=\"\"; Qty=0; Total=0.0}\nlet orderLine1 = {ProductCode=\"AAA\"; Qty=2; Total=19.98} \n```", "```\nassert (orderLine1 = addLine orderLine1 zero)\nassert (orderLine1 = addLine zero orderLine1) \n```", "```\ntype OrderLine = {\n    ProductCode: string\n    Qty: int\n    Price: float\n    Total: float\n    } \n```", "```\nlet addLine orderLine1 orderLine2 =\n    {\n    ProductCode = \"TOTAL\"\n    Qty = orderLine1.Qty + orderLine2.Qty\n    Price = 0 // or use average price? \n    Total = orderLine1.Total + orderLine2.Total\n    } \n```", "```\ntype ProductLine = {\n    ProductCode: string\n    Qty: int\n    Price: float\n    LineTotal: float\n    }\n\ntype TotalLine = {\n    Qty: int\n    OrderTotal: float\n    }\n\ntype OrderLine = \n    | Product of ProductLine\n    | Total of TotalLine \n```", "```\nlet addLine orderLine1 orderLine2 =\n    let totalLine = \n        match orderLine1,orderLine2 with\n        | Product p1, Product p2 ->\n            {Qty = p1.Qty + p2.Qty;\n            OrderTotal = p1.LineTotal + p2.LineTotal}\n        | Product p, Total t ->\n            {Qty = p.Qty + t.Qty;\n            OrderTotal = p.LineTotal + t.OrderTotal}\n        | Total t, Product p ->\n            {Qty = p.Qty + t.Qty;\n            OrderTotal = p.LineTotal + t.OrderTotal}\n        | Total t1, Total t2 ->\n            {Qty = t1.Qty + t2.Qty;\n            OrderTotal = t1.OrderTotal + t2.OrderTotal}\n    Total totalLine // wrap totalLine to make OrderLine \n```", "```\nlet printLine =  function\n    | Product {ProductCode=p; Qty=q; Price=pr; LineTotal=t} -> \n        printfn \"%-10s %5i @%4g each %6g\" p q pr t \n    | Total {Qty=q; OrderTotal=t} -> \n        printfn \"%-10s %5i            %6g\" \"TOTAL\" q t \n```", "```\nlet orderLine1 = Product {ProductCode=\"AAA\"; Qty=2; Price=9.99; LineTotal=19.98}\nlet orderLine2 = Product {ProductCode=\"BBB\"; Qty=1; Price=1.99; LineTotal=1.99}\nlet orderLine3 = addLine orderLine1 orderLine2 \n\norderLine1 |> printLine \norderLine2 |> printLine \norderLine3 |> printLine \n```", "```\ntype ProductLine = {\n    ProductCode: string\n    Qty: int\n    Price: float\n    LineTotal: float\n    }\n\ntype TotalLine = {\n    Qty: int\n    OrderTotal: float\n    }\n\ntype OrderLine = \n    | Product of ProductLine\n    | Total of TotalLine\n    | EmptyOrder \n```", "```\nlet addLine orderLine1 orderLine2 =\n    match orderLine1,orderLine2 with\n    // is one of them zero? If so, return the other one\n    | EmptyOrder, _ -> orderLine2\n    | _, EmptyOrder -> orderLine1\n    // otherwise as before\n    | Product p1, Product p2 ->\n        Total { Qty = p1.Qty + p2.Qty;\n        OrderTotal = p1.LineTotal + p2.LineTotal}\n    | Product p, Total t ->\n        Total {Qty = p.Qty + t.Qty;\n        OrderTotal = p.LineTotal + t.OrderTotal}\n    | Total t, Product p ->\n        Total {Qty = p.Qty + t.Qty;\n        OrderTotal = p.LineTotal + t.OrderTotal}\n    | Total t1, Total t2 ->\n        Total {Qty = t1.Qty + t2.Qty;\n        OrderTotal = t1.OrderTotal + t2.OrderTotal} \n```", "```\nlet zero = EmptyOrder\n\n// test identity\nlet productLine = Product {ProductCode=\"AAA\"; Qty=2; Price=9.99; LineTotal=19.98}\nassert (productLine = addLine productLine zero)\nassert (productLine = addLine zero productLine)\n\nlet totalLine = Total {Qty=2; OrderTotal=19.98}\nassert (totalLine = addLine totalLine zero)\nassert (totalLine = addLine zero totalLine) \n```", "```\ntype OrderLine with\n    static member (+) (x,y) = addLine x y \n    static member Zero = EmptyOrder   // a property \n```", "```\nlet lines1 = [productLine]\n// using fold with explicit op and zero\nlines1 |> List.fold addLine zero |> printfn \"%A\"  \n// using sum with implicit op and zero\nlines1 |> List.sum |> printfn \"%A\"  \n\nlet emptyList: OrderLine list = []\n// using fold with explicit op and zero\nemptyList |> List.fold addLine zero |> printfn \"%A\"  \n// using sum with implicit op and zero\nemptyList |> List.sum |> printfn \"%A\" \n```", "```\nmodule StringMonoid =\n\n    // define extension method\n    type System.String with\n        static member Zero = \"\" \n\n    // OK.\n    [\"a\";\"b\";\"c\"] \n    |> List.reduce (+)    \n    |> printfn \"Using reduce: %s\"\n\n    // OK. String.Zero is visible as an extension method\n    [\"a\";\"b\";\"c\"] \n    |> List.fold (+) System.String.Zero\n    |> printfn \"Using fold: %s\"\n\n    // Error. String.Zero is NOT visible to List.sum\n    [\"a\";\"b\";\"c\"] \n    |> List.sum          \n    |> printfn \"Using sum: %s\" \n```", "```\nopen System\n\ntype Customer = {\n    Name:string // and many more string fields!\n    LastActive:DateTime \n    TotalSpend:float } \n```", "```\n// create a type to track customer statistics\ntype CustomerStats = {\n    // number of customers contributing to these stats\n    Count:int \n    // total number of days since last activity\n    TotalInactiveDays:int \n    // total amount of money spent\n    TotalSpend:float } \n```", "```\nlet add stat1 stat2 = {\n    Count = stat1.Count + stat2.Count;\n    TotalInactiveDays = stat1.TotalInactiveDays + stat2.TotalInactiveDays\n    TotalSpend = stat1.TotalSpend + stat2.TotalSpend\n    }\n\n// define an infix version as well\nlet (++) a b = add a b \n```", "```\n// convert a customer to a stat\nlet toStats cust =\n    let inactiveDays= DateTime.Now.Subtract(cust.LastActive).Days;\n    {Count=1; TotalInactiveDays=inactiveDays; TotalSpend=cust.TotalSpend}\n\n// create a list of customers\nlet c1 = {Name=\"Alice\"; LastActive=DateTime(2005,1,1); TotalSpend=100.0}\nlet c2 = {Name=\"Bob\"; LastActive=DateTime(2010,2,2); TotalSpend=45.0}\nlet c3 = {Name=\"Charlie\"; LastActive=DateTime(2011,3,3); TotalSpend=42.0}\nlet customers = [c1;c2;c3]\n\n// aggregate the stats\ncustomers \n|> List.map toStats\n|> List.reduce add\n|> printfn \"result = %A\" \n```", "```\ntype Text = Text of string \n```", "```\nlet addText (Text s1) (Text s2) =\n    Text (s1 + s2) \n```", "```\nlet t1 = Text \"Hello\"\nlet t2 = Text \" World\"\nlet t3 = addText t1 t2 \n```", "```\nlet wordCount (Text s) =\n    s.Split(' ').Length\n\n// test\nText \"Hello world\"\n|> wordCount\n|> printfn \"The word count is %i\" \n```", "```\nmodule WordCountTest = \n    open System \n\n    type Text = Text of string\n\n    let addText (Text s1) (Text s2) =\n        Text (s1 + s2)\n\n    let wordCount (Text s) =\n        System.Text.RegularExpressions.Regex.Matches(s,@\"\\S+\").Count \n```", "```\nmodule WordCountTest = \n\n    // code as above\n\n    let page() = \n        List.replicate 1000 \"hello \"\n        |> List.reduce (+)\n        |> Text\n\n    let document() = \n        page() |> List.replicate 1000 \n```", "```\nmodule WordCountTest = \n\n    // code as above\n\n    let time f msg = \n        let stopwatch = Diagnostics.Stopwatch()\n        stopwatch.Start()\n        f() \n        stopwatch.Stop()\n        printfn \"Time taken for %s was %ims\" msg stopwatch.ElapsedMilliseconds \n```", "```\nmodule WordCountTest = \n\n    // code as above\n\n    let wordCountViaAddText() = \n        document() \n        |> List.reduce addText\n        |> wordCount\n        |> printfn \"The word count is %i\"\n\n    time wordCountViaAddText \"reduce then count\" \n```", "```\nmodule WordCountTest = \n\n    // code as above\n\n    let wordCountViaMap() = \n        document() \n        |> List.map wordCount\n        |> List.reduce (+)\n        |> printfn \"The word count is %i\"\n\n    time wordCountViaMap \"map then reduce\" \n```", "```\n|> List.reduce addText\n|> wordCount \n```", "```\n|> List.map wordCount\n|> List.reduce (+) \n```", "```\nmodule WordCountTest = \n\n    // code as above\n\n    let wordCountViaParallelAddCounts() = \n        document() \n        |> List.toArray\n        |> Array.Parallel.map wordCount\n        |> Array.reduce (+)\n        |> printfn \"The word count is %i\"\n\n    time wordCountViaParallelAddCounts \"parallel map then reduce\" \n```", "```\nTime taken for reduce then count was 7955ms\nTime taken for map then reduce was 698ms\nTime taken for parallel map then reduce was 603ms \n```", "```\nmodule FrequentWordTest = \n\n    open System \n    open System.Text.RegularExpressions\n\n    type Text = Text of string\n\n    let addText (Text s1) (Text s2) =\n        Text (s1 + s2)\n\n    let mostFrequentWord (Text s) =\n        Regex.Matches(s,@\"\\S+\")\n        |> Seq.cast<Match>\n        |> Seq.map (fun m -> m.ToString())\n        |> Seq.groupBy id\n        |> Seq.map (fun (k,v) -> k,Seq.length v)\n        |> Seq.sortBy (fun (_,v) -> -v)\n        |> Seq.head\n        |> fst \n```", "```\nmodule FrequentWordTest = \n\n    // code as above \n\n    let page1() = \n        List.replicate 1000 \"hello world \"\n        |> List.reduce (+)\n        |> Text\n\n    let page2() = \n        List.replicate 1000 \"goodbye world \"\n        |> List.reduce (+)\n        |> Text\n\n    let page3() = \n        List.replicate 1000 \"foobar \"\n        |> List.reduce (+)\n        |> Text\n\n    let document() = \n        [page1(); page2(); page3()] \n```", "```\nmodule FrequentWordTest = \n\n    // code as above \n\n    document() \n    |> List.reduce addText\n    |> mostFrequentWord\n    |> printfn \"Using add first, the most frequent word is %s\"\n\n    document() \n    |> List.map mostFrequentWord\n    |> List.reduce (+)\n    |> printfn \"Using map reduce, the most frequent word is %s\" \n```", "```\nUsing add first, the most frequent word is world\nUsing map reduce, the most frequent word is hellogoodbyefoobar \n```", "```\nwordCount(page1) + wordCount(page2) EQUALS wordCount(page1 + page) \n```", "```\nmostFrequentWord(page1) + mostFrequentWord(page2) NOT EQUAL TO mostFrequentWord(page1 + page) \n```", "```\nGiven a function that maps from one monoid to another (like 'wordCount' or 'mostFrequentWord')\n\nThen to be a monoid homomorphism, the function must meet the requirement that:\n\nfunction(chunk1) + function(chunk2) MUST EQUAL function(chunk1 + chunk2) \n```", "```\ntype MyType = {count:int; items:int list}\n\nlet addMyType t1 t2 = \n    {count = t1.count + t2.count; \n     items = t1.items @ t2.items} \n```", "```\n'a' + 'b' -> what? \n```", "```\n'a' + 'b' -> \"ab\" // Closure fail! \n```", "```\n\"a\" + \"b\" -> \"ab\" \n```", "```\n['a'] @ ['b'] -> ['a'; 'b'] // Lists FTW! \n```", "```\nmodule MonoidalChar =\n    open System\n\n    /// \"monoidal char\"\n    type MChar = MChar of Char list\n\n    /// convert a char into a \"monoidal char\"\n    let toMChar ch = MChar [ch]\n\n    /// add two monoidal chars\n    let addChar (MChar l1) (MChar l2) = \n        MChar (l1 @ l2)\n\n    // infix version\n    let (++) = addChar  \n\n    /// convert to a string\n    let toString (MChar cs) = \n        new System.String(List.toArray cs) \n```", "```\nopen MonoidalChar\n\n// add two chars and convert to string\nlet a = 'a' |> toMChar\nlet b = 'b' |> toMChar\nlet c = a ++ b\nc |> toString |> printfn \"a + b = %s\"  \n// result: \"a + b = ab\" \n```", "```\n[' '..'z']   // get a lot of chars\n|> List.filter System.Char.IsPunctuation\n|> List.map toMChar\n|> List.reduce addChar\n|> toString\n|> printfn \"punctuation chars are %s\" \n// result: \"punctuation chars are !\"#%&'()*,-./:;?@[\\]_\" \n```", "```\nmodule Validation = \n\n    type ValidationResult = \n        | Success\n        | Failure of string\n\n    let validateBadWord badWord (name:string) =\n        if name.Contains(badWord) then\n            Failure (\"string contains a bad word: \" + badWord)\n        else \n            Success \n\n    let validateLength maxLength name =\n        if String.length name > maxLength then\n            Failure \"string is too long\"\n        else \n            Success \n```", "```\nlet result1 = Failure \"string is null or empty\"\nlet result2 = Failure \"string is too long\"\n\nresult1 + result2 = ???? \n```", "```\nmodule MonoidalValidation = \n\n    type ValidationResult = \n        | Success\n        | Failure of string list\n\n    // helper to convert a single string into the failure case\n    let fail str =\n        Failure [str]\n\n    let validateBadWord badWord (name:string) =\n        if name.Contains(badWord) then\n            fail (\"string contains a bad word: \" + badWord)\n        else \n            Success \n\n    let validateLength maxLength name =\n        if String.length name > maxLength then\n            fail \"string is too long\"\n        else \n            Success \n```", "```\nmodule MonoidalValidation = \n\n    // as above\n\n    /// add two results\n    let add r1 r2 = \n        match r1,r2 with\n        | Success,    Success -> Success \n        | Failure f1, Success -> Failure f1\n        | Success,    Failure f2 -> Failure f2\n        | Failure f1, Failure f2 -> Failure (f1 @ f2) \n```", "```\nopen MonoidalValidation \n\nlet test1 = \n    let result1 = Success\n    let result2 = Success\n    add result1 result2 \n    |> printfn \"Result is %A\"\n    // \"Result is Success\"\n\nlet test2 = \n    let result1 = Success\n    let result2 = fail \"string is too long\"\n    add result1 result2 \n    |> printfn \"Result is %A\"\n    // \"Result is Failure [\"string is too long\"]\"\n\nlet test3 = \n    let result1 = fail \"string is null or empty\"\n    let result2 = fail \"string is too long\"\n    add result1 result2 \n    |> printfn \"Result is %A\"\n\n    // Result is Failure \n    //   [ \"string is null or empty\"; \n    //     \"string is too long\"] \n```", "```\nlet test4 = \n    let validationResults str = \n        [\n        validateLength 10\n        validateBadWord \"monad\"\n        validateBadWord \"cobol\"\n        ]\n        |> List.map (fun validate -> validate str)\n\n    \"cobol has native support for monads\"\n    |> validationResults \n    |> List.reduce add\n    |> printfn \"Result is %A\" \n```", "```\nResult is Failure\n  [\"string is too long\"; \"string contains a bad word: monad\";\n   \"string contains a bad word: cobol\"] \n```", "```\nmodule MonoidalValidation = \n\n    // as above\n\n    // identity\n    let zero = Success \n```", "```\nlet test5 = \n    let validationResults str = \n        []\n        |> List.map (fun validate -> validate str)\n\n    \"cobol has native support for monads\"\n    |> validationResults \n    |> List.fold add zero\n    |> printfn \"Result is %A\"\n\n    // Result is Success \n```", "```\ntype Text = Text of string\n\nlet addText (Text s1) (Text s2) =\n    Text (s1 + s2) \n```", "```\ntype Text = Text of string list\n\nlet addText (Text s1) (Text s2) =\n    Text (s1 @ s2) \n```", "```\n//same as (12 - 3) - 2\n[12;3;2] |> List.reduce (-)  // => 7 \n\n//same as ((12 - 3) - 2) - 1\n[12;3;2;1] |> List.reduce (-)  // => 6 \n```", "```\n//same as 12 - (3 - 2)\n[12;3;2] |> List.reduceBack (-) // => 11\n\n//same as 12 - (3 - (2 - 1))\n[12;3;2;1] |> List.reduceBack (-) // => 10 \n```", "```\nlet subtractChars (s1:string) (s2:string) = \n    let isIncluded (ch:char) = s2.IndexOf(ch) = -1\n    let chars = s1.ToCharArray() |> Array.filter isIncluded\n    System.String(chars)\n\n// infix version \nlet (--) = subtractChars \n```", "```\n\"abcdef\" -- \"abd\"   //  \"cef\"\n\"abcdef\" -- \"\"      //  \"abcdef\" \n```", "```\n(\"abc\" -- \"abc\") -- \"abc\"  // \"\"\n\"abc\" -- (\"abc\" -- \"abc\")  // \"abc\" \n```", "```\nlet removalAction = (subtract \"abd\") // a data structure \n```", "```\nlet removalAction = (subtract \"abd\") \nremovalAction |> applyTo \"abcdef\"  // \"Result is cef\" \n```", "```\nlet removalAction = (subtract \"abc\") + (subtract \"abc\") + (subtract \"abc\")   \nremovalAction |> applyTo \"abc\"    // \"Result is \" \n```", "```\n/// store a list of chars to remove\ntype CharsToRemove = CharsToRemove of Set<char>\n\n/// construct a new CharsToRemove\nlet subtract (s:string) = \n    s.ToCharArray() |> Set.ofArray |>  CharsToRemove \n\n/// apply a CharsToRemove to a string\nlet applyTo (s:string) (CharsToRemove chs) = \n    let isIncluded ch = Set.exists ((=) ch) chs |> not\n    let chars = s.ToCharArray() |> Array.filter isIncluded\n    System.String(chars)\n\n// combine two CharsToRemove to get a new one\nlet (++) (CharsToRemove c1) (CharsToRemove c2) = \n    CharsToRemove (Set.union c1 c2) \n```", "```\nlet test1 = \n    let removalAction = (subtract \"abd\") \n    removalAction |> applyTo \"abcdef\" |> printfn \"Result is %s\"\n    // \"Result is cef\"\n\nlet test2 = \n    let removalAction = (subtract \"abc\") ++ (subtract \"abc\") ++ (subtract \"abc\")   \n    removalAction |> applyTo \"abcdef\" |> printfn \"Result is %s\"\n    // \"Result is \" \n```", "```\n// reverse for partial application\nlet subtract str charsToSubtract = \n    subtractChars charsToSubtract str \n\nlet removalAction = subtract \"abd\" \n\"abcdef\" |> removalAction |> printfn \"Result is %s\"\n// \"Result is cef\" \n```", "```\n(subtract \"abc\") + (subtract \"abc\") + (subtract \"abc\")  = ? \n```", "```\nlet removalAction2 = (subtract \"abc\") >> (subtract \"abc\") >> (subtract \"abc\") \nremovalAction2 \"abcdef\" |> printfn \"Result is %s\"\n// \"Result is def\" \n```", "```\ntype OrderLine = \n    | Product of ProductLine\n    | Total of TotalLine\n    | EmptyOrder \n```", "```\nlet addLine orderLine1 orderLine2 =\n    match orderLine1,orderLine2 with\n    // is one of them zero? If so, return the other one\n    | EmptyOrder, _ -> orderLine2\n    | _, EmptyOrder -> orderLine1\n    // logic for other cases ... \n```", "```\ntype PositiveNumberOrIdentity = \n    | Positive of int\n    | Zero\n\nlet addPositive i1 i2 =\n    match i1,i2 with\n    | Zero, _ -> i2\n    | _, Zero -> i1\n    | Positive p1, Positive p2 -> Positive (p1 + p2) \n```", "```\ntype NormalOrIdentity<'T> = \n    | Normal of 'T\n    | Zero \n```", "```\nlet optionAdd o1 o2 =\n    match o1, o2 with\n    | None, _ -> o2\n    | _, None -> o1\n    | Some s1, Some s2 -> Some (s1 + s2) \n```", "```\nlet optionAdd f o1 o2 =\n    match o1, o2 with\n    | None, _ -> o2\n    | _, None -> o1\n    | Some s1, Some s2 -> Some (f s1 s2) \n```", "```\ntype PositiveNumberOrIdentity = int option\nlet addPositive = optionAdd (+) \n```", "```\n// create some values\nlet p1 = Some 1\nlet p2 = Some 2\nlet zero = None\n\n// test addition\naddPositive p1 p2\naddPositive p1 zero\naddPositive zero p2\naddPositive zero zero \n```", "```\n[1..10]\n|> List.map Some\n|> List.fold addPositive zero \n\n[]\n|> List.map Some\n|> List.fold addPositive zero \n```", "```\ntype ValidationResult = \n    | Success\n    | Failure of string list \n```", "```\ntype ValidationFailure = \n    | Failure of string list\n    | Success \n```", "```\ntype ValidationFailure = string list option \n```", "```\nlet fail str =\n    Some [str] \n```", "```\nlet addFailure f1 f2 = optionAdd (@) f1 f2 \n```", "```\nmodule MonoidalValidationOption = \n\n    type ValidationFailure = string list option\n\n    // helper to convert a string into the failure case\n    let fail str =\n        Some [str]\n\n    let validateBadWord badWord (name:string) =\n        if name.Contains(badWord) then\n            fail (\"string contains a bad word: \" + badWord)\n        else \n            None\n\n    let validateLength maxLength name =\n        if String.length name > maxLength then\n            fail \"string is too long\"\n        else \n            None\n\n    let optionAdd f o1 o2 =\n        match o1, o2 with\n        | None, _ -> o2\n        | _, None -> o1\n        | Some s1, Some s2 -> Some (f s1 s2)\n\n    /// add two results using optionAdd\n    let addFailure f1 f2 = optionAdd (@) f1 f2\n\n    // define the Zero \n    let Success = None\n\nmodule MonoidalValidationOptionTest =\n    open MonoidalValidationOption \n\n    let test1 = \n        let result1 = Success\n        let result2 = Success\n        addFailure result1 result2 \n        |> printfn \"Result is %A\"\n\n        // Result is <null>\n\n    let test2 = \n        let result1 = Success\n        let result2 = fail \"string is too long\"\n        addFailure result1 result2 \n        |> printfn \"Result is %A\"\n        // Result is Some [\"string is too long\"]\n\n    let test3 = \n        let result1 = fail \"string is null or empty\"\n        let result2 = fail \"string is too long\"\n        addFailure result1 result2 \n        |> printfn \"Result is %A\"\n        // Result is Some [\"string is null or empty\"; \"string is too long\"]\n\n    let test4 = \n        let validationResults str = \n            [\n            validateLength 10\n            validateBadWord \"monad\"\n            validateBadWord \"cobol\"\n            ]\n            |> List.map (fun validate -> validate str)\n\n        \"cobol has native support for monads\"\n        |> validationResults \n        |> List.reduce addFailure\n        |> printfn \"Result is %A\"\n        // Result is Some\n        //   [\"string is too long\"; \"string contains a bad word: monad\";\n        //    \"string contains a bad word: cobol\"]\n\n    let test5 = \n        let validationResults str = \n            []\n            |> List.map (fun validate -> validate str)\n\n        \"cobol has native support for monads\"\n        |> validationResults \n        |> List.fold addFailure Success\n        |> printfn \"Result is %A\"\n        // Result is <null> \n```", "```\nlet avg i1 i2 = \n    float (i1 + i2) / 2.0\n\n// test\navg 4 5 |> printfn \"Average is %g\"\n// Average is 4.5 \n```", "```\nlet avgf i1 i2 = \n    (i1 + i2) / 2.0\n\n// test\navgf (avgf 1.0 3.0) 5.0  |> printfn \"Average from left is %g\"\navgf 1.0 (avgf 3.0 5.0)  |> printfn \"Average from right is %g\"\n\n// Average from left is 3.5\n// Average from right is 2.5 \n```", "```\n// store all the info needed for an average\ntype Avg = {total:int; count:int}\n\n// add two Avgs together\nlet addAvg avg1 avg2 = \n    {total = avg1.total + avg2.total; \n     count = avg1.count + avg2.count} \n```", "```\nlet zero = {total=0; count=0} \n```", "```\nmodule Average = \n\n    // store all the info needed for an average\n    type Avg = {total:int; count:int}\n\n    // add two Avgs together\n    let addAvg avg1 avg2 = \n        {total = avg1.total + avg2.total; \n         count = avg1.count + avg2.count}\n\n    // inline version of add\n    let (++) = addAvg\n\n    // construct an average from a single number\n    let avg n = {total=n; count=1}\n\n    // calculate the average from the data.\n    // return 0 for empty lists\n    let calcAvg avg = \n        if avg.count = 0 \n        then 0.0  \n        else float avg.total / float avg.count\n\n    // alternative - return None for empty lists\n    let calcAvg2 avg = \n        if avg.count = 0 \n        then None\n        else Some (float avg.total / float avg.count)\n\n    // the identity\n    let zero = {total=0; count=0}\n\n    // test\n    addAvg (avg 4) (avg 5) \n    |> calcAvg \n    |> printfn \"Average is %g\"\n    // Average is 4.5\n\n    (avg 4) ++ (avg 5) ++ (avg 6) \n    |> calcAvg \n    |> printfn \"Average is %g\"\n    // Average is 5\n\n    // test\n    [1..10]\n    |> List.map avg\n    |> List.reduce addAvg\n    |> calcAvg\n    |> printfn \"Average is %g\"\n    // Average is 5.5 \n```", "```\nmostFrequentWord(text1) + mostFrequentWord(text2) \n```", "```\nmostFrequentWord( text1 + text2 ) \n```", "```\nmodule FrequentWordMonoid = \n\n    open System \n    open System.Text.RegularExpressions\n\n    type Text = Text of string\n\n    let addText (Text s1) (Text s2) =\n        Text (s1 + s2)\n\n    // return a word frequency map\n    let wordFreq (Text s) =\n        Regex.Matches(s,@\"\\S+\")\n        |> Seq.cast<Match>\n        |> Seq.map (fun m -> m.ToString())\n        |> Seq.groupBy id\n        |> Seq.map (fun (k,v) -> k,Seq.length v)\n        |> Map.ofSeq \n```", "```\nmodule FrequentWordMonoid = \n\n    // code from above\n\n    let page1() = \n        List.replicate 1000 \"hello world \"\n        |> List.reduce (+)\n        |> Text\n\n    let page2() = \n        List.replicate 1000 \"goodbye world \"\n        |> List.reduce (+)\n        |> Text\n\n    let page3() = \n        List.replicate 1000 \"foobar \"\n        |> List.reduce (+)\n        |> Text\n\n    let document() = \n        [page1(); page2(); page3()]\n\n    // show some word frequency maps\n    page1() |> wordFreq |> printfn \"The frequency map for page1 is %A\"\n    page2() |> wordFreq |> printfn \"The frequency map for page2 is %A\"\n\n    //The frequency map for page1 is map [(\"hello\", 1000); (\"world\", 1000)]\n    //The frequency map for page2 is map [(\"goodbye\", 1000); (\"world\", 1000)]\n\n    document() \n    |> List.reduce addText\n    |> wordFreq \n    |> printfn \"The frequency map for the document is %A\"\n\n    //The frequency map for the document is map [\n    //      (\"foobar\", 1000); (\"goodbye\", 1000); \n    //      (\"hello\", 1000); (\"world\", 2000)] \n```", "```\nmodule FrequentWordMonoid = \n\n    // code from above\n\n    // define addition for the maps\n    let addMap map1 map2 =\n        let increment mapSoFar word count = \n            match mapSoFar |> Map.tryFind word with\n            | Some count' -> mapSoFar |> Map.add word (count + count') \n            | None -> mapSoFar |> Map.add word count \n\n        map2 |> Map.fold increment map1 \n```", "```\nmodule FrequentWordMonoid = \n\n    // code from above\n\n    // as the last step,\n    // get the most frequent word in a map\n    let mostFrequentWord map = \n        let max (candidateWord,maxCountSoFar) word count =\n            if count > maxCountSoFar\n            then (word,count)\n            else (candidateWord,maxCountSoFar) \n\n        map |> Map.fold max (\"None\",0) \n```", "```\nmodule FrequentWordMonoid = \n\n    // code from above\n\n    document() \n    |> List.reduce addText\n    |> wordFreq\n    // get the most frequent word from the big map\n    |> mostFrequentWord\n    |> printfn \"Using add first, the most frequent word and count is %A\"\n\n    //Using add first, the most frequent word and count is (\"world\", 2000)\n\n    document() \n    |> List.map wordFreq\n    |> List.reduce addMap\n    // get the most frequent word from the merged smaller maps\n    |> mostFrequentWord\n    |> printfn \"Using map reduce, the most frequent and count is %A\"\n\n    //Using map reduce, the most frequent and count is (\"world\", 2000) \n```", "```\nmodule Performance =\n\n    let printHeader() =\n        printfn \"Label,ListSize,ReduceAndIterMs\" \n\n    // time the reduce and iter steps for a given list size and print the results\n    let time label reduce iter listSize = \n        System.GC.Collect() //clean up before starting\n        let stopwatch = System.Diagnostics.Stopwatch()\n        stopwatch.Start()\n        reduce() |> iter\n        stopwatch.Stop()\n        printfn \"%s,%iK,%i\" label (listSize/1000) stopwatch.ElapsedMilliseconds \n\n    let testListPerformance listSize = \n        let lists = List.init listSize (fun i -> [i.ToString()])\n        let reduce() = lists |> List.reduce (@) \n        let iter = List.iter ignore\n        time \"List.@\" reduce iter listSize \n\n    let testSeqPerformance_Append listSize = \n        let seqs = List.init listSize (fun i -> seq {yield i.ToString()})\n        let reduce() = seqs |> List.reduce Seq.append \n        let iter = Seq.iter ignore\n        time \"Seq.append\" reduce iter listSize \n\n    let testSeqPerformance_Yield listSize = \n        let seqs = List.init listSize (fun i -> seq {yield i.ToString()})\n        let reduce() = seqs |> List.reduce (fun x y -> seq {yield! x; yield! y})\n        let iter = Seq.iter ignore\n        time \"seq(yield!)\" reduce iter listSize \n\n    let testArrayPerformance listSize = \n        let arrays = List.init listSize (fun i -> [| i.ToString() |])\n        let reduce() = arrays |> List.reduce Array.append \n        let iter = Array.iter ignore\n        time \"Array.append\" reduce iter listSize \n\n    let testResizeArrayPerformance listSize  = \n        let resizeArrays = List.init listSize (fun i -> new ResizeArray<string>( [i.ToString()] ) ) \n        let append (x:ResizeArray<_>) y = x.AddRange(y); x\n        let reduce() = resizeArrays |> List.reduce append \n        let iter = Seq.iter ignore\n        time \"ResizeArray.append\" reduce iter listSize \n```", "```\nopen Performance\n\nprintHeader() \n\n[2000..4000..50000]\n|> List.iter testArrayPerformance \n\n[2000..4000..50000]\n|> List.iter testResizeArrayPerformance \n\n[2000..4000..50000]\n|> List.iter testListPerformance\n\n[2000..4000..50000]\n|> List.iter testSeqPerformance_Append \n\n[2000..4000..50000]\n|> List.iter testSeqPerformance_Yield \n```"]