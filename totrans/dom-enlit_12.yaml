- en: Chapter 7 - Text Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7.1 *Text* object overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Text in an HTML document is represented by instances of the *Text()* constructor
    function, which produces text nodes. When an HTML document is parsed the text
    mixed in among the elements of an HTML page are converted to text nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/kuz5Z](http://jsfiddle.net/domenlightenment/kuz5Z)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code above concludes that the *Text()* constructor function constructs the
    text node but keep in mind that *Text* inherits from *CharacterData*, *Node*,
    and *Object*.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 *Text* object & properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get accurate information pertaining to the available properties and methods
    on an *Text* node its best to ignore the specification and to ask the browser
    what is available. Examine the arrays created in the code below detailing the
    properties and methods available from a text node.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/Wj3uS](http://jsfiddle.net/domenlightenment/Wj3uS)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The available properties are many even if the inherited properties were not
    considered. Below I've hand pick a list of note worthy properties and methods
    for the context of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '*textContent*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*splitText()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*appendData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*deleteData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*insertData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*replaceData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*subStringData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*normalize()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*document.createTextNode()* (not a property or inherited property of text nodes
    but discussed in this chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3 White space creates *Text* nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a DOM is contstructed either by the browser or by programmatic means text
    nodes are created from white space as well as from text characters. After all,
    whitespace is a character. In the code below the second paragraph, conaining an
    empty space, has a child *Text* node while the first paragraph does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/YbtnZ](http://jsfiddle.net/domenlightenment/YbtnZ)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget that white space and text characters in the DOM are typically represented
    by a text node. This of course means that carriage returns are considered text
    nodes. In the code below we log a carriage return highlighting the fact that this
    type of character is in fact a text node.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/9FEzq](http://jsfiddle.net/domenlightenment/9FEzq)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*The reality is if you can input the character or whitespace into an html document
    using a keyboard then it can potentially be interputed as a text node. If you
    think about it, unless you minimze/compress the html document the average html
    page contains a great deal of whitespace and carriage return text nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Creating & Injecting *Text* Nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Text* nodes are created automatically for us when a browser interputs an HTML
    document and a corresponding DOM is built based on the contents of the document.
    After this fact, its also possible to programatically create *Text* nodes using
    *createTextNode()*. In the code below I create a text node and then inject that
    node into the live DOM tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/xC9q3](http://jsfiddle.net/domenlightenment/xC9q3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that we can also inject text nodes into programmatically created
    DOM structures as well. In the code below I place a text node inside of an *<p>*
    element before I inject it into the live DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/PdatJ](http://jsfiddle.net/domenlightenment/PdatJ)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 7.5 Getting a *Text* node value with *.data* or *nodeValue*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The text value/data represented by a *Text* node can be extracted from the node
    by using the *.data* or *nodeValue* property. Both of these return the text contained
    in a *Text* node. Below I demostrate both of these to retrive the value contained
    in the *<div>*.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/dPLkx](http://jsfiddle.net/domenlightenment/dPLkx)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the *<p>* contains two *Text* node and *Element* (i.e. *<strong>*)node.
    And that we are only getting the value of the first child node contained in the
    *<p>*.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting the length of the characters contained in a text node is as simple as
    accessing the length proerty of the node itself or the actual text value/data
    of the node (i.e. *document.querySelector('p').firstChild.length* or *document.querySelector('p').firstChild.data.length*
    or *document.querySelector('p').firstChild.nodeValue.length*)
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Maniputlating *Text* nodes with *appendData()*, *deleteData()*, *insertData()*,
    *replaceData()*, *subStringData()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *CharacterData* object that *Text* nodes inherits methods from provides
    the following methods for manipulating and extracting sub values from *Text* node
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '*appendData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*deleteData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*insertData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*replaceData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*subStringData()*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these are leverage in the code example below.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/B6AC6](http://jsfiddle.net/domenlightenment/B6AC6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These same manipulation and sub extraction methods can be leverage by *Comment*
    nodes
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 When mulitple sibling *Text* nodes occur
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, immediate sibling *Text* nodes do not occur because DOM trees created
    by browsers intelligently combines text nodes, however two cases exist that make
    sibling text nodes possible. The first case is rather obvious. If a text node
    contains an *Element* node (e.g. *<p>Hi, <strong>cody</strong> welcome!</p>*)
    than the text will be split into the proper node groupings. Its best to look at
    a code example as this might sound more complicted than it really is. In the code
    below the contents of the *<p>* element is not a single *Text* node it is in fact
    3 nodes, a *Text* node, *Element* node, and another *Text* node.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/2ZCn3](http://jsfiddle.net/domenlightenment/2ZCn3)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The next case occurs when we are programatically add *Text* nodes to an element
    we created in our code. In the code below I create a *<p>* element and then append
    two *Text* nodes to this element. Which results in sibling *Text* nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/jk3Jn](http://jsfiddle.net/domenlightenment/jk3Jn)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 7.8 Remove markup and return all child *Text* nodes using *textContent*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *textContent* property can be used to get all child text nodes, as well
    as to set the contents of a node to a specific *Text* node. When its used on a
    node to get the textual content of the node it will returned a concatenataed string
    of all text nodes contained with the node you call the method on. This functionality
    would make it very easy to extract all text nodes from an HTML document. Below
    I extract all of the text contained withing the *<body>* element. Notice that
    *textContent* gathers not just immediate child text nodes but all child text nodes
    no matter the depth of encapsulation inside of the node the method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When *textContent* is used to set the text contained within a node it will remove
    all child nodes first, replacing them with a single *Text* node. In the code below
    I replace all the nodes inside of the *<div>* element with a single *Text* node.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/m766T](http://jsfiddle.net/domenlightenment/m766T)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*### Notes'
  prefs: []
  type: TYPE_NORMAL
- en: '*textContent* returns *null* if used on the a document or doctype node.'
  prefs: []
  type: TYPE_NORMAL
- en: '*textContent* returns the contents from *<script>* and *<style>* elements'
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 The difference between *textContent* & *innerText*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the modern bowser, except Firefox, support a seeminly similiar property
    to *textContent* named *innerText*. However these properties are not the same.
    You should be aware of the following differences between *textContent* & *innerText*.
  prefs: []
  type: TYPE_NORMAL
- en: '*innerText* is aware of CSS. So if you have hidden text *innerText* ignores
    this text, whereas *textContent* will not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because *innerText* cares about CSS it will trigger a reflow, whereas *textContent*
    will not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*innerText* ignores the *Text* nodes contained in *<script>* and *<style>*
    elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*innerText*, unlike *textContent* will normalize the text that is returned.
    Just think of *textContent* as returning exactly what is in the document with
    the markup removed. This will include white space, line breaks, and carriage returns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*innerText* is considered to be non-standard and browser specific while *textContent*
    is implemented from the DOM specifications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you you intend to use *innerText* you'll have to create a work around for
    Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Combine sibling *Text* nodes into one text node using *normalize()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sibling *Text* nodes are typically only encountered when text is programaticly
    added to the DOM. To eliminate sibling *Text* nodes that contain no *Element*
    nodes we can use *normalize()*. This will concatenate sibling text nodes in the
    DOM into a single *Text* node. In the code below I create sibling text, append
    it to the DOM, then normalize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/LG9WR](http://jsfiddle.net/domenlightenment/LG9WR)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 7.11 Splitting a text node using *splitText()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When *splitText()* is called on a *Text* node it will alter the text node its
    being called on (leaving the text up to the offset) and return a new *Text* node
    that contains the text split off from the orginal text based on the offset. In
    the code below the text node *Hey Yo!* is split after *Hey* and *Hey* is left
    in the DOM while *Yo!* is turned into a new text node are returned by the *splitText()*
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/Tz5ce](http://jsfiddle.net/domenlightenment/Tz5ce)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]**'
  prefs: []
  type: TYPE_NORMAL
