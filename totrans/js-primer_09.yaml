- en: 変数と宣言
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://jsprimer.net/basic/variables/](https://jsprimer.net/basic/variables/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: プログラミング言語には、文字列や数値などのデータに名前をつけることで、繰り返し利用できるようにする**変数**という機能があります。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptには「これは変数です」という宣言をするキーワードとして、 `const`、`let`、`var`の3つがあります。
  prefs: []
  type: TYPE_NORMAL
- en: '`var`はもっとも古くからある変数宣言のキーワードですが、意図しない動作を作りやすい問題が知られています。 そのためECMAScript 2015で、`var`の問題を改善するために`const`と`let`という新しいキーワードが導入されました。'
  prefs: []
  type: TYPE_NORMAL
- en: この章では`const`、`let`、`var`の順に、それぞれの方法で宣言した変数の違いについて見ていきます。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#const)*[ES2015] `const`*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`const`キーワードでは、再代入できない変数の宣言とその変数が参照する値（初期値）を定義できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のように、`const`キーワードに続いて`変数名`を書き、代入演算子（`=`）の右辺に変数の`初期値`を書いて変数を定義できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 次のコードでは`bookTitle`という変数を宣言し、初期値が`"JavaScript Primer"`という文字列であることを定義しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`const`、`let`、`var`どのキーワードも共通の仕組みですが、変数同士を`,`（カンマ）で区切ることにより、同時に複数の変数を定義できます。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`bookTitle`と`bookCategory`という変数を順番に定義しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: これは次のように書いた場合と同じ意味になります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: また、`const`は再代入できない変数を宣言するキーワードです。 そのため、`const`キーワードで宣言した変数に対して、後から値を代入することはできません。
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`const`で宣言した変数`bookTitle`に対して値を再代入しているため、次のようなエラー（`TypeError`）が発生します。
    エラーが発生するとそれ以降の処理は実行されなくなります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 一般的に変数への再代入は「変数の値は最初に定義した値と常に同じである」という参照透過性と呼ばれるルールを壊すため、バグを発生させやすい要因として知られています。そのため、変数に対して値を再代入する必要がない場合は、`const`キーワードで変数宣言することを推奨しています。
  prefs: []
  type: TYPE_NORMAL
- en: 変数に値を再代入したいケースとして、ループなどの反復処理の途中で特定の変数が参照する値を変化させたい場合があります。 そのような場合には、変数への再代入が可能な`let`キーワードを利用します。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#let)*[ES2015] `let`*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`let`キーワードでは、値の再代入が可能な変数を宣言できます。 `let`の使い方は`const`とほとんど同じです。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`bookTitle`という変数を宣言し、初期値が`"JavaScript Primer"`という文字列であることを定義しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`let`は`const`とは異なり、初期値を指定しない変数も定義できます。 初期値が指定されなかった変数はデフォルト値として`undefined`という値で初期化されます（`undefined`は値が未定義ということを表す値です）。'
  prefs: []
  type: TYPE_NORMAL
- en: 次のコードでは、`bookTitle`という変数を宣言しています。 このとき`bookTitle`には初期値が指定されていないため、デフォルト値として`undefined`で初期化されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: この`let`で宣言された`bookTitle`という変数には、代入演算子（`=`）を使うことで値を代入できます。 代入演算子（`=`）の右側には変数へ代入する値を書きますが、ここでは`"JavaScript
    Primer"`という文字列を代入しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`let`で宣言した変数に対しては何度でも値の代入が可能です。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[](#var)*`var`*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`var`キーワードでは、値の再代入が可能な変数を宣言できます。 `var`の使い方は`let`とほとんど同じです。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`var`では、`let`と同じように初期値がない変数を宣言でき、変数に対して値の再代入もできます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[](#var-issues)*`var`の問題*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*`var`は`let`とよく似ていますが、`var`キーワードには同じ名前の変数を再定義できてしまう問題があります。'
  prefs: []
  type: TYPE_NORMAL
- en: '`let`や`const`では、同じ名前の変数を再定義しようとすると、次のような構文エラー（`SyntaxError`）が発生します。 そのため、間違えて変数を二重に定義してしまうというミスを防ぐことができます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 一方、`var`は同じ名前の変数を再定義できます。 これは意図せずに同じ変数名で定義してもエラーとならずに、値を上書きしてしまいます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: また`var`には変数の巻き上げと呼ばれる意図しない挙動があり、`let`や`const`ではこの問題が解消されています。 `var`による変数の巻き上げの問題については「[関数とスコープ](../function-scope/)」の章で解説します。
    そのため、現時点では「`let`は`var`を改善したバージョン」ということだけ覚えておくとよいです。
  prefs: []
  type: TYPE_NORMAL
- en: このように、`var`にはさまざまな問題があります。 また、ほとんどすべてのケースで`var`は`const`か`let`に置き換えが可能です。 そのため、これから書くコードに対して`var`を利用することは避けたほうがよいでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#why-add-let-and-const)*[コラム] なぜ`let`や`const`は追加されたのか？*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ECMAScript 2015では、`var`そのものを改善するのではなく、新しく`const`と`let`というキーワードを追加することで、`var`の問題を回避できるようにしました。`var`自体の動作を変更しなかったのは、後方互換性のためです。'
  prefs: []
  type: TYPE_NORMAL
- en: なぜなら、`var`の挙動自体を変更してしまうと、すでに`var`で書かれたコードの動作が変わってしまい、動かなくなるアプリケーションが出てくるためです。
    新しく`const`や`let`などのキーワードをECMAScript仕様に追加しても、そのキーワードを使っているソースコードは追加時点では存在しません。^([1](#fn_1))
    そのため、`const`や`let`が追加されても後方互換性には影響がありません。
  prefs: []
  type: TYPE_NORMAL
- en: このように、ECMAScriptでは機能を追加する際にも後方互換性を重視しているため、`var`自体の挙動は変更されませんでした。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#variable-name)*変数名に使える名前のルール*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*ここまでで`const`、`let`、`var`での変数宣言とそれぞれの特徴について見てきました。 どのキーワードにおいても宣言できる変数に利用できる名前のルールは同じです。
    また、このルールは変数の名前や関数の名前といったJavaScriptの識別子において共通するルールとなります。'
  prefs: []
  type: TYPE_NORMAL
- en: 変数名の名前（識別子）には、次のルールがあります。
  prefs: []
  type: TYPE_NORMAL
- en: 半角のアルファベット、`_`（アンダースコア）、`$`（ダラー）、数字を組み合わせた名前にする
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 変数名は数字から開始できない
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 予約語と被る名前は利用できない
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 変数の名前は、半角のアルファベットである`A`から`Z`（大文字）と`a`から`z`（小文字）、`_`（アンダースコア）、`$`（ダラー）、数字の`0`から`9`を組み合わせた名前にします。
    JavaScriptでは、アルファベットの大文字と小文字は区別されます。
  prefs: []
  type: TYPE_NORMAL
- en: これらに加えて、ひらがなや一部の漢字なども変数名に利用できますが、全角の文字列が混在すると環境によって扱いにくいこともあるためお勧めしません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 変数名に数字を含めることはできますが、変数名を数字から開始することはできません。 これは変数名と数値が区別できなくなってしまうためです。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: また、予約語として定義されているキーワードは変数名には利用できません。 予約語とは、`let`のように構文として意味を持つキーワードのことです。 予約語の一覧は[予約語
    - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Lexical_grammar)で確認できますが、基本的には構文として利用される名前が予約されています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[](#const-is-not-constant)*[コラム] `const`は定数ではない*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*`const`は「再代入できない変数」を定義する変数宣言であり、必ずしも定数を定義するわけではありません。 定数とは、一度定義した名前（変数名）が常に同じ値を示すものです。'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptでも、`const`宣言によって定数に近い変数を定義できます。 次のように、`const`宣言によって定義した変数を、変更できないプリミティブな値で初期化すれば、それは実質的に定数です。
    プリミティブな値とは、数値や文字列などオブジェクト以外のデータです（詳細は「[データ型とリテラル](../data-type/)」の章で解説します）。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: しかし、JavaScriptではオブジェクトなども`const`宣言できます。 次のコードのように、オブジェクトという値そのものは、初期化したあとでも変更できます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: このように、`const`で宣言した変数が常に同じ値を示すとは限らないため、定数とは呼べません （詳細は「[オブジェクト](../object/#const-and-object)」の章で解説します）。
  prefs: []
  type: TYPE_NORMAL
- en: また`const`には、変数名の命名規則はなく、代入できる値にも制限はありません。 そのため、`const`宣言の特性として「再代入できない変数」を定義すると理解しておくのがよいでしょう。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#summary)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では、JavaScriptにおける変数を宣言するキーワードとして`const`、`let`、`var`があることについて学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: '`const`は、再代入できない変数を宣言できる'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`let`は、再代入ができる変数を宣言できる'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var`は、再代入ができる変数を宣言できるが、いくつかの問題が知られている'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 変数の名前（識別子）には利用できる名前のルールがある
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var`はほとんどすべてのケースで`let`や`const`に置き換えが可能です。 `const`は再代入できない変数を定義するキーワードです。再代入を禁止することで、ミスから発生するバグを減らすことが期待できます。
    そのため変数を宣言する場合には、まず`const`で定義できないかを検討し、できない場合は`let`を使うことを推奨しています。'
  prefs: []
  type: TYPE_NORMAL
- en: ¹. `let`や`const`はECMAScript 2015以前に予約語として定義されていたため、既存のコードと衝突する可能性はありませんでした。
    [↩](#reffn_1 "Jump back to footnote [1] in the text.")********
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
