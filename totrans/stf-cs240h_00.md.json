["```\n    main = putStrLn \"Hello, world!\"\n    ```", "```\n    $ ghc --make hello [1 of 1] Compiling Main ( hello.hs, hello.o ) Linking hello ... $ ./hello Hello, world!\n    ```", "```\n    $ ghci hello.hs GHCi, version 7.6.3: http://www.haskell.org/ghc/ :? for help ... Ok, modules loaded: Main. *Main> main Hello, world! *Main> \n    ```", "```\n    x = 2 -- Two hyphens introduce a comment y = 3 -- ...that continues to end of line. main = let z = x + y -- let introduces local bindings in print z -- program will print 5\n    ```", "```\n    add arg1 arg2 = arg1 + arg2 -- defines function add five = add 2 3 -- invokes function add\n    ```", "```\n    bad = print add 2 3 -- error! (print should have only 1 argument)\n    ```", "```\n    main = print (add 2 3) -- ok, calls print with 1 argument, 5\n    ```", "```\n    x = 5 x = 6 -- error, cannot re-bind x\n    ```", "```\n    safeDiv x y = let q = div x y -- safe as q never evaluated if y == 0 in if y == 0 then 0 else q main = print (safeDiv 1 0) -- prints 0\n    ```", "```\n    x = 5 -- this x is not used in main main = let x = x + 1 -- introduces new x, defined in terms of itself in print x -- program \"diverges\" (i.e., loops forever)\n    ```", "```\n    long factorial (int n) { long result = 1; while (n > 1) result *= n--; return result; }\n    ```", "```\n    factorial n = if n > 1 then n * factorial (n-1) else 1\n    ```", "```\n        factorial n = if n > 1 then n * factorial (n-1) else 1\n        ```", "```\n    factorial n = let loop acc n' = if n' > 1 then loop (acc * n') (n' - 1) else acc in loop 1 n\n    ```", "```\n    factorial n = let loop acc n' | n' > 1 = loop (acc * n') (n' - 1) | otherwise = acc in loop 1 n\n    ```", "```\n    factorial n = loop 1 n where loop acc n' | n' > 1 = loop (acc * n') (n' - 1) | otherwise = acc\n    ```", "```\n    factorial n = loop 1 n where loop acc n' | n' > 1 = loop (acc * n) (n' - 1) -- bug | otherwise = acc\n    ```", "```\n    factorial n0 = loop 1 n0 where loop acc n | n > 1 = loop (acc * n) (n - 1) | otherwise = acc\n    ```", "```\n    x :: Integer x = (1 :: Integer) + (1 :: Integer) :: Integer\n    ```", "```\n    add :: Integer -> (Integer -> Integer) add arg1 arg2 = arg1 + arg2\n    ```", "```\n    *Main> :t add add :: Integer -> Integer -> Integer\n    ```", "```\n    data PointT = PointC Double Double deriving Show\n    ```", "```\n    data Point = Point Double Double deriving Show\n    ```", "```\n    data Point = Cartesian Double Double | Polar Double Double deriving Show\n    ```", "```\n    data Color = Red | Green | Blue | Violet deriving (Show, Eq, Enum)\n    ```", "```\n    data Point = Point Double Double deriving Show myPoint :: Point myPoint = Point 1.0 1.0\n    ```", "```\n    data Color = Red | Green | Blue | Violet deriving (Show, Eq, Enum) myColor :: Color myColor = Red\n    ```", "```\n    getX, getMaxCoord :: Point -> Double getX point = case point of Point x y -> x getMaxCoord (Point x y) | x > y = x | otherwise = y\n    ```", "```\n    isRed :: Color -> Bool isRed Red = True -- Only matches constructor Red isRed c = False -- Lower-case c just a variable\n    ```", "```\n    data Move = Rock | Paper | Scissors deriving (Eq, Read, Show, Enum, Bounded) data Outcome = Lose | Tie | Win deriving (Show, Eq, Ord)\n    ```", "```\nGHCi, version 7.6.3: http://www.haskell.org/ghc/ :? for help ... *Main> outcome Rock Paper Lose *Main> outcome Scissors Paper Win *Main> outcome Paper Paper Tie\n```", "```\ndata Move = Rock | Paper | Scissors deriving (Eq, Read, Show, Enum, Bounded) data Outcome = Lose | Tie | Win deriving (Show, Eq, Ord) -- | @outcome our_move their_move@ outcome :: Move -> Move -> Outcome outcome Rock Scissors = Win outcome Paper Rock = Win outcome Scissors Paper = Win outcome us them | us == them = Tie | otherwise = Lose\n```", "```\n    data Maybe a = Just a | Nothing\n    ```", "```\n    data Either a b = Left a | Right b\n    ```", "```\n    Prelude> :t Just True Just True :: Maybe Bool Prelude> :t Left True Left True :: Either Bool b \n    ```", "```\n    isJust :: Maybe a -> Bool -- note parametric polymorphism isJust (Just _) = True isJust Nothing = False\n    ```", "```\n    isRed Red = True isRed _ = False -- we don't need the non-red value\n    ```", "```\n    addMaybes mx my | Just x <- mx, Just y <- my = Just (x + y) addMaybes _ _ = Nothing\n    ```", "```\n    addMaybes (Just x) (Just y) = Just (x + y) addMaybes _ _ = Nothing\n    ```", "```\n    data List a = Cons a (List a) | Nil oneTwoThree = (Cons 1 (Cons 2 (Cons 3 Nil))) :: List Integer\n    ```", "```\n    oneTwoThree = 1:2:3:[] :: [Integer]\n    ```", "```\n    oneTwoThree' = [1, 2, 3] -- comma-separated elements within brackets oneTwoThree'' = [1..3] -- define list by a range\n    ```", "```\nhead :: [a] -> a head (x:_) = x head [] = error \"head: empty list\"\n```", "```\ntail :: [a] -> [a] -- all but first element tail (_:xs) = xs tail [] = error \"tail: empty list\"\n```", "```\na ++ b :: [a] -> [a] -> [a] -- infix operator concatenate lists [] ++ ys = ys (x:xs) ++ ys = x : xs ++ ys\n```", "```\nlength :: [a] -> Int -- This code is from language spec length [] = 0 -- GHC implements differently, why? length (_:l) = 1 + length l\n```", "```\nfilter :: (a -> Bool) -> [a] -> [a] filter pred [] = [] filter pred (x:xs) | pred x = x : filter pred xs | otherwise = filter pred xs\n```", "```\n    *Main> show $ Point 1.0 1.0 \"Point 1.0 1.0\" <-- could paste string into your source\n    ```", "```\n    data Point = Point Double Double deriving (Show, Read)\n    ```", "```\n    *Main> reads \"invalid Point 1 2\" :: [(Point, String)] [] *Main> reads \"Point 1 2\" :: [(Point, String)] [(Point 1.0 2.0,\"\")] *Main> reads \"Point 1 2 and some extra stuff\" :: [(Point, String)] [(Point 1.0 2.0,\" and some extra stuff\")] *Main> reads \"(Point 1 2)\" :: [(Point, String)] -- note parens OK [(Point 1.0 2.0,\"\")]\n    ```", "```\n    parseMove :: String -> Maybe Move\n    ```", "```\n*Main> parseMove \"Rock\" Just Rock *Main> parseMove \"Paper\" Just Paper *Main> parseMove \"Scissors plus extra junk\" Nothing\n```", "```\n    parseMove :: String -> Maybe Move parseMove str = case reads str of [(m, \"\")] -> Just m _ -> Nothing\n    ```", "```\n    parseMove :: String -> Maybe Move parseMove \"Rock\" = Just Rock parseMove \"Paper\" = Just Paper parseMove \"Scissors\" = Just Scissors parseMove _ = Nothing\n    ```", "```\n    parseMove :: String -> Maybe Move parseMove str = case reads str of [(m, rest)] | ok rest -> Just m _ -> Nothing where ok = all (`elem` \" \\r\\n\")\n    ```", "```\n    *Main> parseMove \"Rock \\r\\n\" Just Rock *Main> parseMove \"Rock \\r\\njunk\" Nothing\n    ```", "```\n    import Data.Char -- brings function isLower into scope countLowerCase :: String -> Int countLowerCase str = length (filter isLower str)\n    ```", "```\n    countLowerCase :: String -> Int countLowerCase = length . filter isLower\n    ```", "```\n    (f . g) x = f (g x)\n    ```", "```\n    process = countLowercase . toPigLatin . extractComments . unCompress\n    ```", "```\n    countLowercaseAndDigits :: String -> Int countLowercaseAndDigits = length . filter (\\c -> isLower c || isDigit c)\n    ```", "```\n     ... (\\(Right x) -> x) ...\n    ```", "```\n    stripPunctuation :: String -> String stripPunctuation = filter (`notElem` \"!#$%&*+./<=>?@\\\\^|-~:\") -- Note above string the SECOND argument to notElem ^\n    ```", "```\ninfixl 9 !! -- This is the default when fixity unspecified infixr 9 . infixr 8 ^, ^^, \u22c6\u22c6 infixl 7 \u22c6, /, `quot`, `rem`, `div`, `mod` infixl 6 +, - -- Unary negation \"-\" has this fixity, too infixr 5 ++ -- built-in \":\" constructor has this fixity, too infix 4 ==, /=, <, <=, >=, >, `elem`, `notElem` infixr 3 && infixr 2 || infixl 1 >>, >>= infixr 1 =<< infixr 0 $, $!, `seq`\n```", "```\n    Prelude> :i && (&&) :: Bool -> Bool -> Bool -- Defined in GHC.Classes infixr 3 &&\n    ```", "```\n    ($) :: (a -> b) -> a -> b f $ x = f x\n    ```", "```\n     putStrLn $ \"the value of \" ++ key ++ \" is \" ++ show value\n    ```", "```\n    main = let q = 1 `div` 0 in seq q $ putStrLn \"Hello world!\\n\" -- exception\n    ```", "```\n    f $! x = x `seq` f x\n    ```", "```\nfactorial n0 = loop 1 n0 where loop acc n | n > 1 = loop (acc * n) (n - 1) | otherwise = acc\n```", "```\nfactorial n0 = loop 1 n0 where loop acc n | n > 1 = (loop $! acc * n) (n - 1) | otherwise = acc\n```", "```\nfactorial n0 = loop 1 n0 where loop acc n | n > 1 = acc `seq` loop (acc * n) (n - 1) | otherwise = acc\n```", "```\n        documentation: True library-profiling: True\n        ```", "```\n        alias cbi='LC_CTYPE=en_US.UTF-8 cabal install --user --haddock-hyperlink-source'\n        ```", "```\n    module Main where -- redundant since Main is the default import System.IO\n    ```", "```\nmodule Main where import System.IO greet h = do hPutStrLn h \"What is your name?\" name <- hGetLine h hPutStrLn h $ \"Hi, \" ++ name withTty = withFile \"/dev/tty\" ReadWriteMode main = withTty greet\n```", "```\ngreet h = do hPutStrLn h \"What is your name?\" name <- hGetLine h hPutStrLn h $ \"Hi, \" ++ name\n```", "```\nmain :: IO () greet :: Handle -> IO () hPutStrLn :: Handle -> String -> IO () hGetLine :: Handle -> IO String\n```", "```\n    main = hPutStrLn stdout (hGetLine stdin)\n    ```", "```\ndo name <- hGetLine h hPutStrLn h $ \"Hi, \" ++ name\n```", "```\ndo name <- hGetLine h hPutStrLn h $ \"Hi, \" ++ name\n```", "```\n$ ghc --make greet [1 of 1] Compiling Main ( greet.hs, greet.o ) Linking greet ... $ ./greet What is your name? David Hi, David\n```", "```\n    $ ghci ./greet.hs ... Prelude Main>\n    ```", "```\n    Prelude Main> :load *greet.hs [1 of 1] Compiling Main ( greet.hs, interpreted ) Ok, modules loaded: Main. *Main> \n    ```", "```\n        do ... hPutStrLn h $ \"Hi, \" ++ name name -- Incorrect, will not compile\n        ```", "```\n    greet :: Handle -> IO String greet h = do hPutStrLn h \"What is your name?\" name <- hGetLine h hPutStrLn h $ \"Hi, \" ++ name return name\n    ```", "```\n    return :: a -> IO a\n    ```", "```\n    (>>=) :: IO a -> (a -> IO b) -> IO b infixl 1 >>=\n    ```", "```\n    greet h = do hPutStrLn h \"What is your name?\" hGetLine h >>= hPutStrLn h . (\"Hi, \" ++)\n    ```", "```\n    -- Desugared version of original greet: greet h = hPutStrLn h \"What is your name?\" >>= \\_ -> hGetLine h >>= \\name -> hPutStrLn h (\"Hi, \" ++ name)\n    ```", "```\n    computerVsUser :: Move -> Handle -> IO ()\n    ```", "```\n    *Main> withTty $ computerVsUser Rock Please enter one of [Rock,Paper,Scissors] garbage Please enter one of [Rock,Paper,Scissors] Paper You Win *Main> withTty $ computerVsUser Scissors Please enter one of [Rock,Paper,Scissors] Paper You Lose\n    ```", "```\ngetMove :: Handle -> IO Move getMove h = do hPutStrLn h $ \"Please enter one of \" ++ show ([minBound..] :: [Move]) -- Here is the added code: input <- hGetLine h case parseMove input of Just move -> return move Nothing -> getMove h computerVsUser :: Move -> Handle -> IO () computerVsUser computerMove h = do userMove <- getMove h let o = outcome userMove computerMove hPutStrLn h $ \"You \" ++ show o\n```", "```\nid :: a -> a id x = x\n```", "```\nconst :: a -> b -> a const a _ = a\n```", "```\nfst :: (a, b) -> a fst (a, _) = a\n```", "```\nsnd :: (a, b) -> b snd (_, b) = b\n```", "```\nprint a = putStrLn (show a) -- what's the type? a -> IO ()?\n```", "```\nshow a = ??? -- how to implement?\n```", "```\n    class MyShow a where  myShow :: a -> String\n    ```", "```\n    data Point = Point Double Double instance MyShow Point where myShow (Point x y) = \"(\" ++ show x ++ \", \" ++ show y ++ \")\"\n    ```", "```\n    myPrint x = putStrLn $ myShow x\n    ```", "```\n    *Main> :t myPrint myPrint :: MyShow a => a -> IO ()\n    ```", "```\n    myPrint :: MyShow a => a -> IO ()\n    ```", "```\n    sortAndShow :: (Ord a, MyShow a) => [a] -> String\n    ```", "```\n    elem :: (Eq a) => a -> [a] -> Bool elem _ [] = False elem x (y:ys) = x==y || elem x ys\n    ```", "```\n    add :: (Num a) => a -> a -> a add arg1 arg2 = arg1 + arg2\n    ```", "```\n    superExpensive val = len $ veryExpensive (val :: Int) where len [] = 0 len (x:xs) = 1 + len xs cachedResult = superExpensive 5\n    ```", "```\n    *Main> :t superExpensive superExpensive :: Num a => Int -> a *Main> :t cachedResult cachedResult :: Integer\n    ```", "```\n    -- Compiler infers: show1 :: (Show x) => x -> String show1 x = show x\n    ```", "```\n    show2 = show show3 = \\x -> show x\n    ```", "```\n        -- No problem, compiler knows you want ad hoc polymorphism show2 :: (Show x) => x -> String show2 = show\n        ```", "```\n        class Eq a => Ord a where (<), (>=), (>), (<=) :: a -> a -> Bool a <= b = a == b || a < b -- default methods can use superclasses ....\n        ```", "```\n    instance (MyShow a) => MyShow [a] where myShow [] = \"[]\" myShow (x:xs) = myShow x ++ \":\" ++ myShow xs\n    ```", "```\n    class Functor f where  fmap :: (a -> b) -> f a -> f b\n    ```", "```\n    instance Functor Maybe where fmap _ Nothing = Nothing fmap f (Just a) = Just (f a)\n    ```", "```\n    GHCi, version 7.6.3: http://www.haskell.org/ghc/ :? for help Prelude> fmap (+ 1) Nothing Nothing Prelude> fmap (+ 1) $ Just 2 Just 3\n    ```", "```\n    map :: (a -> b) -> [a] -> [b] map _ [] = [] map f (x:xs) = f x : map f xs instance Functor [] where fmap = map\n    ```", "```\n    instance Functor IO where fmap f io = io >>= return . f -- equivalent to: do val <- io; return (f val)\n    ```", "```\n    greet h = do hPutStrLn h \"What is your name?\" fmap (\"Hi, \" ++) (hGetLine h) >>= hPutStrLn h\n    ```", "```\n    instance Functor Int where -- compilation error fmap _ _ = error \"placeholder\"\n    ```", "```\nclass Monad m where  (>>=) :: m a -> (a -> m b) -> m b  return :: a -> m a  fail :: String -> m a -- called when pattern binding fails fail s = error s -- default is to throw exception  (>>) :: m a -> m b -> m b m >> k = m >>= \\_ -> k\n```", "```\n    instance Monad Maybe where (Just x) >>= k = k x Nothing >>= _ = Nothing return = Just fail _ = Nothing\n    ```", "```\n    extractA :: String -> Maybe Int extractB :: String -> Maybe String ... parseForm :: String -> Maybe Form parseForm raw = do a <- extractA raw b <- extractB raw ... return (Form a b ...)\n    ```", "```\n    -- Argument to createProcess function data CreateProcess = CreateProcess CmdSpec (Maybe FilePath) (Maybe [(String,String)]) StdStream StdStream StdStream Bool\n    ```", "```\n    data CreateProcess = CreateProcess {  cmdspec :: CmdSpec,  cwd :: Maybe FilePath,  env :: Maybe [(String,String)],  std_in :: StdStream,  std_out :: StdStream,  std_err :: StdStream,  close_fds :: Bool }\n    ```", "```\n    data Point = Point { xCoord :: Double, yCoord :: Double }\n    ```", "```\ndata Point = Point { xCoord :: Double, yCoord :: Double }\n```", "```\n    myPoint = Point { xCoord = 1.0, yCoord = 1.0 }\n    ```", "```\n    -- Note the pattern binding assigns the variable on the right of = getX Point{ xCoord = x } = x\n    ```", "```\n        getX' p@Point{ xCoord = x } | x < 100 = x | otherwise = error $ show p ++ \" out of range\"\n        ```", "```\n        -- Also works with non-algebraic patterns getX' p@(Point x _) = ... processString s@('$':_) = ... processString s = ...\n        ```", "```\n    getX point = xCoord point\n    ```", "```\n    setX point x = point { xCoord = x } setXY point x y = point { xCoord = x, yCoord = y }\n    ```", "```\n    data State = State !Int Int data AlgState = AlgState { accumulator :: !Int , otherValue :: Int }\n    ```", "```\n    connectTo :: HostName -> PortID -> IO Handle listenOn :: PortID -> IO Socket accept :: Socket -> (Handle, HostName, PortNumber) sClose :: Socket -> IO ()\n    ```", "```\n    socket :: Family -> SocketType -> ProtocolNumber -> IO Socket connect :: Socket -> SockAddr -> IO () bindSocket :: Socket -> SockAddr -> IO () listen :: Socket -> Int -> IO () accept :: Socket -> IO (Socket, SockAddr) -- not same accept as above\n    ```", "```\n    withClient :: PortID -> (Handle -> IO a) -> IO a withClient listenPort fn = do s <- listenOn listenPort (h, host, port) <- accept s putStrLn $ \"Connection from host \" ++ host ++ \" port \" ++ show port sClose s -- Only accept one client a <- fn h hClose h return a\n    ```", "```\n    *Main> withClient (PortNumber 1617) (computerVsUser Rock)\n    ```", "```\n    $ nc localhost 1617 Please enter one of [Rock,Paper,Scissors] Rock You Tie\n    ```"]