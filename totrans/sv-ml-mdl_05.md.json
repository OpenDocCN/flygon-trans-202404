["```\npublic class ModelServer {\n   public static void main(String[] args) {\n       // Create and initialize pipeline\n       KafkaOptions options =\n         JobConfiguration.initializePipeline(args);\n       Pipeline p = Pipeline.create(options);\n\n       // Coder to use for Kafka data - raw byte message\n       KvCoder<byte[], byte[]> kafkaDataCoder =\n       KvCoder.of(NullableCoder.of(ByteArrayCoder.of()),\n         ByteArrayCoder.of());\n\n       // Data Stream - gets data records from Kafka topic\n       PCollection<KV<String, ModelServer1Support.DataWithModel>>\n         dataStream = p\n          .apply(\"data\", KafkaIO.readBytes()\n             .withBootstrapServers(options.getBroker())\n             .withTopics(Arrays.asList(options.getKafkaDataTopic()))\n             .updateConsumerProperties(\n               JobConfiguration.getKafkaConsumerProps(options,\n                 true))\n             .withoutMetadata()).setCoder(kafkaDataCoder)\n          // Convert Kafka message to WineRecord\n          .apply(\"Parse data records\", ParDo.of(\n            new ModelServer1Support.ConvertDataRecordFunction()));\n\n       // Models Stream - get model records from Kafka\n       PCollection<KV<String,ModelServer1Support.DataWithModel>>\n         modelStream = p\n          .apply(\"models\", KafkaIO.readBytes()\n             .withBootstrapServers(options.getBroker())\n             .withTopics(Arrays.asList(\n               options.getKafkaModelsTopic()))\n             .updateConsumerProperties(\n               JobConfiguration.getKafkaConsumerProps(options,\n                 false))\n             .withoutMetadata()).setCoder(kafkaDataCoder)\n          // Convert Kafka record to ModelDescriptor\n          .apply(\"Parse model\", ParDo.of(\n            new ModelServer1Support.ConvertModelRecordFunction()));\n       // Create a combined PCollection stream.\n       PCollection<KV<String,ModelServer1Support.DataWithModel>>\n         combinedStream =\n           PCollectionList.of(dataStream).and(modelStream)\n                   // Flatten the list\n                   .apply(Flatten.pCollections());\n\n       // Score models and print result\n       PCollection<Double> scoringResults = combinedStream\n          // Score data using current model\n          .apply(\"Scoring the model\", ParDo.of(\n             new ModelServer1Support.ScoringdFunction()))\n          // Print scoring result\n          .apply(\"Print result\", MapElements.via(\n             new ModelServer1Support.SimplePrinterFn<>()));\n\n       // Run the pipeline\n       p.run();\n   }\n```", "```\npublic static class DataWithModel implements Serializable {\n   private Winerecord.WineRecord data;\n   private ModelDescriptor model;\n   ...\n   public Winerecord.WineRecord getData() {return data;}\n\n   public ModelDescriptor getModel() {return model;}\n}\n```", "```\npublic class ConvertDataRecordFunction\n  extends DoFn<KV<byte[], byte[]>, KV<String, DataWithModel>> {\n   @ProcessElement\n   public void processElement(DoFn<KV<byte[], byte[]>,\n      KV<String, DataWithModel>>.ProcessContext ctx) {\n\n       // Get current element\n       KV<byte[], byte[]> input = ctx.element();\n       try {\n           Winerecord.WineRecord record =\n             Winerecord.WineRecord.parseFrom(input.getValue());\n           ctx.output(KV.of(record.getDataType(),\n             new DataWithModel(record)));\n       } catch (Throwable t) {\n          ...\n       }\n   }\n}\n```", "```\npublic class ScoringFunction\n  extends DoFn<KV<String,DataWithModel>, Double> {\n\n   private static final Map<Integer, ModelFactory> factories =\n     new HashMap<Integer, ModelFactory>() {\n   ...\n   // Internal state\n   @StateId(\"model\")\n   private final StateSpec<ValueState<Model>> modelSpec =\n                     StateSpecs.value(ModelCoder.of());\n\n   @ProcessElement\n   public void processElement\n     (DoFn<KV<String,DataWithModel>, Double>.ProcessContext ctx,\n     @StateId(\"model\") ValueState<Model> modelState) {\n       // Get current element\n       KV<String, DataWithModel> input = ctx.element();\n       // Check if we got the model\n       CurrentModelDescriptor descriptor =\n         input.getValue().getModel();\n       // Get current model\n       Model model = modelState.read();\n       if (descriptor != null) {\n           // Process model - store it\n           ModelFactory factory = factories\n             .get(descriptor.getModelType().ordinal());\n           if (factory == null)\n               System.out.println(\"Unknown model type \");\n           else {\n               Optional<Model> current = factory.create(descriptor);\n               if (current.isPresent()) {\n                   if (model != null) model.cleanup();\n                   // Create and store the model\n                   modelState.write(current.get());\n               } else\n                   ...\n           }\n       }\n       // Process data\n       else {\n           if (model == null)\n               System.out.println(\"No model available - skipping\");\n           else {\n               // Score the model\n               long start = System.currentTimeMillis();\n               double quality = (double) model.score(input\n                 .getValue().getData());\n               long duration = System.currentTimeMillis() - start;\n               // Propagate result\n               ctx.output(quality);\n           }\n       }\n   }\n}\n```", "```\npublic class ModelCoder extends AtomicCoder<Model> {\n...\n public static ModelCoder of() {\n   return INSTANCE;\n }\n...\n private static void writeModel(Model value, DataOutputStream dos)\n throws IOException {\n   byte[] bytes = value.getBytes();\n   VarInt.encode((long) bytes.length, dos);\n   dos.write(bytes);\n   VarInt.encode(value.getType(), dos);\n }\n\n private static Model readModel(DataInputStream dis)\n throws IOException {\n   int len = (int)VarInt.decodeLong(dis);\n   ...\n   byte[] bytes = new byte[len];\n   dis.readFully(bytes);\n   int type = (int)VarInt.decodeLong(dis);\n   ModelFactory factory = factories.get(type);\n   ...\n   return factory.restore(bytes);\n }\n...\n @Override\n public void encode(Model value, OutputStream outStream,\n      Context context) throws IOException {\n throws IOException {\n   if (value == null)\n     throw new CoderException(\"cannot encode a null model\");\n   if (context.isWholeStream) {\n     byte[] bytes = value.getBytes();\n     byte[] types = ByteUtils.longToBytes(value.getType());\n     if (outStream instanceof ExposedByteArrayOutputStream) {\n      ((ExposedByteArrayOutputStream) outStream).writeAndOwn(bytes);\n     } else {\n       outStream.write(bytes);\n       outStream.write(types);\n     }\n   } else {\n     writeModel(value, new DataOutputStream(outStream));\n   }\n }\n...\n @Override\n public Model decode(InputStream inStream, Context context)\n   throws IOException {\n   if (context.isWholeStream) {\n     byte[] bytes = StreamUtils.getBytes(inStream);\n     int type = (int)ByteUtils\n       .bytesToLong(StreamUtils.getBytes(inStream));\n     ModelFactory factory = factories.get(type);\n     if (factory == null) {\n       System.out.println(\"Unknown model type \" + type);\n       return null;\n     }\n     return factory.restore(bytes);\n   } else {\n     try {\n       return readModel(new DataInputStream(inStream));\n     } catch (EOFException | UTFDataFormatException exn) {\n       ...\n     }\n   }\n }\n...\n}\n```"]