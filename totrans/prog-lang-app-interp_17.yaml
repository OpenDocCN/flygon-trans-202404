- en: 17Alternate Application Semantics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17替代应用语义
- en: 'Long ago [REF], we considered the question of what to substitute when performing
    application. Now we are ready to consider some alternatives. At the time, we suggested
    just one alternative; in fact there are many more. To understand this, see whether
    you can answer this question:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前[REF]，我们考虑了在执行应用程序时要替换什么的问题。现在我们准备考虑一些替代方案。当时，我们只提出了一个替代方案；实际上有更多选择。要理解这一点，请看看你是否能回答这个问题：
- en: Which of these is the same?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者哪一个是相同的？
- en: (f x (current-seconds))
  id: totrans-3
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: (f x (current-seconds))
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (f x (current-seconds))
  id: totrans-6
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: (f x (current-seconds))
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (f x (current-seconds))
  id: totrans-9
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: (f x (current-seconds))
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (f x (current-seconds))
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: (f x (current-seconds))
- en: 'What we’re about to find is that this fragment of syntax can have wildly different
    run-time behaviors. For instance, there is the distinction we have already mentioned:
    variation in when (current-seconds) is evaluated. There is variation in how many
    times it is evaluated (and hence f is run). There is even variation even in whether
    values for x flow strictly from the caller to the callee, or can even flow in
    the opposite direction!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将发现的是，这个语法片段在运行时行为可能大不相同。例如，我们已经提到的区别是：(current-seconds)何时被求值。它被求值的次数有所不同（因此f被运行的次数也不同）。甚至在值是否严格从调用者流向被调用者，或者甚至可以反向流动的情况下，也存在差异！
- en: 17.1Lazy Application
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1惰性应用
- en: Let’s start by considering when parameters are reduced to values. That is, do
    we substitute formal parameters with the value of the actual parameter, or with
    the actual parameter expression itself? If we define
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑参数何时被简化为值。也就是说，我们是用实际参数的值替换形式参数，还是用实际参数表达式本身替换形式参数？如果我们定义
- en: '| (define (sq x) (* x x)) |'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define sq x) (* x x)) |'
- en: and invoke it as
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其作为
- en: '| (sq (+ 2 3)) |'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (sq (+ 2 3)) |'
- en: does that reduce to
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 是否简化为
- en: '| (* 5 5) |'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (* 5 5) |'
- en: or to
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还是简化为
- en: '| (* (+ 2 3) (+ 2 3)) |'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (* (+ 2 3) (+ 2 3)) |'
- en: '? The former is called eager application, while the latter is lazy.Some people
    also use the term strict for the former. A more arcane terminology is applicative-order
    evaluation for the former and normal-order evaluation for the latter. Or, call-by-value
    for the former and call-by-name or call-by-need for the latter. The last two terms—<wbr>by-name
    versus by-need—<wbr>actually represent a technical distinction we will see below.
    This concludes our name-dump. Of course we don’t want to return to defining interpreters
    by substitution, but it is always useful to think of substitution as a design
    principle.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前者称为急切应用，而后者称为惰性应用。有些人还使用严格一词来表示前者。更深奥的术语是应用顺序评估用于前者，正常顺序评估用于后者。或者，前者称为按值调用，后者称为按名字调用或按需调用。最后两个术语——按名字与按需——实际上代表了我们将在下面看到的技术区别。这结束了我们的术语介绍。当然，我们不想回到通过替换来定义解释器的时代，但将替换视为一种设计原则总是有用的。
- en: 17.1.1A Lazy Application Example
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.1惰性应用示例
- en: The lazy alternative has a distinguished history (for instance, this is what
    the true ~-calculus uses), but returned to the fore from programming experiments
    considering what might happen if certain operators did not evaluate the arguments
    at application but only when the value was needed. For instance, consider the
    definition
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性的替代方案有着悠久的历史（例如，这是真正的λ-演算使用的方法），但从考虑某些运算符在应用时不求值而只在需要值时才求值的编程实验中重新回到人们的视野。例如，考虑以下定义
- en: '| (define ones (cons 1 ones)) |'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define ones (cons 1 ones)) |'
- en: 'In ordinary Racket, this is clearly ill-defined: ones has not yet been defined
    (on the left) when we try to evaluate it (on the right), so this results in an
    error. If, however, we do not try to evaluate it until we actually need it, by
    that time the definition is well-formed. Because each rest obtains another ones,
    this produces an infinite list.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通的Racket中，这显然是不明确的：当我们尝试评估它时（在右侧），ones还没有被定义（在左侧），因此会导致错误。然而，如果我们直到实际需要它时才尝试评估它，那时定义就是完整的。因为每个rest都获得另一个ones，这将产生一个无限列表。
- en: We’ve glossed over a lot that needs explaining. Does the ones in the rest position
    of the cons evaluate to a copy of that expression, or to the result of the very
    same expression itself? In other words, have we simply created an infinitely unfolding
    list, or have we created an actually cyclic one?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了很多需要解释的内容。cons中的rest位置的ones是对该表达式的副本求值，还是对该表达式本身的结果求值？换句话说，我们是创建了一个无限展开的列表，还是创建了一个实际上是循环的列表？
- en: 'This depends in good part on whether or not our language has mutation. If it
    does, then perhaps we can modify each of the cells of the resulting list, which
    means we can observe the difference between the two implementations above: in
    the unfolded version mutating one first will not affect another, but in the cyclic
    one, changing one will affect them all. Therefore, in a language with mutation,
    we might argue that this should represent a lazy unfolding, but not an actual
    cyclic datum.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这在很大程度上取决于我们的语言是否具有变异。如果有的话，那么也许我们可以修改结果列表中的每个单元格，这意味着我们可以观察上述两种实现之间的差异：在展开版本中，先改变一个不会影响另一个，但在循环版本中，改变一个将影响它们全部。因此，在具有变异的语言中，我们可能会认为这应该代表一种惰性展开，而不是实际的循环数据。
- en: Keep this discussion in mind. We cannot resolve it right now; rather, let us
    examine lazy evaluation a little more, then return to this question [REF].
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这个讨论。我们现在无法解决它；相反，让我们更深入地研究一下惰性求值，然后再回到这个问题[REF]。
- en: 17.1.2What Are Values?
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.2值是什么？
- en: 'If we return to our core higher-order function interpreter [REF], we recall
    that we have two kinds of values: numbers and closures. If we want to support
    lazy evaluation instead, we need to ask what happens at function application.
    What exactly are we passing?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的核心高阶函数解释器[REF]，我们会想起我们有两种值：数字和闭包。如果我们想支持惰性求值，我们需要问的是在函数应用时会发生什么。我们究竟传递了什么？
- en: 'This seems obvious enough: in a lazy application semantics, we need to pass
    expressions. But a moment’s thought shows that this can be problematic. Expressions
    contain identifier names,And now these truly will be identifiers, not variables,
    as we will see [REF]. and we don’t want them to be accidentally bound.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很明显：在懒惰的应用语义中，我们需要传递表达式。但稍加思考就会发现这可能会有问题。表达式包含标识符名称，而现在这些确实将是标识符，而不是变量，正如我们将看到的[REF]，我们不希望它们被意外绑定。
- en: For instance, suppose we have
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有
- en: '| (define (f x) |'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (f x) |'
- en: '|   (lambda (y) |'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (lambda (y) |'
- en: '|     (+ x y))) |'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (+ x y))) |'
- en: 'and apply it as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 并按如下方式应用它：
- en: '| ((f 3) (+ x 4)) |'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| ((f 3) (+ x 4)) |'
- en: Do Now!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 立即行动！
- en: What should this produce?
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该产生什么结果？
- en: Clearly, we should get an error reporting x as not being bound.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们应该得到一个报告x未绑定的错误。
- en: Now let’s trace it. The first application creates a closure where x is bound
    to 3. If we now bind y to (+ x 4), this results in the expression (+ x (+ x 4))
    in an environment where x is bound. As a result we get the answer 10, not an error.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们追踪它。第一次应用创建一个闭包，其中x绑定为3。如果我们现在将y绑定为(+ x 4)，这将导致在x被绑定的环境中表达式(+ x (+ x 4))。结果我们得到答案10，而不是错误。
- en: Do Now!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 立即行动！
- en: Have we made a subtle assumption above?
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在上面做了一个微妙的假设吗？
- en: 'Yes we have: we’ve assumed that + evaluates arguments and returns numeric answers.
    Perhaps + also behaves lazily; we will study this issue in a moment. Nevertheless,
    the central point remains: if we are not careful, this erroneous expression will
    produce some kind of valid answer, not an error.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们假设+评估参数并返回数字答案。也许+也会懒惰行事；我们将在一会儿研究这个问题。然而，中心问题仍然存在：如果我们不小心，这个错误的表达式将产生某种有效的答案，而不是错误。
- en: 'In case you think this is entirely a problem with erroneous programs, and can
    hence be treated specially (e.g., first scan the program source for free identifiers),
    here is another use of the same f:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这完全是一个错误程序的问题，因此可以特殊处理（例如，首先扫描程序源代码以查找自由标识符），这里是相同f的另一个用法：
- en: '| (let ([x 5]) |'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([x 5]) |'
- en: '|   ((f 3) x)) |'
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   ((f 3) x)) |'
- en: Do Now!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 立即行动！
- en: What should this produce?
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该产生什么结果？
- en: We would expect this to produce the result of (+ 3 5) (probably 8). However,
    if we substitute x inside the arithmetic expression, we would get (+ 3 3) instead.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望这将产生(+ 3 5)的结果（可能是8）。然而，如果我们在算术表达式中替换x，我们将得到(+ 3 3)。
- en: 'This latter example holds the key to our solution. In the latter example, the
    problem ostensibly arises only when we use environments; if instead we use substitution,
    x in the application is substituted as soon as we encounter the let, and the result
    is what we expect. In fact, note that the same argument holds earlier: if we had
    used substitution, the very occurrence of x would have signaled an error. In short,
    we have to make sure our environment-based implementation matches what substitution
    would have done. Doesn’t that sound familiar!'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 后一个例子揭示了我们解决问题的关键。在后一个例子中，问题显然只在我们使用环境时才会出现；如果我们使用替换，那么在我们遇到 let 时，应用中的 x 就会被替换，结果就是我们所期望的。实际上，请注意，相同的论点在早期也成立：如果我们使用替换，x
    的出现将会引发错误。简而言之，我们必须确保我们基于环境的实现与替换的行为相匹配。这听起来很熟悉！
- en: 'In other words, the solution is to bundle the argument expression with its
    environment: i.e., create a closure. This closure has no parameters, so it is
    effectively a thunk.Indeed, this demonstrates that functions have two uses: to
    substitute names with values, and also to defer substitution. let is the former
    without the latter; thunks are the latter without the former. We have already
    established that the former is valuable in its own right; this section shows that
    the same is true of the latter. We could use existing functions to represent these
    thunks, but our instinct should tell us that it is better to use different data
    representations for logically different purposes: closV for user-created closures,
    and something else for internally-created ones. Indeed, as we will see, it will
    have been wise to keep them separate because there is one place where it is critical
    we can tell them apart.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，解决方案是将参数表达式与其环境捆绑在一起：即创建一个闭包。这个闭包没有参数，因此实际上是一个惰性求值。事实上，这表明函数有两个用途：用值替换名称，以及延迟替换。let是前者而没有后者；惰性求值是后者而没有前者。我们已经确定前者本身就很有价值；本节显示后者也是如此。我们可以使用现有函数来表示这些惰性求值，但我们的直觉应该告诉我们最好使用不同的数据表示来实现逻辑上的不同目的：用户创建的闭包使用closV，内部创建的使用其他东西。事实上，正如我们将看到的，将它们分开是明智的，因为有一个地方我们必须能够区分它们。
- en: 'To conclude this discussion, here is our new set of values:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结讨论，这是我们的新价值观：
- en: '| (define-type Value |'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义类型 Value |'
- en: '|   [numV (n : number)] |'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [numV (n : number)] |'
- en: '|   [closV (arg : symbol) (body : ExprC) (env : Env)] |'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [closV (arg : symbol) (body : ExprC) (env : Env)] |'
- en: '|   [suspendV (body : ExprC) (env : Env)]) |'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   [suspendV (body : ExprC) (env : Env)]) |'
- en: The first two variants are exactly the same; the third is new, and as we discussed,
    is effectively a parameter-less procedure, as its type suggests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个变体完全相同；第三个是新的，正如我们讨论的那样，实际上是一个无参数的过程，正如其类型所示。
- en: 17.1.3What Causes Evaluation?
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.3 什么导致求值？
- en: 'Let us now return to discussing arithmetic expressions. On evaluating (+ 1
    2), a lazy application interpreter could return any number of things, including
    (suspendV (+ 1 2) mt-env).It is legitimate to write mt-env here because even if
    the (+ 1 2) expression was written in a non-empty environment, it has no free
    identifiers, so it doesn’t need any of the environment’s bindings. In this way
    suspended computation could cascade on suspended computation, and in the limiting
    case every program would return immediately with an “answer”: the thunk representing
    the suspension of its computation.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到讨论算术表达式。在计算 (+ 1 2) 时，一个惰性应用解释器可以返回任意数量的东西，包括 (suspendV (+ 1 2) mt-env)。在这里写
    mt-env 是合法的，因为即使 (+ 1 2) 表达式在非空环境中编写，它也没有自由标识符，因此不需要环境的任何绑定。这样，暂停的计算可以级联进行，极端情况下，每个程序都会立即返回一个“答案”：代表其计算暂停的惰性求值。
- en: 'Clearly, something must force a suspension to be lifted. (Lifting a suspension
    means, of course, evaluating its body in the stored environment.) Those expression
    positions that undo suspensions are called strictness points. The most obvious
    strictness point is the interactive environment’s printer, because a user clearly
    would not use such an environment if they did not wish to see answers. We will
    embody the act of lifting suspension in the procedure strict:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，必须有某种力量来解除暂停。 （解除暂停意味着当然，在存储的环境中评估其主体。）撤消暂停的表达位置称为严格点。最明显的严格点是交互式环境的打印机，因为用户显然不会使用这样的环境，如果他们不希望看到答案。我们将在过程
    strict 中体现解除暂停的行为：
- en: '| (define (strict [v : Value]) : Value |'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (定义 (strict [v : Value]) : Value |'
- en: '|   (type-case Value v |'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case Value v |'
- en: '|     [numV (n) v] |'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [numV (n) v] |'
- en: '|     [closV (a b e) v] |'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [closV (a b e) v] |'
- en: '|     [suspendV (b e) (strict (interp b e))])) |'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [suspendV (b e) (strict (interp b e))])) |'
- en: where the returned Value is guaranteed to not be a suspendV. We can imagine
    the printer as wrapping strict around the result of evaluating the program, to
    obtain a value to print.Do Now!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其中返回的值保证不是一个suspendV。我们可以想象打印机将严格包裹在评估程序结果周围，以获得要打印的值。现在做！
- en: What impact would using closures to represent suspended computation have had?
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用闭包来表示暂停的计算会产生什么影响？
- en: The definition of strict above depends crucially on being able to distinguish
    deferred computations—<wbr>which are internally-constructed closures—<wbr>from
    user-defined closures. Had we conflated the two, then we would have to guess what
    to do with zero-argument closures. If we fail to further process them, we might
    incorrectly get an error (e.g., + might get a thunk rather than the numeric value
    residing inside it). If we do process it further, we might accidentally force
    a user-defined thunk prematurely. In short, we need a flag on thunks telling us
    whether they are internal or user-defined. For clarity, our interpreter uses a
    separate variant.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的strict定义关键取决于能够区分延迟计算（内部构造的闭包）和用户定义的闭包。如果我们混淆了两者，那么我们将不得不猜测如何处理零参数闭包。如果我们未能进一步处理它们，我们可能会错误地得到一个错误（例如，+可能会得到一个惰性计算而不是其中包含的数值）。如果我们进一步处理它，我们可能会意外地过早强制用户定义的惰性计算。简而言之，我们需要一个标志来告诉我们惰性计算是内部的还是用户定义的。为了清晰起见，我们的解释器使用了一个单独的变体。
- en: Let us now return to the interaction between strict and the interpreter. Unfortunately,
    as we have defined things, this will cause an infinite loop. The act of trying
    to interpret an addition creates a suspension, which strict tries to undo by forcing
    the interpreter to interpret an addition, which.... Clearly, therefore, we cannot
    have every expression simply suspend its computation; instead, we will limit suspension
    to applications. This suffices to give us the rich power of laziness, without
    making the language absurd.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到严格和解释器之间的交互。不幸的是，正如我们所定义的那样，这将导致一个无限循环。尝试解释加法的行为会创建一个悬挂，而strict试图通过强制解释器解释加法来撤消这个悬挂，然后...
    因此，显然，我们不能让每个表达式都简单地暂停其计算；相反，我们将限制暂停到应用程序中。这足以给我们提供懒惰的丰富功能，而不使语言变得荒谬。
- en: 17.1.4An Interpreter
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.4一个解释器
- en: As usual, we will define the interpreter in cases.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将按照情况定义解释器。
- en: '[<lazy-interp>](#(elem._(chunk._~3clazy-interp~3e~3a1))) ::='
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[<懒惰的interp>](#(elem._(chunk._~3clazy-interp~3e~3a1))) ::='
- en: '| (define (interp [expr : ExprC] [env : Env]) : Value |'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (define (interp [expr : ExprC] [env : Env]) : Value |'
- en: '|   (type-case ExprC expr |'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (type-case ExprC expr |'
- en: '|     [<lazy-numC-case>](#(elem._(chunk._~3clazy-num.C-case~3e~3a1))) |'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<懒惰的numC-case>](#(elem._(chunk._~3clazy-num.C-case~3e~3a1))) |'
- en: '|     [<lazy-idC-case>](#(elem._(chunk._~3clazy-id.C-case~3e~3a1))) |'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<懒惰的idC-case>](#(elem._(chunk._~3clazy-id.C-case~3e~3a1))) |'
- en: '|     [<lazy-plusC/multC-case>](#(elem._(chunk._~3clazy-plus.C/mult.C-case~3e~3a1)))
    |'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<懒惰的plusC/multC-case>](#(elem._(chunk._~3clazy-plus.C/mult.C-case~3e~3a1)))
    |'
- en: '|     [<lazy-appC-case>](#(elem._(chunk._~3clazy-app.C-case~3e~3a1))) |'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<懒惰的appC-case>](#(elem._(chunk._~3clazy-app.C-case~3e~3a1))) |'
- en: '|     [<lazy-lamC-case>](#(elem._(chunk._~3clazy-lam.C-case~3e~3a1))))) |'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     [<懒惰的lamC-case>](#(elem._(chunk._~3clazy-lam.C-case~3e~3a1))))) |'
- en: 'Numbers are easy: they are already values, so there is no point needlessly
    suspending them:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数字很容易：它们已经是值，所以没有必要无谓地悬挂它们：
- en: '[<lazy-numC-case>](#(elem._(chunk._~3clazy-num.C-case~3e~3a1))) ::='
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[<懒惰的numC-case>](#(elem._(chunk._~3clazy-num.C-case~3e~3a1))) ::='
- en: '[numC (n) (numV n)]'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[numC (n) (numV n)]'
- en: 'Closures, similarly, remain the same:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包同样保持不变：
- en: '[<lazy-lamC-case>](#(elem._(chunk._~3clazy-lam.C-case~3e~3a1))) ::='
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[<懒惰的lamC-case>](#(elem._(chunk._~3clazy-lam.C-case~3e~3a1))) ::='
- en: '[lamC (a b) (closV a b env)]'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[lamC (a b) (closV a b env)]'
- en: 'Identifiers should just return whatever they are bound to:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符应该返回它们绑定的内容：
- en: '[<lazy-idC-case>](#(elem._(chunk._~3clazy-id.C-case~3e~3a1))) ::='
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[<懒惰的idC-case>](#(elem._(chunk._~3clazy-id.C-case~3e~3a1))) ::='
- en: '[idC (n) (lookup n env)]'
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[idC (n) (lookup n env)]'
- en: 'The arguments of arithmetic expressions are usually defined as strictness points,
    because otherwise we would simply have to implement the actual arithmetic elsewhere:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 算术表达式的参数通常被定义为严格性点，否则我们将不得不在其他地方实现实际的算术：
- en: '[<lazy-plusC/multC-case>](#(elem._(chunk._~3clazy-plus.C/mult.C-case~3e~3a1)))
    ::='
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[<懒惰的plusC/multC-case>](#(elem._(chunk._~3clazy-plus.C/mult.C-case~3e~3a1)))
    ::='
- en: '| [plusC (l r) (num+ (strict (interp l env)) |'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [plusC (l r) (num+ (strict (interp l env)) |'
- en: '|                    (strict (interp r env)))] |'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (strict (interp r env)))] |'
- en: '| [multC (l r) (num* (strict (interp l env)) |'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [multC (l r) (num* (strict (interp l env)) |'
- en: '|                    (strict (interp r env)))] |'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                    (strict (interp r env)))] |'
- en: 'Finally, we have application. Here, instead of evaluating the argument position,
    we suspend it. The function position has to be a strictness point, however, otherwise
    we wouldn’t know what function to apply and hence how to continue the computation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有应用。在这里，我们不评估参数位置，而是将其暂停。然而，函数位置必须是一个严格点，否则我们将不知道应用哪个函数，因此也不知道如何继续计算：
- en: '[<lazy-appC-case>](#(elem._(chunk._~3clazy-app.C-case~3e~3a1))) ::='
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[<懒惰应用C-case>](#(elem._(chunk._~3clazy-app.C-case~3e~3a1))) ::='
- en: '| [appC (f a) (local ([define f-value (strict (interp f env))]) |'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| [appC (f a) (local ([define f-value (strict (interp f env))]) |'
- en: '|               (interp (closV-body f-value) |'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|               (interp (closV-body f-value) |'
- en: '|                         (extend-env (bind (closV-arg f-value) |'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                         (extend-env (bind (closV-arg f-value) |'
- en: '|                                           (suspendV a env)) |'
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                           (suspendV a env)) |'
- en: '|                                     (closV-env f-value))))] |'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|                                     (closV-env f-value))))] |'
- en: 'And that’s it! By adding a new kind of answer, inserting a few calls to strict,
    and replacing interp with suspendV in the argument position of application, we
    have turned our eager application interpreter into one with lazy application.
    Yet this small change has such enormous impact on the programs we write! For a
    more thorough examination of this impact, study Haskell or the #lang lazy language
    in Racket.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！通过添加一种新的答案类型，插入一些对strict的调用，并在应用的参数位置用suspendV替换interp，我们将我们的急切应用解释器转变为具有惰性应用的解释器。然而，这种小改变对我们编写的程序产生了如此巨大的影响！要更彻底地研究这种影响，请研究Haskell或Racket中的#lang
    lazy语言。
- en: Exercise
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: If we instead replace the identifier case with (strict (lookup n env)) (i.e.,
    wrapped strict around the result of looking up an identifier), what impact would
    it have on the language? Consider richer languages with data structures, etc.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们用(strict(lookup n env))替换标识符情况（即，在查找标识符的结果周围加上strict），这对语言会有什么影响？考虑具有数据结构等更丰富的语言。
- en: Exercise
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Construct programs that produce different results in a lazy evaluation than
    an eager evaluation (i.e., the same program text with different answers in the
    two cases). Try to make the differences interesting, i.e., beyond whether one
    returns a suspendV while the other doesn’t. For instance, does one terminate or
    produce an error while the other one doesn’t?
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建产生在惰性评估和急切评估中产生不同结果的程序（即，在两种情况下具有不同答案的相同程序文本）。尝试使差异有趣，即，超出一个返回suspendV而另一个不返回的范围。例如，一个是否终止或产生错误，而另一个不会？
- en: Exercise
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Instrument both interpreters to count the number of steps they take to return
    answers. For programs that produce the same answer under both evaluation strategies,
    does one strategy always take more steps than the other?
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为两个解释器添加仪器，以计算它们返回答案所需的步骤数。对于在两种评估策略下产生相同答案的程序，是否有一种策略总是比另一种策略需要更多步骤？
- en: 17.1.5Laziness and Mutation
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.5惰性和变异
- en: 'One of the virtues of lazy evaluation is that it defers execution. Usually
    this is a good thing: it enables us to build infinite data structures and avoids
    computation until necessary. Unfortunately, it also changes when computations
    occur, and in particular, changes the order of when computations evaluate relative
    to each other, depending on what strictness points are encountered when. As a
    result, programmers greatly lose predictability of ordering. This is of course
    a problem when expressions perform mutation operations, because now it becomes
    extremely difficult to predict what value a program will compute (relative to
    the eager version).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估的优点之一是它推迟执行。通常这是一件好事：它使我们能够构建无限的数据结构，并避免在必要时进行计算。不幸的是，它也改变了计算发生的时间，特别是改变了计算相对于彼此的顺序，具体取决于遇到的严格点。结果，程序员在排序方面失去了很大的可预测性。当表达式执行变异操作时，这当然是一个问题，因为现在非常难以预测程序将计算出什么值（相对于急切版本）。
- en: As a result, the core of every lazy language is free of mutation. In Haskell,
    mutation and other state operations are introduced through a variety of mechanisms
    such as monads and arrows that ultimately introduce the ability to (strictly)
    sequentialize code; this sequentiality is essential to being able to predict the
    order of execution and thus the result of operations. If programs are structured
    well the number of these dependencies should be small; furthermore, the Haskell
    type system attempts to reflect these operations in the types themselves, so programmers
    can more easily about their effects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个惰性语言的核心都不包含突变。在 Haskell 中，突变和其他状态操作是通过各种机制引入的，例如单子和箭头，最终引入了顺序化代码的能力；这种顺序性对于能够预测执行顺序和因此操作结果至关重要。如果程序结构良好，则这些依赖关系的数量应该很小；此外，Haskell
    类型系统试图在类型本身中反映这些操作，因此程序员可以更容易地了解它们的影响。
- en: 17.1.6Caching Computation
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.6计算缓存
- en: 'Now that we’ve concluded that lazy computation has to have no mutations, we
    observe a pleasant consequence (dare we say, side-effect?): given a fixed an environment,
    an expression always produces the same answer. As a result, the run-time system
    can cache the value of an expression when it is first forced to an answer by strictness,
    and return this cached value on subsequent attempts to compute it. Of course,
    this caching—<wbr>which is a form of memoization—<wbr>is only sound when the expression
    returns the same value every time, which we have assumed. In fact, the compiler
    and run-time system can aggressively hunt for uses of the same expression in different
    parts of the program and, if the relevant parts of their environment are the same,
    conflate their evaluation. The strategy of evaluating the suspended computation
    every time it is needed is called call-by-name; that of caching its result, call-by-need.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得出了惰性计算不能有突变的结论，我们观察到一个愉快的结果（我们敢说，副作用？）：在固定环境中，表达式总是产生相同的答案。因此，运行时系统可以在首次通过严格性迫使其返回答案时缓存表达式的值，并在后续尝试计算它时返回此缓存的值。当然，这种缓存——<wbr>这是一种记忆化的形式——<wbr>仅在表达式每次返回相同值时才是有效的，这是我们假设的。事实上，编译器和运行时系统可以积极地搜索程序的不同部分中对相同表达式的使用，并且，如果它们的环境的相关部分相同，则合并它们的评估。在需要时每次评估挂起的计算的策略称为名字调用；缓存其结果的策略称为需求调用。
- en: 17.2Reactive Application
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2反应性应用
- en: Now consider an expression like (current-seconds). When we evaluate it, it returns
    a single number representing the current time. For instance,
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个表达式，如 (当前秒数)。当我们评估它时，它返回一个表示当前时间的单个数字。例如，
- en: '| > (current-seconds) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| > (当前秒数) |'
- en: '| 1353030630 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 1353030630 |'
- en: However, even as we stare at this value, it is already out-of-date! It represents
    the time when the function application occurred, but does not stay current.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使我们凝视着这个值，它已经过时了！它代表了函数应用发生的时间，但不会保持最新。
- en: '17.2.1Motivating Example: A Timer'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.1激励示例：计时器
- en: 'Suppose we were trying to implement a timer that measures elapsed time. Ideally,
    we would like to write a program such as this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在尝试实现一个测量经过时间的计时器。理想情况下，我们希望写出这样的程序：
- en: '| (let ([start (current-seconds)]) |'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (让 ([开始 (当前秒数)]) |'
- en: '|   (- (current-seconds) |'
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (- (当前秒数) |'
- en: '|      start)) |'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      开始)) |'
- en: 'In JavaScript, we might write:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们可能会这样写：
- en: '| d = new Date(); |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| d = new Date(); |'
- en: '| start = d.getTime(); |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 开始 = d.getTime(); |'
- en: '| current = d.getTime(); |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 当前 = d.getTime(); |'
- en: '| elapsed = current - start; |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 经过时间 = 当前 - 开始; |'
- en: 'On most machines this Racket expression, or the value of elapsed in JavaScript,
    will evaluate to 0 or some other very small number. This is because these programs
    represent one measure of the elapsed time: that at the second invocation of the
    procedure that gets the current time. This gives us an instanteous time split,
    but not an actual timer.In most languages, to build an actual timer, we would
    have to create an instance of some sort of timer object, and install a callback.
    Every time the clock ticks, the timer object—<wbr>representing the operating system—<wbr>invokes
    the callback. The callback is then responsible for updating values in the rest
    of the system, and hopefully doing so globally and consistently. However, it cannot
    do so by returning values, because it would return to the operating system, which
    is agnostic to and does not care about our application; therefore, the callback
    is forced to perform its action through mutation. In JavaScript, for instance:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数机器上，这个 Racket 表达式，或者 JavaScript 中的 elapsed 的值，将会评估为 0 或者其他非常小的数字。这是因为这些程序代表了经过的时间的一种度量：在获取当前时间的过程的第二次调用时。这给了我们一个瞬时的时间分割，但不是一个实际的计时器。在大多数语言中，要构建一个实际的计时器，我们需要创建某种计时器对象的实例，并安装一个回调。每当时钟滴答作响时，代表操作系统的计时器对象会调用回调。然后回调负责更新系统中的值，并希望全局和一致地这样做。然而，它不能通过返回值来实现，因为它会返回给操作系统，而操作系统对我们的应用程序是无知的，也不关心；因此，回调被迫通过突变来执行其操作。例如，在
    JavaScript 中：
- en: '| var timerID = null; |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| var timerID = null; |'
- en: '| var elapsedTime = 0; |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| var elapsedTime = 0; |'
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| function doEverySecond() { |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| function doEverySecond() { |'
- en: '|   elapsedTime += 1; |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|   elapsedTime += 1; |'
- en: '|   document.getElementById(''curTime'').innerHTML = elapsedTime; } |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|   document.getElementById(''curTime'').innerHTML = elapsedTime; } |'
- en: '| function startTimer() { |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| function startTimer() { |'
- en: '|   timerId = setInterval(doEverySecond, 1000); } |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|   timerId = setInterval(doEverySecond, 1000); } |'
- en: 'assuming we have an HTML page with an id named curTime, and that the onload
    or other callback invokes startTimer.One alternative to this spaghetti code is
    for the application program to repeatedly poll the operating system for the current
    time. However:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个带有 id 为 curTime 的 HTML 页面，并且 onload 或其他回调调用 startTimer。对于这种意大利面条代码的另一种选择是，应用程序程序反复轮询操作系统以获取当前时间。然而：
- en: Calling too frequently wastes resources, while calling too infrequently results
    in incorrect answers. However, to call at just the right resolution, we would
    need a timer signal in the first place!
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于频繁地调用会浪费资源，而调用不够频繁会导致错误答案。然而，要以恰到好处的分辨率调用，我们首先需要一个计时器信号！
- en: While it may be possible to create such a polling loop for regular events such
    as timers, it is impossible to do so accurately for unpredictable behaviors such
    as user input (whose frequency cannot, in general, be predicted).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然可能可以为定期事件（如计时器）创建这样的轮询循环，但对于无法准确预测的行为（如用户输入，通常无法预测其频率），这是不可能的。
- en: On top of all this, writing this loop pollutes the program’s structure and forces
    the developer to sustain this extra burden.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除此之外，编写这个循环会污染程序的结构，并迫使开发人员承担这种额外负担。
- en: The callback-based solution, however, demonstrates an inversion of control.
    Instead of the application program calling the operating system, the operating
    system has now been charged with calling (into) the application program. The reactive
    behavior that should have been deeply nested, inside the display expression, has
    instead been brought to the top-level, and its value drives the other computations.
    The fundamental cause for this is that the world is in control, not the program,
    so external stimuli determine when and how the program should next run, not intrinsic
    program expressions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于回调的解决方案展示了一种控制的倒置。而不是应用程序调用操作系统，现在操作系统被委托调用（进入）应用程序。应该深度嵌套在显示表达式内部的反应性行为，现在被带到了顶层，并且它的值驱动其他计算。这一根本原因是世界在控制，而不是程序，因此外部刺激决定了程序何时以及如何运行，而不是内在程序表达式。
- en: 17.2.2Callback Types are Four-Letter Words
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.2 回调类型是四个字母的单词
- en: 'The characteristic signature (so to speak) of this pattern is manifest in the
    types. Because the operating system is agnostic to the program’s values, the callback
    usually has no return type at all, or it is a generic status indicator, not an
    application-specific value. Therefore, in typed languages, the type is usually
    some four-letter word. For instance, here is a fragment of a GUI library in Java:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的特征签名（可以这么说）体现在类型中。因为操作系统对程序的值是不可知的，回调通常根本没有返回类型，或者是一个通用的状态指示器，而不是特定于应用程序的值。因此，在类型化的语言中，类型通常是一些四个字母的单词。例如，这里是
    Java 中 GUI 库的一个片段：
- en: '| interface ChangeListener extends EventListener { |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| interface ChangeListener extends EventListener { |'
- en: '|   void stateChanged(ChangeEvent e) { ... } } |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|   void stateChanged(ChangeEvent e) { ... } } |'
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| interface ActionListener extends EventListener { |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| interface ActionListener extends EventListener { |'
- en: '|   void actionPerformed(ActionEvent e) { ... } } |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|   void actionPerformed(ActionEvent e) { ... } } |'
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| interface MouseListener extends EventListener { |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| interface MouseListener extends EventListener { |'
- en: '|   void mouseClicked(MouseEvent e) { ... } |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|   void mouseClicked(MouseEvent e) { ... } |'
- en: '|   void mouseEntered(MouseEvent e) { ... } } |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|   void mouseEntered(MouseEvent e) { ... } } |'
- en: 'And here’s one in OCaml:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个 OCaml 的例子：
- en: '| mainLoop : unit -> unit |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| mainLoop : unit -> unit |'
- en: '| closeTk : unit -> unit |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| closeTk : unit -> unit |'
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| destroy : ''a Widget.widget -> unit |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| destroy : ''a Widget.widget -> unit |'
- en: '| update : unit -> unit |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| update : unit -> unit |'
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '| pack : ... -> ''d Widget.widget list -> unit |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| pack : ... -> ''d Widget.widget list -> unit |'
- en: '| grid : ... -> ''b Widget.widget list -> unit |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| grid : ... -> ''b Widget.widget list -> unit |'
- en: 'In Haskell, the four letters have an extra space in them:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，这四个字母中间有一个额外的空格：
- en: '| select :: Selecting w => Event w (IO ()) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| select :: Selecting w => Event w (IO ()) |'
- en: '| mouse :: Reactive w => Event w (EventMouse -> IO ()) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| mouse :: Reactive w => Event w (EventMouse -> IO ()) |'
- en: '| keyboard :: Reactive w => Event w (EventKey -> IO ()) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| keyboard :: Reactive w => Event w (EventKey -> IO ()) |'
- en: '| resize :: Reactive w => Event w (IO ()) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| resize :: Reactive w => Event w (IO ()) |'
- en: '| focus :: Reactive w => Event w (Bool -> IO ()) |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| focus :: Reactive w => Event w (Bool -> IO ()) |'
- en: '| activate :: Reactive w => Event w (Bool -> IO ()) |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| activate :: Reactive w => Event w (Bool -> IO ()) |'
- en: 'and so on. In all these cases, the presence of a “void”-like type clearly indicates
    that the functions do not return any interesting value, so their only purpose
    must be to mutate the store or have some other side-effect. This also means that
    no rich means of composition—<wbr>such as the nesting of expressions—<wbr>is possible:
    the only composition operator for void-typed statements is sequencing. Thus the
    types reveal that we will be forced away from being able to write nested expressions.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如此类。在所有这些情况下，“void”-like 类型的存在清楚地表明这些函数不返回任何有趣的值，因此它们的唯一目的必须是改变存储或产生其他副作用。这也意味着没有丰富的组合手段���比如表达式的嵌套，是不可能的：void
    类型语句的唯一组合运算符是序列化。因此，类型表明我们将被迫无法编写嵌套表达式。
- en: Readers will, of course, be familiar with this problem from our earlier discussion
    of Web programming. This problem occurs on the server due to statelessness [REF],
    and also on the client due to single-threading [REF]. On the server, at least,
    we were able to use continuations to address this problem. However, continuations
    are not available in all languages, and implementing them can be onerous. Furthermore,
    it can be tricky to set up just the right continuation to pass as a callback.
    Instead, we will explore an alternate solution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 读者当然会对这个问题很熟悉，因为我们之前讨论过 Web 编程时提到过这个问题。这个问题在服务器端由于无状态性 [REF] 而出现，在客户端由于单线程 [REF]
    而出现。在服务器端，至少我们能够使用延续来解决这个问题。然而，并非所有语言都支持延续，并且实现它们可能很繁琐。此外，设置恰当的延续作为回调可能会有些棘手。因此，我们将探索另一种解决方案。
- en: '17.2.3The Alternative: Reactive Languages'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.3 另一种选择：响应式语言
- en: 'Consider the FrTime (pronounced “Father Time”) language in DrRacket.In DrRacket
    v5.3, you must select the language from the Language menu; writing #lang frtime
    will not provide the interesting interactions window behavior. If we run this
    expression at the interactions window, we still get 0 or some other very small
    non-negative number:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑在 DrRacket 中的 FrTime（发音为“Father Time”）语言。在 DrRacket v5.3 中，您必须从语言菜单中选择语言；写
    #lang frtime 不会提供有趣的交互窗口行为。如果我们在交互窗口中运行这个表达式，我们仍然会得到 0 或其他非常小的非负数：'
- en: '| (let ([start (current-seconds)]) |'
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (let ([start (current-seconds)]) |'
- en: '|   (- (current-seconds) |'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|   (- (current-seconds) |'
- en: '|      start)) |'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|      start)) |'
- en: In fact, we can try several other expressions and see that FrTime seems to have
    exactly like traditional Racket.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以尝试几个其他表达式，发现 FrTime 看起来与传统的 Racket 完全一样。
- en: 'However, it also binds a few additional identifiers. For instance, it provides
    a value bound to seconds. If we type this into the interaction prompt, we get
    something very interesting! First we see 1353030630, then a second later 1353030631,
    another second later 1353030632, and so on. This kind of value is called a behavior:
    a value that changes over time. Except we haven’t written any callbacks or other
    code to keep it current.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'A behavior can be used in computations. For instance, we can write (- seconds
    seconds), and this always evaluates to 0. Here are some more expressions to try
    at the interaction prompt:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '| (add1 seconds) |'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (modulo seconds 10) |'
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (build-list (modulo seconds 10) identity) |'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: '| (build-list (add1 (modulo seconds 10)) identity) |'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_TB
- en: 'As you can see, being a behavior is “sticky”: if any sub-expression is a behavior,
    so is its enclosing expression.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to this evaluation model, every time seconds updates the entire application
    happens afresh: as a result, even though we have written seemingly simple expressions
    without any explicit loop-like control, the program still “loops”. In other words,
    having explored an application semantics where arguments are evaluated once, then
    another where they may be evaluated zero times, now we have one where they are
    evaluated as many times as necessary, and the entire corresponding function with
    them. As a consequence, reactive values that are “inside” an expression no longer
    brought “outisde”; rather, they can reside nested inside expressions, giving programmers
    a more natural means of expression. This style of evaluation is called dataflow
    or functional reactive programming.Historically, dataflow has tended to refer
    to languages with first-order functions, whereas functional reactive languages
    support higher-order functions too.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: FrTime implements what we call transparent reactivity, whereby the programmer
    can inject a reactive behavior anywhere in a program’s evaluation without needing
    to make any syntactic changes to its context. This has the virtue of making it
    easy to inject reactivity into existing programs, but it can make the evaluation
    and cost model more complex for programmers. In other languages, programmers can
    instead explicitly introduce behavior through appropriate primitives, trading
    convenience for greater predictability. FrTime’s sister language, Flapjax, an
    extension of JavaScript, provides both modes.See the [Flapjax Web site](http://www.flapjax-lang.org/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 17.2.4Implementing Transparent Reactivity
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make an existing language implement transparent reactivity, we have to (naturally)
    alter the semantics of function application. We will do this in two steps. First
    we will rewrite reactive function applications into a more complex form, then
    we will show how this more complex form enables reactive updates.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 17.2.4.1Dataflow Graph Construction
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The essence of making an application reactive is simple to explain through desguaring.
    Assume we have defined a new constructor behavior. The constructor takes a thunk
    that represents what computation to perform every time an argument updates, and
    all the values that the expression depends on. The value it produces stores the
    current value of the behavior. Then an expression like (f x y) turns into
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解释 desugaring 简单说明应用程序变得响应的本质。假设我们已经定义了一个新的构造函数 behavior。构造函数接受一个 thunk，表示每次参数更新时要执行的计算，以及表达式依赖的所有值。它产生的值存储了行为的当前值。然后，像
    (f x y) 这样的表达式变成
- en: '| (if (or (behavior? x) (behavior? y)) |'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (if (or (behavior? x) (behavior? y)) |'
- en: '|     (behavior (λ () (f (current-value x) (current-value y))) x y) |'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (behavior (λ () (f (current-value x) (current-value y))) x y) |'
- en: '|     (f x y)) |'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (f x y)) |'
- en: where we assume, given a non-behavior constant, current-value behaves as the
    identity function.Let us look at two examples of using the above definition. Consider
    the trivial case where neither parameter is a behavior, e.g., (+ 3 4). This desugars
    to
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们假设，给定一个非行为常量，current-value 表现为恒等函数。让我们看两个使用上述定义的例子。考虑一个既不是行为的参数的微不足道的情况，例如，(+
    3 4)。这样展开为
- en: '| (if (or (behavior? 3) (behavior? 4)) |'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (if (or (behavior? 3) (behavior? 4)) |'
- en: '|     (behavior (λ () (+ (current-value 3) (current-value 4))) 3 4) |'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (behavior (λ () (+ (current-value 3) (current-value 4))) 3 4) |'
- en: '|     (+ 3 4)) |'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (+ 3 4)) |'
- en: 'Since both 3 and 4 are numbers, not behaviors, this reduces to (+ 3 4), which
    is precisely what we would like. This reflects an important principle: when no
    behaviors are present, programs behave exactly as they did in the non-reactive
    version of the language.If we compute (+ 1 seconds), this expands to'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于3和4都是数字，而不是行为，这就简化为(+ 3 4)，这正是我们想要的。这反映了一个重要原则：当没有行为存在时，程序的行为与语言的非反应版本完全相同。如果我们计算(+
    1 seconds)，这将扩展为
- en: '| (if (or (behavior? 1) (behavior? seconds)) |'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (if (or (behavior? 1) (behavior? seconds)) |'
- en: '|     (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
    |'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
    |'
- en: '|     (+ 1 seconds)) |'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|     (+ 1 seconds)) |'
- en: Because seconds is a behavior, this reduces to
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于秒是一种行为，这就简化为
- en: '| (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
    |'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| (behavior (λ () (+ (current-value 1) (current-value seconds))) 1 seconds)
    |'
- en: Any expression that depends on this now sees its argument also become a behavior,
    making the property “sticky” as we argued before.Exercise
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 任何依赖于此的表达式现在也看到其参数成为一种行为，使得我们之前论述的“粘性”属性成为现实。练习
- en: In what way, if any, did the above desugaring depend on eager evaluation?
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上述的展开是否依赖于急切求值？
- en: 17.2.4.2Dataflow Graph Update
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.4.2数据流图更新
- en: Of course, simply constructing behavior values is not enough. The key additional
    information is in the extra arguments to behavior. The language filters out those
    arguments that are themselves behaviors (e.g., seconds, above) and registers this
    new behavior as one of that depends on those existing ones. This registration
    process creates a graph of behavior expression dependencies, known as a dataflow
    graph (since it reflects the paths along which data need to flow).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅构造行为值是不够的。关键的附加信息在于行为的额外参数。语言过滤掉那些本身是行为的参数（例如，上面的 seconds）并将这个新行为注册为依赖于那些现有行为的行为之一。这个注册过程创建了一个行为表达式依赖图，称为数据流图（因为它反映了数据需要流动的路径）。
- en: If the program did not evaluate to any behaviors, then evaluation simply produces
    an answer, and there are no graphs created. If, however, there are behavior dependencies,
    then evaluation produces not a traditional answer but a behavior value, with dependencies
    already recorded. (In practice, it is useful to also track which primitive behaviors
    are actually necessary, to avoid unnecessarily evaluating primitives that no other
    behavior in the program refers to.) In short, program execution generates a dataflow
    graph. Thus, we do not need a special, new evaluator for the language; we instead
    embed the graph-construction semantics in traditional evaluation.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序没有求值为任何行为，则评估简单地产生一个答案，并且不创建图形。然而，如果存在行为依赖关系，则评估不会产生传统的答案，而是一个行为值，其中已经记录了依赖关系。
    （实际上，还有必要跟踪哪些原始行为实际上是必要的，以避免不必要地评估程序中没有其他行为引用的原始行为。）简而言之，程序执行生成数据流图。因此，我们不需要为语言编写特殊的新评估器；相反，我们将图构造语义嵌入到传统的评估中。
- en: Now a dataflow propagation algorithm begins to execute. Every time a primitive
    behavior changes, the algorithm applies its stored thunk, obtains its new value,
    stores it, and then signals each behavior dependent on it. For instance, if seconds
    updates, it notifies the (+ 1 seconds) expression’s behavior. The latter behavior
    now evaluates its thunk, (λ () (+ (current-value 1) (current-value seconds))).
    This adds 1 to the newest value of seconds, making that the new value of this
    behavior—<wbr>just as we would expect.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个数据流传播算法开始执行。每当一个原始行为发生变化时，算法应用其存储的thunk，获取其新值，存储它，然后通知每个依赖于它的行为。例如，如果秒更新，它会通知（+
    1秒）表达式的行为。后者现在评估其thunk，（λ（）（+（current-value 1）（current-value秒）））。这将1添加到秒的最新值中，使其成为这个行为的新值—<wbr>正如我们所期望的那样。
- en: 17.2.4.3Evaluation Order
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.4.3评估顺序
- en: 'The discussion above presents too simple a view of graph update. Consider the
    following program:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的讨论呈现了对图更新的过于简单的观点。考虑以下程序：
- en: '| (> (add1 seconds) |'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|（>（add1秒）|'
- en: '|    seconds) |'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '|    秒）|'
- en: 'This program has one primitive behavior, seconds, and constructs two more:
    one for (add1 seconds) and one more for the entire expression.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有一个原始行为，秒，还构造了两个更多：一个用于（add1秒），另一个用于整个表达式。
- en: We would expect this expression to always be true. However, when seconds updates,
    depending on the order in which it handles updates, it might update the whole
    expression before it does (add1 seconds). Suppose the old value of seconds was
    100, so the new one is 101. However, the node for (add1 seconds) is still storing
    its old value (because it has not yet been updated), so it holds (add1 100) or
    101. That means the > compares 101 with 1, which is false, making this expression
    return a value that should simply never have ensued from its static description.
    This situation is called a glitch.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望这个表达式总是成立。然而，当秒更新时，取决于处理更新的顺序，它可能在更新整个表达式之前更新（add1秒）。假设秒的旧值为100，所以新值为101。然而，（add1秒）的节点仍然存储着它的旧值（因为它还没有被更新），所以它保持（add1
    100）或101。这意味着>将101与1进行比较，这是错误的，使得这个表达式返回一个从其静态描述中根本不应该发生的值。这种情况被称为故障。
- en: There is an easy solution to avoiding glitches, which the above example illustrates
    (and that a theorem can show is sufficient). This is to topologically sort the
    nodes. Then, every node is only processed after it depends on have been, so there
    is no danger of seeing outdated or inconsistent values.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 避免故障的一个简单解决方案，正如上面的例子所说明的（并且一个定理可以证明是足够的）。这就是对节点进行拓扑排序。然后，每个节点只有在其依赖项已经被处理后才会被处理，因此不会出现看到过时或不一致的值的危险。
- en: The problem becomes more difficult in the presence of cycles in the graph. In
    those cases, we need special recursion operators that can take an initial value
    for the cyclic behavior. This makes it possible to break the cyclic dependency,
    reducing evaluation to the process that has already been defined.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中存在循环的情况下，问题变得更加困难。在这些情况下，我们需要特殊的递归运算符，可以为循环行为提供初始值。这使得打破循环依赖成为可能，将评估简化为已经定义的过程。
- en: There is much more to say about the evaluation of dataflow languages, such as
    the treatment of conditionals and a dual notion to behaviors that is discrete
    and stream-like. I hope you will read the literature on reactive languages to
    learn more about these topics.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据流语言的评估还有很多要说的，比如条件语句的处理以及一种对行为的双重概念，即离散和流式的。我希望你能阅读有关反应性语言的文献，以了解更多关于这些主题的内容。
- en: Exercise
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Earlier we picked on a Haskell library. To be fair, however, the reactive solution
    we have shown was enunciated in Haskell, whose lazy evaluation makes this form
    of evaluation relatively easy to support.
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 早些时候我们批评了一个Haskell库。然而，公平地说，我们展示的反应性解决方案是用Haskell表达的，其惰性评估使得这种形式的评估相对容易支持。
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement reactive evaluation using laziness.
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用惰性实现反应性评估。
