["```\ntype InitGame = unit -> Game \n```", "```\ntype PlayerXMoves = GameState * SomeOtherStuff -> GameState \n```", "```\ntype PlayerXMoves = GameState * SomeOtherStuff -> GameState \ntype PlayerOMoves = GameState * SomeOtherStuff -> GameState \n```", "```\ntype UserAction = \n    | PlayerXMoves of SomeStuff\n    | PlayerOMoves of SomeStuff \n```", "```\ntype Move = UserAction * GameState -> GameState \n```", "```\ntype UserAction = \n    | MoveLeft \n    | MoveRight \n    | Jump\n    | Fire \n```", "```\ntype PlayerXMoves = GameState * PlayerX's Stuff -> GameState \ntype PlayerOMoves = GameState * PlayerO's Stuff -> GameState \n```", "```\ntype HorizPosition = Left | HCenter | Right\ntype VertPosition = Top | VCenter | Bottom \n```", "```\ntype CellPosition = HorizPosition * VertPosition \n```", "```\ntype PlayerXMoves = GameState * CellPosition -> GameState \ntype PlayerOMoves = GameState * CellPosition -> GameState \n```", "```\ntype PlayerXPos = PlayerXPos of CellPosition \ntype PlayerOPos = PlayerOPos of CellPosition \n```", "```\ntype PlayerXMoves = GameState * PlayerXPos -> GameState \ntype PlayerOMoves = GameState * PlayerOPos -> GameState \n```", "```\ntype GameState = {\n    cells : Cell list\n    } \n```", "```\ntype CellState = \n    | X\n    | O\n    | Empty\n\ntype Cell = {\n    pos : CellPosition \n    state : CellState \n    } \n```", "```\n// added \"ChangedCells\"\ntype PlayerXMoves = GameState * PlayerXPos -> GameState * ChangedCells\ntype PlayerOMoves = GameState * PlayerOPos -> GameState * ChangedCells \n```", "```\ntype GetCells = GameState -> Cell list \n```", "```\ntype GetCells = GameState -> Cell[,] \n```", "```\nmodule TicTacToeDomain =\n\n    type HorizPosition = Left | HCenter | Right\n    type VertPosition = Top | VCenter | Bottom\n    type CellPosition = HorizPosition * VertPosition \n\n    type CellState = \n        | X\n        | O\n        | Empty\n\n    type Cell = {\n        pos : CellPosition \n        state : CellState \n        }\n\n    type PlayerXPos = PlayerXPos of CellPosition \n    type PlayerOPos = PlayerOPos of CellPosition \n\n    // the private game state\n    type GameState = exn  // use a placeholder\n\n    // the \"use-cases\" \n    type InitGame = unit -> GameState       \n    type PlayerXMoves = GameState * PlayerXPos -> GameState \n    type PlayerOMoves = GameState * PlayerOPos -> GameState \n\n    // helper function\n    type GetCells = GameState -> Cell list \n```", "```\nInputParam1 * InputParam2 * InputParam3 -> Result \n```", "```\nInputParam1 -> InputParam2 -> InputParam3 -> Result \n```", "```\ntype InitGame = unit -> GameState \n```", "```\ntype InitialGameState = GameState \n```", "```\ntype PlayerXMoves = \n    GameState * PlayerXPos -> GameState \n```", "```\ntype GameStatus = \n    | InProcess \n    | PlayerXWon \n    | PlayerOWon \n    | Tie \n```", "```\ntype PlayerXMoves = \n    GameState * PlayerXPos -> GameState * GameStatus \n```", "```\n// loop while game not over\nlet rec playMove gameState = \n    let pos = // get position from user input\n    let newGameState,status = \n        playerXMoves (gameState,pos) // process move\n    match status with\n    | InProcess -> \n        // play another move\n        playMove newGameState\n    | PlayerXWon -> \n        // show that player X won\n    | etc            \n\n// start the game with the initial state\nlet startGame() = \n    playMove initialGameState \n```", "```\ntype ValidPositionsForNextMove = CellPosition list\n\n// a move returns the list of available positions for the next move\ntype PlayerXMoves = \n    GameState * PlayerXPos -> // input\n        GameState * GameStatus * ValidPositionsForNextMove // output \n```", "```\ntype ValidMovesForPlayerX = PlayerXPos list\ntype ValidMovesForPlayerO = PlayerOPos list\n\ntype PlayerXMoves = \n    GameState * PlayerXPos -> // input\n        GameState * GameStatus * ValidMovesForPlayerO // output\n\ntype PlayerOMoves = \n    GameState * PlayerOPos -> // input\n        GameState * GameStatus * ValidMovesForPlayerX // output \n```", "```\ntype CellState = \n    | X\n    | O\n    | Empty\n\ntype GameStatus = \n    | InProcess \n    | PlayerXWon \n    | PlayerOWon \n    | Tie \n```", "```\ntype Player = PlayerO | PlayerX\n\ntype CellState = \n    | Played of Player \n    | Empty\n\ntype GameStatus = \n    | InProcess \n    | Won of Player\n    | Tie \n```", "```\ntype ValidMovesForPlayerX = PlayerXPos list\ntype ValidMovesForPlayerO = PlayerOPos list\n\ntype MoveResult = \n    | PlayerXToMove of GameState * ValidMovesForPlayerX\n    | PlayerOToMove of GameState * ValidMovesForPlayerO\n    | GameWon of GameState * Player \n    | GameTied of GameState \n```", "```\ntype PlayerXMoves = \n    GameState * PlayerXPos -> \n        GameState * MoveResult\n\ntype PlayerOMoves = \n    GameState * PlayerOPos -> \n        GameState * MoveResult \n```", "```\ntype NewGame = GameState * MoveResult \n```", "```\nmodule TicTacToeDomain =\n\n    type HorizPosition = Left | HCenter | Right\n    type VertPosition = Top | VCenter | Bottom\n    type CellPosition = HorizPosition * VertPosition \n\n    type Player = PlayerO | PlayerX\n\n    type CellState = \n        | Played of Player \n        | Empty\n\n    type Cell = {\n        pos : CellPosition \n        state : CellState \n        }\n\n    type PlayerXPos = PlayerXPos of CellPosition \n    type PlayerOPos = PlayerOPos of CellPosition \n\n    // the private game state\n    type GameState = exn  // use a placeholder\n\n    type ValidMovesForPlayerX = PlayerXPos list\n    type ValidMovesForPlayerO = PlayerOPos list\n\n    // the move result\n    type MoveResult = \n        | PlayerXToMove of ValidMovesForPlayerX\n        | PlayerOToMove of ValidMovesForPlayerO\n        | GameWon of Player \n        | GameTied \n\n    // the \"use-cases\" \n    type NewGame = \n        GameState * MoveResult      \n    type PlayerXMoves = \n        GameState * PlayerXPos -> GameState * MoveResult\n    type PlayerOMoves = \n        GameState * PlayerOPos -> GameState * MoveResult\n\n    // helper function\n    type GetCells = GameState -> Cell list \n```", "```\n/// Types shared by the UI and the game logic\nmodule TicTacToeDomain = \n\n    type HorizPosition = Left | HCenter | Right\n    type VertPosition = Top | VCenter | Bottom\n    type CellPosition = HorizPosition * VertPosition \n\n    type Player = PlayerO | PlayerX\n\n    type CellState = \n        | Played of Player \n        | Empty\n\n    type PlayerXMoves = \n        GameState * PlayerXPos -> GameState * MoveResult    \n    // etc\n\n/// Private types used by the internal game logic\nmodule TicTacToeImplementation = \n    open TicTacToeDomain \n\n    // private implementation detail\n    type GameState = {\n        cells : Cell list\n        }\n\n    // etc \n```", "```\nmodule TicTacToeImplementation = \n\n    // public types \n    type HorizPosition = Left | HCenter | Right\n    type VertPosition = Top | VCenter | Bottom\n    type CellPosition = HorizPosition * VertPosition \n\n    type CellState = \n        | Played of Player \n        | Empty\n\n    type PlayerXMoves = \n        GameState * PlayerXPos -> GameState * MoveResult    \n    // etc\n\n    // -------------------- \n    // private types \n\n    type private InternalType = // to do\n\n    // --------------------\n    // public types with private constructor\n\n    type GameState = private {\n        cells : Cell list\n        }\n\n    // etc \n```", "```\nThe type 'XXX' is less accessible than the value, member or type 'YYY' it is used in \n```", "```\n/// Types shared by the UI and the game logic\nmodule TicTacToeDomain = \n\n    // abstract base class \n    type GameState() = class end\n\n/// Private types used by the internal game logic\nmodule TicTacToeImplementation = \n    open TicTacToeDomain \n\n    type GameStateImpl() =\n        inherit GameState()\n\n    // etc \n```", "```\n/// Types shared by the UI and the game logic\nmodule TicTacToeDomain = \n\n    // unparameterized types\n    type PlayerXPos = PlayerXPos of CellPosition \n    type PlayerOPos = PlayerOPos of CellPosition \n\n    // parameterized types\n    type PlayerXMoves<'GameState> = \n        'GameState * PlayerXPos -> 'GameState * MoveResult\n    type PlayerOMoves<'GameState> = \n        'GameState * PlayerOPos -> 'GameState * MoveResult\n\n    // etc \n```", "```\nmodule TicTacToeImplementation =\n    open TicTacToeDomain\n\n    // can be public\n    type GameState = {\n        cells : Cell list\n        } \n```", "```\nlet playerXMoves : PlayerXMoves<GameState> = \n    fun (gameState,move) ->\n        // logic \n```", "```\nmodule TicTacToeImplementation = \n    open TicTacToeDomain \n\n    /// create the state of a new game\n    let newGame : NewGame<GameState> = \n        // return new game and current available moves\n        let validMoves = // to do\n        gameState, PlayerXToMove validMoves\n\n    let playerXMoves : PlayerXMoves<GameState> = \n        fun (gameState,move) ->\n            // implementation\n\nmodule WinFormUI = \n    open TicTacToeDomain\n    open System.Windows.Forms\n\n    type TicTacToeForm<'T>\n        (\n        // pass in the required functions \n        // as parameters to the constructor\n        newGame:NewGame<'T>, \n        playerXMoves:PlayerXMoves<'T>,\n        playerOMoves:PlayerOMoves<'T>,\n        getCells:GetCells<'T>\n        ) = \n        inherit Form()\n     // implementation to do\n\nmodule WinFormApplication = \n    open WinFormUI\n\n    // get functions from implementation\n    let newGame = TicTacToeImplementation.newGame\n    let playerXMoves = TicTacToeImplementation.playerXMoves\n    let playerOMoves = TicTacToeImplementation.playerOMoves\n    let getCells = TicTacToeImplementation.getCells\n\n    // create form and start game\n    let form = \n        new TicTacToeForm<_>(newGame,playerXMoves,playerOMoves,getCells)\n    form.Show() \n```", "```\nTicTacToeForm<'T>(newGame:NewGame<'T>, playerXMoves:PlayerXMoves<'T>, etc) \n```", "```\nTicTacToeForm(newGame:NewGame<_>, playerXMoves:PlayerXMoves<_>, etc) \n```", "```\nTicTacToeForm(newGame, playerXMoves, etc) \n```", "```\nwarning FS0064: This construct causes code to be less generic than indicated by the type annotations. \nThe type variable 'T has been constrained to be type 'XXX'. \n```", "```\n// the functions exported from the implementation\n// for the UI to use.\ntype TicTacToeAPI<'GameState> = \n    {\n    newGame : NewGame<'GameState>\n    playerXMoves : PlayerXMoves<'GameState> \n    playerOMoves : PlayerOMoves<'GameState> \n    getCells : GetCells<'GameState>\n    } \n```", "```\nmodule TicTacToeImplementation = \n    open TicTacToeDomain \n\n    /// create the functions to export\n    let newGame : NewGame<GameState> = // etc\n    let playerXMoves : PlayerXMoves<GameState> = // etc\n    // etc\n\n    // export the functions\n    let api = {\n        newGame = newGame \n        playerOMoves = playerOMoves \n        playerXMoves = playerXMoves \n        getCells = getCells\n        } \n```", "```\nmodule WinFormUI = \n    open TicTacToeDomain\n    open System.Windows.Forms\n\n    type TicTacToeForm<'T>(api:TicTacToeAPI<'T>) = \n        inherit Form()\n     // implementation to do\n\nmodule WinFormApplication = \n    open WinFormUI\n\n    // get functions from implementation\n    let api = TicTacToeImplementation.api\n\n    // create form and start game\n    let form = new TicTacToeForm<_>(api)\n    form.Show() \n```", "```\nlet newGame : NewGame<GameState> = \n    // create initial game state with empty everything\n    let gameState = { cells=[]}            \n    let validMoves = []\n    gameState, PlayerXToMove validMoves\n\nlet playerXMoves : PlayerXMoves<GameState> = \n    // dummy implementation\n    fun gameState move ->  gameState,GameTied\n\nlet playerOMoves : PlayerOMoves<GameState> = \n    // dummy implementation\n    fun gameState move ->  gameState,GameTied\n\nlet getCells gameState = \n    gameState.cells \n\nlet api = {\n    newGame = newGame \n    playerOMoves = playerOMoves \n    playerXMoves = playerXMoves \n    getCells = getCells\n    } \n```", "```\ntype TicTacToeForm<'GameState>(api:TicTacToeAPI<'GameState>) = \n    inherit Form()\n\n    let mutable gameState : 'GameState = ???\n    let mutable lastMoveResult : MoveResult = ???\n\n    let displayCells gameState = \n        let cells = api.getCells gameState \n        for cell in cells do\n            // update display\n\n    let startGame()= \n        let initialGameState,initialResult = api.newGame\n        gameState <- initialGameState\n        lastMoveResult <- initialResult \n        // create cell grid from gameState \n\n    let handleMoveResult moveResult =\n        match moveResult with\n        | PlayerXToMove availableMoves -> \n            // show available moves\n        | PlayerOToMove availableMoves -> \n            // show available moves\n        | GameWon player -> \n            let msg = sprintf \"%A Won\" player \n            MessageBox.Show(msg) |> ignore\n        | GameTied -> \n            MessageBox.Show(\"Tied\") |> ignore\n\n    // handle a click\n    let handleClick() =\n        let gridIndex = 0,0  // dummy for now\n        let cellPos = createCellPosition gridIndex\n        match lastMoveResult with\n        | PlayerXToMove availableMoves -> \n            let playerXmove = PlayerXPos cellPos\n            // if move is in available moves then send it\n            // to the api\n            let newGameState,newResult = \n                api.playerXMoves gameState playerXmove \n            handleMoveResult newResult \n\n            //update the globals\n            gameState <- newGameState\n            lastMoveResult <- newResult \n        | PlayerOToMove availableMoves -> \n            let playerOmove = PlayerOPos cellPos\n            // if move is in available moves then send it\n            // to the api\n            // etc\n        | GameWon player -> \n            ?? // we aleady showed after the last move \n```", "```\nlet mutable gameState : 'GameState = ??? \n```", "```\ntype UiState = \n    | Idle\n    | Playing\n    | Won\n    | Lost \n```", "```\ntype UiState = \n    | Idle\n    | Playing \n```", "```\ntype UiState<'GameState> = \n    | Idle\n    | Playing of 'GameState * MoveResult \n```", "```\ntype TicTacToeForm<'GameState>(api:TicTacToeAPI<'GameState>) = \n    inherit Form()\n\n    let mutable uiState = Idle \n```", "```\nlet startGame()= \n    uiState <- Playing api.newGame\n    // create cell grid from gameState \n```", "```\nlet handleClick() =\n    match uiState with\n    | Idle -> ()\n        // do nothing\n\n    | Playing (gameState,lastMoveResult) ->\n        let gridIndex = 0,0  // dummy for now\n        let cellPos = createCellPosition gridIndex\n        match lastMoveResult with\n        | PlayerXToMove availableMoves -> \n            let playerXmove = PlayerXPos cellPos\n            // if move is in available moves then send it\n            // to the api\n            let newGameState,newResult = \n                api.playerXMoves gameState playerXmove \n\n            // handle the result\n            // e.g. if the game is over\n            handleMoveResult newResult \n\n            // update the uiState with newGameState\n            uiState <- Playing (newGameState,newResult)\n\n        | PlayerOToMove availableMoves -> \n            // etc\n        | _ -> \n            // ignore other states \n```", "```\n| PlayerXToMove availableMoves -> \n    // snipped\n\n    let newGameState,newResult = // get new state\n\n    // update the uiState with newGameState\n    uiState <- Playing (newGameState,newResult) \n```", "```\nmodule TicTacToeDomain =\n\n    type HorizPosition = Left | HCenter | Right\n    type VertPosition = Top | VCenter | Bottom\n    type CellPosition = HorizPosition * VertPosition \n\n    type Player = PlayerO | PlayerX\n\n    type CellState = \n        | Played of Player \n        | Empty\n\n    type Cell = {\n        pos : CellPosition \n        state : CellState \n        }\n\n    type PlayerXPos = PlayerXPos of CellPosition \n    type PlayerOPos = PlayerOPos of CellPosition \n\n    type ValidMovesForPlayerX = PlayerXPos list\n    type ValidMovesForPlayerO = PlayerOPos list\n\n    type MoveResult = \n        | PlayerXToMove of ValidMovesForPlayerX \n        | PlayerOToMove of ValidMovesForPlayerO \n        | GameWon of Player \n        | GameTied \n\n    // the \"use-cases\" \n    type NewGame<'GameState> = \n        'GameState * MoveResult      \n    type PlayerXMoves<'GameState> = \n        'GameState -> PlayerXPos -> 'GameState * MoveResult\n    type PlayerOMoves<'GameState> = \n        'GameState -> PlayerOPos -> 'GameState * MoveResult\n\n    // helper function\n    type GetCells<'GameState> = \n        'GameState -> Cell list\n\n    // the functions exported from the implementation\n    // for the UI to use.\n    type TicTacToeAPI<'GameState> = \n        {\n        newGame : NewGame<'GameState>\n        playerXMoves : PlayerXMoves<'GameState> \n        playerOMoves : PlayerOMoves<'GameState> \n        getCells : GetCells<'GameState>\n        } \n```", "```\nmodule TicTacToeImplementation =\n    open TicTacToeDomain\n\n    /// private implementation of game state\n    type GameState = {\n        cells : Cell list\n        }\n\n    /// the list of all horizontal positions\n    let allHorizPositions = [Left; HCenter; Right]\n\n    /// the list of all horizontal positions\n    let allVertPositions = [Top; VCenter; Bottom]\n\n    /// A type to store the list of cell positions in a line\n    type Line = Line of CellPosition list\n\n    /// a list of the eight lines to check for 3 in a row\n    let linesToCheck = \n        let makeHLine v = Line [for h in allHorizPositions do yield (h,v)]\n        let hLines= [for v in allVertPositions do yield makeHLine v] \n\n        let makeVLine h = Line [for v in allVertPositions do yield (h,v)]\n        let vLines = [for h in allHorizPositions do yield makeVLine h] \n\n        let diagonalLine1 = Line [Left,Top; HCenter,VCenter; Right,Bottom]\n        let diagonalLine2 = Line [Left,Bottom; HCenter,VCenter; Right,Top]\n\n        // return all the lines to check\n        [\n        yield! hLines\n        yield! vLines\n        yield diagonalLine1 \n        yield diagonalLine2 \n        ]\n\n    /// get the cells from the gameState\n    let getCells gameState = \n        gameState.cells \n\n    /// get the cell corresponding to the cell position\n    let getCell gameState posToFind = \n        gameState.cells \n        |> List.find (fun cell -> cell.pos = posToFind)\n\n    /// update a particular cell in the GameState \n    /// and return a new GameState\n    let private updateCell newCell gameState =\n\n        // create a helper function\n        let substituteNewCell oldCell =\n            if oldCell.pos = newCell.pos then\n                newCell\n            else \n                oldCell                 \n\n        // get a copy of the cells, with the new cell swapped in\n        let newCells = gameState.cells |> List.map substituteNewCell \n\n        // return a new game state with the new cells\n        {gameState with cells = newCells }\n\n    /// Return true if the game was won by the specified player\n    let private isGameWonBy player gameState = \n\n        // helper to check if a cell was played by a particular player\n        let cellWasPlayedBy playerToCompare cell = \n            match cell.state with\n            | Played player -> player = playerToCompare\n            | Empty -> false\n\n        // helper to see if every cell in the Line has been played by the same player\n        let lineIsAllSamePlayer player (Line cellPosList) = \n            cellPosList \n            |> List.map (getCell gameState)\n            |> List.forall (cellWasPlayedBy player)\n\n        linesToCheck\n        |> List.exists (lineIsAllSamePlayer player)\n\n    /// Return true if all cells have been played\n    let private isGameTied gameState = \n        // helper to check if a cell was played by any player\n        let cellWasPlayed cell = \n            match cell.state with\n            | Played _ -> true\n            | Empty -> false\n\n        gameState.cells\n        |> List.forall cellWasPlayed \n\n    /// determine the remaining moves for a player\n    let private remainingMovesForPlayer playerMove gameState = \n\n        // helper to return Some if a cell is playable\n        let playableCell cell = \n            match cell.state with\n            | Played player -> None\n            | Empty -> Some (playerMove cell.pos)\n\n        gameState.cells\n        |> List.choose playableCell\n\n    /// create the state of a new game\n    let newGame = \n\n        // allPositions is the cross-product of the positions\n        let allPositions = [\n            for h in allHorizPositions do \n            for v in allVertPositions do \n                yield (h,v)\n            ]\n\n        // all cells are empty initially\n        let emptyCells = \n            allPositions \n            |> List.map (fun pos -> {pos = pos; state = Empty})\n\n        // create initial game state\n        let gameState = { cells=emptyCells }            \n\n        // initial set of valid moves for player X is all positions\n        let validMoves = \n            allPositions \n            |> List.map PlayerXPos\n\n        // return new game\n        gameState, PlayerXToMove validMoves\n\n    // player X makes a move\n    let playerXMoves gameState (PlayerXPos cellPos) = \n        let newCell = {pos = cellPos; state = Played PlayerX}\n        let newGameState = gameState |> updateCell newCell \n\n        if newGameState |> isGameWonBy PlayerX then\n            // return the new state and the move result\n            newGameState, GameWon PlayerX\n        elif newGameState |> isGameTied then\n            // return the new state and the move result\n            newGameState, GameTied  \n        else\n            let remainingMoves = \n                newGameState |> remainingMovesForPlayer PlayerOPos \n            newGameState, PlayerOToMove remainingMoves\n\n    // player O makes a move\n    let playerOMoves gameState (PlayerOPos cellPos) = \n        let newCell = {pos = cellPos; state = Played PlayerO}\n        let newGameState = gameState |> updateCell newCell \n\n        if newGameState |> isGameWonBy PlayerO then\n            // return the new state and the move result\n            newGameState, GameWon PlayerO\n        elif newGameState |> isGameTied then\n            // return the new state and the move result\n            newGameState, GameTied \n        else\n            let remainingMoves = \n                newGameState |> remainingMovesForPlayer PlayerXPos \n            newGameState, PlayerXToMove remainingMoves\n\n        // Exercise - refactor to remove the duplicate code from \n        // playerXMoves  and playerOMoves \n\n    /// export the API to the application\n    let api = {\n        newGame = newGame \n        playerOMoves = playerOMoves \n        playerXMoves = playerXMoves \n        getCells = getCells\n        } \n```", "```\n/// Console based user interface\nmodule ConsoleUi =\n    open TicTacToeDomain\n\n    /// Track the UI state\n    type UserAction<'a> =\n        | ContinuePlay of 'a\n        | ExitGame\n\n    /// Print each available move on the console\n    let displayAvailableMoves moves = \n        moves\n        |> List.iteri (fun i move -> \n            printfn \"%i) %A\" i move )\n\n    /// Get the move corresponding to the \n    /// index selected by the user\n    let getMove moveIndex moves = \n        if moveIndex < List.length moves then\n            let move = List.nth moves moveIndex \n            Some move\n        else\n            None\n\n    /// Given that the user has not quit, attempt to parse\n    /// the input text into a index and then find the move\n    /// corresponding to that index\n    let processMoveIndex inputStr gameState availableMoves makeMove processInputAgain = \n        match Int32.TryParse inputStr with\n        // TryParse will output a tuple (parsed?,int)\n        | true,inputIndex ->\n            // parsed ok, now try to find the corresponding move\n            match getMove inputIndex availableMoves with\n            | Some move -> \n                // corresponding move found, so make a move\n                let moveResult = makeMove gameState move \n                ContinuePlay moveResult // return it\n            | None ->\n                // no corresponding move found\n                printfn \"...No move found for inputIndex %i. Try again\" inputIndex \n                // try again\n                processInputAgain()\n        | false, _ -> \n            // int was not parsed\n            printfn \"...Please enter an int corresponding to a displayed move.\"             \n            // try again\n            processInputAgain()\n\n    /// Ask the user for input. Process the string entered as \n    /// a move index or a \"quit\" command\n    let rec processInput gameState availableMoves makeMove = \n\n        // helper that calls this function again with exactly\n        // the same parameters\n        let processInputAgain() = \n            processInput gameState availableMoves makeMove \n\n        printfn \"Enter an int corresponding to a displayed move or q to quit:\" \n        let inputStr = Console.ReadLine()\n        if inputStr = \"q\" then\n            ExitGame\n        else\n            processMoveIndex inputStr gameState availableMoves makeMove processInputAgain\n\n    /// Display the cells on the console in a grid\n    let displayCells cells = \n        let cellToStr cell = \n            match cell.state with\n            | Empty -> \"-\"            \n            | Played player ->\n                match player with\n                | PlayerO -> \"O\"\n                | PlayerX -> \"X\"\n\n        let printCells cells  = \n            cells\n            |> List.map cellToStr\n            |> List.reduce (fun s1 s2 -> s1 + \"|\" + s2) \n            |> printfn \"|%s|\"\n\n        let topCells = \n            cells |> List.filter (fun cell -> snd cell.pos = Top) \n        let centerCells = \n            cells |> List.filter (fun cell -> snd cell.pos = VCenter) \n        let bottomCells = \n            cells |> List.filter (fun cell -> snd cell.pos = Bottom) \n\n        printCells topCells\n        printCells centerCells \n        printCells bottomCells \n        printfn \"\"   // add some space\n\n    /// After each game is finished,\n    /// ask whether to play again.\n    let rec askToPlayAgain api  = \n        printfn \"Would you like to play again (y/n)?\"             \n        match Console.ReadLine() with\n        | \"y\" -> \n            ContinuePlay api.newGame\n        | \"n\" -> \n            ExitGame\n        | _ -> askToPlayAgain api \n\n    /// The main game loop, repeated\n    /// for each user input\n    let rec gameLoop api userAction = \n        printfn \"\\n------------------------------\\n\"  // a separator between moves\n\n        match userAction with\n        | ExitGame -> \n            printfn \"Exiting game.\"             \n        | ContinuePlay (state,moveResult) -> \n            // first, update the display\n            state |> api.getCells |> displayCells\n\n            // then handle each case of the result\n            match moveResult with\n            | GameTied -> \n                printfn \"GAME OVER - Tie\"             \n                printfn \"\"             \n                let nextUserAction = askToPlayAgain api \n                gameLoop api nextUserAction\n            | GameWon player -> \n                printfn \"GAME WON by %A\" player            \n                printfn \"\"             \n                let nextUserAction = askToPlayAgain api \n                gameLoop api nextUserAction\n            | PlayerOToMove availableMoves -> \n                printfn \"Player O to move\" \n                displayAvailableMoves availableMoves\n                let newResult = processInput state availableMoves api.playerOMoves\n                gameLoop api newResult \n            | PlayerXToMove availableMoves -> \n                printfn \"Player X to move\" \n                displayAvailableMoves availableMoves\n                let newResult = processInput state availableMoves api.playerXMoves\n                gameLoop api newResult \n\n    /// start the game with the given API\n    let startGame api =\n        let userAction = ContinuePlay api.newGame\n        gameLoop api userAction \n```", "```\nmodule ConsoleApplication = \n\n    let startGame() =\n        let api = TicTacToeImplementation.api\n        ConsoleUi.startGame api \n```", "```\n|-|X|-|\n|X|-|-|\n|O|-|-|\n\nPlayer O to move\n0) PlayerOPos (Left, Top)\n1) PlayerOPos (HCenter, VCenter)\n2) PlayerOPos (HCenter, Bottom)\n3) PlayerOPos (Right, Top)\n4) PlayerOPos (Right, VCenter)\n5) PlayerOPos (Right, Bottom)\nEnter an int corresponding to a displayed move or q to quit:\n1\n\n------------------------------\n\n|-|X|-|\n|X|O|-|\n|O|-|-|\n\nPlayer X to move\n0) PlayerXPos (Left, Top)\n1) PlayerXPos (HCenter, Bottom)\n2) PlayerXPos (Right, Top)\n3) PlayerXPos (Right, VCenter)\n4) PlayerXPos (Right, Bottom)\nEnter an int corresponding to a displayed move or q to quit:\n1\n\n------------------------------\n\n|-|X|-|\n|X|O|-|\n|O|X|-|\n\nPlayer O to move\n0) PlayerOPos (Left, Top)\n1) PlayerOPos (Right, Top)\n2) PlayerOPos (Right, VCenter)\n3) PlayerOPos (Right, Bottom)\nEnter an int corresponding to a displayed move or q to quit:\n1\n\n------------------------------\n\n|-|X|O|\n|X|O|-|\n|O|X|-|\n\nGAME WON by PlayerO\n\nWould you like to play again (y/n)? \n```", "```\nmodule Logger = \n    open TicTacToeDomain\n\n    let logXMove (PlayerXPos cellPos)= \n        printfn \"X played %A\" cellPos\n\n    let logOMove (PlayerOPos cellPos)= \n        printfn \"O played %A\" cellPos\n\n    /// inject logging into the API\n    let injectLogging api =\n\n        // make a logged version of the game function \n        let playerXMoves state move = \n            logXMove move \n            api.playerXMoves state move \n\n        // make a logged version of the game function \n        let playerOMoves state move = \n            logOMove move \n            api.playerOMoves state move \n\n        // create a new API with \n        // the move functions replaced\n        // with logged versions\n        { api with\n            playerXMoves = playerXMoves\n            playerOMoves = playerOMoves\n            } \n```", "```\nmodule ConsoleApplication = \n\n    let startGame() =\n        let api = TicTacToeImplementation.api\n        let loggedApi = Logger.injectLogging api\n        ConsoleUi.startGame loggedApi \n```", "```\ntype InitGame = unit -> GameState \n```", "```\ntype MoveResult<'PlayerXPos,'PlayerOPos> = \n    | PlayerXToMove of 'PlayerXPos list\n    | PlayerOToMove of 'PlayerOPos list\n    | GameWon of Player \n    | GameTied \n\ntype NewGame<'GameState,'PlayerXPos,'PlayerOPos> = \n    'GameState * MoveResult<'PlayerXPos,'PlayerOPos>      \n\ntype PlayerXMoves<'GameState,'PlayerXPos,'PlayerOPos> = \n    'GameState -> 'PlayerXPos -> \n        'GameState * MoveResult<'PlayerXPos,'PlayerOPos>      \ntype PlayerOMoves<'GameState,'PlayerXPos,'PlayerOPos> = \n    'GameState -> 'PlayerOPos -> \n        'GameState * MoveResult<'PlayerXPos,'PlayerOPos> \n```", "```\ntype GetValidXPos<'PlayerXPos,'PlayerOPos> = \n    CellPosition * MoveResult<'PlayerXPos,'PlayerOPos> -> 'PlayerXPos option \n```", "```\n/// create the state of a new game\nlet newGame : NewGame<GameState> = \n    // implementation\n\nlet playerXMoves : PlayerXMoves<GameState> = \n    fun (gameState,move) ->\n        // implementation \n```", "```\n/// create the state of a new game\nlet newGame  = \n    // implementation\n\nlet playerXMoves (gameState,move) = \n    // implementation \n```", "```\nmodule TicTacToeDomain =\n\n    type HorizPosition = Left | HCenter | Right\n    type VertPosition = Top | VCenter | Bottom\n    type CellPosition = HorizPosition * VertPosition \n\n    type Player = PlayerO | PlayerX\n\n    type CellState = \n        | Played of Player \n        | Empty\n\n    type Cell = {\n        pos : CellPosition \n        state : CellState \n        }\n\n    type PlayerXPos = PlayerXPos of CellPosition \n    type PlayerOPos = PlayerOPos of CellPosition \n\n    type ValidMovesForPlayerX = PlayerXPos list\n    type ValidMovesForPlayerO = PlayerOPos list\n\n    type MoveResult = \n        | PlayerXToMove of ValidMovesForPlayerX \n        | PlayerOToMove of ValidMovesForPlayerO \n        | GameWon of Player \n        | GameTied \n\n    // the \"use-cases\" \n    type NewGame<'GameState> = \n        'GameState * MoveResult      \n    type PlayerXMoves<'GameState> = \n        'GameState -> PlayerXPos -> 'GameState * MoveResult\n    type PlayerOMoves<'GameState> = \n        'GameState -> PlayerOPos -> 'GameState * MoveResult \n```", "```\ntype PlayerXMoves = \n    GameState * PlayerXPos -> // input\n        GameState * MoveResult // output \n```", "```\ntype MoveCapability = \n    GameState -> // input\n        GameState * MoveResult // output \n```", "```\ntype MoveCapability = \n    unit -> // no input\n        GameState * MoveResult // output \n```", "```\ntype MoveResult = \n    | PlayerXToMove of MoveCapability list \n    | PlayerOToMove of MoveCapability list \n    | GameWon of Player \n    | GameTied \n```", "```\ntype MoveCapability = \n    unit -> MoveResult \n```", "```\n// loop while game not over\nlet rec playMove moveResult = \n\n    let availableCapabilities = // from moveResult\n\n    // get capability from user input somehow\n    let capability = ??\n\n    // use the capability\n    let newMoveResult = capability()\n\n    // display updated grid\n    let cells = ??  // from where\n\n    // play again\n    match newMoveResult with\n    | PlayerXToMove capabilities -> \n        // play another move\n        playMove newMoveResult\n    | etc \n```", "```\ntype NextMoveInfo = {\n    posToPlay : CellPosition \n    capability : MoveCapability } \n```", "```\ntype MoveResult = \n    | PlayerXToMove of NextMoveInfo list \n    | PlayerOToMove of NextMoveInfo list \n    | GameWon of Player \n    | GameTied \n```", "```\n/// Everything the UI needs to know to display the board\ntype DisplayInfo = {\n    cells : Cell list\n    } \n```", "```\ntype MoveResult = \n    | PlayerXToMove of DisplayInfo * NextMoveInfo list \n    | PlayerOToMove of DisplayInfo * NextMoveInfo list \n    | GameWon of DisplayInfo * Player \n    | GameTied of DisplayInfo \n```", "```\n/// The capability to make a move at a particular location.\n/// The gamestate, player and position are already \"baked\" into the function.\ntype MoveCapability = \n    unit -> MoveResult \n\n/// A capability along with the position the capability is associated with.\n/// This allows the UI to show information so that the user\n/// can pick a particular capability to exercise.\ntype NextMoveInfo = {\n    // the pos is for UI information only\n    // the actual pos is baked into the cap.\n    posToPlay : CellPosition \n    capability : MoveCapability }\n\n/// The result of a move. It includes: \n/// * The information on the current board state.\n/// * The capabilities for the next move, if any.\ntype MoveResult = \n    | PlayerXToMove of DisplayInfo * NextMoveInfo list \n    | PlayerOToMove of DisplayInfo * NextMoveInfo list \n    | GameWon of DisplayInfo * Player \n    | GameTied of DisplayInfo \n```", "```\ntype MoveCapability = \n    // etc\nand NextMoveInfo = {\n    // etc\nand MoveResult = \n    // etc \n```", "```\ntype TicTacToeAPI<'GameState> = \n    {\n    newGame : NewGame<'GameState>\n    playerXMoves : PlayerXMoves<'GameState> \n    playerOMoves : PlayerOMoves<'GameState> \n    getCells : GetCells<'GameState>\n    } \n```", "```\ntype NewGame = unit -> MoveResult\n\ntype TicTacToeAPI = \n    {\n    newGame : NewGame \n    } \n```", "```\nmodule TicTacToeDomain =\n\n    type HorizPosition = Left | HCenter | Right\n    type VertPosition = Top | VCenter | Bottom\n    type CellPosition = HorizPosition * VertPosition \n\n    type Player = PlayerO | PlayerX\n\n    type CellState = \n        | Played of Player \n        | Empty\n\n    type Cell = {\n        pos : CellPosition \n        state : CellState \n        }\n\n    /// Everything the UI needs to know to display the board\n    type DisplayInfo = {\n        cells : Cell list\n        }\n\n    /// The capability to make a move at a particular location.\n    /// The gamestate, player and position are already \"baked\" into the function.\n    type MoveCapability = \n        unit -> MoveResult \n\n    /// A capability along with the position the capability is associated with.\n    /// This allows the UI to show information so that the user\n    /// can pick a particular capability to exercise.\n    and NextMoveInfo = {\n        // the pos is for UI information only\n        // the actual pos is baked into the cap.\n        posToPlay : CellPosition \n        capability : MoveCapability }\n\n    /// The result of a move. It includes: \n    /// * The information on the current board state.\n    /// * The capabilities for the next move, if any.\n    and MoveResult = \n        | PlayerXToMove of DisplayInfo * NextMoveInfo list \n        | PlayerOToMove of DisplayInfo * NextMoveInfo list \n        | GameWon of DisplayInfo * Player \n        | GameTied of DisplayInfo \n\n    // Only the newGame function is exported from the implementation\n    // all other functions come from the results of the previous move\n    type TicTacToeAPI = \n        {\n        newGame : MoveCapability\n        } \n```", "```\n/// Transform a MoveCapability into a logged version\nlet transformCapability transformMR player cellPos (cap:MoveCapability) :MoveCapability =\n\n    // create a new capability that logs the player & cellPos when run\n    let newCap() =\n        printfn \"LOGINFO: %A played %A\" player cellPos\n        let moveResult = cap() \n        transformMR moveResult \n    newCap \n```", "```\n/// Transform a NextMove into a logged version\nlet transformNextMove transformMR player (move:NextMoveInfo) :NextMoveInfo = \n    let cellPos = move.posToPlay \n    let cap = move.capability\n    {move with capability = transformCapability transformMR player cellPos cap} \n```", "```\n/// Transform a MoveResult into a logged version\nlet rec transformMoveResult (moveResult:MoveResult) :MoveResult =\n\n    let tmr = transformMoveResult // abbreviate!\n\n    match moveResult with\n    | PlayerXToMove (display,nextMoves) ->\n        let nextMoves' = nextMoves |> List.map (transformNextMove tmr PlayerX) \n        PlayerXToMove (display,nextMoves') \n    | PlayerOToMove (display,nextMoves) ->\n        let nextMoves' = nextMoves |> List.map (transformNextMove tmr PlayerO)\n        PlayerOToMove (display,nextMoves') \n    | GameWon (display,player) ->\n        printfn \"LOGINFO: Game won by %A\" player \n        moveResult\n    | GameTied display ->\n        printfn \"LOGINFO: Game tied\" \n        moveResult \n```", "```\n/// inject logging into the API\nlet injectLogging api =\n\n    // create a new API with the functions \n    // replaced with logged versions\n    { api with\n        newGame = fun () -> api.newGame() |> transformMoveResult\n        } \n```"]