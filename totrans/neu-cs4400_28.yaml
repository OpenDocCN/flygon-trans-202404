- en: Using Functions as ObjectsTuesday, January 31st
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very important aspect of Racket — using “higher order” functions — functions
    that get and return functions. Here is a very simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: what we get is actually an object that remembers (by the substitution
    we’re doing) a number. How about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Take this idea to the next level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, with types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Even more — why should the internal function expect a boolean and choose what
    to return? We can simply expect a function that will take the two values and return
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And a typed version, using our own constructor to make it a little less painful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `Kons` type definition is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: so `All` is to polymorphic type definitions what `lambda` is for function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with ES6 *arrow functions*, the function definitionss become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
