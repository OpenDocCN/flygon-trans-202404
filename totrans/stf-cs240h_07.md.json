["```\nclass Functor f where  fmap :: (a -> b) -> f a -> f b\n```", "```\nfmap (+1) [1,2,3]\n```", "```\nimport Data.Char fmap toUpper \"qwertyuiop\"\n```", "```\nclass MyFunctor f where  myfmap :: (a -> b) -> f a -> f b\n```", "```\nclass MyFunctor f where  myfmap :: (a -> b) -> f a -> f b\n```", "```\ninstance MyFunctor Maybe where myfmap _ Nothing = Nothing myfmap f (Just a) = Just (f a)\n```", "```\nnewtype Identity a = Identity a\n```", "```\n(,) :: a -> b -> (a, b)\n```", "```\nghci> :type (,) 'X' True (,) 'X' True :: (Char, Bool)\n```", "```\nghci> :type (,) 'X' (,) 'X' :: b -> (Char, b)\n```", "```\nfoo :: b -> (,) Char b foo b = (,) 'X' b\n```", "```\nfoo :: b -> (Char, b)\n```", "```\ninstance MyFunctor ((,) a) where {- ... -}\n```", "```\nclass MyFunctor f where  myfmap :: (a -> b) -> f a -> f b\n```", "```\nnewtype Identity a = Identity a\n```", "```\nfoo :: (->) Char Bool foo c = isUpper c\n```", "```\ninstance MyFunctor ((,) a) where myfmap f (a, b) = (a, f b)\n```", "```\ninstance MyFunctor ((,) a) where myfmap f (a, b) = (a, f b)\n```", "```\ninstance MyFunctor ((->) a) where {- ... -}\n```", "```\ninstance MyFunctor ((->) a) where myfmap f g = \\x -> f (g x)\n```", "```\nreadFile \"/etc/passwd\"\n```", "```\n(length . lines) `fmap` readFile \"/etc/passwd\"\n```", "```\nfmap id === id\n```", "```\nfmap (g . h) = (fmap g) . (fmap h)\n```", "```\nclass Functor f where  fmap :: (a -> b) -> f a -> f b\n```", "```\nclass Functor f where  fmap :: (a -> b) -> (f a -> f b)\n```", "```\nclass Functor f where  fmap :: (a -> b) -> (f a -> f b)\n```", "```\nclass Functor f => Applicative f where  pure :: a -> f a  (<*>) :: f (a -> b) -> f a -> f b\n```", "```\n(<*>) :: f (a -> b) -> f a -> f b fmap :: (a -> b) -> f a -> f b ($) :: (a -> b) -> a -> b\n```", "```\nclass Functor f => Applicative f where  pure :: a -> f a  (<*>) :: f (a -> b) -> f a -> f b\n```", "```\ninstance Applicative Maybe where pure x = Just x\n```", "```\n-- (<*>) :: f (a -> b) -> f a -> f b (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b\n```", "```\nclass Functor f => Applicative f where  pure :: a -> f a  (<*>) :: f (a -> b) -> f a -> f b\n```", "```\ninstance Applicative Maybe where pure x = Just x\n```", "```\n(<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b Just f <*> Just x = Just (f x) _ <*> _ = Nothing\n```", "```\nnewtype MyConst a b = MyConst a\n```", "```\nimport Control.Applicative import Data.Char (chr) import Numeric (readHex) import Text.Parsec (char, hexDigit) import Text.Parsec.String (Parser) hexChar :: Parser Char hexChar = char '%' *> (combo <$> hexDigit <*> hexDigit) where combo a b = case readHex [a,b] of [(n,\"\")] -> chr n _ -> error \"wat\"\n```", "```\n-- Sequence two actions, discarding the result of the first. (*>) :: Applicative f => f a -> f b -> f b -- You'll see this everywhere. (<$>) = fmap\n```", "```\nname=bryan+o%27sullivan&city=san+francisco\n```", "```\nquery = pair `sepBy` char '&'\n```", "```\n-- Zero or more elements, separated by a separator. sepBy :: Alternative f => f a -> f sep -> f [a]\n```", "```\nclass Applicative f => Alternative f where  empty :: f a  (<|>) :: f a -> f a -> f a\n```", "```\n-- Zero or more elements, separated by a separator. sepBy :: Alternative f => f a -> f sep -> f [a] sepBy p sep = sepBy1 p sep <|> pure [] -- One or more elements, separated by a separator. sepBy1 :: Alternative f => f a -> f sep -> f [a] sepBy1 p sep = (:) <$> p <*> many (sep *> p) many :: Alternative f => f a -> f [a]\n```", "```\npair :: Parser (String, Maybe String) pair = (,) <$> many1 urlChar <*> optional (char '=' *> many urlChar) urlChar = oneOf urlBaseChars <|> hexChar <|> ' ' <$ char '+'\n```", "```\noptional :: Alternative f => f a -> f (Maybe a) -- Replace all locations in the input with the same value. (<$) :: Functor f => a -> f b -> f a\n```", "```\nquery = pair `sepBy` char '&' pair :: Parser (String, Maybe String) pair = (,) <$> many1 urlChar <*> optional (char '=' *> many urlChar) urlChar = oneOf urlBaseChars <|> hexChar <|> ' ' <$ char '+' hexChar :: Parser Char hexChar = char '%' *> (eval <$> hexDigit <*> hexDigit) where eval a b = case readHex [a,b] of [(n,\"\")] -> chr n _ -> error \"wat\" urlBaseChars = ['a'..'z']++['A'..'Z']++['0'..'9']++\"$-_.!*'(),\"\n```", "```\nclass Monad m where  return :: a -> m a  (>>=) :: m a -> (a -> m b) -> m b\n```", "```\n(>>=) :: Monad m => m a -> (a -> m b) -> m b (=<<) :: Monad m => (a -> m b) -> m a -> m b\n```", "```\n(<*>) :: Applicative f => f (a -> b) -> f a -> f b fmap :: Functor f => (a -> b) -> f a -> f b ($) :: (a -> b) -> a -> b\n```", "```\n(=<<) :: Monad m => (a -> m b) -> m a -> m b (<*>) :: Applicative f => f (a -> b) -> f a -> f b fmap :: Functor f => (a -> b) -> f a -> f b ($) :: (a -> b) -> a -> b\n```", "```\n(<*>) :: Applicative f => f (a -> b) -> f a -> f b fmap :: Functor f => (a -> b) -> f a -> f b\n```", "```\n(=<<) :: Monad m => (a -> m b) -> m a -> m b (<*>) :: Applicative f => f (a -> b) -> f a -> f b\n```"]