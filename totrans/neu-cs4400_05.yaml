- en: Lists & RecursionTuesday, January 10th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are a fundamental Racket data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list is defined as either:'
  prefs: []
  type: TYPE_NORMAL
- en: the empty list (`null`, `empty`, or `'()`),
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a pair (`cons` cell) of anything and a list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As simple as this may seem, it gives us precise *formal* rules to prove that
    something is a list.
  prefs: []
  type: TYPE_NORMAL
- en: Why is there a “the” in the first rule?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'List operations — predicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can derive `list?` from the above rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But why can’t we define `list?` more simply as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the above definition and the proper one can be observed
    in the full Racket language, not in the student languages (where there are no
    pairs with non-list values in their tails).
  prefs: []
  type: TYPE_NORMAL
- en: 'List operations — destructors for pairs (`cons` cells):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Traditionally called `car`, `cdr`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, any `c<x>r` combination for `<x>` that is made of up to four `a`s and/or
    `d`s — we will probably not use much more than `cadr`, `caddr` etc.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example for recursive function involving lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use different tools, esp:'
  prefs: []
  type: TYPE_NORMAL
- en: syntax-checker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stepper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How come we could use `list` as an argument — use the syntax checker
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Main idea: lists are a recursive structure, so functions that operate on lists
    should be recursive functions that follow the recursive definition of lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Another example for list function — summing a list of numbers
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Also show how to implement `rcons`, using this guideline.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'More examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Define `reverse` — solve the problem using `rcons`.
  prefs: []
  type: TYPE_NORMAL
- en: '`rcons` can be generalized into something very useful: `append`.'
  prefs: []
  type: TYPE_NORMAL
- en: How would we use `append` instead of `rcons`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much time will this take? Does it matter if we use `append` or `rcons`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redefine `reverse` using tail recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Is the result more complex? (Yes, but not too bad because it collects the elements
    in reverse.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
