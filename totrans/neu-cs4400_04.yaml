- en: Quick Intro to RacketTuesday, January 10th
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Racket syntax: similar to other Sexpr-based languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reminder: the parens can be compared to C/etc function cal parens — they always
    mean that some function is applied. This is the reason why `(+ (1) (2))` won’t
    work: if you use C syntax that is `+(1(), 2())` but `1` isn’t a function so `1()`
    is an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important difference between *syntax* and *semantics*. A good way to think
    about this is the difference between the *string* `42` stored in a file somewhere
    (two ASCII values), and the *number* `42` stored in memory (in some representation).
    You could also continue with the above example: there is nothing wrong with “*murder*”
    — it’s just a word, but *murder* is something you’ll go to jail for. The evaluation
    function that Racket uses is actually a function that takes a piece of syntax
    and returns (or executes) its semantics.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`define` expressions are used for creating new bindings, do not try to use
    them to change values. For example, you should not try to write something like
    `(define x (+ x 1))` in an attempt to mimic `x = x+1`. It will not work.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two boolean values built in to Racket: `#t` (true) and `#f` (false).
    They can be used in `if` statements, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'because `(< 2 3)` evaluates to `#t`. As a matter of fact, *any* value except
    for `#f` is considered to be true, so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Racket is a *functional* language — so *everything* has a value.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that the expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: has no meaning when `test` evaluates to `#f`. This is unlike Pascal/C where
    statements *do* something (side effect) like printing or an assignment — here
    an `if` statement with no alternate part will just *do nothing* if the test is
    false… Racket, however, must return some value — it could decide on simply returning
    `#f` (or some unspecified value) as the value of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: as some implementations do, but Racket just declares it a syntax error. (As
    we will see in the future, Racket has a more convenient `when` with a clearer
    intention.)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Well, *almost* everything is a value…
  prefs: []
  type: TYPE_NORMAL
- en: There are certain things that are part of Racket’s syntax — for example `if`
    and `define` are special forms, they do not have a value! More about this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '(Bottom line: much more things do have a value, compared with other languages.)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`cond` is used for a `if` … `else if` … `else if` … `else` … sequence. The
    problem is that nested `if`s are inconvenient. For example,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In C/Java/Whatever, you’d write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '(Side question: why isn’t there a `return` statement in Racket?)'
  prefs: []
  type: TYPE_NORMAL
- en: 'But trying to force Racket code to look similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: is more than just bad taste — the indentation rules are there for a reason,
    the main one is that you can see the structure of your program at a quick glance,
    and this is no longer true in the above code. (Such code will be penalized!)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of this, we can use Racket’s `cond` statement, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that `else` is a keyword that is used by the `cond` form — you should always
    use an `else` clause (for similar reasons as an `if`, to avoid an extra expression
    evaluation there, and we will need it when we use a typed language). Also note
    that square brackets are read by DrRacket like round parens, it will only make
    sure that the paren pairs match. We use this to make code more readable — specifically,
    there is a major difference between the above use of `[]` from the conventional
    use of `()`. Can you see what it is?
  prefs: []
  type: TYPE_NORMAL
- en: 'The general structure of a `cond`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example for using an `if` expression, and a recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this to show the different tools, especially:'
  prefs: []
  type: TYPE_NORMAL
- en: special objects that *cannot* be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: syntax-checker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: stepper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: submission tool (installing, registering and submitting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of converting it to tail recursive form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional notes about homework submissions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin every function with clear documentation: a purpose of statement and its
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document the function when needed, and according to the guidelines above and
    in the style guide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the function, always have a few test cases — they should cover your complete
    code (make sure to include possible corner cases). Later on, we will switch to
    testing the whole file through it’s “public interface”, instead of testing each
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
