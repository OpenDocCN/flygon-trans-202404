["```\n    $ cabal install simple wai-handler-devel\n    ```", "```\n    $ git clone git://github.com/alevy/simple.git $ git clone git://github.com/alevy/postgresql-orm.git $ cd simple $ cabal install $ cd ../postgresql-orm $ cabal install $ cabal install wai-handler-devel\n    ```", "```\nx = 123 def incr(y) y + 1 end\n```", "```\nprotected static int x = 123; public static int incr(int y) { return y + 1; }\n```", "```\nArray.map(myarr, new Runnable() { public void run(int elm) { return elm * 42; } })\n```", "```\nmyarr.map {|elm| elm * 42}\n```", "```\nx = 123 -- :: Num a => a incr y = y + 1 -- :: Num a => a -> a\n```", "```\nmap (* 42) myarr\n```", "```\n    data Request = Request {pathInfo :: [String], requestMethod :: Method, ...} data Response = Response Status [Header] String\n    ```", "```\n    type Application = ...\n    ```", "```\n```", "```\n```", "```\ndata Request = Request {  requestMethod :: Method , httpVersion :: HttpVersion , rawPathInfo :: ByteString , rawQueryString :: ByteString , requestHeaders :: RequestHeaders , isSecure :: Bool , remoteHost :: SockAddr , pathInfo :: [Text] , queryString :: Query , requestBody :: Source IO ByteString , vault :: Vault , requestBodyLength :: RequestBodyLength , requestHeaderHost :: Maybe B.ByteString , requestHeaderRange :: Maybe B.ByteString } data Response = ResponseFile Status ResponseHeaders FilePath (Maybe FilePart) | ResponseBuilder Status ResponseHeaders Builder | ResponseSource Status ResponseHeaders (forall b. WithSource IO (C.Flush Builder) b) | ResponseRaw (forall b. WithRawApp b) Response type Application = Request -> IO Response\n```", "```\n$ cabal install wai warp\n```", "```\nmodule Main where import qualified Data.ByteString.Lazy.Char8 as L8 import Network.HTTP.Types import Network.Wai import Network.Wai.Handler.Warp (run) app :: Application app req = return $ responseLBS status200 [] $ L8.pack \"Hello, World\" main :: IO () main = do run 3000 app\n```", "```\nnewtype Controller s a = Controller {  runController :: s -> Request -> IO (Either Response a, s) } instance Monad Controller instance Applicative Controller instance MonadIO Controller\n```", "```\nrespond :: Response -> Controller s a okHtml :: ByteString -> Response notFound :: Response respond $ okHtml \"Hello world\"\n```", "```\nrequest :: Controller s Request controllerState :: Controller s s\n```", "```\nqueryParam' :: Parseable p => Controller s p parseForm :: Controller s ([Param], (ByteString, FileInfo ByteString))\n```", "```\n-- Match on next dir in path routeName :: Text -> Controller s () -> Controller s () routeName \"articles\" $ ... -- Treat first dir in path as query param routeVar :: Text -> Controller s () -> Controller s () routeName \"articles\" $ routeVar \"name\" $ ... -- Match whole pattern of path routePattern :: Text -> Controller s () -> Controller s () routePattern \"/articles/:name\" $ ... -- Match if no path left routeTop :: Controller s () -> Controller s () -- Match on request method routeMethod :: Method -> Controller s () -> Controller s () routeMethod GET $ routePatter \"/articles/:name\" -- Match hostname routeHost :: ByteString -> Controller s () -> Controller s ()\n```", "```\nget :: Text -> Controller s () -> Controller s () get ptrn ctrl = routeMethod GET $ routePattern ptrn ctrl post :: Text -> Controller s () -> Controller s () post ptrn ctrl = routeMethod POST $ routePattern ptrn ctrl\n```", "```\nmyapp :: Controller s () myapp = do get \"/\" $ respond $ okHtml \"Hello World\" get \"/foo\" $ respond $ okHtml \"bar\"\n```", "```\ndata Article = Article { articleId :: DBKey , articleTitle :: Text , articleBody :: Text , articleShortName :: Text }\n```", "```\nclass Model a where  modelInfo :: ModelInfo a  modelRead :: RowParser a  modelWrite :: a -> [Action] data DBKey = DBKey !Int64 | NullKey data ModelInfo a = ModelInfo {  modelTable :: ByteString , modelColumns :: [ByteString] , modelPrimaryColumn :: Int , modelGetPrimaryKey :: a -> DBKey }\n```", "```\n{-# LANGUAGE DeriveGeneric #-} import GHC.Generics data Article = Article { articleId :: DBKey , articleTitle :: Text , articleBody :: Text , articleShortName :: Text } deriving (Show, Generic) instance Model Article\n```", "```\nsave :: Model a => Connection -> a -> IO () findAll :: Model a => Connection -> IO [a] findRow :: Model a => Connection -> DBRef a -> IO (Maybe a)\n```", "```\n$ cabal install simple $ smpl create my_cms\n```"]