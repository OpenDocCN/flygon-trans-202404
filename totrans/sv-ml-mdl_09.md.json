["```\nclass DataProcessorKeyed\n    extends CoProcessFunction[WineRecord, ModelToServe, Double]\n      with CheckpointedFunction\n      with CheckpointedRestoring[List[Option[Model]]] {\n\n var modelState: ValueState[ModelToServeStats] = _\n var newModelState: ValueState[ModelToServeStats] = _\n ...\n\n override def open(parameters: Configuration): Unit = {\n val modelDesc = new ValueStateDescriptor[ModelToServeStats](\n   \"currentModel\",\n   createTypeInformation[ModelToServeStats])\n   modelDesc.setQueryable(\"currentModel\")\n\n modelState = getRuntimeContext.getState(modelDesc)\n val newModelDesc = new ValueStateDescriptor[ModelToServeStats](\n   \"newModel\",\n   createTypeInformation[ModelToServeStats])\n newModelState = getRuntimeContext.getState(newModelDesc)\n}\n\noverride def processElement2(model: ModelToServe,\n    ctx: CoProcessFunction[WineRecord,\n    ModelToServe, Double]#Context, out: Collector[Double]): Unit = {\n\n   import DataProcessorKeyed._\n\n   println(s\"New model - $model\")\n   newModelState.update(new ModelToServeStats(model))\n   newModel = factories.get(model.modelType) match {\n     case Some(factory) => factory.create (model)\n     case _ => None\n   }\n }\n\n override def processElement1(record: WineRecord,\n    ctx: CoProcessFunction[WineRecord,\n    ModelToServe, Double]#Context, out: Collector[Double]): Unit = {\n\n    ...\n    val start = System.currentTimeMillis()\n    val quality = model.score(record\n      .asInstanceOf[AnyVal]).asInstanceOf[Double]\n    val duration = System.currentTimeMillis() - start\n    modelState.update(modelState.value().incrementUsage(duration))\n    ...\n}\n```", "```\nobject ModelStateQuery {\n def main(args: Array[String]) {\n   val jobId = JobID.fromHexString(\"...\")\n   val types = Array(\"wine\")\n   val config = new Configuration()\n   config.setString(JobManagerOptions.ADDRESS, \"localhost\")\n   config.setInteger(JobManagerOptions.PORT, 6124)\n   ...\n   val client = new QueryableStateClient(config,\n     highAvailabilityServices)\n   val execConfig = new ExecutionConfig\n   val keySerializer = createTypeInformation[\n     String].createSerializer(execConfig)\n   val valueSerializer = createTypeInformation[ModelToServeStats]\n     .createSerializer(execConfig)\n   while(true) {\n     val stats = for (key <- types) yield {\n       val serializedKey = KvStateRequestSerializer\n          .serializeKeyAndNamespace(key,keySerializer,\n          VoidNamespace.INSTANCE, VoidNamespaceSerializer.INSTANCE)\n       // now wait for the result and return it\n       try {\n         val serializedResult = client.getKvState(jobId,\n           \"currentModel\",key.hashCode(), serializedKey)\n         val serializedValue = Await.result(serializedResult,\n           FiniteDuration(2, TimeUnit.SECONDS))\n         val value = KvStateRequestSerializer.deserializeValue\n           (serializedValue, valueSerializer)\n         List(value.name, value.description, value.since,\n           value.usage,value.duration, value.min, value.max)\n    ...\n     }\n     stats.toList.filter(_.nonEmpty).foreach(row =>\n...\n}\n```", "```\npublic class ModelServingInfo {\n\n   private String name;\n   private String description;\n   private long since;\n   private long invocations;\n   private double duration;\n   private long min;\n   private long max;\n   ...\n   public void update(long execution){\n       invocations++;\n       duration += execution;\n       if(execution < min) min = execution;\n       if(execution > max) max = execution;\n   }\n...\n}\n```", "```\npublic class StoreState {\n   ...\n   private ModelServingInfo currentServingInfo = null;\n   private ModelServingInfo newServingInfo = null;\n   ...\n   public ModelServingInfo getCurrentServingInfo() {\n     return currentServingInfo;}\n\n   public void setCurrentServingInfo(ModelServingInfo\n     currentServingInfo) {\n       this.currentServingInfo = currentServingInfo;\n   }\n\n   public ModelServingInfo getNewServingInfo() {\n     return newServingInfo;}\n\n   public void setNewServingInfo(ModelServingInfo newServingInfo) {\n       this.newServingInfo = newServingInfo;\n   }\n}\n```", "```\n...\nprivate void writeServingInfo(ModelServingInfo servingInfo,\n  DataOutputStream output){\n   try{\n       if(servingInfo == null) {\n           output.writeLong(0);\n           return;\n       }\n       output.writeLong(5);\n       output.writeUTF(servingInfo.getDescription());\n       output.writeUTF(servingInfo.getName());\n       output.writeDouble(servingInfo.getDuration());\n       output.writeLong(servingInfo.getInvocations());\n       output.writeLong(servingInfo.getMax());\n       output.writeLong(servingInfo.getMin());\n       output.writeLong(servingInfo.getSince());\n   }\n   catch (Throwable t){\n       System.out.println(\"Error Serializing servingInfo\");\n       t.printStackTrace();\n   }\n}\n...\nprivate ModelServingInfo readServingInfo(DataInputStream input) {\n   try {\n       long length = input.readLong();\n       if (length == 0) return null;\n       String descriprtion = input.readUTF();\n       String name = input.readUTF();\n       double duration = input.readDouble();\n       long invocations = input.readLong();\n       long max  = input.readLong();\n       long min = input.readLong();\n       long since = input.readLong();\n       return new ModelServingInfo(name, descriprtion, since,\n         invocations,duration, min, max); duration, min, max);\n   } catch (Throwable t) {\n       System.out.println(\"Error Deserializing serving info\");\n       t.printStackTrace();\n       return null;\n   }\n}\n```", "```\npublic interface ReadableModelStateStore {\n   ModelServingInfo getCurrentServingInfo();\n}\n```", "```\n...\n   // Score the model\n   long start = System.currentTimeMillis();\n   double quality = (double) modelStore.getCurrentModel().score(\n     dataRecord.get());\n   long duration = System.currentTimeMillis() - start;\n   modelStore.getCurrentServingInfo().update(duration);\n...\n```", "```\npublic class MetadataService {\n   private final KafkaStreams streams;\n\n   public MetadataService(final KafkaStreams streams) {\n       this.streams = streams;\n   }\n\n   public List<HostStoreInfo> streamsMetadata() {\n       // Get metadata for all of the instances of this application\n       final Collection<StreamsMetadata> metadata =\n         streams.allMetadata();\n       return mapInstancesToHostStoreInfo(metadata);\n   }\n\n   public List<HostStoreInfo> streamsMetadataForStore(\n     final  String store) {\n       // Get metadata for all of the instances of this application\n       final Collection<StreamsMetadata> metadata =\n         streams.allMetadataForStore(store);\n       return mapInstancesToHostStoreInfo(metadata);\n   }\n\n   private List<HostStoreInfo> mapInstancesToHostStoreInfo(\n     final Collection<StreamsMetadata> metadatas) {\n       return metadatas.stream().map(metadata -> new HostStoreInfo(\n         metadata.host(),metadata.port(),\n         metadata.stateStoreNames()))\n         .collect(Collectors.toList());\n   }\n}\n```", "```\n@Path(\"state\")\npublic class QueriesRestService {\n   private final KafkaStreams streams;\n   private final MetadataService metadataService;\n   private Server jettyServer;\n\n   public QueriesRestService(final KafkaStreams streams) {\n       this.streams = streams;\n       this.metadataService = new MetadataService(streams);\n   }\n\n   @GET()\n   @Path(\"/instances\")\n   @Produces(MediaType.APPLICATION_JSON)\n   public List<HostStoreInfo> streamsMetadata() {\n       return metadataService.streamsMetadata();\n   }\n   @GET()\n   @Path(\"/instances/{storeName}\")\n   @Produces(MediaType.APPLICATION_JSON)\n   public List<HostStoreInfo> streamsMetadataForStore(\n   @PathParam(\"storeName\") String store) {\n       return metadataService.streamsMetadataForStore(store);\n   }\n   @GET\n   @Path(\"{storeName}/value\")\n   @Produces(MediaType.APPLICATION_JSON)\n   public ModelServingInfo servingInfo(\n   @PathParam(\"storeName\") final String storeName) {\n       // Get the Store\n       final ReadableModelStateStore store = streams.store(\n         storeName, new ModelStateStore.ModelStateStoreType());\n       if (store == null) {\n           throw new NotFoundException();\n       }\n       return store.getCurrentServingInfo();\n   }\n\n...\n}\n```", "```\npublic class HostStoreInfo {\n   private String host;\n   private int port;\n   private Set<String> storeNames;\n   ...\n   public String getHost() {return host;}\n   public void setHost(final String host) {this.host = host;}\\\n   public int getPort() {return port;}\n   public void setPort(final int port) {this.port = port;}\n   public Set<String> getStoreNames() {return storeNames;}\n   public void setStoreNames(final Set<String> storeNames) {\n       this.storeNames = storeNames;\n   }\n}\n```", "```\npublic class ModelStateStoreType implements\nQueryableStoreType<ReadableModelStateStore> {\n   @Override public boolean accepts(StateStore stateStore) {\n       return stateStore instanceof ModelStateStore;\n   }\n   @Override public ReadableModelStateStore create(\n     StateStoreProvider provider,String storeName) {\n       return provider.stores(storeName, this).get(0);\n   }\n}\n```", "```\npublic class ModelServerWithStore {\n   final static int port=8888;\n\n   public static void main(String [ ] args) throws Throwable {\n   ...\n       // Start the Restful proxy for servicing remote access\n       final QueriesRestService restService =\n         startRestProxy(streams, port);\n       // Add shutdown hook to respond to SIGTERM\n       Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n           try {\n               streams.close();\n               restService.stop();\n           } catch (Exception e) {\n               // ignored\n           }\n       }));\n   }\n   ...\n   static QueriesRestService startRestProxy(KafkaStreams streams,\n     int port) throws Exception {\n       final QueriesRestService restService =\n         new QueriesRestService(streams);\n       restService.start(port);\n       return restService;\n   }\n}\n```", "```\ntrait ReadableModelStateStore {\n def getCurrentServingInfo: ModelToServeStats\n}\n```", "```\nclass ModelStage extends GraphStageWithMaterializedValue\n  [ModelStageShape,ReadableModelStateStore] {\n     ...\n     setHandler(shape.dataRecordIn, new InHandler {\n       override def onPush(): Unit = {\n         val record = grab(shape.dataRecordIn)\n         newModel match {\n           ...\n         }\n         currentModel match {\n           case Some(model) => {\n             val start = System.currentTimeMillis()\n             val quality = model.score(record.asInstanceOf[AnyVal]).\n               asInstanceOf[Double]\n             val duration = System.currentTimeMillis() - start\n             println(s\"Calculated quality - $quality calculated in\n               $duration ms\")\n             currentState.get.incrementUsage(duration)\n             push(shape.scoringResultOut, Some(quality))\n           }\n           case _ => {\n             println(\"No model available - skipping\")\n             push(shape.scoringResultOut, None)\n           }\n         }\n         pull(shape.dataRecordIn)\n       }\n     })\n\n...\n     // We materialize this value\n     val readableModelStateStore = new ReadableModelStateStore() {\n       override def getCurrentServingInfo: ModelToServeStats =\n         logic.currentState.getOrElse(ModelToServeStats.empty)\n     }\n     new Tuple2[GraphStageLogic, ReadableModelStateStore]\n     (logic, readableModelStateStore)\n }\n}\n```", "```\nobject QueriesAkkaHttpResource extends JacksonSupport {\n\n def storeRoutes(predictions: ReadableModelStateStore) :\n   Route = pathPrefix(\"stats\"){\n   pathEnd {\n     get {\n       val info: ModelToServeStats =\n         predictions.getCurrentServingInfo\n       complete(info)\n     }\n   }\n }\n}\n```", "```\nobject AkkaModelServer {\n...\n\n def main(args: Array[String]): Unit = {\n\n...\n\n   val modelStream: Source[ModelToServe, Consumer.Control] =\n\n...\n\n   val dataStream: Source[WineRecord, Consumer.Control] =\n\n...\n\n   val model = new ModelStage()\n\n   def keepModelMaterializedValue[M1, M2, M3](\n     m1: M1, m2: M2, m3: M3): M3 = m3\n\n   val modelPredictions :\n     Source[Option[Double], ReadableModelStateStore] =\n    Source.fromGraph(\n     GraphDSL.create(dataStream, modelStream, model)(\n       keepModelMaterializedValue) {\n       implicit builder => (d, m, w) =>\n         import GraphDSL.Implicits._\n\n         d ~> w.dataRecordIn\n         m ~> w.modelRecordIn\n         SourceShape(w.scoringResultOut)\n     }\n   )\n\n val materializedReadableModelStateStore: ReadableModelStateStore =\n     modelPredictions\n       .map(println(_))\n       .to(Sink.ignore)\n       .run() // run the stream, materializing the StateStore\n\n   startRest(materializedReadableModelStateStore)\n }\n\n def startRest(service : ReadableModelStateStore) : Unit = {\n\n   implicit val timeout = Timeout(10 seconds)\n   val host = \"localhost\"\n   val port = 5000\n   val routes: Route = QueriesAkkaHttpResource.storeRoutes(service)\n\n   Http().bindAndHandle(routes, host, port) map\n     { binding => println(s\"REST interface bound to\n        ${binding.localAddress}\") }\n     recover { case ex => println(\n        s\"REST interface could not bind to $host:$port\", ex.getMessage)\n   }\n }\n}\n```"]