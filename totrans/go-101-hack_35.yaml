- en: error vs errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: error vs errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Handling errors is a crucial part of writing robust programs. When scanning
    the `Go` packages, it is not rare to see APIs which have multiple return values
    with an error among them. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: func Open(name string) (*File, error)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Open opens the named file for reading. If successful, methods on the returned
    file can be used for reading; the associated file descriptor has mode O_RDONLY.
    If there is an error, it will be of type *PathError.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And the idiomatic method of using `os.Open` function is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So to implement resilient `Go` programs, how to generate and deal with errors
    is a required course.
  prefs: []
  type: TYPE_NORMAL
- en: '`Go` provides both `error` and `errors`, and you shouldn''t mix up them. `error`
    is a built-in interface type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So for any type, as long as it implements `Error() string` method, it will
    satisfy `error` interface automatically. `errors` is one of my favorite packages
    since it is very simple (The life will definitely be easier if every package is
    similar to `errors`!). Removing the comments, the amount of core code lines is
    very small:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `New` function in `errors` package returns an `errorString` struct which
    complies with `error` interface. Check the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution result is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In real life, you may prefer to use `Errorf` function defined in `fmt` package
    to create `error` interface, rather than use `errors.New()` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: func Errorf(format string, a ...interface{}) error
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Errorf formats according to a format specifier and returns the string as a value
    that satisfies error.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So the above code can be refactored as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'References:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Go Programming Language](http://www.gopl.io/).'
  prefs: []
  type: TYPE_NORMAL
