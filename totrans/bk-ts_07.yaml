- en: 'Chapter 7: Functions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript supports JavaScript functions as you already know them. As it often
    does, TypeScript adds new functionality, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Function Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed Parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional Parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rest Parameters^([1](#fn_1))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow Functions (often also called Lambda or Anonymous functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Everything has a type in TypeScript. If you don''t specify a type, TypeScript
    infers a type and for functions, it''s `Function`. You can declare a variable''s
    type to be `Function` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This isn't a terribly useful thing to do but it shows that there is a `Function`
    data type. You'll see down below that Arrow Functions are far more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Function Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most functions take at least one parameter and most useful functions return
    a value^([2](#fn_2)). You can specify a type for each function parameter as well
    as the return type of the function itself. Here''s a more robust `integerAdder()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a function, `integerAdder`. It takes two parameters and as
    you can see, they are both integer values. Furthermore, the integerAdder function
    itself returns a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a 30 second video showing this in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/zUI2Ygfdhj0](https://www.youtube.com/embed/zUI2Ygfdhj0)'
  prefs: []
  type: TYPE_NORMAL
- en: '(If you can''t see the video, try [accessing it via this link](https://youtu.be/zUI2Ygfdhj0)
    or type this url into your web browser: [https://youtu.be/zUI2Ygfdhj0](https://youtu.be/zUI2Ygfdhj0)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that integerAdder specifies both the types of its arguments and the type
    of its return value: `integerAdder(firstNumber: number, secondNumber: number):
    number`. This tells the TypeScript compiler enough information that it prevents
    you from making two mistakes common in the plain JavaScript world:'
  prefs: []
  type: TYPE_NORMAL
- en: You can't pass in non-numeric values to the integerAdder function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is numeric. You can't invoke the function and accept its result into
    a non-numeric variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functions don''t need to return a value. If you want to be explicit (and you
    probably do!), specify a return type of `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Optional Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can define functions that take optional parameters. Imagine that you have
    a function, `InitializeDataSet` in your application. Sometimes, you want to initialize
    the data set to a collection of hard coded values (i.e. defaults). In other cases,
    you want to provide some "seed" data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Use the question mark (?) to denote an optional parameter.
  prefs: []
  type: TYPE_NORMAL
- en: At run-time, client code invokes the function as normal. If that code does not
    supply a value for the optional parameter, its value is `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Default Parameter Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can specify a default value for your function''s parameters. Here''s the
    previous example re-written to show this syntax and discuss the implication of
    using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that:'
  prefs: []
  type: TYPE_NORMAL
- en: The function takes an input parameter, `seedData`. TypeScript infers the parameter's
    type as an object with two string properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If client code does not pass a value for seedData, it will use the specific
    initial value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you pass the value `undefined` to the function, it will also the specified
    initial value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rest Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you want to pass an unknown number of parameters to a function. This
    case frequently arises during React development, serializing and deserializing
    data and mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a logging example. We can always use `console.log()` to log
    out messages to the console. However, it''s a real challenge debugging applications
    at run-time, particularly errors reported by end users. By the time anyone tells
    you about the error, it''s too late for you to do much about it. Let''s add some
    persistent error logging to our toolkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a function, `myLogger`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'myLogger takes two parameters: `msgType` and `messages`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: msgType is a union data type - client code must pass "INFO" or "ERROR".
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: messages is an array of `any`. Note that `...` preceding the variable name.
    This indicates that all of the remaining arguments will be stuffed into the array.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see how the code invokes the myLogger function, passing in a variable
    number of arguments across its three invocations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrow Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrow functions take their name from their syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Many TypeScript developers prefer to call these *lambda* functions and sometimes
    *anonymous* functions. They almost always mean the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions are tremendously useful. They provide a nice syntax shortener
    and more importantly, help reduce confusion over JavaScript scopes by redefining
    the `this` keyword into something more intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a very simple example to get us started on the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This example defines and then invokes a function named `myHelloFunction`. Since
    myHelloFunction is `const` we need initialize it at definition-time. That''s this
    bit: `{return "Hello!"};` myHelloFunction is now a normal function and we can
    invoke it like any other JavaScript function using the function invocation operator,
    `()`: `myHelloFunction()`;'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to define the function body. For instance, this is perfectly
    good syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines a variable, `myGoodbyeFunction`. myGoodbyeFunction's
    type is a function that takes no parameters and returns a string.
  prefs: []
  type: TYPE_NORMAL
- en: The second line assigns a value to myGoodbyeFunction. In this case, it's the
    function body itself.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the code logs out the result of executing myGoodbyeFunction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go any further, lets look at the transpiled JavaScript. Here''s the
    myHelloFunction''s transpiled JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the line-by-line transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **TypeScript** | **Transpiled JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. let myGoodbyeFunction: () => string; | var myGoodbyeFunction; |'
  prefs: []
  type: TYPE_TB
- en: '| 2\. myGoodbyeFunction = () => {return "Good Bye!"} | myGoodbyeFunction =
    function () { return "Good Bye!"; }; |'
  prefs: []
  type: TYPE_TB
- en: '| 3\. console.log(myGoodbyeFunction()); | console.log(myGoodbyeFunction());
    |'
  prefs: []
  type: TYPE_TB
- en: '`let` transpiles into `var`. The arrow function transpiles into a straight-forward
    `function` definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Parameters in Arrow Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We specify parameters by inserting them info the `()` portion of the function
    definition. Here''s an adder function that takes two integer inputs and returns
    a numeric result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code defines a new function, `myAdderArrowFunction`, using the arrow syntax.
    myAdderFunction takes two numeric arguments and returns number.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to keep in mind that the `let` statement is merely defining a
    typed variable named myAdderFunction. It type happens to be a `Function` with
    typed signature and a typed result.
  prefs: []
  type: TYPE_NORMAL
- en: The second line initializes myAdderArrowFunction. Note that I didn't use the
    same names when specifying the input parameters. Again, the `let` statement is
    defining a type - a Function who takes in two arguments and returns a number.
    As long as meet the requirements of the type, the parameter names don't matter.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow function as interface components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given that arrow functions can define types independent of their implementation,
    you can use them anywhere else you would use a type, including interfaces. This
    is a very useful capability for many reasons. One reason comes into play when
    you''re working with an external library that was not written in TypeScript. This
    obviously happens a lot in the real world^([3](#fn_3)). Let''s assume that we
    are working with one such library that is responsible to create detailed, highly
    interactive visualizations. We don''t know how it works and we don''t care. We
    consult the library''s documentation and see that it provides a robust JavaScript
    API that includes the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Render`: We provide the ID of a `<div>` tag on our page and it renders the
    visualization there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetDimensions`: We can set the height an width with this call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SaveSettings`: We ask the engine to save the current screen settings for use
    next time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s some TypeScript that lets inject some strong typing into our code despite
    the fact that the vendor''s API does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is complex example. Let''s unpack it a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: The code defines an interface, `IVisualizationEngine`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface defines three different functions, one for each of the API calls
    we care about^([4](#fn_4)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get a handle to the engine via the global window object. In order for this
    to work, we had to reference the engine via a script tag in our HTML and the engine
    would have to save itself in the global window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we've done something really nice for ourselves. We now have strongly
    typed access to this third party's API! This allows the IDE to give us the great
    time-saving and error-reducing intellisense we've all grown to love so much.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another video showing these concepts. In this case, we''ll model an
    existing contacts management library that has been in production and stable for
    a long time. The video creates an interface to that plain JS library and then
    uses it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/e1BGcBO8E6U](https://www.youtube.com/embed/e1BGcBO8E6U)'
  prefs: []
  type: TYPE_NORMAL
- en: '(If you can''t see the video, try [clicking this link](https://youtu.be/e1BGcBO8E6U)
    to see it directly on YouTube. You can also try typing this link into your favorite
    web browser: [https://youtu.be/e1BGcBO8E6U](https://youtu.be/e1BGcBO8E6U).)'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow Functions as IIFEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw above, arrow functions transpile down to standard JavaScript functions.
    We can invoke functions as they are defined. These are called Immediately Invoked
    Function Expressions (IIFEs). Arrow functions can also be invoked at any time.
    Here''s a contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines a function here: `() => { return "Paul"}`. It encloses that
    line in its own set of parenthesis and then uses the invoke-function operator,
    `()` to immediately invoke the function. This is itself wrapped inside a template
    string and finally, the result is logged out to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the transpiled JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This (possibly over-produced :)) video shows it live:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/embed/DTBpHxWPf_w](https://www.youtube.com/embed/DTBpHxWPf_w)'
  prefs: []
  type: TYPE_NORMAL
- en: '(If you can''t see the video, [try clicking here](https://youtu.be/DTBpHxWPf_w)
    or typing this URL into your web browser: [https://youtu.be/DTBpHxWPf_w](https://youtu.be/DTBpHxWPf_w).)'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow Functions for Cleaner Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous example doesn''t show it well, but arrow functions can help you
    do more than teach your IDE about function types. It can also help you write cleaner
    code, although this may admittedly be in the eye of the beholder. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define an array of numbers, one through ten.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define a variable, `evenNumbers`. evenNumbers is the result of filtering
    on the numbers array, passing back only those items where mod two equals zero.
    This is a new form for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(item) => !(item % 2)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have written this fully out to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(item) => { return !(item % 2); }`'
  prefs: []
  type: TYPE_NORMAL
- en: It's a bit of shorthand that we're allowed do when you can return a value with
    a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example adds up all the numbers using the standard `reduce` function.
    Reduce runs against an array and takes a function and initial value as an argument.
    That function is passed the previous value and the current value, defined in the
    example as `(prev: number, curr: number)`^([5](#fn_5)). Note that `reduce` *also*
    passes a 3rd argument, the index of the item in the array. We don''t care about
    that so we don''t bother catching it, so to speak.'
  prefs: []
  type: TYPE_NORMAL
- en: Most TypeScript developers come to find Arrow functions to be very helpful and
    generally cleaner looking than spelling out the word "function" all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This blog post describes most of the same things covered here, along with two
    narrated videos: [http://executeautomation.com/blog/working-with-functions-anonymous-and-arrow-functions-in-typescript/](http://executeautomation.com/blog/working-with-functions-anonymous-and-arrow-functions-in-typescript/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This blog post provides a nicely detailed view into Arrow Functions and in particular,
    it explains how `this` works in that context. [http://piotrwalat.net/arrow-function-expressions-in-typescript/](http://piotrwalat.net/arrow-function-expressions-in-typescript/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript enhances plain JavaScript functions by...
  prefs: []
  type: TYPE_NORMAL
- en: Defining the types of function parameters (string, boolean, even interface types)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the return type of a function (not just its parameters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying default values for parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a variable number of parameters via the `rest` operator ("...")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like other Typescript artifacts, functions themselves are typed and their type
    is `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript introduces a different kind of function, the Arrow Function. We haven't
    heard the last of arrow functions. We'll revisit them in chapter 9, "Classes in
    Depth" and explore how they help simplify JavaScript closures. In short, they
    work in a more intuitive way with the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes functions. The next chapter gently introduces basic TypeScript
    classes and lays down the foundation for more advanced topics like abstract classes
    and how interfaces work with them.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ¹. Not to be confused with Representational State Transfer. Rest parameters
    are an entirely different thing, as you'll see. [↩](#reffn_1 "Jump back to footnote
    [1] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ². If your function doesn't return any value, there's a good chance it's affecting
    some data outside of its scope. This is usually a Bad Thing because it introduces
    the risk of side effects. If you want more convincing, you could [start here](https://softwareengineering.stackexchange.com/questions/15269/why-are-side-effects-considered-evil-in-functional-programming).
    [↩](#reffn_2 "Jump back to footnote [2] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ³. This happens so much in the real world that TypeScript provides a significant
    feature set to handle the challenge through the use of "typings files". The first
    cut of this book doesn't address typings in detail but the "Continue Learning"
    chapter will point you in the right direction. [↩](#reffn_3 "Jump back to footnote
    [3] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁴. In this context, "care about" means that the library might provide other
    useful functions but we don't plan to use them for one reason or another. We don't
    need to map each of them to our interface definition, just the ones we plan to
    use. [↩](#reffn_4 "Jump back to footnote [4] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁵. `Reduce`, along with `filter` and `map` tend to find themselves in code that
    adheres to a functional programming style. I've written a small series of blog
    posts on this subject up on my blog, [https://hackernoon.com/functional-programming-the-examples-series-851421e7ae5b](https://hackernoon.com/functional-programming-the-examples-series-851421e7ae5b).
    [↩](#reffn_5 "Jump back to footnote [5] in the text.")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
