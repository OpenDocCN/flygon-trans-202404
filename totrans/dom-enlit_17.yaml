- en: Chapter 12 - Creating dom.js - a wishful jQuery inspired DOM Library for modern
    browers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.1 dom.js overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I want you to take the information and knowledge from this book and leverage
    it as I walk you through a foundation for a wishful, modern, jQuery like DOM library
    called dom.js. Think of dom.js as the foundation to a modern library for selecting
    DOM nodes and doing something with them. Not unlike jQuery the dom.js code will
    provide a function for selecting something from the DOM (or creating) and then
    doing something with it. I show some examples of the *dom()* function below which
    shouldn't look all that foreign if you are familiar with jQuery or really any
    DOM utility for selecting elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For most readers this chapter is simply an exercise in taking the information
    in this book and applying it to a JavaScript DOM library. For others, this might
    just shed some light on jQuery itself and any DOM manipulation logic used in JavaScript
    frameworks today. Ideally, in the end, I hope this exercise inspires readers to
    craft their own micro DOM abstractions on an as needed bases when the situation
    is right. With that said, lets begin.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Create a unique scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To protect our dom.js code from the global scope, I will first create a unique
    scope to which it can live and operate within without fear of collisions in the
    global scope. In the code below I setup a pretty standard [Immediately-Invoked
    Function Expression](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)
    to create this private scope. When the IIFE is invoked the value of *global* will
    be set to the current global scope (i.e. *window*).
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Inside of the IIFE we setup a reference to the *window* and *document* object
    (i.e. *doc*) to speed up the access to these objects inside of the IIFE.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Create the *dom()* and *GetOrMakeDom()* functions exposing *dom()* and
    *GetOrMakeDom.prototype* to the global scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like jQuery we are going to create a function that will return a chain-able,
    wrapped set (i.e. custom array like object) of DOM nodes (e.g. *{0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}*)
    based on the parameters sent into the function. In the code below I setup the
    *dom()* function and parameters which get passed on to the *GetOrMakeDOM* constructor
    function that when invoked will return the object containing the DOM nodes, that
    is then returned by from *dom()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**In order for the *dom()* function to be accessed/called from outside of the
    private scope setup by the IIFE we have to expose the dom function (i.e. create
    a reference) to the global scope. This is done by creating a property in the global
    scope called *dom* and pointing that property to the local *dom()* function. When
    *dom* is accessed from the global scope it will point to my locally scoped *dom()*
    function. In the code below doing, *global.dom = dom;* does the trick.'
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do is expose the *GetOrMakeDom.prototype* property
    to the global scope. Not unlike jQuery (e.g. *jQuery.fn*) we are simply going
    to provide a shortcut reference from *dom.fn* to *GetOrMakeDOM.prototype*. This
    is shown in the code below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Now anything attached to the *dom.fn* is actually a property of the *GetOrMakeDOM.prototype*
    object and is inherited during property lookup for any object instance created
    from the *GetOrMakeDOM* constructor function.'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *getOrMakeDom* function is invoked with the *new* operator. Make sure you
    [understand](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/new)
    what happens when a function is invoked using the *new* operator.
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 Create optional context paramater passed to *dom()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When *dom()* is invoked, it also invokes the *GetOrMakeDom* function passing
    it the parameters that are sent to *dom()*. When the *GetOrMakeDOM* constructor
    is invoked the first thing we need to do is determine context. The context for
    working with the DOM can be set by passing a selector string used to select a
    node or a node reference itself. If its not obvious the purpose of passing a context
    to the *dom()* function provides the ability to limit the search for element nodes
    to a specific branch of the DOM tree. This is very similar, almost identical,
    to the second parameter passed to the *jQuery* or *$* function. In the code below
    I default the context to the current document found in the global scope. If a
    context parameter is available, I determine what it is (i.e. string or node) and
    either make the node passed in the context or select a node via *querySelectorAll()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the *context* parameter logic setup we can next add the logic required
    to deal with the *params* parameter used to actually select or created nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 12.5 Populate object with DOM node references based on *params* and return object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *params* parameter passed to *dom()*, then on to the *getOrMakeDom()* varies
    in the type of parameter that can be passed. Similar to jQuery the type''s of
    value''s passed can be any one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: css selector string (e.g. *dom('body')*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: html string (e.g. *dom('<p>Hellow</p><p> World!</p>')*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Element* node (e.g. *dom(document.body)*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: array of element nodes (e.g. *dom([document.body])*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a *NodeList* (e.g. *dom(document.body.children)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a *HTMLcollection* (e.g. *dom(document.all)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a *dom()* object itself. (e.g. *dom(dom())*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of passing *params* is the construction of a chain-able object containing
    references to nodes (e.g. *{0:ELEMENT_NODE,1:ELEMENT_NODE,length:2})* either in
    the DOM or in a document fragment. Lets examine how each of the above parameters
    can be used to produce an object containing node references.
  prefs: []
  type: TYPE_NORMAL
- en: The logic to permit such a wide variety of parameter types is shown below in
    the code and starts with a simple check to verify that *params* is not *undefined*,
    an empty string, or a string with empty spaces. If this is the case we add a *length*
    property with a value of *0* to the object constructed from calling *GetOrMakeDOM*
    and return the object so the execution of the function ends. If *params* is not
    a false ([or false like](http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/))
    value the execution of the function continues.
  prefs: []
  type: TYPE_NORMAL
- en: Next the *params* value, if a string, is checked to see if contains HTML. If
    the string contains HTML then a [document fragmen](https://developer.mozilla.org/en-US/docs/DOM/DocumentFragment)t
    is created and the string is used as the *innerHTML* value for a *<div>* contained
    in the document fragment so that the string is converted to a DOM structure. With
    the html string converted to a node tree, the structure is looped over accessing
    top level nodes, and references to these nodes are passed to the object being
    created by *GetOrMakeDom*. If the string does not contain HTML execution of the
    function continues.
  prefs: []
  type: TYPE_NORMAL
- en: The next check simply verifies if *params* is a reference to a single node and
    if it is we wrap a reference to it up in an object and return it other wise at
    we are pretty sure the *params* value is a [html collection](https://developer.mozilla.org/en-US/docs/DOM/HTMLCollection),
    [node list](https://developer.mozilla.org/en-US/docs/DOM/NodeList), array, string
    [selector](http://www.quirksmode.org/css/contents.html), or an object created
    from *dom()*. If its a string selector, a node list is created by calling the
    *queryselectorAll()* method on the *currentContext*. If its not a string selector
    we loop over the html collection, node list, array, or object extracting the node
    references and using the references as values contained in the object sent back
    from calling the *GetOrMakeDom*.
  prefs: []
  type: TYPE_NORMAL
- en: All of this logic inside of *GetOrMakeDom()* function can be a bit overwhelming
    just realize that the point of the constructor function is to construct an object
    containing references to nodes (e.g. *{0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}*)
    and returns this object to *dom()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 12.6 Create *each()* method and make it a chainable method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we invoke *dom()* we can access anything attached to *dom.fn* by way of
    prototypical inheritance. (e.g. *dom().each())*. Not unlike jQuery methods attached
    to *dom.fn* operate on the object created from the *GetOrMakeDom* constructor
    function. The code below setups the *each()* method.
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect the *each()* method takes a callback function as a parameter
    and invokes the function (setting the *this* value to the element node object
    with *call()*) for each node element in the *getOrMakeDom* object instance. The
    *this* value inside of the *each()* function is a reference to the *getOrMakeDom*
    object instance (e.g. *{0:ELEMENT_NODE,1:ELEMENT_NODE,length:2}*).
  prefs: []
  type: TYPE_NORMAL
- en: When a method does not return a value (e.g. *dom().length* returns a length)
    its possible to allow method chaning by simply returning the object the method
    belongs too instead of a specific value. Basically, we are returning the *GetOrMakeDom*
    object so another method can be called on this instance of the object. In the
    code below I would like the *each()* method to be chainable, meaning more methods
    can be called after calling *each()*, so I simply return *this*. The *this* in
    the code below is the object instance created from calling the *getOrMakeDom*
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*## 12.7 Create *html()*, *append()*, & *text()* methods'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the core *each()* method created and implicit iteration avaliable we can
    now build out a few *dom()* methods that act on the nodes we select from an HTML
    document or create using document fragments. The three methods we are going to
    create are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*html()* / *html(''html string'')*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*text()* / *text(''text string'')*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*append(''html | text | dom() | nodelist/HTML collection | node | array'')*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *html()* and *text()* methods follow a very similar pattern. If the method
    is called with a parameter value we loop (using *dom.fn.each()* for implicit iteration
    ) over each element node in the *getOrMakeDom* object instance setting either
    the *innerHTML* value or *textContent* value. If no parameter is sent we simply
    return the *innerHTML* or *textContent* value for the first element node in the
    *getOrMakeDom* object instance. Below you will see this logic coded.
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The *append()* method leveraging *insertAdjacentHTML* will take a an html string,
    text string, *dom()* object, nodelist/HTML collection a single node or array of
    nodes and appends it to the nodes selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'github code: [https://github.com/codylindley/domjs/blob/master/builds/dom.js](https://github.com/codylindley/domjs/blob/master/builds/dom.js)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 12.8 Taking dom.js for a spin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the creation of [dom.js I created some very simple qunit tests](https://github.com/codylindley/domjs/tree/master/test)
    that we are now going to run outside of the testing framework. However, you can
    also [run the testing framework](https://github.com/codylindley/domjs/blob/master/test/index.html)
    to see dom.js in action. The follow code demostrates the code create in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'live code: [http://jsfiddle.net/domenlightenment/7aqKm](http://jsfiddle.net/domenlightenment/7aqKm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 12.9 Summary & continuing on with dom.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter has been about creating a foundation to a jQuery like DOM library.
    If you'd like to continue studying the building blocks to a jQuery-like DOM library
    I would suggest checking out [hippo.js](https://github.com/codylindley/hippojs),
    which is an exercise in re-creating the jQuery DOM methods for modern browsers.
    Both [dom.js](https://github.com/codylindley/domjs) and [hippo.js](https://github.com/codylindley/hippojs)
    make use of [grunt](http://gruntjs.com/), [QUnit](http://qunitjs.com/), and [JS
    Hint](http://jshint.com/) which I highly recommend looking into if building your
    own JavaScript libraries is of interest. In addition to the fore mentioned developer
    tools I highly recommending reading, "[Designing Better JavaScript APIs](http://coding.smashingmagazine.com/2012/10/09/designing-javascript-apis-usability/)".
    Now go build something for the DOM.*****
  prefs: []
  type: TYPE_NORMAL
