["```\ntype alias State = Int\ninitState        = 0\nupstate _ i      = i + 1 \n```", "```\nmain =\n  Signal.map2 view Window.dimensions\n    (Signal.foldp upstate initState (Signal.constant ())) \n```", "```\nview (w,h) i =\n     E.color Color.gray\n  <| E.container w h E.middle\n  <| E.flow E.down\n       [ i |> toString |> T.plainText ] \n```", "```\nbutton : Signal.Message -> String -> Element \n```", "```\nSignal.channel : a -> Channel a \n```", "```\nSignal.subscribe : Channel a -> Signal a \n```", "```\nsend : Channel a -> a -> Message \n```", "```\nch : Signal.Channel ()\nch = Signal.channel () \n```", "```\n [ i |> toString |> T.plainText\n   , button (Signal.send ch ()) \"Increment\" \n   , button (Signal.send ch ()) \"Clear\" \n   ] \n```", "```\nmain =\n  Signal.map2 view Window.dimensions\n    (Signal.foldp upstate initState (Signal.subscribe ch)) \n```", "```\ntype CounterEvent = Inc | Clear\nupstate e i       = case e of {Clear -> 0; Inc -> i + 1}\n\nch : Signal.Channel CounterEvent\nch = Signal.channel Clear \n```", "```\nvspace = E.spacer 0 10\n\nview (w,h) i =\n     E.color Color.gray\n  <| E.container w h E.middle\n  <| E.flow E.down\n  <| List.intersperse vspace\n       [ i |> toString |> T.plainText\n       , button (Signal.send ch Inc) \"Increment\" \n       , button (Signal.send ch Clear) \"Clear\" \n       ] \n```", "```\ncustomButton : Signal.Message -> Element -> Element -> Element -> Element \n```", "```\nmyButton evt s =\n  let b = button evt s in\n  customButton evt\n    (E.color Color.lightYellow b)\n    (E.color Color.lightOrange b)\n    (E.color Color.lightBlue   b) \n```", "```\ncircle : Float -> Shape\n\nrect : Float -> Float -> Shape \n```", "```\nfilled : Color -> Shape -> Form\n\noutlined : LineStyle -> Shape -> Form \n```", "```\ncollage : Int -> Int -> List Form -> Element \n```", "```\ntoForm : Element -> Form \n```", "```\nstrStyle : String -> E.Element\nstrStyle = T.fromString >> T.height 30 >> T.centered \n```", "```\nlineStyle =\n  let ls = C.defaultLine in\n    { ls | color <- Color.darkCharcoal,\n           width <- 10 } \n```", "```\nbtnW = 200\nbtnH = 60\n\nmyButton evt s =\n  let mkBtn c =\n    C.collage btnW btnH [\n        C.filled c (C.rect btnW btnH)\n      , C.outlined lineStyle (C.rect btnW btnH)\n      , strStyle s |> C.toForm\n    ]\n  in\n  customButton evt\n    (mkBtn Color.lightYellow)\n    (mkBtn Color.lightOrange)\n    (mkBtn Color.lightBlue) \n```", "```\n ...\n  <| List.intersperse vspace\n       [ i |> toString |> strStyle |> E.container btnW btnH E.middle\n         ...\n       ] \n```", "```\ntype alias Pt    = (Int, Int)\ntype alias State = (Pt, Int)\ninitState        = ((-1,-1), 0) \n```", "```\nbtnW = 200\nbtnH = 60\n\nupstate : Pt -> State -> State\nupstate (x,y) (_,i) =\n  let inPlace i x y = x <= btnW && y >= i * btnH && y < (i+1) * btnH in\n  let j =\n    if | inPlace 1 x y -> i + 1    -- Increment \"button\"\n       | inPlace 2 x y -> 0        -- Clear \"button\"\n       | otherwise     -> i        -- elsewhere\n  in\n  ((x,y), j) \n```", "```\nmain =\n  Signal.map view\n    (Signal.foldp upstate initState\n      (Signal.sampleOn Mouse.clicks Mouse.position)) \n```", "```\nstrStyle : String -> E.Element\nstrStyle = T.fromString >> T.height 30 >> T.centered\n\nview : State -> E.Element\nview st =\n  let rows     = 3\n      w        = btnW\n      h        = rows * btnH\n      place i  = C.moveY (btnH - (i-1)*btnH)\n      rect c   = C.filled c (C.rect btnW btnH)\n      text c s = C.toForm <| color c <| strStyle s\n  in\n  C.collage w h\n    [ place 1 <| rect Color.lightGray\n    , place 1 <| text Color.lightGray <| toString st\n    , place 2 <| rect Color.lightYellow\n    , place 2 <| text Color.lightYellow \"Increment\"\n    , place 3 <| rect Color.lightOrange\n    , place 3 <| text Color.lightOrange \"Clear\"\n    , C.outlined C.defaultLine (C.rect w h)\n    ] \n```"]