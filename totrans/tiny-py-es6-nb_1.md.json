["```\n$ python3 --version\n\n```", "```\n    $ python3\n\n    ```", "```\n    $ python3 file.py\n\n    ```", "```\n    $ python3 -i file.py\n\n    ```", "```\n    $ python3 -m json.tool\n\n    ```", "```\n    $ python3 -c \"print('hi')\"\n\n    ```", "```\n>>> import this\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the\nrules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation\nto guess.\nThere should be one --and preferably only one--\nobvious way to do it.\nAlthough that way may not be obvious at first\nunless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a\nbad idea.\nIf the implementation is easy to explain, it may\nbe a good idea.\nNamespaces are one honking great idea -- let's\ndo more of those!\n\n```", "```\n>>> a = 400     # a points to an integer\n>>> a = '400'   # a now points to a string\n\n```", "```\n>>> people = ['Paul', 'John', 'George']\n>>> people.append('Ringo')\n\n```", "```\n>>> 'Yoko' in people\nFalse\n\n```", "```\n>>> for i, name in enumerate(people, 1):\n...     print('{} - {}'.format(i, name))\n1 - Paul\n2 - John\n3 - George\n4 - Ringo\n\n```", "```\n>>> people[0]\n'Paul'\n>>> people[-1]  # len(people) - 1\n'Ringo'\n\n```", "```\n>>> people[1:2]\n['John']\n>>> people[:1]   # Implicit start at 0\n['Paul']\n>>> people[1:]   # Implicit end at len(people)\n['John', 'George', 'Ringo']\n>>> people[::2]  # Take every other item\n['Paul', 'George']\n>>> people[::-1] # Reverse sequence\n['Ringo', 'George', 'John', 'Paul']\n\n```", "```\n>>> instruments = {'Paul': 'Bass',\n...                'John': 'Guitar'}\n\n>>> instruments['George'] = 'Guitar'\n>>> 'Ringo' in instruments\nFalse\n\n>>> for name in instruments:\n...     print('{} - {}'.format(name,\n...           instruments[name]))\nPaul - Bass\nJohn - Guitar\nGeorge - Guitar\n\n```", "```\n>>> member = ('Paul', 'Bass', 1942)\n>>> member2 = ('Ringo', 'Drums', 1940)\n\n```", "```\n>>> row = 1, 'Fred'     # 2 item tuple\n>>> row2 = (2, 'Bob')   # 2 item tuple\n>>> row3 = ('Bill')     # String!\n>>> row4 = ('Bill',)    # 1 item tuple\n>>> row5 = 'Bill',      # 1 item tuple\n>>> row6 = ()           # Empty tuple\n\n```", "```\n>>> from collections import namedtuple\n>>> Member = namedtuple('Member',\n...     'name, instrument, birth_year')\n>>> member3 = Member('George', 'Guitar', 1943)\n\n```", "```\n>>> member3[0]\n'George'\n\n>>> member3.name\n'George'\n\n```", "```\n>>> digits = [0, 1, 1, 2, 3, 4, 5, 6,\n...     7, 8, 9]\n>>> digit_set = set(digits)   # remove extra 1\n\n>>> 9 in digit_set\nTrue\n\n```", "```\n>>> odd = {1, 3, 5, 7, 9}\n>>> prime = set([2, 3, 5, 7])\n>>> even = digit_set - odd\n>>> even\n{0, 2, 4, 6, 8}\n\n>>> prime & even  # in intersection\n{2}\n\n>>> odd | even    # in both\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n>>> even ^ prime  # not in both\n{0, 3, 4, 5, 6, 7, 8}\n\n```", "```\n>>> empty = set()\n\n```", "```\n>>> x_sq = 'x\u00b2'\n>>> x_sq.encode('utf-8')\nb'x\\xc2\\xb2'\n\n>>> utf8_bytes = b'x\\xc2\\xb2'\n>>> utf8_bytes.decode('utf-8')\n'x\u00b2'\n\n```", "```\n>>> result = 'x\u00b2'\n>>> result = 'x\\u00b2'\n>>> result = 'x\\N{SUPERSCRIPT TWO}'\n\n```", "```\n>>> person = {'name': 'Paul',\n...     'instrument': 'Bass'}\n>>> inst = person['instrument']\n\n>>> print(\"Name: {} plays: {}\".format(\n...     person['name'], inst))\nName: Paul plays: Bass\n\n```", "```\n>>> print(\"Name: {name} \"\n...       \"plays: {inst}\".format(\n...       name=person['name'], inst=inst))\nName: Paul plays: Bass\n\n```", "```\n>>> print(f'Name: {person[\"name\"]} plays: {inst}')\nName: Paul plays: Bass\n\n```", "```\n>>> class Cat:\n...     def __init__(self, name):\n...         self.name = name\n...     def __format__(self, data):\n...         return \"Format\"\n...     def __str__(self):\n...         return \"Str\"\n...     def __repr__(self):\n...         return \"Repr\"\n\n>>> cat = Cat(\"Fred\")\n>>> print(\"{} {!s} {!a} {!r}\".format(cat, cat, cat,\n...       cat))\nFormat Str Repr Repr\n\n```", "```\n[[fill]align][sign][#][0][width][grouping_option]\n[.precision][type]\n\n```", "```\n>>> \"Name: {:*^12}\".format(\"Ringo\")\n'Name: ***Ringo****'\n\n```", "```\n>>> \"Percent: {:=10.1%}\".format(-44/100)\n'Percent: -    44.0%'\n\n```", "```\n>>> \"Binary: {:#b}\".format(12)\n'Binary: 0b1100'\n\n>>> \"Hex: {:#x}\".format(12)\n'Hex: 0xc'\n\n```", "```\n>>> with open('/tmp/names.txt', 'w') as fout:\n...     fout.write('Paul\\r\\nJohn\\n')\n...     fout.writelines(['Ringo\\n', 'George\\n'])\n\n```", "```\n>>> with open('/tmp/names.txt') as fin:\n...     for line in fin:\n...         print(repr(line))\n'Paul\\n'\n'John\\n'\n'Ringo\\n'\n'George\\n'\n\n```", "```\n>>> def add_numbers(x, y):\n...     \"\"\" add_numbers sums up x and y\n...\n...     Arguments:\n...     x -- object that supports addition\n...     y -- object that supports addition\n...     \"\"\"\n...     return x + y\n\n```", "```\n>>> add = lambda x, y: x + y\n>>> add(4, 5)\n9\n\n```", "```\n>>> def add_n(x, n=42):\n...     return x + n\n\n>>> add_n(10)\n52\n>>> add_n(3, -10)\n-7\n\n```", "```\n>>> def add_many(*args):\n...     result = 0\n...     for arg in args:\n...          result += arg\n...     return result\n\n>>> add_many()\n0\n>>> add_many(1)\n1\n>>> add_many(42, 3.14)\n45.14\n\n```", "```\n>>> def add_kwargs(**kwargs):\n...     result = 0\n...     for key in kwargs:\n...         result += kwargs[key]\n...     return result\n\n>>> add_kwargs(x=1, y=2, z=3)\n6\n\n>>> add_kwargs()\n0\n\n>>> add_kwargs(4)\nTraceback (most recent call last):\n  ...\nTypeError: add_kwargs() takes 0 positional arguments\nbut 1 was given\n\n```", "```\n>>> def add_points(*, x1=0, y1=0, x2=0, y2=0):\n...     return x1 + x2, y1 + y2\n\n>>> add_points(x1=1, y1=1, x2=3, y2=4)\n(4, 5)\n\n>>> add_points(1, 1, 3, 4)\nTraceback (most recent call last):\n  ...\nTypeError: add_points() takes 0 positional arguments\nbut 4 were given\n\n```", "```\n>>> def add_all(*args, **kwargs):\n...     \"\"\"Add all arguments\"\"\"\n...     result = 0\n...     for num in args + tuple(kwargs.values()):\n...         result += num\n...     return result\n\n>>> sizes = (2, 4.5)\n>>> named_sizes = {\"this\": 3, \"that\": 1}\n\n```", "```\n>>> add_all(*sizes)\n6.5\n\n>>> add_all(sizes[0], sizes[1])\n6.5\n\n```", "```\n>>> add_all(**named_sizes)\n4\n\n>>> add_all(this=3, that=1)\n4\n\n```", "```\n>>> add_all(*sizes, **named_sizes)\n10.5\n\n```", "```\n>>> help(add_all)\nHelp on function add_all in module __main__:\n\nadd_all(*args, **kwargs)\n    Add all arguments\n\n```", "```\n>>> class Bike:\n...     ''' Represents a bike '''\n...     num_passengers = 1   # class attribute\n...\n...     def __init__(self, wheel_size,\n...                  gear_ratio):\n...         ''' Create a bike specifying the\n...         wheel size, and gear ratio '''\n...         # instance attributes\n...         self.size = wheel_size\n...         self.ratio = gear_ratio\n...\n...     def gear_inches(self):\n...         return self.ratio * self.size\n\n```", "```\n>>> bike = Bike(26, 34/13)\n>>> print(bike.gear_inches())\n68.0\n\n```", "```\n>>> bike.num_passengers\n1\n\n>>> bike.size\n26\n\n```", "```\n>>> class Tandem(Bike):\n...     num_passengers = 2\n...\n...     def __init__(self, wheel_size, rings, cogs):\n...         self.rings = rings\n...         self.cogs = cogs\n...         ratio = rings[0] / cogs[0]\n...         super().__init__(wheel_size, ratio)\n...\n...     def shift(self, ring_idx, cog_idx):\n...         self.ratio = self.rings[ring_idx] \\\n...              / self.cogs[cog_idx]\n...\n\n```", "```\n>>> tan = Tandem(26, [42, 36], [24, 20, 15, 11])\n>>> tan.shift(1, -1)\n>>> tan.gear_inches()\n85.0909090909091\n\n```", "```\n>>> INCHES_PER_METER = 39.37\n\n>>> class MountainBike(Bike):\n...     @classmethod\n...     def from_metric(cls, size_meters, ratio):\n...          return cls(size_meters *\n...                     INCHES_PER_METER,\n...                     ratio)\n\n>>> mtn = MountainBike.from_metric(.559, 38/11)\n>>> mtn.gear_inches()\n76.0270490909091\n\n```", "```\n>>> class Recumbent(Bike):\n...     @staticmethod\n...     def is_fast():\n...         return True\n\n>>> Recumbent.is_fast()\nTrue\n\n>>> lawnchair = Recumbent(20, 4)\n>>> lawnchair.is_fast()\nTrue\n\n```", "```\n>>> class Person:\n...     def __init__(self, name):\n...         self._name = name\n...\n...     @property\n...     def name(self):\n...         if self._name == 'Richard':\n...             return 'Ringo'\n...         return self._name\n...\n...     @name.setter\n...     def name(self, value):\n...         self._name = value\n...\n...     @name.deleter\n...     def name(self):\n...         del self._name\n\n```", "```\n>>> p = Person('Richard')\n>>> p.name\n'Ringo'\n\n>>> p.name = 'Fred'\n\n```", "```\n>>> names = ['John', 'Paul', 'Ringo']\n>>> for name in names:\n...    print(name)\nJohn\nPaul\nRingo\n\n```", "```\n>>> for name in names:\n...    if name == 'Paul':\n...        break\n...    print(name)\nJohn\n\n```", "```\n>>> for name in names:\n...    if name == 'Paul':\n...        continue\n...    print(name)\nJohn\nRingo\n\n```", "```\n>>> for name in names:\n...     if name == 'George':\n...          break\n... else:\n...     raise ValueError(\"No Georges\")\nTraceback (most recent call last):\n  ...\nValueError: No Georges\n\n```", "```\n>>> for i, name in enumerate(names, 1):\n...     print(\"{}. {}\".format(i, name))\n1\\. John\n2\\. Paul\n3\\. Ringo\n\n```", "```\n>>> done = False\n>>> while not done:\n...     # some work\n...     done = True\n\n```", "```\n>>> class fib:\n...     def __init__(self, limit=None):\n...         self.val1 = 1\n...         self.val2 = 1\n...         self.limit = limit\n...\n...     def __iter__(self):\n...         return self\n...\n...     def __next__(self):\n...         val = self.val1\n...         self.val1 = self.val2\n...         self.val2 = val + self.val1\n...         if self.limit is not None and \\\n...             val < self.limit:\n...             return val\n...         raise StopIteration\n\n```", "```\n>>> e = fib(6)\n>>> for val in e:\n...    print(val)\n1\n1\n2\n3\n5\n\n```", "```\n>>> e = fib(6)\n>>> it = iter(e)  # calls e.__iter__()\n>>> next(it)      # calls it.__next__()\n1\n>>> next(it)\n1\n>>> next(it)\n2\n>>> next(it)\n3\n>>> next(it)\n5\n>>> next(it)\nTraceback (most recent call last):\n  ...\nStopIteration\n\n```", "```\n>>> grade = 72\n\n>>> def letter_grade(grade):\n...     if grade > 90:\n...         return 'A'\n...     elif grade > 80:\n...         return 'B'\n...     elif grade > 70:\n...         return 'C'\n...     else:\n...         return 'D'\n\n>>> letter_grade(grade)\n'C'\n\n```", "```\n>>> x = 4\n>>> if 3 < x < 5:\n...     print(\"Four!\")\nFour!\n\n```", "```\n>>> def add(x, y):\n...     return x + y\n\n>>> def sub(x, y):\n...     return x - y\n\n>>> ops = {'+': add, '-': sub}\n\n>>> op = '+'\n>>> a = 2\n>>> b = 3\n>>> ops[op](a, b)\n5\n\n```", "```\n>>> 0 and 1/0\n0\n\n```", "```\n>>> 1 or 1/0\n1\n\n```", "```\n>>> last = 'Lennon' if band == 'Beatles' else 'Jones'\n\n```", "```\n>>> def avg(seq):\n...     try:\n...         result = sum(seq) / len(seq)\n...     except ZeroDivisionError as e:\n...         return None\n...     except Exception:\n...         raise\n...     return result\n\n>>> avg([1, 2, 4])\n2.3333333333333335\n\n>>> avg([]) is None\nTrue\n\n>>> avg('matt')\nTraceback (most recent call last):\n  ...\nTypeError: unsupported operand type(s) for +: 'int'\nand 'str'\n\n```", "```\n>>> def bad_code(x):\n...     raise ValueError('Bad code')\n\n>>> bad_code(1)\nTraceback (most recent call last):\n  ...\nValueError: Bad code\n\n```", "```\n>>> def identity(func):\n...     return func\n\n```", "```\n>>> @identity\n... def add(x, y):\n...     return x + y\n\n```", "```\n>>> import functools\n>>> def verbose(func):\n...     @functools.wraps(func)\n...     def inner(*args, **kwargs):\n...         print(\"Calling with:{} {}\".format(args,\n...               kwargs))\n...         res = func(*args, **kwargs)\n...         print(\"Result:{}\".format(res))\n...         return res\n...     return inner\n\n```", "```\n>>> @verbose\n... def sub(x, y):\n...     return x - y\n\n```", "```\n>>> sub(5, 4)\nCalling with:(5, 4) {}\nResult:1\n1\n\n```", "```\n>>> def verbose_level(level):\n...     def verbose(func):\n...         @functools.wraps(func)\n...         def inner(*args, **kwargs):\n...             for i in range(level):  # parameterized!\n...                 print(\"Calling with:{} {}\".format(\n...                       args, kwargs))\n...             res = func(*args, **kwargs)\n...             print(\"Result:{}\".format(res))\n...             return res\n...         return inner\n...     return verbose\n\n```", "```\n>>> @verbose_level(2)\n... def div(x, y):\n...     return x/y\n\n>>> div(1, 5)\nCalling with:(1, 5) {}\nCalling with:(1, 5) {}\nResult:0.2\n0.2\n\n```", "```\n>>> def add_chirp(cls):\n...     'Class decorator to add speak method'\n...     def chirp(self):\n...         return \"CHIRP\"\n...     cls.speak = chirp\n...     return cls\n...\n>>> @add_chirp\n... class Bird:\n...     pass\n\n>>> b = Bird()\n>>> print(b.speak())\nCHIRP\n\n```", "```\n>>> def howl(self):\n...     return \"HOWL\"\n\n>>> parents = ()\n>>> attrs_map = {'speak': howl}\n>>> F = type('F', parents, attrs_map)\n\n>>> f = F()\n>>> print(f.speak())\nHOWL\n\n```", "```\n>>> def meta(name, parents, attrs_map):\n...     def bark(self):\n...         return \"WOOF!\"\n...     attrs_map['speak'] = bark\n...     return type(name, parents, attrs_map)\n\n>>> class Dog(metaclass=meta):\n...     pass\n\n>>> d = Dog()\n>>> print(d.speak())\nWOOF!\n\n```", "```\n>>> class CatMeta(type): # Needs to subclass type\n...     def __new__(cls, name, parents, attrs_map):\n...         # cls is CatMeta\n...         # res is the class we are creating\n...         res = super().__new__(cls, name,\n...             parents, attrs_map)\n...         def meow(self):\n...             return \"MEOW\"\n...         res.speak = meow\n...         return res\n...\n...     def __init__(cls, name, parents, attrs_map):\n...         super().__init__(name, parents, attrs_map)\n\n>>> class Cat(metaclass=CatMeta):\n...     pass\n\n>>> c = Cat()\n>>> print(c.speak())\nMEOW\n\n```", "```\n>>> def fib_gen():\n...     val1, val2 = 1, 1\n...     while 1:\n...         yield val1\n...         val1, val2 = val2, (val1+val2)\n\n```", "```\n>>> gen = fib_gen()\n>>> gen_iter = iter(gen)\n>>> next(gen_iter)\n1\n>>> next(gen_iter)\n1\n>>> next(gen_iter)\n2\n>>> next(gen_iter)\n3\n\n```", "```\n>>> import asyncio\n>>> async def greeting():\n...    print(\"Here they are!\")\n\n>>> co = greeting()\n>>> co  # Not running\n<coroutine object greeting at 0x1087dcba0>\n\n>>> loop = asyncio.get_event_loop()\n>>> loop.run_until_complete(co)\nHere they are!\n>>> loop.close()\n\n```", "```\n>>> async def compute(future):\n...     print(\"Starting...\")\n...     # Simulate IO...\n...     res = await answer()\n...     future.set_result(res)\n\n>>> async def answer():\n...     await asyncio.sleep(1)\n...     return 42\n\n>>> f = asyncio.Future()\n>>> loop = asyncio.get_event_loop()\n>>> loop.run_until_complete(compute(f))\n>>> loop.close()\n>>> f.result()\n42\n\n```", "```\n>>> async def fib():\n...     v1, v2 = 1, 1\n...     while True:\n...          # similate io\n...          await asyncio.sleep(1)\n...          yield v1\n...          v1, v2 = v2, v1+v2\n...          if v1 > 5:\n...              break\n\n>>> async def get_results():\n...    async for num in fib():\n...        print(num)\n\n>>> loop = asyncio.get_event_loop()\n>>> loop.run_until_complete(get_results())\n1  # sleeps for 1 sec before each print\n1\n2\n3\n5\n>>> loop.close()\n\n```", "```\n>>> nums = range(10)\n>>> result = []\n>>> for num in nums:\n...     if num % 2 == 0:  # filter\n...         result.append(num*num)  # map\n\n```", "```\n>>> result = [num*num for num in nums\n...           if num % 2 == 0]\n\n```", "```\n    result = [ ]\n\n    ```", "```\n    result = [for num in nums]\n\n    ```", "```\n    result = [for num in nums if num % 2 == 0]\n\n    ```", "```\n    result = [num*num for num in nums\n              if num % 2 == 0]\n\n    ```", "```\n>>> {num*num for num in nums if num % 2 == 0}\n{0, 64, 4, 36, 16}\n\n```", "```\n>>> {num:num*num for num in nums if num % 2 == 0}\n{0: 0, 2: 4, 4: 16, 6: 36, 8: 64}\n\n```", "```\n>>> (num*num for num in nums if num % 2 == 0)\n<generator object <genexpr> at 0x10a6f8780>\n\n```", "```\n>>> async def process(aiter):\n...     result = []\n...     async for num in aiter:\n...         if num % 2 == 0:  # filter\n...             result.append(num*num)  # map\n\n```", "```\n>>> async def process(aiter):\n...     result = [num*num async for num in aiter\n...               if num % 2 == 0]\n\n```", "```\n>>> def start(env):\n...     return '\\\\begin{{{}}}'.format(env)\n\n>>> def end(env):\n...      return '\\\\end{{{}}}'.format(env)\n\n>>> def may_error():\n...     import random\n...     if random.random() < .5:\n...         return 'content'\n...     raise ValueError('Problem')\n\n>>> out = []\n>>> out.append(start('center'))\n\n>>> try:\n...     out.append(may_error())\n... except ValueError:\n...     pass\n... finally:\n...     out.append(end('center'))\n\n```", "```\n>>> import contextlib\n>>> @contextlib.contextmanager\n... def env(name, content):\n...     content.append('\\\\begin{{{}}}'.format(name))\n...     try:\n...         yield\n...     except ValueError:\n...         pass\n...     finally:\n...         content.append('\\\\end{{{}}}'.format(name))\n\n```", "```\n>>> out = []\n>>> with env('center', out):\n...     out.append(may_error())\n\n>>> out\n['\\\\begin{center}', 'content', '\\\\end{center}']\n\n```", "```\n>>> class env:\n...     def __init__(self, name, content):\n...         self.name = name\n...         self.content = content\n...\n...     def __enter__(self):\n...         self.content.append('\\\\begin{{{}}}'.format(\n...             self.name))\n...\n...     def __exit__(self, type, value, tb):\n...         # if error in block, t, v, & tb\n...         # have non None values\n...         # return True to hide exception\n...         self.content.append('\\\\end{{{}}}'.format(\n...             self.name))\n...         return True\n\n```", "```\n>>> out = []\n>>> with env('center', out):\n...     out.append(may_error())\n\n>>> out  # may_error had an issue\n['\\\\begin{center}', '\\\\end{center}']\n\n```", "```\nwith open('/tmp/test.txt') as fin:\n    # muck around with fin\n\n```", "```\n>>> def add(x: int, y: int) -> float:\n...     return x + y\n\n>>> add(2, 3)\n5\n\n```", "```\n>>> add(\"foo\", \"bar\")\n'foobar'\n\n```", "```\n>>> from typing import Dict\n>>> ages = {}  # type: Dict[str, int]\n\n```", "```\n$ pip install mypy\n$ python3 -m mypy script.py\n\n```", "```\nif __name__ == '__main__':\n    # execute something\n\n```", "```\npackagename/\n  __init__.py\n  module1.py\n  module2.py\n  subpackage/\n    __init__.py\n\n```", "```\nimport packagename\nimport packagename.module1\n\n```", "```\nimport packagename.module1\n\npackagename.module1.fib()\n\n```", "```\nfrom packagename.module1 import fib\n\nfib()\n\n```", "```\nfrom packagename.module1 import fib as package_fib\n\npackage_fib()\n\n```", "```\n$ python3 -m venv /path/to/env\n\n```", "```\nc:\\>c:\\Python36\\python -m venv c:\\path\\to\\env\n\n```", "```\n$ source /path/to/env/bin/activate\n\n```", "```\nc:\\>c:\\path\\to\\env\\Scripts\\activate.bat\n\n```", "```\n(env) $ deactivate\n\n```", "```\n(env) $ pip install django\n\n```", "```\n(env) $ pip uninstall django\n\n```"]