# 28安全性和完备性

|     [28.1 安全性](#%28part._safety%29) |
| --- |
|     [28.2 “无类型”语言](#%28part.__.Untyped__.Languages%29) |
|     [28.3 中心定理：类型完备性](#%28part._type-soundness%29) |
|     [28.4 类型、时间和空间](#%28part._types-time-space%29) |
|     [28.5 类型与安全性](#%28part._.Types_.Versus_.Safety%29) |

现在我们已经初步了解了类型系统，一个类型系统通常有三个组成部分：类型语言、类型规则集和强制执行这些规则的算法。通过通过检查函数展示类型，我们已经模糊了第二和第三个组成部分之间的区别，但它们仍应被视为在智力上有所不同：前者提供了一个声明性描述，而后者提供了一个可执行的描述。这种区别在（部分“impl-subtyp”）中变得相关。我们准备讨论类型如何提供某种可预测性的方式，一种称为类型完备性的概念。与此相关的是你可能听过的术语，如安全性（或类型安全性），以及其他诸如强类型（相反的是弱类型）和内存安全性等。我们应该理解它们。

## 28.1安全性

语言中的许多操作是部分的：在定义了它们的域的情况下，它们接受域的一些但不是全部元素。例如，虽然加法——<wbr>定义在数字上——<wbr>通常是完全的，但除法通常是部分的，因为除以零被认为是一个错误。在几乎每种语言中，函数应用运算符仅限于应用函数值，即，像3(5)这样的应用——<wbr>数字3应用于一个参数5——<wbr>是非法的。

当然，一个操作是部分的还是完全的，完全取决于我们如何定义域。例如，如果我们将除法的第二个参数的域定义为非零数，那么它就是完全的；而如果我们将加法的参数的域定义为所有值，那么它就是部分的。此外，一些操作在不同语言中处理方式完全不同。例如，平方根函数在应用于-1时，可以有不同的结果

+   带有错误停止，

+   返回一个特殊值称为“非数”（NaN），或

+   返回一个虚数（例如，在Scheme中为0+1i）。

此外，也许令人惊讶的是，一个操作可以在所有值上工作，但这正是参数化多态性所实现的（[REF]）。

那么重要的是，一个操作是否排除任何值。如果是，那么我们可以问语言是否阻止它与任何被排除的值一起使用。如果语言阻止了它，那么我们称该语言是安全的。如果没有，我们称之为不安全。当然，一个语言可能对某些操作是安全的，对其他操作是不安全的；通常，如果一个语言的所有操作都是安全的，我们会将术语“安全”应用于整个语言。

安全语言为程序员提供了一个非常重要的保证：不会对无意义的数据执行任何操作。继续使用数字加法，在一个不安全的语言中，我们可能被允许将一个数字添加到一个字符串中，这将产生一个依赖于字符串的精确表示的值，并且如果字符串的表示方式改变了，这个值可能会改变。（例如，字符串可能是以零结尾的，或者可能记录其长度，这会改变字符串的第一个单词是什么。）我们甚至可以将一个字符串添加到一个函数中，这显然是荒谬的（一个函数的机器表示的第一个单词代表着什么有意义的数字？）。因此，尽管安全性根本不能确保计算将是正确的，但至少它确保它们将是有意义的：不会执行任何荒谬的操作。

观察到我们对语言如何实现安全性没有施加任何要求。通常，安全性可以通过运行时检查动态实现：例如，加法将检查其参数是否为数字，除法还将确保其第二个参数不为零，依此类推。此外，静态类型系统也可以确保安全性。因为这是一个常见的混淆源，我们应该清楚：安全性仅意味着操作不会应用于无意义的值。它不会固定任何确切的实现策略来确保这个属性。

我们将在下文中回到实现问题（[类型，时间和空间](#%28part._types-time-space%29)）。但首先，我们有一些重要的基础材料需要解决。

## 28.2“无类型”语言

在通俗的写作中，常常使用“无类型”的短语。这是一个很大的混淆源，因此我们应该澄清其含义。它可能有两种不同的含义，而且这些含义是不重叠的：

1.  一个没有任何类型的语言。当然，所有数据都有一些赋予它们意义的表示，但它意味着语言中只有一种类型，并且所有数据都属于该类型。此外，此数据类型没有变体，因为这将引入基于类型的歧视。例如，所有数据可能是一个字节，或一个数字，或一个字符串，或其他某个单一的、独特的值。通常，没有操作会无法接受特定类型的值，因为这可能暗示着某种类型的区别，而根据定义，这种区别是不存在的。请注意，这是一种语义上的无类型性概念。

1.  一个具有运行时值分区的语言—<wbr>例如，数字与函数是不同的—<wbr>但没有静态注释或检查。请注意，这是一种语法上的无类型性概念。

除了机器代码之外几乎没有当代语言—<wbr>其中单一类型通常是一个“字”—<wbr>存在。相比之下，后一种类型的语言有很多（例如，Python 和 Racket）。

因为这两个含义是相互矛盾的，因此为这两个含义使用两个不同的名称将是有用的。有些人使用术语“潜在类型化”或“动态类型化”来区分后一种类别，以便将它们区分开来。

遵循现代惯例，我们将使用后一种术语，同时承认有些人认为“类型化”一词仅适用于具有静态规范的语言，因此短语“动态类型化”被视为一个矛盾修辞法。请注意，我们前面的讨论给了我们一条摆脱这种语言混乱的出路。一个在运行时不检查类型的动态类型化语言并不是非常有趣（“类型”可能根本不存在）。相比之下，一个在运行时进行检查的语言已经有一个完全合适的名字：安全（[安全性](#%28part._safety%29)）。因此，使用“动态安全”这个名字更有意义，用于描述那些在运行时执行所有安全检查的语言，而对于尽可能多地在静态地执行安全检查的语言，则使用“静态安全”，只有那些不可判定的检查留给运行时，稍微失去了一些精确性。

## 28.3中心定理：类型的合理性

我们之前已经看到（[程序终止](types.html#%28part._strong-normalization%29））某些类型语言可以为其程序提供非常强大的定理：例如，语言中的所有程序都终止。当然，在一般情况下，我们无法获得这样的保证（事实上，我们添加了一般递归，正是为了让自己编写无界循环）。但是，有意义的类型系统——确实，任何我们希望赋予“类型系统”这一崇高称号的东西——应该提供某种保证，即所有带类型的程序都享有。这对程序员来说是有回报的：通过对这个程序进行类型标记，她可以确信某些不好的事情肯定不会发生。除此之外，我们只有一个错误查找器；虽然它可能有用，但它不足以构建任何更高级别的工具（例如，用于获得安全性、隐私性或健壮性保证）的基础。

什么定理可能是我们对类型系统的期望？请记住，类型检查器在执行之前会在静态程序上运行。在这样做时，它本质上是在对程序的行为进行预测：例如，当它声明某个特定的复杂术语具有数字类型时，它在预测运行时，该术语将产生数字值。我们怎么知道这个预测是准确的，即，类型检查器从不说谎？每个类型系统都应该伴随着一个证明这一点的定理。

有一个很好的理由怀疑类型系统，除了一般的怀疑之外。类型检查器和解释器之间有许多不同之处：

+   类型检查器只看到程序文本，而解释器则在实际数据上运行。

+   类型环境将标识符绑定到类型，而解释器的环境将标识符绑定到值或位置。

+   类型检查器将（甚至是无限的）值集合压缩为类型，而解释器将这些集合的元素区别对待。

+   类型检查器总是终止，而解释器可能不会。

+   类型检查器只需一次通过每个表达式的主体，而解释器可能会对每个主体通过零次到无限次。

因此，假设这两者将对应是不明智的，而且在历史上，它们经常失败。

对于给定类型系统，我们希望获得的中心结果称为健全性。 它说这样。 假设我们有一个表达式（或程序）e。 我们对其进行类型检查，并得出其类型为t。 当我们运行e时，让我们说我们获得了值v。 那么v也将具有类型t。

证明这个定理的标准方法是将其分为两部分，称为进展和保全。 进展说如果一个术语通过了类型检查器，它将能够进行一步评估（除非它已经是一个值）； 保全说这一步的结果将与原始值具有相同的类型。 如果我们交错这些步骤（首先进展，然后保全； 洗涤并重复），我们可以得出最终答案确实与原始答案具有相同的类型，因此类型系统确实是完好的。

例如，考虑这个表达式：5 +（2 * 3）。 它的类型是Number。 在一个健全的类型系统中，进展提供了一个证明，因为这个术语的类型，而且不是一个值，所以它可以执行一步—<wbr>显然可以。 经过一步后，程序缩减为5 + 6。 确实，由于保全证明，这与原始值的类型相同：Number。 进展再次表示这可以进行一步，产生11。 保全再次表明，这与代表程序的先前表达式的类型相同：Number。 现在进展发现我们得到了一个答案，因此没有可采取的步骤了，我们的答案与原始表达式的给定答案相同。

但是，这并不是整个故事。 有两个警告：

1.  程序可能根本不会产生答案； 它可能永远循环。 在这种情况下，严格来说定理不适用。 但是，我们仍然可以观察到程序的每个中间表示都具有与整个表达式相同的类型，因此即使它不产生值，该程序也在进行有意义的计算。

1.  任何足够丰富的语言都具有静态无法决定的属性（以及其他可能可以但语言设计者选择推迟到运行时以减轻程序员使程序通过类型检查器的负担的属性）。 当其中一个属性失败—<wbr>例如，数组索引不在范围内—<wbr>程序没有有意义的类型。 因此，在每个类型健全性定理中都隐含着一些可能发生的已发布的、允许的异常或错误条件。 使用类型系统的开发人员隐含地同意接受这一集合。

作为后一组的一个例子，典型的静态类型语言的用户承认向量解引用、列表索引等都可能产生异常。不同的类型系统设计可能会使这组成为一个 [参数](http://cs.brown.edu/~sk/Publications/Papers/Published/pqk-progressive-types/)。

后一个警告看起来像是一种逃避责任的借口。然而，实际上这是一个非常积极的声明，因为它表明任何不属于这个集合的异常都将不会被触发。当然，在一开始就设计了静态类型的语言中，不清楚（除了松散的类比）这些异常可能是什么，因为不需要定义它们。但是当我们将类型系统后装到现有编程语言中，特别是只有动态执行的语言，比如 Racket 或 Python，那么已经有了一个明确定义的异常集合，并且类型检查器明确声明了其中一些异常集合（比如“应用位置找不到非函数”或“找不到方法”）根本不会发生。因此，这就是程序员接受类型系统的语法限制所得到的回报。

## 28.4 类型、时间和空间

即使在静态类型的语言中，也经常需要几个运行时检查。为了解释这一点，我们将从动态类型的账户开始。考虑以下数据定义

```
data Tree:
  | base
  | node(v :: Number, l :: Tree, r :: Tree)
end
```

以及使用它的一个函数：

```
fun size(t :: Tree) -> Number:
  cases (Tree) t:
    | base => 0
    | node(_, l, r) => 1 + size(l) + size(r)
  end
end
```

在动态类型的语言中，每个值 t 都需要保存一个类型标签，表示其类型。当一个值被传递给 size 时，实现将检查这是否真的是一个 Tree。这样的值将具有额外的变体标签，指示它是 Tree 的基本类型还是节点类型。这个次要标签将用于选择 cases 表达式的一个分支。

假设我们处于一个静态类型的语言中。类型检查器将确保没有非 Tree 值可以替换为 Tree 类型的标识符。因此，根本不需要类型标签。但是，垃圾收集器仍然需要类型标签，尽管其他表示形式，如 BIBOP [REF]，可以大大减少它们的空间影响。然而，仍然需要变体标签，并且将用于在分支之间进行调度。在这个例子中，只需要一个位来区分基值和节点值。这个相同的位位置可以在不引起任何混淆的情况下重用，用于区分其他类型中的变体，因为类型检查器负责防止类型混合。

换句话说，如果存在两种不同的数据类型，每种类型都有两个变体，在动态类型的世界中，所有这四种变体都需要不同的表示。相比之下，在静态类型的世界中，它们的表示可以跨类型重叠，因为静态类型系统将确保一种类型的变体永远不会被误认为是另一种类型。因此，类型对程序有真正的空间（节省表示）和时间（消除运行时检查）性能优势。

> 现在做吧！
> 
> > 在计算机科学中，习惯上有一个[☛空间 - 时间权衡](glossary.html#%28elem._glossary-space-time._tradeoff%29)。然而，在这里，我们遇到了一个情况，即我们同时改善了空间和时间。这似乎几乎是矛盾的！这怎么可能？

这种双重好处对开发人员来说代价很大，他们必须说服静态类型系统他们的程序不会引起类型错误；由于可决性的限制，即使可能没有错误地运行的程序也可能违反类型系统。然而，对于可以做到这一点的程序来说，类型提供了显著的节省。

## 28.5类型与安全性

总之，我们现在已经确定了语言的两种分类：

1.  语言是否有类型，即是否进行静态类型检查。

1.  语言的运行时系统是否安全，即是否执行静态系统未执行的剩余检查 - <wbr>也许甚至没有静态系统）。

鉴于两种现象都有两种选择，这表明有四种不同类型的语言：

|  |  | 安全 |  | 不安全 |
| --- | --- | --- | --- | --- |
| 类型化 |  | ML，Java |  | C，C ++ |
| 未类型化 |  | Python，Racket |  | 机器码 |

机器码的条目有点值得商榷，因为这种语言甚至没有类型，所以没有静态检查可以进行分类检查。类似地，可以认为在运行时系统中没有什么可以检查的，因此最好描述为“甚至不安全”。然而，在实践中，我们确实遇到了真正的问题，比如由于能够从持有数据的任意位置跳转和执行而导致的安全漏洞。

这留下了真正阴险的角落，如C和C ++所属的语言。在这里，静态类型系统给出了值实际上是按类型分隔并检查成员身份的印象。实际上，它们确实在静态世界中。然而，一旦程序员通过了类型检查器，就没有运行时检查了。为了加剧问题，该语言提供了诸如任意指针算术之类的原始操作，使得可以将一种数据解释为另一种数据。因此，我们应该为那些积极误导程序员的语言划定一个特殊的耻辱之地。

> 练习
> 
> > 构造C或C ++将一种数据解释为另一种数据的示例。

历史上，人们有时会使用“强类型”一词来反映ML和Java使用的类型检查，而使用“弱类型”来反映其他类型。然而，这些短语充其量都没有定义清楚。

> 现在做吧！
> 
> > 如果您曾经使用过“强类型”或“弱类型”这样的短语，请定义它们。

这就是我想到的。但还是谢谢你玩。

实际上，这些短语不仅定义不清楚，而且还是错误的，因为问题不在于类型检查器的“强度”，而在于支持它们的运行时系统的性质。这些短语更加错误，因为它们未能说明定理是否支持了类型系统。

因此，最好通过坚持这些概念来表达我们的意图：安全性、类型化和完备性。实际上，我们应该将这视为一个连续体。除了少数例外情况，我们希望一种安全的语言。通常情况下，我们也希望语言是有类型的。如果有类型，我们希望它是完备的，这样我们就知道类型不会说谎。在所有这些情况下，“强类型”和“弱类型”都没有任何有用的含义。
