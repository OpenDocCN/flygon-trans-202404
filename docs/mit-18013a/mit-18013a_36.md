# 章节B：行列式的乐趣

我们在[第4章](../chapter04/contents.html)中讨论了行列式，再次在[第32章](../chapter32/contents.html)中讨论了它。我们讨论了几种计算行列式的方法，原则上并不困难，但是如果你想手动进行，那么实际上是很烦琐的。

在这里，我们提供了一些思路，可以让我们用比写出矩阵还要少的工夫推导出几种特殊类型矩阵的行列式（虽然它们偶尔会有用）。

我们还提供了一个奇特的涉及行列式的公式，这个公式是由爱丽丝梦游仙境的作者刘易斯·卡罗尔发现的，并且基于它提出了一个神奇的计算行列式甚至逆的算法，几乎没有任何努力。

## 1 一些易于计算的行列式。范德蒙德行列式

当一个矩阵的元素是某些变量集合中的单项式甚至多项式时，那么它的行列式一般将是这些变量的多项式，并且这有时对于求值是有用的。

这个的典型例子是所谓的范德蒙德矩阵，其行（或者如果你愿意，列）的形式都是（1，x[j]，x[j]²，x[j]³，...，x[j]^(n-1)）对于某个x[j]。

这是一个示例

![](../Images/41f41b9d9296d71f9669b80965386c9f.jpg)

通过行列式的基本性质，如果它的两行相同，则我们可以推断出范德蒙德矩阵的行列式在任意两行相同时为0。

但是这意味着，作为一个多项式，它必须有(x[i] - x[j])作为一个因子，对于每一个i和j。

这意味着这样的一个行列式必须有![](../Images/076a1de1ba2ff40d201747d2312fc823.jpg)作为一个因子，这里的乘积是对所有i > j的变量对进行的。

这个因子已经是一个次数为![](../Images/a9e4a3da23633229ed6a4034f5d70e66.jpg)的多项式了（我们在处理一个n乘n的矩阵）。

那么我们的范德蒙德行列式作为一个多项式的次数是多少？

好吧，它是条目的总和，每个条目都有每列的一个因子。因此，作为一个多项式，它的次数是0 + 1 + ... + n - 1，即![](../Images/a9e4a3da23633229ed6a4034f5d70e66.jpg)。

因此，由于我们已经看到我们的行列式必须有这个次数的一个因子，我们已经将我们的行列式评估为一个多项式，直到一个常数因子。

那么那个常数是什么呢？我们可以通过查看主对角线项来检查它：即

x[1]⁰x[2]¹x[3]²...x[n]^(n-1)

这正是我们从上述乘积的每个因子中取出第一个（正的）项所得到的。

由于这两项在行列式和乘积中具有相同的系数1，因此乘积就是行列式，这就是我们的答案。

在我们的例子中，我们可以立即推断出行列式是2*1*1，即2。

## 2 另一个简单的例子：柯西行列式

假设我们想要一个矩阵的行列式，其（j，k）项是！[](../Images/ef08a37d5d1a2fa0c4adf099d477b95b.jpg)

这里有一个例子：对于x值1、2、4和y值1、2、3

![](../Images/86569363f4ff6f687e3d398c37c9b4f5.jpg)

现在我们没有一个多项式，而是有一个关于我们变量的有理函数。

我们该怎么办？我们通过因式分解所有分母将其变成一个多项式！

同样，我们知道，如果任何两个x变量相同，或者任何两个y变量相同，它将为0，因为这将使两行或两列相同。

因此，它必须在分子中有![](../Images/2355580d2b919547609518c0f8d9bca0.jpg)的因子。

每对索引较大的变量都有一个乘积。

在分母中，对于每一对变量，我们将有![](../Images/cb5887dcb32afa46d664804b43f4679d.jpg)。

注意，分子在我们的变量中已经有n(n - 1)次，而分母有n²次，比分子的次数多n。

行列式也是如此，其所有项都是n个因子的乘积，每个因子在分母中有一个项，在分子中没有，因此分母中有n个多余的项。

实际上，到目前为止我们有的公式

![](../Images/4510acae1839b1f9a2d9d629c68d0151.jpg)

前两个乘积是变量对，第一个变量具有更大索引，而分母中的乘积是所有对，这就是我们要找的行列式。

我们可以通过设置x[j] = -y[j]来验证这一点，在这种情况下，分子中的乘积项变为矩阵中的非对角线项，并且这些与分母中的类似项相互抵消，我们最终得到分母中的![](../Images/d6dc10150640ffdb10b14b66b8de21d8.jpg)，正是我们从行列式的对角线项中得到的。

在我们的例子中，我们可以推断我们的行列式为![](../Images/c0a20d41245db029098a2a0d6ece88cb.jpg)（其中包括除了与分子相消的一个因子12之外的所有分母）。

**练习B.1 还有一个更有名的例子，我们给你作为练习：

考虑一个矩阵，其(j, k)元素为x[j]，如果j > k，则为y[j]。

对于一个3x3矩阵，这看起来像**

**![](../Images/4df550372dc2f2e56b9f1e1c83d5ed9e.jpg)**

**找出它的行列式公式。（注意它是一个多项式，是几次多项式？在这些变量中什么时候为0？你可以从这些问题的答案中得出答案。）**

例如，考虑矩阵

![](../Images/cc19a4422a8631d6595c00b51f389920.jpg)

你可以立即推断其行列式为6*4*3或72。

## 3 路易斯·卡罗尔定理

二维矩阵行列式的公式

![](../Images/ee8568195dab9f94c46b94172e888229.jpg)

是

a[11]*a[22] - a[12]*a[21]

查尔斯·道奇森（路易斯·卡罗尔，《爱丽丝梦游仙境》的作者）在每个维度中找到了这个公式的类似物。

我们引入以下符号：让**A[i,j]是从A中去除其i-th行和j-th列后获得的矩阵的行列式。如果我们省略两行和相应的列，则让A[ij,ij]是剩下的部分的行列式，这在二维情况下什么都没有（其行列式我们定义为1）。**

然后对于一个二维矩阵A，如上所述，我们有A[2,2] = a[11]，A[1,2] = a[21]等等。

我们上面的二维公式可以写成

(Det A) A[jk,jk] = A[kk]A[jj] - A[jk]A[kj]

(请记住，在这种情况下，因子A[ij,ij]被定义为1。)

就是这个公式是多次公式。他注意到，并证明，如果你选取任意两个不同的指标（比如 j 和 k）用于一个 n x n 矩阵，你会得到相同的结果

(Det A) A[jk,jk] = A[kk]A[jj] - A[jk]A[kj]

这个公式除以A[jk,jk]，给出了一个n乘n的行列式，其用更小尺寸的行列式来表示。

因此它可以用行列式的递归定义来使用。（如果你把0乘0的行列式定义为1，把一个数字的1乘1的行列式定义为它本身，你可以使用这个定义来定义所有更高维度的行列式，只要A[jk,jk]不为0。）

**练习 B.2 通过解决一个一般性的例子来验证3x3矩阵的正确性。**

**不仅可以这样定义行列式，而且还可以使用电子表格高效地和不可思议地计算它。**

我把用于做这个的算法称为**疯帽子算法**。它非常高效，但有一个问题。

**算法是什么？**

我们构建**由连续的行和列组成的所有子矩阵的行列式。**

矩阵本身是一个一个行列式的矩阵。这些有n²个。

从这些中，我们使用Dodson形式中的普通二维行列式公式计算(n - 1)²个2x2连续的行和列子行列式。

并使用同样的规则，即

![](../Images/012cf88e726dfcad496fbea76a347a0f.jpg)

我们计算所有(n-2)²个3x3连续的行和列子行列式，从2x2和1x1的开始；

并继续，直到我们有4个n-1乘n-1连续的行和列子行列式，最后一个完整的行列式。

这听起来像一个巨大的项目，但如果我们从**一个1的方形块开始表示0乘0的行列式**，然后**在它下面输入我们的矩阵**，**我们可以用一个复制到我们的矩阵下方和下方的指令来完成所有工作。**

假设，**例如**，我们在方框a2中插入1，并将其复制到以a2和j10为角的矩形中，并在以a11为左上角的矩阵中输入。

(输入一个10x10矩阵非常无聊。我建议尝试4x4或5x5甚至3x3。如果你想超过10x10，你需要在顶部添加更多的1。)

现在在方框a21中输入=(a11*b12-a12*b11)/b2

并将其复制到以a21和i110为角的矩形内。

**如果你的行列式是j乘j的，它应该神奇地出现在第a列和第10j+1行的框中。**

**不仅如此，**

如果你将**j乘j矩阵扩展到其后复制了前j-1行，然后将前j-1列复制到其右边**，以b列和第9j+2行为左上角的j乘j框将是**当j为奇数时的余子式矩阵**，**当j为偶数时的交替符号反转的余子式矩阵。**

**这真的有效吗？**

如果你的矩阵足够丑陋，它就会奏效。也就是说，如果它没有任何0的条目，并且你在形成答案时所除的相关子行列式都不为0，那么它就会奏效。但是如果你在形成答案时除以0，它就会失败。

**这会发生吗？**

对于一个三乘三矩阵M，只有当中间元素m[22]为0时才会发生。

如果你已经将它的前两行复制到右边，它将只在所有三次尝试中失败（你将在a31、b31和c31中得到潜在答案），只有当中间行完全由零组成时，行列式才为0。

对于一个四乘四的矩阵，如果中间元素m[22]、m[23]、m[32]、m[33]中的任何一个为0，或者它们的行列式为0，则会失败；等等。

**我们能使它真正起作用吗？**

是的！但这需要做一些事情，这并不那么巧妙。

**做什么？**

我不确定该做什么是最好的。通常有效的一件事是用非常小的东西替换矩阵的零（以及在子行列式中出现的任何后续的0），然后你可以让那个非常小的东西趋向于0。

例如，你可以在b1中放入一个像10^(-8)这样的微小数，保持一个行索引j和列索引k，并将$ b$1*(j+k+1)添加到原始矩阵中。有了运气，这将消除所有的零，一切都应该正常工作。

当然，你的答案会略有偏差。然后你可以四舍五入你的答案或者改变b1中的内容来找出答案（你可能想到更好的办法）。

上面的建议会消除你原始矩阵中的0，但其他0可能会出现在子行列式中，尽管这种情况应该很少发生。如果你担心这一点，你应该用以下基本指令替换

**=if( a11*b12=a12*b11, $b$1, (a11*b12-a12*b11)/b2))**

你的朋友们都不会相信你能如此整洁地评估行列式，如果你激励他们输入尽可能丑陋的矩阵，他们也不会发现除以0的缺陷。然后它就不会有让人讨厌的零来除。

另一方面，你有能力通过创建一个方法将要除以0的矩阵来使朴素的算法失败。

**练习B.3 设置这个并让它起作用，并使用它得到一个4乘4矩阵的余子式矩阵。**

**如果你只想评估3乘3的矩阵和叉乘，那么设置就简单得多。**

**就是这样**

步骤1

在b1、b2、c1、c2、d1、d2、e1、e2中输入1（可以通过在b1中输入1然后复制到其余部分来完成）。

步骤2

**在a3 a4 a5, b3 b4 b5 和 c3 c4 c5中输入你的矩阵**，或者在a3 b3 c3 和 a4 b4 c4中输入你想要进行叉乘的两个向量（第5行可以是任意内容）。

步骤3

**在d3中输入 =a3**，然后将其复制到d3、d4、e3 和 e4。

步骤4

**在a6中输入 = (a3*b4-a4*b3)/b1**，然后将其复制到a6 到 d6、a7 到 d7、a8 到 d8、a9 到 d9。

**叉乘结果将出现在b6、c6 和 d6中。**

并且在a9、b9 和 c9中的一个或全部中计算行列式。

如果没有数字出现，则行列式为0。

顺便说一句，**如果行列式为0**，那么(b7, c7, d7) 和 (b6, c6, d6)如果不全为零，则是你的矩阵的**列特征向量**，对应的**特征值**为0。

如果你需要计算叉乘或行列式，用这种方法检查答案是一个很好的主意。
