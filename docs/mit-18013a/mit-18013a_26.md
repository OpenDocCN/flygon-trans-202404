# 第25章：数值积分

## 介绍

我们可以很容易地设置一个电子表格来评估给定积分f在从a到b的大量点，并形成黎曼和。一个对称的做法是“梯形法则”，它通过在给定区间的两端具有相同高度的梯形的面积来近似条带中的面积。我们探讨了这个规则和更准确的外推。其中一个被称为辛普森法则。

## 主题

25.1  [梯形法则](section01.html)

25.2  [辛普森法则](section02.html)

25.3  [外推和更好的逼近](section03.html)

25.4  [线积分的数值评估](section04.html)

25.5  [在电子表格上执行通量（表面）积分](section05.html)

## 25.1 梯形法则

我们面临的问题是在有限区间[a, b]内找到**由方程y = f(x)描述的曲线与x轴之间的面积。**

我们采用了定义积分的方法。当f在区间内连续时，我们将其分成N个子区间，每个宽度为![](../Images/4f5e0b41767718ffa879967219fe65b6.jpg)，我们将其称为d，（我们假设b > a），并评估f在每个区间的端点，从a + jd到N为止。

**当f只有分段连续时，您应该先将区间分成f连续的子区间，然后按照我们在每个区间中讨论的方式继续。**

**梯形法则**包括将每个子区间的面积近似为其宽度d乘以其端点处f值的平均值。对于第j个区间，这是

![](../Images/6648654172847e6ea1270787aa215e61.jpg)

**现在我们来回答这个问题：为什么要这样做？**

**是否比起选择一个随机点x'在第j个区间中计算d * f(x')作为该区间对面积的贡献来说，使用这个梯形法则更好？**

要对这个问题得到部分答案，请考虑**一个宽度为d、中心在x[j]处的区间**，为了方便起见，我们将x[j]设为0。

然后区间开始于![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)，并在![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)结束。

现在假设我们可以在x周围用幂级数展开我们的被积函数f，结果是

f(x) = f(0) + ax + bx² + cx³ + ex⁴ + ...

在这个区间内这个函数的实际面积将是

![](../Images/f9151ce4cb269d9a2f8183a488f19fc6.jpg)

（这里的因子![](../Images/5b814ed740e82e673036174062ff3be2.jpg)的产生如下：端点![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)和![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)各有相同的贡献，每个为![](../Images/e5ba4c26d7cbeaf2bf5f2468145e60f6.jpg)。）

因子![](../Images/e3e9eee02c13276a499f8bf4cdff843d.jpg)的产生方式类似。**请注意，在这里ax和其他奇数次幂项在这里根本不贡献，因为它们是奇数的，它们的贡献会相互抵消。）**

**我们描述的梯形法则提供了对于这个区域的以下建议答案**

**![](../Images/88abfe0f331102022e506bdd6597bedb.jpg)**

**f(0)的贡献完全正确，b的贡献是三倍于此，而e的贡献是五倍于此。**

**请注意，这里任何关于0对称的估计都将准确得到奇数（a、c等）项。**

特别地，我们可以使用**"中点法"**，它将面积近似为f(0)d，这样就能准确获得a、c等贡献，但完全得不到b、e等项的贡献。

导致a和c项相互抵消的对称性是梯形法在此处拥有的巨大优势，它与中点法共享此优势。

**考虑一下，如果我们将d减小一半**（或任何其他因子z）。由于这种对称性，**梯形法或中点法中的误差会在每个区间中减少8倍，但现在有两个区间，而不是一个。**

因此，必须**加倍此错误以便在原始区间上进行比较**，而且**梯形法或中点法中的实际误差在任何一个来自b项的区间中会减少四分之一，甚至在e和其他项中会减少更多。**

**练习：**

**25.1 设置一个电子表格，将给定区间a到b分成N个等分区间，评估给定函数，比如sin x，在每个N + 1个区间端点，并计算结果积分的梯形法评估。**

**25.2 制作一个具有同时计算N = 1、2、4、8、16和32的能力的电子表格。（您可以通过从32开始并输入指令=if(mod(j,2^k)=0,2*prev column entry,0)来将它们放在一起，其中j是子区间端点的索引，k是列索引。每增加1次k，梯形区间的数量就会减少一半。）**

## 25.2 辛普森法则

在上一节的符号表示中，函数f在介于![](../Images/96977f1b442ba74f610c02b37c7444cb.jpg)和![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg)之间的实际面积将是

![](../Images/46d24ee2f1f51a82a25641688c627ddb.jpg)

另一方面，我们描述的梯形法则对于这个区域提供了以下建议答案

![](../Images/feefa1f2cab42840444bd64e0c87a9ac.jpg)

而"中点法"将面积近似为f(0)d。

这意味着**如果我们将中点法的两部分与梯形法的一部分混合在一起，我们将完全正确地得到二次b项**，而误差的主导项将来自e项，其量级将为d⁴。

**刚才描述的积分近似法则称为辛普森法则，在介于![](../Images/b9c249e945dc0581feee41673a53efff.jpg)和![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg)之间的区间中采用以下形式**

![](../Images/82d8946f8b4bfdd190c0d18427130604.jpg)

**请注意，在这个公式中，f 在间隔为 ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg) 的位置进行评估**。如果我们在这里给参数 ![](../Images/83b6a7e501910fa3dd5b509eb2d120be.jpg) 一个新名称，称之为 h，那么辛普森法则的公式变为

![](../Images/8f193f222b265837f197ed6e1aed3ef7.jpg)

它代表了对由 f 在从 -h 到 h 的区间内定义的曲线下面积的逼近；一个其误差与 h 的四次方成正比的逼近。

值得注意的是，当应用于一系列小子间隔时，这些各种规则的外观是什么样子的。

梯形法则给予所有中间点的评估相等的权重 d，因为每个点都是一个子间隔的左端点和右端点，它**从每个端点获得 ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg) 的权重。**

另一方面，最后两个评估只是一个子间隔的末端，**这些获得权重为 ![](../Images/11fc42ad43ed4c77081363430fd2716a.jpg)。**

中点法则给予奇数次评估 d 或 2h 相等的权重。

**辛普森法则给出的权重形成模式 1 4 2 4 2 ... 4 1 乘以 ![](../Images/aed297b225b0463bf3774b5df7565b91.jpg)，因为中点获得权重 ![](../Images/49e792c28a53f3732fb9053c86698bc7.jpg)，而梯形法则除以 3 解释了其余部分。**

|  | 端点a | 第一个间隔的中点a + h | 第一个间隔的末端a + 2h | 第二个间隔的中点a + 3h | 第二个间隔的末端a + 4h | 等。 |
| --- | --- | --- | --- | --- | --- | --- |
| 梯形法则项 | hf(a) | 0 | 2hf(a + 2h) | 0 | 2hf(a + 4h) | 等。 |
| 中点法则项 | 0 | 2hf(a + h) | 0 | 2hf(a + 3h) | 0 | 等。 |
| 辛普森法则项 | ![](../Images/4082a090b51e10b925a3d3896a92c83e.jpg) | ![](../Images/891358600490512a6a809d0ee14ec4d8.jpg) | ![](../Images/818cf85ac94e6b33825d80a7e0fed1f9.jpg) | ![](../Images/5a98c1d838f19c240545a5fbe3788bce.jpg) | ![](https://ocw.mit.edu/ans7870/18/18.013a/textbook/HTML/chapter25/equations/sections_eqn22.gif) | 等。 |

注意，在为 f 生成辛普森法则中产生误差的幂级数中，主导项是 ex⁴ 项，**如果我们将间隔减半，这将导致误差减少 16 倍。**

<applet code="NumericalIntegration" codebase="../applets/" archive="numericalIntegration.jar,mk_lib.jar,parser_math.jar,jcbwt363.jar" width="760" height="450"></applet>

## 25.3 外推和更好的逼近

我们在讨论数值微分时看到，当我们有一系列数字，这些数字是对一个数字 A 的逼近，**其误差从项到项按给定因子 r 减少时，我们可以外推这个序列，以获得一个更快收敛的序列。**

一般的外推规则是：**为了消除按因子 z 减少的误差，将当前结果乘以 z 减去前一个结果，然后将此差异除以 z - 1。**

例如，如果我们查看梯形法则提供的答案，对于值16d、8d、4d、2d、d，我们得到一个近似答案序列，其误差可以预期每次减少大约4倍。如果我们将这些答案表示为![](../Images/e08122572eec913bfccd5015394f7d24.jpg)，并查看序列![](../Images/ebd8418ce531aeefec773ee80fea5c02.jpg)，（对于 j = 2 到 5），那么在每个 B 中下降为 4 倍的 A 项将在每个 B 中抵消掉，我们只会留下更高阶的项。

如果我们在这里将这个过程应用于梯形法则，我们得到了先前定义的辛普森法则近似。

**练习 25.3** **验证这个说法。**

但我们知道辛普森法则中领先的项每次减少16倍，我们可以用同样的方法来玩它们。

我们可以形成![](../Images/0b0d3341080eeec5116b7b5b7989ade6.jpg)，由![](../Images/1acae4732e6866813275d4e027298de9.jpg)定义，对于j = 3到5，并得到一个“超级辛普森法则近似”，其中（在幂级数展开中）领先的项每次减少64。

我们可以再继续这样做两次：得到对于j = 4和5的![](../Images/cd5a0d718bac703f1813aa6ba5f8960f.jpg)，以及![](../Images/89983ffa875559ed30822e5928ca5d57.jpg)，这大约是我们用16个区间进行近似的最好的结果。

**练习：**

**25.4 使用练习 25.2 的结果来计算 A 到 E。在你知道值的积分上比较它们的准确性。（例如 sin x 从 x = 0 到 1。）**

请注意，虽然这些方法非常好，但在sin x上特别有效。**

**25.5 你能找到一个这种积分方法很糟糕的函数吗？你可以怎么改进它？**

## 25.4 线积分的数值评估

假设我们面对一条线积分，这是沿着欧几里得空间中某条路径的积分，其中向量场**v**为![](../Images/942a415c6b0fa1fa8b2f7d2d2c8c225a.jpg)**ds**。

![](../Images/61f9cc97bb28e966f6fe6341b3c2bc02.jpg)

我们可以设置一个电子表格来评估这样的积分，而几乎没有困难。

在本节中，我们描述了如何实现这一点，并试图怂恿你自己在电子表格上做一些类似的事情。

顺便说一句，一旦你拥有这样的东西，你就可以用极少的努力修改路径、被积函数或者网格大小，因此可以使用你的产品来评估你所遇到的任何线积分。

线积分与普通积分相比更复杂，主要是因为你不仅需要处理被积函数，还需要处理路径，而对于普通的被积函数，路径是实线的一个区间，由其两个端点完全确定，你只需要处理被积函数。

我们所做的取决于积分的路径 C 如何定义。

最简单的情况，我们在这里解决的是当我们把 C 给出作为一个**参数曲线**时发生的情况。 

这意味着我们有一个参数，让我们称之为 t，并且对于每个坐标 x、y、z 等，我们有 t 的函数形式，并且 t 值的区间定义了曲线。

我们的计划是将 t 区间分成许多小片段，并在这些片段的边界处计算 x(t)、y(t)、z(t) 和 v[x](x(t), y(t), ...)、v[y](x(t), y(t), ...)、...。

换句话说，我们将为 x、y 和 z（在三维空间中）的每个计算分配一列；并且为矢量场 **v** 在点 (x(t), y(t), z(t)) 处的每个分量进行计算。然后，我们使用一列来描述来自一个子区间（比如 t 到 t + d 之间）的积分贡献。

**我们用什么来估计这个贡献？**

t 是 x(t) 在该区间内的变化乘以该区间端点上 v[x] 的平均值，再加上 y 和 z 上相同的情况。我们只在这里写下 x 的贡献，即

![](../Images/a153ad247f43744e8c9e8488ec629302.jpg)

在最后一列，我们将这些贡献加起来，覆盖各个区间，这就是我们的积分。这是线积分的梯形法则。

**一旦完成了这个步骤，我们如何改变路径？** 修改 x(t)、y(t) 和 z(t) 列，以使用不同的 t 函数。

**我们如何改变被积函数 v？** 改变它的列。

**我们如何改变区间大小参数 d？** 只需改变它。

**我们究竟要如何做到这一点？**

我喜欢把前五行留给注释和数据输入。

在 B2 中，我会放入起始 t 值，在 B3 中放入 d 的值。

在顶行，我会给出对曲线和矢量场的文字描述。

所以我会从第 6 行开始计算。

这里是我会放在 t 列（A 列）的内容。

A6=B2

A7=A6+B3

A8=2*A7-A6

并且我会把 A8 复制到 A9-A1005（或者更远，如果你愿意）。

在 x、y 和 z 列中放入

B6=x(A6)（当然，你必须放入这个函数是什么）

C6= y(A6)

D6=z(A6)

并将这些复制到 B7-B1005，等等。

在 **v** 列中，放入 **v** 的各个分量的值

E6=v[x](B6,C6,D6)

F6=v[y](B6,C6,D6)

G6=v[z](B6,C6,D6)

并将其复制下去。

接下来设置

H6=(B7-B6)*(E(7)+E(6))/2

并将其复制到 I6 和 J6 的位置，并向下延伸。

设置

K6=H6+I6+J6

并且

L7=L6+K6

并将这些复制下去，**你就完成了**。

如果最终的 t 值出现在 Ak，则积分答案将在 Lk 中。

你可以调整 d，并且可以像普通积分一样进行外推。

这里使用的方法是梯形法则的路径积分版本。

通过一点诡计，你可以推断出这一点积分版本的辛普森法则，并且也可以推断出它。

你可以通过对一个 d 值、2d 值和 4d 值进行积分来检查准确性（确保适当调整端点，以检查准确性）。

在没有外推的情况下，当你将d减小一半时，答案的差异应该减少4倍；用细分的结果的![](../Images/31ae4dcbda598a1ae3e4f53057763b4a.jpg) 减去较粗糙的结果的![](../Images/a5ac7d89e8de036eb98a1a6e004b07a3.jpg) 或较粗糙的结果应该会改善到Simpson的结果。

依此类推。

## 25.5 在电子表格上进行通量（表面）积分

当表面S以参数形式描述时，也就是说，给定函数x(s, t)，y(s, t)和z(s, t)，以及s和t的值域，你可以使用电子表格来计算任何可定义在电子表格上的向量函数**w**（即与表面法线的点积）的通量积分。

你可以利用电子表格的能力，在二维的大范围位置复制单个指令，行和列。

假设你想要先对s进行积分，然后再对t进行积分，你将从t[1]到t[2]进行积分，并从s[1](t)到s[2](t)进行积分。假设你想将每个范围分成N，N = 100个片段。

这个计划如下：你设置s值、t值的数组，然后是x、y和z值，然后是w[x]、w[y]和w[z]值的数组，最后是一个积分的数组；这些数组中的每一个都将是N + 1乘以N + 1的大小，但最多只需要构造3或4个条目。其余的都是复制。

设置一个t值的数组，将t[1]分配给第一列中使用的第一行，然后在其下一行中将(previous + (t[2] - t[1]) / N)，以及在(previous to previous)之下的(2 * previous - (previous to previous))。将其复制到接下来的98行。然后将下一列的条目设置为“=左侧条目”，将其复制到接下来的98列和行。

这应该在每一行中给出一个单一的恒定t值，但在每一列中给出不同的值。

接下来设置两列来计算每个t值的s[1](t)和s[2](t)。

通过在第一列中放置=s[1]、第一行中的s[1] + (s[2](t[0]) - s[1](t[0])) / N（在N上使用美元符号）以及下一列中的(2 * 左侧 - 左侧左侧)来设置一个s值的数组。

然后将这个复制到98行，并将第三列复制到98行。

再次设置相同大小的x、y、z和w[x]、w[y]和w[z]数组，方法是将x(s[0](t[0]), t[0])放在x数组的左上角条目中，并将其复制到整个数组中。其他5个数组也可以类似地完成。

要计算积分，你可以将每个“区间对”ds和dt的贡献相加，即

w[x] * (dy[s]dz[t] - dy[t]dz[s]) + w[y] * (dz[s]dx[t] - dz[t]dx[s]) + w[z] * (dx[s]dy[t] - dx[t]dy[s])

要再次计算每个2x2矩形中的积分，你只需要计算顶部左侧的一个，然后再次复制到一个100乘100的数组中。

这可以一次完成或每个项都完成一次。积分将是整个数组上的这些的总和。

对于一对区间，你需要做什么来获得w[x]或dy[s]或dz[t]？

假设区间的角落是（s，t），（s + d，t），（s，t + d'）和（s + d，t + d'）。

然后，二维中梯形法则的类比给出

![](../Images/d696f80f2d6ce3a78987628d749c738c.jpg)

尽管创建这个最后一个数组很混乱，但实际上只需要在一个正方形中完成并复制，而且只需要完成一次，并且可以在其他数组具有相同起始点的情况下重复使用。

请注意，要更改s和t的域，只需更改前两个数组；要更改参数化，只需更改x、y和z数组，要更改计算其通量积分的向量**w**，只需更改其三个数组。

通过对最后一个数组进行不同的求和，可以获得对表面子集的积分。

这里是一个例子

t[1] =1，t[2] = 2，s[1] = t²，s[2] = t³，

![](../Images/56c616fd7da8005f030f20f69b69c6d6.jpg)

![](../Images/b3090b8b16d274171ecb7ff72c700a6f.jpg)

请注意，更改t[1]、t[2]、s[1]、s[2]、x、y、z、w[x]、w[y]或w[z]每次只需要更改一个条目，然后将其复制到整个相应的数组中。（或在适当的地方。对于t[1]和t[2]，您无需复制任何内容，对于s[1]和s[2]，那是一列。）

很容易推断这些结果：您可以将N更改为50，并对最后一个数组的左上角进行求和，将N更改为25，并对该数组的左上角进行求和。

此积分的结果为N = 100时为132.2450414，N = 50时为132.1941481，N = 25时为131.9909671。

在50和100之间，这些之间的差异大约是25和50之间的4倍。将更好的乘以![](../Images/31ae4dcbda598a1ae3e4f53057763b4a.jpg)，减去更差的乘以![](../Images/a5ac7d89e8de036eb98a1a6e004b07a3.jpg)得到132.262006和132.261875。假设剩余误差按16的倍数下降，给出132.2620145的估计，这可能准确到6位小数。

这可以通过扩大数组并尝试N = 200来验证，这只需要复制，并形成一个新的总和。

**练习：**

**25.6 创建刚才描述的电子表格，并验证或证伪上述说法。**

**25.7 您能得到描述的积分的最佳估计是什么？**

**25.8 将s和t更改为从0到![](../Images/0e42b2bc5fad4aa5017f2e8e7fd0d0e4.jpg)和2![](../Images/0e42b2bc5fad4aa5017f2e8e7fd0d0e4.jpg)，使x、y和z等于球坐标中的值，并让w为向量（x，y，0）。通过这种方法找到积分的合理精度。**
